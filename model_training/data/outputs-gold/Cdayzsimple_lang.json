	0
	0
from typing import List , Dict [EOL] import interpreter [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import NewType , List , Dict [EOL] [EOL] from interpreter . src . parser . operation import OperationType [EOL] [EOL] [EOL] Keyword = NewType ( [string] , str ) [EOL] Register = NewType ( [string] , str ) [EOL] [EOL] [EOL] LANGUAGE_OPTYPES = { Keyword ( [string] ) : OperationType . Binary , Keyword ( [string] ) : OperationType . Binary , Keyword ( [string] ) : OperationType . Binary , Keyword ( [string] ) : OperationType . Binary , Keyword ( [string] ) : OperationType . Binary , Keyword ( [string] ) : OperationType . Binary , Keyword ( [string] ) : OperationType . Binary , Keyword ( [string] ) : OperationType . Unary , Keyword ( [string] ) : OperationType . Binary , Keyword ( [string] ) : OperationType . Binary , Keyword ( [string] ) : OperationType . Unary , Keyword ( [string] ) : OperationType . Unary , Keyword ( [string] ) : OperationType . Unary , Keyword ( [string] ) : OperationType . Unary , Keyword ( [string] ) : OperationType . Unary , Keyword ( [string] ) : OperationType . Unary , Keyword ( [string] ) : OperationType . Unary , Keyword ( [string] ) : OperationType . Unary , Keyword ( [string] ) : OperationType . Nop , Keyword ( [string] ) : OperationType . Nop , Keyword ( [string] ) : OperationType . Unary , Keyword ( [string] ) : OperationType . Nop , } [EOL] [EOL] [EOL] LANGUAGE_KEYWORDS = list ( LANGUAGE_OPTYPES . keys ( ) ) [EOL] [EOL] [EOL] LANGUAGE_REGISTERS = [ Register ( [string] ) , Register ( [string] ) , Register ( [string] ) , Register ( [string] ) , Register ( [string] ) , Register ( [string] ) , Register ( [string] ) , Register ( [string] ) , Register ( [string] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[Keyword,interpreter.src.parser.operation.OperationType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Keyword]$ 0 0 0 $typing.Dict[Keyword,interpreter.src.parser.operation.OperationType]$ 0 0 0 0 0 0 0 0 $typing.List[Register]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[docstring] [EOL] [EOL] [EOL] class BadOperationIdentifier ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class BadOperationArgument ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class BadInPlaceValue ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ParsingError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , line_index , line , exception ) : [EOL] self . line_index = line_index [EOL] self . line_code = line [EOL] self . exception = exception [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import enum [EOL] import typing [EOL] import dataclasses [EOL] [EOL] [EOL] class OperationType ( enum . Enum ) : [EOL] [docstring] [EOL] [EOL] Nop = [number] [EOL] Unary = [number] [EOL] Binary = [number] [EOL] [EOL] [EOL] class OperationArgumentType ( enum . Enum ) : [EOL] [docstring] [EOL] [EOL] Nop = [number] [EOL] Label = [number] [EOL] Register = [number] [EOL] RegisterPointer = [number] [EOL] InPlaceValue = [number] [EOL] [EOL] [EOL] @ dataclasses . dataclass class OperationArgument : [EOL] [docstring] [EOL] [EOL] arg_type = ... [EOL] arg_word = ... [EOL] [EOL] [EOL] @ dataclasses . dataclass class Operation : [EOL] [docstring] [EOL] [EOL] op_type = ... [EOL] op_word = ... [EOL] op_args = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $OperationArgumentType$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $OperationType$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[OperationArgument]$ 0 0 0
	0
	0
import interpreter [EOL] from interpreter . src . parser . errors import ParsingError [EOL] [EOL] [EOL] def test_parsing_error ( ) : [EOL] exc = Exception ( [string] ) [EOL] parse_error = ParsingError ( [number] , [string] , exc ) [EOL] [EOL] assert parse_error . exception is exc [EOL] assert parse_error . line_code == [string] [EOL] assert parse_error . line_index == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import interpreter [EOL] import typing [EOL] import io [EOL] [docstring] [EOL] [EOL] import io [EOL] import typing [EOL] import struct [EOL] import itertools [EOL] [EOL] from interpreter . src . parser . operation import Operation [EOL] [EOL] from interpreter . src . virtual_machine . bytecode import BYTECODES , Keyword [EOL] from interpreter . src . virtual_machine . errors import BadOperationSize [EOL] [EOL] OP_SIZE = [number] [EOL] MAG_NUM = [number] [EOL] [EOL] [EOL] class BytecodeCompiler : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file_crc ) : [EOL] [docstring] [EOL] self . file_crc = file_crc [EOL] [EOL] def compile ( self , code ) : [EOL] [docstring] [EOL] bytecode_buffer = io . BytesIO ( ) [EOL] [EOL] metadata = self . generate_metadata ( self . file_crc ) [EOL] [EOL] bytecode_buffer . write ( metadata ) [EOL] [EOL] for operation in code : [EOL] try : [EOL] encoded_operation = self . encode_operation ( operation ) [EOL] except KeyError : [EOL] raise Exception ( [string] ) [EOL] except struct . error : [EOL] raise BadOperationSize ( [string] ) [EOL] [EOL] bytecode_buffer . write ( encoded_operation ) [EOL] [EOL] bytecode_buffer . seek ( [number] ) [EOL] [EOL] return bytecode_buffer [EOL] [EOL] def generate_metadata ( self , file_crc ) : [EOL] [docstring] [EOL] return struct . pack ( [string] , MAG_NUM , file_crc ) [EOL] [EOL] def encode_operation ( self , operation ) : [EOL] [docstring] [EOL] op_word = operation . op_word [EOL] [EOL] op_code = BYTECODES [ Keyword ( op_word ) ] [EOL] [EOL] arguments = list ( itertools . chain ( * [ ( arg . arg_type . value , arg . arg_word ) for arg in operation . op_args ] ) ) [EOL] [EOL] operation_code = struct . pack ( [string] , op_code , * arguments ) [EOL] [EOL] return operation_code [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $io.BytesIO$ 0 0 0 $typing.List[interpreter.src.parser.operation.Operation]$ 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.List[interpreter.src.parser.operation.Operation]$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 $builtins.bytes$ 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 $interpreter.src.parser.operation.Operation$ 0 0 0 0 0 $builtins.str$ 0 $interpreter.src.parser.operation.Operation$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $interpreter.src.parser.operation.Operation$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.bytes$ 0
[docstring] [EOL] [EOL] [EOL] class BadOperationSize ( Exception ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import builtins [EOL] import interpreter [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import Dict [EOL] [EOL] from interpreter . src . lexer . keywords import Keyword , LANGUAGE_OPTYPES [EOL] [EOL] [EOL] BYTECODES = { keyword : code for code , keyword in enumerate ( LANGUAGE_OPTYPES . keys ( ) ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[interpreter.src.lexer.keywords.Keyword,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import interpreter [EOL] import typing [EOL] import io [EOL] [docstring] [EOL] [EOL] import io [EOL] import struct [EOL] [EOL] from interpreter . src . virtual_machine . vm . vm_def import VmState [EOL] [EOL] from interpreter . src . virtual_machine . vm import VM_BYTECODE_FUNC , VM_LABEL_FUNC [EOL] [EOL] [EOL] def initialize_vm ( bytecode ) : [EOL] [docstring] [EOL] code_size = len ( bytecode . read1 ( ) ) [EOL] [EOL] vm_state = VmState ( vm_code_buffer = bytecode ) [EOL] [EOL] [comment] [EOL] [EOL] while vm_state . vm_code_pointer < code_size : [EOL] vm_state . vm_code_buffer . seek ( vm_state . vm_code_pointer ) [EOL] [EOL] bcode = vm_state . vm_code_buffer . read1 ( [number] ) [EOL] opcode = struct . unpack ( [string] , bcode ) [ [number] ] [EOL] [EOL] vm_state . vm_code_buffer . seek ( vm_state . vm_code_pointer ) [EOL] [EOL] vm_state = VM_LABEL_FUNC [ opcode ] ( vm_state ) [EOL] [EOL] vm_state . vm_code_pointer = [number] [EOL] vm_state . vm_code_buffer . seek ( [number] ) [EOL] [EOL] return vm_state [EOL] [EOL] [EOL] def execute_bytecode ( bytecode ) : [EOL] [docstring] [EOL] code_size = len ( bytecode . read ( ) ) [EOL] bytecode . seek ( [number] ) [EOL] vm_state = initialize_vm ( bytecode ) [EOL] [EOL] while vm_state . vm_code_pointer < code_size : [EOL] vm_state . vm_code_buffer . seek ( vm_state . vm_code_pointer ) [EOL] bcode = vm_state . vm_code_buffer . read1 ( [number] ) [EOL] opcode = struct . unpack ( [string] , bcode ) [ [number] ] [EOL] [EOL] vm_state . vm_code_buffer . seek ( vm_state . vm_code_pointer ) [EOL] [EOL] vm_state = VM_BYTECODE_FUNC [ opcode ] ( vm_state ) [EOL] [EOL] return vm_state [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $interpreter.src.virtual_machine.vm.vm_def.VmState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $interpreter.src.virtual_machine.vm.vm_def.VmState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable [EOL] import builtins [EOL] import interpreter [EOL] import typing [EOL] [docstring] [EOL] [EOL] import typing [EOL] [EOL] from interpreter . src . virtual_machine . vm . vm_def import ( VmState , VM_OPERATION_TO_BYTECODE ) [EOL] from interpreter . src . virtual_machine . vm . helpers import vm_operation [EOL] [EOL] [EOL] def generate_jump ( jmp_name , cond ) : [EOL] [docstring] [EOL] @ vm_operation def gen ( vm_state , * args , op_bytecode = None , ** kwargs ) : [EOL] op_code , _ , arg1 , _ , _ = op_bytecode [EOL] [EOL] assert VM_OPERATION_TO_BYTECODE [ op_code ] == jmp_name [EOL] [EOL] label_index = arg1 [EOL] [EOL] if label_index not in vm_state . vm_labels : [EOL] raise Exception ( f" [string] { label_index }" ) [EOL] [EOL] if cond ( vm_state ) : [EOL] vm_state . vm_code_pointer = vm_state . vm_labels [ label_index ] [EOL] [EOL] return vm_state [EOL] [EOL] [comment] [EOL] gen . __name__ = f" [string] { jmp_name . lower ( ) }" [EOL] [EOL] return gen [EOL] [EOL] [EOL] [comment] [EOL] vm_jmp = generate_jump ( [string] , lambda _ : True ) [EOL] vm_jump_eq = generate_jump ( [string] , lambda state : state . vm_registers [ [number] ] . value ) [EOL] vm_jump_lt = generate_jump ( [string] , lambda state : state . vm_registers [ [number] ] . value ) [EOL] vm_jump_gt = generate_jump ( [string] , lambda state : state . vm_registers [ [number] ] . value ) [EOL] vm_jump_ne = generate_jump ( [string] , lambda state : state . vm_registers [ [number] ] . value ) [EOL] [EOL] [EOL] def set_called_subroutine ( state ) : [EOL] [docstring] [EOL] state . vm_call_stack . append ( state . vm_code_pointer ) [EOL] [EOL] return True [EOL] [EOL] [EOL] vm_call = generate_jump ( [string] , set_called_subroutine ) [EOL] [EOL] [EOL] @ vm_operation def vm_ret ( vm_state , * args , op_bytecode = None , ** kwargs ) : [EOL] op_code , _ , _ , _ , _ = op_bytecode [EOL] [EOL] assert VM_OPERATION_TO_BYTECODE [ op_code ] == [string] [EOL] [EOL] try : [EOL] previuous_routine = vm_state . vm_call_stack . pop ( ) [EOL] except IndexError : [EOL] raise Exception ( [string] ) [EOL] [EOL] vm_state . vm_code_pointer = previuous_routine [EOL] [EOL] return vm_state [EOL] [EOL] [EOL] @ vm_operation def vm_label ( vm_state , * args , op_bytecode = None , ** kwargs ) : [EOL] [docstring] [EOL] op_code , _ , arg1 , _ , _ = op_bytecode [EOL] [EOL] assert VM_OPERATION_TO_BYTECODE [ op_code ] == [string] [EOL] [EOL] label_index = arg1 [EOL] label_position = vm_state . vm_code_pointer [EOL] [EOL] if label_index not in vm_state . vm_labels : [EOL] vm_state . vm_labels [ label_index ] = label_position [EOL] [EOL] return vm_state [EOL] [EOL] [EOL] @ vm_operation def vm_cmp ( vm_state , * args , op_bytecode = None , ** kwargs ) : [EOL] [docstring] [EOL] op_code , arg1_type , arg1 , arg2_type , arg2 = op_bytecode [EOL] [EOL] assert VM_OPERATION_TO_BYTECODE [ op_code ] == [string] [EOL] [EOL] if arg2_type == [number] : [comment] [EOL] right_value = vm_state . vm_registers [ arg2 ] . value [EOL] [EOL] elif arg2_type == [number] : [comment] [EOL] input_value_addr = vm_state . vm_registers [ arg2 ] . value [EOL] right_value = vm_state . vm_memory [ input_value_addr ] [EOL] [EOL] elif arg2_type == [number] : [comment] [EOL] right_value = arg2 [EOL] [EOL] else : [EOL] raise Exception ( f" [string] " ) [EOL] [EOL] if arg1_type == [number] : [comment] [EOL] left_value = vm_state . vm_registers [ arg1 ] . value [EOL] [EOL] elif arg1_type == [number] : [comment] [EOL] mem_index = vm_state . vm_registers [ arg1 ] . value [EOL] left_value = vm_state . vm_memory [ mem_index ] [EOL] [EOL] elif arg1_type == [number] : [comment] [EOL] left_value = arg1 [EOL] [EOL] else : [EOL] raise Exception ( f" [string] " ) [EOL] [EOL] if left_value > right_value : [EOL] vm_state . vm_registers [ [number] ] . value = True [EOL] vm_state . vm_registers [ [number] ] . value = True [EOL] elif left_value < right_value : [EOL] vm_state . vm_registers [ [number] ] . value = True [EOL] vm_state . vm_registers [ [number] ] . value = True [EOL] elif left_value == right_value : [EOL] vm_state . vm_registers [ [number] ] . value = True [EOL] vm_state . vm_registers [ [number] ] . value = False [EOL] vm_state . vm_registers [ [number] ] . value = False [EOL] vm_state . vm_registers [ [number] ] . value = False [EOL] [EOL] return vm_state [EOL] [EOL] [EOL] @ vm_operation def vm_nop ( vm_state , * args , op_bytecode = None , ** kwargs ) : [EOL] [docstring] [EOL] op_code , _ , _ , _ , _ = op_bytecode [EOL] [EOL] [comment] [EOL] [EOL] return vm_state [EOL] [EOL] [EOL] @ vm_operation def vm_end ( vm_state , * args , op_bytecode = None , ** kwargs ) : [EOL] [docstring] [EOL] op_code , _ , _ , _ , _ = op_bytecode [EOL] [EOL] assert VM_OPERATION_TO_BYTECODE [ op_code ] == [string] [EOL] [EOL] last_code_addr = vm_state . vm_code_pointer [EOL] [EOL] end_pointer = len ( vm_state . vm_code_buffer . read1 ( ) ) [EOL] [EOL] vm_state . vm_code_pointer = last_code_addr + end_pointer [EOL] [EOL] return vm_state [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $interpreter.src.virtual_machine.vm.vm_def.VmState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Callable [EOL] import interpreter [EOL] import typing [EOL] [docstring] [EOL] [EOL] import copy [EOL] import typing [EOL] import struct [EOL] import functools [EOL] [EOL] from interpreter . src . virtual_machine . vm . vm_def import VmState [EOL] [EOL] [EOL] def vm_operation ( func ) : [EOL] [docstring] [EOL] @ functools . wraps ( func ) def wrapper ( vm_state , * args , ** kwargs ) : [EOL] new_state = copy . deepcopy ( vm_state ) [EOL] operation_bytecode = struct . unpack ( [string] , new_state . vm_code_buffer . read1 ( [number] ) ) [EOL] [EOL] kwargs [ [string] ] = operation_bytecode [EOL] [EOL] new_state = func ( new_state , * args , ** kwargs ) [EOL] [EOL] new_state . vm_code_pointer += [number] [EOL] [EOL] return new_state [EOL] [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Dict [EOL] import typing [EOL] from interpreter . src . virtual_machine . vm . binary_ops import ( vm_add , vm_sub , vm_mul , vm_div , vm_and , vm_or , vm_xor , vm_mov , vm_not , ) [EOL] from interpreter . src . virtual_machine . vm . jumps_and_labels import ( vm_end , vm_call , vm_ret , vm_nop , vm_cmp , vm_jmp , vm_label , vm_jump_eq , vm_jump_lt , vm_jump_gt , vm_jump_ne , ) [EOL] from interpreter . src . virtual_machine . vm . io_ops import ( vm_input , vm_print ) [EOL] [EOL] from interpreter . src . virtual_machine . bytecode import BYTECODES [EOL] [EOL] [EOL] FUNCTIONS = ( vm_add , vm_sub , vm_div , vm_mul , vm_and , vm_or , vm_xor , vm_not , vm_mov , vm_cmp , vm_jmp , vm_jump_eq , vm_jump_gt , vm_jump_lt , vm_jump_ne , vm_label , vm_print , vm_input , vm_nop , vm_end , vm_call , vm_ret ) [EOL] [EOL] [EOL] VM_BYTECODE_FUNC = { bytecode : func for bytecode , func in zip ( [ bytecode for _ , bytecode in BYTECODES . items ( ) ] , FUNCTIONS , ) } [EOL] [EOL] [EOL] VM_LABEL_FUNC = { bytecode : vm_nop if func . __name__ != [string] else vm_label for bytecode , func in VM_BYTECODE_FUNC . items ( ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0
from typing import Any [EOL] import interpreter [EOL] import typing [EOL] [docstring] [EOL] [EOL] from interpreter . src . virtual_machine . vm . vm_def import ( VmState , VM_OPERATION_TO_BYTECODE ) [EOL] from interpreter . src . virtual_machine . vm . helpers import vm_operation [EOL] [EOL] [EOL] @ vm_operation def vm_input ( vm_state , * args , op_bytecode = None , ** kwargs ) : [EOL] [docstring] [EOL] op_code , arg1_type , arg1 , _ , _ = op_bytecode [EOL] [EOL] assert VM_OPERATION_TO_BYTECODE [ op_code ] == [string] [EOL] [EOL] while True : [EOL] try : [EOL] input_value = int ( input ( [string] ) ) [EOL] except ValueError : [EOL] continue [EOL] else : [EOL] break [EOL] [EOL] if arg1_type == [number] : [comment] [EOL] vm_state . vm_registers [ arg1 ] . value = input_value [EOL] [EOL] elif arg1_type == [number] : [comment] [EOL] mem_address = vm_state . vm_registers [ arg1 ] . value [EOL] vm_state . vm_memory [ mem_address ] = input_value [EOL] [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] return vm_state [EOL] [EOL] [EOL] @ vm_operation def vm_print ( vm_state , * args , op_bytecode = None , ** kwargs ) : [EOL] [docstring] [EOL] op_code , arg1_type , arg1 , _ , _ = op_bytecode [EOL] [EOL] assert VM_OPERATION_TO_BYTECODE [ op_code ] == [string] [EOL] [EOL] if arg1_type == [number] : [comment] [EOL] value_for_print = vm_state . vm_registers [ arg1 ] . value [EOL] [EOL] elif arg1_type == [number] : [comment] [EOL] mem_address = vm_state . vm_registers [ arg1 ] . value [EOL] value_for_print = vm_state . vm_memory [ mem_address ] [EOL] [EOL] elif arg1_type == [number] : [comment] [EOL] value_for_print = arg1 [EOL] [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] print ( f' [string] { value_for_print }' ) [EOL] [EOL] return vm_state [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $interpreter.src.virtual_machine.vm.vm_def.VmState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $interpreter.src.virtual_machine.vm.vm_def.VmState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict [EOL] import builtins [EOL] import interpreter [EOL] import typing [EOL] [docstring] [EOL] [EOL] import io [EOL] import typing [EOL] import dataclasses [EOL] [EOL] from interpreter . src . lexer . keywords import LANGUAGE_REGISTERS [EOL] from interpreter . src . virtual_machine . bytecode import BYTECODES [EOL] [EOL] [EOL] VM_OPERATION_TO_BYTECODE = { bytecode : operation for operation , bytecode in BYTECODES . items ( ) } [EOL] [EOL] VM_MEM_SIZE = [number] [EOL] [EOL] [EOL] @ dataclasses . dataclass class VmRegister : [EOL] [docstring] [EOL] [EOL] name = ... [EOL] value = ... [EOL] [EOL] [EOL] def get_registers_map ( ) : [EOL] [docstring] [EOL] return { reg_index : VmRegister ( name = name , value = [number] ) for reg_index , name in enumerate ( LANGUAGE_REGISTERS ) } [EOL] [EOL] [EOL] def get_default_memory ( ) : [EOL] [docstring] [EOL] return [ [number] for _ in range ( VM_MEM_SIZE ) ] [EOL] [EOL] [EOL] @ dataclasses . dataclass class VmState : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] vm_code_buffer = ... [EOL] vm_code_pointer = [number] [EOL] [EOL] [comment] [EOL] vm_registers = dataclasses . field ( default_factory = get_registers_map ) [EOL] [EOL] [comment] [EOL] vm_memory = dataclasses . field ( default_factory = get_default_memory ) [EOL] [EOL] [comment] [EOL] vm_labels = dataclasses . field ( default_factory = dict ) [EOL] [EOL] [comment] [EOL] vm_call_stack = dataclasses . field ( default_factory = list ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,interpreter.src.lexer.keywords.Keyword]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.int,VmRegister]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.int,VmRegister]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable [EOL] import builtins [EOL] import interpreter [EOL] import typing [EOL] [docstring] [EOL] [EOL] import typing [EOL] import operator [EOL] [EOL] from interpreter . src . virtual_machine . vm . vm_def import ( VmState , VM_OPERATION_TO_BYTECODE ) [EOL] from interpreter . src . virtual_machine . vm . helpers import vm_operation [EOL] [EOL] [EOL] def gen_binary_operation ( operation_name , func ) : [EOL] [docstring] [EOL] @ vm_operation def gen ( vm_state , * args , op_bytecode = None , ** kwargs ) : [EOL] op_code , arg1_type , arg1 , arg2_type , arg2 = op_bytecode [EOL] [EOL] assert VM_OPERATION_TO_BYTECODE [ op_code ] == operation_name [EOL] [EOL] if arg2_type == [number] : [comment] [EOL] input_value = vm_state . vm_registers [ arg2 ] . value [EOL] [EOL] elif arg2_type == [number] : [comment] [EOL] input_value_addr = vm_state . vm_registers [ arg2 ] . value [EOL] input_value = vm_state . vm_memory [ input_value_addr ] [EOL] [EOL] elif arg2_type == [number] : [comment] [EOL] input_value = arg2 [EOL] [EOL] else : [EOL] raise Exception ( f" [string] { operation_name }" ) [EOL] [EOL] if arg1_type == [number] : [comment] [EOL] output_val = vm_state . vm_registers [ arg1 ] . value [EOL] vm_state . vm_registers [ arg1 ] . value = func ( output_val , input_value ) [EOL] [EOL] elif arg1_type == [number] : [comment] [EOL] mem_index = vm_state . vm_registers [ arg1 ] . value [EOL] output_val = vm_state . vm_memory [ mem_index ] [EOL] vm_state . vm_memory [ mem_index ] = func ( output_val , input_value ) [EOL] [EOL] else : [EOL] raise Exception ( f" [string] { operation_name }" ) [EOL] [EOL] return vm_state [EOL] [EOL] [comment] [EOL] gen . __name__ = f" [string] { operation_name . lower ( ) }" [EOL] [EOL] return gen [EOL] [EOL] [EOL] [comment] [EOL] vm_add = gen_binary_operation ( [string] , operator . add ) [EOL] vm_sub = gen_binary_operation ( [string] , operator . sub ) [EOL] vm_mul = gen_binary_operation ( [string] , operator . mul ) [EOL] vm_div = gen_binary_operation ( [string] , operator . truediv ) [EOL] vm_and = gen_binary_operation ( [string] , operator . and_ ) [EOL] vm_or = gen_binary_operation ( [string] , operator . or_ ) [EOL] vm_xor = gen_binary_operation ( [string] , operator . xor ) [EOL] vm_mov = gen_binary_operation ( [string] , lambda _ , x : x ) [EOL] [comment] [EOL] vm_not = gen_binary_operation ( [string] , lambda _ , y : ~ y ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 $interpreter.src.virtual_machine.vm.vm_def.VmState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0