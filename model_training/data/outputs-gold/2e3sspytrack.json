import sys [EOL] import os [EOL] [EOL] directory_name = os . path . dirname ( os . path . dirname ( __file__ ) ) [EOL] sys . path . insert ( [number] , [string] . format ( directory_name ) ) [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import List [EOL] import aw_core [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] from typing import List [EOL] from aw_core import Event [EOL] [EOL] [EOL] def get_date ( seconds ) : [EOL] return datetime . datetime ( [number] , [number] , [number] , [number] , [number] , seconds , tzinfo = datetime . timezone . utc ) [EOL] [EOL] [EOL] [comment] [EOL] def get_events ( bucket_id ) : [EOL] if bucket_id == [string] : [EOL] return [ Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] , } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] , } ) , ] [EOL] elif bucket_id == [string] : [EOL] return [ Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] } ) , ] [EOL] elif bucket_id == [string] : [EOL] return [ Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] } ) , ] [EOL] else : [EOL] return [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Tuple , Any [EOL] import analyze [EOL] import typing [EOL] import TestTimeline [EOL] import tests [EOL] import unittest [EOL] from parameterized import parameterized [EOL] from typing import Tuple , List [EOL] from aw_core import Event [EOL] from analyze . bucket_type import BucketType [EOL] from analyze . events_analyzer import EventsAnalyzer [EOL] from . dataset import get_events , get_date [EOL] from analyze . timeline import Timeline [EOL] [EOL] [EOL] class TestTimeline ( unittest . TestCase ) : [EOL] [comment] [EOL] TimelineResults = List [ Tuple [ str , int , bool ] ] [EOL] [comment] [EOL] TimelineData = List [ Tuple [ int , int ] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] timelines = [ ( [ ( [number] , [number] ) ] , [ ( [number] , [number] ) ] , [ ( [string] , [number] , False ) , ( [string] , [number] , True ) , ] , [ ( [string] , [number] , False ) , ( [string] , [number] , True ) , ] , ) , ( [ ( [number] , [number] ) ] , [ ( [number] , [number] ) ] , [ ( [string] , [number] , False ) , ( [string] , [number] , True ) , ] , [ ( [string] , [number] , False ) , ( [string] , [number] , True ) , ] , ) , ( [ ( [number] , [number] ) ] , [ ( [number] , [number] ) ] , [ ( [string] , [number] , False ) , ( [string] , [number] , True ) , ] , [ ( [string] , [number] , False ) , ( [string] , [number] , True ) , ( [string] , [number] , False ) , ( [string] , [number] , True ) , ] , ) , ( [ ( [number] , [number] ) ] , [ ( [number] , [number] ) ] , [ ( [string] , [number] , False ) , ( [string] , [number] , True ) , ] , [ ] , ) , ( [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] , [ ( [number] , [number] ) ] , [ ( [string] , [number] , False ) , ( [string] , [number] , True ) , ( [string] , [number] , False ) , ( [string] , [number] , True ) , ] , [ ( [string] , [number] , False ) , ( [string] , [number] , True ) , ( [string] , [number] , False ) , ( [string] , [number] , True ) , ] , ) , ] [EOL] [EOL] @ parameterized . expand ( timelines ) def test_intersect_simple ( self , app_data , afk_data , inclusive_results , exclusive_results ) : [EOL] app_events = [ Event ( [number] , get_date ( data [ [number] ] ) , data [ [number] ] , { [string] : [string] , [string] : [string] } ) for data in app_data ] [EOL] afk_events = [ Event ( [number] , get_date ( data [ [number] ] ) , data [ [number] ] , { [string] : [string] } ) for data in afk_data ] [EOL] create_function = Timeline . create_from_bucket_events [EOL] app_timeline = create_function ( BucketType . APP , app_events ) [EOL] afk_timeline = create_function ( BucketType . AFK , afk_events ) [EOL] app_timeline . intersect ( afk_timeline , EventsAnalyzer . app_afk_timeline_condition ) [EOL] self . assert_timeline ( app_timeline , inclusive_results ) [EOL] [EOL] app_timeline = create_function ( BucketType . APP , app_events ) [EOL] afk_timeline = create_function ( BucketType . AFK , afk_events ) [EOL] app_timeline . intersect ( afk_timeline , EventsAnalyzer . app_afk_timeline_condition , False ) [EOL] self . assert_timeline ( app_timeline , exclusive_results ) [EOL] [EOL] def test_intersect ( self ) : [EOL] create_function = Timeline . create_from_bucket_events [EOL] app_timeline = create_function ( BucketType . APP , get_events ( [string] ) ) [EOL] afk_timeline = create_function ( BucketType . AFK , get_events ( [string] ) ) [EOL] [EOL] app_timeline . intersect ( afk_timeline , EventsAnalyzer . app_afk_timeline_condition ) [EOL] self . assert_timeline ( app_timeline , [ ( [string] , [number] , False ) , ( [string] , [number] , True ) , ( [string] , [number] , False ) , ( [string] , [number] , True ) , ] ) [EOL] [EOL] def assert_timeline ( self , timeline , check_points ) : [EOL] self . assertEqual ( len ( check_points ) , len ( timeline . points ) ) [EOL] for i in range ( [number] , len ( check_points ) ) : [EOL] check = check_points [ i ] [EOL] point = timeline . points [ i ] [EOL] self . assertEqual ( check [ [number] ] , point . event_data [ [string] ] ) [EOL] self . assertEqual ( check [ [number] ] , point . timestamp . second , point . event_data [ [string] ] ) [EOL] self . assertEqual ( check [ [number] ] , point . is_end ( ) , point . event_data [ [string] ] ) [EOL] [EOL] def test_get_events ( self ) : [EOL] original_events = get_events ( [string] ) [EOL] app_timeline = Timeline . create_from_bucket_events ( BucketType . APP , original_events ) [EOL] self . assertEqual ( [number] , len ( app_timeline . points ) ) [EOL] generated_events = app_timeline . get_events ( ) [EOL] self . assertEqual ( [number] , len ( generated_events ) ) [EOL] for i in range ( len ( original_events ) ) : [EOL] original_event = original_events [ i ] [EOL] generated_event = generated_events [ i ] [EOL] self . assertEqual ( original_event . timestamp , generated_event . timestamp ) [EOL] self . assertEqual ( original_event . data , generated_event . data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $TestTimeline.TimelineData$ 0 $TestTimeline.TimelineData$ 0 $TestTimeline.TimelineResults$ 0 $TestTimeline.TimelineResults$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TestTimeline.TimelineData$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TestTimeline.TimelineData$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $TestTimeline.TimelineResults$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $TestTimeline.TimelineResults$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $analyze.timeline.Timeline$ 0 $TestTimeline.TimelineResults$ 0 0 0 0 0 0 0 0 0 $TestTimeline.TimelineResults$ 0 0 0 0 $analyze.timeline.Timeline$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TestTimeline.TimelineResults$ 0 0 0 0 $typing.Any$ 0 $TestTimeline.TimelineResults$ 0 0 0 0 $typing.Any$ 0 $analyze.timeline.Timeline$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] import unittest [EOL] from datetime import datetime , timezone [EOL] [EOL] from analyze . bucket_type import BucketType [EOL] from analyze . event import Event [EOL] from aw_core import Event as ParentEvent [EOL] [EOL] [EOL] class TestEvent ( unittest . TestCase ) : [EOL] def test_stringify_data ( self ) : [EOL] current_time = datetime . now ( ) . astimezone ( timezone . utc ) [EOL] event = Event ( ParentEvent ( [number] , current_time , [number] , { [string] : [string] } ) , BucketType . WEB ) [EOL] self . assertEqual ( [string] , event . stringify_data ( ) ) [EOL] [EOL] def test_wrong_data ( self ) : [EOL] current_time = datetime . now ( ) . astimezone ( timezone . utc ) [EOL] event = Event ( ParentEvent ( [number] , current_time , [number] , { [string] : [string] } ) , BucketType . WEB ) [EOL] self . assertRaises ( Exception , event . stringify_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Optional , Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from analyze . bucket_type import BucketType [EOL] from analyze . events_analyzer import EventsAnalyzer [EOL] from config . config import Projects [EOL] from . dataset import get_events [EOL] from config import Project , Rule [EOL] [EOL] [EOL] class TestAnalyzer ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] [EOL] def test_analyze_events ( self ) : [EOL] analyzer = EventsAnalyzer ( ) [EOL] events = analyzer . analyze_events ( { [string] : BucketType . APP , [string] : BucketType . AFK , [string] : BucketType . WEB , } , { [string] : get_events ( [string] ) , [string] : get_events ( [string] ) , [string] : get_events ( [string] ) , } , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] check_events = [ ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ] [EOL] self . assertEqual ( len ( check_events ) , len ( events ) ) [EOL] for i in range ( [number] , len ( check_events ) ) : [EOL] check = check_events [ i ] [EOL] event = events [ i ] [EOL] self . assertEqual ( check [ [number] ] , event . data [ [string] ] ) [EOL] self . assertEqual ( check [ [number] ] , event . timestamp . second , event . data [ [string] ] ) [EOL] self . assertEqual ( check [ [number] ] , event . duration . seconds , event . data [ [string] ] ) [EOL] [EOL] projects = Projects ( [ Project ( [string] , [ Rule ( { [string] : [string] , [string] : [string] , [string] : [string] } ) ] ) ] , [string] ) [EOL] matched_events = analyzer . match ( events , projects ) [EOL] check_matched_events = [ ( [string] , None ) , ( [string] , [string] ) , ( [string] , None ) , ( [string] , None ) , ] [EOL] for i in range ( [number] , len ( check_matched_events ) ) : [EOL] matched_check = check_matched_events [ i ] [EOL] matched_event = matched_events [ i ] [EOL] self . assertEqual ( matched_check [ [number] ] , matched_event . data [ [string] ] ) [EOL] [EOL] [comment] [EOL] matched_events = analyzer . match ( events , projects ) [EOL] for i in range ( [number] , len ( check_matched_events ) ) : [EOL] matched_check = check_matched_events [ i ] [EOL] matched_event = matched_events [ i ] [EOL] self . assertEqual ( matched_check [ [number] ] , matched_event . data [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.int,builtins.int]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 $typing.Tuple[builtins.str,typing.Optional[builtins.str]]$ 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 $typing.Tuple[builtins.str,typing.Optional[builtins.str]]$ 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import aw_client [EOL] import aw_core [EOL] import datetime [EOL] import builtins [EOL] import unittest [EOL] from datetime import datetime [EOL] from aw_core import Event [EOL] from typing import List , Tuple [EOL] from analyze . event_repository import EventRepository [EOL] from . dataset import get_events [EOL] from unittest . mock import Mock , MagicMock [EOL] from aw_client import ActivityWatchClient [EOL] [EOL] [EOL] class TestEventRepository ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . client_mock = Mock ( ) [EOL] self . client_mock . get_buckets = MagicMock ( ) [EOL] self . client_mock . get_buckets . return_value = { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } [EOL] [EOL] self . repository = EventRepository ( self . client_mock ) [EOL] [EOL] def test_get_buckets ( self ) : [EOL] buckets = list ( self . repository . fetch_buckets ( ) . keys ( ) ) [EOL] self . assertEqual ( [ [string] , [string] , [string] ] , buckets ) [EOL] [EOL] def test_get_events ( self ) : [EOL] self . client_mock . get_events = MagicMock ( side_effect = lambda bucket_id , * args : get_events ( bucket_id ) ) [EOL] time = datetime . now ( ) [EOL] events = self . repository . get_events ( [string] , time , time ) [EOL] self . check_events ( [ ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ] , events ) [EOL] [EOL] def check_events ( self , checked_events , events ) : [EOL] self . assertEqual ( len ( checked_events ) , len ( events ) ) [EOL] for i in range ( [number] , len ( checked_events ) ) : [EOL] check = checked_events [ i ] [EOL] event = events [ i ] [EOL] self . assertEqual ( check [ [number] ] , event . data [ [string] ] ) [EOL] self . assertEqual ( check [ [number] ] , event . data [ [string] ] ) [EOL] self . assertEqual ( check [ [number] ] , event . timestamp . second ) [EOL] self . assertEqual ( check [ [number] ] , event . duration . total_seconds ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]]$ 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 $typing.Any$ 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from config import Config [EOL] [EOL] [EOL] class TestConfig ( unittest . TestCase ) : [EOL] def test_created ( self ) : [EOL] config = Config . parse ( { [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , [string] : { [string] : True , [string] : [number] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [ { [string] : [string] } ] , } , ] , } , } ) [EOL] self . assertEqual ( [number] , config . port ) [EOL] self . assertEqual ( [number] , config . interval ) [EOL] self . assertEqual ( [string] , config . host ) [EOL] self . assertTrue ( config . run_daemon ) [EOL] [EOL] self . assertEqual ( [number] , len ( config . projects ) ) [EOL] self . assertEqual ( [string] , config . projects . projects [ [number] ] . name ) [EOL] self . assertEqual ( config . projects . none_project , config . projects . projects [ [number] ] . name ) [EOL] self . assertEqual ( [number] , len ( config . projects . projects [ [number] ] . rules ) ) [EOL] self . assertEqual ( [number] , len ( config . projects . projects [ [number] ] . rules [ [number] ] . to_json ( ) ) ) [EOL] self . assertEqual ( [string] , config . projects . projects [ [number] ] . rules [ [number] ] [ [string] ] ) [EOL] self . assertIsNotNone ( [string] in config . projects . projects [ [number] ] . rules [ [number] ] . id ) [EOL] [EOL] config . host = [string] [EOL] self . assertEqual ( [string] , config . host ) [EOL] config . interval = [number] [EOL] self . assertEqual ( [number] , config . interval ) [EOL] config . port = [number] [EOL] self . assertEqual ( [number] , config . port ) [EOL] config . run_daemon = False [EOL] self . assertFalse ( config . run_daemon ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import aw_client [EOL] import aw_core [EOL] import datetime [EOL] import builtins [EOL] import unittest [EOL] from datetime import datetime [EOL] from aw_core import Event [EOL] from typing import List , Tuple [EOL] [EOL] from analyze . cached_event_repository import CachedEventRepository [EOL] from analyze . event_repository import EventRepository [EOL] from . dataset import get_date [EOL] from unittest . mock import Mock , MagicMock [EOL] from aw_client import ActivityWatchClient [EOL] [EOL] [EOL] class TestEventRepository ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . client_mock = Mock ( ) [EOL] self . client_mock . get_buckets = MagicMock ( ) [EOL] self . client_mock . get_buckets . return_value = { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } [EOL] [EOL] wrapped_repository = EventRepository ( self . client_mock ) [EOL] self . repository = CachedEventRepository ( wrapped_repository ) [EOL] [EOL] def test_get_cached_events ( self ) : [EOL] mock_events1 = [ Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] } ) , ] [EOL] mock_events2 = [ Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] } ) , Event ( [number] , get_date ( [number] ) , [number] , { [string] : [string] , [string] : [string] } ) , ] [EOL] self . client_mock . get_events = MagicMock ( side_effect = [ mock_events1 , mock_events2 ] ) [EOL] [EOL] time = datetime . now ( ) [EOL] events = self . repository . get_events ( [string] , time , time ) [EOL] self . check_events ( [ ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ] , events ) [EOL] [EOL] events = self . repository . get_events ( [string] , time , time ) [EOL] self . check_events ( [ ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) , ] , events ) [EOL] [EOL] def check_events ( self , checked_events , events ) : [EOL] self . assertEqual ( len ( checked_events ) , len ( events ) ) [EOL] for i in range ( [number] , len ( checked_events ) ) : [EOL] check = checked_events [ i ] [EOL] event = events [ i ] [EOL] self . assertEqual ( check [ [number] ] , event . data [ [string] ] ) [EOL] self . assertEqual ( check [ [number] ] , event . data [ [string] ] ) [EOL] self . assertEqual ( check [ [number] ] , event . timestamp . second ) [EOL] self . assertEqual ( check [ [number] ] , event . duration . total_seconds ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]]$ 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 $typing.Any$ 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
from typing import Union , List , Dict , Any [EOL] import typing [EOL] import pathlib [EOL] import unittest [EOL] [EOL] import yaml [EOL] [EOL] from config import Project , Rule [EOL] from tests . integration import get_current_directory [EOL] from pathlib import Path [EOL] from config . config_storage import FileConfigStorage [EOL] from config . config import Config [EOL] [EOL] [EOL] class TestFileConfigStorage ( unittest . TestCase ) : [EOL] def test_load_non_existing ( self ) : [EOL] current_directory = get_current_directory ( ) [EOL] filename = Path ( [string] . format ( current_directory ) ) [EOL] file = Path ( filename ) [EOL] self . assertFalse ( file . exists ( ) ) [EOL] self . assertFalse ( file . parent . exists ( ) ) [EOL] [EOL] save_storage = FileConfigStorage ( filename ) [EOL] try : [EOL] config = save_storage . load ( ) [EOL] self . assertEqual ( [string] , config . host ) [EOL] self . assertTrue ( file . is_file ( ) ) [EOL] finally : [EOL] file . unlink ( ) [EOL] file . parent . rmdir ( ) [EOL] [EOL] def test_save_load ( self ) : [EOL] current_directory = get_current_directory ( ) [EOL] file = Path ( [string] . format ( current_directory ) ) [EOL] save_storage = FileConfigStorage ( file ) [EOL] [EOL] initial_yaml = { [string] : { [string] : [number] , [string] : [string] , } , [string] : { [string] : True , [string] : [number] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [ { [string] : [string] } , ] , } , ] , } , } [EOL] [EOL] saved_config = Config . parse ( initial_yaml ) [EOL] save_storage . save ( saved_config ) [EOL] self . assertTrue ( file . is_file ( ) ) [EOL] [EOL] try : [EOL] load_storage = FileConfigStorage ( file ) [EOL] load_config = load_storage . load ( ) [EOL] [EOL] self . assertEqual ( [string] , load_config . host ) [EOL] self . assertEqual ( [number] , load_config . port ) [EOL] self . assertEqual ( [number] , load_config . interval ) [EOL] self . assertTrue ( load_config . run_daemon ) [EOL] self . assertEqual ( [number] , len ( load_config . projects ) ) [EOL] self . assertEqual ( load_config . projects . none_project , load_config . projects . projects [ [number] ] . name ) [EOL] self . assertIsInstance ( load_config . projects . projects [ [number] ] , Project ) [EOL] self . assertIsInstance ( load_config . projects . projects [ [number] ] . rules [ [number] ] , Rule ) [EOL] saved_yaml = yaml . safe_load ( file . read_text ( ) ) [EOL] self . assertEqual ( initial_yaml , saved_yaml ) [EOL] finally : [EOL] file . unlink ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import types [EOL] import typing [EOL] import builtins [EOL] import inspect [EOL] import pathlib [EOL] [EOL] [EOL] def get_current_directory ( ) : [EOL] frame = inspect . currentframe ( ) [EOL] filename = inspect . getframeinfo ( frame ) . filename [comment] [EOL] return str ( pathlib . Path ( filename ) . resolve ( ) . parent ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from config import ConfigStorage , get_config_file [EOL] from gui import Gui [EOL] from runner import Runner [EOL] [EOL] config_storage = ConfigStorage ( get_config_file ( ) ) [EOL] stats_runner = Runner ( config_storage . load ( ) ) [EOL] gui = Gui ( config_storage , stats_runner ) [EOL] gui . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0
from typing import List , Callable , Dict , Any [EOL] import config [EOL] import analyze [EOL] import typing [EOL] import PyQt5 [EOL] import datetime [EOL] import builtins [EOL] from datetime import datetime , timedelta [EOL] from typing import List , Dict , Callable [EOL] from PyQt5 import QtWidgets , QtCore [EOL] from PyQt5 . QtCore import Qt [EOL] from PyQt5 . QtWidgets import QListWidgetItem [EOL] from aw_client import ActivityWatchClient [EOL] from analyze . event_repository import EventRepository [EOL] from analyze . matched_event import MatchedEvent [EOL] from analyze import AnalyzerFacade [EOL] from analyze . stats import get_pie_chart , PieChartData [EOL] from config import Config , ConfigStorage [EOL] from gui . chart import Chart [EOL] from gui . settings_window import SettingsWindow [EOL] from . ui . main_page import Ui_MainPage [EOL] [EOL] WidgetItems = List [ QListWidgetItem ] [EOL] [EOL] [EOL] class MainPageWidget ( QtWidgets . QWidget ) : [EOL] last_matched_events = ... [EOL] [EOL] def __init__ ( self , config_storage , reload_config ) : [EOL] super ( ) . __init__ ( ) [EOL] self . external_reload_config = reload_config [EOL] self . config_storage = config_storage [EOL] self . config = config_storage . load ( ) [EOL] self . ui = Ui_MainPage ( ) [EOL] self . ui . setupUi ( self ) [EOL] aw_client = ActivityWatchClient ( [string] , testing = False ) [EOL] self . events_repository = EventRepository ( aw_client ) [EOL] [EOL] self . chart = Chart ( self . config , self . ui . chartView ) [EOL] self . ui . projectsTimesList . itemSelectionChanged . connect ( self . _update_project_events ) [EOL] self . ui . settingsButton . clicked . connect ( self . _show_settings ) [EOL] self . last_matched_events = [ ] [EOL] self . analyzer = AnalyzerFacade ( self . events_repository , self . config ) [EOL] [EOL] self . _setup_datetime ( ) [EOL] self . _run_timer ( ) [EOL] [EOL] def _show_settings ( self ) : [EOL] settings_window = SettingsWindow ( self . config , self . config_storage , self . _reload_config ) [EOL] settings_window . exec_ ( ) [EOL] [EOL] def _reload_config ( self , config ) : [EOL] self . external_reload_config ( config ) [EOL] self . config = config [EOL] self . timer . stop ( ) [EOL] self . analyzer = AnalyzerFacade ( self . events_repository , config ) [EOL] self . chart . reload_config ( config ) [EOL] self . timer . start ( self . config . interval * [number] ) [EOL] [EOL] def _setup_datetime ( self ) : [EOL] end_time = datetime . now ( ) . replace ( microsecond = [number] ) [EOL] start_time = self . _get_last_day_beginning ( end_time ) [EOL] if start_time > end_time : [EOL] start_time = start_time . replace ( day = start_time . day - [number] ) [EOL] self . ui . startDateTimeEdit . setDateTime ( start_time ) [EOL] self . ui . endDateTimeEdit . setDateTime ( end_time . replace ( ) ) [EOL] [EOL] def state_changed ( ) : [EOL] is_range_disabled = self . ui . disableDateRange . isChecked ( ) [EOL] self . ui . endDateTimeEdit . setDisabled ( is_range_disabled ) [EOL] self . ui . startDateTimeEdit . setDisabled ( is_range_disabled ) [EOL] self . ui . disableDateRange . stateChanged . connect ( state_changed ) [EOL] [EOL] def _get_last_day_beginning ( self , now_time ) : [EOL] ( hours , minutes ) = self . config . start_day_time . split ( [string] ) [EOL] start_time = now_time . replace ( hour = int ( hours ) , minute = int ( minutes ) , second = [number] ) [EOL] if start_time > now_time : [EOL] start_time = start_time - timedelta ( days = [number] ) [EOL] return start_time [EOL] [EOL] def _run_timer ( self ) : [EOL] self . _run_chart ( ) [EOL] self . timer = QtCore . QTimer ( ) [EOL] self . timer . setSingleShot ( False ) [EOL] self . timer . timeout . connect ( self . _run_chart ) [EOL] self . timer . start ( self . config . interval * [number] ) [EOL] [EOL] def _run_chart ( self ) : [EOL] if self . ui . disableDateRange . isChecked ( ) : [EOL] end_date = datetime . now ( ) [EOL] start_date = self . _get_last_day_beginning ( end_date ) [EOL] else : [EOL] end_date = self . ui . endDateTimeEdit . dateTime ( ) . toPyDateTime ( ) [EOL] start_date = self . ui . startDateTimeEdit . dateTime ( ) . toPyDateTime ( ) [EOL] [EOL] self . last_matched_events = self . analyzer . analyze ( start_date , end_date , self . ui . disableDateRange . isChecked ( ) ) [EOL] chart_data = get_pie_chart ( self . last_matched_events ) [EOL] self . chart . draw ( chart_data ) [EOL] self . _run_projects ( chart_data ) [EOL] [EOL] def _update_project_events ( self ) : [EOL] self . ui . projectEventsList . clear ( ) [EOL] selected_items = self . ui . projectsTimesList . selectedItems ( ) [EOL] if len ( selected_items ) < [number] : [EOL] return [EOL] if len ( self . last_matched_events ) < [number] : [EOL] return [EOL] selected_project = selected_items [ [number] ] . data ( Qt . UserRole ) [EOL] i = [number] [EOL] items = [ ] [EOL] items_duration = { } [EOL] selected_events = [ ] [EOL] [EOL] for event in reversed ( self . last_matched_events ) : [EOL] if event . project == selected_project : [EOL] data_hash = event . stringify_data ( ) [EOL] if data_hash not in items_duration : [EOL] items_duration [ data_hash ] = [number] [EOL] selected_events . append ( event ) [EOL] items_duration [ data_hash ] += event . duration . total_seconds ( ) [EOL] [EOL] for event in selected_events : [EOL] text = [string] . join ( [ [string] . format ( key , value ) for key , value in event . data . items ( ) ] ) [EOL] duration = int ( items_duration [ event . stringify_data ( ) ] ) [EOL] text = [string] . format ( duration , text ) [EOL] items . append ( text ) [EOL] i += [number] [EOL] if i > [number] : [EOL] break [EOL] self . ui . projectEventsList . addItems ( items ) [EOL] [EOL] def _run_projects ( self , chart_data ) : [EOL] existing_projects = { } [EOL] for i in range ( [number] , self . ui . projectsTimesList . count ( ) ) : [EOL] item = self . ui . projectsTimesList . item ( i ) [EOL] existing_projects [ str ( item . data ( Qt . UserRole ) ) ] = item [EOL] [EOL] for project , duration in chart_data . data . items ( ) : [EOL] if project not in existing_projects : [EOL] item = QListWidgetItem ( ) [EOL] item . setData ( Qt . UserRole , project ) [EOL] self . ui . projectsTimesList . addItem ( item ) [EOL] else : [EOL] item = existing_projects [ project ] [EOL] item . setText ( [string] . format ( self . _format_project_name ( project ) , str ( timedelta ( seconds = int ( duration ) ) ) ) ) [EOL] self . _update_project_events ( ) [EOL] [EOL] def _format_project_name ( self , project_name ) : [EOL] if project_name == self . config . projects . none_project : [EOL] return [string] [EOL] else : [EOL] return project_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[analyze.matched_event.MatchedEvent]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $WidgetItems$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $WidgetItems$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $WidgetItems$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.List[analyze.matched_event.MatchedEvent]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 $typing.Any$ 0 0 0 0 $typing.List[analyze.matched_event.MatchedEvent]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[analyze.matched_event.MatchedEvent]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 $analyze.stats.PieChartData$ 0 0 0 $typing.Dict[builtins.str,PyQt5.QtWidgets.QListWidgetItem]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,PyQt5.QtWidgets.QListWidgetItem]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $analyze.stats.PieChartData$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,PyQt5.QtWidgets.QListWidgetItem]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,PyQt5.QtWidgets.QListWidgetItem]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
from typing import List , Callable , Any [EOL] import config [EOL] import typing [EOL] import PyQt5 [EOL] import gui [EOL] import builtins [EOL] from typing import Callable , List [EOL] [EOL] from PyQt5 import QtWidgets [EOL] from PyQt5 . QtWidgets import QVBoxLayout [EOL] from config import Project , Rule [EOL] from gui . rule_widget import RuleWidget [EOL] from . ui . project import Ui_ProjectFrame [EOL] [EOL] [EOL] class ProjectWidget ( QtWidgets . QFrame ) : [EOL] def __init__ ( self , project , on_remove_rule , on_edit_project_name , ) : [EOL] super ( ) . __init__ ( ) [EOL] self . ui = Ui_ProjectFrame ( ) [EOL] self . ui . setupUi ( self ) [EOL] self . ui . nameEdit . setText ( project . name ) [EOL] self . _setup_rules ( project ) [EOL] [EOL] self . ui . removeButton . clicked . connect ( lambda : on_remove_rule ( self ) ) [EOL] self . ui . nameEdit . textChanged . connect ( on_edit_project_name ) [EOL] [EOL] def _setup_rules ( self , project ) : [EOL] layout = self . ui . rulesBox . layout ( ) [EOL] for rule in project . rules : [EOL] rule_widget = self . _create_rule_widget ( layout , rule ) [EOL] layout . addWidget ( rule_widget ) [EOL] [EOL] def _create_rule_widget ( self , layout , rule ) : [EOL] rule_widget = RuleWidget ( rule ) [EOL] rule_widget . register_callbacks ( lambda : layout . insertWidget ( layout . indexOf ( rule_widget ) , self . _create_rule_widget ( layout , Rule ( { [string] : [string] } ) ) ) , lambda : rule_widget . remove_from ( layout ) ) [EOL] [EOL] return rule_widget [EOL] [EOL] def remove_from ( self , layout ) : [EOL] self . hide ( ) [EOL] layout . removeWidget ( self ) [EOL] self . deleteLater ( ) [EOL] [EOL] @ property def project ( self ) : [EOL] name = self . ui . nameEdit . text ( ) [EOL] layout = self . ui . rulesBox . layout ( ) [EOL] rule_widgets = [ ] [EOL] for i in range ( [number] , layout . count ( ) ) : [EOL] widget = layout . itemAt ( i ) . widget ( ) [EOL] assert isinstance ( widget , RuleWidget ) [EOL] rule_widgets . append ( widget ) [EOL] return Project ( name , [ rule_widget . rule for rule_widget in rule_widgets ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Callable[[builtins.str],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.str],None]$ 0 0 0 0 $None$ 0 0 0 $config.Project$ 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 $config.Project$ 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 0 0 $gui.rule_widget.RuleWidget$ 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 $config.Rule$ 0 0 0 $typing.Any$ 0 0 0 $config.Rule$ 0 0 $typing.Any$ 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $config.Project$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 $typing.List[gui.rule_widget.RuleWidget]$ 0 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 0 $typing.Any$ 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[gui.rule_widget.RuleWidget]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[gui.rule_widget.RuleWidget]$ 0 0 0
from typing import Optional , Any [EOL] import gui [EOL] import typing [EOL] import PyQt5 [EOL] import builtins [EOL] from typing import Optional [EOL] from PyQt5 import QtCore [EOL] from PyQt5 . QtGui import QIcon [EOL] from PyQt5 . QtWidgets import QAction , qApp , QMenu , QSystemTrayIcon , QApplication [EOL] from gui . main_window import MainWindow [EOL] [EOL] [EOL] class Tray ( QSystemTrayIcon ) : [EOL] def __init__ ( self , parent , main_window = None ) : [EOL] super ( ) . __init__ ( parent ) [EOL] icon = QIcon ( [string] ) [EOL] self . setIcon ( icon ) [EOL] [EOL] quit_action = QAction ( [string] , parent ) [EOL] quit_action . triggered . connect ( qApp . quit ) [EOL] self . tray_menu = QMenu ( ) [EOL] self . setContextMenu ( self . tray_menu ) [EOL] if main_window is not None : [EOL] self . _create_main_window ( main_window , self . tray_menu ) [EOL] self . tray_menu . addAction ( quit_action ) [EOL] [EOL] def _create_main_window ( self , main_window , tray_menu ) : [EOL] self . main_window = main_window [EOL] show_action = QAction ( [string] , self . main_window ) [EOL] show_action . triggered . connect ( self . _show_hide_main_window ) [EOL] tray_menu . addAction ( show_action ) [EOL] self . activated . connect ( self . _left_click ) [comment] [EOL] [EOL] def _left_click ( self , reason ) : [EOL] if reason == QSystemTrayIcon . Trigger : [EOL] self . _show_hide_main_window ( ) [EOL] [EOL] def _show_hide_main_window ( self ) : [EOL] for window in QApplication . topLevelWidgets ( ) : [EOL] if not window . isHidden ( ) \ [EOL] and window . objectName ( ) == [string] : [EOL] return [EOL] if self . main_window . isVisible ( ) : [EOL] self . main_window . hide ( ) [EOL] else : [EOL] self . main_window . show ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $PyQt5.QtCore.QObject$ 0 $typing.Optional[gui.main_window.MainWindow]$ 0 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtCore.QObject$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $PyQt5.QtCore.QObject$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[gui.main_window.MainWindow]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[gui.main_window.MainWindow]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 $PyQt5.QtWidgets.QMenu$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QMenu$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from gui . gui import Gui [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
import SettingsWindow [EOL] from typing import List , Callable , Any [EOL] import config [EOL] import typing [EOL] import PyQt5 [EOL] import gui [EOL] import builtins [EOL] from typing import List , Callable [EOL] [EOL] from PyQt5 import QtWidgets , QtCore [EOL] from PyQt5 . QtWidgets import QVBoxLayout , QFrame , QToolBox [EOL] [EOL] from config import Project , Rule , Config [EOL] from gui . project_widget import ProjectWidget [EOL] from gui . ui . settings import Ui_settingsWindow [EOL] from config import ConfigStorage [EOL] [EOL] [EOL] class SettingsWindow ( QtWidgets . QDialog ) : [EOL] config = ... [EOL] [EOL] def __init__ ( self , config , config_storage , reload_config ) : [EOL] super ( ) . __init__ ( ) [EOL] self . reload_config = reload_config [EOL] self . config = config [EOL] self . config_storage = config_storage [EOL] self . ui = Ui_settingsWindow ( ) [EOL] self . ui . setupUi ( self ) [EOL] [EOL] self . actual_project_widgets = [ ] [EOL] self . _setup_projects_settings ( ) [EOL] self . _setup_server_settings ( ) [EOL] [EOL] def accept ( self ) : [EOL] self . _modify_config ( ) [EOL] [EOL] super ( ) . accept ( ) [EOL] [EOL] def _get_projects ( self ) : [EOL] return [ widget . project for widget in self . actual_project_widgets ] [EOL] [EOL] def _setup_server_settings ( self ) : [EOL] self . ui . portBox . setValue ( self . config . port ) [EOL] self . ui . intervalBox . setValue ( self . config . interval ) [EOL] self . ui . hostEdit . setText ( self . config . host ) [EOL] [EOL] def _state_changed ( ) : [EOL] self . ui . hostEdit . setDisabled ( self . ui . isLocalServerBox . isChecked ( ) ) [EOL] [EOL] self . ui . isLocalServerBox . stateChanged . connect ( _state_changed ) [EOL] self . ui . isLocalServerBox . setCheckState ( QtCore . Qt . Checked [EOL] if self . config . run_daemon [EOL] else QtCore . Qt . Unchecked ) [EOL] [EOL] def _setup_projects_settings ( self ) : [EOL] self . ui . addProjectButton . clicked . connect ( self . _add_callback ) [EOL] layout = self . ui . projectsFrame . layout ( ) [EOL] [EOL] self . projects_box = QToolBox ( ) [EOL] self . projects_box . setFrameShape ( QFrame . NoFrame ) [EOL] self . projects_box . setLineWidth ( [number] ) [EOL] self . projects_box . setFrameShadow ( QFrame . Plain ) [EOL] [EOL] layout . addWidget ( self . projects_box ) [EOL] for project in self . config . projects : [EOL] if project . name == self . config . projects . none_project : [EOL] continue [EOL] project_widget = self . _create_project_widget ( project ) [EOL] self . projects_box . addItem ( project_widget , project . name ) [EOL] [EOL] def _create_project_widget ( self , project ) : [EOL] project_widget = ProjectWidget ( project , self . _remove_callback , self . _edit_project_name ) [EOL] self . actual_project_widgets . append ( project_widget ) [EOL] return project_widget [EOL] [EOL] def _add_callback ( self ) : [EOL] new_project_name = [string] [EOL] empty_project = Project ( new_project_name , [ Rule ( { [string] : [string] } ) ] ) [EOL] project_widget = self . _create_project_widget ( empty_project ) [EOL] self . projects_box . addItem ( project_widget , new_project_name ) [EOL] self . projects_box . setCurrentWidget ( project_widget ) [EOL] [EOL] def _remove_callback ( self , widget ) : [EOL] self . actual_project_widgets . remove ( widget ) [EOL] widget . remove_from ( self . ui . projectsFrame . layout ( ) ) [EOL] [EOL] def _edit_project_name ( self , name ) : [EOL] self . projects_box . setItemText ( self . projects_box . currentIndex ( ) , name ) [EOL] [EOL] def _modify_config ( self ) : [EOL] self . config = self . config . modify ( int ( self . ui . portBox . value ( ) ) , self . ui . hostEdit . text ( ) , int ( self . ui . intervalBox . value ( ) ) , self . ui . isLocalServerBox . isChecked ( ) , self . _get_projects ( ) ) [EOL] [EOL] self . config_storage . save ( self . config ) [EOL] self . reload_config ( self . config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $config.Config$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[gui.project_widget.ProjectWidget]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[SettingsWindow.config.Project]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 $PyQt5.QtWidgets.QToolBox$ 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QToolBox$ 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QToolBox$ 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QToolBox$ 0 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 $PyQt5.QtWidgets.QToolBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QToolBox$ 0 0 0 0 0 0 0 0 0 0 0 0 $gui.project_widget.ProjectWidget$ 0 0 0 $SettingsWindow.config.Project$ 0 0 0 $typing.Any$ 0 0 0 $SettingsWindow.config.Project$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $gui.project_widget.ProjectWidget$ 0 0 0 0 0 0 0 0 0 $gui.project_widget.ProjectWidget$ 0 0 $gui.project_widget.ProjectWidget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import config [EOL] import runner [EOL] import typing [EOL] import spytrack [EOL] import sys [EOL] from PyQt5 import QtWidgets [EOL] from PyQt5 import QtCore [EOL] from config import ConfigStorage [EOL] from runner import Runner [EOL] from . tray import Tray [EOL] from . main_window import MainWindow [EOL] [EOL] [EOL] class Gui : [EOL] timer = ... [EOL] [EOL] def __init__ ( self , config_storage , stats_runner ) : [EOL] self . stats_runner = stats_runner [EOL] self . config_storage = config_storage [EOL] [EOL] def run ( self ) : [EOL] app = QtWidgets . QApplication ( sys . argv ) [EOL] with self . stats_runner : [EOL] main_window = MainWindow ( self . config_storage , self . stats_runner ) [EOL] tray_icon = Tray ( app , main_window ) [EOL] tray_icon . show ( ) [EOL] exit_code = app . exec_ ( ) [EOL] sys . exit ( exit_code ) [EOL] [EOL] def run_headless ( self ) : [EOL] app = QtWidgets . QApplication ( sys . argv ) [EOL] with self . stats_runner : [EOL] tray_icon = Tray ( app ) [EOL] tray_icon . show ( ) [EOL] exit_code = app . exec_ ( ) [EOL] sys . exit ( exit_code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtCore.QTimer$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spytrack.gui.main_window.MainWindow$ 0 0 0 0 0 0 0 0 0 0 0 0 $spytrack.gui.tray.Tray$ 0 0 0 $typing.Any$ 0 $spytrack.gui.main_window.MainWindow$ 0 0 $spytrack.gui.tray.Tray$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spytrack.gui.tray.Tray$ 0 0 0 $typing.Any$ 0 0 $spytrack.gui.tray.Tray$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import config [EOL] import runner [EOL] import typing [EOL] import PyQt5 [EOL] from typing import List [EOL] from PyQt5 import QtWidgets [EOL] from PyQt5 . QtGui import QCloseEvent [EOL] from PyQt5 . QtWidgets import QListWidgetItem , QVBoxLayout [EOL] from analyze . matched_event import MatchedEvent [EOL] from gui . main_page_widget import MainPageWidget [EOL] from gui . ui . main import Ui_Main [EOL] from config import ConfigStorage [EOL] from runner import Runner [EOL] [EOL] WidgetItems = List [ QListWidgetItem ] [EOL] [EOL] [EOL] class MainWindow ( QtWidgets . QMainWindow ) : [EOL] ui = ... [EOL] last_matched_events = ... [EOL] [EOL] def __init__ ( self , config_storage , stats_runner ) : [EOL] super ( ) . __init__ ( ) [EOL] self . stats_runner = stats_runner [EOL] self . config = config_storage . load ( ) [EOL] self . config_storage = config_storage [EOL] self . ui = Ui_Main ( ) [EOL] self . ui . setupUi ( self ) [EOL] [EOL] self . last_matched_events = [ ] [EOL] [EOL] self . _setup_main_widget ( ) [EOL] [EOL] def closeEvent ( self , event ) : [EOL] event . ignore ( ) [EOL] self . hide ( ) [EOL] [EOL] def _setup_main_widget ( self ) : [EOL] self . main_page_widget = MainPageWidget ( self . config_storage , self . stats_runner . reload ) [EOL] layout = self . ui . tabChart . layout ( ) [EOL] layout . addWidget ( self . main_page_widget ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gui.ui.main.Ui_Main$ 0 0 0 $typing.List[analyze.matched_event.MatchedEvent]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $PyQt5.QtGui.QCloseEvent$ 0 0 0 $PyQt5.QtGui.QCloseEvent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 $PyQt5.QtWidgets.QVBoxLayout$ 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import config [EOL] import analyze [EOL] import typing [EOL] import PyQt5 [EOL] from PyQt5 . QtChart import QChartView , QBarSeries , QBarSet , QBarCategoryAxis , QChart , QLegend [EOL] from PyQt5 . QtGui import QPainter [EOL] from analyze . stats import PieChartData [EOL] from config import Config [EOL] [EOL] [EOL] class Chart : [EOL] def __init__ ( self , config , chart_view ) : [EOL] self . chart_view = chart_view [EOL] self . config = config [EOL] self . initialized = False [EOL] [EOL] chart_view . setRenderHint ( QPainter . Antialiasing ) [EOL] self . chart = chart_view . chart ( ) [EOL] legend = self . chart . legend ( ) [EOL] legend . hide ( ) [EOL] [EOL] self . chart_view . repaint ( ) [EOL] [EOL] def draw ( self , chart_data ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] series = QBarSeries ( ) [EOL] bar_set = QBarSet ( [string] ) [EOL] categories = [ ] [EOL] for project , duration in chart_data . data . items ( ) : [EOL] if project == self . config . projects . none_project : [EOL] project = [string] [EOL] categories . append ( project ) [EOL] bar_set . append ( duration ) [EOL] series . append ( bar_set ) [EOL] axis_x = QBarCategoryAxis ( ) [EOL] axis_x . append ( categories ) [EOL] [EOL] self . chart . removeAllSeries ( ) [EOL] self . chart . addSeries ( series ) [EOL] self . chart . setAxisX ( axis_x ) [EOL] series . attachAxis ( axis_x ) [EOL] [EOL] self . initialized = True [EOL] [EOL] def reload_config ( self , config ) : [EOL] self . config = config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PyQt5.QtChart.QChart$ 0 0 0 $PyQt5.QtChart.QChart$ 0 0 0 $PyQt5.QtChart.QLegend$ 0 0 0 $PyQt5.QtChart.QChart$ 0 $PyQt5.QtChart.QLegend$ 0 0 0 $PyQt5.QtChart.QLegend$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $analyze.stats.PieChartData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $analyze.stats.PieChartData$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , List , Any [EOL] import analyze [EOL] import typing [EOL] import aw_client [EOL] import datetime [EOL] import spytrack [EOL] import builtins [EOL] from datetime import datetime , timezone [EOL] from typing import Dict , Any , List [EOL] from analyze . bucket_type import BucketType [EOL] from . event import Event [EOL] from aw_client import ActivityWatchClient [EOL] [EOL] [EOL] Events = List [ Event ] [EOL] Buckets = Dict [ str , BucketType ] [EOL] [EOL] [EOL] class EventRepository : [EOL] BUCKET_TYPE_WINDOW = [string] [EOL] BUCKET_TYPE_AFK = [string] [EOL] BUCKET_TYPE_WEB = [string] [EOL] [EOL] def __init__ ( self , client ) : [EOL] self . client = client [EOL] [EOL] def fetch_buckets ( self ) : [EOL] return { key : self . _get_bucket_type ( value ) for key , value in self . client . get_buckets ( ) . items ( ) if value [ [string] ] in [ EventRepository . BUCKET_TYPE_WINDOW , EventRepository . BUCKET_TYPE_AFK , EventRepository . BUCKET_TYPE_WEB , ] } [EOL] [EOL] def _get_bucket_type ( self , data ) : [EOL] if data [ [string] ] == EventRepository . BUCKET_TYPE_AFK : [EOL] return BucketType . AFK [EOL] elif data [ [string] ] == EventRepository . BUCKET_TYPE_WINDOW : [EOL] return BucketType . APP [EOL] elif data [ [string] ] == EventRepository . BUCKET_TYPE_WEB : [EOL] return BucketType . WEB [EOL] else : [EOL] raise RuntimeError [EOL] [EOL] def get_events ( self , bucket , start_date , end_date ) : [EOL] events = self . client . get_events ( bucket , - [number] , start_date . astimezone ( timezone . utc ) , end_date . astimezone ( timezone . utc ) ) [EOL] bucket_type = self . fetch_buckets ( ) [ bucket ] [EOL] return [ Event ( event , bucket_type ) for event in events if event . duration . total_seconds ( ) > [number] ] [EOL] [EOL] def get_bucket_events ( self , buckets , start_date , end_date ) : [EOL] events = { } [EOL] for bucket_name in buckets : [EOL] events [ bucket_name ] = self . get_events ( bucket_name , start_date , end_date ) [EOL] [EOL] return events [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Buckets$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $analyze.bucket_type.BucketType$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Events$ 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Events]$ 0 0 0 $typing.List[builtins.str]$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import List , Callable , Any , Tuple , Type , Optional , Dict [EOL] import config [EOL] import typing [EOL] import timeline [EOL] import bucket_point [EOL] import matched_event [EOL] import spytrack [EOL] import event [EOL] import builtins [EOL] import re [EOL] from typing import Dict , List , Any , Callable , Tuple [EOL] from analyze . bucket_type import BucketType [EOL] from . event import Event [EOL] from . matched_event import MatchedEvent [EOL] from . bucket_point import BucketPoint [EOL] from . timeline import Timeline [EOL] from config import Rule , Projects [EOL] [EOL] ClientBuckets = Dict [ str , Dict [ str , Any ] ] [EOL] Events = List [ Event ] [EOL] BucketName = str [EOL] Buckets = Dict [ BucketName , BucketType ] [EOL] BucketPoints = List [ BucketPoint ] [EOL] BucketPointCondition = Callable [ [ BucketPoint ] , bool ] [EOL] [EOL] [EOL] class EventsAnalyzer : [EOL] browser_buckets_cache = { } [EOL] [EOL] def __init__ ( self ) : [EOL] self . matches_cache = { } [EOL] [EOL] def analyze_events ( self , buckets , bucket_events ) : [EOL] timelines = { } [EOL] for bucket_name , bucket_type in buckets . items ( ) : [EOL] events = bucket_events [ bucket_name ] [EOL] timelines [ bucket_name ] = Timeline . create_from_bucket_events ( bucket_type , events ) [EOL] [EOL] browser_buckets = [ bucket for bucket , value in buckets . items ( ) if value == BucketType . WEB ] [EOL] app_buckets = [ bucket for bucket , value in buckets . items ( ) if value == BucketType . APP ] [EOL] afk_buckets = [ bucket for bucket , value in buckets . items ( ) if value == BucketType . AFK ] [EOL] [EOL] if len ( app_buckets ) == [number] or len ( afk_buckets ) == [number] : [EOL] return [ ] [EOL] app_bucket = app_buckets [ [number] ] [EOL] afk_bucket = afk_buckets [ [number] ] [EOL] browser_matches = self . _match_browser_buckets ( app_bucket , browser_buckets , timelines ) [EOL] for bucket_name in browser_buckets : [EOL] if bucket_name not in browser_matches : [EOL] del timelines [ bucket_name ] [EOL] [EOL] [comment] [EOL] timelines [ app_bucket ] . intersect ( timelines [ afk_bucket ] , self . app_afk_timeline_condition ) [EOL] all_events = [ ] [EOL] [comment] [EOL] [comment] [EOL] for web_bucket_name , app_name in browser_matches . items ( ) : [EOL] timelines [ web_bucket_name ] . intersect ( timelines [ app_bucket ] , self . app_browser_timeline_condition ( app_name ) ) [EOL] timelines [ app_bucket ] . intersect ( timelines [ web_bucket_name ] , lambda _ : True , False ) [EOL] all_events += timelines [ web_bucket_name ] . get_events ( ) [EOL] [EOL] all_events += timelines [ app_bucket ] . get_events ( ) [EOL] all_events . sort ( ) [EOL] [EOL] return all_events [EOL] [EOL] def match ( self , events , projects ) : [EOL] matched_events = [ ] [EOL] for event in events : [EOL] data_hash = event . stringify_data ( ) [EOL] if data_hash in self . matches_cache : [EOL] hit = self . matches_cache [ data_hash ] [EOL] matched_event = MatchedEvent ( hit [ [number] ] , hit [ [number] ] , event ) [EOL] else : [EOL] matched_event = self . _match_event ( event , projects ) [EOL] self . matches_cache [ data_hash ] = ( matched_event . project , matched_event . rule_id ) [EOL] matched_events . append ( matched_event ) [EOL] [EOL] return matched_events [EOL] [EOL] def _match_event ( self , event , projects ) : [EOL] for project in projects : [EOL] for rule in project . rules : [EOL] if self . _is_event_matching ( event , rule ) : [EOL] return MatchedEvent ( project . name , rule . id , event ) [EOL] return MatchedEvent ( projects . none_project , projects . none_project , event ) [EOL] [EOL] def _is_event_matching ( self , event , definition ) : [EOL] if [string] in definition and [string] in event . data : [EOL] return re . search ( definition [ [string] ] , event . data [ [string] ] , flags = re . IGNORECASE ) is not None [EOL] if [string] in definition and [string] in event . data : [EOL] return re . search ( definition [ [string] ] , event . data [ [string] ] , flags = re . IGNORECASE ) is not None [EOL] if [string] in definition and [string] in event . data : [EOL] return re . search ( definition [ [string] ] , event . data [ [string] ] , flags = re . IGNORECASE ) is not None [EOL] return False [EOL] [EOL] @ staticmethod def app_afk_timeline_condition ( afk_event ) : [EOL] return bool ( afk_event . event_data [ [string] ] == [string] ) [EOL] [EOL] @ staticmethod def app_browser_timeline_condition ( app_name ) : [EOL] return lambda app_event : bool ( app_event . event_data [ [string] ] == app_name ) [EOL] [EOL] @ staticmethod def _match_browser_buckets ( app_bucket , browser_buckets , timelines ) : [EOL] app_timeline = timelines [ app_bucket ] [EOL] matches = { } [EOL] cache = EventsAnalyzer . browser_buckets_cache [EOL] for browser_bucket in browser_buckets : [EOL] if browser_bucket in cache : [EOL] matches [ browser_bucket ] = cache [ browser_bucket ] [EOL] continue [EOL] [EOL] browser_timeline = timelines [ browser_bucket ] [EOL] match_app = browser_timeline . get_browser_app ( app_timeline ) [EOL] [EOL] if match_app is not None : [EOL] matches [ browser_bucket ] = match_app [EOL] return matches [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[BucketName,builtins.str]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 $Events$ 0 0 0 $Buckets$ 0 $typing.Dict[BucketName,Events]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $Buckets$ 0 0 0 0 0 0 $typing.List[spytrack.analyze.event.Event]$ 0 $typing.Dict[BucketName,Events]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[spytrack.analyze.event.Event]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $Buckets$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $Buckets$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $Buckets$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $Events$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $Events$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $Events$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $Events$ 0 0 0 0 0 0 0 $Events$ 0 0 0 $typing.List[matched_event.MatchedEvent]$ 0 0 0 $Events$ 0 $config.Projects$ 0 0 0 $spytrack.analyze.matched_event.MatchedEvent$ 0 0 0 0 0 0 0 $Events$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $spytrack.analyze.matched_event.MatchedEvent$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $spytrack.analyze.matched_event.MatchedEvent$ 0 0 0 0 0 0 0 $config.Projects$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $spytrack.analyze.matched_event.MatchedEvent$ 0 0 0 $spytrack.analyze.matched_event.MatchedEvent$ 0 0 0 0 $spytrack.analyze.matched_event.MatchedEvent$ 0 0 0 $spytrack.analyze.matched_event.MatchedEvent$ 0 0 0 0 $spytrack.analyze.matched_event.MatchedEvent$ 0 0 0 $matched_event.MatchedEvent$ 0 0 0 $event.Event$ 0 $config.Projects$ 0 0 0 0 0 0 $config.Projects$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event.Event$ 0 0 0 0 0 $config.Projects$ 0 0 0 $config.Projects$ 0 0 0 $event.Event$ 0 0 0 0 $builtins.bool$ 0 0 0 $event.Event$ 0 $config.Rule$ 0 0 0 0 0 0 $config.Rule$ 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 $config.Rule$ 0 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $config.Rule$ 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 $config.Rule$ 0 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $config.Rule$ 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 $config.Rule$ 0 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $bucket_point.BucketPoint$ 0 0 0 0 0 0 $bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $BucketPointCondition$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[BucketName,builtins.str]$ 0 $builtins.str$ 0 $typing.List[BucketName]$ 0 $typing.Dict[BucketName,timeline.Timeline]$ 0 0 0 $spytrack.analyze.timeline.Timeline$ 0 $typing.Dict[BucketName,timeline.Timeline]$ 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[BucketName]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $spytrack.analyze.timeline.Timeline$ 0 $typing.Dict[BucketName,timeline.Timeline]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $spytrack.analyze.timeline.Timeline$ 0 0 0 $spytrack.analyze.timeline.Timeline$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
import AnalyzerFacade [EOL] from typing import List , Callable , Any , Type , Dict [EOL] import config [EOL] import analyze [EOL] import typing [EOL] import matched_event [EOL] import _datetime [EOL] import spytrack [EOL] import builtins [EOL] from _datetime import datetime [EOL] from typing import Dict , List , Any , Callable [EOL] from analyze . bucket_type import BucketType [EOL] from analyze . cached_event_repository import CachedEventRepository [EOL] from analyze . event_repository import EventRepository [EOL] from analyze . events_analyzer import EventsAnalyzer [EOL] from config import Config [EOL] from . event import Event [EOL] from . matched_event import MatchedEvent [EOL] from . bucket_point import BucketPoint [EOL] [EOL] ClientBuckets = Dict [ str , Dict [ str , Any ] ] [EOL] Events = List [ Event ] [EOL] BucketName = str [EOL] Buckets = Dict [ BucketName , BucketType ] [EOL] BucketPoints = List [ BucketPoint ] [EOL] BucketPointCondition = Callable [ [ BucketPoint ] , bool ] [EOL] [EOL] [EOL] class AnalyzerFacade : [EOL] browser_buckets_cache = { } [EOL] [EOL] def __init__ ( self , event_repository , config ) : [EOL] self . config = config [EOL] self . event_repository = event_repository [EOL] self . cached_event_repository = CachedEventRepository ( event_repository ) [EOL] self . analyzer = EventsAnalyzer ( ) [EOL] [EOL] def analyze ( self , start_date , end_date , is_current ) : [EOL] buckets = self . event_repository . fetch_buckets ( ) [EOL] [EOL] if is_current : [EOL] events = self . cached_event_repository . get_bucket_events ( list ( buckets . keys ( ) ) , start_date , end_date ) [EOL] else : [EOL] events = self . event_repository . get_bucket_events ( list ( buckets . keys ( ) ) , start_date , end_date ) [EOL] [EOL] analyzed_events = self . analyzer . analyze_events ( buckets , events ) [EOL] return self . analyzer . match ( analyzed_events , self . config . projects ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[BucketName,builtins.str]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[matched_event.MatchedEvent]$ 0 0 0 $_datetime.datetime$ 0 $_datetime.datetime$ 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $_datetime.datetime$ 0 $_datetime.datetime$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $_datetime.datetime$ 0 $_datetime.datetime$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
from typing import List , Callable , Any , Type , Optional , Dict [EOL] import typing [EOL] import bucket_point [EOL] import bucket_type [EOL] import Timeline [EOL] import datetime [EOL] import spytrack [EOL] import builtins [EOL] import datetime [EOL] from typing import Callable , List , Optional , Dict [EOL] from aw_core import Event as ParentEvent [EOL] from . event import Event [EOL] from . bucket_point import BucketPoint [EOL] from . bucket_type import BucketType [EOL] [EOL] Events = List [ Event ] [EOL] BucketPoints = List [ BucketPoint ] [EOL] [EOL] [EOL] class Timeline : [EOL] CutCondition = Callable [ [ BucketPoint ] , bool ] [EOL] [EOL] @ staticmethod def create_from_bucket_events ( bucket_type , events ) : [EOL] all_points = [ ] [EOL] for event in events : [EOL] all_points . append ( BucketPoint ( bucket_type , event . timestamp , event , False ) ) [EOL] all_points . append ( BucketPoint ( bucket_type , event . timestamp + event . duration , event , True ) ) [EOL] [EOL] return Timeline ( bucket_type , all_points ) [EOL] [EOL] def __init__ ( self , bucket_type , points ) : [EOL] self . _bucket_type = bucket_type [EOL] self . points = points [EOL] self . points . sort ( ) [EOL] [EOL] def intersect ( self , spec_timeline , intersect_condition , is_inclusive = True ) : [EOL] [docstring] [EOL] points = self . points [EOL] for point in spec_timeline . points : [EOL] points . append ( point ) [EOL] points . sort ( ) [EOL] [EOL] cut_points = [ ] [EOL] is_exclusive = not is_inclusive [EOL] [comment] [EOL] [comment] [EOL] in_intersection = is_exclusive [EOL] opened_point = None [EOL] for point in points : [EOL] if spec_timeline . _is_source_of_point ( point ) : [EOL] if not intersect_condition ( point ) : [EOL] continue [EOL] [EOL] if not point . is_end ( ) : [EOL] intersection_started = is_inclusive [EOL] else : [EOL] intersection_started = is_exclusive [EOL] intersection_ended = not intersection_started [EOL] [EOL] if opened_point is not None : [EOL] cut_points . append ( BucketPoint ( opened_point . event_type , point . timestamp , opened_point . event , intersection_ended ) ) [EOL] in_intersection = intersection_started [EOL] else : [EOL] if in_intersection : [EOL] cut_points . append ( point ) [EOL] if not point . is_end ( ) : [EOL] opened_point = point [EOL] else : [EOL] opened_point = None [EOL] [EOL] if len ( cut_points ) > [number] : [EOL] self . _filter_empty_points ( cut_points ) [EOL] [EOL] self . points = cut_points [EOL] [EOL] def _is_source_of_point ( self , point ) : [EOL] [comment] [EOL] return point . event_type == self . _bucket_type [EOL] [EOL] def _filter_empty_points ( self , cut_points ) : [EOL] current_time = cut_points [ - [number] ] . timestamp [EOL] close_points = { } [EOL] for i in reversed ( range ( len ( cut_points ) ) ) : [EOL] point = cut_points [ i ] [EOL] if point . timestamp != current_time : [EOL] close_points . clear ( ) [EOL] current_time = point . timestamp [EOL] if point . is_end ( ) : [EOL] close_points [ i ] = point [EOL] elif len ( close_points ) > [number] : [EOL] for index , opened_point in close_points . items ( ) : [EOL] if point . event is opened_point . event : [EOL] del cut_points [ index ] [EOL] del cut_points [ i ] [EOL] [EOL] def get_browser_app ( self , app_timeline ) : [EOL] for point in self . points : [EOL] app_point = app_timeline . _get_event_at ( point . timestamp ) [EOL] if app_point is None : [EOL] continue [EOL] app_point_title = app_point . event_data [ [string] ] [EOL] point_title = point . event_data [ [string] ] [EOL] if app_point_title . startswith ( point_title ) : [EOL] return str ( app_point . event_data [ [string] ] ) [EOL] return None [EOL] [EOL] def _get_event_at ( self , at_time ) : [EOL] last_event = None [EOL] for point in self . points : [EOL] if point . is_end ( ) : [EOL] continue [EOL] if last_event is None : [EOL] if point . timestamp > at_time : [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] elif at_time < point . timestamp : [EOL] return last_event [EOL] last_event = point [EOL] return None [EOL] [EOL] def get_events ( self ) : [EOL] events = [ ] [EOL] for open_i in range ( len ( self . points ) ) : [EOL] open_point = self . points [ open_i ] [EOL] if open_point . is_end ( ) : [EOL] continue [EOL] for close_i in range ( open_i + [number] , len ( self . points ) ) : [EOL] close_point = self . points [ close_i ] [EOL] if not close_point . is_end ( ) : [EOL] continue [EOL] if open_point . event is close_point . event : [EOL] old_event = open_point . event [EOL] event = ParentEvent ( old_event . id , open_point . timestamp , close_point . timestamp - open_point . timestamp , old_event . data ) [EOL] events . append ( Event ( event , open_point . event_type ) ) [EOL] break [EOL] [EOL] return events [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Timeline'$ 0 $bucket_type.BucketType$ 0 $Events$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $Events$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $bucket_type.BucketType$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $bucket_type.BucketType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bucket_type.BucketType$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $bucket_type.BucketType$ 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 0 0 $spytrack.analyze.bucket_type.BucketType$ 0 $bucket_type.BucketType$ 0 0 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $'Timeline'$ 0 $Timeline.CutCondition$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 0 $'Timeline'$ 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 0 0 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $None$ 0 0 0 0 0 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 $'Timeline'$ 0 0 0 0 0 0 0 0 0 $Timeline.CutCondition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 $None$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[spytrack.analyze.bucket_point.BucketPoint]$ 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 $bucket_point.BucketPoint$ 0 0 0 0 0 0 $bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $BucketPoints$ 0 0 0 $datetime.datetime$ 0 $BucketPoints$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,bucket_point.BucketPoint]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $BucketPoints$ 0 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 $BucketPoints$ 0 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 $datetime.datetime$ 0 0 $typing.Dict[builtins.int,bucket_point.BucketPoint]$ 0 0 0 0 0 $datetime.datetime$ 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 0 0 $typing.Dict[builtins.int,bucket_point.BucketPoint]$ 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 $typing.Dict[builtins.int,bucket_point.BucketPoint]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,bucket_point.BucketPoint]$ 0 0 0 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 0 $BucketPoints$ 0 0 0 0 0 $BucketPoints$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $'Timeline'$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[spytrack.analyze.bucket_point.BucketPoint]$ 0 $'Timeline'$ 0 0 0 0 0 0 0 0 0 $typing.Optional[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[spytrack.analyze.bucket_point.BucketPoint]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[bucket_point.BucketPoint]$ 0 0 0 $datetime.datetime$ 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 $Events$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 $typing.Any$ 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 $typing.Any$ 0 0 $spytrack.analyze.event.Event$ 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $spytrack.analyze.event.Event$ 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 $spytrack.analyze.event.Event$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $spytrack.analyze.bucket_point.BucketPoint$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import List , Dict [EOL] import matched_event [EOL] import typing [EOL] import spytrack [EOL] from typing import List , Dict [EOL] from . matched_event import MatchedEvent [EOL] [EOL] [EOL] class PieChartData : [EOL] data = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . data = { } [EOL] [EOL] def count_event ( self , event ) : [EOL] if event . project not in self . data : [EOL] self . data [ event . project ] = [number] [EOL] self . data [ event . project ] += event . duration . total_seconds ( ) [EOL] [EOL] [EOL] def get_pie_chart ( matched_events ) : [EOL] result = PieChartData ( ) [EOL] for event in matched_events : [EOL] result . count_event ( event ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $None$ 0 0 0 $matched_event.MatchedEvent$ 0 0 0 0 $matched_event.MatchedEvent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $matched_event.MatchedEvent$ 0 0 0 0 0 0 0 0 0 0 $matched_event.MatchedEvent$ 0 0 0 0 $matched_event.MatchedEvent$ 0 0 0 0 0 0 0 0 0 0 $PieChartData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import event [EOL] import builtins [EOL] from . event import Event [EOL] [EOL] [EOL] class MatchedEvent ( Event ) : [EOL] project = ... [EOL] rule_id = ... [EOL] [EOL] def __init__ ( self , project , rule_id , event ) : [EOL] super ( ) . __init__ ( event , event . type ) [EOL] self . rule_id = rule_id [EOL] self . project = project [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $event.Event$ 0 0 0 0 0 0 0 0 0 $event.Event$ 0 $event.Event$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0
from typing import Dict [EOL] import typing [EOL] import datetime [EOL] import bucket_type [EOL] import spytrack [EOL] import event [EOL] import builtins [EOL] import datetime [EOL] from typing import Dict [EOL] from . event import Event [EOL] from . bucket_type import BucketType [EOL] [EOL] [EOL] class BucketPoint : [EOL] def __init__ ( self , bucket_type , timestamp , event , is_end ) : [EOL] self . _bucket_type = bucket_type [EOL] self . _is_end = is_end [EOL] self . event = event [EOL] self . timestamp = timestamp [EOL] [EOL] @ property def event_data ( self ) : [EOL] return self . event . data [comment] [EOL] [EOL] @ property def event_type ( self ) : [EOL] return self . _bucket_type [EOL] [EOL] def is_end ( self ) : [EOL] return self . _is_end [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if self . timestamp == other . timestamp : [EOL] return self . event_type == BucketType . AFK \ [EOL] and other . event_type != BucketType . AFK [EOL] return self . timestamp < other . timestamp [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $bucket_type.BucketType$ 0 $datetime.datetime$ 0 $spytrack.analyze.event.Event$ 0 $builtins.bool$ 0 0 0 0 0 $spytrack.analyze.bucket_type.BucketType$ 0 $bucket_type.BucketType$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $spytrack.analyze.event.Event$ 0 $spytrack.analyze.event.Event$ 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bucket_type.BucketType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $'BucketPoint'$ 0 0 0 0 0 0 0 0 $'BucketPoint'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'BucketPoint'$ 0 0 0 0 0 0 0 0 0 0 0 0 $'BucketPoint'$ 0 0 0
from typing import List [EOL] import typing [EOL] from . analyzer_facade import AnalyzerFacade [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
import aw_core [EOL] import spytrack [EOL] import bucket_type [EOL] import builtins [EOL] from aw_core import Event as ParentEvent [EOL] from . bucket_type import BucketType [EOL] [EOL] [EOL] class Event ( ParentEvent ) : [comment] [EOL] def __init__ ( self , event , bucket_type ) : [EOL] super ( ) . __init__ ( event . id , event . timestamp , event . duration , event . data ) [EOL] self . type = bucket_type [EOL] [EOL] def has_equal_data ( self , event ) : [EOL] return self . stringify_data ( ) == event . stringify_data ( ) [EOL] [EOL] def stringify_data ( self ) : [EOL] result = [string] [EOL] if [string] in self . data : [EOL] result += f' [string] { self . data [ [string] ] }' [EOL] if [string] in self . data : [EOL] result += f' [string] { self . data [ [string] ] }' [EOL] if [string] in self . data : [EOL] result += f' [string] { self . data [ [string] ] }' [EOL] [EOL] if len ( result ) == [number] : [EOL] raise Exception [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aw_core.Event$ 0 $bucket_type.BucketType$ 0 0 0 0 0 0 0 0 0 $aw_core.Event$ 0 0 0 $aw_core.Event$ 0 0 0 $aw_core.Event$ 0 0 0 $aw_core.Event$ 0 0 0 0 0 0 $spytrack.analyze.bucket_type.BucketType$ 0 $bucket_type.BucketType$ 0 0 0 $builtins.bool$ 0 0 0 $'Event'$ 0 0 0 0 0 0 0 0 0 0 $'Event'$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
from enum import Enum , auto [EOL] [EOL] [EOL] class BucketType ( Enum ) : [EOL] AFK = auto ( ) [EOL] APP = auto ( ) [EOL] WEB = auto ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import datetime [EOL] import analyze [EOL] import typing [EOL] import builtins [EOL] from datetime import datetime [EOL] from typing import List , Dict [EOL] from analyze . event import Event [EOL] from analyze . event_repository import EventRepository [EOL] [EOL] Events = List [ Event ] [EOL] [EOL] [EOL] class CachedEventRepository : [EOL] def __init__ ( self , event_repository ) : [EOL] self . event_repository = event_repository [EOL] self . events_cache = { } [EOL] self . cached_start_time = datetime . now ( ) [EOL] [EOL] def get_bucket_events ( self , buckets , start_time , end_time ) : [EOL] if not self . _cached_time_matches ( start_time ) : [EOL] self . events_cache . clear ( ) [EOL] self . cached_start_time = start_time [EOL] [EOL] events = { } [EOL] for bucket_name in buckets : [EOL] events [ bucket_name ] = self . get_events ( bucket_name , start_time , end_time ) [EOL] [EOL] return events [EOL] [EOL] def get_events ( self , bucket , start_time , end_time ) : [EOL] if bucket not in self . events_cache or len ( self . events_cache [ bucket ] ) == [number] : [EOL] events = self . event_repository . get_events ( bucket , start_time , end_time ) [EOL] else : [EOL] original_events = self . events_cache [ bucket ] [EOL] last_event = original_events [ [number] ] [EOL] next_start_time = last_event . timestamp . astimezone ( tz = None ) [EOL] next_events = self . event_repository . get_events ( bucket , next_start_time , end_time ) [EOL] next_ids = [ event . id for event in reversed ( next_events ) ] [EOL] if last_event . id not in next_ids : [EOL] [comment] [EOL] events = next_events + original_events [EOL] else : [EOL] last_position = len ( next_ids ) - next_ids . index ( last_event . id ) - [number] [EOL] original_events [ [number] ] = next_events [ last_position ] [EOL] if last_position == len ( next_ids ) - [number] : [EOL] events = next_events + original_events [ [number] : ] [EOL] else : [EOL] events = next_events [ : last_position ] + original_events [EOL] [EOL] self . events_cache [ bucket ] = events [EOL] [EOL] return events [EOL] [EOL] def _cached_time_matches ( self , compared_time ) : [EOL] cached_time = self . cached_start_time . replace ( microsecond = [number] , second = [number] ) [EOL] compared_time = compared_time . replace ( microsecond = [number] , second = [number] ) [EOL] [EOL] return cached_time == compared_time [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Events$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $datetime.datetime$ 0
from typing import List [EOL] import typing [EOL] from runner . runner import Runner [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from time import sleep [EOL] from aw_client import ActivityWatchClient [EOL] from aw_watcher_window . main import heartbeat_loop [EOL] [EOL] [EOL] def windows_watcher_run ( ) : [EOL] client = ActivityWatchClient ( [string] , testing = False ) [EOL] [EOL] bucket_id = [string] . format ( client . client_name , client . client_hostname ) [EOL] event_type = [string] [EOL] [EOL] client . create_bucket ( bucket_id , event_type , queued = True ) [EOL] sleep ( [number] ) [comment] [EOL] with client : [EOL] heartbeat_loop ( client , bucket_id , poll_time = [number] , exclude_title = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from aw_server . server import create_app [EOL] from aw_server . log import FlaskLogHandler [EOL] from aw_datastore import get_storage_methods [EOL] [EOL] [EOL] def server_run ( ) : [EOL] storage_methods = get_storage_methods ( ) [EOL] storage_method = storage_methods [ [string] ] [EOL] [EOL] app = create_app ( storage_method = storage_method , testing = False , cors_origins = [ ] ) [EOL] app . static_folder = [string] [EOL] app . run ( debug = False , host = [string] , port = [number] , request_handler = FlaskLogHandler , use_reloader = False , threaded = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Optional [EOL] import config [EOL] import typing [EOL] import multiprocessing [EOL] import threading [EOL] import types [EOL] import builtins [EOL] import threading [EOL] import multiprocessing [EOL] from time import sleep [EOL] from typing import Union , Optional , Type [EOL] from types import TracebackType [EOL] from aw_core . log import setup_logging [EOL] from config import Config [EOL] from runner . afk import AfkRunner [EOL] from runner . server import server_run [EOL] from runner . windows import windows_watcher_run [EOL] [EOL] [EOL] class Runner : [EOL] process_server = ... [EOL] thread_watcher_awk = ... [EOL] process_watcher_windows = ... [EOL] [EOL] def __init__ ( self , config ) : [EOL] self . config = config [EOL] self . afk_runner = AfkRunner ( ) [EOL] setup_logging ( [string] , testing = False , verbose = False , log_stderr = False , log_file = False ) [EOL] [EOL] def run_all ( self ) : [EOL] if self . config . run_daemon : [EOL] self . process_server = multiprocessing . Process ( target = server_run ) [EOL] self . process_server . start ( ) [EOL] sleep ( [number] ) [EOL] [EOL] self . thread_watcher_awk = threading . Thread ( target = self . afk_runner . run ) [EOL] self . thread_watcher_awk . start ( ) [EOL] [EOL] [comment] [EOL] self . process_watcher_windows = multiprocessing . Process ( target = windows_watcher_run ) [EOL] self . process_watcher_windows . start ( ) [EOL] [EOL] def reload ( self , config ) : [EOL] self . config = config [EOL] self . stop ( ) [EOL] sleep ( [number] ) [EOL] self . run_all ( ) [EOL] [EOL] def stop ( self ) : [EOL] if self . process_server is not None : [EOL] self . process_server . terminate ( ) [EOL] self . process_server = None [EOL] [EOL] self . afk_runner . stop ( ) [EOL] self . process_watcher_windows . terminate ( ) [EOL] [EOL] def __enter__ ( self ) : [EOL] self . run_all ( ) [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] self . stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[multiprocessing.Process,None]$ 0 0 0 $threading.Thread$ 0 0 0 $multiprocessing.Process$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[multiprocessing.context.Process]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[multiprocessing.context.Process]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $multiprocessing.context.Process$ 0 0 0 0 0 0 0 0 0 0 0 0 $multiprocessing.context.Process$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Optional[multiprocessing.context.Process]$ 0 0 0 0 0 0 0 $typing.Optional[multiprocessing.context.Process]$ 0 0 0 0 0 0 0 $typing.Optional[multiprocessing.context.Process]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.Type[builtins.BaseException]]$ 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Optional[types.TracebackType]$ 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from config . config import Config , Rule , Project , Projects [EOL] from config . config_storage import FileConfigStorage as ConfigStorage [EOL] from config . config_storage import get_config_file [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import config [EOL] import typing [EOL] import argparse [EOL] import pathlib [EOL] import yaml [EOL] import argparse [EOL] import appdirs [EOL] from pathlib import Path [EOL] from config . config import Config , ConfigDict [EOL] from config . default_config import default_yaml [EOL] [EOL] [EOL] def get_config_file ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] ) [EOL] args , _ = parser . parse_known_args ( ) [EOL] [EOL] if args . config is None : [EOL] config_dir = appdirs . user_config_dir ( [string] ) [EOL] return Path ( config_dir ) . joinpath ( [string] ) [EOL] else : [EOL] return Path ( args . config ) [EOL] [EOL] [EOL] class ConfigParseException ( BaseException ) : [EOL] pass [EOL] [EOL] [EOL] class FileConfigStorage : [EOL] def __init__ ( self , file ) : [EOL] self . file = file [EOL] [EOL] def load ( self ) : [EOL] try : [EOL] if not self . file . exists ( ) : [EOL] self . file . parent . mkdir ( parents = True , exist_ok = True ) [EOL] values = yaml . safe_load ( default_yaml ) [EOL] self . _persist ( values ) [EOL] else : [EOL] values = yaml . safe_load ( self . file . read_text ( ) ) [EOL] return Config . parse ( values ) [EOL] except yaml . YAMLError : [EOL] raise ConfigParseException [EOL] [EOL] def save ( self , config ) : [EOL] dump = { [string] : { [string] : config . host , [string] : config . port , } , [string] : { [string] : config . run_daemon , [string] : config . interval , [string] : config . start_day_time , [string] : config . projects . to_json ( ) } } [EOL] self . _persist ( dump ) [EOL] [EOL] def _persist ( self , dump ) : [EOL] with self . file . open ( [string] ) as outfile : [EOL] yaml . dump ( dump , outfile , default_flow_style = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $config.config.ConfigDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $config.config.ConfigDict$ 0 $config.config.ConfigDict$ 0 0 0 0 0 0 0 0
default_yaml = [string] [EOL]	$builtins.str$ 0 0 0
from typing import List , Any , Type , Iterator , Dict [EOL] import spytrack [EOL] import typing [EOL] import builtins [EOL] import uuid [EOL] from typing import Dict , Any , List , Iterator [EOL] [EOL] ConfigDict = Dict [ str , Any ] [EOL] [EOL] [EOL] class Rule : [EOL] APP = [string] [EOL] WEB = [string] [EOL] [EOL] def __init__ ( self , values ) : [EOL] if [string] in values : [EOL] self . id = values [ [string] ] [EOL] del values [ [string] ] [EOL] else : [EOL] self . id = str ( uuid . uuid4 ( ) ) [EOL] self . values = values [EOL] [EOL] def to_json ( self ) : [EOL] return self . values [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . to_json ( ) ) [EOL] [EOL] def __getitem__ ( self , item ) : [EOL] return self . values [ item ] [EOL] [EOL] def __contains__ ( self , item ) : [EOL] return item in self . values [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . values ) [EOL] [EOL] def is_web ( self ) : [EOL] return self . values [ [string] ] == Rule . WEB [EOL] [EOL] def is_app ( self ) : [EOL] return self . values [ [string] ] == Rule . APP [EOL] [EOL] [EOL] class Project : [EOL] @ staticmethod def reinstate ( config_project ) : [EOL] return Project ( config_project [ [string] ] , [ Rule ( rule ) for rule in config_project [ [string] ] ] ) [EOL] [EOL] @ staticmethod def create_empty ( none_project ) : [EOL] return Project ( none_project , [ ] ) [EOL] [EOL] def __init__ ( self , name , rules ) : [EOL] self . rules = rules [EOL] self . name = name [EOL] [EOL] def to_json ( self ) : [EOL] return { [string] : self . name , [string] : [ rule . to_json ( ) for rule in self . rules ] } [EOL] [EOL] [EOL] class Projects : [EOL] @ staticmethod def reinstate ( config_projects , none_project ) : [EOL] projects = [ ] [EOL] for config_project in config_projects : [EOL] rules = [ Rule ( rule ) for rule in config_project [ [string] ] ] [EOL] project = Project ( config_project [ [string] ] , rules ) [EOL] projects . append ( project ) [EOL] [EOL] return Projects ( projects , none_project ) [EOL] [EOL] def __init__ ( self , projects , none_project ) : [EOL] self . none_project = none_project [EOL] self . projects = projects [EOL] self . projects . append ( Project . create_empty ( self . none_project ) ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . projects ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . projects ) [EOL] [EOL] def to_json ( self ) : [EOL] return [ project . to_json ( ) for project in self . projects if project . name != self . none_project ] [EOL] [EOL] [EOL] class Config : [EOL] config = ... [EOL] [EOL] @ staticmethod def parse ( values ) : [EOL] port = int ( values [ [string] ] [ [string] ] ) [EOL] host = str ( values [ [string] ] [ [string] ] ) [EOL] interval = int ( values [ [string] ] [ [string] ] ) [EOL] run_daemon = bool ( values [ [string] ] [ [string] ] ) [EOL] start_day_time = str ( values [ [string] ] [ [string] ] ) [EOL] projects = Projects . reinstate ( values [ [string] ] [ [string] ] , str ( uuid . uuid4 ( ) ) ) [EOL] return Config ( port , host , interval , run_daemon , start_day_time , projects ) [EOL] [EOL] def __init__ ( self , port , host , interval , run_daemon , start_day_time , projects ) : [EOL] self . port = port [EOL] self . host = host [EOL] self . interval = interval [EOL] self . run_daemon = run_daemon [EOL] self . start_day_time = start_day_time [EOL] self . projects = projects [EOL] [EOL] def modify ( self , port , host , interval , run_daemon , projects ) : [EOL] return Config ( port , host , interval , run_daemon , self . start_day_time , Projects ( projects , self . projects . none_project ) ) [EOL] [EOL] def get_full_address ( self ) : [EOL] return [string] % ( self . host , self . port ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Project'$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $'Project'$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[spytrack.config.config.Rule]$ 0 0 0 0 0 $typing.List[spytrack.config.config.Rule]$ 0 $typing.List[spytrack.config.config.Rule]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Projects'$ 0 $typing.List[typing.Any]$ 0 $builtins.str$ 0 0 0 $spytrack.config.config.Project$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[spytrack.config.config.Rule]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spytrack.config.config.Project$ 0 0 0 0 0 0 0 0 $typing.List[spytrack.config.config.Rule]$ 0 0 $spytrack.config.config.Project$ 0 0 0 $spytrack.config.config.Project$ 0 0 0 0 0 0 $spytrack.config.config.Project$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $typing.List[spytrack.config.config.Project]$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[spytrack.config.config.Project]$ 0 $typing.List[spytrack.config.config.Project]$ 0 0 0 $typing.List[spytrack.config.config.Project]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Iterator[Project]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ConfigDict$ 0 0 0 0 0 0 0 $'Config'$ 0 $ConfigDict$ 0 0 0 $builtins.int$ 0 0 0 $ConfigDict$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $ConfigDict$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $ConfigDict$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $ConfigDict$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $ConfigDict$ 0 0 0 0 0 0 0 0 $spytrack.config.config.Projects$ 0 0 0 0 0 $ConfigDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.bool$ 0 $typing.Any$ 0 $spytrack.config.config.Projects$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.bool$ 0 $builtins.str$ 0 $spytrack.config.config.Projects$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $spytrack.config.config.Projects$ 0 $spytrack.config.config.Projects$ 0 0 0 $'Config'$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.bool$ 0 $typing.List[Project]$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.List[Project]$ 0 0 0 $typing.List[Project]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0