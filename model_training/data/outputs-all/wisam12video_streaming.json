	0
from faustapp . app import app [EOL] app . main ( ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
import faust [EOL] import os [EOL] import faust [EOL] [EOL] [comment] [EOL] os . environ . setdefault ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] os . environ . setdefault ( [string] , [string] ) [EOL] [EOL] app = faust . App ( [string] , autodiscover = True , origin = [string] ) [EOL] [EOL] [EOL] @ app . on_configured . connect def configure_from_settings ( app , conf , ** kwargs ) : [EOL] from django . conf import settings [EOL] conf . broker = settings . FAUST_BROKER_URL [EOL] conf . store = settings . FAUST_STORE_URL [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0
from django . apps import AppConfig [EOL] [EOL] [EOL] class FaustappConfig ( AppConfig ) : [EOL] name = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
	0
	0
from typing import Type [EOL] import typing [EOL] import examples [EOL] from django . db import models [EOL] from django . utils . translation import ugettext_lazy as _ [EOL] [EOL] [EOL] class Account ( models . Model ) : [EOL] name = models . CharField ( _ ( [string] ) , max_length = [number] ) [EOL] score = models . DecimalField ( _ ( [string] ) , default = [number] , max_digits = [number] , decimal_places = [number] ) [EOL] active = models . BooleanField ( _ ( [string] ) , default = True ) [EOL] [EOL] class Meta : [EOL] verbose_name = _ ( [string] ) [EOL] verbose_name_plural = _ ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[examples.django.accounts.models.Account]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[examples.django.accounts.models.Account]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[examples.django.accounts.models.Account]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[examples.django.accounts.models.Account.Meta]$ 0 0 0 0 0 0 $typing.Type[examples.django.accounts.models.Account.Meta]$ 0 0 0 0 0 0
	0
from django . apps import AppConfig [EOL] [EOL] [EOL] class AccountsConfig ( AppConfig ) : [EOL] name = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import faust [EOL] import builtins [EOL] import typing [EOL] from decimal import Decimal [EOL] import faust [EOL] from faust . types import StreamT [EOL] from faustapp . app import app [EOL] from . models import Account [EOL] [EOL] [EOL] class AccountRecord ( faust . Record ) : [EOL] name = ... [EOL] score = ... [EOL] active = ... [EOL] [EOL] [EOL] @ app . agent ( ) async def add_account ( accounts ) : [EOL] async for account in accounts : [EOL] result = Account . objects . create ( name = account . name , score = Decimal ( str ( account . score ) ) , active = account . active , ) [EOL] yield result . pk [EOL] [EOL] [EOL] @ app . agent ( ) async def disable_account ( account_ids ) : [EOL] async for account_id in account_ids : [EOL] account = Account . objects . get ( pk = account_id ) [EOL] account . active = False [EOL] account . save ( ) [EOL] yield account . active [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import os [EOL] import sys [EOL] os . environ . setdefault ( [string] , [string] ) [EOL] from django . core . management import execute_from_command_line [comment] [EOL] execute_from_command_line ( sys . argv ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from django . conf . urls import url [EOL] from django . contrib import admin [EOL] [EOL] urlpatterns = [ url ( [string] , admin . site . urls ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] from django . core . wsgi import get_wsgi_application [EOL] [EOL] os . environ . setdefault ( [string] , [string] ) [EOL] [EOL] application = get_wsgi_application ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
import faust [EOL] [docstring] [EOL] import faust [EOL] [EOL] [EOL] app = faust . App ( [string] ) [EOL] [EOL] [EOL] @ app . service class MyService ( faust . Service ) : [EOL] [EOL] async def on_start ( self ) : [EOL] self . log . info ( [string] ) [EOL] [EOL] async def on_stop ( self ) : [EOL] self . log . info ( [string] ) [EOL] [EOL] [EOL] @ app . agent ( value_type = str ) async def consumer ( stream ) : [EOL] async for message in stream : [EOL] print ( f' [string] { message !r}' ) [EOL] [EOL] [EOL] @ app . timer ( [number] ) async def producer ( ) : [EOL] await consumer . send ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0
[comment] [EOL] from typing import Any , AsyncIterable [EOL] import faust [EOL] import builtins [EOL] import typing [EOL] from typing import AsyncIterable [EOL] import faust [EOL] from faust import StreamT [EOL] [EOL] [EOL] app = faust . App ( [string] , reply_create_topic = True ) [EOL] pow_topic = app . topic ( [string] ) [EOL] mul_topic = app . topic ( [string] ) [EOL] [EOL] [EOL] @ app . agent ( pow_topic ) async def pow ( stream ) : [EOL] async for value in stream : [EOL] yield await mul . ask ( value = value ** [number] ) [EOL] [EOL] [EOL] @ app . agent ( mul_topic ) async def mul ( stream ) : [EOL] async for value in stream : [EOL] yield value * [number] [EOL] [EOL] [EOL] @ app . timer ( interval = [number] ) async def _sender ( ) : [EOL] [comment] [EOL] res = await pow . join ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] print ( f' [string] { res !r}' ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] async for value in pow . map ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) : [EOL] print ( f' [string] { value !r}' ) [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.topics.TopicT$ 0 $faust.app.base.App$ 0 0 0 0 0 0 $faust.types.topics.TopicT$ 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 $faust.types.topics.TopicT$ 0 0 0 $typing.AsyncIterable[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 $faust.types.topics.TopicT$ 0 0 0 $typing.AsyncIterable[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import builtins [EOL] import datetime [EOL] import typing [EOL] import faust [EOL] [docstring] [EOL] import asyncio [EOL] import random [EOL] from datetime import datetime , timezone [EOL] from itertools import count [EOL] import faust [EOL] from faust . cli import option [EOL] [EOL] [EOL] class Withdrawal ( faust . Record , isodates = True , serializer = [string] ) : [EOL] user = ... [EOL] country = ... [EOL] amount = ... [EOL] date = None [EOL] [EOL] [EOL] app = faust . App ( [string] , broker = [string] , store = [string] , origin = [string] , topic_partitions = [number] , ) [EOL] withdrawals_topic = app . topic ( [string] , value_type = Withdrawal ) [EOL] foo_topic = app . topic ( [string] , value_type = Withdrawal ) [EOL] [EOL] withdrawal_counts = app . Table ( [string] , default = int ) [EOL] seen_events = [number] [EOL] [EOL] [EOL] @ app . agent ( withdrawals_topic , isolated_partitions = True ) async def track_user_withdrawal ( withdrawals ) : [EOL] global seen_events [EOL] i = [number] [EOL] async for _withdrawal in withdrawals : [comment] [EOL] event = withdrawals . current_event [EOL] assert event . message . tp in withdrawals . active_partitions [EOL] i += [number] [EOL] seen_events += [number] [EOL] withdrawal_counts [ _withdrawal . user ] += [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ app . task async def report_progress ( app ) : [EOL] prev_count = [number] [EOL] while not app . should_stop : [EOL] await app . sleep ( [number] ) [EOL] if seen_events <= prev_count : [EOL] print ( f' [string] { prev_count } [string] { seen_events }' ) [EOL] else : [EOL] print ( f' [string] { prev_count } [string] { seen_events }' ) [EOL] prev_count = seen_events [EOL] [EOL] [EOL] @ app . command ( option ( [string] , type = float , default = [number] , envvar = [string] , help = [string] ) , option ( [string] , type = int , default = None , help = [string] ) , ) async def produce ( self , max_latency , max_messages ) : [EOL] [docstring] [EOL] for i , withdrawal in enumerate ( generate_withdrawals ( max_messages ) ) : [EOL] await withdrawals_topic . send ( key = withdrawal . user , value = withdrawal ) [EOL] if not i % [number] : [EOL] self . say ( f' [string] { i }' ) [EOL] if max_latency : [EOL] await asyncio . sleep ( random . uniform ( [number] , max_latency ) ) [EOL] [EOL] [EOL] def generate_withdrawals ( n = None ) : [EOL] for d in generate_withdrawals_dict ( n ) : [EOL] yield Withdrawal ( ** d ) [EOL] [EOL] [EOL] def generate_withdrawals_dict ( n = None ) : [EOL] num_countries = [number] [EOL] countries = [ f' [string] { i }' for i in range ( num_countries ) ] [EOL] country_dist = [ [number] ] + ( [ [number] / num_countries ] * ( num_countries - [number] ) ) [EOL] num_users = [number] [EOL] users = [ f' [string] { i }' for i in range ( num_users ) ] [EOL] for _ in range ( n ) if n is not None else count ( ) : [EOL] yield { [string] : random . choice ( users ) , [string] : random . uniform ( [number] , [number] ) , [string] : random . choices ( countries , country_dist ) [ [number] ] , [string] : datetime . utcnow ( ) . replace ( tzinfo = timezone . utc ) . isoformat ( ) , } [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import sys [EOL] if len ( sys . argv ) < [number] : [EOL] sys . argv . extend ( [ [string] , [string] , [string] ] ) [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import json [EOL] from random import random [EOL] from kafka import KafkaProducer [EOL] [EOL] TOPIC = [string] [EOL] KEY = [string] [EOL] [EOL] [EOL] def publish_message ( producer_instance , topic_name , key , value ) : [EOL] try : [EOL] key_bytes = bytes ( key , encoding = [string] ) [EOL] value_bytes = bytes ( value , encoding = [string] ) [EOL] producer_instance . send ( topic_name , key = key_bytes , value = value_bytes ) [EOL] producer_instance . flush ( ) [EOL] print ( [string] ) [EOL] except Exception as ex : [EOL] print ( [string] ) [EOL] print ( ex ) [EOL] [EOL] [EOL] def connect_kafka_producer ( ) : [EOL] _producer = None [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _producer = KafkaProducer ( bootstrap_servers = [ [string] ] , api_version = ( [number] , [number] ) ) [EOL] except Exception as ex : [EOL] print ( [string] ) [EOL] print ( ex ) [EOL] finally : [EOL] return _producer [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] kafka_producer = connect_kafka_producer ( ) [EOL] for index in range ( [number] , [number] ) : [EOL] message = { [string] : index , [string] : round ( random ( ) , [number] ) , } [EOL] publish_message ( kafka_producer , TOPIC , KEY , json . dumps ( message ) ) [EOL] if kafka_producer is not None : [EOL] kafka_producer . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
import faust [EOL] import faust [EOL] from time import monotonic [EOL] [EOL] app = faust . App ( [string] , version = [number] , stream_buffer_maxsize = [number] , ) [EOL] [EOL] benchmark_topic = app . topic ( [string] ) [EOL] [EOL] [EOL] @ app . agent ( benchmark_topic ) async def process ( stream ) : [EOL] time_start = None [EOL] async for i , value in stream . enumerate ( ) : [EOL] if time_start is None : [EOL] time_start = monotonic ( ) [EOL] if not i % [number] : [EOL] now = monotonic ( ) [EOL] print ( f' [string] { now - time_start }' ) [EOL] time_start = now [EOL] [EOL] [EOL] @ app . command ( ) async def produce ( ) : [EOL] for i in range ( [number] ) : [EOL] await process . send ( value = i ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import sys [EOL] if len ( sys . argv ) == [number] : [EOL] sys . argv . extend ( [ [string] , [string] , [string] ] ) [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.topics.TopicT$ 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 $faust.types.topics.TopicT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.app.base.App$ 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] REFBASE = [string] [EOL] REFS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] from typing import Any [EOL] from faust . models import Record [EOL] from faust . types import K , ModelT [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] class ReqRepRequest ( Record , serializer = [string] , namespace = [string] , allow_blessed_key = True ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] value = ... [EOL] reply_to = ... [EOL] correlation_id = ... [EOL] [EOL] [EOL] class ModelReqRepRequest ( ReqRepRequest ) : [EOL] [docstring] [EOL] [EOL] value = ... [EOL] [EOL] [EOL] class ReqRepResponse ( Record , serializer = [string] , namespace = [string] ) : [EOL] [docstring] [EOL] [EOL] key = ... [EOL] value = ... [EOL] correlation_id = ... [EOL] [EOL] [EOL] class ModelReqRepResponse ( ReqRepResponse ) : [EOL] value = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.ModelT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.K$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Any , Set , MutableMapping , MutableSet , Dict , Callable [EOL] import faust [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from collections import defaultdict [EOL] from typing import Any , Dict , MutableMapping , MutableSet , Set [EOL] from weakref import WeakSet [EOL] from mode import Service [EOL] from mode . utils . collections import ManagedUserDict [EOL] from mode . utils . compat import OrderedDict [EOL] from faust . types import AgentManagerT , AgentT , AppT [EOL] from faust . types . tuples import TP , tp_set_to_map [EOL] from faust . utils . tracing import traced_from_parent_span [EOL] [EOL] [EOL] class AgentManager ( Service , AgentManagerT , ManagedUserDict ) : [EOL] [docstring] [EOL] [EOL] _by_topic = ... [EOL] [EOL] def __init__ ( self , app , ** kwargs ) : [EOL] self . app = app [EOL] self . data = OrderedDict ( ) [EOL] self . _by_topic = defaultdict ( WeakSet ) [EOL] Service . __init__ ( self , ** kwargs ) [EOL] [EOL] async def on_start ( self ) : [EOL] [docstring] [EOL] self . update_topic_index ( ) [EOL] for agent in self . values ( ) : [EOL] await agent . maybe_start ( ) [EOL] [EOL] def service_reset ( self ) : [EOL] [docstring] [EOL] [ agent . service_reset ( ) for agent in self . values ( ) ] [EOL] super ( ) . service_reset ( ) [EOL] [EOL] async def on_stop ( self ) : [EOL] [docstring] [EOL] for agent in self . values ( ) : [EOL] try : [EOL] await asyncio . shield ( agent . stop ( ) ) [EOL] except asyncio . CancelledError : [EOL] pass [EOL] [EOL] async def stop ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . cancel ( ) [EOL] [comment] [EOL] await super ( ) . stop ( ) [EOL] [EOL] def cancel ( self ) : [EOL] [docstring] [EOL] [ agent . cancel ( ) for agent in self . values ( ) ] [EOL] [EOL] def update_topic_index ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] by_topic_index = self . _by_topic [EOL] for agent in self . values ( ) : [EOL] for topic in agent . get_topic_names ( ) : [EOL] by_topic_index [ topic ] . add ( agent ) [EOL] [EOL] async def on_rebalance ( self , revoked , newly_assigned ) : [EOL] [docstring] [EOL] T = traced_from_parent_span ( ) [EOL] [comment] [EOL] [comment] [EOL] for agent , tps in self . _collect_agents_for_update ( revoked ) . items ( ) : [EOL] await T ( agent . on_partitions_revoked ) ( tps ) [EOL] [comment] [EOL] [comment] [EOL] for agent , tps in T ( self . _collect_agents_for_update ) ( newly_assigned ) . items ( ) : [EOL] await T ( agent . on_partitions_assigned ) ( tps ) [EOL] [EOL] def _collect_agents_for_update ( self , tps ) : [EOL] by_agent = defaultdict ( set ) [EOL] for topic , tps in tp_set_to_map ( tps ) . items ( ) : [EOL] for agent in self . _by_topic [ topic ] : [EOL] by_agent [ agent ] . update ( tps ) [EOL] return by_agent [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.MutableSet[faust.types.AgentT]]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.MutableSet[faust.types.agents.AgentT]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.MutableSet[faust.types.agents.AgentT]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.MutableSet[faust.types.agents.AgentT]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[faust.types.AgentT,typing.Set[faust.types.tuples.TP]]$ 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 $typing.Dict[faust.types.AgentT,typing.Set[faust.types.tuples.TP]]$ 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[faust.types.AgentT,typing.Set[faust.types.tuples.TP]]$ 0 0 0 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 $typing.Dict[faust.types.AgentT,typing.Set[faust.types.tuples.TP]]$ 0
	0
	0
	0
	0
	0
	0
from typing import Any , List [EOL] import builtins [EOL] import raven [EOL] import typing [EOL] import logging [EOL] import os [EOL] from typing import List [EOL] from raven import Client [EOL] from raven . handlers . logging import SentryHandler [EOL] from raven_aiohttp import AioHttpTransport [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] broker = os . environ . get ( [string] , [string] ) [EOL] store = os . environ . get ( [string] , [string] ) [EOL] topic_partitions = int ( os . environ . get ( [string] , [number] ) ) [EOL] sentry_dsn = os . environ . get ( [string] ) [EOL] [EOL] [EOL] def loghandlers ( ) : [EOL] handlers = [ ] [EOL] if sentry_dsn : [EOL] client = Client ( dsn = sentry_dsn , include_paths = [ __name__ . split ( [string] , [number] ) [ [number] ] ] , transport = AioHttpTransport , disable_existing_loggers = False , ) [EOL] handler = SentryHandler ( client ) [EOL] handler . setLevel ( logging . ERROR ) [EOL] handler . propagate = False [EOL] handlers . append ( handler ) [EOL] return handlers [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[raven.handlers.logging.SentryHandler]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import typing [EOL] OK = [string] [EOL] FAIL = [string] [EOL] SLOW = [string] [EOL] STALL = [string] [EOL] UNASSIGNED = [string] [EOL] REBALANCING = [string] [EOL] PAUSED = [string] [EOL] [EOL] OK_STATES = { OK , UNASSIGNED } [EOL] MAYBE_STATES = { REBALANCING , PAUSED } [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Set[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0
import jinja2 [EOL] from jinja2 import Environment , PackageLoader , select_autoescape [EOL] [EOL] env = Environment ( loader = PackageLoader ( [string] , [string] ) , autoescape = select_autoescape ( [ [string] , [string] ] ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List [EOL] import typing [EOL] from . app import app [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
	0
	0
import sys [EOL] from pathlib import Path [EOL] import pytest [EOL] [EOL] sys . path . append ( str ( Path ( __file__ ) . parent ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def app ( ) : [EOL] from proj323 import faust [EOL] faust . app = faust . create_app ( ) [EOL] return faust . app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import io [EOL] import typing [EOL] import asyncio [EOL] import io [EOL] import os [EOL] import sys [EOL] from contextlib import ExitStack , redirect_stderr , redirect_stdout [EOL] import pytest [EOL] from mode . utils . mocks import patch [EOL] [EOL] [EOL] def test_main ( * , app , loop ) : [EOL] from proj324 import main [EOL] [EOL] neu_loop = asyncio . set_event_loop ( asyncio . new_event_loop ( ) ) [comment] [EOL] [EOL] [comment] [EOL] stdout = io . StringIO ( ) [EOL] stderr = io . StringIO ( ) [EOL] environ = dict ( os . environ ) [EOL] try : [EOL] with ExitStack ( ) as stack : [EOL] stack . enter_context ( patch ( [string] , [ [string] , [string] ] ) ) [EOL] assert sys . argv == [ [string] , [string] ] [EOL] stack . enter_context ( pytest . raises ( SystemExit ) ) [EOL] stack . enter_context ( redirect_stdout ( stdout ) ) [EOL] stack . enter_context ( redirect_stderr ( stderr ) ) [EOL] [EOL] main ( ) [EOL] finally : [EOL] os . environ . clear ( ) [EOL] os . environ . update ( environ ) [EOL] print ( f' [string] { stdout . getvalue ( ) !r}' ) [EOL] print ( f' [string] { stderr . getvalue ( ) !r}' ) [EOL] assert [string] not in stdout . getvalue ( ) [EOL] assert [string] not in stdout . getvalue ( ) [EOL] assert [string] in stdout . getvalue ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] import builtins [EOL] import faust [EOL] from typing import List [EOL] import faust [EOL] [EOL] [EOL] class Point ( faust . Record ) : [EOL] x = ... [EOL] y = ... [EOL] [EOL] [EOL] class Arena ( faust . Record ) : [EOL] points = ... [EOL] timestamp = None [EOL] [EOL] [EOL] app = faust . App ( [string] , origin = [string] ) [EOL] add_topic = app . topic ( [string] ) [EOL] local_channel = app . channel ( ) [EOL] [EOL] [EOL] @ app . agent ( ) async def mul ( stream ) : [EOL] [docstring] [EOL] async for event in stream : [EOL] yield event * [number] [EOL] [EOL] [EOL] @ app . agent ( add_topic ) async def add ( stream ) : [EOL] async for event in stream : [EOL] yield event + [number] [EOL] [EOL] [EOL] @ app . agent ( local_channel ) async def internal ( stream ) : [EOL] async for event in stream : [EOL] yield event / [number] [EOL] [EOL] [EOL] @ app . command ( ) async def error_command ( ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any , Type , Tuple [EOL] import faust [EOL] import typing [EOL] import builtins [EOL] import subprocess [EOL] import pathlib [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Callable , Tuple [EOL] from faust . types import AppT [EOL] from faust . utils . json import loads [EOL] import pytest [EOL] from t . integration import app as _app_module [EOL] [EOL] [EOL] @ pytest . fixture def app ( ) : [EOL] os . environ . pop ( [string] , None ) [EOL] os . environ . pop ( [string] , None ) [EOL] os . environ . pop ( [string] , None ) [EOL] os . environ . pop ( [string] , None ) [EOL] return _app_module . app [EOL] [EOL] [EOL] @ pytest . fixture def main_path ( ) : [EOL] return Path ( _app_module . __file__ ) . with_suffix ( [string] ) [EOL] [EOL] [EOL] CommandReturns = Tuple [ int , str , str ] [EOL] [EOL] [EOL] def _create_faust_cli ( executable , * partial_args , color = False , json = False ) : [EOL] if not color : [EOL] partial_args += ( [string] , ) [EOL] if json : [EOL] partial_args += ( [string] , ) [EOL] [EOL] def call_faust_cli ( * args ) : [EOL] p = subprocess . Popen ( [ sys . executable , str ( executable ) ] + list ( partial_args ) + list ( args ) , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = False , ) [EOL] stdout , stderr = p . communicate ( ) [EOL] if json : [EOL] print ( f' [string] { p . returncode } [string] { stdout !r} [string] { stderr !r}' ) [EOL] ret = p . returncode , loads ( stdout ) , stderr [EOL] return ret [EOL] print ( f' [string] { p . returncode } [string] { stdout !r} [string] { stderr !r}' ) [EOL] return p . returncode , stdout , stderr [EOL] return call_faust_cli [EOL] [EOL] [EOL] @ pytest . fixture def faust ( main_path ) : [EOL] return _create_faust_cli ( main_path ) [EOL] [EOL] [EOL] @ pytest . fixture def faust_json ( main_path ) : [EOL] return _create_faust_cli ( main_path , json = True ) [EOL] [EOL] [EOL] @ pytest . fixture def faust_color ( main_path ) : [EOL] return _create_faust_cli ( main_path , color = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,CommandReturns]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,CommandReturns]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,CommandReturns]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
def test_command_returns_nonzero_exit_status ( * , faust ) : [EOL] exitcode , stdout , stderr = faust ( [string] ) [EOL] assert not stdout [EOL] assert stderr [EOL] assert exitcode [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class test_Arena : [EOL] [EOL] def test_json ( self , faust_json ) : [EOL] exitcode , model , stderr = faust_json ( [string] , [string] ) [EOL] assert not exitcode [EOL] [EOL] assert model == [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] [EOL] def test_tabulated ( self , faust ) : [EOL] exitcode , stdout , stderr = faust ( [string] , [string] ) [EOL] assert not exitcode [EOL] assert [string] in stdout [EOL] [EOL] def test_colors ( self , faust_color ) : [EOL] exitcode , stdout , stderr = faust_color ( [string] , [string] ) [EOL] assert [string] in stdout [EOL] [EOL] [EOL] class test_Point : [EOL] [EOL] def test_json ( self , faust_json ) : [EOL] exitcode , model , stderr = faust_json ( [string] , [string] ) [EOL] assert not exitcode [EOL] [EOL] assert model == [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] [EOL] def test_tabulated ( self , faust ) : [EOL] exitcode , stdout , stderr = faust ( [string] , [string] ) [EOL] assert not exitcode [EOL] assert [string] in stdout [EOL] [EOL] def test_colors ( self , faust_color ) : [EOL] exitcode , stdout , stderr = faust_color ( [string] , [string] ) [EOL] assert not exitcode [EOL] assert [string] in stdout [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] def test_json ( faust_json ) : [EOL] exitcode , agents , stderr = faust_json ( [string] , [string] ) [EOL] assert not exitcode [EOL] [EOL] assert { [string] : [string] , [string] : [string] , [string] : [string] } in agents [EOL] assert { [string] : [string] , [string] : [string] , [string] : [string] } in agents [EOL] assert { [string] : [string] , [string] : [string] , [string] : [string] } in agents [EOL] [EOL] names = [ agent [ [string] ] for agent in agents ] [EOL] assert names . index ( [string] ) < names . index ( [string] ) < names . index ( [string] ) [EOL] [EOL] [EOL] def test_tabulated ( faust ) : [EOL] exitcode , stdout , stderr = faust ( [string] , [string] ) [EOL] assert not exitcode [EOL] assert [string] in stdout [EOL] [EOL] [EOL] def test_colors ( faust_color ) : [EOL] exitcode , stdout , stderr = faust_color ( [string] , [string] ) [EOL] assert not exitcode [EOL] assert [string] in stdout [EOL] [EOL] [EOL] def test_json_no_local ( faust_json ) : [EOL] exitcode , agents , stderr = faust_json ( [string] ) [EOL] assert not exitcode [EOL] [EOL] names = [ agent [ [string] ] for agent in agents ] [EOL] assert [string] in names [EOL] assert [string] in names [EOL] assert [string] not in names [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] import asyncio [EOL] from mode . utils . aiter import anext [EOL] import pytest [EOL] from t . helpers import message [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] async def channel_empty ( channel , * , timeout = [number] ) : [EOL] assert channel . empty ( ) [EOL] with pytest . raises ( asyncio . TimeoutError ) : [EOL] await channel . get ( timeout = timeout ) [EOL] return True [EOL] [EOL] [EOL] async def times_out ( coro , * , timeout = [number] ) : [EOL] with pytest . raises ( asyncio . TimeoutError ) : [EOL] await asyncio . wait_for ( coro , timeout = timeout ) [EOL] return True [EOL] [EOL] [EOL] async def is_empty ( it , * , timeout = [number] ) : [EOL] return await times_out ( anext ( it ) , timeout = timeout ) [EOL] [EOL] [EOL] async def put ( channel , key = None , value = None , ** kwargs ) : [EOL] msg = message ( key = key , value = value , ** kwargs ) [EOL] await channel . deliver ( msg ) [EOL] return msg [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from faust . agents import current_agent [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_sets_current_agent ( * , app , event_loop ) : [EOL] assert current_agent ( ) is None [EOL] [EOL] agent_body_executed = event_loop . create_future ( ) [EOL] [EOL] @ app . agent ( ) async def agent ( stream ) : [EOL] agent_body_executed . set_result ( True ) [EOL] assert current_agent ( ) is agent [EOL] async for item in stream : [EOL] ... [EOL] [EOL] await agent . start ( ) [EOL] await agent_body_executed [EOL] await agent . stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List , Set , Mapping [EOL] import builtins [EOL] import typing [EOL] from typing import Mapping [EOL] from mode import setup_logging [EOL] import pytest [EOL] from . app import simple [EOL] [EOL] [EOL] setup_logging ( loglevel = [string] ) [EOL] [EOL] [EOL] def _build_data ( i ) : [EOL] return { [string] : { [string] : { [string] : { [string] : { [string] : i } } } } } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_simple_ask ( ) : [EOL] for i in range ( [number] ) : [EOL] value = _build_data ( i ) [EOL] assert await simple . ask ( value = value ) == value [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_simple_map ( ) : [EOL] values = [ _build_data ( i ) for i in range ( [number] ) ] [EOL] check = set ( range ( [number] ) ) [EOL] replies = set ( ) [EOL] async for reply in simple . map ( values ) : [EOL] v = reply [ [string] ] [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] assert v in check [EOL] replies . add ( v ) [EOL] assert replies == check [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] from mode . utils . mocks import Mock [EOL] from faust . livecheck . locals import current_execution , current_execution_stack [EOL] [EOL] [EOL] def test_current_execution ( ) : [EOL] m1 = Mock ( name = [string] ) [EOL] assert current_execution ( ) is None [EOL] with current_execution_stack . push ( m1 ) : [EOL] assert current_execution ( ) is m1 [EOL] m2 = Mock ( name = [string] ) [EOL] with current_execution_stack . push ( m2 ) : [EOL] assert current_execution ( ) is m2 [EOL] m3 = Mock ( name = [string] ) [EOL] with current_execution_stack . push ( m3 ) : [EOL] assert current_execution ( ) is m3 [EOL] assert current_execution ( ) is m2 [EOL] assert current_execution ( ) is m1 [EOL] assert current_execution ( ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import types [EOL] from types import SimpleNamespace [EOL] import pytest [EOL] from mode . utils . mocks import Mock [EOL] from faust . livecheck . locals import current_test_stack [EOL] from faust . livecheck . patches . aiohttp import ( LiveCheckMiddleware , patch_aiohttp_session , ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_patch_aiohttp_session ( * , execution ) : [EOL] [EOL] patch_aiohttp_session ( ) [EOL] from aiohttp . client import ClientSession [EOL] trace_configs = [ ] [EOL] async with ClientSession ( trace_configs = trace_configs ) : [EOL] assert trace_configs [EOL] config = trace_configs [ - [number] ] [EOL] on_request_start = config . on_request_start [ - [number] ] [EOL] [EOL] session = Mock ( ) [EOL] ctx = SimpleNamespace ( ) [EOL] params = Mock ( ) [EOL] params . headers = { } [EOL] [EOL] assert current_test_stack . top is None [EOL] [EOL] await on_request_start ( session , ctx , params ) [EOL] [EOL] with current_test_stack . push ( execution ) : [EOL] await on_request_start ( session , ctx , params ) [EOL] assert params . headers [EOL] assert [string] in params . headers [EOL] [EOL] async with ClientSession ( trace_configs = None ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_LiveCheckMiddleware ( * , execution ) : [EOL] request = Mock ( ) [EOL] request . headers = execution . as_headers ( ) [EOL] assert current_test_stack . top is None [EOL] [EOL] called = [ False ] [EOL] [EOL] async def handler ( request ) : [EOL] called [ [number] ] = True [EOL] assert current_test_stack . top is not None [EOL] [EOL] await LiveCheckMiddleware ( ) ( request , handler ) [EOL] [EOL] assert current_test_stack . top is None [EOL] assert called [ [number] ] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_LiveCheckMiddleware__no_test ( * , execution ) : [EOL] request = Mock ( ) [EOL] request . headers = { } [EOL] assert current_test_stack . top is None [EOL] [EOL] called = [ False ] [EOL] [EOL] async def handler ( request ) : [EOL] called [ [number] ] = True [EOL] assert current_test_stack . top is None [EOL] [EOL] await LiveCheckMiddleware ( ) ( request , handler ) [EOL] [EOL] assert current_test_stack . top is None [EOL] assert called [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import os [EOL] import pytest [EOL] from faust . types . _env import _getenv [EOL] [EOL] [EOL] def test_getenv_not_set ( ) : [EOL] os . environ . pop ( [string] , None ) [EOL] with pytest . raises ( KeyError ) : [EOL] _getenv ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from mode . utils . mocks import Mock [EOL] [EOL] [EOL] @ pytest . fixture ( ) def context ( * , app , request ) : [EOL] context = Mock ( ) [EOL] context . app = app [EOL] context . find_root . return_value = context [EOL] return context [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import click . exceptions [EOL] import pytest [EOL] from yarl import URL [EOL] from faust . cli . params import CaseInsensitiveChoice , TCPPort , URLParam [EOL] [EOL] [EOL] def test_CaseInsensitiveChoice ( ) : [EOL] choices = CaseInsensitiveChoice ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] assert choices . convert ( [string] , None , None ) == [string] [EOL] assert choices . convert ( [string] , None , None ) == [string] [EOL] assert choices . convert ( [string] , None , None ) == [string] [EOL] assert choices . convert ( [string] , None , None ) == [string] [EOL] [EOL] with pytest . raises ( click . exceptions . BadParameter ) : [EOL] choices . convert ( [string] , None , None ) [EOL] [EOL] [EOL] def test_TCPPort ( ) : [EOL] port = TCPPort ( ) [EOL] assert port . convert ( [number] , None , None ) == [number] [EOL] assert port . convert ( [number] , None , None ) == [number] [EOL] assert port . convert ( [number] , None , None ) == [number] [EOL] with pytest . raises ( click . exceptions . BadParameter ) : [EOL] port . convert ( [number] , None , None ) [EOL] with pytest . raises ( click . exceptions . BadParameter ) : [EOL] port . convert ( - [number] , None , None ) [EOL] with pytest . raises ( click . exceptions . BadParameter ) : [EOL] port . convert ( [number] , None , None ) [EOL] with pytest . raises ( click . exceptions . BadParameter ) : [EOL] port . convert ( [number] , None , None ) [EOL] [EOL] [EOL] def test_URLParam ( ) : [EOL] urlp = URLParam ( ) [EOL] assert repr ( urlp ) == [string] [EOL] [EOL] url = urlp . convert ( [string] , None , None ) [EOL] assert isinstance ( url , URL ) [EOL] assert url . host == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union [EOL] import typing [EOL] import pytz [EOL] import pytz [EOL] from freezegun import freeze_time [EOL] from faust . utils . cron import secs_for_next [EOL] [EOL] SECS_IN_HOUR = [number] * [number] [EOL] [EOL] [EOL] @ freeze_time ( [string] ) def test_secs_for_next ( ) : [EOL] every_minute_cron_format = [string] [EOL] assert secs_for_next ( every_minute_cron_format ) == [number] [EOL] [EOL] every_8pm_cron_format = [string] [EOL] assert secs_for_next ( every_8pm_cron_format ) == [number] * SECS_IN_HOUR [EOL] [EOL] every_4th_july_1pm_cron_format = [string] [EOL] days_until_4th_july = [number] + [number] + [number] + [number] + [number] + [number] + [number] [EOL] secs_until_4th_july = SECS_IN_HOUR * [number] * days_until_4th_july [EOL] secs_until_1_pm = [number] * SECS_IN_HOUR [EOL] total_secs = secs_until_4th_july + secs_until_1_pm [EOL] assert secs_for_next ( every_4th_july_1pm_cron_format ) == total_secs [EOL] [EOL] [EOL] @ freeze_time ( [string] ) def test_secs_for_next_with_tz ( ) : [EOL] pacific = pytz . timezone ( [string] ) [EOL] [EOL] every_8pm_cron_format = [string] [EOL] [comment] [EOL] assert secs_for_next ( every_8pm_cron_format , tz = pacific ) == [number] * SECS_IN_HOUR [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from datetime import datetime , timezone [EOL] from faust . utils . _iso8601_python import InvalidTZ , parse , parse_tz [EOL] [EOL] [EOL] def test_python ( ) : [EOL] dt1 = datetime . now ( ) . astimezone ( timezone . utc ) [EOL] dt2 = parse ( dt1 . isoformat ( ) ) [EOL] assert dt1 == dt2 [EOL] [EOL] [EOL] def test_timezone_no_sep ( ) : [EOL] dt = parse ( [string] ) [EOL] assert dt . tzinfo [EOL] assert str ( dt . tzinfo ) == [string] [EOL] [EOL] [EOL] def test_parse_error ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] parse ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , ] ) def test_parse_tz ( tz ) : [EOL] assert parse_tz ( tz ) is not None [EOL] [EOL] [EOL] def test_parse_tz__no_match ( ) : [EOL] with pytest . raises ( InvalidTZ ) : [EOL] parse_tz ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import logging [EOL] from faust . utils . terminal . spinners import Spinner , SpinnerHandler [EOL] from mode . utils . mocks import Mock , call , patch [EOL] [EOL] [EOL] def spinner ( file = None , isatty = True ) : [EOL] file = file if file is not None else Mock ( name = [string] ) [EOL] file . isatty . return_value = isatty [EOL] return Spinner ( file ) [EOL] [EOL] [EOL] class test_Spinner : [EOL] [EOL] def spinner ( self , file = None , isatty = True ) : [EOL] return spinner ( file = file , isatty = isatty ) [EOL] [EOL] def test_constructor ( self ) : [EOL] f = Mock ( name = [string] ) [EOL] spinner = self . spinner ( f ) [EOL] assert spinner . file is f [EOL] assert spinner . width == [number] [EOL] assert spinner . count == [number] [EOL] assert not spinner . stopped [EOL] [EOL] def test_update ( self ) : [EOL] s = self . spinner ( ) [EOL] assert s . count == [number] [EOL] s . begin = Mock ( name = [string] ) [EOL] s . write = Mock ( name = [string] ) [EOL] s . update ( ) [EOL] s . begin . assert_called_once_with ( ) [EOL] assert s . count == [number] [EOL] s . write . assert_called_once_with ( s . sprites [ [number] ] ) [EOL] [EOL] for i in range ( [number] ) : [EOL] s . update ( ) [EOL] s . begin . assert_called_once_with ( ) [EOL] assert s . count == i + [number] [EOL] s . write . assert_called_with ( s . sprites [ ( s . count - [number] ) % len ( s . sprites ) ] ) [EOL] count = s . count [EOL] s . stop ( ) [EOL] assert s . stopped [EOL] s . update ( ) [EOL] assert s . count == count [EOL] [EOL] def test_reset ( self ) : [EOL] s = self . spinner ( isatty = True ) [EOL] s . reset ( ) [EOL] assert not s . stopped [EOL] assert s . count == [number] [EOL] [EOL] def test_write ( self ) : [EOL] s = self . spinner ( isatty = True ) [EOL] s . write ( [string] ) [EOL] s . file . write . assert_has_calls ( [ call ( [string] ) , call ( [string] ) , ] ) [EOL] s . file . flush . assert_called_once_with ( ) [EOL] [EOL] def test_write__notatty ( self ) : [EOL] s = self . spinner ( isatty = False ) [EOL] s . write ( [string] ) [EOL] s . file . write . assert_not_called ( ) [EOL] [EOL] def test_begin ( self ) : [EOL] s = self . spinner ( ) [EOL] with patch ( [string] ) as atexit_register : [EOL] s . begin ( ) [EOL] s . file . write . assert_has_calls ( [ call ( s . cursor_hide ) , call ( [string] ) , ] ) [EOL] s . file . flush . assert_called_once_with ( ) [EOL] atexit_register . assert_called_with ( type ( s ) . _finish , s . file , at_exit = True ) [EOL] [EOL] def test_finish ( self ) : [EOL] s = self . spinner ( ) [EOL] s . finish ( ) [EOL] s . file . write . assert_has_calls ( [ call ( s . bell ) , call ( [string] ) , call ( s . cursor_show ) , call ( [string] ) , ] ) [EOL] s . file . flush . assert_called_once_with ( ) [EOL] assert s . stopped [EOL] [EOL] [EOL] def test_SpinnerHandler ( ) : [EOL] s = Mock ( name = [string] , autospec = Spinner ) [EOL] s . stopped = False [EOL] handler = SpinnerHandler ( spinner = s ) [EOL] assert handler . spinner is s [EOL] handler . emit ( Mock ( name = [string] , autospec = logging . LogRecord ) ) [EOL] handler . spinner . update . assert_called_once_with ( ) [EOL] [EOL] [EOL] def test_SpinnerHandler__no_spinner ( ) : [EOL] SpinnerHandler ( spinner = None ) . emit ( Mock ( name = [string] , autospec = logging . LogRecord , ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] from faust . windows import SlidingWindow [EOL] [EOL] [EOL] class test_SlidingWindow : [EOL] [EOL] def test_constructor ( self ) : [EOL] x = SlidingWindow ( [number] , [number] , [number] ) [EOL] assert x . before == [number] [EOL] assert x . after == [number] [EOL] assert x . expires == [number] [EOL] [EOL] def test_has_ranges_including_the_value ( self ) : [EOL] size = [number] [EOL] step = [number] [EOL] timestamp = [number] [EOL] [EOL] window = SlidingWindow ( size , step , [number] ) [EOL] [EOL] window_ranges = window . ranges ( timestamp ) [EOL] assert len ( window_ranges ) == [number] [EOL] for range in window_ranges : [EOL] assert range [ [number] ] <= timestamp [EOL] assert range [ [number] ] > timestamp [EOL] [EOL] def test_current_range_is_latest_range ( self ) : [EOL] size = [number] [EOL] step = [number] [EOL] timestamp = [number] [EOL] [EOL] window = SlidingWindow ( size , step , [number] ) [EOL] ranges = window . ranges ( timestamp ) [EOL] current_range = window . current ( timestamp ) [EOL] [EOL] assert current_range == ranges [ - [number] ] [EOL] [EOL] def test_earliest_range_is_first_range ( self ) : [EOL] size = [number] [EOL] step = [number] [EOL] timestamp = [number] [EOL] [EOL] window = SlidingWindow ( size , step , [number] ) [EOL] ranges = window . ranges ( timestamp ) [EOL] earliest_range = window . earliest ( timestamp ) [EOL] [EOL] assert earliest_range == ranges [ [number] ] [EOL] [EOL] def test_non_stale_timestamp ( self ) : [EOL] size = [number] [EOL] step = [number] [EOL] expires = [number] [EOL] [EOL] now_timestamp = [number] [EOL] [EOL] window = SlidingWindow ( size , step , expires ) [EOL] for time in range ( now_timestamp - expires + [number] , now_timestamp ) : [EOL] assert window . stale ( time , now_timestamp ) is False [EOL] [EOL] def test_delta ( self ) : [EOL] size = [number] [EOL] step = [number] [EOL] expires = [number] [EOL] [EOL] now_timestamp = [number] [EOL] window = SlidingWindow ( size , step , expires ) [EOL] assert window . delta ( now_timestamp , [number] ) == ( [number] , [number] ) [EOL] [EOL] def test_stale_timestamp ( self ) : [EOL] size = [number] [EOL] step = [number] [EOL] expires = [number] [EOL] now_timestamp = [number] [EOL] [EOL] window = SlidingWindow ( size , step , expires ) [EOL] for time in range ( [number] , now_timestamp - expires ) : [EOL] print ( f' [string] { time } [string] { now_timestamp }' ) [EOL] assert window . stale ( time , now_timestamp ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0
	0
	0
from typing import Any , Set [EOL] import typing [EOL] import asyncio [EOL] import pytest [EOL] from faust import App , Channel , Topic [EOL] from faust . transport . consumer import Consumer [EOL] from faust . transport . conductor import Conductor [EOL] from faust . types import Message , TP [EOL] from mode import label , shortlabel [EOL] from mode . utils . futures import done_future [EOL] from mode . utils . mocks import AsyncMock , Mock [EOL] [EOL] TP1 = TP ( [string] , [number] ) [EOL] TP2 = TP ( [string] , [number] ) [EOL] [EOL] [EOL] class test_Conductor : [EOL] [EOL] @ pytest . fixture def con ( self , * , app ) : [EOL] return Conductor ( app ) [EOL] [EOL] def test_constructor ( self , * , con ) : [EOL] assert con . _topics == set ( ) [EOL] assert con . _topic_name_index == { } [EOL] assert con . _tp_index == { } [EOL] assert con . _tp_to_callback == { } [EOL] assert con . _acking_topics == set ( ) [EOL] assert con . _subscription_changed is None [EOL] assert con . _subscription_done is None [EOL] assert con . _compiler [EOL] assert con . on_message [EOL] [EOL] def test_acks_enabled_for ( self , * , con ) : [EOL] assert not con . acks_enabled_for ( [string] ) [EOL] con . _acking_topics . add ( [string] ) [EOL] assert con . acks_enabled_for ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit ( self , * , con ) : [EOL] con . app = Mock ( name = [string] , autospec = App , consumer = Mock ( autospec = Consumer , commit = AsyncMock ( ) , ) , ) [EOL] await con . commit ( { TP1 } ) [EOL] [EOL] con . app . consumer . commit . assert_called_once_with ( { TP1 } ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_message ( self , * , con ) : [EOL] cb = con . _tp_to_callback [ TP1 ] = AsyncMock ( name = [string] ) [EOL] message = Mock ( name = [string] , autospec = Message ) [EOL] message . tp = TP1 [EOL] await con . on_message ( message ) [EOL] cb . assert_called_once_with ( message ) [EOL] [EOL] @ pytest . mark . asyncio async def test_wait_for_subscription ( self , * , con ) : [EOL] con . _subscription_done = None [EOL] await con . wait_for_subscriptions ( ) [EOL] con . _subscription_done = done_future ( ) [EOL] await con . wait_for_subscriptions ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_update_indices ( self , * , con ) : [EOL] topic1 = Mock ( name = [string] , autospec = Topic ) [EOL] topic1 . acks = False [EOL] topic1 . topics = [ [string] ] [EOL] topic1 . internal = False [EOL] topic2 = Mock ( name = [string] , autospec = Topic ) [EOL] topic2 . acks = True [EOL] topic2 . topics = [ [string] ] [EOL] topic2 . internal = True [EOL] topic2 . maybe_declare = AsyncMock ( name = [string] ) [EOL] con . _topics = { topic1 , topic2 } [EOL] [EOL] await con . _update_indices ( ) [EOL] topic1 . maybe_declare . assert_not_called ( ) [EOL] topic2 . maybe_declare . assert_called_once_with ( ) [EOL] assert [string] not in con . _acking_topics [EOL] assert [string] in con . _acking_topics [EOL] assert con . _topic_name_index [ [string] ] == { topic1 } [EOL] assert con . _topic_name_index [ [string] ] == { topic2 } [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_assigned ( self , * , con ) : [EOL] con . _tp_index = { [number] : [number] } [EOL] con . _update_tp_index = Mock ( name = [string] ) [EOL] con . _update_callback_map = Mock ( name = [string] ) [EOL] assigned = { TP1 , TP2 } [EOL] await con . on_partitions_assigned ( assigned ) [EOL] assert not con . _tp_index [EOL] con . _update_tp_index . assert_called_once_with ( assigned ) [EOL] con . _update_callback_map . assert_called_once_with ( ) [EOL] [EOL] def test_update_tp_index ( self , * , con ) : [EOL] assigned = { TP1 , TP2 } [EOL] topic1 = Mock ( name = [string] , autospec = Topic ) [EOL] topic1 . topics = [ TP1 . topic ] [EOL] topic1 . active_partitions = None [EOL] con . _topics . add ( topic1 ) [EOL] con . _update_tp_index ( assigned ) [EOL] assert topic1 in con . _tp_index [ TP1 ] [EOL] assert topic1 in con . _tp_index [ TP2 ] [EOL] [EOL] def test_update_tp_index__active_partitions ( self , * , con ) : [EOL] assigned = { TP1 , TP2 } [EOL] topic1 = Mock ( name = [string] , autospec = Topic ) [EOL] topic1 . active_partitions = { TP1 , TP2 } [EOL] con . _topics . add ( topic1 ) [EOL] con . _update_tp_index ( assigned ) [EOL] assert topic1 in con . _tp_index [ TP1 ] [EOL] assert topic1 in con . _tp_index [ TP2 ] [EOL] con . _update_tp_index ( set ( ) ) [EOL] [EOL] def test_update_tp_index__active_partitions_empty ( self , * , con ) : [EOL] assigned = { TP1 , TP2 } [EOL] topic1 = Mock ( name = [string] , autospec = Topic ) [EOL] topic1 . active_partitions = set ( ) [EOL] con . _topics . add ( topic1 ) [EOL] con . _update_tp_index ( assigned ) [EOL] assert topic1 not in con . _tp_index [ TP1 ] [EOL] assert topic1 not in con . _tp_index [ TP2 ] [EOL] [EOL] def test_update_callback_map ( self , * , con ) : [EOL] chan1 = Mock ( name = [string] , autospec = Channel ) [EOL] chan2 = Mock ( name = [string] , autospec = Channel ) [EOL] con . _tp_index = { TP1 : chan1 , TP2 : chan2 , } [EOL] con . _update_callback_map ( ) [EOL] [EOL] assert con . _tp_to_callback [ TP1 ] [EOL] assert con . _tp_to_callback [ TP2 ] [EOL] [EOL] def test_clear ( self , * , con ) : [EOL] con . _topics = { [string] } [EOL] con . _topic_name_index = { [number] : [number] } [EOL] con . _tp_index = { [number] : [number] } [EOL] con . _tp_to_callback = { [number] : [number] } [EOL] con . _acking_topics = { [number] , [number] , [number] } [EOL] con . clear ( ) [EOL] [EOL] assert not con . _topics [EOL] assert not con . _topic_name_index [EOL] assert not con . _tp_index [EOL] assert not con . _tp_to_callback [EOL] assert not con . _acking_topics [EOL] [EOL] def test_iter ( self , * , con ) : [EOL] con . _topics = { [string] , [string] } [EOL] assert sorted ( list ( iter ( con ) ) ) == [ [string] , [string] ] [EOL] [EOL] def test_hash ( self , * , con ) : [EOL] assert hash ( con ) [EOL] [EOL] def test_add ( self , * , app , con ) : [EOL] con . _topics = set ( ) [EOL] con . _topic_name_index = { } [EOL] topic = app . topic ( [string] ) [EOL] con . add ( topic ) [EOL] assert topic in con . _topics [EOL] con . add ( topic ) [EOL] con . add ( app . topic ( [string] ) ) [EOL] [EOL] def test_topic_contain_unsubcribed_topics ( self , * , app , con ) : [EOL] con . _topic_name_index = { [string] : { } } [EOL] assert con . _topic_contain_unsubscribed_topics ( app . topic ( [string] ) ) [EOL] assert not con . _topic_contain_unsubscribed_topics ( app . topic ( [string] ) ) [EOL] [EOL] def test_flag_changes ( self , * , con ) : [EOL] con . _subscription_changed = None [EOL] con . _subscription_done = None [EOL] con . _flag_changes ( ) [EOL] assert con . _subscription_done is not None [EOL] [EOL] con . _subscription_done = None [EOL] con . _subscription_changed = asyncio . Event ( ) [EOL] con . _flag_changes ( ) [EOL] assert con . _subscription_changed . is_set ( ) [EOL] assert con . _subscription_done is not None [EOL] con . _flag_changes ( ) [EOL] [EOL] def test_add_flags_changes ( self , * , con , app ) : [EOL] topic = app . topic ( [string] , [string] ) [EOL] con . _flag_changes = Mock ( name = [string] ) [EOL] con . _topic_name_index [ [string] ] . add ( topic ) [EOL] con . add ( topic ) [EOL] con . _flag_changes . assert_called_once_with ( ) [EOL] [EOL] def test_discard ( self , * , con , app ) : [EOL] topic = app . topic ( [string] , [string] ) [EOL] con . add ( topic ) [EOL] assert topic in con . _topics [EOL] con . discard ( topic ) [EOL] assert topic not in con . _topics [EOL] [EOL] def test_label ( self , * , con ) : [EOL] assert label ( con ) [EOL] [EOL] def test_shortlabel ( self , * , con ) : [EOL] assert shortlabel ( con ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] from faust . transport . producer import Producer [EOL] [EOL] [EOL] class ProducerTests : [EOL] [EOL] @ pytest . mark . asyncio async def test_send ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . send ( [string] , [string] , [string] , [number] , None , { } ) [EOL] [EOL] @ pytest . mark . asyncio async def test_flush ( self , * , producer ) : [EOL] await producer . flush ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_send_and_wait ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . send_and_wait ( [string] , [string] , [string] , [number] , None , { } ) [EOL] [EOL] @ pytest . mark . asyncio async def test_create_topic ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . create_topic ( [string] , [number] , [number] ) [EOL] [EOL] def test_key_partition ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] producer . key_partition ( [string] , [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_begin_transaction ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . begin_transaction ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_transaction ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . commit_transaction ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_abort_transaction ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . abort_transaction ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_stop_transaction ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . stop_transaction ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_maybe_begin_transaction ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . maybe_begin_transaction ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_transactions ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . commit_transactions ( { } , [string] ) [EOL] [EOL] def test_supports_headers ( self , * , producer ) : [EOL] assert not producer . supports_headers ( ) [EOL] [EOL] [EOL] class test_Producer ( ProducerTests ) : [EOL] [EOL] @ pytest . fixture def producer ( self , * , app ) : [EOL] return Producer ( app . transport ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Set [EOL] import t [EOL] import builtins [EOL] import typing [EOL] import faust [EOL] import asyncio [EOL] import pytest [EOL] from faust import App [EOL] from faust . app . _attached import Attachments [EOL] from faust . exceptions import AlreadyConfiguredWarning [EOL] from faust . tables . manager import TableManager [EOL] from faust . transport . base import Producer , Transport [EOL] from faust . transport . consumer import ( Consumer , ConsumerThread , Fetcher , ProducerSendError , ThreadDelegateConsumer , TransactionManager , ) [EOL] from faust . transport . conductor import Conductor [EOL] from faust . types import Message , TP [EOL] from mode import Service [EOL] from mode . threads import MethodQueue [EOL] from mode . utils . futures import done_future [EOL] from mode . utils . mocks import ANY , AsyncMock , Mock , call , patch [EOL] [EOL] TP1 = TP ( [string] , [number] ) [EOL] TP2 = TP ( [string] , [number] ) [EOL] TP3 = TP ( [string] , [number] ) [EOL] [EOL] [EOL] class test_Fetcher : [EOL] [EOL] @ pytest . fixture def consumer ( self ) : [EOL] return Mock ( name = [string] , autospec = Consumer , _drain_messages = AsyncMock ( ) , ) [EOL] [EOL] @ pytest . fixture def fetcher ( self , * , app , consumer ) : [EOL] fetcher = Fetcher ( app ) [EOL] app . consumer = consumer [EOL] [comment] [EOL] fetcher . loop = asyncio . get_event_loop ( ) [EOL] return fetcher [EOL] [EOL] @ pytest . mark . asyncio async def test_fetcher ( self , * , fetcher , app ) : [EOL] await fetcher . _fetcher ( fetcher ) [EOL] app . consumer . _drain_messages . assert_called_once_with ( fetcher ) [EOL] [EOL] @ pytest . mark . asyncio async def test_fetcher__raises_CancelledError ( self , * , fetcher , app ) : [EOL] app . consumer . _drain_messages . side_effect = asyncio . CancelledError [EOL] await fetcher . _fetcher ( fetcher ) [EOL] app . consumer . _drain_messages . assert_called_once_with ( fetcher ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop__no_drainer ( self , * , fetcher ) : [EOL] fetcher . _drainer = None [EOL] await fetcher . on_stop ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop__drainer_done ( self , * , fetcher ) : [EOL] fetcher . _drainer = Mock ( done = Mock ( return_value = True ) ) [EOL] await fetcher . on_stop ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop__drainer_pending ( self , * , fetcher ) : [EOL] fetcher . _drainer = Mock ( done = Mock ( return_value = False ) ) [EOL] with patch ( [string] , AsyncMock ( ) ) as wait_for : [EOL] await fetcher . on_stop ( ) [EOL] wait_for . assert_called_once_with ( fetcher . _drainer , timeout = [number] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop__drainer_raises_StopIteration ( self , * , fetcher ) : [EOL] fetcher . _drainer = Mock ( done = Mock ( return_value = False ) ) [EOL] with patch ( [string] , AsyncMock ( ) ) as wait_for : [EOL] wait_for . side_effect = StopIteration ( ) [EOL] await fetcher . on_stop ( ) [EOL] wait_for . assert_called_once_with ( fetcher . _drainer , timeout = [number] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop__drainer_raises_CancelledError ( self , * , fetcher ) : [EOL] fetcher . _drainer = Mock ( done = Mock ( return_value = False ) ) [EOL] with patch ( [string] , AsyncMock ( ) ) as wait_for : [EOL] wait_for . coro . side_effect = asyncio . CancelledError ( ) [EOL] await fetcher . on_stop ( ) [EOL] wait_for . assert_called_once_with ( fetcher . _drainer , timeout = [number] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop__drainer_raises_TimeoutError ( self , * , fetcher ) : [EOL] fetcher . _drainer = Mock ( done = Mock ( return_value = False ) ) [EOL] with patch ( [string] , AsyncMock ( ) ) as wait_for : [EOL] wait_for . coro . side_effect = [ asyncio . TimeoutError ( ) , asyncio . TimeoutError ( ) , None , ] [EOL] await fetcher . on_stop ( ) [EOL] wait_for . assert_called_with ( fetcher . _drainer , timeout = [number] , ) [EOL] assert wait_for . call_count == [number] [EOL] [EOL] [EOL] class test_TransactionManager : [EOL] [EOL] @ pytest . fixture ( ) def consumer ( self ) : [EOL] return Mock ( name = [string] , spec = Consumer , ) [EOL] [EOL] @ pytest . fixture ( ) def producer ( self ) : [EOL] return Mock ( name = [string] , spec = Producer , create_topic = AsyncMock ( ) , stop_transaction = AsyncMock ( ) , maybe_begin_transaction = AsyncMock ( ) , commit_transactions = AsyncMock ( ) , send = AsyncMock ( ) , flush = AsyncMock ( ) , ) [EOL] [EOL] @ pytest . fixture ( ) def transport ( self , * , app ) : [EOL] return Mock ( name = [string] , spec = Transport , app = app , ) [EOL] [EOL] @ pytest . fixture ( ) def manager ( self , * , consumer , producer , transport ) : [EOL] return TransactionManager ( transport , consumer = consumer , producer = producer , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked ( self , * , manager ) : [EOL] manager . flush = AsyncMock ( ) [EOL] await manager . on_partitions_revoked ( { TP1 } ) [EOL] manager . flush . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_rebalance ( self , * , manager ) : [EOL] TP3_group = [number] [EOL] TP2_group = [number] [EOL] manager . app . assignor . _topic_groups = { TP3 . topic : TP3_group , TP2 . topic : TP2_group , } [EOL] [EOL] assert TP3 . topic != TP2 . topic [comment] [EOL] manager . _stop_transactions = AsyncMock ( ) [EOL] manager . _start_transactions = AsyncMock ( ) [EOL] [EOL] assigned = { TP2 } [EOL] revoked = { TP3 } [EOL] newly_assigned = { TP2 } [EOL] await manager . on_rebalance ( assigned , revoked , newly_assigned ) [EOL] [EOL] manager . _stop_transactions . assert_called_once_with ( [ f'{ TP3_group } [string] { TP3 . partition }' ] ) [EOL] manager . _start_transactions . assert_called_once_with ( [ f'{ TP2_group } [string] { TP2 . partition }' ] ) [EOL] [EOL] await manager . on_rebalance ( set ( ) , set ( ) , set ( ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test__stop_transactions ( self , * , manager , producer ) : [EOL] await manager . _stop_transactions ( [ [string] , [string] ] ) [EOL] producer . stop_transaction . assert_has_calls ( [ call ( [string] ) , call . coro ( [string] ) , call ( [string] ) , call . coro ( [string] ) , ] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_start_transactions ( self , * , manager , producer ) : [EOL] manager . _start_new_producer = AsyncMock ( ) [EOL] await manager . _start_transactions ( [ [string] , [string] ] ) [EOL] producer . maybe_begin_transaction . assert_has_calls ( [ call ( [string] ) , call . coro ( [string] ) , call ( [string] ) , call . coro ( [string] ) , ] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_send ( self , * , manager , producer ) : [EOL] manager . app . assignor . _topic_groups = { [string] : [number] , } [EOL] manager . consumer . key_partition . return_value = [number] [EOL] [EOL] await manager . send ( [string] , [string] , [string] , partition = None , headers = None , timestamp = None ) [EOL] manager . consumer . key_partition . assert_called_once_with ( [string] , [string] , None ) [EOL] producer . send . assert_called_once_with ( [string] , [string] , [string] , [number] , None , None , transactional_id = [string] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_send_and_wait ( self , * , manager ) : [EOL] on_send = Mock ( ) [EOL] [EOL] async def send ( * args , ** kwargs ) : [EOL] on_send ( * args , ** kwargs ) [EOL] return done_future ( ) [EOL] manager . send = send [EOL] [EOL] await manager . send_and_wait ( [string] , [string] , [string] , [number] , [number] , { } ) [EOL] on_send . assert_called_once_with ( [string] , [string] , [string] , [number] , [number] , { } , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit ( self , * , manager , producer ) : [EOL] manager . app . assignor . _topic_groups = { [string] : [number] , [string] : [number] , } [EOL] await manager . commit ( { TP ( [string] , [number] ) : [number] , TP ( [string] , [number] ) : [number] , TP ( [string] , [number] ) : [number] , TP ( [string] , [number] ) : [number] , } , start_new_transaction = False , ) [EOL] producer . commit_transactions . assert_called_once_with ( { [string] : { TP ( [string] , [number] ) : [number] , } , [string] : { TP ( [string] , [number] ) : [number] , } , [string] : { TP ( [string] , [number] ) : [number] , } , [string] : { TP ( [string] , [number] ) : [number] , } , } , [string] , start_new_transaction = False , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit__empty ( self , * , manager ) : [EOL] await manager . commit ( { } , start_new_transaction = False ) [EOL] [EOL] def test_key_partition ( self , * , manager ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] manager . key_partition ( [string] , [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_flush ( self , * , manager , producer ) : [EOL] await manager . flush ( ) [EOL] producer . flush . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_create_topic ( self , * , manager ) : [EOL] await manager . create_topic ( topic = [string] , partitions = [number] , replication = [number] , config = { [string] : [number] } , timeout = [number] , retention = [number] , compacting = True , deleting = True , ensure_created = True , ) [EOL] manager . producer . create_topic . assert_called_once_with ( [string] , [number] , [number] , config = { [string] : [number] } , timeout = [number] , retention = [number] , compacting = True , deleting = True , ensure_created = True , ) [EOL] [EOL] def test_supports_headers ( self , * , manager ) : [EOL] ret = manager . supports_headers ( ) [EOL] assert ret is manager . producer . supports_headers . return_value [EOL] [EOL] [EOL] class MockedConsumerAbstractMethods : [EOL] [EOL] def assignment ( self ) : [EOL] return self . current_assignment [EOL] [EOL] def position ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def create_topic ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] def earliest_offsets ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] def highwater ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] def highwaters ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def _getmany ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def _seek ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] def _to_message ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def seek_to_committed ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def seek_wait ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def subscribe ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def seek_to_beginning ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def _commit ( self , offsets ) : [EOL] ... [EOL] [EOL] def topic_partitions ( self , topic ) : [EOL] ... [EOL] [EOL] def _new_topicpartition ( self , topic , partition ) : [EOL] return TP ( topic , partition ) [EOL] [EOL] def key_partition ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] [EOL] class MyConsumer ( MockedConsumerAbstractMethods , Consumer ) : [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . current_assignment = set ( ) [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] class test_Consumer : [EOL] [EOL] @ pytest . fixture def callback ( self ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] @ pytest . fixture def on_P_revoked ( self ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] @ pytest . fixture def on_P_assigned ( self ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] @ pytest . fixture def consumer ( self , * , app , callback , on_P_revoked , on_P_assigned ) : [EOL] return MyConsumer ( app . transport , callback = callback , on_partitions_revoked = on_P_revoked , on_partitions_assigned = on_P_assigned , ) [EOL] [EOL] @ pytest . fixture def message ( self ) : [EOL] return Mock ( name = [string] , autospec = Message ) [EOL] [EOL] def test_on_init_dependencies__default ( self , * , consumer ) : [EOL] consumer . in_transaction = False [EOL] assert consumer . on_init_dependencies ( ) == [ ] [EOL] [EOL] def test_on_init_dependencies__exactly_once ( self , * , consumer ) : [EOL] consumer . in_transaction = True [EOL] assert consumer . on_init_dependencies ( ) == [ consumer . transactions ] [EOL] [EOL] @ pytest . mark . asyncio async def test_getmany__stopped_after_wait ( self , * , consumer ) : [EOL] consumer . _wait_next_records = AsyncMock ( ) [EOL] [EOL] async def on_wait ( timeout ) : [EOL] consumer . _stopped . set ( ) [EOL] return None , None [EOL] [EOL] consumer . _wait_next_records . side_effect = on_wait [EOL] assert [ a async for a in consumer . getmany ( [number] ) ] == [ ] [EOL] [EOL] @ pytest . mark . asyncio async def test_getmany__flow_inactive ( self , * , consumer ) : [EOL] consumer . _wait_next_records = AsyncMock ( return_value = ( { TP1 : [ [string] , [string] , [string] ] } , { TP1 } , ) ) [EOL] consumer . flow_active = False [EOL] assert [ a async for a in consumer . getmany ( [number] ) ] == [ ] [EOL] [EOL] @ pytest . mark . asyncio async def test_getmany__flow_inactive2 ( self , * , consumer ) : [EOL] consumer . _wait_next_records = AsyncMock ( return_value = ( { TP1 : [ [string] , [string] , [string] ] , TP2 : [ [string] ] } , { TP1 } , ) ) [EOL] consumer . scheduler = Mock ( ) [EOL] [EOL] def se ( records ) : [EOL] for value in records . items ( ) : [EOL] yield value [EOL] consumer . flow_active = False [EOL] consumer . scheduler . iterate . side_effect = se [EOL] [EOL] consumer . flow_active = True [EOL] res = [ a async for a in consumer . getmany ( [number] ) ] [EOL] assert res [EOL] assert len ( res ) == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_getmany ( self , * , consumer ) : [EOL] def to_message ( tp , record ) : [EOL] return record [EOL] consumer . _to_message = to_message [EOL] self . _setup_records ( consumer , active_partitions = { TP1 , TP2 } , records = { TP1 : [ [string] , [string] , [string] ] , TP2 : [ [string] , [string] , [string] , [string] ] , TP3 : [ [string] , [string] , [string] ] , } , ) [EOL] assert not consumer . should_stop [EOL] consumer . flow_active = False [EOL] consumer . can_resume_flow . set ( ) [EOL] assert [ a async for a in consumer . getmany ( [number] ) ] == [ ] [EOL] assert not consumer . should_stop [EOL] consumer . flow_active = True [EOL] assert [ a async for a in consumer . getmany ( [number] ) ] == [ ( TP1 , [string] ) , ( TP2 , [string] ) , ( TP1 , [string] ) , ( TP2 , [string] ) , ( TP1 , [string] ) , ( TP2 , [string] ) , ( TP2 , [string] ) , ] [EOL] [EOL] @ pytest . mark . asyncio async def test__wait_next_records ( self , * , consumer ) : [EOL] self . _setup_records ( consumer , active_partitions = { TP1 } , records = { TP1 : [ [string] , [string] , [string] ] , } , ) [EOL] ret = await consumer . _wait_next_records ( [number] ) [EOL] assert ret == ( { TP1 : [ [string] , [string] , [string] ] } , { TP1 } ) [EOL] [EOL] @ pytest . mark . asyncio async def test__wait_next_records__flow_inactive ( self , * , consumer ) : [EOL] self . _setup_records ( consumer , { TP1 } , flow_active = False ) [EOL] consumer . can_resume_flow . set ( ) [EOL] consumer . wait = AsyncMock ( ) [EOL] await consumer . _wait_next_records ( [number] ) [EOL] consumer . wait . assert_called_once_with ( consumer . can_resume_flow ) [EOL] [EOL] @ pytest . mark . asyncio async def test__wait_next_records__no_active_tps ( self , * , consumer ) : [EOL] self . _setup_records ( consumer , set ( ) ) [EOL] consumer . sleep = AsyncMock ( ) [EOL] ret = await consumer . _wait_next_records ( [number] ) [EOL] consumer . sleep . assert_called_once_with ( [number] ) [EOL] assert ret == ( { } , set ( ) ) [EOL] [EOL] def _setup_records ( self , consumer , active_partitions , records = None , flow_active = True ) : [EOL] consumer . flow_active = flow_active [EOL] consumer . _active_partitions = active_partitions [EOL] consumer . _getmany = AsyncMock ( return_value = { } if records is None else records , ) [EOL] [EOL] @ pytest . mark . asyncio async def test__wait_for_ack ( self , * , consumer ) : [EOL] [EOL] async def set_ack ( ) : [EOL] await asyncio . sleep ( [number] ) [EOL] consumer . _waiting_for_ack . set_result ( None ) [EOL] [EOL] await asyncio . gather ( consumer . _wait_for_ack ( timeout = [number] ) , set_ack ( ) , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_restart ( self , * , consumer ) : [EOL] consumer . _reset_state = Mock ( ) [EOL] consumer . on_init = Mock ( ) [EOL] await consumer . on_restart ( ) [EOL] consumer . _reset_state . assert_called_once_with ( ) [EOL] consumer . on_init . assert_called_once_with ( ) [EOL] [EOL] def test__get_active_partitions__when_empty ( self , * , consumer ) : [EOL] consumer . _active_partitions = None [EOL] consumer . assignment = Mock ( return_value = { TP1 } ) [EOL] assert consumer . _get_active_partitions ( ) == { TP1 } [EOL] [EOL] def test__get_active_partitions__when_set ( self , * , consumer ) : [EOL] consumer . _active_partitions = { TP1 , TP2 } [EOL] consumer . assignment = Mock ( return_value = { TP1 } ) [EOL] assert consumer . _get_active_partitions ( ) == { TP1 , TP2 } [EOL] [EOL] @ pytest . mark . asyncio async def test_perform_seek ( self , * , consumer ) : [EOL] consumer . _read_offset . update ( TP1 = [number] , TP2 = [number] ) [EOL] consumer . _committed_offset . update ( TP1 = [number] , TP2 = [number] ) [EOL] consumer . seek_to_committed = AsyncMock ( return_value = { TP1 : [number] , TP2 : [number] , } ) [EOL] [EOL] await consumer . perform_seek ( ) [EOL] [EOL] assert consumer . _read_offset [ TP1 ] == [number] [EOL] assert consumer . _read_offset [ TP2 ] == [number] [EOL] [EOL] assert consumer . _committed_offset [ TP1 ] == [number] [EOL] assert consumer . _committed_offset [ TP2 ] is None [EOL] [EOL] @ pytest . mark . asyncio async def test_seek ( self , * , consumer ) : [EOL] consumer . _last_batch = [number] [EOL] consumer . _read_offset [ TP1 ] = [number] [EOL] consumer . _seek = AsyncMock ( ) [EOL] [EOL] await consumer . seek ( TP1 , [number] ) [EOL] [EOL] assert consumer . _last_batch is None [EOL] assert consumer . _read_offset [ TP1 ] == [number] [EOL] consumer . _seek . assert_called_once_with ( TP1 , [number] ) [EOL] [EOL] def test_stop_flow ( self , * , consumer ) : [EOL] consumer . flow_active = True [EOL] consumer . can_resume_flow . set ( ) [EOL] [EOL] consumer . stop_flow ( ) [EOL] [EOL] assert not consumer . flow_active [EOL] assert not consumer . can_resume_flow . is_set ( ) [EOL] [EOL] def test_resume_flow ( self , * , consumer ) : [EOL] consumer . flow_active = False [EOL] consumer . can_resume_flow . clear ( ) [EOL] [EOL] consumer . resume_flow ( ) [EOL] [EOL] assert consumer . flow_active [EOL] assert consumer . can_resume_flow . is_set ( ) [EOL] [EOL] def test_pause_partitions ( self , * , consumer ) : [EOL] consumer . _paused_partitions . clear ( ) [EOL] consumer . _active_partitions = { TP1 , TP2 } [EOL] [EOL] consumer . pause_partitions ( [ TP2 ] ) [EOL] assert consumer . _active_partitions == { TP1 } [EOL] assert consumer . _paused_partitions == { TP2 } [EOL] [EOL] def test_resume_partitions ( self , * , consumer ) : [EOL] consumer . _paused_partitions = { TP2 } [EOL] consumer . _active_partitions = { TP1 } [EOL] [EOL] consumer . resume_partitions ( [ TP2 ] ) [EOL] assert consumer . _active_partitions == { TP1 , TP2 } [EOL] assert not consumer . _paused_partitions [EOL] [EOL] def test_read_offset_default ( self , * , consumer ) : [EOL] assert consumer . _read_offset [ TP1 ] is None [EOL] [EOL] def test_committed_offset_default ( self , * , consumer ) : [EOL] assert consumer . _committed_offset [ TP1 ] is None [EOL] [EOL] def test_is_changelog_tp ( self , * , app , consumer ) : [EOL] app . tables = Mock ( name = [string] , autospec = TableManager ) [EOL] app . tables . changelog_topics = { [string] , [string] } [EOL] assert consumer . _is_changelog_tp ( TP ( [string] , [number] ) ) [EOL] assert consumer . _is_changelog_tp ( TP ( [string] , [number] ) ) [EOL] assert not consumer . _is_changelog_tp ( TP ( [string] , [number] ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked ( self , * , consumer ) : [EOL] consumer . _on_partitions_revoked = AsyncMock ( name = [string] ) [EOL] tps = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] await consumer . on_partitions_revoked ( tps ) [EOL] [EOL] consumer . _on_partitions_revoked . assert_called_once_with ( tps ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked__updates_active ( self , * , consumer ) : [EOL] consumer . _active_partitions = { TP ( [string] , [number] ) } [EOL] consumer . _on_partitions_revoked = AsyncMock ( name = [string] ) [EOL] tps = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] await consumer . on_partitions_revoked ( tps ) [EOL] [EOL] consumer . _on_partitions_revoked . assert_called_once_with ( tps ) [EOL] [EOL] assert not consumer . _active_partitions [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_assigned ( self , * , consumer ) : [EOL] consumer . _on_partitions_assigned = AsyncMock ( name = [string] ) [EOL] tps = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] await consumer . on_partitions_assigned ( tps ) [EOL] [EOL] consumer . _on_partitions_assigned . assert_called_once_with ( tps ) [EOL] [EOL] def test_track_message ( self , * , consumer , message ) : [EOL] consumer . _on_message_in = Mock ( name = [string] ) [EOL] consumer . track_message ( message ) [EOL] [EOL] assert message in consumer . unacked [EOL] consumer . _on_message_in . assert_called_once_with ( message . tp , message . offset , message ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , ] ) def test_ack ( self , offset , * , consumer , message ) : [EOL] message . acked = False [EOL] consumer . app = Mock ( name = [string] , autospec = App ) [EOL] consumer . app . topics . acks_enabled_for . return_value = True [EOL] consumer . _committed_offset [ message . tp ] = [number] [EOL] message . offset = offset [EOL] consumer . _acked_index [ message . tp ] = set ( ) [EOL] consumer . ack ( message ) [EOL] message . acked = False [EOL] consumer . ack ( message ) [EOL] [EOL] def test_ack__already_acked ( self , * , consumer , message ) : [EOL] message . acked = True [EOL] consumer . ack ( message ) [EOL] [EOL] def test_ack__disabled ( self , * , consumer , message , app ) : [EOL] message . acked = False [EOL] app . topics = Mock ( name = [string] , autospec = Conductor ) [EOL] app . topics . acks_enabled_for . return_value = False [EOL] consumer . ack ( message ) [EOL] [EOL] @ pytest . mark . asyncio async def test_wait_empty ( self , * , consumer ) : [EOL] consumer . _unacked_messages = { Mock ( autospec = Message ) } [EOL] consumer . _wait_for_ack = AsyncMock ( ) [EOL] [EOL] def on_commit ( start_new_transaction = True ) : [EOL] for _ in range ( [number] ) : [EOL] yield [EOL] if consumer . commit . call_count == [number] : [EOL] consumer . _unacked_messages . clear ( ) [EOL] consumer . commit = AsyncMock ( name = [string] , side_effect = on_commit ) [EOL] [EOL] await consumer . wait_empty ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_wait_empty__when_stopped ( self , * , consumer ) : [EOL] consumer . _stopped . set ( ) [EOL] await consumer . wait_empty ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop ( self , * , consumer ) : [EOL] consumer . app . conf . stream_wait_empty = False [EOL] consumer . _last_batch = [number] [EOL] await consumer . on_stop ( ) [EOL] assert consumer . _last_batch is None [EOL] [EOL] with pytest . warns ( AlreadyConfiguredWarning ) : [EOL] consumer . app . conf . stream_wait_empty = True [EOL] consumer . wait_empty = AsyncMock ( name = [string] ) [EOL] [EOL] await consumer . on_stop ( ) [EOL] consumer . wait_empty . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_force_commit ( self , * , consumer ) : [EOL] consumer . app = Mock ( name = [string] , autospec = App ) [EOL] oci = consumer . app . sensors . on_commit_initiated [EOL] occ = consumer . app . sensors . on_commit_completed [EOL] consumer . _commit_tps = AsyncMock ( name = [string] ) [EOL] consumer . _acked = { TP1 : [ [number] , [number] , [number] , [number] , [number] ] , } [EOL] consumer . _committed_offset = { TP1 : [number] , } [EOL] await consumer . force_commit ( { TP1 } ) [EOL] oci . assert_called_once_with ( consumer ) [EOL] consumer . _commit_tps . assert_called_once_with ( [ TP1 ] , start_new_transaction = True , ) [EOL] occ . assert_called_once_with ( consumer , oci ( ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_tps ( self , * , consumer ) : [EOL] consumer . _handle_attached = AsyncMock ( name = [string] ) [EOL] consumer . _commit_offsets = AsyncMock ( name = [string] ) [EOL] consumer . _filter_committable_offsets = Mock ( name = [string] ) [EOL] consumer . _filter_committable_offsets . return_value = { TP1 : [number] , TP2 : [number] , } [EOL] await consumer . _commit_tps ( { TP1 , TP2 } , start_new_transaction = False , ) [EOL] [EOL] consumer . _handle_attached . assert_called_once_with ( { TP1 : [number] , TP2 : [number] , } ) [EOL] consumer . _commit_offsets . assert_called_once_with ( { TP1 : [number] , TP2 : [number] } , start_new_transaction = False , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_tps__ProducerSendError ( self , * , consumer ) : [EOL] consumer . _handle_attached = Mock ( name = [string] ) [EOL] exc = consumer . _handle_attached . side_effect = ProducerSendError ( ) [EOL] consumer . crash = AsyncMock ( name = [string] ) [EOL] consumer . _filter_committable_offsets = Mock ( name = [string] ) [EOL] consumer . _filter_committable_offsets . return_value = { TP1 : [number] , TP2 : [number] , } [EOL] await consumer . _commit_tps ( { TP1 , TP2 } , start_new_transaction = True , ) [EOL] [EOL] consumer . crash . assert_called_once_with ( exc ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_tps__no_committable ( self , * , consumer ) : [EOL] consumer . _filter_committable_offsets = Mock ( name = [string] ) [EOL] consumer . _filter_committable_offsets . return_value = { } [EOL] await consumer . _commit_tps ( { TP1 , TP2 } , start_new_transaction = True , ) [EOL] [EOL] def test_filter_committable_offsets ( self , * , consumer ) : [EOL] consumer . _acked = { TP1 : [ [number] , [number] , [number] , [number] , [number] , [number] ] , TP2 : [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , } [EOL] consumer . _committed_offset = { TP1 : [number] , TP2 : [number] , } [EOL] assert consumer . _filter_committable_offsets ( { TP1 , TP2 } ) == { TP2 : [number] , } [EOL] [EOL] @ pytest . mark . asyncio async def test_handle_attached ( self , * , consumer ) : [EOL] consumer . app = Mock ( name = [string] , autospec = App , _attachments = Mock ( autospec = Attachments , publish_for_tp_offset = AsyncMock ( ) , ) , producer = Mock ( autospec = Service , wait_many = AsyncMock ( ) , ) , ) [EOL] await consumer . _handle_attached ( { TP1 : [number] , TP2 : [number] , } ) [EOL] consumer . app . _attachments . publish_for_tp_offset . coro . assert_has_calls ( [ call ( TP1 , [number] ) , call ( TP2 , [number] ) , ] ) [EOL] [EOL] consumer . app . producer . wait_many . coro . assert_called_with ( ANY ) [EOL] att = consumer . app . _attachments [EOL] att . publish_for_tp_offset . coro . return_value = None [EOL] await consumer . _handle_attached ( { TP1 : [number] , TP2 : [number] , } ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_offsets ( self , * , consumer ) : [EOL] consumer . _commit = AsyncMock ( name = [string] ) [EOL] consumer . current_assignment . update ( { TP1 , TP2 } ) [EOL] await consumer . _commit_offsets ( { TP1 : [number] , TP2 : [number] , } ) [EOL] consumer . _commit . assert_called_once_with ( { TP1 : [number] , TP2 : [number] , } ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_offsets__did_not_commit ( self , * , consumer ) : [EOL] consumer . in_transaction = False [EOL] consumer . _commit = AsyncMock ( return_value = False ) [EOL] consumer . current_assignment . update ( { TP1 , TP2 } ) [EOL] consumer . app . tables = Mock ( name = [string] ) [EOL] await consumer . _commit_offsets ( { TP1 : [number] , TP2 : [number] , TP3 : [number] , } ) [EOL] consumer . app . tables . on_commit . assert_not_called ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_offsets__in_transaction ( self , * , consumer ) : [EOL] consumer . in_transaction = True [EOL] consumer . transactions . commit = AsyncMock ( ) [EOL] consumer . current_assignment . update ( { TP1 , TP2 } ) [EOL] ret = await consumer . _commit_offsets ( { TP1 : [number] , TP2 : [number] , TP3 : [number] , } ) [EOL] consumer . transactions . commit . assert_called_once_with ( { TP1 : [number] , TP2 : [number] } , start_new_transaction = True , ) [EOL] assert ret is consumer . transactions . commit . coro ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_offsets__no_committable_offsets ( self , * , consumer ) : [EOL] consumer . current_assignment . clear ( ) [EOL] assert not await consumer . _commit_offsets ( { TP1 : [number] , TP2 : [number] , TP3 : [number] , } ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit__already_committing ( self , * , consumer ) : [EOL] consumer . maybe_wait_for_commit_to_finish = AsyncMock ( return_value = True ) [EOL] assert not await consumer . commit ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit ( self , * , consumer ) : [EOL] topics = { [string] , [string] } [EOL] start_new_transaction = False [EOL] consumer . maybe_wait_for_commit_to_finish = AsyncMock ( return_value = False ) [EOL] consumer . force_commit = AsyncMock ( ) [EOL] ret = await consumer . commit ( topics , start_new_transaction = start_new_transaction , ) [EOL] consumer . force_commit . assert_called_once_with ( topics , start_new_transaction = start_new_transaction , ) [EOL] assert ret is consumer . force_commit . coro ( ) [EOL] assert consumer . _commit_fut is None [EOL] [EOL] def test_filter_tps_with_pending_acks ( self , * , consumer ) : [EOL] consumer . _acked = { TP1 : [ [number] , [number] , [number] , [number] , [number] , [number] ] , TP2 : [ [number] , [number] , [number] , [number] ] , } [EOL] assert list ( consumer . _filter_tps_with_pending_acks ( ) ) == [ TP1 , TP2 , ] [EOL] assert list ( consumer . _filter_tps_with_pending_acks ( [ TP1 ] ) ) == [ TP1 , ] [EOL] assert list ( consumer . _filter_tps_with_pending_acks ( [ TP1 . topic ] ) ) == [ TP1 , TP2 , ] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( TP1 , [number] , [number] , False ) , ( TP1 , [number] , [number] , True ) , ( TP1 , [number] , [number] , False ) , ( TP1 , [number] , [number] , True ) , ] ) def test_should_commit ( self , tp , offset , committed , should , * , consumer ) : [EOL] consumer . _committed_offset [ tp ] = committed [EOL] assert consumer . _should_commit ( tp , offset ) == should [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( TP1 , [ ] , None ) , ( TP1 , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , ( TP1 , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , ( TP1 , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , ( TP1 , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , ] ) def test_new_offset ( self , tp , acked , expected_offset , * , consumer ) : [EOL] consumer . _acked [ tp ] = acked [EOL] assert consumer . _new_offset ( tp ) == expected_offset [EOL] [EOL] @ pytest . mark . asyncio async def test_on_task_error ( self , * , consumer ) : [EOL] consumer . commit = AsyncMock ( name = [string] ) [EOL] await consumer . on_task_error ( KeyError ( ) ) [EOL] consumer . commit . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_handler ( self , * , consumer ) : [EOL] i = [number] [EOL] [EOL] def on_sleep ( secs , ** kwargs ) : [EOL] nonlocal i [EOL] if i > [number] : [EOL] consumer . _stopped . set ( ) [EOL] i += [number] [EOL] [EOL] consumer . sleep = AsyncMock ( name = [string] , side_effect = on_sleep ) [EOL] consumer . commit = AsyncMock ( name = [string] ) [EOL] [EOL] await consumer . _commit_handler ( consumer ) [EOL] consumer . sleep . coro . assert_has_calls ( [ call ( consumer . commit_interval ) , call ( pytest . approx ( consumer . commit_interval , rel = [number] ) , loop = None ) , ] ) [EOL] consumer . commit . assert_called_once_with ( ) [EOL] [EOL] def test_close ( self , * , consumer ) : [EOL] consumer . close ( ) [EOL] [EOL] [EOL] class test_ConsumerThread : [EOL] [EOL] class MyConsumerThread ( MockedConsumerAbstractMethods , ConsumerThread ) : [EOL] [EOL] async def getmany ( self , * args , ** kwargs ) : [EOL] yield None , None [EOL] [EOL] def pause_partitions ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] def resume_partitions ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] def stop_flow ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] def resume_flow ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def commit ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def perform_seek ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def seek ( self , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] @ pytest . fixture def consumer ( self ) : [EOL] return Mock ( name = [string] , spec = Consumer , threadsafe_partitions_revoked = AsyncMock ( ) , threadsafe_partitions_assigned = AsyncMock ( ) , transport = Mock ( ) , ) [EOL] [EOL] @ pytest . fixture def thread ( self , * , consumer ) : [EOL] return self . MyConsumerThread ( consumer ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked ( self , * , thread , consumer ) : [EOL] await thread . on_partitions_revoked ( { TP1 , TP2 } ) [EOL] consumer . threadsafe_partitions_revoked . assert_called_once_with ( thread . thread_loop , { TP1 , TP2 } , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_assigned ( self , * , thread , consumer ) : [EOL] await thread . on_partitions_assigned ( { TP1 , TP2 } ) [EOL] consumer . threadsafe_partitions_assigned . assert_called_once_with ( thread . thread_loop , { TP1 , TP2 } , ) [EOL] [EOL] [EOL] class test_ThreadDelegateConsumer : [EOL] [EOL] class TestThreadDelegateConsumer ( ThreadDelegateConsumer ) : [EOL] [EOL] def _new_consumer_thread ( self ) : [EOL] return Mock ( name = [string] , spec = Consumer , getmany = AsyncMock ( ) , subscribe = AsyncMock ( ) , seek_to_committed = AsyncMock ( ) , position = AsyncMock ( ) , seek_wait = AsyncMock ( ) , seek = AsyncMock ( ) , earliest_offsets = AsyncMock ( ) , highwaters = AsyncMock ( ) , commit = AsyncMock ( ) , ) [EOL] [EOL] def _new_topicpartition ( self , * args , ** kwargs ) : [EOL] return TP ( * args , ** kwargs ) [EOL] [EOL] def _to_message ( self , * args , ** kwargs ) : [EOL] return ( args , kwargs ) [EOL] [EOL] def create_topic ( self , * args , ** kwargs ) : [EOL] return [EOL] [EOL] @ pytest . fixture def message_callback ( self ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] @ pytest . fixture def partitions_revoked_callback ( self ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] @ pytest . fixture def partitions_assigned_callback ( self ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] @ pytest . fixture def consumer ( self , * , app , message_callback , partitions_revoked_callback , partitions_assigned_callback ) : [EOL] consumer = self . TestThreadDelegateConsumer ( app . transport , callback = message_callback , on_partitions_revoked = partitions_revoked_callback , on_partitions_assigned = partitions_assigned_callback , ) [EOL] [EOL] async def _call ( * args , ** kwargs ) : [EOL] consumer . _method_queue . _call ( * args , ** kwargs ) [EOL] return done_future ( ) [EOL] [EOL] consumer . _method_queue = Mock ( name = [string] , spec = MethodQueue , call = _call , _call = Mock ( ) , ) [EOL] return consumer [EOL] [EOL] @ pytest . mark . asyncio async def test_threadsafe_partitions_revoked ( self , * , consumer ) : [EOL] loop = Mock ( name = [string] ) [EOL] await consumer . threadsafe_partitions_revoked ( loop , { } ) [EOL] loop . create_future . assert_called_once_with ( ) [EOL] consumer . _method_queue . _call . assert_called_once_with ( loop . create_future ( ) , consumer . on_partitions_revoked , { } , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_threadsafe_partitions_assigned ( self , * , consumer ) : [EOL] loop = Mock ( name = [string] ) [EOL] await consumer . threadsafe_partitions_assigned ( loop , { } ) [EOL] loop . create_future . assert_called_once_with ( ) [EOL] consumer . _method_queue . _call . assert_called_once_with ( loop . create_future ( ) , consumer . on_partitions_assigned , { } , ) [EOL] [EOL] @ pytest . mark . asyncio async def test__getmany ( self , * , consumer ) : [EOL] ret = await consumer . _getmany ( { TP1 , TP2 } , timeout = [number] ) [EOL] consumer . _thread . getmany . assert_called_once_with ( { TP1 , TP2 } , [number] , ) [EOL] assert ret is consumer . _thread . getmany . coro . return_value [EOL] [EOL] @ pytest . mark . asyncio async def test_subscribe ( self , * , consumer ) : [EOL] await consumer . subscribe ( topics = [ [string] , [string] , [string] ] ) [EOL] consumer . _thread . subscribe . assert_called_once_with ( topics = [ [string] , [string] , [string] ] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_seek_to_committed ( self , * , consumer ) : [EOL] ret = await consumer . seek_to_committed ( ) [EOL] consumer . _thread . seek_to_committed . assert_called_once_with ( ) [EOL] assert ret is consumer . _thread . seek_to_committed . coro . return_value [EOL] [EOL] @ pytest . mark . asyncio async def test_position ( self , * , consumer ) : [EOL] ret = await consumer . position ( TP1 ) [EOL] consumer . _thread . position . assert_called_once_with ( TP1 ) [EOL] assert ret is consumer . _thread . position . coro . return_value [EOL] [EOL] @ pytest . mark . asyncio async def test_seek_wait ( self , * , consumer ) : [EOL] await consumer . seek_wait ( { TP1 : [number] } ) [EOL] consumer . _thread . seek_wait . assert_called_once_with ( { TP1 : [number] } ) [EOL] [EOL] @ pytest . mark . asyncio async def test__seek ( self , * , consumer ) : [EOL] await consumer . _seek ( TP1 , [number] ) [EOL] consumer . _thread . seek . assert_called_once_with ( TP1 , [number] ) [EOL] [EOL] def test_assignment ( self , * , consumer ) : [EOL] ret = consumer . assignment ( ) [EOL] consumer . _thread . assignment . assert_called_once_with ( ) [EOL] assert ret is consumer . _thread . assignment ( ) [EOL] [EOL] def test_highwater ( self , * , consumer ) : [EOL] ret = consumer . highwater ( TP2 ) [EOL] consumer . _thread . highwater . assert_called_once_with ( TP2 ) [EOL] assert ret is consumer . _thread . highwater ( ) [EOL] [EOL] def test_topic_partitions ( self , * , consumer ) : [EOL] ret = consumer . topic_partitions ( TP2 . topic ) [EOL] consumer . _thread . topic_partitions . assert_called_once_with ( TP2 . topic ) [EOL] assert ret is consumer . _thread . topic_partitions ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_earliest_offsets ( self , * , consumer ) : [EOL] ret = await consumer . earliest_offsets ( TP1 , TP2 ) [EOL] consumer . _thread . earliest_offsets . assert_called_once_with ( TP1 , TP2 ) [EOL] assert ret is consumer . _thread . earliest_offsets . coro . return_value [EOL] [EOL] @ pytest . mark . asyncio async def test_highwaters ( self , * , consumer ) : [EOL] ret = await consumer . highwaters ( TP1 , TP2 ) [EOL] consumer . _thread . highwaters . assert_called_once_with ( TP1 , TP2 ) [EOL] assert ret is consumer . _thread . highwaters . coro . return_value [EOL] [EOL] @ pytest . mark . asyncio async def test_commit ( self , * , consumer ) : [EOL] ret = await consumer . _commit ( { TP1 : [number] , TP2 : [number] } ) [EOL] consumer . _thread . commit . assert_called_once_with ( { TP1 : [number] , TP2 : [number] } , ) [EOL] assert ret is consumer . _thread . commit . coro . return_value [EOL] [EOL] @ pytest . mark . asyncio async def test_maybe_wait_for_commit_to_finish ( self , * , loop , consumer ) : [EOL] consumer . _commit_fut = None [EOL] assert not await consumer . maybe_wait_for_commit_to_finish ( ) [EOL] consumer . _commit_fut = loop . create_future ( ) [EOL] consumer . _commit_fut . cancel ( ) [EOL] assert not await consumer . maybe_wait_for_commit_to_finish ( ) [EOL] consumer . _commit_fut = loop . create_future ( ) [EOL] consumer . _commit_fut . set_result ( None ) [EOL] assert await consumer . maybe_wait_for_commit_to_finish ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_close ( self , * , consumer ) : [EOL] consumer . close ( ) [EOL] consumer . _thread . close . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_key_partition ( self , * , consumer ) : [EOL] ret = consumer . key_partition ( [string] , [string] , partition = [number] ) [EOL] consumer . _thread . key_partition . assert_called_once_with ( [string] , [string] , partition = [number] , ) [EOL] assert ret is consumer . _thread . key_partition ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.transport.test_consumer.test_ThreadDelegateConsumer.TestThreadDelegateConsumer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.transport.test_consumer.test_ThreadDelegateConsumer.TestThreadDelegateConsumer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.transport.test_consumer.test_ThreadDelegateConsumer.TestThreadDelegateConsumer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.transport.test_consumer.test_ThreadDelegateConsumer.TestThreadDelegateConsumer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Any , Mapping , Set , Dict , Tuple [EOL] import t [EOL] import typing [EOL] import faust [EOL] from contextlib import contextmanager [EOL] import faust [EOL] import pytest [EOL] import aiokafka [EOL] from aiokafka . errors import CommitFailedError , IllegalStateError , KafkaError [EOL] from aiokafka . structs import OffsetAndMetadata , TopicPartition [EOL] from faust import auth [EOL] from faust . exceptions import ImproperlyConfigured , NotReady [EOL] from faust . transport . drivers . aiokafka import ( AIOKafkaConsumerThread , Consumer , ConsumerNotStarted , ConsumerRebalanceListener , ConsumerStoppedError , Producer , ProducerSendError , Transport , credentials_to_aiokafka_auth , server_list , ) [EOL] from faust . types import TP [EOL] from mode . utils . futures import done_future [EOL] from mode . utils . mocks import AsyncMock , MagicMock , Mock , call , patch [EOL] [EOL] TP1 = TP ( [string] , [number] ) [EOL] TP2 = TP ( [string] , [number] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def thread ( ) : [EOL] return Mock ( name = [string] , create_topic = AsyncMock ( ) , ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def consumer ( * , thread , app , callback , on_partitions_revoked , on_partitions_assigned ) : [EOL] consumer = Consumer ( app . transport , callback = callback , on_partitions_revoked = on_partitions_revoked , on_partitions_assigned = on_partitions_assigned , ) [EOL] consumer . _thread = thread [EOL] return consumer [EOL] [EOL] [EOL] @ pytest . fixture ( ) def callback ( ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def on_partitions_revoked ( ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def on_partitions_assigned ( ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] [EOL] class test_ConsumerRebalanceListener : [EOL] [EOL] @ pytest . fixture ( ) def handler ( self , * , thread ) : [EOL] return ConsumerRebalanceListener ( thread ) [EOL] [EOL] @ pytest . fixture ( ) def thread ( self ) : [EOL] return Mock ( name = [string] , on_partitions_assigned = AsyncMock ( ) , on_partitions_revoked = AsyncMock ( ) , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked ( self , * , handler , thread ) : [EOL] await handler . on_partitions_revoked ( [ TopicPartition ( [string] , [number] ) , TopicPartition ( [string] , [number] ) , ] ) [EOL] thread . on_partitions_revoked . assert_called_once_with ( { TP ( [string] , [number] ) , TP ( [string] , [number] ) , } ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_assigned ( self , * , handler , thread ) : [EOL] await handler . on_partitions_assigned ( [ TopicPartition ( [string] , [number] ) , TopicPartition ( [string] , [number] ) , ] ) [EOL] thread . on_partitions_assigned . assert_called_once_with ( { TP ( [string] , [number] ) , TP ( [string] , [number] ) , } ) [EOL] [EOL] [EOL] class test_Consumer : [EOL] [EOL] @ pytest . fixture ( ) def thread ( self ) : [EOL] return Mock ( name = [string] , create_topic = AsyncMock ( ) , ) [EOL] [EOL] @ pytest . fixture ( ) def consumer ( self , * , thread , app , callback , on_partitions_revoked , on_partitions_assigned ) : [EOL] consumer = Consumer ( app . transport , callback = callback , on_partitions_revoked = on_partitions_revoked , on_partitions_assigned = on_partitions_assigned , ) [EOL] consumer . _thread = thread [EOL] return consumer [EOL] [EOL] @ pytest . fixture ( ) def callback ( self ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] @ pytest . fixture ( ) def on_partitions_revoked ( self ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] @ pytest . fixture ( ) def on_partitions_assigned ( self ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_create_topic ( self , * , consumer , thread ) : [EOL] await consumer . create_topic ( [string] , [number] , [number] , timeout = [number] , retention = [number] , compacting = True , deleting = True , ensure_created = True , ) [EOL] thread . create_topic . assert_called_once_with ( [string] , [number] , [number] , config = None , timeout = [number] , retention = [number] , compacting = True , deleting = True , ensure_created = True , ) [EOL] [EOL] def test__new_topicpartition ( self , * , consumer ) : [EOL] tp = consumer . _new_topicpartition ( [string] , [number] ) [EOL] assert isinstance ( tp , TopicPartition ) [EOL] assert tp . topic == [string] [EOL] assert tp . partition == [number] [EOL] [EOL] def test__to_message ( self , * , consumer ) : [EOL] record = self . mock_record ( timestamp = [number] , headers = [ ( [string] , [string] ) ] , ) [EOL] m = consumer . _to_message ( TopicPartition ( [string] , [number] ) , record ) [EOL] assert m . topic == record . topic [EOL] assert m . partition == record . partition [EOL] assert m . offset == record . offset [EOL] assert m . timestamp == [number] [EOL] assert m . headers == record . headers [EOL] assert m . key == record . key [EOL] assert m . value == record . value [EOL] assert m . checksum == record . checksum [EOL] assert m . serialized_key_size == record . serialized_key_size [EOL] assert m . serialized_value_size == record . serialized_value_size [EOL] [EOL] def test__to_message__no_timestamp ( self , * , consumer ) : [EOL] record = self . mock_record ( timestamp = None ) [EOL] m = consumer . _to_message ( TopicPartition ( [string] , [number] ) , record ) [EOL] assert m . timestamp is None [EOL] [EOL] def mock_record ( self , topic = [string] , partition = [number] , offset = [number] , timestamp = None , timestamp_type = [number] , headers = None , key = [string] , value = [string] , checksum = [number] , serialized_key_size = [number] , serialized_value_size = [number] , ** kwargs ) : [EOL] return Mock ( name = [string] , topic = topic , partition = partition , offset = offset , timestamp = timestamp , timestamp_type = timestamp_type , headers = headers , key = key , value = value , checksum = checksum , serialized_key_size = serialized_key_size , serialized_value_size = serialized_value_size , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop ( self , * , consumer ) : [EOL] consumer . transport . _topic_waiters = { [string] : Mock ( ) } [EOL] await consumer . on_stop ( ) [EOL] assert not consumer . transport . _topic_waiters [EOL] [EOL] [EOL] class test_AIOKafkaConsumerThread : [EOL] [EOL] @ pytest . fixture ( ) def cthread ( self , * , consumer ) : [EOL] return AIOKafkaConsumerThread ( consumer ) [EOL] [EOL] @ pytest . fixture ( ) def _consumer ( self ) : [EOL] return Mock ( name = [string] , autospec = aiokafka . AIOKafkaConsumer , start = AsyncMock ( ) , stop = AsyncMock ( ) , commit = AsyncMock ( ) , position = AsyncMock ( ) , end_offsets = AsyncMock ( ) , ) [EOL] [EOL] def test_constructor ( self , * , cthread ) : [EOL] assert cthread . _partitioner [EOL] assert cthread . _rebalance_listener [EOL] [EOL] @ pytest . mark . asyncio async def test_on_start ( self , * , cthread , _consumer ) : [EOL] cthread . _create_consumer = Mock ( name = [string] , return_value = _consumer , ) [EOL] await cthread . on_start ( ) [EOL] [EOL] assert cthread . _consumer is cthread . _create_consumer . return_value [EOL] cthread . _create_consumer . assert_called_once_with ( loop = cthread . thread_loop ) [EOL] cthread . _consumer . start . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_thread_stop ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] await cthread . on_thread_stop ( ) [EOL] cthread . _consumer . stop . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_thread_stop__consumer_not_started ( self , * , cthread ) : [EOL] cthread . _consumer = None [EOL] await cthread . on_thread_stop ( ) [EOL] [EOL] def test__create_consumer__client ( self , * , cthread , app ) : [EOL] app . client_only = True [EOL] loop = Mock ( name = [string] ) [EOL] cthread . _create_client_consumer = Mock ( name = [string] ) [EOL] c = cthread . _create_consumer ( loop = loop ) [EOL] assert c is cthread . _create_client_consumer . return_value [EOL] cthread . _create_client_consumer . assert_called_once_with ( cthread . transport , loop = loop ) [EOL] [EOL] def test__create_consumer__worker ( self , * , cthread , app ) : [EOL] app . client_only = False [EOL] loop = Mock ( name = [string] ) [EOL] cthread . _create_worker_consumer = Mock ( name = [string] ) [EOL] c = cthread . _create_consumer ( loop = loop ) [EOL] assert c is cthread . _create_worker_consumer . return_value [EOL] cthread . _create_worker_consumer . assert_called_once_with ( cthread . transport , loop = loop ) [EOL] [EOL] def test__create_worker_consumer ( self , * , cthread , app ) : [EOL] self . assert_create_worker_consumer ( cthread , app , in_transaction = False , isolation_level = [string] , ) [EOL] [EOL] def test__create_worker_consumer__transaction ( self , * , cthread , app ) : [EOL] self . assert_create_worker_consumer ( cthread , app , in_transaction = True , isolation_level = [string] , ) [EOL] [EOL] def assert_create_worker_consumer ( self , cthread , app , in_transaction = False , isolation_level = [string] , api_version = None ) : [EOL] loop = Mock ( name = [string] ) [EOL] transport = cthread . transport [EOL] conf = app . conf [EOL] cthread . consumer . in_transaction = in_transaction [EOL] auth_settings = credentials_to_aiokafka_auth ( conf . broker_credentials , conf . ssl_context ) [EOL] with patch ( [string] ) as AIOKafkaConsumer : [EOL] c = cthread . _create_worker_consumer ( transport , loop ) [EOL] assert c is AIOKafkaConsumer . return_value [EOL] AIOKafkaConsumer . assert_called_once_with ( loop = loop , client_id = conf . broker_client_id , group_id = conf . id , bootstrap_servers = server_list ( transport . url , transport . default_port ) , partition_assignment_strategy = [ cthread . _assignor ] , enable_auto_commit = False , auto_offset_reset = conf . consumer_auto_offset_reset , max_poll_records = conf . broker_max_poll_records , max_partition_fetch_bytes = conf . consumer_max_fetch_size , fetch_max_wait_ms = [number] , request_timeout_ms = int ( conf . broker_request_timeout * [number] ) , check_crcs = conf . broker_check_crcs , session_timeout_ms = int ( conf . broker_session_timeout * [number] ) , heartbeat_interval_ms = int ( conf . broker_heartbeat_interval * [number] ) , isolation_level = isolation_level , ** auth_settings , ) [EOL] [EOL] def test__create_client_consumer ( self , * , cthread , app ) : [EOL] loop = Mock ( name = [string] ) [EOL] transport = cthread . transport [EOL] conf = app . conf [EOL] auth_settings = credentials_to_aiokafka_auth ( conf . broker_credentials , conf . ssl_context ) [EOL] with patch ( [string] ) as AIOKafkaConsumer : [EOL] c = cthread . _create_client_consumer ( transport , loop ) [EOL] assert c is AIOKafkaConsumer . return_value [EOL] AIOKafkaConsumer . assert_called_once_with ( loop = loop , client_id = conf . broker_client_id , bootstrap_servers = server_list ( transport . url , transport . default_port ) , request_timeout_ms = int ( conf . broker_request_timeout * [number] ) , enable_auto_commit = True , max_poll_records = conf . broker_max_poll_records , auto_offset_reset = conf . consumer_auto_offset_reset , check_crcs = conf . broker_check_crcs , ** auth_settings , ) [EOL] [EOL] def test_close ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] cthread . close ( ) [EOL] _consumer . set_close . assert_called_once_with ( ) [EOL] _consumer . _coordinator . set_close . assert_called_once_with ( ) [EOL] [EOL] def test_close__no_consumer ( self , * , cthread ) : [EOL] cthread . _consumer = None [EOL] cthread . close ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_subscribe ( self , * , cthread , _consumer ) : [EOL] with self . assert_calls_thread ( cthread , _consumer , _consumer . subscribe , topics = { [string] , [string] } , listener = cthread . _rebalance_listener ) : [EOL] await cthread . subscribe ( [ [string] , [string] ] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_seek_to_committed ( self , * , cthread , _consumer ) : [EOL] with self . assert_calls_thread ( cthread , _consumer , _consumer . seek_to_committed ) : [EOL] await cthread . seek_to_committed ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit ( self , * , cthread , _consumer ) : [EOL] offsets = { TP1 : [number] } [EOL] with self . assert_calls_thread ( cthread , _consumer , cthread . _commit , offsets ) : [EOL] await cthread . commit ( offsets ) [EOL] [EOL] @ pytest . mark . asyncio async def test__commit ( self , * , cthread , _consumer ) : [EOL] offsets = { TP1 : [number] } [EOL] cthread . _consumer = _consumer [EOL] await cthread . _commit ( offsets ) [EOL] [EOL] _consumer . commit . assert_called_once_with ( { TP1 : OffsetAndMetadata ( [number] , [string] ) } , ) [EOL] [EOL] @ pytest . mark . asyncio async def test__commit__already_rebalancing ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] _consumer . commit . side_effect = CommitFailedError ( [string] ) [EOL] assert not ( await cthread . _commit ( { TP1 : [number] } ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test__commit__CommitFailedError ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] exc = _consumer . commit . side_effect = CommitFailedError ( [string] ) [EOL] cthread . crash = AsyncMock ( ) [EOL] assert not ( await cthread . _commit ( { TP1 : [number] } ) ) [EOL] cthread . crash . assert_called_once_with ( exc ) [EOL] [EOL] @ pytest . mark . asyncio async def test__commit__IllegalStateError ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] cthread . assignment = Mock ( ) [EOL] exc = _consumer . commit . side_effect = IllegalStateError ( [string] ) [EOL] cthread . crash = AsyncMock ( ) [EOL] assert not ( await cthread . _commit ( { TP1 : [number] } ) ) [EOL] cthread . crash . assert_called_once_with ( exc ) [EOL] [EOL] @ pytest . mark . asyncio async def test_position ( self , * , cthread , _consumer ) : [EOL] with self . assert_calls_thread ( cthread , _consumer , _consumer . position , TP1 ) : [EOL] await cthread . position ( TP1 ) [EOL] [EOL] @ pytest . mark . asyncio async def test_seek_to_beginning ( self , * , cthread , _consumer ) : [EOL] partitions = ( TP1 , ) [EOL] with self . assert_calls_thread ( cthread , _consumer , _consumer . seek_to_beginning , * partitions ) : [EOL] await cthread . seek_to_beginning ( * partitions ) [EOL] [EOL] @ pytest . mark . asyncio async def test_seek_wait ( self , * , cthread , _consumer ) : [EOL] partitions = { TP1 : [number] } [EOL] with self . assert_calls_thread ( cthread , _consumer , cthread . _seek_wait , _consumer , partitions ) : [EOL] await cthread . seek_wait ( partitions ) [EOL] [EOL] @ pytest . mark . asyncio async def test__seek_wait ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] cthread . consumer . _read_offset . clear ( ) [EOL] partitions = { TP1 : [number] , TP2 : [number] } [EOL] [EOL] await cthread . _seek_wait ( _consumer , partitions ) [EOL] [EOL] assert cthread . consumer . _read_offset [ TP2 ] == [number] [EOL] assert TP1 not in cthread . consumer . _read_offset [EOL] [EOL] _consumer . position . assert_has_calls ( [ call ( TP1 ) , call ( TP2 ) , ] ) [EOL] [EOL] @ pytest . mark . asyncio async def test__seek_wait__empty ( self , * , cthread , _consumer ) : [EOL] await cthread . _seek_wait ( _consumer , { } ) [EOL] [EOL] def test_seek ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] cthread . seek ( TP1 , [number] ) [EOL] _consumer . seek . assert_called_once_with ( TP1 , [number] ) [EOL] [EOL] def test_assignment ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] _consumer . assignment . return_value = { TopicPartition ( TP1 . topic , TP1 . partition ) , } [EOL] assignment = cthread . assignment ( ) [EOL] assert assignment == { TP1 } [EOL] assert all ( isinstance ( x , TP ) for x in assignment ) [EOL] [EOL] def test_highwater ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] cthread . consumer . in_transaction = False [EOL] ret = cthread . highwater ( TP1 ) [EOL] assert ret is _consumer . highwater . return_value [EOL] _consumer . highwater . assert_called_once_with ( TP1 ) [EOL] [EOL] def test_highwater__in_transaction ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] cthread . consumer . in_transaction = True [EOL] ret = cthread . highwater ( TP1 ) [EOL] assert ret is _consumer . last_stable_offset . return_value [EOL] _consumer . last_stable_offset . assert_called_once_with ( TP1 ) [EOL] [EOL] def test_topic_partitions ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = None [EOL] assert cthread . topic_partitions ( [string] ) is None [EOL] cthread . _consumer = _consumer [EOL] assert cthread . topic_partitions ( [string] ) is ( _consumer . _coordinator . _metadata_snapshot . get . return_value ) [EOL] [EOL] @ pytest . mark . asyncio async def test_earliest_offsets ( self , * , cthread , _consumer ) : [EOL] with self . assert_calls_thread ( cthread , _consumer , _consumer . beginning_offsets , ( TP1 , ) ) : [EOL] await cthread . earliest_offsets ( TP1 ) [EOL] [EOL] @ pytest . mark . asyncio async def test_highwaters ( self , * , cthread , _consumer ) : [EOL] with self . assert_calls_thread ( cthread , _consumer , cthread . _highwaters , ( TP1 , ) ) : [EOL] await cthread . highwaters ( TP1 ) [EOL] [EOL] @ pytest . mark . asyncio async def test__highwaters ( self , * , cthread , _consumer ) : [EOL] cthread . consumer . in_transaction = False [EOL] cthread . _consumer = _consumer [EOL] assert await cthread . _highwaters ( [ TP1 ] ) is ( _consumer . end_offsets . coro . return_value ) [EOL] [EOL] @ pytest . mark . asyncio async def test__highwaters__in_transaction ( self , * , cthread , _consumer ) : [EOL] cthread . consumer . in_transaction = True [EOL] cthread . _consumer = _consumer [EOL] assert await cthread . _highwaters ( [ TP1 ] ) == { TP1 : _consumer . last_stable_offset . return_value , } [EOL] [EOL] def test__ensure_consumer ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] assert cthread . _ensure_consumer ( ) is _consumer [EOL] cthread . _consumer = None [EOL] with pytest . raises ( ConsumerNotStarted ) : [EOL] cthread . _ensure_consumer ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_getmany ( self , * , cthread , _consumer ) : [EOL] timeout = [number] [EOL] active_partitions = { TP1 } [EOL] with self . assert_calls_thread ( cthread , _consumer , cthread . _fetch_records , _consumer , active_partitions , timeout = timeout , max_records = _consumer . _max_poll_records ) : [EOL] await cthread . getmany ( active_partitions , timeout ) [EOL] [EOL] @ pytest . mark . asyncio async def test__fetch_records__flow_inactive ( self , * , cthread , _consumer ) : [EOL] cthread . consumer . flow_active = False [EOL] assert await cthread . _fetch_records ( _consumer , set ( ) ) == { } [EOL] [EOL] @ pytest . mark . asyncio async def test__fetch_records_consumer_closed ( self , * , cthread , _consumer ) : [EOL] _consumer . _closed = True [EOL] with pytest . raises ( ConsumerStoppedError ) : [EOL] await cthread . _fetch_records ( _consumer , set ( ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test__fetch_records_fetcher_closed ( self , * , cthread , _consumer ) : [EOL] _consumer . _closed = False [EOL] _consumer . _fetcher . _closed = True [EOL] with pytest . raises ( ConsumerStoppedError ) : [EOL] await cthread . _fetch_records ( _consumer , set ( ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test__fetch_records ( self , * , cthread , _consumer ) : [EOL] _consumer . _closed = False [EOL] fetcher = _consumer . _fetcher [EOL] fetcher . _closed = False [EOL] fetcher . _subscriptions . fetch_context = MagicMock ( ) [EOL] fetcher . fetched_records = AsyncMock ( ) [EOL] ret = await cthread . _fetch_records ( _consumer , { TP1 } , timeout = [number] , max_records = [number] ) [EOL] assert ret is fetcher . fetched_records . coro . return_value [EOL] fetcher . fetched_records . assert_called_once_with ( { TP1 } , timeout = [number] , max_records = [number] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_create_topic ( self , * , cthread , _consumer ) : [EOL] topic = [string] [EOL] partitions = [number] [EOL] replication = [number] [EOL] config = { [string] : [string] } [EOL] timeout = [number] [EOL] retention = [number] [EOL] compacting = True [EOL] deleting = False [EOL] ensure_created = True [EOL] [EOL] transport = cthread . transport [EOL] with self . assert_calls_thread ( cthread , _consumer , transport . _create_topic , cthread , _consumer . _client , topic , partitions , replication , config = config , timeout = int ( timeout * [number] ) , retention = int ( retention * [number] ) , compacting = compacting , deleting = deleting , ensure_created = ensure_created ) : [EOL] await cthread . create_topic ( topic , partitions , replication , config = config , timeout = timeout , retention = retention , compacting = compacting , deleting = deleting , ensure_created = ensure_created , ) [EOL] [EOL] def test_key_partition ( self , * , cthread , _consumer ) : [EOL] cthread . _consumer = _consumer [EOL] cthread . _partitioner = Mock ( name = [string] ) [EOL] metadata = _consumer . _client . cluster [EOL] metadata . partitions_for_topic . return_value = [ [number] , [number] , [number] ] [EOL] metadata . available_partitions_for_topic . return_value = [ [number] , [number] ] [EOL] [EOL] cthread . key_partition ( [string] , [string] , None ) [EOL] cthread . _partitioner . assert_called_once_with ( [string] , [ [number] , [number] , [number] ] , [ [number] , [number] ] , ) [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] cthread . key_partition ( [string] , [string] , - [number] ) [EOL] with pytest . raises ( AssertionError ) : [EOL] cthread . key_partition ( [string] , [string] , [number] ) [EOL] [EOL] assert cthread . key_partition ( [string] , [string] , [number] ) == [number] [EOL] [EOL] @ contextmanager def assert_calls_thread ( self , cthread , _consumer , method , * args , ** kwargs ) : [EOL] cthread . _consumer = _consumer [EOL] cthread . call_thread = AsyncMock ( ) [EOL] try : [EOL] yield [EOL] finally : [EOL] cthread . call_thread . assert_called_once_with ( method , * args , ** kwargs ) [EOL] [EOL] [EOL] class MyPartitioner : [EOL] ... [EOL] [EOL] [EOL] my_partitioner = MyPartitioner ( ) [EOL] [EOL] [EOL] class test_Producer : [EOL] [EOL] @ pytest . fixture ( ) def producer ( self , * , app , _producer ) : [EOL] producer = Producer ( app . transport ) [EOL] producer . _producer = _producer [EOL] return producer [EOL] [EOL] @ pytest . fixture ( ) def _producer ( self ) : [EOL] return Mock ( name = [string] , autospec = aiokafka . AIOKafkaProducer , start = AsyncMock ( ) , stop = AsyncMock ( ) , begin_transaction = AsyncMock ( ) , commit_transaction = AsyncMock ( ) , abort_transaction = AsyncMock ( ) , stop_transaction = AsyncMock ( ) , maybe_begin_transaction = AsyncMock ( ) , commit = AsyncMock ( ) , send = AsyncMock ( ) , flush = AsyncMock ( ) , ) [EOL] [EOL] @ pytest . mark . conf ( producer_partitioner = my_partitioner ) def test_producer__uses_custom_partitioner ( self , * , producer ) : [EOL] assert producer . partitioner is my_partitioner [EOL] [EOL] @ pytest . mark . asyncio async def test_begin_transaction ( self , * , producer , _producer ) : [EOL] await producer . begin_transaction ( [string] ) [EOL] _producer . begin_transaction . assert_called_once_with ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_transaction ( self , * , producer , _producer ) : [EOL] await producer . commit_transaction ( [string] ) [EOL] _producer . commit_transaction . assert_called_once_with ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_abort_transaction ( self , * , producer , _producer ) : [EOL] await producer . abort_transaction ( [string] ) [EOL] _producer . abort_transaction . assert_called_once_with ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_stop_transaction ( self , * , producer , _producer ) : [EOL] await producer . stop_transaction ( [string] ) [EOL] _producer . stop_transaction . assert_called_once_with ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_maybe_begin_transaction ( self , * , producer , _producer ) : [EOL] await producer . maybe_begin_transaction ( [string] ) [EOL] _producer . maybe_begin_transaction . assert_called_once_with ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_transactions ( self , * , producer , _producer ) : [EOL] tid_to_offset_map = { [string] : { TP1 : [number] } , [string] : { TP2 : [number] } } [EOL] await producer . commit_transactions ( tid_to_offset_map , [string] , start_new_transaction = False ) [EOL] _producer . commit . assert_called_once_with ( tid_to_offset_map , [string] , start_new_transaction = False ) [EOL] [EOL] def test__settings_extra ( self , * , producer , app ) : [EOL] app . in_transaction = True [EOL] assert producer . _settings_extra ( ) == { [string] : [string] } [EOL] app . in_transaction = False [EOL] assert producer . _settings_extra ( ) == { } [EOL] [EOL] def test__new_producer ( self , * , producer ) : [EOL] self . assert_new_producer ( producer ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ pytest . param ( { [string] : [string] } , marks = pytest . mark . conf ( producer_api_version = [string] ) ) , pytest . param ( { [string] : [string] } , marks = pytest . mark . conf ( producer_acks = [string] ) ) , pytest . param ( { [string] : [ [string] , [string] ] } , marks = pytest . mark . conf ( broker = [string] ) ) , pytest . param ( { [string] : [string] } , marks = pytest . mark . conf ( broker_client_id = [string] ) ) , pytest . param ( { [string] : [string] } , marks = pytest . mark . conf ( producer_compression_type = [string] ) ) , pytest . param ( { [string] : [number] } , marks = pytest . mark . conf ( producer_linger_ms = [number] ) ) , pytest . param ( { [string] : [number] } , marks = pytest . mark . conf ( producer_max_batch_size = [number] ) ) , pytest . param ( { [string] : [number] } , marks = pytest . mark . conf ( producer_max_request_size = [number] ) ) , pytest . param ( { [string] : [number] } , marks = pytest . mark . conf ( producer_request_timeout = [number] ) ) , pytest . param ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None } , marks = pytest . mark . conf ( broker_credentials = auth . SASLCredentials ( username = [string] , password = [string] , mechanism = [string] ) , ) , ) , ] ) def test__new_producer__using_settings ( self , expected_args , * , app , producer ) : [EOL] self . assert_new_producer ( producer , ** expected_args ) [EOL] [EOL] def assert_new_producer ( self , producer , acks = - [number] , api_version = [string] , bootstrap_servers = [ [string] ] , client_id = f' [string] { faust . __version__ }' , compression_type = None , linger_ms = [number] , max_batch_size = [number] , max_request_size = [number] , request_timeout_ms = [number] , security_protocol = [string] , ** kwargs ) : [EOL] with patch ( [string] ) as AIOKafkaProducer : [EOL] p = producer . _new_producer ( ) [EOL] assert p is AIOKafkaProducer . return_value [EOL] AIOKafkaProducer . assert_called_once_with ( acks = acks , api_version = api_version , bootstrap_servers = bootstrap_servers , client_id = client_id , compression_type = compression_type , linger_ms = linger_ms , max_batch_size = max_batch_size , max_request_size = max_request_size , request_timeout_ms = request_timeout_ms , security_protocol = security_protocol , loop = producer . loop , partitioner = producer . partitioner , on_irrecoverable_error = producer . _on_irrecoverable_error , ** kwargs , ) [EOL] [EOL] def test__new_producer__default ( self , * , producer ) : [EOL] p = producer . _new_producer ( ) [EOL] assert isinstance ( p , aiokafka . AIOKafkaProducer ) [EOL] [EOL] def test__new_producer__in_transaction ( self , * , producer ) : [EOL] producer . app . in_transaction = True [EOL] p = producer . _new_producer ( ) [EOL] assert isinstance ( p , aiokafka . MultiTXNProducer ) [EOL] [EOL] def test__producer_type ( self , * , producer , app ) : [EOL] app . in_transaction = True [EOL] assert producer . _producer_type is aiokafka . MultiTXNProducer [EOL] app . in_transaction = False [EOL] assert producer . _producer_type is aiokafka . AIOKafkaProducer [EOL] [EOL] @ pytest . mark . asyncio async def test__on_irrecoverable_error ( self , * , producer ) : [EOL] exc = KeyError ( ) [EOL] producer . crash = AsyncMock ( ) [EOL] app = producer . transport . app [EOL] app . consumer = None [EOL] await producer . _on_irrecoverable_error ( exc ) [EOL] producer . crash . assert_called_once_with ( exc ) [EOL] app . consumer = Mock ( name = [string] ) [EOL] app . consumer . crash = AsyncMock ( ) [EOL] await producer . _on_irrecoverable_error ( exc ) [EOL] app . consumer . crash . assert_called_once_with ( exc ) [EOL] [EOL] @ pytest . mark . asyncio async def test_create_topic ( self , * , producer , _producer ) : [EOL] producer . transport = Mock ( _create_topic = AsyncMock ( ) , ) [EOL] await producer . create_topic ( [string] , [number] , [number] , config = { [string] : [string] } , timeout = [number] , retention = [number] , compacting = True , deleting = True , ensure_created = True , ) [EOL] producer . transport . _create_topic . coro . assert_called_once_with ( producer , _producer . client , [string] , [number] , [number] , config = { [string] : [string] } , timeout = int ( [number] * [number] ) , retention = int ( [number] * [number] ) , compacting = True , deleting = True , ensure_created = True , ) [EOL] [EOL] def test__ensure_producer ( self , * , producer , _producer ) : [EOL] assert producer . _ensure_producer ( ) is _producer [EOL] producer . _producer = None [EOL] with pytest . raises ( NotReady ) : [EOL] producer . _ensure_producer ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_start ( self , * , producer , loop ) : [EOL] producer . _new_producer = Mock ( name = [string] , return_value = Mock ( start = AsyncMock ( ) , ) , ) [EOL] _producer = producer . _new_producer . return_value [EOL] producer . beacon = Mock ( ) [EOL] producer . _last_batch = loop . time ( ) [EOL] [EOL] await producer . on_start ( ) [EOL] assert producer . _producer is _producer [EOL] producer . _new_producer . assert_called_once_with ( ) [EOL] producer . beacon . add . assert_called_once_with ( _producer ) [EOL] _producer . start . coro . assert_called_once_with ( ) [EOL] assert producer . _last_batch is None [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop ( self , * , producer , _producer ) : [EOL] await producer . on_stop ( ) [EOL] assert producer . _producer is None [EOL] _producer . stop . assert_called_once_with ( ) [EOL] [EOL] def test_supports_headers__not_ready ( self , * , producer ) : [EOL] producer . _producer . client = None [EOL] with pytest . raises ( NotReady ) : [EOL] producer . supports_headers ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_send ( self , producer , _producer ) : [EOL] await producer . send ( [string] , [string] , [string] , [number] , [number] , { [string] : [string] } , transactional_id = [string] , ) [EOL] _producer . send . assert_called_once_with ( [string] , [string] , key = [string] , partition = [number] , timestamp_ms = [number] * [number] , headers = [ ( [string] , [string] ) ] , transactional_id = [string] , ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . conf ( producer_api_version = [string] ) async def test_send__request_no_headers ( self , producer , _producer ) : [EOL] await producer . send ( [string] , [string] , [string] , [number] , [number] , { [string] : [string] } , transactional_id = [string] , ) [EOL] _producer . send . assert_called_once_with ( [string] , [string] , key = [string] , partition = [number] , timestamp_ms = [number] * [number] , headers = None , transactional_id = [string] , ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . conf ( producer_api_version = [string] ) async def test_send__kafka011_supports_headers ( self , producer , _producer ) : [EOL] await producer . send ( [string] , [string] , [string] , [number] , [number] , { [string] : [string] } , transactional_id = [string] , ) [EOL] _producer . send . assert_called_once_with ( [string] , [string] , key = [string] , partition = [number] , timestamp_ms = [number] * [number] , headers = [ ( [string] , [string] ) ] , transactional_id = [string] , ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . conf ( producer_api_version = [string] ) async def test_send__auto_passes_headers ( self , producer , _producer ) : [EOL] await producer . send ( [string] , [string] , [string] , [number] , [number] , [ ( [string] , [string] ) ] , transactional_id = [string] , ) [EOL] _producer . send . assert_called_once_with ( [string] , [string] , key = [string] , partition = [number] , timestamp_ms = [number] * [number] , headers = [ ( [string] , [string] ) ] , transactional_id = [string] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_send__no_headers ( self , producer , _producer ) : [EOL] await producer . send ( [string] , [string] , [string] , [number] , [number] , None , transactional_id = [string] , ) [EOL] _producer . send . assert_called_once_with ( [string] , [string] , key = [string] , partition = [number] , timestamp_ms = [number] * [number] , headers = None , transactional_id = [string] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_send__no_timestamp ( self , producer , _producer ) : [EOL] await producer . send ( [string] , [string] , [string] , [number] , None , None , transactional_id = [string] , ) [EOL] _producer . send . assert_called_once_with ( [string] , [string] , key = [string] , partition = [number] , timestamp_ms = None , headers = None , transactional_id = [string] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_send__KafkaError ( self , producer , _producer ) : [EOL] _producer . send . coro . side_effect = KafkaError ( ) [EOL] with pytest . raises ( ProducerSendError ) : [EOL] await producer . send ( [string] , [string] , [string] , [number] , None , None , transactional_id = [string] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_send_and_wait ( self , producer ) : [EOL] producer . send = AsyncMock ( return_value = done_future ( done_future ( ) ) ) [EOL] [EOL] await producer . send_and_wait ( [string] , [string] , [string] , [number] , [number] , [ ( [string] , [string] ) ] , transactional_id = [string] ) [EOL] producer . send . assert_called_once_with ( [string] , key = [string] , value = [string] , partition = [number] , timestamp = [number] , headers = [ ( [string] , [string] ) ] , transactional_id = [string] , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_flush ( self , * , producer , _producer ) : [EOL] producer . _producer = None [EOL] await producer . flush ( ) [EOL] producer . _producer = _producer [EOL] await producer . flush ( ) [EOL] _producer . flush . assert_called_once_with ( ) [EOL] [EOL] def test_key_partition ( self , * , producer , _producer ) : [EOL] x = producer . key_partition ( [string] , [string] ) [EOL] assert x == TP ( [string] , _producer . _partition . return_value ) [EOL] [EOL] def test_supports_headers ( self , * , producer ) : [EOL] producer . _producer . client . api_version = ( [number] , [number] ) [EOL] assert producer . supports_headers ( ) [EOL] [EOL] [EOL] class test_Transport : [EOL] [EOL] @ pytest . fixture ( ) def transport ( self , * , app ) : [EOL] return Transport ( url = [ [string] ] , app = app ) [EOL] [EOL] def test_constructor ( self , * , transport ) : [EOL] assert transport . _topic_waiters == { } [EOL] [EOL] def test__topic_config ( self , * , transport ) : [EOL] assert transport . _topic_config ( ) == { } [EOL] [EOL] def test__topic_config__retention ( self , * , transport ) : [EOL] assert transport . _topic_config ( retention = [number] ) == { [string] : [number] , } [EOL] [EOL] def test__topic_config__compacting ( self , * , transport ) : [EOL] assert transport . _topic_config ( compacting = True ) == { [string] : [string] , } [EOL] [EOL] def test__topic_config__deleting ( self , * , transport ) : [EOL] assert transport . _topic_config ( deleting = True ) == { [string] : [string] , } [EOL] [EOL] def test__topic_config__combined ( self , * , transport ) : [EOL] res = transport . _topic_config ( compacting = True , deleting = True , retention = [number] ) [EOL] assert res == { [string] : [number] , [string] : [string] , } [EOL] [EOL] @ pytest . mark . asyncio async def test__create_topic ( self , * , transport ) : [EOL] client = Mock ( name = [string] ) [EOL] transport . _topic_waiters [ [string] ] = AsyncMock ( ) [EOL] await transport . _create_topic ( transport , client , topic = [string] , partitions = [number] , replication = [number] , ) [EOL] transport . _topic_waiters [ [string] ] . coro . assert_called_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test__create_topic__missing ( self , * , transport , loop ) : [EOL] client = Mock ( name = [string] ) [EOL] transport . _topic_waiters . clear ( ) [EOL] with patch ( [string] ) as SW : [EOL] SW . return_value = AsyncMock ( ) [EOL] await transport . _create_topic ( transport , client , topic = [string] , partitions = [number] , replication = [number] , ) [EOL] SW . assert_called_once_with ( transport . _really_create_topic , transport , client , [string] , [number] , [number] , loop = loop , ) [EOL] SW . return_value . coro . assert_called_once_with ( ) [EOL] assert transport . _topic_waiters [ [string] ] is SW . return_value [EOL] [EOL] @ pytest . mark . asyncio async def test__create_topic__raises ( self , * , transport , loop ) : [EOL] client = Mock ( name = [string] ) [EOL] transport . _topic_waiters . clear ( ) [EOL] with patch ( [string] ) as SW : [EOL] SW . return_value = AsyncMock ( ) [EOL] SW . return_value . coro . side_effect = KeyError ( [string] ) [EOL] with pytest . raises ( KeyError ) : [EOL] await transport . _create_topic ( transport , client , topic = [string] , partitions = [number] , replication = [number] , ) [EOL] assert [string] not in transport . _topic_waiters [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , { } , { [string] : [string] , [string] : { } , } ) , ( None , None , { [string] : [string] , } ) , ( auth . SSLCredentials ( { } ) , None , { [string] : [string] , [string] : { } , } ) , ( auth . SASLCredentials ( username = [string] , password = [string] ) , None , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } ) , ( auth . GSSAPICredentials ( kerberos_service_name = [string] , kerberos_domain_name = [string] ) , None , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } ) , ] ) def test_credentials_to_aiokafka ( credentials , ssl_context , expected ) : [EOL] assert credentials_to_aiokafka_auth ( credentials , ssl_context ) == expected [EOL] [EOL] [EOL] def test_credentials_to_aiokafka__invalid ( ) : [EOL] with pytest . raises ( ImproperlyConfigured ) : [EOL] credentials_to_aiokafka_auth ( object ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.transport.drivers.aiokafka.Consumer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.transport.drivers.aiokafka.Consumer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.transport.drivers.aiokafka.Consumer$ 0 0 0 0 0 0 $faust.transport.drivers.aiokafka.Consumer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.transport.drivers.test_aiokafka.MyPartitioner$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.transport.drivers.test_aiokafka.MyPartitioner$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.transport.drivers.test_aiokafka.MyPartitioner$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,builtins.int]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 0 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import t [EOL] import typing [EOL] from mode import Service , label [EOL] from mode . utils . mocks import AsyncMock , Mock , call [EOL] import pytest [EOL] [EOL] [EOL] class OtherService ( Service ) : [EOL] ... [EOL] [EOL] [EOL] class test_AppService : [EOL] [EOL] def test_on_init_dependencies ( self , * , app ) : [EOL] app . boot_strategy = Mock ( name = [string] ) [EOL] app . client_only = True [EOL] assert app . on_init_dependencies ( ) == app . boot_strategy . client_only ( ) [EOL] [EOL] app . client_only = False [EOL] assert app . on_init_dependencies ( ) == app . boot_strategy . server ( ) [EOL] [EOL] app . producer_only = True [EOL] assert app . on_init_dependencies ( ) == app . boot_strategy . producer_only ( ) [EOL] [EOL] def test_components_client ( self , * , app ) : [EOL] assert list ( app . boot_strategy . client_only ( ) ) == [ app . producer , app . consumer , app . _reply_consumer , app . topics , app . _fetcher , ] [EOL] [EOL] def test_components_producer_only ( self , * , app ) : [EOL] assert list ( app . boot_strategy . producer_only ( ) ) == [ app . cache , app . web , app . producer , ] [EOL] [EOL] def test_components_server ( self , * , app ) : [EOL] components = list ( app . boot_strategy . server ( ) ) [EOL] expected_components = list ( app . sensors ) [EOL] expected_components . extend ( [ app . producer , app . cache , app . web , app . consumer , app . _leader_assignor , app . _reply_consumer , ] ) [EOL] expected_components . extend ( list ( app . agents . values ( ) ) ) [EOL] expected_components . extend ( [ app . agents , app . topics , app . tables , ] ) [EOL] assert components == expected_components [EOL] [EOL] @ pytest . mark . asyncio async def test_on_first_start ( self , * , app ) : [EOL] app . agents = Mock ( name = [string] ) [EOL] app . _create_directories = Mock ( name = [string] ) [EOL] await app . on_first_start ( ) [EOL] [EOL] app . _create_directories . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_start ( self , * , app ) : [EOL] app . finalize = Mock ( name = [string] ) [EOL] await app . on_start ( ) [EOL] [EOL] app . finalize . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_started ( self , * , app ) : [EOL] app . _wait_for_table_recovery_completed = AsyncMock ( return_value = True ) [EOL] app . on_started_init_extra_tasks = AsyncMock ( name = [string] ) [EOL] app . on_started_init_extra_services = AsyncMock ( name = [string] ) [EOL] app . on_startup_finished = None [EOL] app . _wait_for_table_recovery_completed . coro . return_value = True [EOL] await app . on_started ( ) [EOL] [EOL] app . _wait_for_table_recovery_completed . coro . return_value = False [EOL] await app . on_started ( ) [EOL] [EOL] app . on_started_init_extra_tasks . assert_called_once_with ( ) [EOL] app . on_started_init_extra_services . assert_called_once_with ( ) [EOL] [EOL] app . on_startup_finished = AsyncMock ( name = [string] ) [EOL] await app . on_started ( ) [EOL] [EOL] app . on_startup_finished . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_wait_for_table_recovery_completed ( self , * , app ) : [EOL] app . tables = Mock ( ) [EOL] app . tables . recovery . started = True [EOL] app . wait_for_stopped = AsyncMock ( name = [string] ) [EOL] await app . _wait_for_table_recovery_completed ( ) [EOL] app . wait_for_stopped . assert_called_once_with ( app . tables . recovery . completed ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_started_init_extra_tasks ( self , * , app ) : [EOL] app . add_future = Mock ( name = [string] ) [EOL] [EOL] t1_mock = Mock ( name = [string] ) [EOL] t2_mock = Mock ( name = [string] ) [EOL] [EOL] def t1 ( ) : [EOL] return t1_mock ( ) [EOL] [EOL] def t2 ( ) : [EOL] return t2_mock ( self ) [EOL] [EOL] app . _tasks = [ t1 , t2 ] [EOL] await app . on_started_init_extra_tasks ( ) [EOL] [EOL] app . add_future . assert_has_calls ( [ call ( t1 ( ) ) , call ( t2 ( ) ) , ] ) [EOL] [EOL] t1_mock . assert_called_with ( ) [EOL] t2_mock . assert_called_with ( self ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_started_init_extra_services ( self , * , app ) : [EOL] app . add_runtime_dependency = AsyncMock ( name = [string] ) [EOL] service1 = Mock ( name = [string] , autospec = Service ) [EOL] app . _extra_services = [ service1 ] [EOL] app . _extra_service_instances = None [EOL] await app . on_started_init_extra_services ( ) [EOL] [EOL] app . add_runtime_dependency . assert_called_once_with ( service1 ) [EOL] assert app . _extra_service_instances == [ service1 ] [EOL] await app . on_started_init_extra_services ( ) [comment] [EOL] [EOL] def test_prepare_subservice ( self , * , app ) : [EOL] service = OtherService ( ) [EOL] assert app . _prepare_subservice ( service ) is service [EOL] [EOL] def test_prepare_subservice__class ( self , * , app ) : [EOL] service = app . _prepare_subservice ( OtherService ) [EOL] assert service . loop is app . loop [EOL] assert service . beacon . parent is app . beacon [EOL] [EOL] def test_label ( self , * , app ) : [EOL] assert label ( app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.app.test_service.OtherService$ 0 0 0 0 0 0 0 0 0 0 $t.unit.app.test_service.OtherService$ 0 0 $t.unit.app.test_service.OtherService$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from faust . app . router import Router [EOL] from faust . exceptions import SameNode [EOL] from faust . web . exceptions import ServiceUnavailable [EOL] from mode . utils . mocks import ANY , Mock [EOL] from yarl import URL [EOL] [EOL] [EOL] class test_Router : [EOL] [EOL] @ pytest . fixture ( ) def assignor ( self , * , app ) : [EOL] assignor = app . assignor = Mock ( name = [string] ) [EOL] return assignor [EOL] [EOL] @ pytest . fixture ( ) def router ( self , * , app , assignor ) : [EOL] return Router ( app ) [EOL] [EOL] def test_constructor ( self , * , router , app , assignor ) : [EOL] assert router . app is app [EOL] assert router . _assignor is assignor [EOL] [EOL] def test_key_store ( self , * , router , app , assignor ) : [EOL] table = app . tables [ [string] ] = Mock ( name = [string] ) [EOL] assert router . key_store ( [string] , [string] ) is assignor . key_store . return_value [EOL] assignor . key_store . assert_called_once_with ( table . changelog_topic . get_topic_name ( ) , table . changelog_topic . prepare_key . return_value , ) [EOL] [EOL] def test_table_metadata ( self , * , router , app , assignor ) : [EOL] table = app . tables [ [string] ] = Mock ( name = [string] ) [EOL] ret = router . table_metadata ( [string] ) [EOL] assert ret is assignor . table_metadata . return_value [EOL] assignor . table_metadata . assert_called_once_with ( table . changelog_topic . get_topic_name ( ) , ) [EOL] [EOL] def test_tables_metadata ( self , * , router , assignor ) : [EOL] res = router . tables_metadata ( ) [EOL] assert res is assignor . tables_metadata . return_value [EOL] assignor . tables_metadata . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_route_req__unavail ( self , * , router , app ) : [EOL] web = Mock ( name = [string] ) [EOL] request = Mock ( name = [string] ) [EOL] app . router . key_store = Mock ( ) [EOL] app . router . key_store . side_effect = KeyError ( ) [EOL] with pytest . raises ( ServiceUnavailable ) : [EOL] await router . route_req ( [string] , [string] , web , request ) [EOL] [EOL] @ pytest . mark . asyncio async def test_route_req__same_node ( self , * , router , app ) : [EOL] app . conf . canonical_url = URL ( [string] ) [EOL] web = Mock ( name = [string] ) [EOL] request = Mock ( name = [string] ) [EOL] app . router . key_store = Mock ( ) [EOL] app . router . key_store . return_value = URL ( [string] ) [EOL] with pytest . raises ( SameNode ) : [EOL] await router . route_req ( [string] , [string] , web , request ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . http_session ( text = [string] ) async def test_route_req ( self , * , router , app , mock_http_client ) : [EOL] app . conf . canonical_url = URL ( [string] ) [EOL] web = Mock ( name = [string] ) [EOL] request = Mock ( name = [string] ) [EOL] app . router . key_store = Mock ( ) [EOL] app . router . key_store . return_value = URL ( [string] ) [EOL] response = await router . route_req ( [string] , [string] , web , request ) [EOL] assert response is web . text . return_value [EOL] web . text . assert_called_once_with ( [string] , content_type = ANY ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Union , Set [EOL] import t [EOL] import typing [EOL] import re [EOL] import collections [EOL] import faust [EOL] from faust . agents import Agent [EOL] from faust . app . base import SCAN_AGENT , SCAN_PAGE , SCAN_TASK [EOL] from faust . assignor . leader_assignor import LeaderAssignor , LeaderAssignorT [EOL] from faust . channels import Channel , ChannelT [EOL] from faust . cli . base import AppCommand [EOL] from faust . exceptions import ( AlreadyConfiguredWarning , ConsumerNotStarted , ImproperlyConfigured , SameNode , ) [EOL] from faust . fixups . base import Fixup [EOL] from faust . sensors . monitor import Monitor [EOL] from faust . serializers import codecs [EOL] from faust . transport . base import Transport [EOL] from faust . transport . conductor import Conductor [EOL] from faust . transport . consumer import Consumer , Fetcher [EOL] from faust . types import TP [EOL] from faust . types . models import ModelT [EOL] from faust . types . settings import Settings [EOL] from faust . types . web import ResourceOptions [EOL] from mode import Service [EOL] from mode . utils . compat import want_bytes [EOL] from mode . utils . mocks import ANY , AsyncMock , Mock , call , patch [EOL] from yarl import URL [EOL] import pytest [EOL] [EOL] TEST_TOPIC = [string] [EOL] CONFIG_DICT = { [string] : [string] , [string] : [number] , } [EOL] CONFIG_PATH = [string] [EOL] [EOL] TP1 = TP ( [string] , [number] ) [EOL] TP2 = TP ( [string] , [number] ) [EOL] TP3 = TP ( [string] , [number] ) [EOL] TP4 = TP ( [string] , [number] ) [EOL] [EOL] [EOL] class ConfigClass : [EOL] broker = [string] [EOL] stream_buffer_maxsize = [number] [EOL] [EOL] [EOL] class Key ( faust . Record ) : [EOL] value = ... [EOL] [EOL] [EOL] class Value ( faust . Record , serializer = [string] ) : [EOL] amount = ... [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( [string] , TEST_TOPIC , TEST_TOPIC , None ) , ( Key ( value = [number] ) , TEST_TOPIC , TEST_TOPIC , None ) , ( { [string] : [string] } , TEST_TOPIC , TEST_TOPIC , [string] ) , ( None , [string] , [string] , None ) , ( [string] , TEST_TOPIC , TEST_TOPIC , None ) , ( [string] , [string] , [string] , None ) , ] ) async def test_send ( key , topic_name , expected_topic , key_serializer , app ) : [EOL] topic = app . topic ( topic_name ) [EOL] event = Value ( amount = [number] ) [EOL] await app . send ( topic , key , event , key_serializer = key_serializer ) [EOL] [comment] [EOL] await app . send ( topic , key , event , key_serializer = key_serializer ) [EOL] expected_sender = app . producer . send [EOL] if key is not None : [EOL] if isinstance ( key , str ) : [EOL] [comment] [EOL] [comment] [EOL] key_serializer = [string] [EOL] if isinstance ( key , ModelT ) : [EOL] expected_key = key . dumps ( serializer = [string] ) [EOL] elif key_serializer : [EOL] expected_key = codecs . dumps ( key_serializer , key ) [EOL] else : [EOL] expected_key = want_bytes ( key ) [EOL] else : [EOL] expected_key = None [EOL] expected_sender . assert_called_with ( expected_topic , expected_key , event . dumps ( ) , partition = None , timestamp = None , headers = { } , ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_send_str ( app ) : [EOL] await app . send ( [string] , Value ( amount = [number] ) ) [EOL] [EOL] [EOL] class test_App : [EOL] [EOL] def test_stream ( self , * , app ) : [EOL] s = app . topic ( TEST_TOPIC ) . stream ( ) [EOL] assert s . channel . topics == ( TEST_TOPIC , ) [EOL] assert s . channel in app . topics [EOL] assert s . channel . app == app [EOL] [EOL] def test_new_producer ( self , * , app ) : [EOL] app . _producer = None [EOL] transport = app . _transport = Mock ( name = [string] , autospec = Transport , ) [EOL] assert app . _new_producer ( ) is transport . create_producer . return_value [EOL] transport . create_producer . assert_called_with ( beacon = ANY ) [EOL] assert app . producer is transport . create_producer . return_value [EOL] [EOL] def test_new_transport ( self , * , app , patching ) : [EOL] by_url = patching ( [string] ) [EOL] assert app . _new_transport ( ) is by_url . return_value . return_value [EOL] assert app . transport is by_url . return_value . return_value [EOL] by_url . assert_called_with ( app . conf . broker [ [number] ] ) [EOL] by_url . return_value . assert_called_with ( app . conf . broker , app , loop = app . loop ) [EOL] app . transport = [number] [EOL] assert app . transport == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop ( self , * , app ) : [EOL] app . _http_client = Mock ( name = [string] , close = AsyncMock ( ) ) [EOL] app . _producer = Mock ( name = [string] , flush = AsyncMock ( ) ) [EOL] await app . on_stop ( ) [EOL] app . _http_client . close . assert_called_once_with ( ) [EOL] app . _http_client = None [EOL] await app . on_stop ( ) [EOL] app . _producer = None [EOL] await app . on_stop ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_stop_consumer__wait_empty_enabled ( self , * , app ) : [EOL] app . conf . stream_wait_empty = True [EOL] await self . assert_stop_consumer ( app ) [EOL] app . _consumer . wait_empty . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_stop_consumer__wait_empty_disabled ( self , * , app ) : [EOL] app . conf . stream_wait_empty = False [EOL] await self . assert_stop_consumer ( app ) [EOL] app . consumer . wait_empty . assert_not_called ( ) [EOL] [EOL] async def assert_stop_consumer ( self , app ) : [EOL] consumer = app . _consumer = Mock ( wait_empty = AsyncMock ( ) , ) [EOL] consumer . assignment . return_value = set ( ) [EOL] app . tables = Mock ( ) [EOL] app . flow_control = Mock ( ) [EOL] app . _stop_fetcher = AsyncMock ( ) [EOL] await app . _stop_consumer ( ) [EOL] [EOL] consumer . assignment . side_effect = ConsumerNotStarted ( ) [EOL] await app . _stop_consumer ( ) [EOL] [EOL] consumer . assignment . side_effect = None [EOL] assigned = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] consumer . assignment . return_value = assigned [EOL] [EOL] await app . _stop_consumer ( ) [EOL] app . tables . on_partitions_revoked . assert_called_once_with ( assigned ) [EOL] consumer . stop_flow . assert_called_once_with ( ) [EOL] app . flow_control . suspend . assert_called_once_with ( ) [EOL] app . _stop_fetcher . assert_called_once_with ( ) [EOL] [EOL] def test_on_rebalance_start_end ( self , * , app ) : [EOL] app . tables = Mock ( ) [EOL] assert not app . rebalancing [EOL] [EOL] app . on_rebalance_start ( ) [EOL] assert app . rebalancing [EOL] app . tables . on_rebalance_start . assert_called_once_with ( ) [EOL] [EOL] app . on_rebalance_end ( ) [EOL] assert not app . rebalancing [EOL] [EOL] app . tracer = Mock ( name = [string] ) [EOL] app . on_rebalance_start ( ) [EOL] span = app . _rebalancing_span [EOL] assert span is not None [EOL] app . on_rebalance_end ( ) [EOL] span . finish . assert_called_once_with ( ) [EOL] [EOL] def test_trace ( self , * , app ) : [EOL] app . tracer = None [EOL] with app . trace ( [string] ) : [EOL] pass [EOL] app . tracer = Mock ( ) [EOL] assert app . trace ( [string] ) is app . tracer . trace . return_value [EOL] [EOL] def test_traced ( self , * , app ) : [EOL] @ app . traced def foo ( val ) : [EOL] return val [EOL] assert foo ( [number] ) == [number] [EOL] [EOL] def test__start_span_from_rebalancing ( self , * , app ) : [EOL] app . tracer = None [EOL] app . _rebalancing_span = None [EOL] assert app . _start_span_from_rebalancing ( [string] ) [EOL] app . tracer = Mock ( name = [string] ) [EOL] try : [EOL] app . _rebalancing_span = Mock ( name = [string] ) [EOL] assert app . _start_span_from_rebalancing ( [string] ) [EOL] finally : [EOL] app . tracer = None [EOL] app . _rebalancing_span = None [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked ( self , * , app ) : [EOL] app . on_partitions_revoked = Mock ( send = AsyncMock ( ) ) [EOL] consumer = app . consumer = Mock ( wait_empty = AsyncMock ( ) , transactions = Mock ( on_partitions_revoked = AsyncMock ( ) , ) , ) [EOL] app . tables = Mock ( ) [EOL] app . flow_control = Mock ( ) [EOL] app . _producer = Mock ( flush = AsyncMock ( ) ) [EOL] revoked = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] ass = app . consumer . assignment . return_value = { TP ( [string] , [number] ) } [EOL] [EOL] app . in_transaction = False [EOL] await app . _on_partitions_revoked ( revoked ) [EOL] [EOL] app . on_partitions_revoked . send . assert_called_once_with ( revoked ) [EOL] consumer . stop_flow . assert_called_once_with ( ) [EOL] app . flow_control . suspend . assert_called_once_with ( ) [EOL] consumer . pause_partitions . assert_called_once_with ( ass ) [EOL] app . flow_control . clear . assert_called_once_with ( ) [EOL] consumer . wait_empty . assert_called_once_with ( ) [EOL] app . _producer . flush . assert_called_once_with ( ) [EOL] consumer . transactions . on_partitions_revoked . assert_not_called ( ) [EOL] [EOL] app . in_transaction = True [EOL] await app . _on_partitions_revoked ( revoked ) [EOL] consumer . transactions . on_partitions_revoked . assert_called_once_with ( revoked ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked__no_assignment ( self , * , app ) : [EOL] app . on_partitions_revoked = Mock ( send = AsyncMock ( ) ) [EOL] app . consumer = Mock ( ) [EOL] app . tables = Mock ( ) [EOL] revoked = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] app . consumer . assignment . return_value = set ( ) [EOL] await app . _on_partitions_revoked ( revoked ) [EOL] [EOL] app . on_partitions_revoked . send . assert_called_once_with ( revoked ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked__crashes ( self , * , app ) : [EOL] app . on_partitions_revoked = Mock ( send = AsyncMock ( ) ) [EOL] app . crash = AsyncMock ( ) [EOL] app . consumer = Mock ( ) [EOL] app . tables = Mock ( ) [EOL] revoked = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] app . consumer . assignment . side_effect = RuntimeError ( ) [EOL] await app . _on_partitions_revoked ( revoked ) [EOL] [EOL] app . crash . assert_called_once ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked__when_stopped ( self , * , app ) : [EOL] app . _stopped . set ( ) [EOL] app . _on_rebalance_when_stopped = AsyncMock ( ) [EOL] await app . _on_partitions_revoked ( set ( ) ) [EOL] app . _on_rebalance_when_stopped . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_stop_fetcher ( self , * , app ) : [EOL] app . _fetcher = Mock ( stop = AsyncMock ( ) ) [EOL] await app . _stop_fetcher ( ) [EOL] app . _fetcher . stop . assert_called_once_with ( ) [EOL] app . _fetcher . service_reset . assert_called_once_with ( ) [EOL] [EOL] def test_on_rebalance_when_stopped ( self , * , app ) : [EOL] app . consumer = Mock ( ) [EOL] app . _on_rebalance_when_stopped ( ) [EOL] app . consumer . close . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_assigned__when_stopped ( self , * , app ) : [EOL] app . _stopped . set ( ) [EOL] app . _on_rebalance_when_stopped = AsyncMock ( ) [EOL] await app . _on_partitions_assigned ( set ( ) ) [EOL] app . _on_rebalance_when_stopped . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_assigned ( self , * , app ) : [EOL] app . _assignment = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] app . on_partitions_assigned = Mock ( send = AsyncMock ( ) ) [EOL] app . consumer = Mock ( transactions = Mock ( on_rebalance = AsyncMock ( ) , ) , ) [EOL] app . agents = Mock ( on_rebalance = AsyncMock ( ) , ) [EOL] app . tables = Mock ( on_rebalance = AsyncMock ( ) , ) [EOL] app . topics = Mock ( wait_for_subscriptions = AsyncMock ( ) , on_partitions_assigned = AsyncMock ( ) , ) [EOL] [EOL] assigned = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] revoked = { TP ( [string] , [number] ) } [EOL] newly_assigned = { TP ( [string] , [number] ) } [EOL] [EOL] app . in_transaction = False [EOL] await app . _on_partitions_assigned ( assigned ) [EOL] [EOL] app . agents . on_rebalance . assert_called_once_with ( revoked , newly_assigned ) [EOL] app . topics . wait_for_subscriptions . assert_called_once_with ( ) [EOL] app . consumer . pause_partitions . assert_called_once_with ( assigned ) [EOL] app . topics . on_partitions_assigned . assert_called_once_with ( assigned ) [EOL] app . consumer . transactions . on_rebalance . assert_not_called ( ) [EOL] app . tables . on_rebalance . assert_called_once_with ( assigned , revoked , newly_assigned ) [EOL] app . on_partitions_assigned . send . assert_called_once_with ( assigned ) [EOL] [EOL] app . in_transaction = True [EOL] app . _assignment = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] await app . _on_partitions_assigned ( assigned ) [EOL] app . consumer . transactions . on_rebalance . assert_called_once_with ( assigned , revoked , newly_assigned ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_assigned__crashes ( self , * , app ) : [EOL] app . _assignment = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] app . on_partitions_assigned = Mock ( send = AsyncMock ( ) ) [EOL] app . consumer = Mock ( ) [EOL] app . agents = Mock ( on_rebalance = AsyncMock ( ) , ) [EOL] app . agents . on_rebalance . coro . side_effect = RuntimeError ( ) [EOL] app . crash = AsyncMock ( ) [EOL] [EOL] await app . _on_partitions_assigned ( set ( ) ) [EOL] app . crash . assert_called_once ( ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , { TP1 , TP2 } , set ( ) , { TP1 , TP2 } ) , ( set ( ) , set ( ) , set ( ) , set ( ) ) , ( set ( ) , { TP1 , TP2 } , set ( ) , { TP1 , TP2 } ) , ( { TP1 , TP2 } , { TP1 , TP2 } , set ( ) , set ( ) ) , ( { TP1 , TP2 } , { TP1 , TP3 , TP4 } , { TP2 } , { TP3 , TP4 } ) , ] ) def test_update_assignment ( self , prev , new , expected_revoked , expected_assigned , * , app ) : [EOL] app . _assignment = prev [EOL] revoked , newly_assigned = app . _update_assignment ( new ) [EOL] assert revoked == expected_revoked [EOL] assert newly_assigned == expected_assigned [EOL] assert app . _assignment == new [EOL] [EOL] def test_worker_init ( self , * , app ) : [EOL] on_worker_init = app . on_worker_init . connect ( Mock ( name = [string] ) ) [EOL] fixup1 = Mock ( name = [string] , autospec = Fixup ) [EOL] fixup2 = Mock ( name = [string] , autospec = Fixup ) [EOL] app . fixups = [ fixup1 , fixup2 ] [EOL] [EOL] app . worker_init ( ) [EOL] [EOL] fixup1 . on_worker_init . assert_called_once_with ( ) [EOL] fixup2 . on_worker_init . assert_called_once_with ( ) [EOL] on_worker_init . assert_called_once_with ( app , signal = app . on_worker_init ) [EOL] [EOL] def test_discover ( self , * , app ) : [EOL] app . conf . autodiscover = [ [string] , [string] , [string] ] [EOL] app . conf . origin = [string] [EOL] fixup1 = Mock ( name = [string] , autospec = Fixup ) [EOL] fixup1 . autodiscover_modules . return_value = [ [string] , [string] ] [EOL] app . fixups = [ fixup1 ] [EOL] with patch ( [string] ) : [EOL] with patch ( [string] ) as import_module : [EOL] app . discover ( ) [EOL] [EOL] import_module . assert_has_calls ( [ call ( [string] ) , call ( [string] ) , call ( [string] ) , call ( [string] ) , call ( [string] ) , call ( [string] ) , ] , any_order = True , ) [EOL] [EOL] def test_discover__disabled ( self , * , app ) : [EOL] app . conf . autodiscover = False [EOL] app . discover ( ) [EOL] [EOL] def test_discover__unknown_module ( self , * , app ) : [EOL] app . conf . autodiscover = [ [string] ] [EOL] app . conf . origin = [string] [EOL] with patch ( [string] ) : [EOL] with pytest . raises ( ModuleNotFoundError ) : [EOL] app . discover ( ) [EOL] [EOL] def test_discovery_modules__bool ( self , * , app ) : [EOL] app . conf . origin = [string] [EOL] app . conf . autodiscover = True [EOL] assert app . _discovery_modules ( ) == [ [string] ] [EOL] [EOL] def test_discovery_modules__callable ( self , * , app ) : [EOL] app . conf . origin = [string] [EOL] app . conf . autodiscover = lambda : [ [string] , [string] , [string] ] [EOL] assert app . _discovery_modules ( ) == [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def test_discovery_modules__list ( self , * , app ) : [EOL] app . conf . origin = [string] [EOL] app . conf . autodiscover = [ [string] , [string] , [string] ] [EOL] assert app . _discovery_modules ( ) == [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def test_discovery_modules__list_no_origin ( self , * , app ) : [EOL] app . conf . origin = None [EOL] app . conf . autodiscover = [ [string] , [string] , [string] ] [EOL] assert app . _discovery_modules ( ) == [ [string] , [string] , [string] ] [EOL] [EOL] def test_discovery_modules__disabled ( self , * , app ) : [EOL] app . conf . origin = [string] [EOL] app . conf . autodiscover = False [EOL] assert app . _discovery_modules ( ) == [ ] [EOL] [EOL] def test_discovery_modules__without_origin ( self , * , app ) : [EOL] app . conf . autodiscover = True [EOL] app . conf . origin = None [EOL] with pytest . raises ( ImproperlyConfigured ) : [EOL] app . _discovery_modules ( ) [EOL] [EOL] def test_discover_ignore ( self , * , app ) : [EOL] with patch ( [string] ) as venusian : [EOL] app . conf . origin = [string] [EOL] app . conf . autodiscover = [ [string] , [string] ] [EOL] app . discover ( categories = [ [string] ] , ignore = [ [string] , [string] ] ) [EOL] [EOL] assert venusian . Scanner ( ) . scan . assert_has_calls ( [ call ( re , categories = ( [string] , ) , ignore = [ [string] , [string] ] , ) , call ( faust , categories = ( [string] , ) , ignore = [ [string] , [string] ] , ) , call ( collections , categories = ( [string] , ) , ignore = [ [string] , [string] ] , ) , ] , any_order = True ) is None [EOL] [EOL] def test_main ( self , * , app ) : [EOL] with patch ( [string] ) as cli : [EOL] app . finalize = Mock ( name = [string] ) [EOL] app . worker_init = Mock ( name = [string] ) [EOL] app . discover = Mock ( name = [string] ) [EOL] [EOL] app . conf . autodiscover = False [EOL] with pytest . raises ( SystemExit ) : [EOL] app . main ( ) [EOL] [EOL] z = app . conf . autodiscover [EOL] assert z is False [EOL] [EOL] app . finalize . assert_called_once_with ( ) [EOL] app . worker_init . assert_called_once_with ( ) [EOL] cli . assert_called_once_with ( app = app ) [EOL] [EOL] with pytest . warns ( AlreadyConfiguredWarning ) : [EOL] app . conf . autodiscover = True [EOL] with pytest . raises ( SystemExit ) : [EOL] app . main ( ) [EOL] [EOL] def test_channel ( self , * , app ) : [EOL] channel = app . channel ( ) [EOL] assert isinstance ( channel , Channel ) [EOL] assert isinstance ( channel , ChannelT ) [EOL] assert app . channel ( key_type = [string] ) . key_type == [string] [EOL] assert app . channel ( value_type = [string] ) . value_type == [string] [EOL] assert app . channel ( maxsize = [number] ) . maxsize == [number] [EOL] [EOL] def test_agent ( self , * , app ) : [EOL] with patch ( [string] ) as venusian : [EOL] @ app . agent ( ) async def foo ( stream ) : [EOL] ... [EOL] [EOL] assert foo . name [EOL] assert app . agents [ foo . name ] is foo [EOL] [EOL] venusian . attach . assert_called_once_with ( foo , category = SCAN_AGENT ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_agent_error ( self , * , app ) : [EOL] app . _consumer = None [EOL] agent = Mock ( name = [string] , autospec = Agent ) [EOL] await app . _on_agent_error ( agent , KeyError ( ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_agent_error__consumer ( self , * , app ) : [EOL] app . _consumer = Mock ( name = [string] , autospec = Consumer ) [EOL] agent = Mock ( name = [string] , autospec = Agent ) [EOL] exc = KeyError ( ) [EOL] await app . _on_agent_error ( agent , exc ) [EOL] app . _consumer . on_task_error . assert_called_with ( exc ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_agent_error__MemoryError ( self , * , app ) : [EOL] app . _consumer = Mock ( name = [string] , autospec = Consumer ) [EOL] app . _consumer . on_task_error . side_effect = MemoryError ( ) [EOL] agent = Mock ( name = [string] , autospec = Agent ) [EOL] exc = KeyError ( ) [EOL] with pytest . raises ( MemoryError ) : [EOL] await app . _on_agent_error ( agent , exc ) [EOL] app . _consumer . on_task_error . assert_called_with ( exc ) [EOL] [EOL] def test_task ( self , * , app ) : [EOL] with patch ( [string] ) as venusian : [EOL] @ app . task async def foo ( ) : [EOL] ... [EOL] [EOL] venusian . attach . assert_called_once_with ( foo , category = SCAN_TASK ) [EOL] assert foo in app . _tasks [EOL] [EOL] @ pytest . mark . asyncio async def test_task__on_leader ( self , * , app ) : [EOL] @ app . task ( on_leader = True ) async def mytask ( app ) : [EOL] return app [EOL] [EOL] app . is_leader = Mock ( return_value = False ) [EOL] assert await mytask ( ) is None [EOL] [EOL] app . is_leader = Mock ( return_value = True ) [EOL] assert await mytask ( ) is app [EOL] [EOL] @ pytest . mark . asyncio async def test_timer ( self , * , app ) : [EOL] did_execute = Mock ( name = [string] ) [EOL] app . _producer = Mock ( name = [string] , flush = AsyncMock ( ) ) [EOL] [EOL] @ app . timer ( [number] ) async def foo ( ) : [EOL] did_execute ( ) [EOL] await app . stop ( ) [EOL] [EOL] await foo ( ) [EOL] did_execute . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_timer__sleep_stopped ( self , * , app ) : [EOL] did_execute = Mock ( name = [string] ) [EOL] app . sleep = AsyncMock ( ) [EOL] [EOL] def on_sleep ( seconds , ** kwargs ) : [EOL] app . _stopped . set ( ) [EOL] [EOL] app . sleep . coro . side_effect = on_sleep [EOL] [EOL] @ app . timer ( [number] ) async def foo ( ) : [EOL] did_execute ( ) [EOL] [EOL] await foo ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_timer__on_leader_not_leader ( self , * , app ) : [EOL] did_execute = Mock ( name = [string] ) [EOL] app . is_leader = Mock ( return_value = False ) [EOL] app . sleep = AsyncMock ( ) [EOL] [EOL] def on_sleep ( seconds , ** kwargs ) : [EOL] if app . sleep . call_count >= [number] : [EOL] app . _stopped . set ( ) [EOL] [comment] [EOL] [comment] [EOL] app . sleep . coro . side_effect = on_sleep [EOL] [EOL] @ app . timer ( [number] , on_leader = True ) async def foo ( ) : [EOL] did_execute ( ) [EOL] [EOL] await foo ( ) [EOL] [EOL] assert app . sleep . call_count == [number] [EOL] did_execute . assert_not_called ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_timer__on_leader_is_leader ( self , * , app ) : [EOL] did_execute = Mock ( name = [string] ) [EOL] app . is_leader = Mock ( return_value = True ) [EOL] app . sleep = AsyncMock ( ) [EOL] [EOL] def on_sleep ( seconds , ** kwargs ) : [EOL] if app . sleep . call_count >= [number] : [EOL] app . _stopped . set ( ) [EOL] [comment] [EOL] [comment] [EOL] app . sleep . coro . side_effect = on_sleep [EOL] [EOL] @ app . timer ( [number] , on_leader = True ) async def foo ( app ) : [EOL] did_execute ( ) [EOL] [EOL] await foo ( ) [EOL] [EOL] assert app . sleep . call_count == [number] [EOL] assert did_execute . call_count == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_crontab ( self , * , app ) : [EOL] did_execute = Mock ( name = [string] ) [EOL] app . _producer = Mock ( name = [string] , flush = AsyncMock ( ) ) [EOL] [EOL] with patch ( [string] ) as cron : [EOL] cron . secs_for_next . return_value = [number] [EOL] [EOL] @ app . crontab ( [string] ) async def foo ( ) : [EOL] did_execute ( ) [EOL] await app . stop ( ) [EOL] [EOL] await foo ( ) [EOL] did_execute . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_crontab__on_leader_not_leader ( self , * , app ) : [EOL] did_execute = Mock ( name = [string] ) [EOL] with patch ( [string] ) as cron : [EOL] cron . secs_for_next . return_value = [number] [EOL] [EOL] @ app . crontab ( [string] , on_leader = True ) async def foo ( ) : [EOL] did_execute ( ) [EOL] [EOL] app . is_leader = Mock ( return_value = False ) [EOL] app . sleep = AsyncMock ( ) [EOL] [EOL] def on_sleep ( seconds , ** kwargs ) : [EOL] if app . sleep . call_count >= [number] : [EOL] app . _stopped . set ( ) [EOL] app . sleep . coro . side_effect = on_sleep [EOL] [EOL] await foo ( ) [EOL] assert app . sleep . call_count == [number] [EOL] did_execute . assert_not_called ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_crontab__on_leader_is_leader ( self , * , app ) : [EOL] did_execute = Mock ( name = [string] ) [EOL] with patch ( [string] ) as cron : [EOL] cron . secs_for_next . return_value = [number] [EOL] [EOL] @ app . crontab ( [string] , on_leader = True ) async def foo ( app ) : [EOL] did_execute ( ) [EOL] [EOL] app . is_leader = Mock ( return_value = True ) [EOL] app . sleep = AsyncMock ( ) [EOL] [EOL] def on_sleep ( seconds , ** kwargs ) : [EOL] if app . sleep . call_count >= [number] : [EOL] app . _stopped . set ( ) [EOL] app . sleep . coro . side_effect = on_sleep [EOL] [EOL] await foo ( ) [EOL] assert app . sleep . call_count == [number] [EOL] assert did_execute . call_count == [number] [EOL] [EOL] def test_service ( self , * , app ) : [EOL] [EOL] @ app . service class Foo ( Service ) : [EOL] ... [EOL] [EOL] assert Foo in app . _extra_services [EOL] [EOL] def test_is_leader ( self , * , app ) : [EOL] app . _leader_assignor = Mock ( name = [string] , autospec = LeaderAssignor , ) [EOL] app . _leader_assignor . is_leader . return_value = True [EOL] assert app . is_leader ( ) [EOL] [EOL] def test_Table ( self , * , app ) : [EOL] table = app . Table ( [string] ) [EOL] assert app . tables . data [ [string] ] is table [EOL] [EOL] def test_SetTable ( self , * , app ) : [EOL] table = app . SetTable ( [string] ) [EOL] assert app . tables . data [ [string] ] is table [EOL] [EOL] def test_page ( self , * , app ) : [EOL] [EOL] with patch ( [string] ) as venusian : [EOL] [EOL] @ app . page ( [string] ) async def view ( self , request ) : [EOL] ... [EOL] [EOL] assert [string] in app . web . views [EOL] [EOL] venusian . attach . assert_called_once_with ( view , category = SCAN_PAGE ) [EOL] [EOL] def test_page__with_cors_options ( self , * , app ) : [EOL] [EOL] with patch ( [string] ) as venusian : [EOL] [EOL] @ app . page ( [string] , cors_options = { [string] : ResourceOptions ( allow_credentials = True , expose_headers = [string] , allow_headers = [string] , max_age = None , allow_methods = [string] , ) , } , ) async def view ( self , request ) : [EOL] ... [EOL] [EOL] assert [string] in app . web . views [EOL] [EOL] venusian . attach . assert_called_once_with ( view , category = SCAN_PAGE ) [EOL] [EOL] def test_page__view_class_but_not_view ( self , * , app ) : [EOL] with pytest . raises ( TypeError ) : [EOL] @ app . page ( [string] ) class Foo : [EOL] ... [EOL] [EOL] @ pytest . mark . asyncio async def test_table_route__query_param ( self , * , app ) : [EOL] table = app . Table ( [string] ) [EOL] view = Mock ( ) [EOL] request = Mock ( ) [EOL] app . router . route_req = AsyncMock ( ) [EOL] [EOL] @ app . table_route ( table , query_param = [string] ) async def routed ( self , request ) : [EOL] return [number] [EOL] [EOL] request . query = { [string] : [string] } [EOL] [EOL] ret = await routed ( view , request ) [EOL] assert ret is app . router . route_req . coro . return_value [EOL] [EOL] app . router . route_req . coro . side_effect = SameNode ( ) [EOL] ret = await routed ( view , request ) [EOL] assert ret == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_table_route__match_info ( self , * , app ) : [EOL] table = app . Table ( [string] ) [EOL] view = Mock ( ) [EOL] request = Mock ( ) [EOL] app . router . route_req = AsyncMock ( ) [EOL] [EOL] @ app . table_route ( table , match_info = [string] ) async def routed ( self , request ) : [EOL] return [number] [EOL] [EOL] request . match_info = { [string] : [string] } [EOL] [EOL] ret = await routed ( view , request ) [EOL] assert ret is app . router . route_req . coro . return_value [EOL] [EOL] app . router . route_req . coro . side_effect = SameNode ( ) [EOL] ret = await routed ( view , request ) [EOL] assert ret == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_table_route__exact_key ( self , * , app ) : [EOL] table = app . Table ( [string] ) [EOL] view = Mock ( ) [EOL] request = Mock ( ) [EOL] app . router . route_req = AsyncMock ( ) [EOL] [EOL] @ app . table_route ( table , exact_key = [string] ) async def routed ( self , request ) : [EOL] return [number] [EOL] [EOL] ret = await routed ( view , request ) [EOL] assert ret is app . router . route_req . coro . return_value [EOL] [EOL] app . router . route_req . coro . side_effect = SameNode ( ) [EOL] ret = await routed ( view , request ) [EOL] assert ret == [number] [EOL] [EOL] def test_table_route__compat_shard_param ( self , * , app ) : [EOL] table = app . Table ( [string] ) [EOL] with pytest . warns ( DeprecationWarning ) : [EOL] @ app . table_route ( table , shard_param = [string] ) async def view ( self , request ) : [EOL] ... [EOL] [EOL] def test_table_route__query_param_and_shard_param ( self , * , app ) : [EOL] table = app . Table ( [string] ) [EOL] with pytest . warns ( DeprecationWarning ) : [EOL] with pytest . raises ( TypeError ) : [EOL] @ app . table_route ( table , query_param = [string] , shard_param = [string] ) async def view ( self , request ) : [EOL] ... [EOL] [EOL] def test_table_route__missing_param ( self , * , app ) : [EOL] table = app . Table ( [string] ) [EOL] with pytest . raises ( TypeError ) : [EOL] @ app . table_route ( table ) async def view ( self , request ) : [EOL] ... [EOL] [EOL] def test_command ( self , * , app ) : [EOL] @ app . command ( ) async def foo ( ) : [EOL] ... [EOL] [EOL] def test_command__with_base ( self , * , app ) : [EOL] class MyBase ( AppCommand ) : [EOL] ... [EOL] [EOL] @ app . command ( base = MyBase ) async def foo ( ) : [EOL] ... [EOL] [EOL] assert issubclass ( foo , MyBase ) [EOL] [EOL] @ pytest . mark . asyncio async def test_start_client ( self , * , app ) : [EOL] app . maybe_start = AsyncMock ( name = [string] ) [EOL] await app . start_client ( ) [EOL] assert app . client_only [EOL] app . maybe_start . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_maybe_start_client ( self , * , app ) : [EOL] app . start_client = AsyncMock ( name = [string] ) [EOL] app . _started . set ( ) [EOL] await app . maybe_start_client ( ) [EOL] app . start_client . assert_not_called ( ) [EOL] [EOL] app . _started . clear ( ) [EOL] await app . maybe_start_client ( ) [EOL] app . start_client . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit ( self , * , app ) : [EOL] app . topics = Mock ( name = [string] , autospec = Conductor , commit = AsyncMock ( ) , ) [EOL] await app . commit ( { [number] } ) [EOL] app . topics . commit . assert_called_with ( { [number] } ) [EOL] [EOL] def test_Worker ( self , * , app ) : [EOL] app . conf = Mock ( name = [string] , autospec = Settings ) [EOL] worker = app . Worker ( loglevel = [number] ) [EOL] app . conf . Worker . assert_called_once_with ( app , loglevel = [number] ) [EOL] assert worker is app . conf . Worker ( ) [EOL] [EOL] def test_create_directories ( self , * , app ) : [EOL] app . conf = Mock ( name = [string] , autospec = Settings ) [EOL] [EOL] app . _create_directories ( ) [EOL] [EOL] app . conf . datadir . mkdir . assert_called_once_with ( exist_ok = True ) [EOL] app . conf . appdir . mkdir . assert_called_once_with ( exist_ok = True ) [EOL] app . conf . tabledir . mkdir . assert_called_once_with ( exist_ok = True ) [EOL] [EOL] @ pytest . mark . asyncio async def test_maybe_start_producer ( self , * , app ) : [EOL] app . in_transaction = True [EOL] assert await app . maybe_start_producer ( ) is app . consumer . transactions [EOL] [EOL] app . in_transaction = False [EOL] app . producer = Mock ( maybe_start = AsyncMock ( ) ) [EOL] assert await app . maybe_start_producer ( ) is app . producer [EOL] app . producer . maybe_start . coro . assert_called_once_with ( ) [EOL] [EOL] def test_repr ( self , * , app ) : [EOL] assert repr ( app ) [EOL] [EOL] def test_repr__unfinialized ( self , * , app ) : [EOL] app . _conf = None [EOL] assert repr ( app ) [EOL] [EOL] def test_monitor ( self , * , app ) : [EOL] assert app . _monitor is None [EOL] app . conf . Monitor = Mock ( name = [string] , return_value = Mock ( autospec = Monitor ) , ) [EOL] monitor = app . monitor [EOL] app . conf . Monitor . assert_called_once_with ( loop = app . loop , beacon = app . beacon ) [EOL] assert monitor is app . conf . Monitor ( ) [EOL] assert app . monitor is monitor [EOL] assert app . _monitor is monitor [EOL] [EOL] monitor2 = app . monitor = Mock ( name = [string] , autospec = Monitor , ) [EOL] assert app . _monitor is monitor2 [EOL] assert app . monitor is monitor2 [EOL] [EOL] def test_fetcher ( self , * , app ) : [EOL] app . transport . Fetcher = Mock ( name = [string] , return_value = Mock ( autospec = Fetcher ) , ) [EOL] fetcher = app . _fetcher [EOL] app . transport . Fetcher . assert_called_once_with ( app , loop = app . loop , beacon = app . beacon , ) [EOL] assert fetcher is app . transport . Fetcher ( ) [EOL] [EOL] def test_reply_consumer ( self , * , app ) : [EOL] with patch ( [string] ) as ReplyConsumer : [EOL] reply_consumer = app . _reply_consumer [EOL] ReplyConsumer . assert_called_once_with ( app , loop = app . loop , beacon = app . beacon ) [EOL] assert reply_consumer is ReplyConsumer ( ) [EOL] [EOL] def test_label ( self , * , app ) : [EOL] assert app . label [EOL] [EOL] def test_cache ( self , * , app ) : [EOL] assert app . cache [EOL] assert app . cache is app . _cache [EOL] obj = object ( ) [EOL] app . cache = obj [EOL] assert app . cache is obj [EOL] [EOL] def test_http_client ( self , * , app ) : [EOL] app . conf . HttpClient = Mock ( name = [string] ) [EOL] assert app . _http_client is None [EOL] client = app . http_client [EOL] app . conf . HttpClient . assert_called_once_with ( ) [EOL] assert client is app . conf . HttpClient ( ) [EOL] assert app . _http_client is client [EOL] assert app . http_client is client [EOL] [EOL] obj = object ( ) [EOL] app . http_client = obj [EOL] assert app . http_client is obj [EOL] [EOL] def test_leader_assignor ( self , * , app ) : [EOL] leader_assignor = app . _leader_assignor [EOL] assert isinstance ( leader_assignor , LeaderAssignorT ) [EOL] assert isinstance ( leader_assignor , LeaderAssignor ) [EOL] assert leader_assignor . app is app [EOL] assert leader_assignor . beacon . parent is app . beacon [EOL] [EOL] [EOL] class test_AppConfiguration : [EOL] [EOL] def test_conf__before_finalized ( self , * , monkeypatch , app ) : [EOL] app . finalized = False [EOL] monkeypatch . setattr ( [string] , False ) [EOL] app . conf . id [EOL] monkeypatch . setattr ( [string] , True ) [EOL] with pytest . raises ( ImproperlyConfigured ) : [EOL] app . conf . id [EOL] [EOL] def test_set_conf ( self , * , app ) : [EOL] conf = Mock ( name = [string] , autospec = Settings ) [EOL] app . conf = conf [EOL] assert app . conf is conf [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ConfigClass , CONFIG_DICT , CONFIG_PATH , ] ) def test_config_From_object ( self , config_source , * , app ) : [EOL] on_before = app . on_before_configured . connect ( Mock ( name = [string] ) ) [EOL] on_config = app . on_configured . connect ( Mock ( name = [string] ) ) [EOL] on_after = app . on_after_configured . connect ( Mock ( name = [string] ) ) [EOL] [EOL] app . configured = False [EOL] app . finalized = False [EOL] app . config_from_object ( config_source ) [EOL] app . _conf = None [EOL] app . finalized = True [EOL] [EOL] app . configured = False [EOL] with pytest . warns ( AlreadyConfiguredWarning ) : [EOL] app . config_from_object ( config_source ) [EOL] [EOL] assert app . _config_source is config_source [EOL] app . _config_source = None [EOL] [EOL] app . configured = True [EOL] with pytest . warns ( AlreadyConfiguredWarning ) : [EOL] app . config_from_object ( config_source ) [EOL] [EOL] assert app . _config_source is config_source [EOL] on_before . assert_called_with ( app , signal = app . on_before_configured ) [EOL] on_config . assert_called_with ( app , app . conf , signal = app . on_configured ) [EOL] on_after . assert_called_with ( app , signal = app . on_after_configured ) [EOL] assert app . conf . broker == [ URL ( [string] ) ] [EOL] assert app . conf . stream_buffer_maxsize == [number] [EOL] [EOL] def test_finalize__no_id ( self , * , app ) : [EOL] with pytest . warns ( AlreadyConfiguredWarning ) : [EOL] app . conf . id = None [EOL] app . finalized = False [EOL] with pytest . raises ( ImproperlyConfigured ) : [EOL] app . finalize ( ) [EOL] [EOL] def test_load_settings_from_source__no_attribute ( self , * , app ) : [EOL] with pytest . raises ( AttributeError ) : [EOL] app . _load_settings_from_source ( [string] ) [EOL] assert app . _load_settings_from_source ( [string] , silent = True ) == { } [EOL] [EOL] def test_load_settings_from_source__import_error ( self , * , app ) : [EOL] with pytest . raises ( ImportError ) : [EOL] app . _load_settings_from_source ( [string] ) [EOL] assert app . _load_settings_from_source ( [string] , silent = True ) == { } [EOL] [EOL] def test_load_settings_with_compat_and_new_settings ( self , * , app ) : [EOL] config = { [string] : [string] , [string] : [string] , } [EOL] with pytest . warns ( AlreadyConfiguredWarning ) : [EOL] with pytest . raises ( ImproperlyConfigured ) : [EOL] app . config_from_object ( config ) [EOL] [EOL] @ pytest . mark . asyncio async def test_wait_for_table_recovery__producer_only ( self , * , app ) : [EOL] app . producer_only = True [EOL] assert await app . _wait_for_table_recovery_completed ( ) is False [EOL] [EOL] @ pytest . mark . asyncio async def test_wait_for_table_recovery__client_only ( self , * , app ) : [EOL] app . client_only = True [EOL] assert await app . _wait_for_table_recovery_completed ( ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 0 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 0 0 $builtins.KeyError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0