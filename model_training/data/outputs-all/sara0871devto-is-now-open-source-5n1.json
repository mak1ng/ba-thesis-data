[docstring] [EOL]	0 0
from typing import Any , List [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import functools [EOL] import logging [EOL] import os [EOL] from unittest . mock import patch , MagicMock [EOL] [EOL] import pytest [EOL] import requests_mock as _requests_mock [EOL] [EOL] from homeassistant import util [EOL] from homeassistant . util import location [EOL] [EOL] from tests . common import ( async_test_home_assistant , INSTANCES , async_mock_mqtt_component , mock_coro , mock_storage as mock_storage ) [EOL] from tests . test_util . aiohttp import mock_aiohttp_client [EOL] from tests . mock . zwave import MockNetwork , MockOption [EOL] [EOL] if os . environ . get ( [string] ) == [string] : [EOL] import uvloop [EOL] asyncio . set_event_loop_policy ( uvloop . EventLoopPolicy ( ) ) [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] def check_real ( func ) : [EOL] [docstring] [EOL] @ functools . wraps ( func ) def guard_func ( * args , ** kwargs ) : [EOL] real = kwargs . pop ( [string] , None ) [EOL] [EOL] if not real : [EOL] raise Exception ( [string] , func . __name__ ) [EOL] [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return guard_func [EOL] [EOL] [EOL] [comment] [EOL] location . detect_location_info = check_real ( location . detect_location_info ) [EOL] location . elevation = check_real ( location . elevation ) [EOL] util . get_local_ip = lambda : [string] [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def verify_cleanup ( ) : [EOL] [docstring] [EOL] yield [EOL] [EOL] if len ( INSTANCES ) >= [number] : [EOL] count = len ( INSTANCES ) [EOL] for inst in INSTANCES : [EOL] inst . stop ( ) [EOL] pytest . exit ( [string] [string] . format ( count ) ) [EOL] [EOL] [EOL] @ pytest . fixture def hass_storage ( ) : [EOL] [docstring] [EOL] with mock_storage ( ) as stored_data : [EOL] yield stored_data [EOL] [EOL] [EOL] @ pytest . fixture def hass ( loop , hass_storage ) : [EOL] [docstring] [EOL] hass = loop . run_until_complete ( async_test_home_assistant ( loop ) ) [EOL] [EOL] yield hass [EOL] [EOL] loop . run_until_complete ( hass . async_stop ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture def requests_mock ( ) : [EOL] [docstring] [EOL] with _requests_mock . mock ( ) as m : [EOL] yield m [EOL] [EOL] [EOL] @ pytest . fixture def aioclient_mock ( ) : [EOL] [docstring] [EOL] with mock_aiohttp_client ( ) as mock_session : [EOL] yield mock_session [EOL] [EOL] [EOL] @ pytest . fixture def mqtt_mock ( loop , hass ) : [EOL] [docstring] [EOL] client = loop . run_until_complete ( async_mock_mqtt_component ( hass ) ) [EOL] client . reset_mock ( ) [EOL] return client [EOL] [EOL] [EOL] @ pytest . fixture def mock_openzwave ( ) : [EOL] [docstring] [EOL] base_mock = MagicMock ( ) [EOL] libopenzwave = base_mock . libopenzwave [EOL] libopenzwave . __file__ = [string] [EOL] base_mock . network . ZWaveNetwork = MockNetwork [EOL] base_mock . option . ZWaveOption = MockOption [EOL] [EOL] with patch . dict ( [string] , { [string] : libopenzwave , [string] : base_mock . option , [string] : base_mock . network , [string] : base_mock . group , } ) : [EOL] yield base_mock [EOL] [EOL] [EOL] @ pytest . fixture def mock_device_tracker_conf ( ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] [EOL] async def mock_update_config ( path , id , entity ) : [EOL] devices . append ( entity ) [EOL] [EOL] with patch ( [string] [string] , side_effect = mock_update_config ) , patch ( [string] , side_effect = lambda * args : mock_coro ( devices ) ) : [EOL] yield devices [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import logging [EOL] import asyncio [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import threading [EOL] [EOL] import homeassistant . util . logging as logging_util [EOL] [EOL] [EOL] def test_sensitive_data_filter ( ) : [EOL] [docstring] [EOL] log_filter = logging_util . HideSensitiveDataFilter ( [string] ) [EOL] [EOL] clean_record = logging . makeLogRecord ( { [string] : [string] } ) [EOL] log_filter . filter ( clean_record ) [EOL] assert clean_record . msg == [string] [EOL] [EOL] sensitive_record = logging . makeLogRecord ( { [string] : [string] } ) [EOL] log_filter . filter ( sensitive_record ) [EOL] assert sensitive_record . msg == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_async_handler_loop_log ( loop ) : [EOL] [docstring] [EOL] loop . _thread_ident = threading . get_ident ( ) [EOL] [EOL] queue = asyncio . Queue ( loop = loop ) [EOL] base_handler = logging . handlers . QueueHandler ( queue ) [EOL] handler = logging_util . AsyncHandler ( loop , base_handler ) [EOL] [EOL] [comment] [EOL] assert handler . createLock ( ) is None [EOL] assert handler . acquire ( ) is None [EOL] assert handler . release ( ) is None [EOL] assert handler . formatter is base_handler . formatter [EOL] assert handler . name is base_handler . get_name ( ) [EOL] handler . name = [string] [EOL] assert base_handler . get_name ( ) == [string] [EOL] [EOL] log_record = logging . makeLogRecord ( { [string] : [string] } ) [EOL] handler . emit ( log_record ) [EOL] yield from handler . async_close ( True ) [EOL] assert queue . get_nowait ( ) == log_record [EOL] assert queue . empty ( ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_async_handler_thread_log ( loop ) : [EOL] [docstring] [EOL] loop . _thread_ident = threading . get_ident ( ) [EOL] [EOL] queue = asyncio . Queue ( loop = loop ) [EOL] base_handler = logging . handlers . QueueHandler ( queue ) [EOL] handler = logging_util . AsyncHandler ( loop , base_handler ) [EOL] [EOL] log_record = logging . makeLogRecord ( { [string] : [string] } ) [EOL] [EOL] def add_log ( ) : [EOL] [docstring] [EOL] handler . emit ( log_record ) [EOL] handler . close ( ) [EOL] [EOL] yield from loop . run_in_executor ( None , add_log ) [EOL] yield from handler . async_close ( True ) [EOL] [EOL] assert queue . get_nowait ( ) == log_record [EOL] assert queue . empty ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Any , List [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import asyncio [EOL] import unittest [EOL] import datetime [EOL] [EOL] from homeassistant . core import CoreState , State [EOL] from homeassistant . setup import setup_component , async_setup_component [EOL] from homeassistant . components . input_datetime import ( DOMAIN , async_set_datetime ) [EOL] [EOL] from tests . common import get_test_home_assistant , mock_restore_cache [EOL] [EOL] [EOL] class TestInputDatetime ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] [comment] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_invalid_configs ( self ) : [EOL] [docstring] [EOL] invalid_configs = [ None , { } , { [string] : None } , { [string] : { [string] : False , [string] : False } } , ] [EOL] for cfg in invalid_configs : [EOL] self . assertFalse ( setup_component ( self . hass , DOMAIN , { DOMAIN : cfg } ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_set_datetime ( hass ) : [EOL] [docstring] [EOL] yield from async_setup_component ( hass , DOMAIN , { DOMAIN : { [string] : { [string] : True , [string] : True } , } } ) [EOL] [EOL] entity_id = [string] [EOL] [EOL] dt_obj = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] yield from async_set_datetime ( hass , entity_id , dt_obj ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( entity_id ) [EOL] assert state . state == str ( dt_obj ) [EOL] assert state . attributes [ [string] ] [EOL] assert state . attributes [ [string] ] [EOL] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == dt_obj . timestamp ( ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_set_datetime_time ( hass ) : [EOL] [docstring] [EOL] yield from async_setup_component ( hass , DOMAIN , { DOMAIN : { [string] : { [string] : True , [string] : False } } } ) [EOL] [EOL] entity_id = [string] [EOL] [EOL] dt_obj = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] time_portion = dt_obj . time ( ) [EOL] [EOL] yield from async_set_datetime ( hass , entity_id , dt_obj ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( entity_id ) [EOL] assert state . state == str ( time_portion ) [EOL] assert state . attributes [ [string] ] [EOL] assert not state . attributes [ [string] ] [EOL] [EOL] assert state . attributes [ [string] ] == ( [number] * [number] ) + ( [number] * [number] ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_set_invalid ( hass ) : [EOL] [docstring] [EOL] initial = [string] [EOL] yield from async_setup_component ( hass , DOMAIN , { DOMAIN : { [string] : { [string] : False , [string] : True , [string] : initial } } } ) [EOL] [EOL] entity_id = [string] [EOL] [EOL] dt_obj = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] time_portion = dt_obj . time ( ) [EOL] [EOL] yield from hass . services . async_call ( [string] , [string] , { [string] : [string] , [string] : time_portion } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( entity_id ) [EOL] assert state . state == initial [EOL] [EOL] [EOL] @ asyncio . coroutine def test_set_datetime_date ( hass ) : [EOL] [docstring] [EOL] yield from async_setup_component ( hass , DOMAIN , { DOMAIN : { [string] : { [string] : False , [string] : True } } } ) [EOL] [EOL] entity_id = [string] [EOL] [EOL] dt_obj = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] date_portion = dt_obj . date ( ) [EOL] [EOL] yield from async_set_datetime ( hass , entity_id , dt_obj ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( entity_id ) [EOL] assert state . state == str ( date_portion ) [EOL] assert not state . attributes [ [string] ] [EOL] assert state . attributes [ [string] ] [EOL] [EOL] date_dt_obj = datetime . datetime ( [number] , [number] , [number] ) [EOL] assert state . attributes [ [string] ] == date_dt_obj . timestamp ( ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_restore_state ( hass ) : [EOL] [docstring] [EOL] mock_restore_cache ( hass , ( State ( [string] , [string] ) , State ( [string] , [string] ) , State ( [string] , [string] ) , State ( [string] , [string] ) , ) ) [EOL] [EOL] hass . state = CoreState . starting [EOL] [EOL] initial = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] yield from async_setup_component ( hass , DOMAIN , { DOMAIN : { [string] : { [string] : True , [string] : False } , [string] : { [string] : False , [string] : True } , [string] : { [string] : True , [string] : True } , [string] : { [string] : True , [string] : True , [string] : str ( initial ) } , } } ) [EOL] [EOL] dt_obj = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] state_time = hass . states . get ( [string] ) [EOL] assert state_time . state == str ( dt_obj . time ( ) ) [EOL] [EOL] state_date = hass . states . get ( [string] ) [EOL] assert state_date . state == str ( dt_obj . date ( ) ) [EOL] [EOL] state_datetime = hass . states . get ( [string] ) [EOL] assert state_datetime . state == str ( dt_obj ) [EOL] [EOL] state_bogus = hass . states . get ( [string] ) [EOL] assert state_bogus . state == str ( initial ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,None],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.bool]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,None],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.bool]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Dict , Union , Any , List [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import Mock , mock_open , patch [EOL] [EOL] import pytest [EOL] import requests [EOL] import requests_mock [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_NAME , CONF_FRIENDLY_NAME , CONF_IP_ADDRESS , CONF_PORT , STATE_UNKNOWN ) [EOL] from homeassistant . setup import async_setup_component [EOL] import homeassistant . components . image_processing as ip [EOL] import homeassistant . components . image_processing . facebox as fb [EOL] [EOL] [comment] [EOL] [EOL] MOCK_IP = [string] [EOL] MOCK_PORT = [string] [EOL] [EOL] [comment] [EOL] MOCK_ERROR = [string] [EOL] MOCK_FACE = { [string] : [number] , [string] : [string] , [string] : True , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] [EOL] MOCK_FILE_PATH = [string] [EOL] [EOL] MOCK_JSON = { [string] : [number] , [string] : True , [string] : [ MOCK_FACE ] } [EOL] [EOL] MOCK_NAME = [string] [EOL] [EOL] [comment] [EOL] PARSED_FACES = [ { ATTR_NAME : [string] , fb . ATTR_IMAGE_ID : [string] , fb . ATTR_CONFIDENCE : [number] , fb . ATTR_MATCHED : True , fb . ATTR_BOUNDING_BOX : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } ] [EOL] [EOL] MATCHED_FACES = { [string] : [number] } [EOL] [EOL] VALID_ENTITY_ID = [string] [EOL] VALID_CONFIG = { ip . DOMAIN : { [string] : [string] , CONF_IP_ADDRESS : MOCK_IP , CONF_PORT : MOCK_PORT , ip . CONF_SOURCE : { ip . CONF_ENTITY_ID : [string] } } , [string] : { [string] : [string] } } [EOL] [EOL] [EOL] @ pytest . fixture def mock_isfile ( ) : [EOL] [docstring] [EOL] with patch ( [string] , return_value = True ) as _mock_isfile : [EOL] yield _mock_isfile [EOL] [EOL] [EOL] @ pytest . fixture def mock_open_file ( ) : [EOL] [docstring] [EOL] mopen = mock_open ( ) [EOL] with patch ( [string] , mopen , create = True ) as _mock_open : [EOL] yield _mock_open [EOL] [EOL] [EOL] def test_encode_image ( ) : [EOL] [docstring] [EOL] assert fb . encode_image ( [string] ) == [string] [EOL] [EOL] [EOL] def test_get_matched_faces ( ) : [EOL] [docstring] [EOL] assert fb . get_matched_faces ( PARSED_FACES ) == MATCHED_FACES [EOL] [EOL] [EOL] def test_parse_faces ( ) : [EOL] [docstring] [EOL] assert fb . parse_faces ( MOCK_JSON [ [string] ] ) == PARSED_FACES [EOL] [EOL] [EOL] @ patch ( [string] , Mock ( return_value = False ) ) def test_valid_file_path ( ) : [EOL] [docstring] [EOL] assert not fb . valid_file_path ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def mock_image ( ) : [EOL] [docstring] [EOL] with patch ( [string] , return_value = [string] ) as image : [EOL] yield image [EOL] [EOL] [EOL] async def test_setup_platform ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , ip . DOMAIN , VALID_CONFIG ) [EOL] assert hass . states . get ( VALID_ENTITY_ID ) [EOL] [EOL] [EOL] async def test_process_image ( hass , mock_image ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , ip . DOMAIN , VALID_CONFIG ) [EOL] assert hass . states . get ( VALID_ENTITY_ID ) [EOL] [EOL] face_events = [ ] [EOL] [EOL] @ callback def mock_face_event ( event ) : [EOL] [docstring] [EOL] face_events . append ( event ) [EOL] [EOL] hass . bus . async_listen ( [string] , mock_face_event ) [EOL] [EOL] with requests_mock . Mocker ( ) as mock_req : [EOL] url = [string] . format ( MOCK_IP , MOCK_PORT ) [EOL] mock_req . post ( url , json = MOCK_JSON ) [EOL] data = { ATTR_ENTITY_ID : VALID_ENTITY_ID } [EOL] await hass . services . async_call ( ip . DOMAIN , ip . SERVICE_SCAN , service_data = data ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( VALID_ENTITY_ID ) [EOL] assert state . state == [string] [EOL] assert state . attributes . get ( [string] ) == MATCHED_FACES [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] [EOL] PARSED_FACES [ [number] ] [ ATTR_ENTITY_ID ] = VALID_ENTITY_ID [comment] [EOL] assert state . attributes . get ( [string] ) == PARSED_FACES [EOL] assert state . attributes . get ( CONF_FRIENDLY_NAME ) == [string] [EOL] [EOL] assert len ( face_events ) == [number] [EOL] assert face_events [ [number] ] . data [ ATTR_NAME ] == PARSED_FACES [ [number] ] [ ATTR_NAME ] [EOL] assert ( face_events [ [number] ] . data [ fb . ATTR_CONFIDENCE ] == PARSED_FACES [ [number] ] [ fb . ATTR_CONFIDENCE ] ) [EOL] assert face_events [ [number] ] . data [ ATTR_ENTITY_ID ] == VALID_ENTITY_ID [EOL] assert ( face_events [ [number] ] . data [ fb . ATTR_IMAGE_ID ] == PARSED_FACES [ [number] ] [ fb . ATTR_IMAGE_ID ] ) [EOL] assert ( face_events [ [number] ] . data [ fb . ATTR_BOUNDING_BOX ] == PARSED_FACES [ [number] ] [ fb . ATTR_BOUNDING_BOX ] ) [EOL] [EOL] [EOL] async def test_connection_error ( hass , mock_image ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , ip . DOMAIN , VALID_CONFIG ) [EOL] assert hass . states . get ( VALID_ENTITY_ID ) [EOL] [EOL] with requests_mock . Mocker ( ) as mock_req : [EOL] url = [string] . format ( MOCK_IP , MOCK_PORT ) [EOL] mock_req . register_uri ( [string] , url , exc = requests . exceptions . ConnectTimeout ) [EOL] data = { ATTR_ENTITY_ID : VALID_ENTITY_ID } [EOL] await hass . services . async_call ( ip . DOMAIN , ip . SERVICE_SCAN , service_data = data ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( VALID_ENTITY_ID ) [EOL] assert state . state == STATE_UNKNOWN [EOL] assert state . attributes . get ( [string] ) == [ ] [EOL] assert state . attributes . get ( [string] ) == { } [EOL] [EOL] [EOL] async def test_teach_service ( hass , mock_image , mock_isfile , mock_open_file ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , ip . DOMAIN , VALID_CONFIG ) [EOL] assert hass . states . get ( VALID_ENTITY_ID ) [EOL] [EOL] teach_events = [ ] [EOL] [EOL] @ callback def mock_teach_event ( event ) : [EOL] [docstring] [EOL] teach_events . append ( event ) [EOL] [EOL] hass . bus . async_listen ( [string] , mock_teach_event ) [EOL] [EOL] [comment] [EOL] hass . config . is_allowed_path = Mock ( return_value = True ) [EOL] [EOL] with requests_mock . Mocker ( ) as mock_req : [EOL] url = [string] . format ( MOCK_IP , MOCK_PORT ) [EOL] mock_req . post ( url , status_code = [number] ) [EOL] data = { ATTR_ENTITY_ID : VALID_ENTITY_ID , ATTR_NAME : MOCK_NAME , fb . FILE_PATH : MOCK_FILE_PATH } [EOL] await hass . services . async_call ( ip . DOMAIN , fb . SERVICE_TEACH_FACE , service_data = data ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( teach_events ) == [number] [EOL] assert teach_events [ [number] ] . data [ fb . ATTR_CLASSIFIER ] == fb . CLASSIFIER [EOL] assert teach_events [ [number] ] . data [ ATTR_NAME ] == MOCK_NAME [EOL] assert teach_events [ [number] ] . data [ fb . FILE_PATH ] == MOCK_FILE_PATH [EOL] assert teach_events [ [number] ] . data [ [string] ] [EOL] assert not teach_events [ [number] ] . data [ [string] ] [EOL] [EOL] [comment] [EOL] with requests_mock . Mocker ( ) as mock_req : [EOL] url = [string] . format ( MOCK_IP , MOCK_PORT ) [EOL] mock_req . post ( url , status_code = [number] , text = MOCK_ERROR ) [EOL] data = { ATTR_ENTITY_ID : VALID_ENTITY_ID , ATTR_NAME : MOCK_NAME , fb . FILE_PATH : MOCK_FILE_PATH } [EOL] await hass . services . async_call ( ip . DOMAIN , fb . SERVICE_TEACH_FACE , service_data = data ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( teach_events ) == [number] [EOL] assert teach_events [ [number] ] . data [ fb . ATTR_CLASSIFIER ] == fb . CLASSIFIER [EOL] assert teach_events [ [number] ] . data [ ATTR_NAME ] == MOCK_NAME [EOL] assert teach_events [ [number] ] . data [ fb . FILE_PATH ] == MOCK_FILE_PATH [EOL] assert not teach_events [ [number] ] . data [ [string] ] [EOL] assert teach_events [ [number] ] . data [ [string] ] == MOCK_ERROR [EOL] [EOL] [EOL] async def test_setup_platform_with_name ( hass ) : [EOL] [docstring] [EOL] named_entity_id = [string] . format ( MOCK_NAME ) [EOL] [EOL] valid_config_named = VALID_CONFIG . copy ( ) [EOL] valid_config_named [ ip . DOMAIN ] [ ip . CONF_SOURCE ] [ ip . CONF_NAME ] = MOCK_NAME [EOL] [EOL] await async_setup_component ( hass , ip . DOMAIN , valid_config_named ) [EOL] assert hass . states . get ( named_entity_id ) [EOL] state = hass . states . get ( named_entity_id ) [EOL] assert state . attributes . get ( CONF_FRIENDLY_NAME ) == MOCK_NAME [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] from homeassistant . components import vacuum [EOL] from homeassistant . components . vacuum import ( ATTR_BATTERY_LEVEL , ATTR_COMMAND , ATTR_ENTITY_ID , ATTR_FAN_SPEED , ATTR_FAN_SPEED_LIST , ATTR_PARAMS , ATTR_STATUS , DOMAIN , ENTITY_ID_ALL_VACUUMS , SERVICE_SEND_COMMAND , SERVICE_SET_FAN_SPEED ) [EOL] from homeassistant . components . vacuum . demo import ( DEMO_VACUUM_BASIC , DEMO_VACUUM_COMPLETE , DEMO_VACUUM_MINIMAL , DEMO_VACUUM_MOST , DEMO_VACUUM_NONE , FAN_SPEEDS ) [EOL] from homeassistant . const import ( ATTR_SUPPORTED_FEATURES , CONF_PLATFORM , STATE_OFF , STATE_ON ) [EOL] from homeassistant . setup import setup_component [EOL] from tests . common import get_test_home_assistant , mock_service [EOL] [EOL] [EOL] ENTITY_VACUUM_BASIC = [string] . format ( DOMAIN , DEMO_VACUUM_BASIC ) . lower ( ) [EOL] ENTITY_VACUUM_COMPLETE = [string] . format ( DOMAIN , DEMO_VACUUM_COMPLETE ) . lower ( ) [EOL] ENTITY_VACUUM_MINIMAL = [string] . format ( DOMAIN , DEMO_VACUUM_MINIMAL ) . lower ( ) [EOL] ENTITY_VACUUM_MOST = [string] . format ( DOMAIN , DEMO_VACUUM_MOST ) . lower ( ) [EOL] ENTITY_VACUUM_NONE = [string] . format ( DOMAIN , DEMO_VACUUM_NONE ) . lower ( ) [EOL] [EOL] [EOL] class TestVacuumDemo ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . assertTrue ( setup_component ( self . hass , DOMAIN , { DOMAIN : { CONF_PLATFORM : [string] } } ) ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_supported_features ( self ) : [EOL] [docstring] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertListEqual ( FAN_SPEEDS , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_MOST ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_MINIMAL ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_NONE ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] def test_methods ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( ENTITY_VACUUM_BASIC , STATE_ON ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_BASIC ) ) [EOL] [EOL] self . hass . states . set ( ENTITY_VACUUM_BASIC , STATE_OFF ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_BASIC ) ) [EOL] [EOL] self . hass . states . set ( ENTITY_ID_ALL_VACUUMS , STATE_ON ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass ) ) [EOL] [EOL] self . hass . states . set ( ENTITY_ID_ALL_VACUUMS , STATE_OFF ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass ) ) [EOL] [EOL] vacuum . turn_on ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . turn_off ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . toggle ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . start_pause ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . start_pause ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . stop ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertLess ( state . attributes . get ( ATTR_BATTERY_LEVEL ) , [number] ) [EOL] self . assertNotEqual ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] [EOL] vacuum . locate ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertIn ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] [EOL] vacuum . return_to_base ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertIn ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] [EOL] vacuum . set_fan_speed ( self . hass , FAN_SPEEDS [ - [number] ] , entity_id = ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertEqual ( FAN_SPEEDS [ - [number] ] , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] [EOL] vacuum . clean_spot ( self . hass , entity_id = ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertIn ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( STATE_ON , state . state ) [EOL] [EOL] def test_unsupported_methods ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( ENTITY_VACUUM_NONE , STATE_ON ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] vacuum . turn_off ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] vacuum . stop ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] self . hass . states . set ( ENTITY_VACUUM_NONE , STATE_OFF ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] vacuum . turn_on ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] vacuum . toggle ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] [comment] [EOL] vacuum . start_pause ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] vacuum . locate ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_NONE ) [EOL] self . assertIsNone ( state . attributes . get ( ATTR_STATUS ) ) [EOL] [EOL] vacuum . return_to_base ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_NONE ) [EOL] self . assertIsNone ( state . attributes . get ( ATTR_STATUS ) ) [EOL] [EOL] vacuum . set_fan_speed ( self . hass , FAN_SPEEDS [ - [number] ] , entity_id = ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_NONE ) [EOL] self . assertNotEqual ( FAN_SPEEDS [ - [number] ] , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] [EOL] vacuum . clean_spot ( self . hass , entity_id = ENTITY_VACUUM_BASIC ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] self . assertNotIn ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] def test_services ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] send_command_calls = mock_service ( self . hass , DOMAIN , SERVICE_SEND_COMMAND ) [EOL] [EOL] params = { [string] : [number] , [string] : [number] } [EOL] vacuum . send_command ( self . hass , [string] , entity_id = ENTITY_VACUUM_BASIC , params = params ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( send_command_calls ) ) [EOL] call = send_command_calls [ - [number] ] [EOL] [EOL] self . assertEqual ( DOMAIN , call . domain ) [EOL] self . assertEqual ( SERVICE_SEND_COMMAND , call . service ) [EOL] self . assertEqual ( ENTITY_VACUUM_BASIC , call . data [ ATTR_ENTITY_ID ] ) [EOL] self . assertEqual ( [string] , call . data [ ATTR_COMMAND ] ) [EOL] self . assertEqual ( params , call . data [ ATTR_PARAMS ] ) [EOL] [EOL] [comment] [EOL] set_fan_speed_calls = mock_service ( self . hass , DOMAIN , SERVICE_SET_FAN_SPEED ) [EOL] [EOL] vacuum . set_fan_speed ( self . hass , FAN_SPEEDS [ [number] ] , entity_id = ENTITY_VACUUM_COMPLETE ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( set_fan_speed_calls ) ) [EOL] call = set_fan_speed_calls [ - [number] ] [EOL] [EOL] self . assertEqual ( DOMAIN , call . domain ) [EOL] self . assertEqual ( SERVICE_SET_FAN_SPEED , call . service ) [EOL] self . assertEqual ( ENTITY_VACUUM_COMPLETE , call . data [ ATTR_ENTITY_ID ] ) [EOL] self . assertEqual ( FAN_SPEEDS [ [number] ] , call . data [ ATTR_FAN_SPEED ] ) [EOL] [EOL] def test_set_fan_speed ( self ) : [EOL] [docstring] [EOL] group_vacuums = [string] . join ( [ ENTITY_VACUUM_BASIC , ENTITY_VACUUM_COMPLETE ] ) [EOL] old_state_basic = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] old_state_complete = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] [EOL] vacuum . set_fan_speed ( self . hass , FAN_SPEEDS [ [number] ] , entity_id = group_vacuums ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] new_state_basic = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] new_state_complete = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] [EOL] self . assertEqual ( old_state_basic , new_state_basic ) [EOL] self . assertNotIn ( ATTR_FAN_SPEED , new_state_basic . attributes ) [EOL] [EOL] self . assertNotEqual ( old_state_complete , new_state_complete ) [EOL] self . assertEqual ( FAN_SPEEDS [ [number] ] , old_state_complete . attributes [ ATTR_FAN_SPEED ] ) [EOL] self . assertEqual ( FAN_SPEEDS [ [number] ] , new_state_complete . attributes [ ATTR_FAN_SPEED ] ) [EOL] [EOL] def test_send_command ( self ) : [EOL] [docstring] [EOL] group_vacuums = [string] . join ( [ ENTITY_VACUUM_BASIC , ENTITY_VACUUM_COMPLETE ] ) [EOL] old_state_basic = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] old_state_complete = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] [EOL] vacuum . send_command ( self . hass , [string] , params = { [string] : [number] } , entity_id = group_vacuums ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] new_state_basic = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] new_state_complete = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] [EOL] self . assertEqual ( old_state_basic , new_state_basic ) [EOL] self . assertNotEqual ( old_state_complete , new_state_complete ) [EOL] self . assertEqual ( STATE_ON , new_state_complete . state ) [EOL] self . assertEqual ( [string] , new_state_complete . attributes [ ATTR_STATUS ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import Mock , patch [EOL] [EOL] import requests [EOL] [EOL] from homeassistant . components . climate . fritzbox import FritzboxThermostat [EOL] [EOL] [EOL] class TestFritzboxClimate ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . device = Mock ( ) [EOL] self . device . name = [string] [EOL] self . device . actual_temperature = [number] [EOL] self . device . target_temperature = [number] [EOL] self . device . comfort_temperature = [number] [EOL] self . device . eco_temperature = [number] [EOL] self . device . present = True [EOL] self . device . device_lock = True [EOL] self . device . lock = False [EOL] self . device . battery_low = True [EOL] self . device . set_target_temperature = Mock ( ) [EOL] self . device . update = Mock ( ) [EOL] mock_fritz = Mock ( ) [EOL] mock_fritz . login = Mock ( ) [EOL] self . thermostat = FritzboxThermostat ( self . device , mock_fritz ) [EOL] [EOL] def test_init ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . _current_temperature ) [EOL] self . assertEqual ( [number] , self . thermostat . _target_temperature ) [EOL] self . assertEqual ( [number] , self . thermostat . _comfort_temperature ) [EOL] self . assertEqual ( [number] , self . thermostat . _eco_temperature ) [EOL] [EOL] def test_supported_features ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . supported_features ) [EOL] [EOL] def test_available ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( self . thermostat . available ) [EOL] self . thermostat . _device . present = False [EOL] self . assertFalse ( self . thermostat . available ) [EOL] [EOL] def test_name ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [string] , self . thermostat . name ) [EOL] [EOL] def test_temperature_unit ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [string] , self . thermostat . temperature_unit ) [EOL] [EOL] def test_precision ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . precision ) [EOL] [EOL] def test_current_temperature ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . current_temperature ) [EOL] [EOL] def test_target_temperature ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . target_temperature ) [EOL] [EOL] self . thermostat . _target_temperature = [number] [EOL] self . assertEqual ( None , self . thermostat . target_temperature ) [EOL] [EOL] self . thermostat . _target_temperature = [number] [EOL] self . assertEqual ( None , self . thermostat . target_temperature ) [EOL] [EOL] @ patch . object ( FritzboxThermostat , [string] ) def test_set_temperature_operation_mode ( self , mock_set_op ) : [EOL] [docstring] [EOL] self . thermostat . set_temperature ( operation_mode = [string] ) [EOL] mock_set_op . assert_called_once_with ( [string] ) [EOL] [EOL] def test_set_temperature_temperature ( self ) : [EOL] [docstring] [EOL] self . thermostat . set_temperature ( temperature = [number] ) [EOL] self . thermostat . _device . set_target_temperature . assert_called_once_with ( [number] ) [EOL] [EOL] @ patch . object ( FritzboxThermostat , [string] ) def test_set_temperature_none ( self , mock_set_op ) : [EOL] [docstring] [EOL] self . thermostat . set_temperature ( ) [EOL] mock_set_op . assert_not_called ( ) [EOL] self . thermostat . _device . set_target_temperature . assert_not_called ( ) [EOL] [EOL] @ patch . object ( FritzboxThermostat , [string] ) def test_set_temperature_operation_mode_precedence ( self , mock_set_op ) : [EOL] [docstring] [EOL] self . thermostat . set_temperature ( operation_mode = [string] , temperature = [number] ) [EOL] mock_set_op . assert_called_once_with ( [string] ) [EOL] self . thermostat . _device . set_target_temperature . assert_not_called ( ) [EOL] [EOL] def test_current_operation ( self ) : [EOL] [docstring] [EOL] self . thermostat . _target_temperature = [number] [EOL] self . assertEqual ( [string] , self . thermostat . current_operation ) [EOL] self . thermostat . _target_temperature = [number] [EOL] self . assertEqual ( [string] , self . thermostat . current_operation ) [EOL] self . thermostat . _target_temperature = [number] [EOL] self . assertEqual ( [string] , self . thermostat . current_operation ) [EOL] self . thermostat . _target_temperature = [number] [EOL] self . assertEqual ( [string] , self . thermostat . current_operation ) [EOL] self . thermostat . _target_temperature = [number] [EOL] self . assertEqual ( [string] , self . thermostat . current_operation ) [EOL] [EOL] def test_operation_list ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [ [string] , [string] , [string] , [string] ] , self . thermostat . operation_list ) [EOL] [EOL] @ patch . object ( FritzboxThermostat , [string] ) def test_set_operation_mode ( self , mock_set_temp ) : [EOL] [docstring] [EOL] values = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] for mode , temp in values . items ( ) : [EOL] print ( mode , temp ) [EOL] [EOL] mock_set_temp . reset_mock ( ) [EOL] self . thermostat . set_operation_mode ( mode ) [EOL] mock_set_temp . assert_called_once_with ( temperature = temp ) [EOL] [EOL] mock_set_temp . reset_mock ( ) [EOL] self . thermostat . set_operation_mode ( [string] ) [EOL] mock_set_temp . assert_not_called ( ) [EOL] [EOL] def test_min_max_temperature ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . min_temp ) [EOL] self . assertEqual ( [number] , self . thermostat . max_temp ) [EOL] [EOL] def test_device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = self . thermostat . device_state_attributes [EOL] self . assertEqual ( attr [ [string] ] , True ) [EOL] self . assertEqual ( attr [ [string] ] , False ) [EOL] self . assertEqual ( attr [ [string] ] , True ) [EOL] [EOL] def test_update ( self ) : [EOL] [docstring] [EOL] device = Mock ( ) [EOL] device . update = Mock ( ) [EOL] device . actual_temperature = [number] [EOL] device . target_temperature = [number] [EOL] device . comfort_temperature = [number] [EOL] device . eco_temperature = [number] [EOL] self . thermostat . _device = device [EOL] [EOL] self . thermostat . update ( ) [EOL] [EOL] device . update . assert_called_once_with ( ) [EOL] self . assertEqual ( [number] , self . thermostat . _current_temperature ) [EOL] self . assertEqual ( [number] , self . thermostat . _target_temperature ) [EOL] self . assertEqual ( [number] , self . thermostat . _comfort_temperature ) [EOL] self . assertEqual ( [number] , self . thermostat . _eco_temperature ) [EOL] [EOL] def test_update_http_error ( self ) : [EOL] [docstring] [EOL] self . device . update . side_effect = requests . exceptions . HTTPError [EOL] self . thermostat . update ( ) [EOL] self . thermostat . _fritz . login . assert_called_once_with ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components import rfxtrx as rfxtrx_core [EOL] [EOL] from tests . common import get_test_home_assistant , mock_component [EOL] [EOL] [EOL] @ pytest . mark . skipif ( [string] ) class TestSwitchRfxtrx ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] mock_component ( self . hass , [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS = [ ] [EOL] rfxtrx_core . RFX_DEVICES = { } [EOL] if rfxtrx_core . RFXOBJECT : [EOL] rfxtrx_core . RFXOBJECT . close_connection ( ) [EOL] self . hass . stop ( ) [EOL] [EOL] def test_valid_config ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : True , [string] : { [string] : { [string] : [string] , rfxtrx_core . ATTR_FIREEVENT : True } } } } ) ) [EOL] [EOL] def test_valid_config_int_device_id ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : True , [string] : { [number] : { [string] : [string] , rfxtrx_core . ATTR_FIREEVENT : True } } } } ) ) [EOL] [EOL] def test_invalid_config1 ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : True , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] } } } } ) ) [EOL] [EOL] def test_invalid_config2 ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : True , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , rfxtrx_core . ATTR_FIREEVENT : True } } } } ) ) [EOL] [EOL] def test_invalid_config3 ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : True , [string] : { [string] : { [string] : [string] , [string] : [string] , rfxtrx_core . ATTR_FIREEVENT : True } } } } ) ) [EOL] [EOL] def test_invalid_config4 ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : True , [string] : { [string] : { [string] : [string] , rfxtrx_core . ATTR_FIREEVENT : True } } } } ) ) [EOL] [EOL] def test_default_config ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { } } } ) ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] [EOL] def test_old_config ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] } } } } ) ) [EOL] [EOL] import RFXtrx as rfxtrxmod [EOL] rfxtrx_core . RFXOBJECT = rfxtrxmod . Core ( [string] , transport_protocol = rfxtrxmod . DummyTransport ) [EOL] [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] entity = rfxtrx_core . RFX_DEVICES [ [string] ] [EOL] self . assertEqual ( [string] , entity . name ) [EOL] self . assertEqual ( [string] , entity . state ) [EOL] self . assertTrue ( entity . assumed_state ) [EOL] self . assertEqual ( entity . signal_repetitions , [number] ) [EOL] self . assertFalse ( entity . should_fire_event ) [EOL] self . assertFalse ( entity . should_poll ) [EOL] [EOL] self . assertFalse ( entity . is_on ) [EOL] entity . turn_on ( ) [EOL] self . assertTrue ( entity . is_on ) [EOL] entity . turn_off ( ) [EOL] self . assertFalse ( entity . is_on ) [EOL] [EOL] def test_one_switch ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] } } } } ) ) [EOL] [EOL] import RFXtrx as rfxtrxmod [EOL] rfxtrx_core . RFXOBJECT = rfxtrxmod . Core ( [string] , transport_protocol = rfxtrxmod . DummyTransport ) [EOL] [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] entity = rfxtrx_core . RFX_DEVICES [ [string] ] [EOL] self . assertEqual ( [string] , entity . name ) [EOL] self . assertEqual ( [string] , entity . state ) [EOL] self . assertTrue ( entity . assumed_state ) [EOL] self . assertEqual ( entity . signal_repetitions , [number] ) [EOL] self . assertFalse ( entity . should_fire_event ) [EOL] self . assertFalse ( entity . should_poll ) [EOL] [EOL] self . assertFalse ( entity . is_on ) [EOL] entity . turn_on ( ) [EOL] self . assertTrue ( entity . is_on ) [EOL] entity . turn_off ( ) [EOL] self . assertFalse ( entity . is_on ) [EOL] [EOL] entity_id = rfxtrx_core . RFX_DEVICES [ [string] ] . entity_id [EOL] entity_hass = self . hass . states . get ( entity_id ) [EOL] self . assertEqual ( [string] , entity_hass . name ) [EOL] self . assertEqual ( [string] , entity_hass . state ) [EOL] entity . turn_on ( ) [EOL] entity_hass = self . hass . states . get ( entity_id ) [EOL] self . assertEqual ( [string] , entity_hass . state ) [EOL] entity . turn_off ( ) [EOL] entity_hass = self . hass . states . get ( entity_id ) [EOL] self . assertEqual ( [string] , entity_hass . state ) [EOL] [EOL] def test_several_switches ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [number] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } } ) ) [EOL] [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] device_num = [number] [EOL] for id in rfxtrx_core . RFX_DEVICES : [EOL] entity = rfxtrx_core . RFX_DEVICES [ id ] [EOL] self . assertEqual ( entity . signal_repetitions , [number] ) [EOL] if entity . name == [string] : [EOL] device_num = device_num + [number] [EOL] self . assertEqual ( [string] , entity . state ) [EOL] self . assertEqual ( [string] , entity . __str__ ( ) ) [EOL] elif entity . name == [string] : [EOL] device_num = device_num + [number] [EOL] self . assertEqual ( [string] , entity . state ) [EOL] self . assertEqual ( [string] , entity . __str__ ( ) ) [EOL] elif entity . name == [string] : [EOL] device_num = device_num + [number] [EOL] self . assertEqual ( [string] , entity . state ) [EOL] self . assertEqual ( [string] , entity . __str__ ( ) ) [EOL] [EOL] self . assertEqual ( [number] , device_num ) [EOL] [EOL] def test_discover_switch ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : True , [string] : { } } } ) ) [EOL] [EOL] event = rfxtrx_core . get_rfx_object ( [string] ) [EOL] event . data = bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] entity = rfxtrx_core . RFX_DEVICES [ [string] ] [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] self . assertEqual ( [string] , entity . __str__ ( ) ) [EOL] [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] [EOL] event = rfxtrx_core . get_rfx_object ( [string] ) [EOL] event . data = bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] entity = rfxtrx_core . RFX_DEVICES [ [string] ] [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] self . assertEqual ( [string] , entity . __str__ ( ) ) [EOL] [EOL] [comment] [EOL] event = rfxtrx_core . get_rfx_object ( [string] ) [EOL] event . data = bytearray ( [string] ) [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] [EOL] [comment] [EOL] event = rfxtrx_core . get_rfx_object ( [string] ) [EOL] event . data = bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] [EOL] [comment] [EOL] event = rfxtrx_core . get_rfx_object ( [string] ) [EOL] event . data = bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] [EOL] def test_discover_switch_noautoadd ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : False , [string] : { } } } ) ) [EOL] [EOL] event = rfxtrx_core . get_rfx_object ( [string] ) [EOL] event . data = bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] [EOL] event = rfxtrx_core . get_rfx_object ( [string] ) [EOL] event . data = bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] [EOL] [comment] [EOL] event = rfxtrx_core . get_rfx_object ( [string] ) [EOL] event . data = bytearray ( [string] ) [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] [EOL] [comment] [EOL] event = rfxtrx_core . get_rfx_object ( [string] ) [EOL] event . data = bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL] [EOL] [comment] [EOL] event = rfxtrx_core . get_rfx_object ( [string] ) [EOL] event . data = bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] rfxtrx_core . RECEIVED_EVT_SUBSCRIBERS [ [number] ] ( event ) [EOL] self . assertEqual ( [number] , len ( rfxtrx_core . RFX_DEVICES ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from unittest . mock import Mock , patch [EOL] [EOL] import aiohue [EOL] import pytest [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . hue import config_flow , const , errors [EOL] [EOL] from tests . common import MockConfigEntry , mock_coro [EOL] [EOL] [EOL] async def test_flow_works ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( const . API_NUPNP , json = [ { [string] : [string] , [string] : [string] } ] ) [EOL] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] await flow . async_step_init ( ) [EOL] [EOL] with patch ( [string] ) as mock_bridge : [EOL] def mock_constructor ( host , websession , username = None ) : [EOL] [docstring] [EOL] mock_bridge . host = host [EOL] return mock_bridge [EOL] [EOL] mock_bridge . side_effect = mock_constructor [EOL] mock_bridge . username = [string] [EOL] mock_bridge . config . name = [string] [EOL] mock_bridge . config . bridgeid = [string] [EOL] mock_bridge . create_user . return_value = mock_coro ( ) [EOL] mock_bridge . initialize . return_value = mock_coro ( ) [EOL] [EOL] result = await flow . async_step_link ( user_input = { } ) [EOL] [EOL] assert mock_bridge . host == [string] [EOL] assert len ( mock_bridge . create_user . mock_calls ) == [number] [EOL] assert len ( mock_bridge . initialize . mock_calls ) == [number] [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] async def test_flow_no_discovered_bridges ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( const . API_NUPNP , json = [ ] ) [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_init ( ) [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_flow_all_discovered_bridges_exist ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( const . API_NUPNP , json = [ { [string] : [string] , [string] : [string] } ] ) [EOL] MockConfigEntry ( domain = [string] , data = { [string] : [string] } ) . add_to_hass ( hass ) [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_init ( ) [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_flow_one_bridge_discovered ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( const . API_NUPNP , json = [ { [string] : [string] , [string] : [string] } ] ) [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_init ( ) [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_flow_two_bridges_discovered ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( const . API_NUPNP , json = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] ) [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_init ( ) [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] with pytest . raises ( vol . Invalid ) : [EOL] assert result [ [string] ] ( { [string] : [string] } ) [EOL] [EOL] result [ [string] ] ( { [string] : [string] } ) [EOL] result [ [string] ] ( { [string] : [string] } ) [EOL] [EOL] [EOL] async def test_flow_two_bridges_discovered_one_new ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( const . API_NUPNP , json = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] ) [EOL] MockConfigEntry ( domain = [string] , data = { [string] : [string] } ) . add_to_hass ( hass ) [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_init ( ) [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert flow . host == [string] [EOL] [EOL] [EOL] async def test_flow_timeout_discovery ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch ( [string] , side_effect = asyncio . TimeoutError ) : [EOL] result = await flow . async_step_init ( ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_flow_link_timeout ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch ( [string] , side_effect = asyncio . TimeoutError ) : [EOL] result = await flow . async_step_link ( { } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] async def test_flow_link_button_not_pressed ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch ( [string] , side_effect = aiohue . LinkButtonNotPressed ) : [EOL] result = await flow . async_step_link ( { } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] async def test_flow_link_unknown_host ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch ( [string] , side_effect = aiohue . RequestError ) : [EOL] result = await flow . async_step_link ( { } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] async def test_bridge_discovery ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch . object ( config_flow , [string] , side_effect = errors . AuthenticationRequired ) : [EOL] result = await flow . async_step_discovery ( { [string] : [string] , [string] : [string] } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_bridge_discovery_emulated_hue ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_discovery ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_bridge_discovery_already_configured ( hass ) : [EOL] [docstring] [EOL] MockConfigEntry ( domain = [string] , data = { [string] : [string] } ) . add_to_hass ( hass ) [EOL] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_discovery ( { [string] : [string] , [string] : [string] } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_import_with_existing_config ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] bridge = Mock ( ) [EOL] bridge . username = [string] [EOL] bridge . config . bridgeid = [string] [EOL] bridge . config . name = [string] [EOL] bridge . host = [string] [EOL] [EOL] with patch . object ( config_flow , [string] , return_value = [string] ) , patch . object ( config_flow , [string] , return_value = mock_coro ( bridge ) ) : [EOL] result = await flow . async_step_import ( { [string] : [string] , [string] : [string] } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] async def test_import_with_no_config ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch . object ( config_flow , [string] , side_effect = errors . AuthenticationRequired ) : [EOL] result = await flow . async_step_import ( { [string] : [string] , } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_import_with_existing_but_invalid_config ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch . object ( config_flow , [string] , return_value = [string] ) , patch . object ( config_flow , [string] , side_effect = errors . AuthenticationRequired ) : [EOL] result = await flow . async_step_import ( { [string] : [string] , [string] : [string] } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_import_cannot_connect ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch . object ( config_flow , [string] , side_effect = errors . CannotConnect ) : [EOL] result = await flow . async_step_import ( { [string] : [string] , } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_creating_entry_removes_entries_for_same_host_or_bridge ( hass ) : [EOL] [docstring] [EOL] MockConfigEntry ( domain = [string] , data = { [string] : [string] , [string] : [string] } ) . add_to_hass ( hass ) [EOL] [EOL] MockConfigEntry ( domain = [string] , data = { [string] : [string] , [string] : [string] } ) . add_to_hass ( hass ) [EOL] [EOL] assert len ( hass . config_entries . async_entries ( [string] ) ) == [number] [EOL] [EOL] flow = config_flow . HueFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] bridge = Mock ( ) [EOL] bridge . username = [string] [EOL] bridge . config . bridgeid = [string] [EOL] bridge . config . name = [string] [EOL] bridge . host = [string] [EOL] [EOL] with patch . object ( config_flow , [string] , return_value = mock_coro ( bridge ) ) : [EOL] result = await flow . async_step_import ( { [string] : [string] , } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [comment] [EOL] [comment] [EOL] assert len ( hass . config_entries . async_entries ( [string] ) ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Dict , Any , Match , Optional , Generator [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import re [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components . frontend import ( DOMAIN , CONF_JS_VERSION , CONF_THEMES , CONF_EXTRA_HTML_URL , CONF_EXTRA_HTML_URL_ES5 ) [EOL] from homeassistant . components import websocket_api as wapi [EOL] [EOL] from tests . common import mock_coro [EOL] [EOL] [EOL] CONFIG_THEMES = { DOMAIN : { CONF_THEMES : { [string] : { [string] : [string] } } } } [EOL] [EOL] [EOL] @ pytest . fixture def mock_http_client ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] hass . loop . run_until_complete ( async_setup_component ( hass , [string] , { } ) ) [EOL] return hass . loop . run_until_complete ( aiohttp_client ( hass . http . app ) ) [EOL] [EOL] [EOL] @ pytest . fixture def mock_http_client_with_themes ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] hass . loop . run_until_complete ( async_setup_component ( hass , [string] , { DOMAIN : { CONF_THEMES : { [string] : { [string] : [string] } } } } ) ) [EOL] return hass . loop . run_until_complete ( aiohttp_client ( hass . http . app ) ) [EOL] [EOL] [EOL] @ pytest . fixture def mock_http_client_with_urls ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] hass . loop . run_until_complete ( async_setup_component ( hass , [string] , { DOMAIN : { CONF_JS_VERSION : [string] , CONF_EXTRA_HTML_URL : [ [string] ] , CONF_EXTRA_HTML_URL_ES5 : [ [string] ] } } ) ) [EOL] return hass . loop . run_until_complete ( aiohttp_client ( hass . http . app ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_frontend_and_static ( mock_http_client ) : [EOL] [docstring] [EOL] resp = yield from mock_http_client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] assert [string] not in resp . headers [EOL] [EOL] text = yield from resp . text ( ) [EOL] [EOL] [comment] [EOL] frontendjs = re . search ( [string] , text ) [EOL] [EOL] assert frontendjs is not None [EOL] resp = yield from mock_http_client . get ( frontendjs . groups ( [number] ) [ [number] ] ) [EOL] assert resp . status == [number] [EOL] assert [string] in resp . headers . get ( [string] ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_dont_cache_service_worker ( mock_http_client ) : [EOL] [docstring] [EOL] resp = yield from mock_http_client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] assert [string] not in resp . headers [EOL] [EOL] resp = yield from mock_http_client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] assert [string] not in resp . headers [EOL] [EOL] [EOL] @ asyncio . coroutine def test_404 ( mock_http_client ) : [EOL] [docstring] [EOL] resp = yield from mock_http_client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_we_cannot_POST_to_root ( mock_http_client ) : [EOL] [docstring] [EOL] resp = yield from mock_http_client . post ( [string] ) [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_states_routes ( mock_http_client ) : [EOL] [docstring] [EOL] resp = yield from mock_http_client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] [EOL] resp = yield from mock_http_client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] async def test_themes_api ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] assert await async_setup_component ( hass , [string] , CONFIG_THEMES ) [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] [ [string] ] == [string] [EOL] assert msg [ [string] ] [ [string] ] == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] async def test_themes_set_theme ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] assert await async_setup_component ( hass , [string] , CONFIG_THEMES ) [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] await hass . services . async_call ( DOMAIN , [string] , { [string] : [string] } , blocking = True ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] [ [string] ] == [string] [EOL] [EOL] await hass . services . async_call ( DOMAIN , [string] , { [string] : [string] } , blocking = True ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_themes_set_theme_wrong_name ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] assert await async_setup_component ( hass , [string] , CONFIG_THEMES ) [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] await hass . services . async_call ( DOMAIN , [string] , { [string] : [string] } , blocking = True ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_themes_reload_themes ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] assert await async_setup_component ( hass , [string] , CONFIG_THEMES ) [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] with patch ( [string] , return_value = { DOMAIN : { CONF_THEMES : { [string] : { [string] : [string] } } } } ) : [EOL] await hass . services . async_call ( DOMAIN , [string] , { [string] : [string] } , blocking = True ) [EOL] await hass . services . async_call ( DOMAIN , [string] , blocking = True ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] [ [string] ] == { [string] : { [string] : [string] } } [EOL] assert msg [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_missing_themes ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] ) [EOL] [EOL] client = await hass_ws_client ( hass ) [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == [number] [EOL] assert msg [ [string] ] == wapi . TYPE_RESULT [EOL] assert msg [ [string] ] [EOL] assert msg [ [string] ] [ [string] ] == [string] [EOL] assert msg [ [string] ] [ [string] ] == { } [EOL] [EOL] [EOL] @ asyncio . coroutine def test_extra_urls ( mock_http_client_with_urls ) : [EOL] [docstring] [EOL] resp = yield from mock_http_client_with_urls . get ( [string] ) [EOL] assert resp . status == [number] [EOL] text = yield from resp . text ( ) [EOL] assert text . find ( [string] ) >= [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_extra_urls_es5 ( mock_http_client_with_urls ) : [EOL] [docstring] [EOL] resp = yield from mock_http_client_with_urls . get ( [string] ) [EOL] assert resp . status == [number] [EOL] text = yield from resp . text ( ) [EOL] assert text . find ( [string] ) >= [number] [EOL] [EOL] [EOL] async def test_get_panels ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] ) [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] [EOL] client = await hass_ws_client ( hass ) [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == [number] [EOL] assert msg [ [string] ] == wapi . TYPE_RESULT [EOL] assert msg [ [string] ] [EOL] assert msg [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] assert msg [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] assert msg [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] assert msg [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_get_translations ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] ) [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] with patch ( [string] , side_effect = lambda hass , lang : mock_coro ( { [string] : lang } ) ) : [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == [number] [EOL] assert msg [ [string] ] == wapi . TYPE_RESULT [EOL] assert msg [ [string] ] [EOL] assert msg [ [string] ] == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] async def test_lovelace_ui ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] ) [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] with patch ( [string] , return_value = { [string] : [string] } ) : [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == [number] [EOL] assert msg [ [string] ] == wapi . TYPE_RESULT [EOL] assert msg [ [string] ] [EOL] assert msg [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] async def test_lovelace_ui_not_found ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] ) [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] with patch ( [string] , side_effect = FileNotFoundError ) : [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == [number] [EOL] assert msg [ [string] ] == wapi . TYPE_RESULT [EOL] assert msg [ [string] ] is False [EOL] assert msg [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_lovelace_ui_load_err ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] ) [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] with patch ( [string] , side_effect = HomeAssistantError ) : [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == [number] [EOL] assert msg [ [string] ] == wapi . TYPE_RESULT [EOL] assert msg [ [string] ] is False [EOL] assert msg [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_auth_load ( mock_http_client ) : [EOL] [docstring] [EOL] resp = await mock_http_client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] async def test_onboarding_load ( mock_http_client ) : [EOL] [docstring] [EOL] resp = await mock_http_client . get ( [string] ) [EOL] assert resp . status == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 $builtins.int$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from functools import partial [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant import config_entries , data_entry_flow [EOL] [EOL] [EOL] def register_discovery_flow ( domain , title , discovery_function ) : [EOL] [docstring] [EOL] config_entries . HANDLERS . register ( domain ) ( partial ( DiscoveryFlowHandler , domain , title , discovery_function ) ) [EOL] [EOL] [EOL] class DiscoveryFlowHandler ( data_entry_flow . FlowHandler ) : [EOL] [docstring] [EOL] [EOL] VERSION = [number] [EOL] [EOL] def __init__ ( self , domain , title , discovery_function ) : [EOL] [docstring] [EOL] self . _domain = domain [EOL] self . _title = title [EOL] self . _discovery_function = discovery_function [EOL] [EOL] async def async_step_init ( self , user_input = None ) : [EOL] [docstring] [EOL] if self . _async_current_entries ( ) : [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] [comment] [EOL] in_progress = self . _async_in_progress ( ) [EOL] [EOL] has_devices = in_progress [EOL] if not has_devices : [EOL] has_devices = await self . hass . async_add_job ( self . _discovery_function , self . hass ) [EOL] [EOL] if not has_devices : [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] [comment] [EOL] for flow in in_progress : [EOL] self . hass . config_entries . flow . async_abort ( flow [ [string] ] ) [EOL] [EOL] return self . async_create_entry ( title = self . _title , data = { } , ) [EOL] [EOL] async def async_step_confirm ( self , user_input = None ) : [EOL] [docstring] [EOL] if user_input is not None : [EOL] return self . async_create_entry ( title = self . _title , data = { } , ) [EOL] [EOL] return self . async_show_form ( step_id = [string] , ) [EOL] [EOL] async def async_step_discovery ( self , discovery_info ) : [EOL] [docstring] [EOL] if self . _async_in_progress ( ) or self . _async_current_entries ( ) : [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] return await self . async_step_confirm ( ) [EOL] [EOL] async def async_step_import ( self , _ ) : [EOL] [docstring] [EOL] if self . _async_in_progress ( ) or self . _async_current_entries ( ) : [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] return self . async_create_entry ( title = self . _title , data = { } , ) [EOL] [EOL] @ callback def _async_current_entries ( self ) : [EOL] [docstring] [EOL] return self . hass . config_entries . async_entries ( self . _domain ) [EOL] [EOL] @ callback def _async_in_progress ( self ) : [EOL] [docstring] [EOL] return [ flw for flw in self . hass . config_entries . flow . async_progress ( ) if flw [ [string] ] == self . _domain and flw [ [string] ] != self . flow_id ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import OrderedDict , Any [EOL] import typing [EOL] import collections [EOL] [docstring] [EOL] from collections import OrderedDict [EOL] import fnmatch [EOL] import re [EOL] [EOL] from homeassistant . core import split_entity_id [EOL] [EOL] [EOL] class EntityValues : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , exact = None , domain = None , glob = None ) : [EOL] [docstring] [EOL] self . _cache = { } [EOL] self . _exact = exact [EOL] self . _domain = domain [EOL] [EOL] if glob is None : [EOL] compiled = None [EOL] else : [EOL] compiled = OrderedDict ( ) [EOL] for key , value in glob . items ( ) : [EOL] compiled [ re . compile ( fnmatch . translate ( key ) ) ] = value [EOL] [EOL] self . _glob = compiled [EOL] [EOL] def get ( self , entity_id ) : [EOL] [docstring] [EOL] if entity_id in self . _cache : [EOL] return self . _cache [ entity_id ] [EOL] [EOL] domain , _ = split_entity_id ( entity_id ) [EOL] result = self . _cache [ entity_id ] = { } [EOL] [EOL] if self . _domain is not None and domain in self . _domain : [EOL] result . update ( self . _domain [ domain ] ) [EOL] [EOL] if self . _glob is not None : [EOL] for pattern , values in self . _glob . items ( ) : [EOL] if pattern . match ( entity_id ) : [EOL] result . update ( values ) [EOL] [EOL] if self . _exact is not None and entity_id in self . _exact : [EOL] result . update ( self . _exact [ entity_id ] ) [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import threading [EOL] [docstring] [EOL] [comment] [EOL] import threading [EOL] import logging [EOL] import os [EOL] import time [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( EVENT_HOMEASSISTANT_START , EVENT_HOMEASSISTANT_STOP ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEVICE_DESCRIPTOR = [string] [EOL] DEVICE_ID_GROUP = [string] [EOL] DEVICE_NAME = [string] [EOL] DOMAIN = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] KEY_CODE = [string] [EOL] KEY_VALUE = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] KEYBOARD_REMOTE_COMMAND_RECEIVED = [string] [EOL] KEYBOARD_REMOTE_CONNECTED = [string] [EOL] KEYBOARD_REMOTE_DISCONNECTED = [string] [EOL] [EOL] TYPE = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . All ( cv . ensure_list , [ vol . Schema ( { vol . Exclusive ( DEVICE_DESCRIPTOR , DEVICE_ID_GROUP ) : cv . string , vol . Exclusive ( DEVICE_NAME , DEVICE_ID_GROUP ) : cv . string , vol . Optional ( TYPE , default = [string] ) : vol . All ( cv . string , vol . Any ( [string] , [string] , [string] ) ) } ) ] ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] config = config . get ( DOMAIN ) [EOL] [EOL] keyboard_remote = KeyboardRemote ( hass , config ) [EOL] [EOL] def _start_keyboard_remote ( _event ) : [EOL] keyboard_remote . run ( ) [EOL] [EOL] def _stop_keyboard_remote ( _event ) : [EOL] keyboard_remote . stop ( ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , _start_keyboard_remote ) [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , _stop_keyboard_remote ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class KeyboardRemoteThread ( threading . Thread ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device_name , device_descriptor , key_value ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . device_name = device_name [EOL] self . device_descriptor = device_descriptor [EOL] self . key_value = key_value [EOL] [EOL] if self . device_descriptor : [EOL] self . device_id = self . device_descriptor [EOL] else : [EOL] self . device_id = self . device_name [EOL] [EOL] self . dev = self . _get_keyboard_device ( ) [EOL] if self . dev is not None : [EOL] _LOGGER . debug ( [string] , self . device_id ) [EOL] else : [EOL] _LOGGER . debug ( [string] [string] , self . device_id ) [EOL] [EOL] id_folder = [string] [EOL] [EOL] if os . path . isdir ( id_folder ) : [EOL] from evdev import InputDevice , list_devices [EOL] device_names = [ InputDevice ( file_name ) . name for file_name in list_devices ( ) ] [EOL] _LOGGER . debug ( [string] [string] , device_names , id_folder , os . listdir ( id_folder ) ) [EOL] [EOL] threading . Thread . __init__ ( self ) [EOL] self . stopped = threading . Event ( ) [EOL] self . hass = hass [EOL] [EOL] def _get_keyboard_device ( self ) : [EOL] [docstring] [EOL] from evdev import InputDevice , list_devices [EOL] if self . device_name : [EOL] devices = [ InputDevice ( file_name ) for file_name in list_devices ( ) ] [EOL] for device in devices : [EOL] if self . device_name == device . name : [EOL] return device [EOL] elif self . device_descriptor : [EOL] try : [EOL] device = InputDevice ( self . device_descriptor ) [EOL] except OSError : [EOL] pass [EOL] else : [EOL] return device [EOL] return None [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] from evdev import categorize , ecodes [EOL] [EOL] if self . dev is not None : [EOL] self . dev . grab ( ) [EOL] _LOGGER . debug ( [string] , self . dev ) [EOL] [EOL] while not self . stopped . isSet ( ) : [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] if self . dev is None : [EOL] self . dev = self . _get_keyboard_device ( ) [EOL] if self . dev is not None : [EOL] self . dev . grab ( ) [EOL] self . hass . bus . fire ( KEYBOARD_REMOTE_CONNECTED ) [EOL] _LOGGER . debug ( [string] , self . device_id ) [EOL] else : [EOL] continue [EOL] [EOL] try : [EOL] event = self . dev . read_one ( ) [EOL] except IOError : [comment] [EOL] self . dev = None [EOL] self . hass . bus . fire ( KEYBOARD_REMOTE_DISCONNECTED ) [EOL] _LOGGER . debug ( [string] , self . device_id ) [EOL] continue [EOL] [EOL] if not event : [EOL] continue [EOL] [EOL] if event . type is ecodes . EV_KEY and event . value is self . key_value : [EOL] _LOGGER . debug ( categorize ( event ) ) [EOL] self . hass . bus . fire ( KEYBOARD_REMOTE_COMMAND_RECEIVED , { KEY_CODE : event . code , DEVICE_DESCRIPTOR : self . device_descriptor , DEVICE_NAME : self . device_name } ) [EOL] [EOL] [EOL] class KeyboardRemote : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] self . threads = [ ] [EOL] for dev_block in config : [EOL] device_descriptor = dev_block . get ( DEVICE_DESCRIPTOR ) [EOL] device_name = dev_block . get ( DEVICE_NAME ) [EOL] key_value = KEY_VALUE . get ( dev_block . get ( TYPE , [string] ) ) [EOL] [EOL] if device_descriptor is not None or device_name is not None : [EOL] thread = KeyboardRemoteThread ( hass , device_name , device_descriptor , key_value ) [EOL] self . threads . append ( thread ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] for thread in self . threads : [EOL] thread . start ( ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] for thread in self . threads : [EOL] thread . stopped . set ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.list$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.keyboard_remote.KeyboardRemoteThread$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $homeassistant.components.keyboard_remote.KeyboardRemoteThread$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 $homeassistant.components.keyboard_remote.KeyboardRemoteThread$ 0 0 0 $homeassistant.components.keyboard_remote.KeyboardRemoteThread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . helpers import discovery [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( CONF_PORT , CONF_HOST , CONF_PASSWORD , CONF_USERNAME , CONF_NAME , EVENT_HOMEASSISTANT_STOP ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_REPORT_SERVER_CODES = [string] [EOL] CONF_REPORT_SERVER_ENABLED = [string] [EOL] CONF_REPORT_SERVER_PORT = [string] [EOL] REPORT_SERVER_CODES_IGNORE = [string] [EOL] CONF_VERSION = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_REPORT_SERVER_ENABLED = False [EOL] DEFAULT_REPORT_SERVER_PORT = [number] [EOL] DEFAULT_VERSION = [string] [EOL] DOMAIN = [string] [EOL] EGARDIA_SERVER = [string] [EOL] EGARDIA_DEVICE = [string] [EOL] EGARDIA_NAME = [string] [EOL] EGARDIA_REPORT_SERVER_ENABLED = [string] [EOL] EGARDIA_REPORT_SERVER_CODES = [string] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] ATTR_DISCOVER_DEVICES = [string] [EOL] [EOL] SERVER_CODE_SCHEMA = vol . Schema ( { vol . Optional ( [string] ) : vol . All ( cv . ensure_list_csv , [ cv . string ] ) , vol . Optional ( [string] ) : vol . All ( cv . ensure_list_csv , [ cv . string ] ) , vol . Optional ( [string] ) : vol . All ( cv . ensure_list_csv , [ cv . string ] ) , vol . Optional ( [string] ) : vol . All ( cv . ensure_list_csv , [ cv . string ] ) , vol . Optional ( [string] ) : vol . All ( cv . ensure_list_csv , [ cv . string ] ) } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_VERSION , default = DEFAULT_VERSION ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_REPORT_SERVER_CODES , default = { } ) : SERVER_CODE_SCHEMA , vol . Optional ( CONF_REPORT_SERVER_ENABLED , default = DEFAULT_REPORT_SERVER_ENABLED ) : cv . boolean , vol . Optional ( CONF_REPORT_SERVER_PORT , default = DEFAULT_REPORT_SERVER_PORT ) : cv . port , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] from pythonegardia import egardiadevice [EOL] from pythonegardia import egardiaserver [EOL] conf = config [ DOMAIN ] [EOL] username = conf . get ( CONF_USERNAME ) [EOL] password = conf . get ( CONF_PASSWORD ) [EOL] host = conf . get ( CONF_HOST ) [EOL] port = conf . get ( CONF_PORT ) [EOL] version = conf . get ( CONF_VERSION ) [EOL] rs_enabled = conf . get ( CONF_REPORT_SERVER_ENABLED ) [EOL] rs_port = conf . get ( CONF_REPORT_SERVER_PORT ) [EOL] try : [EOL] device = hass . data [ EGARDIA_DEVICE ] = egardiadevice . EgardiaDevice ( host , port , username , password , [string] , version ) [EOL] except requests . exceptions . RequestException : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] except egardiadevice . UnauthorizedError : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [comment] [EOL] if rs_enabled : [EOL] _LOGGER . debug ( [string] ) [EOL] try : [EOL] if EGARDIA_SERVER not in hass . data : [EOL] server = egardiaserver . EgardiaServer ( [string] , rs_port ) [EOL] bound = server . bind ( ) [EOL] if not bound : [EOL] raise IOError ( [string] + [string] ) [EOL] hass . data [ EGARDIA_SERVER ] = server [EOL] server . start ( ) [EOL] [EOL] def handle_stop_event ( event ) : [EOL] [docstring] [EOL] server . stop ( ) [EOL] [EOL] [comment] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , handle_stop_event ) [EOL] [EOL] except IOError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] [EOL] discovery . load_platform ( hass , [string] , DOMAIN , discovered = conf , hass_config = config ) [EOL] [EOL] [comment] [EOL] sensors = device . getsensors ( ) [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { ATTR_DISCOVER_DEVICES : sensors } , config ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import CONF_HOST , CONF_PASSWORD , CONF_USERNAME [EOL] from homeassistant . helpers import discovery [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] LUTRON_CONTROLLER = [string] [EOL] LUTRON_DEVICES = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , base_config ) : [EOL] [docstring] [EOL] from pylutron import Lutron [EOL] [EOL] hass . data [ LUTRON_CONTROLLER ] = None [EOL] hass . data [ LUTRON_DEVICES ] = { [string] : [ ] , [string] : [ ] } [EOL] [EOL] config = base_config . get ( DOMAIN ) [EOL] hass . data [ LUTRON_CONTROLLER ] = Lutron ( config [ CONF_HOST ] , config [ CONF_USERNAME ] , config [ CONF_PASSWORD ] ) [EOL] [EOL] hass . data [ LUTRON_CONTROLLER ] . load_xml_db ( ) [EOL] hass . data [ LUTRON_CONTROLLER ] . connect ( ) [EOL] _LOGGER . info ( [string] , config [ CONF_HOST ] ) [EOL] [EOL] [comment] [EOL] for area in hass . data [ LUTRON_CONTROLLER ] . areas : [EOL] for output in area . outputs : [EOL] if output . type == [string] : [EOL] hass . data [ LUTRON_DEVICES ] [ [string] ] . append ( ( area . name , output ) ) [EOL] else : [EOL] hass . data [ LUTRON_DEVICES ] [ [string] ] . append ( ( area . name , output ) ) [EOL] [EOL] for component in ( [string] , [string] ) : [EOL] discovery . load_platform ( hass , component , DOMAIN , None , base_config ) [EOL] return True [EOL] [EOL] [EOL] class LutronDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , area_name , lutron_device , controller ) : [EOL] [docstring] [EOL] self . _lutron_device = lutron_device [EOL] self . _controller = controller [EOL] self . _area_name = area_name [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . async_add_job ( self . _controller . subscribe , self . _lutron_device , self . _update_callback ) [EOL] [EOL] def _update_callback ( self , _device ) : [EOL] [docstring] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _area_name , self . _lutron_device . name ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_HOST [EOL] from homeassistant . helpers import discovery [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] hass . data [ DOMAIN ] = config [ DOMAIN ] [ CONF_HOST ] [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_API_KEY [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . discovery import load_platform [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] CONF_API_SECRET = [string] [EOL] CONF_EXCHANGE_CURRENCIES = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] DATA_COINBASE = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_API_SECRET ) : cv . string , vol . Optional ( CONF_EXCHANGE_CURRENCIES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] api_key = config [ DOMAIN ] . get ( CONF_API_KEY ) [EOL] api_secret = config [ DOMAIN ] . get ( CONF_API_SECRET ) [EOL] exchange_currencies = config [ DOMAIN ] . get ( CONF_EXCHANGE_CURRENCIES ) [EOL] [EOL] hass . data [ DATA_COINBASE ] = coinbase_data = CoinbaseData ( api_key , api_secret ) [EOL] [EOL] if not hasattr ( coinbase_data , [string] ) : [EOL] return False [EOL] for account in coinbase_data . accounts . data : [EOL] load_platform ( hass , [string] , DOMAIN , { [string] : account } , config ) [EOL] for currency in exchange_currencies : [EOL] if currency not in coinbase_data . exchange_rates . rates : [EOL] _LOGGER . warning ( [string] , currency ) [EOL] continue [EOL] native = coinbase_data . exchange_rates . currency [EOL] load_platform ( hass , [string] , DOMAIN , { [string] : native , [string] : currency } , config ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class CoinbaseData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_key , api_secret ) : [EOL] [docstring] [EOL] from coinbase . wallet . client import Client [EOL] self . client = Client ( api_key , api_secret ) [EOL] self . update ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] from coinbase . wallet . error import AuthenticationError [EOL] try : [EOL] self . accounts = self . client . get_accounts ( ) [EOL] self . exchange_rates = self . client . get_exchange_rates ( ) [EOL] except AuthenticationError as coinbase_error : [EOL] _LOGGER . error ( [string] [string] , coinbase_error ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Tuple , Any , List [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_HS_COLOR , SUPPORT_BRIGHTNESS , SUPPORT_COLOR_TEMP , SUPPORT_COLOR , Light ) [EOL] from homeassistant . components . wink import DOMAIN , WinkDevice [EOL] from homeassistant . util import color as color_util [EOL] from homeassistant . util . color import color_temperature_mired_to_kelvin as mired_to_kelvin [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import pywink [EOL] [EOL] for light in pywink . get_light_bulbs ( ) : [EOL] _id = light . object_id ( ) + light . name ( ) [EOL] if _id not in hass . data [ DOMAIN ] [ [string] ] : [EOL] add_devices ( [ WinkLight ( light , hass ) ] ) [EOL] for light in pywink . get_light_groups ( ) : [EOL] _id = light . object_id ( ) + light . name ( ) [EOL] if _id not in hass . data [ DOMAIN ] [ [string] ] : [EOL] add_devices ( [ WinkLight ( light , hass ) ] ) [EOL] [EOL] [EOL] class WinkLight ( WinkDevice , Light ) : [EOL] [docstring] [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . data [ DOMAIN ] [ [string] ] [ [string] ] . append ( self ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . wink . state ( ) [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] if self . wink . brightness ( ) is not None : [EOL] return int ( self . wink . brightness ( ) * [number] ) [EOL] return None [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] if self . wink . supports_xy_color ( ) : [EOL] return color_util . color_xy_to_hs ( * self . wink . color_xy ( ) ) [EOL] [EOL] if self . wink . supports_hue_saturation ( ) : [EOL] hue = self . wink . color_hue ( ) [EOL] saturation = self . wink . color_saturation ( ) [EOL] if hue is not None and saturation is not None : [EOL] return hue * [number] , saturation * [number] [EOL] [EOL] return None [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] if not self . wink . supports_temperature ( ) : [EOL] return None [EOL] return color_util . color_temperature_kelvin_to_mired ( self . wink . color_temperature_kelvin ( ) ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] supports = SUPPORT_BRIGHTNESS [EOL] if self . wink . supports_temperature ( ) : [EOL] supports = supports | SUPPORT_COLOR_TEMP [EOL] if self . wink . supports_xy_color ( ) : [EOL] supports = supports | SUPPORT_COLOR [EOL] elif self . wink . supports_hue_saturation ( ) : [EOL] supports = supports | SUPPORT_COLOR [EOL] return supports [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] brightness = kwargs . get ( ATTR_BRIGHTNESS ) [EOL] hs_color = kwargs . get ( ATTR_HS_COLOR ) [EOL] color_temp_mired = kwargs . get ( ATTR_COLOR_TEMP ) [EOL] [EOL] state_kwargs = { } [EOL] [EOL] if hs_color : [EOL] if self . wink . supports_xy_color ( ) : [EOL] xy_color = color_util . color_hs_to_xy ( * hs_color ) [EOL] state_kwargs [ [string] ] = xy_color [EOL] if self . wink . supports_hue_saturation ( ) : [EOL] hs_scaled = hs_color [ [number] ] / [number] , hs_color [ [number] ] / [number] [EOL] state_kwargs [ [string] ] = hs_scaled [EOL] [EOL] if color_temp_mired : [EOL] state_kwargs [ [string] ] = mired_to_kelvin ( color_temp_mired ) [EOL] [EOL] if brightness : [EOL] state_kwargs [ [string] ] = brightness / [number] [EOL] [EOL] self . wink . set_state ( True , ** state_kwargs ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . wink . set_state ( False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , List , Tuple , Any , Literal [EOL] import logging [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from threading import Timer [EOL] from homeassistant . components . light import ( ATTR_WHITE_VALUE , ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_HS_COLOR , ATTR_TRANSITION , SUPPORT_BRIGHTNESS , SUPPORT_COLOR_TEMP , SUPPORT_COLOR , SUPPORT_TRANSITION , SUPPORT_WHITE_VALUE , DOMAIN , Light ) [EOL] from homeassistant . components import zwave [EOL] from homeassistant . components . zwave import async_setup_platform [comment] [EOL] from homeassistant . const import STATE_OFF , STATE_ON [EOL] import homeassistant . util . color as color_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] AEOTEC = [number] [EOL] AEOTEC_ZW098_LED_BULB = [number] [EOL] AEOTEC_ZW098_LED_BULB_LIGHT = ( AEOTEC , AEOTEC_ZW098_LED_BULB ) [EOL] [EOL] COLOR_CHANNEL_WARM_WHITE = [number] [EOL] COLOR_CHANNEL_COLD_WHITE = [number] [EOL] COLOR_CHANNEL_RED = [number] [EOL] COLOR_CHANNEL_GREEN = [number] [EOL] COLOR_CHANNEL_BLUE = [number] [EOL] [EOL] WORKAROUND_ZW098 = [string] [EOL] [EOL] DEVICE_MAPPINGS = { AEOTEC_ZW098_LED_BULB_LIGHT : WORKAROUND_ZW098 } [EOL] [EOL] [comment] [EOL] [comment] [EOL] TEMP_COLOR_MAX = [number] [comment] [EOL] TEMP_COLOR_MIN = [number] [EOL] TEMP_MID_HASS = ( TEMP_COLOR_MAX - TEMP_COLOR_MIN ) / [number] + TEMP_COLOR_MIN [EOL] TEMP_WARM_HASS = ( TEMP_COLOR_MAX - TEMP_COLOR_MIN ) / [number] * [number] + TEMP_COLOR_MIN [EOL] TEMP_COLD_HASS = ( TEMP_COLOR_MAX - TEMP_COLOR_MIN ) / [number] + TEMP_COLOR_MIN [EOL] [EOL] [EOL] def get_device ( node , values , node_config , ** kwargs ) : [EOL] [docstring] [EOL] refresh = node_config . get ( zwave . CONF_REFRESH_VALUE ) [EOL] delay = node_config . get ( zwave . CONF_REFRESH_DELAY ) [EOL] _LOGGER . debug ( [string] [string] , node . node_id , values . primary . value_id , node_config , refresh , delay ) [EOL] [EOL] if node . has_command_class ( zwave . const . COMMAND_CLASS_SWITCH_COLOR ) : [EOL] return ZwaveColorLight ( values , refresh , delay ) [EOL] return ZwaveDimmer ( values , refresh , delay ) [EOL] [EOL] [EOL] def brightness_state ( value ) : [EOL] [docstring] [EOL] if value . data > [number] : [EOL] return round ( ( value . data / [number] ) * [number] ) , STATE_ON [EOL] return [number] , STATE_OFF [EOL] [EOL] [EOL] def ct_to_hs ( temp ) : [EOL] [docstring] [EOL] colorlist = list ( color_util . color_temperature_to_hs ( color_util . color_temperature_mired_to_kelvin ( temp ) ) ) [EOL] return [ int ( val ) for val in colorlist ] [EOL] [EOL] [EOL] class ZwaveDimmer ( zwave . ZWaveDeviceEntity , Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , values , refresh , delay ) : [EOL] [docstring] [EOL] zwave . ZWaveDeviceEntity . __init__ ( self , values , DOMAIN ) [EOL] self . _brightness = None [EOL] self . _state = None [EOL] self . _supported_features = None [EOL] self . _delay = delay [EOL] self . _refresh_value = refresh [EOL] self . _zw098 = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( self . node . manufacturer_id . strip ( ) and self . node . product_id . strip ( ) ) : [EOL] specific_sensor_key = ( int ( self . node . manufacturer_id , [number] ) , int ( self . node . product_id , [number] ) ) [EOL] if specific_sensor_key in DEVICE_MAPPINGS : [EOL] if DEVICE_MAPPINGS [ specific_sensor_key ] == WORKAROUND_ZW098 : [EOL] _LOGGER . debug ( [string] ) [EOL] self . _zw098 = [number] [EOL] [EOL] [comment] [EOL] self . _refreshing = False [EOL] self . _timer = None [EOL] _LOGGER . debug ( [string] , self . _refresh_value , self . _delay ) [EOL] self . value_added ( ) [EOL] self . update_properties ( ) [EOL] [EOL] def update_properties ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _brightness , self . _state = brightness_state ( self . values . primary ) [EOL] [EOL] def value_added ( self ) : [EOL] [docstring] [EOL] self . _supported_features = SUPPORT_BRIGHTNESS [EOL] if self . values . dimming_duration is not None : [EOL] self . _supported_features |= SUPPORT_TRANSITION [EOL] [EOL] def value_changed ( self ) : [EOL] [docstring] [EOL] if self . _refresh_value : [EOL] if self . _refreshing : [EOL] self . _refreshing = False [EOL] else : [EOL] def _refresh_value ( ) : [EOL] [docstring] [EOL] self . _refreshing = True [EOL] self . values . primary . refresh ( ) [EOL] [EOL] if self . _timer is not None and self . _timer . isAlive ( ) : [EOL] self . _timer . cancel ( ) [EOL] [EOL] self . _timer = Timer ( self . _delay , _refresh_value ) [EOL] self . _timer . start ( ) [EOL] return [EOL] super ( ) . value_changed ( ) [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state == STATE_ON [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported_features [EOL] [EOL] def _set_duration ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . values . dimming_duration is None : [EOL] if ATTR_TRANSITION in kwargs : [EOL] _LOGGER . debug ( [string] , self . entity_id ) [EOL] return [EOL] [EOL] if ATTR_TRANSITION not in kwargs : [EOL] self . values . dimming_duration . data = [number] [EOL] return [EOL] [EOL] transition = kwargs [ ATTR_TRANSITION ] [EOL] if transition <= [number] : [EOL] self . values . dimming_duration . data = int ( transition ) [EOL] elif transition > [number] : [EOL] self . values . dimming_duration . data = [number] [EOL] _LOGGER . warning ( [string] , self . entity_id ) [EOL] else : [EOL] minutes = int ( transition / [number] ) [EOL] _LOGGER . debug ( [string] , minutes , self . entity_id ) [EOL] self . values . dimming_duration . data = minutes + [number] [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _set_duration ( ** kwargs ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . _brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] brightness = int ( ( self . _brightness / [number] ) * [number] ) [EOL] else : [EOL] brightness = [number] [EOL] [EOL] if self . node . set_dimmer ( self . values . primary . value_id , brightness ) : [EOL] self . _state = STATE_ON [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _set_duration ( ** kwargs ) [EOL] [EOL] if self . node . set_dimmer ( self . values . primary . value_id , [number] ) : [EOL] self . _state = STATE_OFF [EOL] [EOL] [EOL] class ZwaveColorLight ( ZwaveDimmer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , values , refresh , delay ) : [EOL] [docstring] [EOL] self . _color_channels = None [EOL] self . _hs = None [EOL] self . _ct = None [EOL] self . _white = None [EOL] [EOL] super ( ) . __init__ ( values , refresh , delay ) [EOL] [EOL] def value_added ( self ) : [EOL] [docstring] [EOL] super ( ) . value_added ( ) [EOL] [EOL] self . _supported_features |= SUPPORT_COLOR [EOL] if self . _zw098 : [EOL] self . _supported_features |= SUPPORT_COLOR_TEMP [EOL] elif self . _color_channels is not None and self . _color_channels & ( COLOR_CHANNEL_WARM_WHITE | COLOR_CHANNEL_COLD_WHITE ) : [EOL] self . _supported_features |= SUPPORT_WHITE_VALUE [EOL] [EOL] def update_properties ( self ) : [EOL] [docstring] [EOL] super ( ) . update_properties ( ) [EOL] [EOL] if self . values . color is None : [EOL] return [EOL] if self . values . color_channels is None : [EOL] return [EOL] [EOL] [comment] [EOL] self . _color_channels = self . values . color_channels . data [EOL] [EOL] [comment] [EOL] data = self . values . color . data [EOL] [EOL] [comment] [EOL] rgb = [ int ( data [ [number] : [number] ] , [number] ) , int ( data [ [number] : [number] ] , [number] ) , int ( data [ [number] : [number] ] , [number] ) ] [EOL] self . _hs = color_util . color_RGB_to_hs ( * rgb ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] index = [number] [EOL] [EOL] [comment] [EOL] if self . _color_channels & COLOR_CHANNEL_WARM_WHITE : [EOL] warm_white = int ( data [ index : index + [number] ] , [number] ) [EOL] index += [number] [EOL] else : [EOL] warm_white = [number] [EOL] [EOL] [comment] [EOL] if self . _color_channels & COLOR_CHANNEL_COLD_WHITE : [EOL] cold_white = int ( data [ index : index + [number] ] , [number] ) [EOL] index += [number] [EOL] else : [EOL] cold_white = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . _zw098 : [EOL] if warm_white > [number] : [EOL] self . _ct = TEMP_WARM_HASS [EOL] self . _hs = ct_to_hs ( self . _ct ) [EOL] elif cold_white > [number] : [EOL] self . _ct = TEMP_COLD_HASS [EOL] self . _hs = ct_to_hs ( self . _ct ) [EOL] else : [EOL] [comment] [EOL] self . _ct = TEMP_MID_HASS [EOL] [EOL] elif self . _color_channels & COLOR_CHANNEL_WARM_WHITE : [EOL] self . _white = warm_white [EOL] [EOL] elif self . _color_channels & COLOR_CHANNEL_COLD_WHITE : [EOL] self . _white = cold_white [EOL] [EOL] [comment] [EOL] if not ( self . _color_channels & COLOR_CHANNEL_RED or self . _color_channels & COLOR_CHANNEL_GREEN or self . _color_channels & COLOR_CHANNEL_BLUE ) : [EOL] self . _hs = None [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return self . _hs [EOL] [EOL] @ property def white_value ( self ) : [EOL] [docstring] [EOL] return self . _white [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] return self . _ct [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] rgbw = None [EOL] [EOL] if ATTR_WHITE_VALUE in kwargs : [EOL] self . _white = kwargs [ ATTR_WHITE_VALUE ] [EOL] [EOL] if ATTR_COLOR_TEMP in kwargs : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . _zw098 : [EOL] if kwargs [ ATTR_COLOR_TEMP ] > TEMP_MID_HASS : [EOL] self . _ct = TEMP_WARM_HASS [EOL] rgbw = [string] [EOL] else : [EOL] self . _ct = TEMP_COLD_HASS [EOL] rgbw = [string] [EOL] elif ATTR_HS_COLOR in kwargs : [EOL] self . _hs = kwargs [ ATTR_HS_COLOR ] [EOL] if ATTR_WHITE_VALUE not in kwargs : [EOL] [comment] [EOL] self . _white = [number] [EOL] [EOL] if ATTR_WHITE_VALUE in kwargs or ATTR_HS_COLOR in kwargs : [EOL] rgbw = [string] [EOL] for colorval in color_util . color_hs_to_RGB ( * self . _hs ) : [EOL] rgbw += format ( colorval , [string] ) [EOL] if self . _white is not None : [EOL] rgbw += format ( self . _white , [string] ) + [string] [EOL] else : [EOL] rgbw += [string] [EOL] [EOL] if rgbw and self . values . color : [EOL] self . values . color . data = rgbw [EOL] [EOL] super ( ) . turn_on ( ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Tuple[builtins.int,builtins.int],builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Dict[typing.Tuple[builtins.int,builtins.int],builtins.str]$ 0 0 0 $typing.Dict[typing.Tuple[builtins.int,builtins.int],builtins.str]$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . event import track_point_in_utc_time [EOL] from homeassistant . components . device_tracker import ( YAML_DEVICES , CONF_TRACK_NEW , CONF_SCAN_INTERVAL , DEFAULT_SCAN_INTERVAL , load_config , PLATFORM_SCHEMA , DEFAULT_TRACK_NEW , SOURCE_TYPE_BLUETOOTH ) [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] REQUIREMENTS = [ [string] , [string] ] [EOL] [EOL] BT_PREFIX = [string] [EOL] [EOL] CONF_REQUEST_RSSI = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_TRACK_NEW ) : cv . boolean , vol . Optional ( CONF_REQUEST_RSSI ) : cv . boolean } ) [EOL] [EOL] [EOL] def setup_scanner ( hass , config , see , discovery_info = None ) : [EOL] [docstring] [EOL] [comment] [EOL] import bluetooth [EOL] from bt_proximity import BluetoothRSSI [EOL] [EOL] def see_device ( mac , name , rssi = None ) : [EOL] [docstring] [EOL] attributes = { } [EOL] if rssi is not None : [EOL] attributes [ [string] ] = rssi [EOL] see ( mac = [string] . format ( BT_PREFIX , mac ) , host_name = name , attributes = attributes , source_type = SOURCE_TYPE_BLUETOOTH ) [EOL] [EOL] def discover_devices ( ) : [EOL] [docstring] [EOL] result = bluetooth . discover_devices ( duration = [number] , lookup_names = True , flush_cache = True , lookup_class = False ) [EOL] _LOGGER . debug ( [string] , len ( result ) ) [EOL] return result [EOL] [EOL] yaml_path = hass . config . path ( YAML_DEVICES ) [EOL] devs_to_track = [ ] [EOL] devs_donot_track = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for device in load_config ( yaml_path , hass , [number] ) : [EOL] [comment] [EOL] if device . mac and device . mac [ : [number] ] . upper ( ) == BT_PREFIX : [EOL] if device . track : [EOL] devs_to_track . append ( device . mac [ [number] : ] ) [EOL] else : [EOL] devs_donot_track . append ( device . mac [ [number] : ] ) [EOL] [EOL] [comment] [EOL] track_new = config . get ( CONF_TRACK_NEW , DEFAULT_TRACK_NEW ) [EOL] if track_new : [EOL] for dev in discover_devices ( ) : [EOL] if dev [ [number] ] not in devs_to_track and dev [ [number] ] not in devs_donot_track : [EOL] devs_to_track . append ( dev [ [number] ] ) [EOL] see_device ( dev [ [number] ] , dev [ [number] ] ) [EOL] [EOL] interval = config . get ( CONF_SCAN_INTERVAL , DEFAULT_SCAN_INTERVAL ) [EOL] [EOL] request_rssi = config . get ( CONF_REQUEST_RSSI , False ) [EOL] [EOL] def update_bluetooth ( now ) : [EOL] [docstring] [EOL] try : [EOL] if track_new : [EOL] for dev in discover_devices ( ) : [EOL] if dev [ [number] ] not in devs_to_track and dev [ [number] ] not in devs_donot_track : [EOL] devs_to_track . append ( dev [ [number] ] ) [EOL] for mac in devs_to_track : [EOL] _LOGGER . debug ( [string] , mac ) [EOL] result = bluetooth . lookup_name ( mac , timeout = [number] ) [EOL] rssi = None [EOL] if request_rssi : [EOL] rssi = BluetoothRSSI ( mac ) . request_rssi ( ) [EOL] if result is None : [EOL] [comment] [EOL] continue [EOL] see_device ( mac , result , rssi ) [EOL] except bluetooth . BluetoothError : [EOL] _LOGGER . exception ( [string] ) [EOL] track_point_in_utc_time ( hass , update_bluetooth , dt_util . utcnow ( ) + interval ) [EOL] [EOL] update_bluetooth ( dt_util . utcnow ( ) ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . device_tracker import ( DOMAIN , PLATFORM_SCHEMA , DeviceScanner ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_USERNAME , CONF_PORT ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] MTK_DEFAULT_API_PORT = [string] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_PORT , default = MTK_DEFAULT_API_PORT ) : cv . port } ) [EOL] [EOL] [EOL] def get_scanner ( hass , config ) : [EOL] [docstring] [EOL] scanner = MikrotikScanner ( config [ DOMAIN ] ) [EOL] return scanner if scanner . success_init else None [EOL] [EOL] [EOL] class MikrotikScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] self . last_results = { } [EOL] [EOL] self . host = config [ CONF_HOST ] [EOL] self . port = config [ CONF_PORT ] [EOL] self . username = config [ CONF_USERNAME ] [EOL] self . password = config [ CONF_PASSWORD ] [EOL] [EOL] self . connected = False [EOL] self . success_init = False [EOL] self . client = None [EOL] self . wireless_exist = None [EOL] self . success_init = self . connect_to_device ( ) [EOL] [EOL] if self . success_init : [EOL] _LOGGER . info ( [string] , self . host ) [EOL] self . _update_info ( ) [EOL] else : [EOL] _LOGGER . error ( [string] , self . host ) [EOL] [EOL] def connect_to_device ( self ) : [EOL] [docstring] [EOL] import librouteros [EOL] try : [EOL] self . client = librouteros . connect ( self . host , self . username , self . password , port = int ( self . port ) , encoding = [string] ) [EOL] [EOL] try : [EOL] routerboard_info = self . client ( cmd = [string] ) [EOL] except ( librouteros . exceptions . TrapError , librouteros . exceptions . MultiTrapError , librouteros . exceptions . ConnectionError ) : [EOL] routerboard_info = None [EOL] raise [EOL] [EOL] if routerboard_info : [EOL] _LOGGER . info ( [string] , routerboard_info [ [number] ] . get ( [string] , [string] ) , self . host ) [EOL] [EOL] self . connected = True [EOL] [EOL] try : [EOL] self . capsman_exist = self . client ( cmd = [string] ) [EOL] except ( librouteros . exceptions . TrapError , librouteros . exceptions . MultiTrapError , librouteros . exceptions . ConnectionError ) : [EOL] self . capsman_exist = False [EOL] [EOL] if not self . capsman_exist : [EOL] _LOGGER . info ( [string] [string] , self . host ) [EOL] [EOL] try : [EOL] self . wireless_exist = self . client ( cmd = [string] ) [EOL] except ( librouteros . exceptions . TrapError , librouteros . exceptions . MultiTrapError , librouteros . exceptions . ConnectionError ) : [EOL] self . wireless_exist = False [EOL] [EOL] if not self . wireless_exist : [EOL] _LOGGER . info ( [string] [string] [string] , self . host ) [EOL] [EOL] except ( librouteros . exceptions . TrapError , librouteros . exceptions . MultiTrapError , librouteros . exceptions . ConnectionError ) as api_error : [EOL] _LOGGER . error ( [string] , api_error ) [EOL] [EOL] return self . connected [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return [ device for device in self . last_results ] [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return self . last_results . get ( device ) [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] if self . capsman_exist : [EOL] devices_tracker = [string] [EOL] elif self . wireless_exist : [EOL] devices_tracker = [string] [EOL] else : [EOL] devices_tracker = [string] [EOL] [EOL] _LOGGER . info ( [string] , devices_tracker , self . host ) [EOL] [EOL] device_names = self . client ( cmd = [string] ) [EOL] if devices_tracker == [string] : [EOL] devices = self . client ( cmd = [string] ) [EOL] elif devices_tracker == [string] : [EOL] devices = self . client ( cmd = [string] ) [EOL] else : [EOL] devices = device_names [EOL] [EOL] if device_names is None and devices is None : [EOL] return False [EOL] [EOL] mac_names = { device . get ( [string] ) : device . get ( [string] ) for device in device_names if device . get ( [string] ) } [EOL] [EOL] if self . wireless_exist or self . capsman_exist : [EOL] self . last_results = { device . get ( [string] ) : mac_names . get ( device . get ( [string] ) ) for device in devices } [EOL] else : [EOL] self . last_results = { device . get ( [string] ) : mac_names . get ( device . get ( [string] ) ) for device in device_names if device . get ( [string] ) } [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 $logging.Logger$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . vacuum import ( ATTR_CLEANED_AREA , SUPPORT_BATTERY , SUPPORT_CLEAN_SPOT , SUPPORT_FAN_SPEED , SUPPORT_LOCATE , SUPPORT_PAUSE , SUPPORT_RETURN_HOME , SUPPORT_SEND_COMMAND , SUPPORT_STATUS , SUPPORT_STOP , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , VacuumDevice ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_MINIMAL_SERVICES = SUPPORT_TURN_ON | SUPPORT_TURN_OFF [EOL] [EOL] SUPPORT_BASIC_SERVICES = SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_STATUS | SUPPORT_BATTERY [EOL] [EOL] SUPPORT_MOST_SERVICES = SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_STOP | SUPPORT_RETURN_HOME | SUPPORT_STATUS | SUPPORT_BATTERY [EOL] [EOL] SUPPORT_ALL_SERVICES = SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_PAUSE | SUPPORT_STOP | SUPPORT_RETURN_HOME | SUPPORT_FAN_SPEED | SUPPORT_SEND_COMMAND | SUPPORT_LOCATE | SUPPORT_STATUS | SUPPORT_BATTERY | SUPPORT_CLEAN_SPOT [EOL] [EOL] FAN_SPEEDS = [ [string] , [string] , [string] , [string] ] [EOL] DEMO_VACUUM_COMPLETE = [string] [EOL] DEMO_VACUUM_MOST = [string] [EOL] DEMO_VACUUM_BASIC = [string] [EOL] DEMO_VACUUM_MINIMAL = [string] [EOL] DEMO_VACUUM_NONE = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] add_devices ( [ DemoVacuum ( DEMO_VACUUM_COMPLETE , SUPPORT_ALL_SERVICES ) , DemoVacuum ( DEMO_VACUUM_MOST , SUPPORT_MOST_SERVICES ) , DemoVacuum ( DEMO_VACUUM_BASIC , SUPPORT_BASIC_SERVICES ) , DemoVacuum ( DEMO_VACUUM_MINIMAL , SUPPORT_MINIMAL_SERVICES ) , DemoVacuum ( DEMO_VACUUM_NONE , [number] ) , ] ) [EOL] [EOL] [EOL] class DemoVacuum ( VacuumDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , supported_features ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _supported_features = supported_features [EOL] self . _state = False [EOL] self . _status = [string] [EOL] self . _fan_speed = FAN_SPEEDS [ [number] ] [EOL] self . _cleaned_area = [number] [EOL] self . _battery_level = [number] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def status ( self ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_STATUS == [number] : [EOL] return [EOL] [EOL] return self . _status [EOL] [EOL] @ property def fan_speed ( self ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_FAN_SPEED == [number] : [EOL] return [EOL] [EOL] return self . _fan_speed [EOL] [EOL] @ property def fan_speed_list ( self ) : [EOL] [docstring] [EOL] assert self . supported_features & SUPPORT_FAN_SPEED != [number] [EOL] return FAN_SPEEDS [EOL] [EOL] @ property def battery_level ( self ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_BATTERY == [number] : [EOL] return [EOL] [EOL] return max ( [number] , min ( [number] , self . _battery_level ) ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_CLEANED_AREA : round ( self . _cleaned_area , [number] ) } [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported_features [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_TURN_ON == [number] : [EOL] return [EOL] [EOL] self . _state = True [EOL] self . _cleaned_area += [number] [EOL] self . _battery_level -= [number] [EOL] self . _status = [string] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_TURN_OFF == [number] : [EOL] return [EOL] [EOL] self . _state = False [EOL] self . _status = [string] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def stop ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_STOP == [number] : [EOL] return [EOL] [EOL] self . _state = False [EOL] self . _status = [string] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def clean_spot ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_CLEAN_SPOT == [number] : [EOL] return [EOL] [EOL] self . _state = True [EOL] self . _cleaned_area += [number] [EOL] self . _battery_level -= [number] [EOL] self . _status = [string] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def locate ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_LOCATE == [number] : [EOL] return [EOL] [EOL] self . _status = [string] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def start_pause ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_PAUSE == [number] : [EOL] return [EOL] [EOL] self . _state = not self . _state [EOL] if self . _state : [EOL] self . _status = [string] [EOL] self . _cleaned_area += [number] [EOL] self . _battery_level -= [number] [EOL] else : [EOL] self . _status = [string] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def set_fan_speed ( self , fan_speed , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_FAN_SPEED == [number] : [EOL] return [EOL] [EOL] if fan_speed in self . fan_speed_list : [EOL] self . _fan_speed = fan_speed [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def return_to_base ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_RETURN_HOME == [number] : [EOL] return [EOL] [EOL] self . _state = False [EOL] self . _status = [string] [EOL] self . _battery_level += [number] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def send_command ( self , command , params = None , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_SEND_COMMAND == [number] : [EOL] return [EOL] [EOL] self . _status = [string] . format ( command , params ) [EOL] self . _state = True [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import telnetlib [EOL] [docstring] [EOL] import logging [EOL] import telnetlib [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( PLATFORM_SCHEMA , SUPPORT_NEXT_TRACK , SUPPORT_SELECT_SOURCE , SUPPORT_PAUSE , SUPPORT_PREVIOUS_TRACK , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_STOP , SUPPORT_PLAY , MediaPlayerDevice ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , STATE_OFF , STATE_ON , STATE_UNKNOWN ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] SUPPORT_DENON = SUPPORT_VOLUME_SET | SUPPORT_VOLUME_MUTE | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE \ [EOL] [EOL] SUPPORT_MEDIA_MODES = SUPPORT_PAUSE | SUPPORT_STOP | SUPPORT_PREVIOUS_TRACK | SUPPORT_NEXT_TRACK | SUPPORT_PLAY [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] NORMAL_INPUTS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] MEDIA_MODES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] denon = DenonDevice ( config . get ( CONF_NAME ) , config . get ( CONF_HOST ) ) [EOL] [EOL] if denon . update ( ) : [EOL] add_devices ( [ denon ] ) [EOL] [EOL] [EOL] class DenonDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , host ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _host = host [EOL] self . _pwstate = [string] [EOL] self . _volume = [number] [EOL] [comment] [EOL] self . _volume_max = [number] [EOL] self . _source_list = NORMAL_INPUTS . copy ( ) [EOL] self . _source_list . update ( MEDIA_MODES ) [EOL] self . _muted = False [EOL] self . _mediasource = [string] [EOL] self . _mediainfo = [string] [EOL] [EOL] self . _should_setup_sources = True [EOL] [EOL] def _setup_sources ( self , telnet ) : [EOL] [comment] [EOL] nsfrn = self . telnet_request ( telnet , [string] ) [ len ( [string] ) : ] [EOL] if nsfrn : [EOL] self . _name = nsfrn [EOL] [EOL] [comment] [EOL] self . _source_list = { } [EOL] for line in self . telnet_request ( telnet , [string] , all_lines = True ) : [EOL] source , configured_name = line [ len ( [string] ) : ] . split ( [string] , [number] ) [EOL] self . _source_list [ configured_name ] = source [EOL] [EOL] [comment] [EOL] for line in self . telnet_request ( telnet , [string] , all_lines = True ) : [EOL] source , status = line [ len ( [string] ) : ] . split ( [string] , [number] ) [EOL] if status == [string] : [EOL] for pretty_name , name in self . _source_list . items ( ) : [EOL] if source == name : [EOL] del self . _source_list [ pretty_name ] [EOL] break [EOL] [EOL] @ classmethod def telnet_request ( cls , telnet , command , all_lines = False ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , command ) [EOL] telnet . write ( command . encode ( [string] ) + [string] ) [EOL] lines = [ ] [EOL] while True : [EOL] line = telnet . read_until ( [string] , timeout = [number] ) [EOL] if not line : [EOL] break [EOL] lines . append ( line . decode ( [string] ) . strip ( ) ) [EOL] _LOGGER . debug ( [string] , line ) [EOL] [EOL] if all_lines : [EOL] return lines [EOL] return lines [ [number] ] if lines else [string] [EOL] [EOL] def telnet_command ( self , command ) : [EOL] [docstring] [EOL] telnet = telnetlib . Telnet ( self . _host ) [EOL] _LOGGER . debug ( [string] , command ) [EOL] telnet . write ( command . encode ( [string] ) + [string] ) [EOL] telnet . read_very_eager ( ) [comment] [EOL] telnet . close ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] telnet = telnetlib . Telnet ( self . _host ) [EOL] except OSError : [EOL] return False [EOL] [EOL] if self . _should_setup_sources : [EOL] self . _setup_sources ( telnet ) [EOL] self . _should_setup_sources = False [EOL] [EOL] self . _pwstate = self . telnet_request ( telnet , [string] ) [EOL] for line in self . telnet_request ( telnet , [string] , all_lines = True ) : [EOL] if line . startswith ( [string] ) : [EOL] [comment] [EOL] self . _volume_max = int ( line [ len ( [string] ) : len ( [string] ) ] ) [EOL] continue [EOL] if line . startswith ( [string] ) : [EOL] self . _volume = int ( line [ len ( [string] ) : ] ) [EOL] self . _muted = ( self . telnet_request ( telnet , [string] ) == [string] ) [EOL] self . _mediasource = self . telnet_request ( telnet , [string] ) [ len ( [string] ) : ] [EOL] [EOL] if self . _mediasource in MEDIA_MODES . values ( ) : [EOL] self . _mediainfo = [string] [EOL] answer_codes = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] for line in self . telnet_request ( telnet , [string] , all_lines = True ) : [EOL] self . _mediainfo += line [ len ( answer_codes . pop ( [number] ) ) : ] + [string] [EOL] else : [EOL] self . _mediainfo = self . source [EOL] [EOL] telnet . close ( ) [EOL] return True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _pwstate == [string] : [EOL] return STATE_OFF [EOL] if self . _pwstate == [string] : [EOL] return STATE_ON [EOL] [EOL] return STATE_UNKNOWN [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume / self . _volume_max [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _muted [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return sorted ( list ( self . _source_list . keys ( ) ) ) [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _mediainfo [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] if self . _mediasource in MEDIA_MODES . values ( ) : [EOL] return SUPPORT_DENON | SUPPORT_MEDIA_MODES [EOL] return SUPPORT_DENON [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] for pretty_name , name in self . _source_list . items ( ) : [EOL] if self . _mediasource == name : [EOL] return pretty_name [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] + str ( round ( volume * self . _volume_max ) ) . zfill ( [number] ) ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] + ( [string] if mute else [string] ) ) [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def media_stop ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] + self . _source_list . get ( source ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from homeassistant . components . lock import LockDevice , SUPPORT_OPEN [EOL] from homeassistant . components . homematic import HMDevice , ATTR_DISCOVER_DEVICES [EOL] from homeassistant . const import STATE_UNKNOWN [EOL] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] devices = [ ] [EOL] for conf in discovery_info [ ATTR_DISCOVER_DEVICES ] : [EOL] devices . append ( HMLock ( conf ) ) [EOL] [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class HMLock ( HMDevice , LockDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_locked ( self ) : [EOL] [docstring] [EOL] return not bool ( self . _hm_get_state ( ) ) [EOL] [EOL] def lock ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _hmdevice . lock ( ) [EOL] [EOL] def unlock ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _hmdevice . unlock ( ) [EOL] [EOL] def open ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _hmdevice . open ( ) [EOL] [EOL] def _init_data_struct ( self ) : [EOL] [docstring] [EOL] self . _state = [string] [EOL] self . _data . update ( { self . _state : STATE_UNKNOWN } ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_OPEN [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ATTR_ENTITY_ID , CONF_ICON , CONF_NAME [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . restore_state import async_get_last_state [EOL] from homeassistant . loader import bind_hass [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_INITIAL = [string] [EOL] ATTR_STEP = [string] [EOL] [EOL] CONF_INITIAL = [string] [EOL] CONF_STEP = [string] [EOL] [EOL] DEFAULT_INITIAL = [number] [EOL] DEFAULT_STEP = [number] [EOL] DOMAIN = [string] [EOL] [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] SERVICE_DECREMENT = [string] [EOL] SERVICE_INCREMENT = [string] [EOL] SERVICE_RESET = [string] [EOL] [EOL] SERVICE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { cv . slug : vol . Any ( { vol . Optional ( CONF_ICON ) : cv . icon , vol . Optional ( CONF_INITIAL , default = DEFAULT_INITIAL ) : cv . positive_int , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_STEP , default = DEFAULT_STEP ) : cv . positive_int , } , None ) } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ bind_hass def increment ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . add_job ( async_increment , hass , entity_id ) [EOL] [EOL] [EOL] @ callback @ bind_hass def async_increment ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_INCREMENT , { ATTR_ENTITY_ID : entity_id } ) ) [EOL] [EOL] [EOL] @ bind_hass def decrement ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . add_job ( async_decrement , hass , entity_id ) [EOL] [EOL] [EOL] @ callback @ bind_hass def async_decrement ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_DECREMENT , { ATTR_ENTITY_ID : entity_id } ) ) [EOL] [EOL] [EOL] @ bind_hass def reset ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . add_job ( async_reset , hass , entity_id ) [EOL] [EOL] [EOL] @ callback @ bind_hass def async_reset ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_RESET , { ATTR_ENTITY_ID : entity_id } ) ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass ) [EOL] [EOL] entities = [ ] [EOL] [EOL] for object_id , cfg in config [ DOMAIN ] . items ( ) : [EOL] if not cfg : [EOL] cfg = { } [EOL] [EOL] name = cfg . get ( CONF_NAME ) [EOL] initial = cfg . get ( CONF_INITIAL ) [EOL] step = cfg . get ( CONF_STEP ) [EOL] icon = cfg . get ( CONF_ICON ) [EOL] [EOL] entities . append ( Counter ( object_id , name , initial , step , icon ) ) [EOL] [EOL] if not entities : [EOL] return False [EOL] [EOL] async def async_handler_service ( service ) : [EOL] [docstring] [EOL] target_counters = component . async_extract_from_service ( service ) [EOL] [EOL] if service . service == SERVICE_INCREMENT : [EOL] attr = [string] [EOL] elif service . service == SERVICE_DECREMENT : [EOL] attr = [string] [EOL] elif service . service == SERVICE_RESET : [EOL] attr = [string] [EOL] [EOL] tasks = [ getattr ( counter , attr ) ( ) for counter in target_counters ] [EOL] if tasks : [EOL] await asyncio . wait ( tasks , loop = hass . loop ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_INCREMENT , async_handler_service ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_DECREMENT , async_handler_service ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_RESET , async_handler_service ) [EOL] [EOL] await component . async_add_entities ( entities ) [EOL] return True [EOL] [EOL] [EOL] class Counter ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , object_id , name , initial , step , icon ) : [EOL] [docstring] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( object_id ) [EOL] self . _name = name [EOL] self . _step = step [EOL] self . _state = self . _initial = initial [EOL] self . _icon = icon [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_INITIAL : self . _initial , ATTR_STEP : self . _step , } [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _state is not None : [EOL] return [EOL] [EOL] state = await async_get_last_state ( self . hass , self . entity_id ) [EOL] self . _state = state and state . state == state [EOL] [EOL] async def async_decrement ( self ) : [EOL] [docstring] [EOL] self . _state -= self . _step [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] async def async_increment ( self ) : [EOL] [docstring] [EOL] self . _state += self . _step [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] async def async_reset ( self ) : [EOL] [docstring] [EOL] self . _state = self . _initial [EOL] await self . async_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import logging [EOL] import typing [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] from homeassistant . const import STATE_UNKNOWN [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] from homeassistant . components . homematic import HMDevice , ATTR_DISCOVER_DEVICES [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SENSOR_TYPES_CLASS = { [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : None , [string] : None , [string] : [string] , } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] devices = [ ] [EOL] for conf in discovery_info [ ATTR_DISCOVER_DEVICES ] : [EOL] new_device = HMBinarySensor ( conf ) [EOL] devices . append ( new_device ) [EOL] [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class HMBinarySensor ( HMDevice , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] if not self . available : [EOL] return False [EOL] return bool ( self . _hm_get_state ( ) ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _state == [string] : [EOL] return [string] [EOL] return SENSOR_TYPES_CLASS . get ( self . _hmdevice . __class__ . __name__ , None ) [EOL] [EOL] def _init_data_struct ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _state : [EOL] self . _data . update ( { self . _state : STATE_UNKNOWN } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] from homeassistant . components . ring import ( CONF_ATTRIBUTION , DEFAULT_ENTITY_NAMESPACE , DATA_RING ) [EOL] [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_ENTITY_NAMESPACE , CONF_MONITORED_CONDITIONS ) [EOL] [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] [comment] [EOL] SENSOR_TYPES = { [string] : [ [string] , [ [string] ] , [string] ] , [string] : [ [string] , [ [string] , [string] ] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_ENTITY_NAMESPACE , default = DEFAULT_ENTITY_NAMESPACE ) : cv . string , vol . Required ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] ring = hass . data [ DATA_RING ] [EOL] [EOL] sensors = [ ] [EOL] for sensor_type in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] for device in ring . doorbells : [EOL] if [string] in SENSOR_TYPES [ sensor_type ] [ [number] ] : [EOL] sensors . append ( RingBinarySensor ( hass , device , sensor_type ) ) [EOL] [EOL] for device in ring . stickup_cams : [EOL] if [string] in SENSOR_TYPES [ sensor_type ] [ [number] ] : [EOL] sensors . append ( RingBinarySensor ( hass , device , sensor_type ) ) [EOL] add_devices ( sensors , True ) [EOL] return True [EOL] [EOL] [EOL] class RingBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , data , sensor_type ) : [EOL] [docstring] [EOL] super ( RingBinarySensor , self ) . __init__ ( ) [EOL] self . _sensor_type = sensor_type [EOL] self . _data = data [EOL] self . _name = [string] . format ( self . _data . name , SENSOR_TYPES . get ( self . _sensor_type ) [ [number] ] ) [EOL] self . _device_class = SENSOR_TYPES . get ( self . _sensor_type ) [ [number] ] [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { } [EOL] attrs [ ATTR_ATTRIBUTION ] = CONF_ATTRIBUTION [EOL] [EOL] attrs [ [string] ] = self . _data . id [EOL] attrs [ [string] ] = self . _data . firmware [EOL] attrs [ [string] ] = self . _data . timezone [EOL] [EOL] if self . _data . alert and self . _data . alert_expires_at : [EOL] attrs [ [string] ] = self . _data . alert_expires_at [EOL] attrs [ [string] ] = self . _data . alert . get ( [string] ) [EOL] [EOL] return attrs [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _data . check_alerts ( ) [EOL] [EOL] if self . _data . alert : [EOL] if self . _sensor_type == self . _data . alert . get ( [string] ) and self . _data . account_id == self . _data . alert . get ( [string] ) : [EOL] self . _state = True [EOL] else : [EOL] self . _state = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , DEVICE_CLASSES_SCHEMA , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . sensor . command_line import CommandSensorData [EOL] from homeassistant . const import ( CONF_PAYLOAD_OFF , CONF_PAYLOAD_ON , CONF_NAME , CONF_VALUE_TEMPLATE , CONF_COMMAND , CONF_DEVICE_CLASS ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PAYLOAD_ON = [string] [EOL] DEFAULT_PAYLOAD_OFF = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] CONF_COMMAND_TIMEOUT = [string] [EOL] DEFAULT_TIMEOUT = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_COMMAND ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PAYLOAD_OFF , default = DEFAULT_PAYLOAD_OFF ) : cv . string , vol . Optional ( CONF_PAYLOAD_ON , default = DEFAULT_PAYLOAD_ON ) : cv . string , vol . Optional ( CONF_DEVICE_CLASS ) : DEVICE_CLASSES_SCHEMA , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_COMMAND_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] command = config . get ( CONF_COMMAND ) [EOL] payload_off = config . get ( CONF_PAYLOAD_OFF ) [EOL] payload_on = config . get ( CONF_PAYLOAD_ON ) [EOL] device_class = config . get ( CONF_DEVICE_CLASS ) [EOL] value_template = config . get ( CONF_VALUE_TEMPLATE ) [EOL] command_timeout = config . get ( CONF_COMMAND_TIMEOUT ) [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] data = CommandSensorData ( hass , command , command_timeout ) [EOL] [EOL] add_devices ( [ CommandBinarySensor ( hass , data , name , device_class , payload_on , payload_off , value_template ) ] , True ) [EOL] [EOL] [EOL] class CommandBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , data , name , device_class , payload_on , payload_off , value_template ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . data = data [EOL] self . _name = name [EOL] self . _device_class = device_class [EOL] self . _state = False [EOL] self . _payload_on = payload_on [EOL] self . _payload_off = payload_off [EOL] self . _value_template = value_template [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] value = self . data . value [EOL] [EOL] if self . _value_template is not None : [EOL] value = self . _value_template . render_with_possible_json_value ( value , False ) [EOL] if value == self . _payload_on : [EOL] self . _state = True [EOL] elif value == self . _payload_off : [EOL] self . _state = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] import functools as ft [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . loader import bind_hass [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( STATE_ON , SERVICE_TURN_ON , SERVICE_TURN_OFF , SERVICE_TOGGLE , ATTR_ENTITY_ID ) [EOL] from homeassistant . components import group [EOL] from homeassistant . helpers . config_validation import PLATFORM_SCHEMA [comment] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_ACTIVITY = [string] [EOL] ATTR_COMMAND = [string] [EOL] ATTR_DEVICE = [string] [EOL] ATTR_NUM_REPEATS = [string] [EOL] ATTR_DELAY_SECS = [string] [EOL] [EOL] DOMAIN = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] ENTITY_ID_ALL_REMOTES = group . ENTITY_ID_FORMAT . format ( [string] ) [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] GROUP_NAME_ALL_REMOTES = [string] [EOL] [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] SERVICE_SEND_COMMAND = [string] [EOL] SERVICE_SYNC = [string] [EOL] [EOL] DEFAULT_NUM_REPEATS = [number] [EOL] DEFAULT_DELAY_SECS = [number] [EOL] [EOL] REMOTE_SERVICE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] REMOTE_SERVICE_ACTIVITY_SCHEMA = REMOTE_SERVICE_SCHEMA . extend ( { vol . Optional ( ATTR_ACTIVITY ) : cv . string } ) [EOL] [EOL] REMOTE_SERVICE_SEND_COMMAND_SCHEMA = REMOTE_SERVICE_SCHEMA . extend ( { vol . Required ( ATTR_COMMAND ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( ATTR_DEVICE ) : cv . string , vol . Optional ( ATTR_NUM_REPEATS , default = DEFAULT_NUM_REPEATS ) : cv . positive_int , vol . Optional ( ATTR_DELAY_SECS ) : vol . Coerce ( float ) , } ) [EOL] [EOL] [EOL] @ bind_hass def is_on ( hass , entity_id = None ) : [EOL] [docstring] [EOL] entity_id = entity_id or ENTITY_ID_ALL_REMOTES [EOL] return hass . states . is_state ( entity_id , STATE_ON ) [EOL] [EOL] [EOL] @ bind_hass def turn_on ( hass , activity = None , entity_id = None ) : [EOL] [docstring] [EOL] data = { key : value for key , value in [ ( ATTR_ACTIVITY , activity ) , ( ATTR_ENTITY_ID , entity_id ) , ] if value is not None } [EOL] hass . services . call ( DOMAIN , SERVICE_TURN_ON , data ) [EOL] [EOL] [EOL] @ bind_hass def turn_off ( hass , activity = None , entity_id = None ) : [EOL] [docstring] [EOL] data = { } [EOL] if activity : [EOL] data [ ATTR_ACTIVITY ] = activity [EOL] [EOL] if entity_id : [EOL] data [ ATTR_ENTITY_ID ] = entity_id [EOL] [EOL] hass . services . call ( DOMAIN , SERVICE_TURN_OFF , data ) [EOL] [EOL] [EOL] @ bind_hass def toggle ( hass , activity = None , entity_id = None ) : [EOL] [docstring] [EOL] data = { } [EOL] if activity : [EOL] data [ ATTR_ACTIVITY ] = activity [EOL] [EOL] if entity_id : [EOL] data [ ATTR_ENTITY_ID ] = entity_id [EOL] [EOL] hass . services . call ( DOMAIN , SERVICE_TOGGLE , data ) [EOL] [EOL] [EOL] @ bind_hass def send_command ( hass , command , entity_id = None , device = None , num_repeats = None , delay_secs = None ) : [EOL] [docstring] [EOL] data = { ATTR_COMMAND : command } [EOL] if entity_id : [EOL] data [ ATTR_ENTITY_ID ] = entity_id [EOL] [EOL] if device : [EOL] data [ ATTR_DEVICE ] = device [EOL] [EOL] if num_repeats : [EOL] data [ ATTR_NUM_REPEATS ] = num_repeats [EOL] [EOL] if delay_secs : [EOL] data [ ATTR_DELAY_SECS ] = delay_secs [EOL] [EOL] hass . services . call ( DOMAIN , SERVICE_SEND_COMMAND , data ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass , SCAN_INTERVAL , GROUP_NAME_ALL_REMOTES ) [EOL] yield from component . async_setup ( config ) [EOL] [EOL] @ asyncio . coroutine def async_handle_remote_service ( service ) : [EOL] [docstring] [EOL] target_remotes = component . async_extract_from_service ( service ) [EOL] kwargs = service . data . copy ( ) [EOL] [EOL] update_tasks = [ ] [EOL] for remote in target_remotes : [EOL] if service . service == SERVICE_TURN_ON : [EOL] yield from remote . async_turn_on ( ** kwargs ) [EOL] elif service . service == SERVICE_TOGGLE : [EOL] yield from remote . async_toggle ( ** kwargs ) [EOL] elif service . service == SERVICE_SEND_COMMAND : [EOL] yield from remote . async_send_command ( ** kwargs ) [EOL] else : [EOL] yield from remote . async_turn_off ( ** kwargs ) [EOL] [EOL] if not remote . should_poll : [EOL] continue [EOL] update_tasks . append ( remote . async_update_ha_state ( True ) ) [EOL] [EOL] if update_tasks : [EOL] yield from asyncio . wait ( update_tasks , loop = hass . loop ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_TURN_OFF , async_handle_remote_service , schema = REMOTE_SERVICE_ACTIVITY_SCHEMA ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_TURN_ON , async_handle_remote_service , schema = REMOTE_SERVICE_ACTIVITY_SCHEMA ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_TOGGLE , async_handle_remote_service , schema = REMOTE_SERVICE_ACTIVITY_SCHEMA ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_SEND_COMMAND , async_handle_remote_service , schema = REMOTE_SERVICE_SEND_COMMAND_SCHEMA ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class RemoteDevice ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def send_command ( self , command , ** kwargs ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def async_send_command ( self , command , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_job ( ft . partial ( self . send_command , command , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . alarm_control_panel import AlarmControlPanel [EOL] from homeassistant . components . canary import DATA_CANARY [EOL] from homeassistant . const import STATE_ALARM_DISARMED , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_NIGHT , STATE_ALARM_ARMED_HOME [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] data = hass . data [ DATA_CANARY ] [EOL] devices = [ ] [EOL] [EOL] for location in data . locations : [EOL] devices . append ( CanaryAlarm ( data , location . location_id ) ) [EOL] [EOL] add_devices ( devices , True ) [EOL] [EOL] [EOL] class CanaryAlarm ( AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , location_id ) : [EOL] [docstring] [EOL] self . _data = data [EOL] self . _location_id = location_id [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] location = self . _data . get_location ( self . _location_id ) [EOL] return location . name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] from canary . api import LOCATION_MODE_AWAY , LOCATION_MODE_HOME , LOCATION_MODE_NIGHT [EOL] [EOL] location = self . _data . get_location ( self . _location_id ) [EOL] [EOL] if location . is_private : [EOL] return STATE_ALARM_DISARMED [EOL] [EOL] mode = location . mode [EOL] if mode . name == LOCATION_MODE_AWAY : [EOL] return STATE_ALARM_ARMED_AWAY [EOL] if mode . name == LOCATION_MODE_HOME : [EOL] return STATE_ALARM_ARMED_HOME [EOL] if mode . name == LOCATION_MODE_NIGHT : [EOL] return STATE_ALARM_ARMED_NIGHT [EOL] return None [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] location = self . _data . get_location ( self . _location_id ) [EOL] return { [string] : location . is_private } [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] location = self . _data . get_location ( self . _location_id ) [EOL] self . _data . set_location_mode ( self . _location_id , location . mode . name , True ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] from canary . api import LOCATION_MODE_HOME [EOL] self . _data . set_location_mode ( self . _location_id , LOCATION_MODE_HOME ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] from canary . api import LOCATION_MODE_AWAY [EOL] self . _data . set_location_mode ( self . _location_id , LOCATION_MODE_AWAY ) [EOL] [EOL] def alarm_arm_night ( self , code = None ) : [EOL] [docstring] [EOL] from canary . api import LOCATION_MODE_NIGHT [EOL] self . _data . set_location_mode ( self . _location_id , LOCATION_MODE_NIGHT ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] import requests [EOL] from homeassistant . const import STATE_OFF , STATE_ON [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] from homeassistant . components . neato import NEATO_ROBOTS , NEATO_LOGIN [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] SWITCH_TYPE_SCHEDULE = [string] [EOL] [EOL] SWITCH_TYPES = { SWITCH_TYPE_SCHEDULE : [ [string] ] } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] dev = [ ] [EOL] for robot in hass . data [ NEATO_ROBOTS ] : [EOL] for type_name in SWITCH_TYPES : [EOL] dev . append ( NeatoConnectedSwitch ( hass , robot , type_name ) ) [EOL] _LOGGER . debug ( [string] , dev ) [EOL] add_devices ( dev ) [EOL] [EOL] [EOL] class NeatoConnectedSwitch ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , robot , switch_type ) : [EOL] [docstring] [EOL] self . type = switch_type [EOL] self . robot = robot [EOL] self . neato = hass . data [ NEATO_LOGIN ] [EOL] self . _robot_name = [string] . format ( self . robot . name , SWITCH_TYPES [ self . type ] [ [number] ] ) [EOL] try : [EOL] self . _state = self . robot . state [EOL] except ( requests . exceptions . ConnectionError , requests . exceptions . HTTPError ) as ex : [EOL] _LOGGER . warning ( [string] , ex ) [EOL] self . _state = None [EOL] self . _schedule_state = None [EOL] self . _clean_state = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] self . neato . update_robots ( ) [EOL] try : [EOL] self . _state = self . robot . state [EOL] except ( requests . exceptions . ConnectionError , requests . exceptions . HTTPError ) as ex : [EOL] _LOGGER . warning ( [string] , ex ) [EOL] self . _state = None [EOL] return [EOL] _LOGGER . debug ( [string] , self . _state ) [EOL] if self . type == SWITCH_TYPE_SCHEDULE : [EOL] _LOGGER . debug ( [string] , self . _state ) [EOL] if self . _state [ [string] ] [ [string] ] : [EOL] self . _schedule_state = STATE_ON [EOL] else : [EOL] self . _schedule_state = STATE_OFF [EOL] _LOGGER . debug ( [string] , self . _schedule_state ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _robot_name [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] if self . type == SWITCH_TYPE_SCHEDULE : [EOL] if self . _schedule_state == STATE_ON : [EOL] return True [EOL] return False [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . type == SWITCH_TYPE_SCHEDULE : [EOL] self . robot . enable_schedule ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . type == SWITCH_TYPE_SCHEDULE : [EOL] self . robot . disable_schedule ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import time [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA , ATTR_CURRENT_POWER_W , ATTR_TODAY_ENERGY_KWH ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , ATTR_VOLTAGE ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_TOTAL_ENERGY_KWH = [string] [EOL] ATTR_CURRENT_A = [string] [EOL] [EOL] CONF_LEDS = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_LEDS ) : cv . boolean , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from pyHS100 import SmartPlug [EOL] host = config . get ( CONF_HOST ) [EOL] name = config . get ( CONF_NAME ) [EOL] leds_on = config . get ( CONF_LEDS ) [EOL] [EOL] add_devices ( [ SmartPlugSwitch ( SmartPlug ( host ) , name , leds_on ) ] , True ) [EOL] [EOL] [EOL] class SmartPlugSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , smartplug , name , leds_on ) : [EOL] [docstring] [EOL] self . smartplug = smartplug [EOL] self . _name = name [EOL] self . _leds_on = leds_on [EOL] self . _state = None [EOL] self . _available = True [EOL] [comment] [EOL] self . _emeter_params = { } [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . smartplug . turn_on ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . smartplug . turn_off ( ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _emeter_params [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from pyHS100 import SmartDeviceException [EOL] try : [EOL] self . _state = self . smartplug . state == self . smartplug . SWITCH_STATE_ON [EOL] [EOL] if self . _leds_on is not None : [EOL] self . smartplug . led = self . _leds_on [EOL] self . _leds_on = None [EOL] [EOL] [comment] [EOL] if self . _name == DEFAULT_NAME : [EOL] self . _name = self . smartplug . alias [EOL] [EOL] if self . smartplug . has_emeter : [EOL] emeter_readings = self . smartplug . get_emeter_realtime ( ) [EOL] [EOL] self . _emeter_params [ ATTR_CURRENT_POWER_W ] = [string] . format ( emeter_readings [ [string] ] ) [EOL] self . _emeter_params [ ATTR_TOTAL_ENERGY_KWH ] = [string] . format ( emeter_readings [ [string] ] ) [EOL] self . _emeter_params [ ATTR_VOLTAGE ] = [string] . format ( emeter_readings [ [string] ] ) [EOL] self . _emeter_params [ ATTR_CURRENT_A ] = [string] . format ( emeter_readings [ [string] ] ) [EOL] [EOL] emeter_statics = self . smartplug . get_emeter_daily ( ) [EOL] try : [EOL] self . _emeter_params [ ATTR_TODAY_ENERGY_KWH ] = [string] . format ( emeter_statics [ int ( time . strftime ( [string] ) ) ] ) [EOL] except KeyError : [EOL] [comment] [EOL] pass [EOL] [EOL] self . _available = True [EOL] [EOL] except ( SmartDeviceException , OSError ) as ex : [EOL] if self . _available : [EOL] _LOGGER . warning ( [string] , self . name , ex ) [EOL] self . _available = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Type , Any , List [EOL] import builtins [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . switch import DOMAIN , SwitchDevice [EOL] from homeassistant . components import zha [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] discovery_info = zha . get_discovery_info ( hass , discovery_info ) [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] from zigpy . zcl . clusters . general import OnOff [EOL] in_clusters = discovery_info [ [string] ] [EOL] cluster = in_clusters [ OnOff . cluster_id ] [EOL] await cluster . bind ( ) [EOL] await cluster . configure_reporting ( [number] , [number] , [number] , [number] , ) [EOL] [EOL] async_add_devices ( [ Switch ( ** discovery_info ) ] , update_before_add = True ) [EOL] [EOL] [EOL] class Switch ( zha . Entity , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] _domain = DOMAIN [EOL] value_attribute = [number] [EOL] [EOL] def attribute_updated ( self , attribute , value ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self , attribute , value ) [EOL] if attribute == self . value_attribute : [EOL] self . _state = value [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] if self . _state is None : [EOL] return False [EOL] return bool ( self . _state ) [EOL] [EOL] async def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] from zigpy . exceptions import DeliveryError [EOL] try : [EOL] await self . _endpoint . on_off . on ( ) [EOL] except DeliveryError as ex : [EOL] _LOGGER . error ( [string] , ex ) [EOL] return [EOL] [EOL] self . _state = [number] [EOL] [EOL] async def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] from zigpy . exceptions import DeliveryError [EOL] try : [EOL] await self . _endpoint . on_off . off ( ) [EOL] except DeliveryError as ex : [EOL] _LOGGER . error ( [string] , ex ) [EOL] return [EOL] [EOL] self . _state = [number] [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] result = await zha . safe_read ( self . _endpoint . on_off , [ [string] ] ) [EOL] self . _state = result . get ( [string] , self . _state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[homeassistant.components.switch.zha.Switch]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . hydrawise import ( ALLOWED_WATERING_TIME , CONF_WATERING_TIME , DATA_HYDRAWISE , DEFAULT_WATERING_TIME , HydrawiseEntity , SWITCHES , DEVICE_MAP , DEVICE_MAP_INDEX ) [EOL] from homeassistant . components . switch import PLATFORM_SCHEMA , SwitchDevice [EOL] from homeassistant . const import CONF_MONITORED_CONDITIONS [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = SWITCHES ) : vol . All ( cv . ensure_list , [ vol . In ( SWITCHES ) ] ) , vol . Optional ( CONF_WATERING_TIME , default = DEFAULT_WATERING_TIME ) : vol . All ( vol . In ( ALLOWED_WATERING_TIME ) ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] hydrawise = hass . data [ DATA_HYDRAWISE ] . data [EOL] [EOL] default_watering_timer = config . get ( CONF_WATERING_TIME ) [EOL] [EOL] sensors = [ ] [EOL] for sensor_type in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] [comment] [EOL] for zone in hydrawise . relays : [EOL] sensors . append ( HydrawiseSwitch ( default_watering_timer , zone , sensor_type ) ) [EOL] [EOL] add_devices ( sensors , True ) [EOL] [EOL] [EOL] class HydrawiseSwitch ( HydrawiseEntity , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , default_watering_timer , * args ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( * args ) [EOL] self . _default_watering_timer = default_watering_timer [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _sensor_type == [string] : [EOL] self . hass . data [ DATA_HYDRAWISE ] . data . run_zone ( self . _default_watering_timer , ( self . data [ [string] ] - [number] ) ) [EOL] elif self . _sensor_type == [string] : [EOL] self . hass . data [ DATA_HYDRAWISE ] . data . suspend_zone ( [number] , ( self . data [ [string] ] - [number] ) ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _sensor_type == [string] : [EOL] self . hass . data [ DATA_HYDRAWISE ] . data . run_zone ( [number] , ( self . data [ [string] ] - [number] ) ) [EOL] elif self . _sensor_type == [string] : [EOL] self . hass . data [ DATA_HYDRAWISE ] . data . suspend_zone ( [number] , ( self . data [ [string] ] - [number] ) ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] mydata = self . hass . data [ DATA_HYDRAWISE ] . data [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] if self . _sensor_type == [string] : [EOL] if not mydata . running : [EOL] self . _state = False [EOL] else : [EOL] self . _state = int ( mydata . running [ [number] ] [ [string] ] ) == self . data [ [string] ] [EOL] elif self . _sensor_type == [string] : [EOL] for relay in mydata . relays : [EOL] if relay [ [string] ] == self . data [ [string] ] : [EOL] if relay . get ( [string] ) is not None : [EOL] self . _state = False [EOL] else : [EOL] self . _state = True [EOL] break [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return DEVICE_MAP [ self . _sensor_type ] [ DEVICE_MAP_INDEX . index ( [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] [EOL] STEPS = [ STEP_USER ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0
from typing import List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . camera . mjpeg import ( CONF_MJPEG_URL , CONF_STILL_IMAGE_URL , MjpegCamera ) [EOL] from homeassistant . const import ( CONF_AUTHENTICATION , CONF_HOST , CONF_NAME , CONF_PASSWORD , CONF_PORT , CONF_USERNAME , HTTP_DIGEST_AUTHENTICATION ) [EOL] from homeassistant . helpers . dispatcher import dispatcher_connect [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] DEPENDENCIES = [ DOMAIN ] [EOL] [EOL] [EOL] def _get_image_url ( host , port , mode ) : [EOL] [docstring] [EOL] if mode == [string] : [EOL] return [string] . format ( host , port ) [EOL] if mode == [string] : [EOL] return [string] . format ( host , port ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] camera_config = { CONF_NAME : discovery_info [ CONF_NAME ] , CONF_USERNAME : discovery_info [ CONF_USERNAME ] , CONF_PASSWORD : discovery_info [ CONF_PASSWORD ] , CONF_MJPEG_URL : _get_image_url ( discovery_info [ CONF_HOST ] , str ( discovery_info [ CONF_PORT ] ) , [string] ) , CONF_STILL_IMAGE_URL : _get_image_url ( discovery_info [ CONF_HOST ] , str ( discovery_info [ CONF_PORT ] ) , [string] ) , CONF_AUTHENTICATION : HTTP_DIGEST_AUTHENTICATION , } [EOL] add_devices ( [ AxisCamera ( hass , camera_config , str ( discovery_info [ CONF_PORT ] ) ) ] ) [EOL] [EOL] [EOL] class AxisCamera ( MjpegCamera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config , port ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( hass , config ) [EOL] self . port = port [EOL] dispatcher_connect ( hass , DOMAIN + [string] + config [ CONF_NAME ] + [string] , self . _new_ip ) [EOL] [EOL] def _new_ip ( self , host ) : [EOL] [docstring] [EOL] self . _mjpeg_url = _get_image_url ( host , self . port , [string] ) [EOL] self . _still_image_url = _get_image_url ( host , self . port , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . camera import Camera , PLATFORM_SCHEMA [EOL] from homeassistant . components . ffmpeg import DATA_FFMPEG [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PATH , CONF_PASSWORD , CONF_PORT , CONF_USERNAME ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . aiohttp_client import async_aiohttp_proxy_stream [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] DEPENDENCIES = [ [string] ] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_BRAND = [string] [EOL] DEFAULT_PASSWORD = [string] [EOL] DEFAULT_PATH = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_USERNAME = [string] [EOL] [EOL] CONF_FFMPEG_ARGUMENTS = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . string , vol . Optional ( CONF_PATH , default = DEFAULT_PATH ) : cv . string , vol . Optional ( CONF_USERNAME , default = DEFAULT_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_FFMPEG_ARGUMENTS ) : cv . string } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] async_add_devices ( [ YiCamera ( hass , config ) ] , True ) [EOL] [EOL] [EOL] class YiCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _extra_arguments = config . get ( CONF_FFMPEG_ARGUMENTS ) [EOL] self . _last_image = None [EOL] self . _last_url = None [EOL] self . _manager = hass . data [ DATA_FFMPEG ] [EOL] self . _name = config [ CONF_NAME ] [EOL] self . host = config [ CONF_HOST ] [EOL] self . port = config [ CONF_PORT ] [EOL] self . path = config [ CONF_PATH ] [EOL] self . user = config [ CONF_USERNAME ] [EOL] self . passwd = config [ CONF_PASSWORD ] [EOL] [EOL] @ property def brand ( self ) : [EOL] [docstring] [EOL] return DEFAULT_BRAND [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] async def _get_latest_video_url ( self ) : [EOL] [docstring] [EOL] from aioftp import Client , StatusCodeError [EOL] [EOL] ftp = Client ( loop = self . hass . loop ) [EOL] try : [EOL] await ftp . connect ( self . host ) [EOL] await ftp . login ( self . user , self . passwd ) [EOL] except StatusCodeError as err : [EOL] raise PlatformNotReady ( err ) [EOL] [EOL] try : [EOL] await ftp . change_directory ( self . path ) [EOL] dirs = [ ] [EOL] for path , attrs in await ftp . list ( ) : [EOL] if attrs [ [string] ] == [string] and [string] not in str ( path ) : [EOL] dirs . append ( path ) [EOL] latest_dir = dirs [ - [number] ] [EOL] await ftp . change_directory ( latest_dir ) [EOL] [EOL] videos = [ ] [EOL] for path , _ in await ftp . list ( ) : [EOL] videos . append ( path ) [EOL] if not videos : [EOL] _LOGGER . info ( [string] , latest_dir ) [EOL] return None [EOL] [EOL] await ftp . quit ( ) [EOL] [EOL] return [string] . format ( self . user , self . passwd , self . host , self . port , self . path , latest_dir , videos [ - [number] ] ) [EOL] except ( ConnectionRefusedError , StatusCodeError ) as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] return None [EOL] [EOL] async def async_camera_image ( self ) : [EOL] [docstring] [EOL] from haffmpeg import ImageFrame , IMAGE_JPEG [EOL] [EOL] url = await self . _get_latest_video_url ( ) [EOL] if url != self . _last_url : [EOL] ffmpeg = ImageFrame ( self . _manager . binary , loop = self . hass . loop ) [EOL] self . _last_image = await asyncio . shield ( ffmpeg . get_image ( url , output_format = IMAGE_JPEG , extra_cmd = self . _extra_arguments ) , loop = self . hass . loop ) [EOL] self . _last_url = url [EOL] [EOL] return self . _last_image [EOL] [EOL] async def handle_async_mjpeg_stream ( self , request ) : [EOL] [docstring] [EOL] from haffmpeg import CameraMjpeg [EOL] [EOL] stream = CameraMjpeg ( self . _manager . binary , loop = self . hass . loop ) [EOL] await stream . open_camera ( self . _last_url , extra_cmd = self . _extra_arguments ) [EOL] [EOL] await async_aiohttp_proxy_stream ( self . hass , request , stream , [string] ) [EOL] await stream . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_VERIFY_SSL [EOL] from homeassistant . components . netatmo import CameraData [EOL] from homeassistant . components . camera import ( Camera , PLATFORM_SCHEMA ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_HOME = [string] [EOL] CONF_CAMERAS = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_VERIFY_SSL , default = True ) : cv . boolean , vol . Optional ( CONF_HOME ) : cv . string , vol . Optional ( CONF_CAMERAS , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] netatmo = hass . components . netatmo [EOL] home = config . get ( CONF_HOME ) [EOL] verify_ssl = config . get ( CONF_VERIFY_SSL , True ) [EOL] import pyatmo [EOL] try : [EOL] data = CameraData ( netatmo . NETATMO_AUTH , home ) [EOL] for camera_name in data . get_camera_names ( ) : [EOL] camera_type = data . get_camera_type ( camera = camera_name , home = home ) [EOL] if CONF_CAMERAS in config : [EOL] if config [ CONF_CAMERAS ] != [ ] and camera_name not in config [ CONF_CAMERAS ] : [EOL] continue [EOL] add_devices ( [ NetatmoCamera ( data , camera_name , home , camera_type , verify_ssl ) ] ) [EOL] except pyatmo . NoDevice : [EOL] return None [EOL] [EOL] [EOL] class NetatmoCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , camera_name , home , camera_type , verify_ssl ) : [EOL] [docstring] [EOL] super ( NetatmoCamera , self ) . __init__ ( ) [EOL] self . _data = data [EOL] self . _camera_name = camera_name [EOL] self . _verify_ssl = verify_ssl [EOL] if home : [EOL] self . _name = home + [string] + camera_name [EOL] else : [EOL] self . _name = camera_name [EOL] self . _vpnurl , self . _localurl = self . _data . camera_data . cameraUrls ( camera = camera_name ) [EOL] self . _cameratype = camera_type [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] try : [EOL] if self . _localurl : [EOL] response = requests . get ( [string] . format ( self . _localurl ) , timeout = [number] ) [EOL] elif self . _vpnurl : [EOL] response = requests . get ( [string] . format ( self . _vpnurl ) , timeout = [number] , verify = self . _verify_ssl ) [EOL] else : [EOL] _LOGGER . error ( [string] ) [EOL] self . _data . update ( ) [EOL] ( self . _vpnurl , self . _localurl ) = self . _data . camera_data . cameraUrls ( camera = self . _camera_name ) [EOL] return None [EOL] except requests . exceptions . RequestException as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] self . _data . update ( ) [EOL] ( self . _vpnurl , self . _localurl ) = self . _data . camera_data . cameraUrls ( camera = self . _camera_name ) [EOL] return None [EOL] return response . content [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def brand ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def model ( self ) : [EOL] [docstring] [EOL] if self . _cameratype == [string] : [EOL] return [string] [EOL] if self . _cameratype == [string] : [EOL] return [string] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] _LOGGER = logging . getLogger ( [string] ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] COMPONENTS = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] CONF_NAME = [string] [EOL] CONF_ACCESSPOINT = [string] [EOL] CONF_AUTHTOKEN = [string] [EOL] [EOL] HMIPC_NAME = [string] [EOL] HMIPC_HAPID = [string] [EOL] HMIPC_AUTHTOKEN = [string] [EOL] HMIPC_PIN = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . fan import ( SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH , FanEntity , SUPPORT_SET_SPEED , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . velbus import DOMAIN [EOL] from homeassistant . const import CONF_NAME , CONF_DEVICES , STATE_OFF [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DEVICES ) : vol . All ( cv . ensure_list , [ { vol . Required ( [string] ) : cv . positive_int , vol . Required ( [string] ) : cv . positive_int , vol . Required ( [string] ) : cv . positive_int , vol . Required ( [string] ) : cv . positive_int , vol . Required ( CONF_NAME ) : cv . string , } ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] velbus = hass . data [ DOMAIN ] [EOL] add_devices ( VelbusFan ( fan , velbus ) for fan in config [ CONF_DEVICES ] ) [EOL] [EOL] [EOL] class VelbusFan ( FanEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , fan , velbus ) : [EOL] [docstring] [EOL] self . _velbus = velbus [EOL] self . _name = fan [ CONF_NAME ] [EOL] self . _module = fan [ [string] ] [EOL] self . _channel_low = fan [ [string] ] [EOL] self . _channel_medium = fan [ [string] ] [EOL] self . _channel_high = fan [ [string] ] [EOL] self . _channels = [ self . _channel_low , self . _channel_medium , self . _channel_high ] [EOL] self . _channels_state = [ False , False , False ] [EOL] self . _speed = STATE_OFF [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] def _init_velbus ( ) : [EOL] [docstring] [EOL] self . _velbus . subscribe ( self . _on_message ) [EOL] self . get_status ( ) [EOL] [EOL] yield from self . hass . async_add_job ( _init_velbus ) [EOL] [EOL] def _on_message ( self , message ) : [EOL] import velbus [EOL] if isinstance ( message , velbus . RelayStatusMessage ) and message . address == self . _module and message . channel in self . _channels : [EOL] if message . channel == self . _channel_low : [EOL] self . _channels_state [ [number] ] = message . is_on ( ) [EOL] elif message . channel == self . _channel_medium : [EOL] self . _channels_state [ [number] ] = message . is_on ( ) [EOL] elif message . channel == self . _channel_high : [EOL] self . _channels_state [ [number] ] = message . is_on ( ) [EOL] self . _calculate_speed ( ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def _calculate_speed ( self ) : [EOL] if self . _is_off ( ) : [EOL] self . _speed = STATE_OFF [EOL] elif self . _is_low ( ) : [EOL] self . _speed = SPEED_LOW [EOL] elif self . _is_medium ( ) : [EOL] self . _speed = SPEED_MEDIUM [EOL] elif self . _is_high ( ) : [EOL] self . _speed = SPEED_HIGH [EOL] [EOL] def _is_off ( self ) : [EOL] return self . _channels_state [ [number] ] is False and self . _channels_state [ [number] ] is False and self . _channels_state [ [number] ] is False [EOL] [EOL] def _is_low ( self ) : [EOL] return self . _channels_state [ [number] ] is True and self . _channels_state [ [number] ] is False and self . _channels_state [ [number] ] is False [EOL] [EOL] def _is_medium ( self ) : [EOL] return self . _channels_state [ [number] ] is True and self . _channels_state [ [number] ] is True and self . _channels_state [ [number] ] is False [EOL] [EOL] def _is_high ( self ) : [EOL] return self . _channels_state [ [number] ] is True and self . _channels_state [ [number] ] is False and self . _channels_state [ [number] ] is True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def speed ( self ) : [EOL] [docstring] [EOL] return self . _speed [EOL] [EOL] @ property def speed_list ( self ) : [EOL] [docstring] [EOL] return [ STATE_OFF , SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH ] [EOL] [EOL] def turn_on ( self , speed = None , ** kwargs ) : [EOL] [docstring] [EOL] if speed is None : [EOL] speed = SPEED_MEDIUM [EOL] self . set_speed ( speed ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . set_speed ( STATE_OFF ) [EOL] [EOL] def set_speed ( self , speed ) : [EOL] [docstring] [EOL] channels_off = [ ] [EOL] channels_on = [ ] [EOL] if speed == STATE_OFF : [EOL] channels_off = self . _channels [EOL] elif speed == SPEED_LOW : [EOL] channels_off = [ self . _channel_medium , self . _channel_high ] [EOL] channels_on = [ self . _channel_low ] [EOL] elif speed == SPEED_MEDIUM : [EOL] channels_off = [ self . _channel_high ] [EOL] channels_on = [ self . _channel_low , self . _channel_medium ] [EOL] elif speed == SPEED_HIGH : [EOL] channels_off = [ self . _channel_medium ] [EOL] channels_on = [ self . _channel_low , self . _channel_high ] [EOL] for channel in channels_off : [EOL] self . _relay_off ( channel ) [EOL] for channel in channels_on : [EOL] self . _relay_on ( channel ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def _relay_on ( self , channel ) : [EOL] import velbus [EOL] message = velbus . SwitchRelayOnMessage ( ) [EOL] message . set_defaults ( self . _module ) [EOL] message . relay_channels = [ channel ] [EOL] self . _velbus . send ( message ) [EOL] [EOL] def _relay_off ( self , channel ) : [EOL] import velbus [EOL] message = velbus . SwitchRelayOffMessage ( ) [EOL] message . set_defaults ( self . _module ) [EOL] message . relay_channels = [ channel ] [EOL] self . _velbus . send ( message ) [EOL] [EOL] def get_status ( self ) : [EOL] [docstring] [EOL] import velbus [EOL] message = velbus . ModuleStatusRequestMessage ( ) [EOL] message . set_defaults ( self . _module ) [EOL] message . channels = self . _channels [EOL] self . _velbus . send ( message ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_SET_SPEED [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import logging [EOL] import io [EOL] import subprocess [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import io [EOL] import os [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . core import split_entity_id [EOL] from homeassistant . components . image_processing import ( PLATFORM_SCHEMA , ImageProcessingEntity , CONF_SOURCE , CONF_ENTITY_ID , CONF_NAME ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DIGITS = [string] [EOL] CONF_EXTRA_ARGUMENTS = [string] [EOL] CONF_HEIGHT = [string] [EOL] CONF_ROTATE = [string] [EOL] CONF_SSOCR_BIN = [string] [EOL] CONF_THRESHOLD = [string] [EOL] CONF_WIDTH = [string] [EOL] CONF_X_POS = [string] [EOL] CONF_Y_POS = [string] [EOL] [EOL] DEFAULT_BINARY = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_EXTRA_ARGUMENTS , default = [string] ) : cv . string , vol . Optional ( CONF_DIGITS ) : cv . positive_int , vol . Optional ( CONF_HEIGHT , default = [number] ) : cv . positive_int , vol . Optional ( CONF_SSOCR_BIN , default = DEFAULT_BINARY ) : cv . string , vol . Optional ( CONF_THRESHOLD , default = [number] ) : cv . positive_int , vol . Optional ( CONF_ROTATE , default = [number] ) : cv . positive_int , vol . Optional ( CONF_WIDTH , default = [number] ) : cv . positive_int , vol . Optional ( CONF_X_POS , default = [number] ) : cv . string , vol . Optional ( CONF_Y_POS , default = [number] ) : cv . positive_int , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] entities = [ ] [EOL] for camera in config [ CONF_SOURCE ] : [EOL] entities . append ( ImageProcessingSsocr ( hass , camera [ CONF_ENTITY_ID ] , config , camera . get ( CONF_NAME ) ) ) [EOL] [EOL] async_add_devices ( entities ) [EOL] [EOL] [EOL] class ImageProcessingSsocr ( ImageProcessingEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , camera_entity , config , name ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _camera_entity = camera_entity [EOL] if name : [EOL] self . _name = name [EOL] else : [EOL] self . _name = [string] . format ( split_entity_id ( camera_entity ) [ [number] ] ) [EOL] self . _state = None [EOL] [EOL] self . filepath = os . path . join ( self . hass . config . config_dir , [string] ) [EOL] crop = [ [string] , str ( config [ CONF_X_POS ] ) , str ( config [ CONF_Y_POS ] ) , str ( config [ CONF_WIDTH ] ) , str ( config [ CONF_HEIGHT ] ) ] [EOL] digits = [ [string] , str ( config . get ( CONF_DIGITS , - [number] ) ) ] [EOL] rotate = [ [string] , str ( config [ CONF_ROTATE ] ) ] [EOL] threshold = [ [string] , str ( config [ CONF_THRESHOLD ] ) ] [EOL] extra_arguments = config [ CONF_EXTRA_ARGUMENTS ] . split ( [string] ) [EOL] [EOL] self . _command = [ config [ CONF_SSOCR_BIN ] ] + crop + digits + threshold + rotate + extra_arguments [EOL] self . _command . append ( self . filepath ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def camera_entity ( self ) : [EOL] [docstring] [EOL] return self . _camera_entity [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def process_image ( self , image ) : [EOL] [docstring] [EOL] from PIL import Image [EOL] import subprocess [EOL] [EOL] stream = io . BytesIO ( image ) [EOL] img = Image . open ( stream ) [EOL] img . save ( self . filepath , [string] ) [EOL] [EOL] ocr = subprocess . Popen ( self . _command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] out = ocr . communicate ( ) [EOL] if out [ [number] ] != [string] : [EOL] self . _state = out [ [number] ] . strip ( ) . decode ( [string] ) [EOL] else : [EOL] self . _state = None [EOL] _LOGGER . warning ( [string] , out [ [number] ] . strip ( ) . decode ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $io.BytesIO$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Coroutine , List , Any , Pattern , Set , Generator [EOL] import logging [EOL] import io [EOL] import asyncio [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import io [EOL] import logging [EOL] import re [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . core import split_entity_id , callback [EOL] from homeassistant . const import STATE_UNKNOWN , CONF_REGION [EOL] from homeassistant . components . image_processing import ( PLATFORM_SCHEMA , ImageProcessingEntity , CONF_CONFIDENCE , CONF_SOURCE , CONF_ENTITY_ID , CONF_NAME , ATTR_ENTITY_ID , ATTR_CONFIDENCE ) [EOL] from homeassistant . util . async_ import run_callback_threadsafe [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] RE_ALPR_PLATE = re . compile ( [string] ) [EOL] RE_ALPR_RESULT = re . compile ( [string] ) [EOL] [EOL] EVENT_FOUND_PLATE = [string] [EOL] [EOL] ATTR_PLATE = [string] [EOL] ATTR_PLATES = [string] [EOL] ATTR_VEHICLES = [string] [EOL] [EOL] OPENALPR_REGIONS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] CONF_ALPR_BIN = [string] [EOL] [EOL] DEFAULT_BINARY = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_REGION ) : vol . All ( vol . Lower , vol . In ( OPENALPR_REGIONS ) ) , vol . Optional ( CONF_ALPR_BIN , default = DEFAULT_BINARY ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] command = [ config [ CONF_ALPR_BIN ] , [string] , config [ CONF_REGION ] , [string] ] [EOL] confidence = config [ CONF_CONFIDENCE ] [EOL] [EOL] entities = [ ] [EOL] for camera in config [ CONF_SOURCE ] : [EOL] entities . append ( OpenAlprLocalEntity ( camera [ CONF_ENTITY_ID ] , command , confidence , camera . get ( CONF_NAME ) ) ) [EOL] [EOL] async_add_devices ( entities ) [EOL] [EOL] [EOL] class ImageProcessingAlprEntity ( ImageProcessingEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . plates = { } [EOL] self . vehicles = [number] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] confidence = [number] [EOL] plate = STATE_UNKNOWN [EOL] [EOL] [comment] [EOL] for i_pl , i_co in self . plates . items ( ) : [EOL] if i_co > confidence : [EOL] confidence = i_co [EOL] plate = i_pl [EOL] return plate [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] attr = { ATTR_PLATES : self . plates , ATTR_VEHICLES : self . vehicles } [EOL] [EOL] return attr [EOL] [EOL] def process_plates ( self , plates , vehicles ) : [EOL] [docstring] [EOL] run_callback_threadsafe ( self . hass . loop , self . async_process_plates , plates , vehicles ) . result ( ) [EOL] [EOL] @ callback def async_process_plates ( self , plates , vehicles ) : [EOL] [docstring] [EOL] plates = { plate : confidence for plate , confidence in plates . items ( ) if confidence >= self . confidence } [EOL] new_plates = set ( plates ) - set ( self . plates ) [EOL] [EOL] [comment] [EOL] for i_plate in new_plates : [EOL] self . hass . async_add_job ( self . hass . bus . async_fire , EVENT_FOUND_PLATE , { ATTR_PLATE : i_plate , ATTR_ENTITY_ID : self . entity_id , ATTR_CONFIDENCE : plates . get ( i_plate ) , } ) [EOL] [EOL] [comment] [EOL] self . plates = plates [EOL] self . vehicles = vehicles [EOL] [EOL] [EOL] class OpenAlprLocalEntity ( ImageProcessingAlprEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , camera_entity , command , confidence , name = None ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _cmd = command [EOL] self . _camera = camera_entity [EOL] self . _confidence = confidence [EOL] [EOL] if name : [EOL] self . _name = name [EOL] else : [EOL] self . _name = [string] . format ( split_entity_id ( camera_entity ) [ [number] ] ) [EOL] [EOL] @ property def confidence ( self ) : [EOL] [docstring] [EOL] return self . _confidence [EOL] [EOL] @ property def camera_entity ( self ) : [EOL] [docstring] [EOL] return self . _camera [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ asyncio . coroutine def async_process_image ( self , image ) : [EOL] [docstring] [EOL] result = { } [EOL] vehicles = [number] [EOL] [EOL] alpr = yield from asyncio . create_subprocess_exec ( * self . _cmd , loop = self . hass . loop , stdin = asyncio . subprocess . PIPE , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . DEVNULL ) [EOL] [EOL] [comment] [EOL] stdout , _ = yield from alpr . communicate ( input = image ) [EOL] stdout = io . StringIO ( str ( stdout , [string] ) ) [EOL] [EOL] while True : [EOL] line = stdout . readline ( ) [EOL] if not line : [EOL] break [EOL] [EOL] new_plates = RE_ALPR_PLATE . search ( line ) [EOL] new_result = RE_ALPR_RESULT . search ( line ) [EOL] [EOL] [comment] [EOL] if new_plates : [EOL] vehicles += [number] [EOL] continue [EOL] [EOL] [comment] [EOL] if new_result : [EOL] try : [EOL] result . update ( { new_result . group ( [number] ) : float ( new_result . group ( [number] ) ) } ) [EOL] except ValueError : [EOL] continue [EOL] [EOL] self . async_process_plates ( result , vehicles ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Generator[typing.Coroutine[typing.Any,typing.Any,asyncio.subprocess.Process],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 $typing.Generator[typing.Coroutine[typing.Any,typing.Any,asyncio.subprocess.Process],None,None]$ 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.int$ 0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
from typing import Generator , Any , List [EOL] import builtins [EOL] import logging [EOL] import homeassistant [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] from functools import partial [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import CONF_NAME , TEMP_FAHRENHEIT [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . util . temperature import celsius_to_fahrenheit [EOL] [EOL] REQUIREMENTS = [ [string] , [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_I2C_BUS = [string] [EOL] DEFAULT_I2C_BUS = [number] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] SENSOR_TEMPERATURE = [string] [EOL] SENSOR_HUMIDITY = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_I2C_BUS , default = DEFAULT_I2C_BUS ) : vol . Coerce ( int ) , } ) [EOL] [EOL] [EOL] [comment] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import smbus [EOL] from i2csense . htu21d import HTU21D [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] bus_number = config . get ( CONF_I2C_BUS ) [EOL] temp_unit = hass . config . units . temperature_unit [EOL] [EOL] bus = smbus . SMBus ( config . get ( CONF_I2C_BUS ) ) [EOL] sensor = yield from hass . async_add_job ( partial ( HTU21D , bus , logger = _LOGGER ) ) [EOL] if not sensor . sample_ok : [EOL] _LOGGER . error ( [string] , bus_number ) [EOL] return False [EOL] [EOL] sensor_handler = yield from hass . async_add_job ( HTU21DHandler , sensor ) [EOL] [EOL] dev = [ HTU21DSensor ( sensor_handler , name , SENSOR_TEMPERATURE , temp_unit ) , HTU21DSensor ( sensor_handler , name , SENSOR_HUMIDITY , [string] ) ] [EOL] [EOL] async_add_devices ( dev ) [EOL] [EOL] [EOL] class HTU21DHandler : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor ) : [EOL] [docstring] [EOL] self . sensor = sensor [EOL] self . sensor . update ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] self . sensor . update ( ) [EOL] [EOL] [EOL] class HTU21DSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , htu21d_client , name , variable , unit ) : [EOL] [docstring] [EOL] self . _name = [string] . format ( name , variable ) [EOL] self . _variable = variable [EOL] self . _unit_of_measurement = unit [EOL] self . _client = htu21d_client [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] yield from self . hass . async_add_job ( self . _client . update ) [EOL] if self . _client . sensor . sample_ok : [EOL] if self . _variable == SENSOR_TEMPERATURE : [EOL] value = round ( self . _client . sensor . temperature , [number] ) [EOL] if self . unit_of_measurement == TEMP_FAHRENHEIT : [EOL] value = celsius_to_fahrenheit ( value ) [EOL] else : [EOL] value = round ( self . _client . sensor . humidity , [number] ) [EOL] self . _state = value [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
[docstring] [EOL] [EOL] import logging [EOL] [EOL] from homeassistant . const import TEMP_CELSIUS [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . components . juicenet import JuicenetDevice , DOMAIN [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , None ] , [string] : [ [string] , TEMP_CELSIUS ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] api = hass . data [ DOMAIN ] [ [string] ] [EOL] [EOL] dev = [ ] [EOL] for device in api . get_devices ( ) : [EOL] for variable in SENSOR_TYPES : [EOL] dev . append ( JuicenetSensorDevice ( device , variable , hass ) ) [EOL] [EOL] add_devices ( dev ) [EOL] [EOL] [EOL] class JuicenetSensorDevice ( JuicenetDevice , Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , sensor_type , hass ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( device , sensor_type , hass ) [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . device . name ( ) , self . _name ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] icon = None [EOL] if self . type == [string] : [EOL] status = self . device . getStatus ( ) [EOL] if status == [string] : [EOL] icon = [string] [EOL] elif status == [string] : [EOL] icon = [string] [EOL] elif status == [string] : [EOL] icon = [string] [EOL] elif self . type == [string] : [EOL] icon = [string] [EOL] elif self . type == [string] : [EOL] icon = [string] [EOL] elif self . type == [string] : [EOL] icon = [string] [EOL] elif self . type == [string] : [EOL] icon = [string] [EOL] elif self . type == [string] : [EOL] icon = [string] [EOL] elif self . type == [string] : [EOL] icon = [string] [EOL] return icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] state = None [EOL] if self . type == [string] : [EOL] state = self . device . getStatus ( ) [EOL] elif self . type == [string] : [EOL] state = self . device . getTemperature ( ) [EOL] elif self . type == [string] : [EOL] state = self . device . getVoltage ( ) [EOL] elif self . type == [string] : [EOL] state = self . device . getAmps ( ) [EOL] elif self . type == [string] : [EOL] state = self . device . getWatts ( ) [EOL] elif self . type == [string] : [EOL] state = self . device . getChargeTime ( ) [EOL] elif self . type == [string] : [EOL] state = self . device . getEnergyAdded ( ) [EOL] else : [EOL] state = [string] [EOL] return state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = { } [EOL] if self . type == [string] : [EOL] man_dev_id = self . device . id ( ) [EOL] if man_dev_id : [EOL] attributes [ [string] ] = man_dev_id [EOL] return attributes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from typing import Optional [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . sensor import ENTITY_ID_FORMAT , PLATFORM_SCHEMA , DEVICE_CLASSES_SCHEMA [EOL] from homeassistant . const import ( ATTR_FRIENDLY_NAME , ATTR_UNIT_OF_MEASUREMENT , CONF_VALUE_TEMPLATE , CONF_ICON_TEMPLATE , CONF_ENTITY_PICTURE_TEMPLATE , ATTR_ENTITY_ID , CONF_SENSORS , EVENT_HOMEASSISTANT_START , CONF_FRIENDLY_NAME_TEMPLATE , MATCH_ALL , CONF_DEVICE_CLASS ) [EOL] from homeassistant . exceptions import TemplateError [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity , async_generate_entity_id [EOL] from homeassistant . helpers . event import async_track_state_change [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SENSOR_SCHEMA = vol . Schema ( { vol . Required ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_ICON_TEMPLATE ) : cv . template , vol . Optional ( CONF_ENTITY_PICTURE_TEMPLATE ) : cv . template , vol . Optional ( CONF_FRIENDLY_NAME_TEMPLATE ) : cv . template , vol . Optional ( ATTR_FRIENDLY_NAME ) : cv . string , vol . Optional ( ATTR_UNIT_OF_MEASUREMENT ) : cv . string , vol . Optional ( CONF_DEVICE_CLASS ) : DEVICE_CLASSES_SCHEMA , vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SENSORS ) : vol . Schema ( { cv . slug : SENSOR_SCHEMA } ) , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] sensors = [ ] [EOL] [EOL] for device , device_config in config [ CONF_SENSORS ] . items ( ) : [EOL] state_template = device_config [ CONF_VALUE_TEMPLATE ] [EOL] icon_template = device_config . get ( CONF_ICON_TEMPLATE ) [EOL] entity_picture_template = device_config . get ( CONF_ENTITY_PICTURE_TEMPLATE ) [EOL] friendly_name = device_config . get ( ATTR_FRIENDLY_NAME , device ) [EOL] friendly_name_template = device_config . get ( CONF_FRIENDLY_NAME_TEMPLATE ) [EOL] unit_of_measurement = device_config . get ( ATTR_UNIT_OF_MEASUREMENT ) [EOL] device_class = device_config . get ( CONF_DEVICE_CLASS ) [EOL] [EOL] entity_ids = set ( ) [EOL] manual_entity_ids = device_config . get ( ATTR_ENTITY_ID ) [EOL] [EOL] for template in ( state_template , icon_template , entity_picture_template , friendly_name_template ) : [EOL] if template is None : [EOL] continue [EOL] template . hass = hass [EOL] [EOL] if entity_ids == MATCH_ALL or manual_entity_ids is not None : [EOL] continue [EOL] [EOL] template_entity_ids = template . extract_entities ( ) [EOL] if template_entity_ids == MATCH_ALL : [EOL] entity_ids = MATCH_ALL [EOL] else : [EOL] entity_ids |= set ( template_entity_ids ) [EOL] [EOL] if manual_entity_ids is not None : [EOL] entity_ids = manual_entity_ids [EOL] elif entity_ids != MATCH_ALL : [EOL] entity_ids = list ( entity_ids ) [EOL] [EOL] sensors . append ( SensorTemplate ( hass , device , friendly_name , friendly_name_template , unit_of_measurement , state_template , icon_template , entity_picture_template , entity_ids , device_class ) ) [EOL] if not sensors : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] async_add_devices ( sensors ) [EOL] return True [EOL] [EOL] [EOL] class SensorTemplate ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device_id , friendly_name , friendly_name_template , unit_of_measurement , state_template , icon_template , entity_picture_template , entity_ids , device_class ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . entity_id = async_generate_entity_id ( ENTITY_ID_FORMAT , device_id , hass = hass ) [EOL] self . _name = friendly_name [EOL] self . _friendly_name_template = friendly_name_template [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . _template = state_template [EOL] self . _state = None [EOL] self . _icon_template = icon_template [EOL] self . _entity_picture_template = entity_picture_template [EOL] self . _icon = None [EOL] self . _entity_picture = None [EOL] self . _entities = entity_ids [EOL] self . _device_class = device_class [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] @ callback def template_sensor_state_listener ( entity , old_state , new_state ) : [EOL] [docstring] [EOL] self . async_schedule_update_ha_state ( True ) [EOL] [EOL] @ callback def template_sensor_startup ( event ) : [EOL] [docstring] [EOL] async_track_state_change ( self . hass , self . _entities , template_sensor_state_listener ) [EOL] [EOL] self . async_schedule_update_ha_state ( True ) [EOL] [EOL] self . hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_START , template_sensor_startup ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] @ property def entity_picture ( self ) : [EOL] [docstring] [EOL] return self . _entity_picture [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _state = self . _template . async_render ( ) [EOL] except TemplateError as ex : [EOL] if ex . args and ex . args [ [number] ] . startswith ( [string] ) : [EOL] [comment] [EOL] _LOGGER . warning ( [string] [string] , self . _name ) [EOL] else : [EOL] self . _state = None [EOL] _LOGGER . error ( [string] , self . _name , ex ) [EOL] for property_name , template in ( ( [string] , self . _icon_template ) , ( [string] , self . _entity_picture_template ) , ( [string] , self . _friendly_name_template ) ) : [EOL] if template is None : [EOL] continue [EOL] [EOL] try : [EOL] setattr ( self , property_name , template . async_render ( ) ) [EOL] except TemplateError as ex : [EOL] friendly_property_name = property_name [ [number] : ] . replace ( [string] , [string] ) [EOL] if ex . args and ex . args [ [number] ] . startswith ( [string] ) : [EOL] [comment] [EOL] _LOGGER . warning ( [string] [string] , friendly_property_name , self . _name ) [EOL] continue [EOL] [EOL] try : [EOL] setattr ( self , property_name , getattr ( super ( ) , property_name ) ) [EOL] except AttributeError : [EOL] _LOGGER . error ( [string] , friendly_property_name , self . _name , ex ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Generator , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import aiohttp [EOL] from aiohttp . hdrs import ACCEPT , AUTHORIZATION [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . components . thethingsnetwork import ( DATA_TTN , TTN_APP_ID , TTN_ACCESS_KEY , TTN_DATA_STORAGE_URL ) [EOL] from homeassistant . const import CONTENT_TYPE_JSON [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_DEVICE_ID = [string] [EOL] ATTR_RAW = [string] [EOL] ATTR_TIME = [string] [EOL] [EOL] DEFAULT_TIMEOUT = [number] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_DEVICE_ID = [string] [EOL] CONF_VALUES = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DEVICE_ID ) : cv . string , vol . Required ( CONF_VALUES ) : { cv . string : cv . string } , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] ttn = hass . data . get ( DATA_TTN ) [EOL] device_id = config . get ( CONF_DEVICE_ID ) [EOL] values = config . get ( CONF_VALUES ) [EOL] app_id = ttn . get ( TTN_APP_ID ) [EOL] access_key = ttn . get ( TTN_ACCESS_KEY ) [EOL] [EOL] ttn_data_storage = TtnDataStorage ( hass , app_id , device_id , access_key , values ) [EOL] success = yield from ttn_data_storage . async_update ( ) [EOL] [EOL] if not success : [EOL] return False [EOL] [EOL] devices = [ ] [EOL] for value , unit_of_measurement in values . items ( ) : [EOL] devices . append ( TtnDataSensor ( ttn_data_storage , device_id , value , unit_of_measurement ) ) [EOL] async_add_devices ( devices , True ) [EOL] [EOL] [EOL] class TtnDataSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ttn_data_storage , device_id , value , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _ttn_data_storage = ttn_data_storage [EOL] self . _state = None [EOL] self . _device_id = device_id [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . _value = value [EOL] self . _name = [string] . format ( self . _device_id , self . _value ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _ttn_data_storage . data is not None : [EOL] try : [EOL] return round ( self . _state [ self . _value ] , [number] ) [EOL] except KeyError : [EOL] pass [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _ttn_data_storage . data is not None : [EOL] return { ATTR_DEVICE_ID : self . _device_id , ATTR_RAW : self . _state [ [string] ] , ATTR_TIME : self . _state [ [string] ] , } [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] yield from self . _ttn_data_storage . async_update ( ) [EOL] self . _state = self . _ttn_data_storage . data [EOL] [EOL] [EOL] class TtnDataStorage : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , app_id , device_id , access_key , values ) : [EOL] [docstring] [EOL] self . data = None [EOL] self . _hass = hass [EOL] self . _app_id = app_id [EOL] self . _device_id = device_id [EOL] self . _values = values [EOL] self . _url = TTN_DATA_STORAGE_URL . format ( app_id = app_id , endpoint = [string] , device_id = device_id ) [EOL] self . _headers = { ACCEPT : CONTENT_TYPE_JSON , AUTHORIZATION : [string] . format ( access_key ) , } [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] try : [EOL] session = async_get_clientsession ( self . _hass ) [EOL] with async_timeout . timeout ( DEFAULT_TIMEOUT , loop = self . _hass . loop ) : [EOL] req = yield from session . get ( self . _url , headers = self . _headers ) [EOL] [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) : [EOL] _LOGGER . error ( [string] , self . _url ) [EOL] return False [EOL] [EOL] status = req . status [EOL] [EOL] if status == [number] : [EOL] _LOGGER . error ( [string] , self . _device_id ) [EOL] return False [EOL] [EOL] if status == [number] : [EOL] _LOGGER . error ( [string] , self . _app_id ) [EOL] return False [EOL] [EOL] if status == [number] : [EOL] _LOGGER . error ( [string] , self . _app_id ) [EOL] return False [EOL] [EOL] data = yield from req . json ( ) [EOL] self . data = data [ [number] ] [EOL] [EOL] for value in self . _values . items ( ) : [EOL] if value [ [number] ] not in self . data . keys ( ) : [EOL] _LOGGER . warning ( [string] , value [ [number] ] ) [EOL] [EOL] return req [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0
from typing import Any , List [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from homeassistant . components . sensor import ENTITY_ID_FORMAT [EOL] from homeassistant . components . waterfurnace import ( DOMAIN as WF_DOMAIN , UPDATE_TOPIC ) [EOL] from homeassistant . const import TEMP_FAHRENHEIT [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import slugify [EOL] [EOL] [EOL] class WFSensorConfig : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , friendly_name , field , icon = [string] , unit_of_measurement = None ) : [EOL] [docstring] [EOL] self . friendly_name = friendly_name [EOL] self . field = field [EOL] self . icon = icon [EOL] self . unit_of_measurement = unit_of_measurement [EOL] [EOL] [EOL] SENSORS = [ WFSensorConfig ( [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] sensors = [ ] [EOL] client = hass . data [ WF_DOMAIN ] [EOL] for sconfig in SENSORS : [EOL] sensors . append ( WaterFurnaceSensor ( client , sconfig ) ) [EOL] [EOL] add_devices ( sensors ) [EOL] [EOL] [EOL] class WaterFurnaceSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , config ) : [EOL] [docstring] [EOL] self . client = client [EOL] self . _name = config . friendly_name [EOL] self . _attr = config . field [EOL] self . _state = None [EOL] self . _icon = config . icon [EOL] self . _unit_of_measurement = config . unit_of_measurement [EOL] [EOL] [comment] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( [string] . format ( slugify ( self . client . unit ) , slugify ( self . _attr ) ) ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( UPDATE_TOPIC , self . async_update_callback ) [EOL] [EOL] @ callback def async_update_callback ( self ) : [EOL] [docstring] [EOL] if self . client . data is not None : [EOL] self . _state = getattr ( self . client . data , self . _attr , None ) [EOL] self . async_schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[homeassistant.components.sensor.waterfurnace.WFSensorConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[homeassistant.components.sensor.waterfurnace.WFSensorConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Dict , Any , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] import json [EOL] import logging [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_NAME , CONF_OFFSET , STATE_UNKNOWN ) [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] _RESOURCE = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] CONF_CURRENT_HOUR_AVERAGE = [string] [EOL] CONF_FIVE_MINUTE = [string] [EOL] CONF_MONITORED_FEEDS = [string] [EOL] CONF_SENSOR_TYPE = [string] [EOL] [EOL] SENSOR_TYPES = { CONF_FIVE_MINUTE : [ [string] , [string] ] , CONF_CURRENT_HOUR_AVERAGE : [ [string] , [string] ] , } [EOL] [EOL] TYPES_SCHEMA = vol . In ( SENSOR_TYPES ) [EOL] [EOL] SENSORS_SCHEMA = vol . Schema ( { vol . Required ( CONF_SENSOR_TYPE ) : TYPES_SCHEMA , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_OFFSET , default = [number] ) : vol . Coerce ( float ) , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MONITORED_FEEDS ) : [ SENSORS_SCHEMA ] , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] websession = async_get_clientsession ( hass ) [EOL] dev = [ ] [EOL] [EOL] for variable in config [ CONF_MONITORED_FEEDS ] : [EOL] dev . append ( ComedHourlyPricingSensor ( hass . loop , websession , variable [ CONF_SENSOR_TYPE ] , variable [ CONF_OFFSET ] , variable . get ( CONF_NAME ) ) ) [EOL] [EOL] async_add_devices ( dev , True ) [EOL] [EOL] [EOL] class ComedHourlyPricingSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , loop , websession , sensor_type , offset , name ) : [EOL] [docstring] [EOL] self . loop = loop [EOL] self . websession = websession [EOL] if name : [EOL] self . _name = name [EOL] else : [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . type = sensor_type [EOL] self . offset = offset [EOL] self . _state = None [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { ATTR_ATTRIBUTION : CONF_ATTRIBUTION } [EOL] return attrs [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] try : [EOL] if self . type == CONF_FIVE_MINUTE or self . type == CONF_CURRENT_HOUR_AVERAGE : [EOL] url_string = _RESOURCE [EOL] if self . type == CONF_FIVE_MINUTE : [EOL] url_string += [string] [EOL] else : [EOL] url_string += [string] [EOL] [EOL] with async_timeout . timeout ( [number] , loop = self . loop ) : [EOL] response = yield from self . websession . get ( url_string ) [EOL] [comment] [EOL] text = yield from response . text ( ) [EOL] data = json . loads ( text ) [EOL] self . _state = round ( float ( data [ [number] ] [ [string] ] ) + self . offset , [number] ) [EOL] [EOL] else : [EOL] self . _state = STATE_UNKNOWN [EOL] [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] except ( ValueError , KeyError ) : [EOL] _LOGGER . warning ( [string] , self . name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , STATE_UNKNOWN , CONF_TYPE , ATTR_UNIT_OF_MEASUREMENT ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import async_track_state_change [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_MIN_VALUE = [string] [EOL] ATTR_MAX_VALUE = [string] [EOL] ATTR_COUNT_SENSORS = [string] [EOL] ATTR_MEAN = [string] [EOL] ATTR_LAST = [string] [EOL] [EOL] ATTR_TO_PROPERTY = [ ATTR_COUNT_SENSORS , ATTR_MAX_VALUE , ATTR_MEAN , ATTR_MIN_VALUE , ATTR_LAST , ] [EOL] [EOL] CONF_ENTITY_IDS = [string] [EOL] CONF_ROUND_DIGITS = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] SENSOR_TYPES = { ATTR_MIN_VALUE : [string] , ATTR_MAX_VALUE : [string] , ATTR_MEAN : [string] , ATTR_LAST : [string] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_TYPE , default = SENSOR_TYPES [ ATTR_MAX_VALUE ] ) : vol . All ( cv . string , vol . In ( SENSOR_TYPES . values ( ) ) ) , vol . Optional ( CONF_NAME ) : cv . string , vol . Required ( CONF_ENTITY_IDS ) : cv . entity_ids , vol . Optional ( CONF_ROUND_DIGITS , default = [number] ) : vol . Coerce ( int ) , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] entity_ids = config . get ( CONF_ENTITY_IDS ) [EOL] name = config . get ( CONF_NAME ) [EOL] sensor_type = config . get ( CONF_TYPE ) [EOL] round_digits = config . get ( CONF_ROUND_DIGITS ) [EOL] [EOL] async_add_devices ( [ MinMaxSensor ( hass , entity_ids , name , sensor_type , round_digits ) ] , True ) [EOL] return True [EOL] [EOL] [EOL] def calc_min ( sensor_values ) : [EOL] [docstring] [EOL] val = STATE_UNKNOWN [EOL] for sval in sensor_values : [EOL] if sval != STATE_UNKNOWN : [EOL] if val == STATE_UNKNOWN or val > sval : [EOL] val = sval [EOL] return val [EOL] [EOL] [EOL] def calc_max ( sensor_values ) : [EOL] [docstring] [EOL] val = STATE_UNKNOWN [EOL] for sval in sensor_values : [EOL] if sval != STATE_UNKNOWN : [EOL] if val == STATE_UNKNOWN or val < sval : [EOL] val = sval [EOL] return val [EOL] [EOL] [EOL] def calc_mean ( sensor_values , round_digits ) : [EOL] [docstring] [EOL] val = [number] [EOL] count = [number] [EOL] for sval in sensor_values : [EOL] if sval != STATE_UNKNOWN : [EOL] val += sval [EOL] count += [number] [EOL] if count == [number] : [EOL] return STATE_UNKNOWN [EOL] return round ( val / count , round_digits ) [EOL] [EOL] [EOL] class MinMaxSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , entity_ids , name , sensor_type , round_digits ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _entity_ids = entity_ids [EOL] self . _sensor_type = sensor_type [EOL] self . _round_digits = round_digits [EOL] [EOL] if name : [EOL] self . _name = name [EOL] else : [EOL] self . _name = [string] . format ( next ( v for k , v in SENSOR_TYPES . items ( ) if self . _sensor_type == v ) ) . capitalize ( ) [EOL] self . _unit_of_measurement = None [EOL] self . _unit_of_measurement_mismatch = False [EOL] self . min_value = self . max_value = self . mean = self . last = STATE_UNKNOWN [EOL] self . count_sensors = len ( self . _entity_ids ) [EOL] self . states = { } [EOL] [EOL] @ callback [comment] [EOL] def async_min_max_sensor_state_listener ( entity , old_state , new_state ) : [EOL] [docstring] [EOL] if new_state . state is None or new_state . state in STATE_UNKNOWN : [EOL] self . states [ entity ] = STATE_UNKNOWN [EOL] hass . async_add_job ( self . async_update_ha_state , True ) [EOL] return [EOL] [EOL] if self . _unit_of_measurement is None : [EOL] self . _unit_of_measurement = new_state . attributes . get ( ATTR_UNIT_OF_MEASUREMENT ) [EOL] [EOL] if self . _unit_of_measurement != new_state . attributes . get ( ATTR_UNIT_OF_MEASUREMENT ) : [EOL] _LOGGER . warning ( [string] , self . entity_id ) [EOL] self . _unit_of_measurement_mismatch = True [EOL] [EOL] try : [EOL] self . states [ entity ] = float ( new_state . state ) [EOL] self . last = float ( new_state . state ) [EOL] except ValueError : [EOL] _LOGGER . warning ( [string] [string] ) [EOL] [EOL] hass . async_add_job ( self . async_update_ha_state , True ) [EOL] [EOL] async_track_state_change ( hass , entity_ids , async_min_max_sensor_state_listener ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _unit_of_measurement_mismatch : [EOL] return STATE_UNKNOWN [EOL] return getattr ( self , next ( k for k , v in SENSOR_TYPES . items ( ) if self . _sensor_type == v ) ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] if self . _unit_of_measurement_mismatch : [EOL] return [string] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] state_attr = { attr : getattr ( self , attr ) for attr in ATTR_TO_PROPERTY if getattr ( self , attr ) is not None } [EOL] return state_attr [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] sensor_values = [ self . states [ k ] for k in self . _entity_ids if k in self . states ] [EOL] self . min_value = calc_min ( sensor_values ) [EOL] self . max_value = calc_max ( sensor_values ) [EOL] self . mean = calc_mean ( sensor_values , self . _round_digits ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_connect [EOL] from homeassistant . components . envisalink import ( DATA_EVL , PARTITION_SCHEMA , CONF_PARTITIONNAME , EnvisalinkDevice , SIGNAL_KEYPAD_UPDATE , SIGNAL_PARTITION_UPDATE ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] configured_partitions = discovery_info [ [string] ] [EOL] [EOL] devices = [ ] [EOL] for part_num in configured_partitions : [EOL] device_config_data = PARTITION_SCHEMA ( configured_partitions [ part_num ] ) [EOL] device = EnvisalinkSensor ( hass , device_config_data [ CONF_PARTITIONNAME ] , part_num , hass . data [ DATA_EVL ] . alarm_state [ [string] ] [ part_num ] , hass . data [ DATA_EVL ] ) [EOL] devices . append ( device ) [EOL] [EOL] async_add_devices ( devices ) [EOL] [EOL] [EOL] class EnvisalinkSensor ( EnvisalinkDevice , Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , partition_name , partition_number , info , controller ) : [EOL] [docstring] [EOL] self . _icon = [string] [EOL] self . _partition_number = partition_number [EOL] [EOL] _LOGGER . debug ( [string] , partition_name ) [EOL] super ( ) . __init__ ( partition_name + [string] , info , controller ) [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] async_dispatcher_connect ( self . hass , SIGNAL_KEYPAD_UPDATE , self . _update_callback ) [EOL] async_dispatcher_connect ( self . hass , SIGNAL_PARTITION_UPDATE , self . _update_callback ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _info [ [string] ] [ [string] ] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _info [ [string] ] [EOL] [EOL] @ callback def _update_callback ( self , partition ) : [EOL] [docstring] [EOL] if partition is None or int ( partition ) == self . _partition_number : [EOL] self . async_schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import requests [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] import requests [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( TEMP_CELSIUS , CONF_NAME , STATE_UNKNOWN , ATTR_ATTRIBUTION ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] _RESOURCE = [string] [EOL] [EOL] CONF_STATION = [string] [EOL] CONF_ATTRIBUTION = [string] [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] ATTR_LOCATION = [string] [EOL] ATTR_UPDATE = [string] [EOL] ATTR_DISCHARGE = [string] [EOL] ATTR_WATERLEVEL = [string] [EOL] ATTR_DISCHARGE_MEAN = [string] [EOL] ATTR_WATERLEVEL_MEAN = [string] [EOL] ATTR_TEMPERATURE_MEAN = [string] [EOL] ATTR_DISCHARGE_MAX = [string] [EOL] ATTR_WATERLEVEL_MAX = [string] [EOL] ATTR_TEMPERATURE_MAX = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_STATION ) : vol . Coerce ( int ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import xmltodict [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] station = config . get ( CONF_STATION ) [EOL] [EOL] try : [EOL] response = requests . get ( _RESOURCE , timeout = [number] ) [EOL] if any ( str ( station ) == location . get ( [string] ) for location in xmltodict . parse ( response . text ) [ [string] ] [ [string] ] ) is False : [EOL] _LOGGER . error ( [string] , station ) [EOL] return False [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] data = HydrologicalData ( station ) [EOL] add_devices ( [ SwissHydrologicalDataSensor ( name , data ) ] , True ) [EOL] [EOL] [EOL] class SwissHydrologicalDataSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , data ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _name = name [EOL] self . _unit_of_measurement = TEMP_CELSIUS [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] if self . _state is not STATE_UNKNOWN : [EOL] return self . _unit_of_measurement [EOL] return None [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] try : [EOL] return round ( float ( self . _state ) , [number] ) [EOL] except ValueError : [EOL] return STATE_UNKNOWN [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = { } [EOL] if self . data . measurings is not None : [EOL] if [string] in self . data . measurings : [EOL] attributes [ ATTR_WATERLEVEL ] = self . data . measurings [ [string] ] [ [string] ] [EOL] attributes [ ATTR_WATERLEVEL_MEAN ] = self . data . measurings [ [string] ] [ [string] ] [EOL] attributes [ ATTR_WATERLEVEL_MAX ] = self . data . measurings [ [string] ] [ [string] ] [EOL] if [string] in self . data . measurings : [EOL] attributes [ ATTR_TEMPERATURE_MEAN ] = self . data . measurings [ [string] ] [ [string] ] [EOL] attributes [ ATTR_TEMPERATURE_MAX ] = self . data . measurings [ [string] ] [ [string] ] [EOL] if [string] in self . data . measurings : [EOL] attributes [ ATTR_DISCHARGE ] = self . data . measurings [ [string] ] [ [string] ] [EOL] attributes [ ATTR_DISCHARGE_MEAN ] = self . data . measurings [ [string] ] [ [string] ] [EOL] attributes [ ATTR_DISCHARGE_MAX ] = self . data . measurings [ [string] ] [ [string] ] [EOL] [EOL] attributes [ ATTR_LOCATION ] = self . data . measurings [ [string] ] [EOL] attributes [ ATTR_UPDATE ] = self . data . measurings [ [string] ] [EOL] attributes [ ATTR_ATTRIBUTION ] = CONF_ATTRIBUTION [EOL] return attributes [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] if self . data . measurings is not None : [EOL] if [string] not in self . data . measurings : [EOL] self . _state = STATE_UNKNOWN [EOL] else : [EOL] self . _state = self . data . measurings [ [string] ] [ [string] ] [EOL] [EOL] [EOL] class HydrologicalData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , station ) : [EOL] [docstring] [EOL] self . station = station [EOL] self . measurings = None [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] import xmltodict [EOL] [EOL] details = { } [EOL] try : [EOL] response = requests . get ( _RESOURCE , timeout = [number] ) [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] , _RESOURCE ) [EOL] [EOL] try : [EOL] stations = xmltodict . parse ( response . text ) [ [string] ] [ [string] ] [EOL] [comment] [EOL] for station in stations : [EOL] if str ( self . station ) != station . get ( [string] ) : [EOL] continue [EOL] for data in [ [string] , [string] , [string] ] : [EOL] if data != station . get ( [string] ) : [EOL] continue [EOL] values = station . get ( [string] ) [EOL] if values is not None : [EOL] details [ data ] = { [string] : values [ [number] ] , [string] : list ( values [ [number] ] . items ( ) ) [ [number] ] [ [number] ] , [string] : list ( values [ [number] ] . items ( ) ) [ [number] ] [ [number] ] } [EOL] [EOL] details [ [string] ] = station . get ( [string] ) [EOL] details [ [string] ] = station . get ( [string] ) [EOL] [EOL] self . measurings = details [EOL] except AttributeError : [EOL] self . measurings = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] import re [EOL] from datetime import datetime , timedelta [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_MODE [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_ATCOCODE = [string] [EOL] ATTR_LOCALITY = [string] [EOL] ATTR_STOP_NAME = [string] [EOL] ATTR_REQUEST_TIME = [string] [EOL] ATTR_NEXT_BUSES = [string] [EOL] ATTR_STATION_CODE = [string] [EOL] ATTR_CALLING_AT = [string] [EOL] ATTR_NEXT_TRAINS = [string] [EOL] [EOL] CONF_API_APP_KEY = [string] [EOL] CONF_API_APP_ID = [string] [EOL] CONF_QUERIES = [string] [EOL] CONF_ORIGIN = [string] [EOL] CONF_DESTINATION = [string] [EOL] [EOL] _QUERY_SCHEME = vol . Schema ( { vol . Required ( CONF_MODE ) : vol . All ( cv . ensure_list , [ vol . In ( list ( [ [string] , [string] ] ) ) ] ) , vol . Required ( CONF_ORIGIN ) : cv . string , vol . Required ( CONF_DESTINATION ) : cv . string , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_APP_ID ) : cv . string , vol . Required ( CONF_API_APP_KEY ) : cv . string , vol . Required ( CONF_QUERIES ) : [ _QUERY_SCHEME ] , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] sensors = [ ] [EOL] number_sensors = len ( config . get ( CONF_QUERIES ) ) [EOL] interval = timedelta ( seconds = [number] * number_sensors ) [EOL] [EOL] for query in config . get ( CONF_QUERIES ) : [EOL] if [string] in query . get ( CONF_MODE ) : [EOL] stop_atcocode = query . get ( CONF_ORIGIN ) [EOL] bus_direction = query . get ( CONF_DESTINATION ) [EOL] sensors . append ( UkTransportLiveBusTimeSensor ( config . get ( CONF_API_APP_ID ) , config . get ( CONF_API_APP_KEY ) , stop_atcocode , bus_direction , interval ) ) [EOL] [EOL] elif [string] in query . get ( CONF_MODE ) : [EOL] station_code = query . get ( CONF_ORIGIN ) [EOL] calling_at = query . get ( CONF_DESTINATION ) [EOL] sensors . append ( UkTransportLiveTrainTimeSensor ( config . get ( CONF_API_APP_ID ) , config . get ( CONF_API_APP_KEY ) , station_code , calling_at , interval ) ) [EOL] [EOL] add_devices ( sensors , True ) [EOL] [EOL] [EOL] class UkTransportSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] TRANSPORT_API_URL_BASE = [string] [EOL] ICON = [string] [EOL] [EOL] def __init__ ( self , name , api_app_id , api_app_key , url ) : [EOL] [docstring] [EOL] self . _data = { } [EOL] self . _api_app_id = api_app_id [EOL] self . _api_app_key = api_app_key [EOL] self . _url = self . TRANSPORT_API_URL_BASE + url [EOL] self . _name = name [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . ICON [EOL] [EOL] def _do_api_request ( self , params ) : [EOL] [docstring] [EOL] request_params = dict ( { [string] : self . _api_app_id , [string] : self . _api_app_key , } , ** params ) [EOL] [EOL] response = requests . get ( self . _url , params = request_params ) [EOL] if response . status_code != [number] : [EOL] _LOGGER . warning ( [string] ) [EOL] elif [string] in response . json ( ) : [EOL] if [string] in response . json ( ) [ [string] ] : [EOL] self . _state = [string] [EOL] if [string] in response . json ( ) [ [string] ] : [EOL] self . _state = [string] [EOL] else : [EOL] self . _data = response . json ( ) [EOL] [EOL] [EOL] class UkTransportLiveBusTimeSensor ( UkTransportSensor ) : [EOL] [docstring] [EOL] [EOL] ICON = [string] [EOL] [EOL] def __init__ ( self , api_app_id , api_app_key , stop_atcocode , bus_direction , interval ) : [EOL] [docstring] [EOL] self . _stop_atcocode = stop_atcocode [EOL] self . _bus_direction = bus_direction [EOL] self . _next_buses = [ ] [EOL] self . _destination_re = re . compile ( [string] . format ( bus_direction ) , re . IGNORECASE ) [EOL] [EOL] sensor_name = [string] . format ( bus_direction ) [EOL] stop_url = [string] . format ( stop_atcocode ) [EOL] [EOL] UkTransportSensor . __init__ ( self , sensor_name , api_app_id , api_app_key , stop_url ) [EOL] self . update = Throttle ( interval ) ( self . _update ) [EOL] [EOL] def _update ( self ) : [EOL] [docstring] [EOL] params = { [string] : [string] , [string] : [string] } [EOL] [EOL] self . _do_api_request ( params ) [EOL] [EOL] if self . _data != { } : [EOL] self . _next_buses = [ ] [EOL] [EOL] for ( route , departures ) in self . _data [ [string] ] . items ( ) : [EOL] for departure in departures : [EOL] if self . _destination_re . search ( departure [ [string] ] ) : [EOL] self . _next_buses . append ( { [string] : route , [string] : departure [ [string] ] , [string] : departure [ [string] ] , [string] : departure [ [string] ] } ) [EOL] [EOL] if self . _next_buses : [EOL] self . _state = min ( _delta_mins ( bus [ [string] ] ) for bus in self . _next_buses ) [EOL] else : [EOL] self . _state = None [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { } [EOL] if self . _data is not None : [EOL] for key in [ ATTR_ATCOCODE , ATTR_LOCALITY , ATTR_STOP_NAME , ATTR_REQUEST_TIME ] : [EOL] attrs [ key ] = self . _data . get ( key ) [EOL] attrs [ ATTR_NEXT_BUSES ] = self . _next_buses [EOL] return attrs [EOL] [EOL] [EOL] class UkTransportLiveTrainTimeSensor ( UkTransportSensor ) : [EOL] [docstring] [EOL] [EOL] ICON = [string] [EOL] [EOL] def __init__ ( self , api_app_id , api_app_key , station_code , calling_at , interval ) : [EOL] [docstring] [EOL] self . _station_code = station_code [EOL] self . _calling_at = calling_at [EOL] self . _next_trains = [ ] [EOL] [EOL] sensor_name = [string] . format ( calling_at ) [EOL] query_url = [string] . format ( station_code ) [EOL] [EOL] UkTransportSensor . __init__ ( self , sensor_name , api_app_id , api_app_key , query_url ) [EOL] self . update = Throttle ( interval ) ( self . _update ) [EOL] [EOL] def _update ( self ) : [EOL] [docstring] [EOL] params = { [string] : [string] , [string] : self . _calling_at , [string] : [string] } [EOL] [EOL] self . _do_api_request ( params ) [EOL] self . _next_trains = [ ] [EOL] [EOL] if self . _data != { } : [EOL] if self . _data [ [string] ] [ [string] ] == [ ] : [EOL] self . _state = [string] [EOL] else : [EOL] for departure in self . _data [ [string] ] [ [string] ] : [EOL] self . _next_trains . append ( { [string] : departure [ [string] ] , [string] : departure [ [string] ] , [string] : departure [ [string] ] , [string] : departure [ [string] ] , [string] : departure [ [string] ] , [string] : departure [ [string] ] , [string] : departure [ [string] ] } ) [EOL] [EOL] if self . _next_trains : [EOL] self . _state = min ( _delta_mins ( train [ [string] ] ) for train in self . _next_trains ) [EOL] else : [EOL] self . _state = None [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { } [EOL] if self . _data is not None : [EOL] attrs [ ATTR_STATION_CODE ] = self . _station_code [EOL] attrs [ ATTR_CALLING_AT ] = self . _calling_at [EOL] if self . _next_trains : [EOL] attrs [ ATTR_NEXT_TRAINS ] = self . _next_trains [EOL] return attrs [EOL] [EOL] [EOL] def _delta_mins ( hhmm_time_str ) : [EOL] [docstring] [EOL] now = datetime . now ( ) [EOL] hhmm_time = datetime . strptime ( hhmm_time_str , [string] ) [EOL] [EOL] hhmm_datetime = datetime ( now . year , now . month , now . day , hour = hhmm_time . hour , minute = hhmm_time . minute ) [EOL] if hhmm_datetime < now : [EOL] hhmm_datetime += timedelta ( days = [number] ) [EOL] [EOL] delta_mins = ( hhmm_datetime - now ) . seconds // [number] [EOL] return delta_mins [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import homeassistant [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import requests . exceptions [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_API_KEY ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_API_SECRET = [string] [EOL] CONF_SENSOR_ID = [string] [EOL] [EOL] ACTIVE_NAME = [string] [EOL] DAILY_NAME = [string] [EOL] [EOL] ACTIVE_TYPE = [string] [EOL] DAILY_TYPE = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] MIN_TIME_BETWEEN_DAILY_UPDATES = timedelta ( seconds = [number] ) [EOL] MIN_TIME_BETWEEN_ACTIVE_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_API_SECRET ) : cv . string , vol . Optional ( CONF_SENSOR_ID ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] api_key = config . get ( CONF_API_KEY ) [EOL] api_secret = config . get ( CONF_API_SECRET ) [EOL] sensor_id = config . get ( CONF_SENSOR_ID ) [EOL] [EOL] data = NeurioData ( api_key , api_secret , sensor_id ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_DAILY_UPDATES ) def update_daily ( ) : [EOL] [docstring] [EOL] data . get_daily_usage ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_ACTIVE_UPDATES ) def update_active ( ) : [EOL] [docstring] [EOL] data . get_active_power ( ) [EOL] [EOL] update_daily ( ) [EOL] update_active ( ) [EOL] [EOL] [comment] [EOL] add_devices ( [ NeurioEnergy ( data , ACTIVE_NAME , ACTIVE_TYPE , update_active ) ] ) [EOL] [comment] [EOL] add_devices ( [ NeurioEnergy ( data , DAILY_NAME , DAILY_TYPE , update_daily ) ] ) [EOL] [EOL] [EOL] class NeurioData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_key , api_secret , sensor_id ) : [EOL] [docstring] [EOL] import neurio [EOL] [EOL] self . api_key = api_key [EOL] self . api_secret = api_secret [EOL] self . sensor_id = sensor_id [EOL] [EOL] self . _daily_usage = None [EOL] self . _active_power = None [EOL] [EOL] self . _state = None [EOL] [EOL] neurio_tp = neurio . TokenProvider ( key = api_key , secret = api_secret ) [EOL] self . neurio_client = neurio . Client ( token_provider = neurio_tp ) [EOL] [EOL] if not self . sensor_id : [EOL] user_info = self . neurio_client . get_user_information ( ) [EOL] _LOGGER . warning ( [string] , user_info [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] ) [EOL] self . sensor_id = user_info [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] [EOL] [EOL] @ property def daily_usage ( self ) : [EOL] [docstring] [EOL] return self . _daily_usage [EOL] [EOL] @ property def active_power ( self ) : [EOL] [docstring] [EOL] return self . _active_power [EOL] [EOL] def get_active_power ( self ) : [EOL] [docstring] [EOL] try : [EOL] sample = self . neurio_client . get_samples_live_last ( self . sensor_id ) [EOL] self . _active_power = sample [ [string] ] [EOL] except ( requests . exceptions . RequestException , ValueError , KeyError ) : [EOL] _LOGGER . warning ( [string] ) [EOL] return None [EOL] [EOL] def get_daily_usage ( self ) : [EOL] [docstring] [EOL] kwh = [number] [EOL] start_time = dt_util . start_of_local_day ( ) . astimezone ( dt_util . UTC ) . isoformat ( ) [EOL] end_time = dt_util . utcnow ( ) . isoformat ( ) [EOL] [EOL] _LOGGER . debug ( [string] , start_time , end_time ) [EOL] [EOL] try : [EOL] history = self . neurio_client . get_samples_stats ( self . sensor_id , start_time , [string] , end_time ) [EOL] except ( requests . exceptions . RequestException , ValueError , KeyError ) : [EOL] _LOGGER . warning ( [string] ) [EOL] return None [EOL] [EOL] for result in history : [EOL] kwh += result [ [string] ] / [number] [EOL] [EOL] self . _daily_usage = round ( kwh , [number] ) [EOL] [EOL] [EOL] class NeurioEnergy ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , name , sensor_type , update_call ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _data = data [EOL] self . _sensor_type = sensor_type [EOL] self . update_sensor = update_call [EOL] self . _state = None [EOL] [EOL] if sensor_type == ACTIVE_TYPE : [EOL] self . _unit_of_measurement = [string] [EOL] elif sensor_type == DAILY_TYPE : [EOL] self . _unit_of_measurement = [string] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . update_sensor ( ) [EOL] [EOL] if self . _sensor_type == ACTIVE_TYPE : [EOL] self . _state = self . _data . active_power [EOL] elif self . _sensor_type == DAILY_TYPE : [EOL] self . _state = self . _data . daily_usage [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import track_time_interval [EOL] from homeassistant . const import ( CONF_NAME , CONF_ID , CONF_URL , CONF_CURRENCY ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ITEMS = [string] [EOL] [EOL] ICON = [string] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] * [number] * [number] ) [comment] [EOL] MIN_TIME_BETWEEN_CURRENCY_UPDATES = timedelta ( seconds = [number] * [number] * [number] ) [comment] [EOL] [EOL] [EOL] _ITEM_SCHEMA = vol . All ( vol . Schema ( { vol . Exclusive ( CONF_URL , [string] ) : cv . string , vol . Exclusive ( CONF_ID , [string] ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_CURRENCY ) : cv . string } ) , cv . has_at_least_one_key ( CONF_URL , CONF_ID ) ) [EOL] [EOL] _ITEMS_SCHEMA = vol . Schema ( [ _ITEM_SCHEMA ] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ITEMS ) : _ITEMS_SCHEMA , vol . Required ( CONF_CURRENCY ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from gearbest_parser import CurrencyConverter [EOL] currency = config . get ( CONF_CURRENCY ) [EOL] [EOL] sensors = [ ] [EOL] items = config . get ( CONF_ITEMS ) [EOL] [EOL] converter = CurrencyConverter ( ) [EOL] converter . update ( ) [EOL] [EOL] for item in items : [EOL] try : [EOL] sensors . append ( GearbestSensor ( converter , item , currency ) ) [EOL] except ValueError as exc : [EOL] _LOGGER . error ( exc ) [EOL] [EOL] def currency_update ( event_time ) : [EOL] [docstring] [EOL] converter . update ( ) [EOL] [EOL] track_time_interval ( hass , currency_update , MIN_TIME_BETWEEN_CURRENCY_UPDATES ) [EOL] [EOL] add_devices ( sensors , True ) [EOL] [EOL] [EOL] class GearbestSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , converter , item , currency ) : [EOL] [docstring] [EOL] from gearbest_parser import GearbestParser [EOL] [EOL] self . _name = item . get ( CONF_NAME ) [EOL] self . _parser = GearbestParser ( ) [EOL] self . _parser . set_currency_converter ( converter ) [EOL] self . _item = self . _parser . load ( item . get ( CONF_ID ) , item . get ( CONF_URL ) , item . get ( CONF_CURRENCY , currency ) ) [EOL] if self . _item is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name if self . _name is not None else self . _item . name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _item . price [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _item . currency [EOL] [EOL] @ property def entity_picture ( self ) : [EOL] [docstring] [EOL] return self . _item . image [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { [string] : self . _item . name , [string] : self . _item . description , [string] : self . _item . currency , [string] : self . _item . url } [EOL] return attrs [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] self . _item . update ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0