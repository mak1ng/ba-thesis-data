from typing import Any [EOL] import typing [EOL] from math import ceil [EOL] [EOL] [EOL] def median_up_to_5 ( array , start , end ) : [EOL] [docstring] [EOL] [EOL] assert [number] <= start <= end < len ( array ) [EOL] assert start <= end <= start + [number] [EOL] [EOL] quicksort ( array , start , end ) [EOL] return ceil ( ( end + start ) / [number] ) [EOL] [EOL] [EOL] def average_pivot ( array , start , end ) : [EOL] [docstring] [EOL] [EOL] assert [number] <= start <= end < len ( array ) [EOL] [EOL] return ( end + start ) // [number] [EOL] [EOL] [EOL] def partition ( array , start , end , pivot_index ) : [EOL] [docstring] [EOL] [EOL] assert [number] <= start <= pivot_index <= end < len ( array ) [EOL] [EOL] pivot_value = array [ pivot_index ] [EOL] [comment] [EOL] array [ end ] , array [ pivot_index ] = array [ pivot_index ] , array [ end ] [EOL] [EOL] i , j = start , end [EOL] while i < j : [EOL] [comment] [EOL] while array [ i ] < pivot_value : [EOL] i += [number] [EOL] [comment] [EOL] while array [ j ] >= pivot_value and i < j : [EOL] j -= [number] [EOL] if i < j : [EOL] [comment] [EOL] array [ i ] , array [ j ] = array [ j ] , array [ i ] [EOL] i += [number] [EOL] [EOL] [comment] [EOL] array [ j ] , array [ end ] = array [ end ] , array [ j ] [EOL] return j [EOL] [EOL] [EOL] def quicksort ( array , start = None , end = None , pivot_fn = average_pivot ) : [EOL] [docstring] [EOL] [EOL] start = [number] if start is None else start [EOL] end = len ( array ) - [number] if end is None else end [EOL] [EOL] if end <= start : [EOL] return [EOL] [EOL] pivot_index = pivot_fn ( array , start , end ) [EOL] pivot_index = partition ( array , start , end , pivot_index ) [EOL] [EOL] [comment] [EOL] if pivot_index - [number] - start <= end - pivot_index + [number] : [comment] [EOL] quicksort ( array , start , pivot_index - [number] , pivot_fn ) [EOL] quicksort ( array , pivot_index + [number] , end , pivot_fn ) [comment] [EOL] [comment] [EOL] quicksort ( array , pivot_index + [number] , end , pivot_fn ) [EOL] quicksort ( array , start , pivot_index - [number] , pivot_fn ) [comment] [EOL] [EOL] [EOL] def quickselect ( array , k , pivot_fn = average_pivot ) : [EOL] [docstring] [EOL] [EOL] assert [number] <= k <= len ( array ) [EOL] [EOL] return array [ _quickselect ( array , k , pivot_fn , [number] , len ( array ) - [number] ) ] [EOL] [EOL] [EOL] def _quickselect ( array , k , pivot_fn , start , end ) : [EOL] [docstring] [EOL] [EOL] if start == end : [EOL] return start [EOL] [EOL] pivot_index = pivot_fn ( array , start , end ) [EOL] pivot_index = partition ( array , start , end , pivot_index ) [EOL] [EOL] if k == pivot_index + [number] : [EOL] return pivot_index [EOL] elif k < pivot_index + [number] : [EOL] [comment] [EOL] return _quickselect ( array , k , pivot_fn , start , pivot_index - [number] ) [EOL] [comment] [EOL] return _quickselect ( array , k , pivot_fn , pivot_index + [number] , end ) [EOL] [EOL] [EOL] def median_of_medians_pivot ( array , start , end ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if end - start < [number] : [EOL] return median_up_to_5 ( array , start , end ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( start , end , [number] ) : [EOL] [comment] [EOL] sub_right = min ( i + [number] , end ) [EOL] [EOL] [comment] [EOL] median = median_up_to_5 ( array , i , sub_right ) [EOL] [EOL] [comment] [EOL] new_pos = start + int ( ( i - start ) / [number] ) [EOL] array [ median ] , array [ new_pos ] = array [ new_pos ] , array [ median ] [EOL] [EOL] medians_number = ceil ( ( end - start + [number] ) / [number] ) [comment] [EOL] last_median_pos = start + medians_number - [number] [EOL] [EOL] [comment] [EOL] median_of_medians_pos = ceil ( ( start + last_median_pos ) / [number] ) [EOL] return _quickselect ( array , median_of_medians_pos , median_of_medians_pivot , start , last_median_pos ) [EOL] [EOL] [EOL] def median_of_medians ( array , k ) : [EOL] [docstring] [EOL] [EOL] assert [number] <= k <= len ( array ) [EOL] [EOL] return quickselect ( array , k , median_of_medians_pivot ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any , Literal [EOL] import typing [EOL] import typing_extensions [EOL] import random [EOL] import unittest [EOL] [EOL] from algorithms import median_of_medians , partition , quickselect , quicksort [EOL] [EOL] [EOL] class TestPartition ( unittest . TestCase ) : [EOL] [EOL] def test_partition ( self ) : [EOL] array = [ ] [EOL] with self . assertRaises ( AssertionError ) : [EOL] partition ( array , [number] , [number] , [number] ) [EOL] [EOL] array = [ [number] ] [EOL] partitioning = [ [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] ] [EOL] partitioning = [ [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] ] [EOL] partitioning = [ [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] ] [EOL] partitioning = [ [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] ] [EOL] partitioning = [ [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] , [number] ] [EOL] partitioning = [ [number] , [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] , [number] ] [EOL] partitioning = [ [number] , [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] , [number] ] [EOL] partitioning = [ [number] , [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] , [number] ] [EOL] partitioning = [ [number] , [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] , [number] ] [EOL] partitioning = [ [number] , [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] , [number] ] [EOL] partitioning = [ [number] , [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] , [number] , [number] ] [EOL] partitioning = [ [number] , [number] , [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] , [number] , [number] ] [EOL] partitioning = [ [number] , [number] , [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] , [number] , [number] ] [EOL] partitioning = [ [number] , [number] , [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] array = [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] partitioning = [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] k = partition ( array , [number] , [number] , [number] ) [comment] [EOL] self . assertEqual ( k , [number] , [string] . format ( k , array ) ) [EOL] self . assertEqual ( array , partitioning , [string] . format ( array , partitioning ) ) [EOL] [EOL] [EOL] class TestQuicksort ( unittest . TestCase ) : [EOL] [EOL] def test_quicksort ( self ) : [EOL] random . seed ( [number] ) [EOL] max_length = [number] [EOL] repetitions_per_length = [number] [EOL] int_range = ( - [number] , [number] ) [EOL] [EOL] [comment] [EOL] for length in range ( max_length + [number] ) : [EOL] for _ in range ( length * repetitions_per_length ) : [EOL] array = [ random . randint ( * int_range ) for _ in range ( length ) ] [EOL] array_rep = str ( array ) [EOL] array_copy = array . copy ( ) [EOL] quicksort ( array ) [EOL] array_copy . sort ( ) [EOL] self . assertEqual ( array , array_copy , [string] . format ( array_rep ) ) [EOL] [EOL] [EOL] class TestQuickselect ( unittest . TestCase ) : [EOL] [EOL] def test_quickselect ( self ) : [EOL] random . seed ( [number] ) [EOL] max_length = [number] [EOL] repetitions_per_length = [number] [EOL] int_range = ( - [number] , [number] ) [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] quickselect ( [ [number] ] , [number] ) [comment] [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] quickselect ( [ [number] ] , [number] ) [comment] [EOL] [EOL] [comment] [EOL] for length in range ( max_length + [number] ) : [EOL] for _ in range ( length * repetitions_per_length ) : [EOL] for j in range ( [number] , length + [number] ) : [comment] [EOL] array = [ random . randint ( * int_range ) for _ in range ( length ) ] [EOL] array_rep = str ( array ) [EOL] array_copy = array . copy ( ) [EOL] array_copy . sort ( ) [EOL] self . assertEqual ( quickselect ( array , j ) , array_copy [ j - [number] ] , [string] . format ( j , array_rep ) ) [EOL] [EOL] [EOL] class TestMedianOfMedians ( unittest . TestCase ) : [EOL] [EOL] def test_median_of_medians ( self ) : [EOL] random . seed ( [number] ) [EOL] max_length = [number] [EOL] repetitions_per_length = [number] [EOL] int_range = ( - [number] , [number] ) [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] median_of_medians ( [ [number] ] , [number] ) [comment] [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] median_of_medians ( [ [number] ] , [number] ) [comment] [EOL] [EOL] [comment] [EOL] for length in range ( max_length + [number] ) : [EOL] for _ in range ( length * repetitions_per_length ) : [EOL] for j in range ( [number] , length + [number] ) : [comment] [EOL] array = [ random . randint ( * int_range ) for _ in range ( length ) ] [EOL] array_rep = str ( array ) [EOL] array_copy = array . copy ( ) [EOL] array_copy . sort ( ) [EOL] self . assertEqual ( median_of_medians ( array , j ) , array_copy [ j - [number] ] , [string] . format ( j , array_rep ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( verbosity = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Tuple[typing_extensions.Literal[-50],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal[-50],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Tuple[typing_extensions.Literal[-50],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal[-50],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Tuple[typing_extensions.Literal[-50],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal[-50],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Type , Deque , Optional , Callable [EOL] import typing [EOL] import builtins [EOL] from collections import defaultdict [EOL] from math import ceil [EOL] from collections import deque [EOL] from typing import Callable , Deque , Dict , List , Optional [EOL] [EOL] [EOL] ItemType = int [EOL] [EOL] def counting_sort ( array , key_fn ) : [EOL] [docstring] [EOL] [EOL] counts = defaultdict ( int ) [comment] [EOL] k = [number] [EOL] for i in array : [EOL] key_value = key_fn ( i ) [EOL] counts [ key_value ] += [number] [EOL] k = max ( k , key_value ) [EOL] [EOL] total = [number] [EOL] for i in range ( k + [number] ) : [EOL] old_count = counts [ i ] [EOL] counts [ i ] = total [EOL] total += old_count [EOL] [EOL] sorted_array = array . copy ( ) [EOL] for i in array : [EOL] key_value = key_fn ( i ) [EOL] sorted_array [ counts [ key_value ] ] = i [EOL] counts [ key_value ] += [number] [EOL] [EOL] return sorted_array [EOL] [EOL] [EOL] def merge_sort ( array , start = None , end = None ) : [EOL] [docstring] [EOL] [EOL] start = [number] if start is None else start [EOL] end = len ( array ) - [number] if end is None else end [EOL] [EOL] if start == end : [EOL] return [EOL] [EOL] half = ( start + end ) // [number] [EOL] merge_sort ( array , start , half ) [EOL] merge_sort ( array , half + [number] , end ) [EOL] merge_adjacent_runs ( array , start , half , end ) [EOL] [EOL] [EOL] def merge_adjacent_runs ( array , start , half , end ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] aux = deque ( ) [EOL] [comment] [EOL] [comment] [EOL] aux . append ( array [ start ] ) [EOL] [EOL] i , j = start , half + [number] [EOL] curr = start [EOL] while len ( aux ) > [number] and j <= end : [EOL] if aux [ [number] ] <= array [ j ] : [EOL] [comment] [EOL] array [ curr ] = aux . popleft ( ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] array [ curr ] = array [ j ] [EOL] j += [number] [EOL] [comment] [EOL] [comment] [EOL] if i < half : [EOL] [comment] [EOL] i += [number] [EOL] aux . append ( array [ i ] ) [EOL] curr += [number] [EOL] [EOL] [comment] [EOL] while len ( aux ) > [number] : [EOL] array [ curr ] = aux . popleft ( ) [EOL] curr += [number] [EOL] [EOL] [comment] [EOL] for j in range ( j , end ) : [EOL] array [ curr ] = array [ j ] [EOL] curr += [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List [EOL] import design_patterns [EOL] import builtins [EOL] import typing [EOL] import abc [EOL] [EOL] from typing import cast , List , Optional [EOL] [EOL] [EOL] class VolumeController : [comment] [EOL] [EOL] def __init__ ( self , min_volume , max_volume ) : [EOL] self . min_volume = min_volume [EOL] self . max_volume = max_volume [EOL] self . curr_volume = ( max_volume + min_volume ) // [number] [EOL] [EOL] def raise_volume ( self , increase ) : [EOL] assert increase >= [number] [EOL] self . curr_volume = min ( self . curr_volume + increase , self . max_volume ) [EOL] [EOL] def decrease_volume ( self , decrease ) : [EOL] assert decrease >= [number] [EOL] self . curr_volume = max ( self . curr_volume - decrease , self . min_volume ) [EOL] [EOL] def boost_volume ( self ) : [EOL] self . curr_volume = self . max_volume [EOL] [EOL] def mute_volume ( self ) : [EOL] self . curr_volume = self . min_volume [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . curr_volume ) [EOL] [EOL] [EOL] class VolumeCommand ( abc . ABC ) : [comment] [EOL] [EOL] def __init__ ( self , receiver ) : [EOL] self . receiver = receiver [EOL] [EOL] @ abc . abstractmethod def do_action ( self ) : [EOL] pass [EOL] [EOL] [EOL] class UndoableVolumeCommand ( VolumeCommand ) : [comment] [EOL] [EOL] def __init__ ( self , command ) : [EOL] super ( ) . __init__ ( command . receiver ) [EOL] self . command = command [EOL] [EOL] @ abc . abstractmethod def undo_action ( self ) : [EOL] pass [EOL] [EOL] [EOL] class SingleUndoCommand ( UndoableVolumeCommand ) : [comment] [EOL] [EOL] def __init__ ( self , command ) : [EOL] super ( ) . __init__ ( command ) [EOL] self . prev_state = None [EOL] [EOL] def do_action ( self ) : [EOL] self . prev_state = self . receiver . curr_volume [EOL] self . command . do_action ( ) [EOL] [EOL] def undo_action ( self ) : [EOL] if self . prev_state == None : [EOL] raise RuntimeError ( [string] ) [EOL] assert isinstance ( self . prev_state , int ) [EOL] self . receiver . curr_volume = self . prev_state [EOL] self . prev_state = None [EOL] [EOL] [EOL] class RaiseVolumeCommand ( VolumeCommand ) : [comment] [EOL] [EOL] def __init__ ( self , receiver , increment ) : [EOL] super ( ) . __init__ ( receiver ) [EOL] self . increment = increment [EOL] [EOL] def do_action ( self ) : [EOL] self . receiver . raise_volume ( self . increment ) [EOL] if self . receiver . curr_volume == self . receiver . max_volume : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class DecreaseVolumeCommand ( VolumeCommand ) : [comment] [EOL] [EOL] def __init__ ( self , receiver , decrement ) : [EOL] super ( ) . __init__ ( receiver ) [EOL] self . decrement = decrement [EOL] [EOL] def do_action ( self ) : [EOL] self . receiver . decrease_volume ( self . decrement ) [EOL] if self . receiver . curr_volume == self . receiver . min_volume : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class BoostVolumeCommand ( VolumeCommand ) : [comment] [EOL] [EOL] def __init__ ( self , receiver ) : [EOL] super ( ) . __init__ ( receiver ) [EOL] [EOL] def do_action ( self ) : [EOL] self . receiver . boost_volume ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] class MuteVolumeCommand ( VolumeCommand ) : [comment] [EOL] [EOL] def __init__ ( self , receiver ) : [EOL] super ( ) . __init__ ( receiver ) [EOL] [EOL] def do_action ( self ) : [EOL] self . receiver . mute_volume ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] class GUIButton : [comment] [EOL] [EOL] def __init__ ( self , label , command ) : [EOL] self . label = label [EOL] self . command = command [EOL] [EOL] def on_click ( self ) : [EOL] print ( [string] . format ( self . label ) ) [EOL] self . command . do_action ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . label [EOL] [EOL] [EOL] class UndoableGUIButton ( GUIButton ) : [comment] [EOL] [EOL] def __init__ ( self , label , command ) : [EOL] super ( ) . __init__ ( label , command ) [EOL] [EOL] def cancel ( self ) : [EOL] assert isinstance ( self . command , UndoableVolumeCommand ) [EOL] print ( [string] . format ( self . label ) ) [EOL] self . command . undo_action ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . label ) [EOL] [EOL] [EOL] class VolumeControlGUI : [comment] [EOL] [EOL] def __init__ ( self ) : [EOL] self . buttons = [ ] [EOL] self . last_index = None [EOL] [EOL] def add_button ( self , button ) : [EOL] self . buttons . append ( button ) [EOL] [EOL] def click ( self , i ) : [EOL] self . buttons [ i ] . on_click ( ) [EOL] self . last_index = i [EOL] [EOL] def cancel ( self ) : [EOL] if self . last_index == None or cast ( int , self . last_index ) >= len ( self . buttons ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] last_button = self . buttons [ cast ( int , self . last_index ) ] [EOL] if isinstance ( last_button , UndoableGUIButton ) : [EOL] last_button . cancel ( ) [EOL] self . last_button = None [EOL] else : [EOL] print ( [string] . format ( last_button ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . buttons ) [EOL] [EOL] [EOL] def main ( ) : [EOL] volume_controller = VolumeController ( [number] , [number] ) [EOL] volume_controller_gui = VolumeControlGUI ( ) [EOL] [EOL] add_30_command = RaiseVolumeCommand ( volume_controller , [number] ) [EOL] add_30_button = UndoableGUIButton ( [string] , SingleUndoCommand ( add_30_command ) ) [EOL] volume_controller_gui . add_button ( add_30_button ) [EOL] [EOL] sub_30_command = DecreaseVolumeCommand ( volume_controller , [number] ) [EOL] sub_30_button = UndoableGUIButton ( [string] , SingleUndoCommand ( sub_30_command ) ) [EOL] volume_controller_gui . add_button ( sub_30_button ) [EOL] [EOL] boost_command = BoostVolumeCommand ( volume_controller ) [EOL] boost_button = GUIButton ( [string] , boost_command ) [EOL] volume_controller_gui . add_button ( boost_button ) [EOL] [EOL] mute_command = MuteVolumeCommand ( volume_controller ) [EOL] mute_button = GUIButton ( [string] , mute_command ) [EOL] volume_controller_gui . add_button ( mute_button ) [EOL] [EOL] print ( volume_controller_gui ) [EOL] [comment] [EOL] print ( volume_controller ) [EOL] [comment] [EOL] volume_controller_gui . click ( [number] ) [EOL] [comment] [EOL] print ( volume_controller ) [EOL] [comment] [EOL] volume_controller_gui . click ( [number] ) [EOL] [comment] [EOL] [comment] [EOL] print ( volume_controller ) [EOL] [comment] [EOL] volume_controller_gui . cancel ( ) [EOL] [comment] [EOL] print ( volume_controller ) [EOL] [comment] [EOL] volume_controller_gui . click ( [number] ) [EOL] [comment] [EOL] [comment] [EOL] print ( volume_controller ) [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $design_patterns.mix.command_decorator_mixer.VolumeController$ 0 0 0 0 0 $design_patterns.mix.command_decorator_mixer.VolumeController$ 0 $design_patterns.mix.command_decorator_mixer.VolumeController$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $design_patterns.mix.command_decorator_mixer.VolumeCommand$ 0 0 0 0 0 0 0 0 0 $design_patterns.mix.command_decorator_mixer.VolumeCommand$ 0 0 0 0 0 0 $design_patterns.mix.command_decorator_mixer.VolumeCommand$ 0 $design_patterns.mix.command_decorator_mixer.VolumeCommand$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $VolumeCommand$ 0 0 0 0 0 0 0 0 0 $VolumeCommand$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $VolumeController$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $VolumeController$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $VolumeController$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $VolumeController$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $VolumeController$ 0 0 0 0 0 0 0 0 0 $VolumeController$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $VolumeController$ 0 0 0 0 0 0 0 0 0 $VolumeController$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $design_patterns.mix.command_decorator_mixer.VolumeCommand$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $design_patterns.mix.command_decorator_mixer.VolumeCommand$ 0 $design_patterns.mix.command_decorator_mixer.VolumeCommand$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $UndoableVolumeCommand$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $UndoableVolumeCommand$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[GUIButton]$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $None$ 0 0 0 $GUIButton$ 0 0 0 0 0 0 0 0 0 $GUIButton$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Type , Generator [EOL] import typing [EOL] import design_patterns [EOL] import builtins [EOL] import abc [EOL] [EOL] from typing import Dict , Generator , List [EOL] [EOL] NodeId = int [EOL] NodeValue = str [EOL] [EOL] [EOL] class Node : [EOL] curr_id = [number] [EOL] [EOL] def __init__ ( self , value ) : [EOL] self . node_id = Node . curr_id [EOL] self . value = value [EOL] Node . curr_id += [number] [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . value , self . node_id ) [EOL] [EOL] [EOL] class Graph : [EOL] [EOL] def __init__ ( self ) : [EOL] self . nodes = { } [EOL] self . adjacents = { } [EOL] [EOL] def add_node ( self , node ) : [EOL] self . nodes [ node . node_id ] = node [EOL] self . adjacents [ node . node_id ] = [ ] [EOL] [EOL] def add_edge ( self , node1 , node2 ) : [EOL] assert node1 . node_id in self . nodes and node2 . node_id in self . nodes [EOL] self . adjacents [ node1 . node_id ] . append ( node2 . node_id ) [EOL] self . adjacents [ node2 . node_id ] . append ( node1 . node_id ) [EOL] [EOL] def get_adjacents ( self , node ) : [EOL] return [ self . nodes [ i ] for i in self . adjacents [ node . node_id ] ] [EOL] [EOL] def __repr__ ( self ) : [EOL] nodes_rep = [ [string] . format ( n , self . adjacents [ i ] ) for i , n in self . nodes . items ( ) ] [EOL] return [string] . format ( [string] . join ( nodes_rep ) ) [EOL] [EOL] [EOL] class GraphIterator ( abc . ABC ) : [comment] [EOL] [EOL] @ abc . abstractmethod def get_next ( self ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def is_done ( self ) : [EOL] pass [EOL] [EOL] [EOL] class BFSIterator ( GraphIterator ) : [comment] [EOL] [EOL] def __init__ ( self , graph , source ) : [EOL] self . graph = graph [EOL] self . visited = { i : False for i in graph . nodes . keys ( ) } [EOL] self . queue = [ source . node_id ] [EOL] [EOL] def get_next ( self ) : [EOL] assert not self . is_done ( ) [EOL] [EOL] if len ( self . queue ) == [number] : [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] unvisited = next ( i for i , v in self . visited . items ( ) if not v ) [EOL] [comment] [EOL] self . queue . append ( unvisited ) [EOL] [EOL] head_id = self . queue . pop ( [number] ) [EOL] adj_ids = [ n . node_id for n in self . graph . get_adjacents ( self . graph . nodes [ head_id ] ) ] [EOL] self . queue . extend ( [ i for i in adj_ids if not self . visited [ i ] ] ) [EOL] self . visited [ head_id ] = True [EOL] return self . graph . nodes [ head_id ] [EOL] [EOL] def is_done ( self ) : [EOL] return all ( self . visited . values ( ) ) [EOL] [EOL] [EOL] class DFSIterator ( GraphIterator ) : [comment] [EOL] [EOL] def __init__ ( self , graph , source ) : [EOL] self . graph = graph [EOL] self . visited = { i : False for i in graph . nodes . keys ( ) } [EOL] self . source = source [EOL] [comment] [EOL] self . node_gen = self . get_next_helper ( self . source ) [EOL] [EOL] def get_next ( self ) : [EOL] assert not self . is_done ( ) [EOL] [EOL] for n in self . node_gen : [EOL] return n [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] unvisited = next ( i for i , v in self . visited . items ( ) if not v ) [EOL] [comment] [EOL] self . node_gen = self . get_next_helper ( self . graph . nodes [ unvisited ] ) [EOL] return self . get_next ( ) [EOL] [EOL] def get_next_helper ( self , curr_node ) : [EOL] if self . visited [ curr_node . node_id ] : [EOL] return [EOL] [EOL] self . visited [ curr_node . node_id ] = True [EOL] yield curr_node [EOL] for adj in self . graph . get_adjacents ( curr_node ) : [EOL] yield from self . get_next_helper ( adj ) [EOL] [EOL] def is_done ( self ) : [EOL] return all ( self . visited . values ( ) ) [EOL] [EOL] [EOL] class GraphTraversal ( abc . ABC ) : [comment] [EOL] [EOL] @ abc . abstractmethod def get_iterator ( self ) : [EOL] pass [EOL] [EOL] [EOL] class BFSTraversal ( GraphTraversal ) : [comment] [EOL] [EOL] def __init__ ( self , graph , source ) : [EOL] self . graph = graph [EOL] self . source = source [EOL] [EOL] def get_iterator ( self ) : [EOL] return BFSIterator ( self . graph , self . source ) [EOL] [EOL] [EOL] class DFSTraversal ( GraphTraversal ) : [comment] [EOL] [EOL] def __init__ ( self , graph , source ) : [EOL] self . graph = graph [EOL] self . source = source [EOL] [EOL] def get_iterator ( self ) : [EOL] return DFSIterator ( self . graph , self . source ) [EOL] [EOL] [EOL] class GraphExplorer : [comment] [EOL] [EOL] def __init__ ( self , traversal ) : [EOL] self . traversal = traversal [EOL] [EOL] def explore ( self ) : [EOL] it = self . traversal . get_iterator ( ) [EOL] visited = [ ] [EOL] while not it . is_done ( ) : [EOL] visited . append ( repr ( it . get_next ( ) ) ) [EOL] print ( [string] . format ( [string] . join ( visited ) ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] graph = Graph ( ) [EOL] alex = Node ( [string] ) [EOL] barbara , becky , bruce = Node ( [string] ) , Node ( [string] ) , Node ( [string] ) [EOL] carl , charlotte , charles = Node ( [string] ) , Node ( [string] ) , Node ( [string] ) [EOL] dafne = Node ( [string] ) [EOL] elizabeth = Node ( [string] ) [EOL] franz = Node ( [string] ) [EOL] [EOL] graph . add_node ( alex ) [EOL] graph . add_node ( barbara ) [EOL] graph . add_node ( becky ) [EOL] graph . add_node ( bruce ) [EOL] graph . add_node ( carl ) [EOL] graph . add_node ( charlotte ) [EOL] graph . add_node ( charles ) [EOL] graph . add_node ( dafne ) [EOL] graph . add_node ( elizabeth ) [EOL] graph . add_node ( franz ) [EOL] [EOL] graph . add_edge ( alex , barbara ) [EOL] graph . add_edge ( alex , becky ) [EOL] graph . add_edge ( alex , bruce ) [EOL] graph . add_edge ( becky , carl ) [EOL] graph . add_edge ( becky , charlotte ) [EOL] graph . add_edge ( bruce , charles ) [EOL] graph . add_edge ( charlotte , dafne ) [EOL] [EOL] print ( graph ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] traversal = BFSTraversal ( graph , alex ) [EOL] graph_explorer = GraphExplorer ( traversal ) [EOL] graph_explorer . explore ( ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] traversal = DFSTraversal ( graph , alex ) [EOL] graph_explorer = GraphExplorer ( traversal ) [EOL] graph_explorer . explore ( ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $NodeId$ 0 0 0 0 0 0 0 0 0 $NodeValue$ 0 0 0 0 0 $NodeId$ 0 0 0 0 0 0 0 $NodeValue$ 0 $NodeValue$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[NodeId,Node]$ 0 0 0 0 0 0 $typing.Dict[NodeId,typing.List[NodeId]]$ 0 0 0 0 0 0 $None$ 0 0 0 $Node$ 0 0 0 0 0 0 0 $Node$ 0 0 0 0 $Node$ 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Node$ 0 $Node$ 0 0 0 0 $Node$ 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 $typing.List[Node]$ 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Graph$ 0 $Node$ 0 0 0 0 0 $Graph$ 0 $Graph$ 0 0 0 $typing.Dict[NodeId,builtins.bool]$ 0 0 0 0 0 0 0 0 $Graph$ 0 0 0 0 0 0 0 0 0 0 $typing.List[NodeId]$ 0 0 $Node$ 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Graph$ 0 $design_patterns.behavioural.iterator_graph.Node$ 0 0 0 0 0 $Graph$ 0 $Graph$ 0 0 0 $typing.Dict[NodeId,builtins.bool]$ 0 0 0 0 0 0 0 0 $Graph$ 0 0 0 0 0 0 0 0 0 0 $design_patterns.behavioural.iterator_graph.Node$ 0 $design_patterns.behavioural.iterator_graph.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $design_patterns.behavioural.iterator_graph.Node$ 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[Node,None,None]$ 0 0 0 $Node$ 0 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $GraphIterator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $design_patterns.behavioural.iterator_graph.Graph$ 0 $design_patterns.behavioural.iterator_graph.Node$ 0 0 0 0 0 $design_patterns.behavioural.iterator_graph.Graph$ 0 $design_patterns.behavioural.iterator_graph.Graph$ 0 0 0 $design_patterns.behavioural.iterator_graph.Node$ 0 $design_patterns.behavioural.iterator_graph.Node$ 0 0 0 $BFSIterator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $design_patterns.behavioural.iterator_graph.Graph$ 0 $design_patterns.behavioural.iterator_graph.Node$ 0 0 0 0 0 $design_patterns.behavioural.iterator_graph.Graph$ 0 $design_patterns.behavioural.iterator_graph.Graph$ 0 0 0 $design_patterns.behavioural.iterator_graph.Node$ 0 $design_patterns.behavioural.iterator_graph.Node$ 0 0 0 $DFSIterator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $design_patterns.behavioural.iterator_graph.GraphTraversal$ 0 0 0 0 0 $design_patterns.behavioural.iterator_graph.GraphTraversal$ 0 $design_patterns.behavioural.iterator_graph.GraphTraversal$ 0 0 0 $None$ 0 0 0 0 0 $GraphIterator$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $GraphIterator$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $GraphIterator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Set [EOL] import typing [EOL] import design_patterns [EOL] import builtins [EOL] import abc [EOL] [EOL] from enum import Enum [EOL] from typing import List , Set [EOL] [EOL] [EOL] class UserType ( Enum ) : [EOL] USER = [number] [EOL] ADMIN = [number] [EOL] [EOL] [EOL] class User : [EOL] [EOL] def __init__ ( self , user_type ) : [EOL] self . user_type = user_type [EOL] [EOL] [EOL] class FileSystem ( abc . ABC ) : [comment] [EOL] [EOL] @ abc . abstractmethod def list_files ( self ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def create_file ( self , name ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def remove_file ( self , name ) : [EOL] pass [EOL] [EOL] [EOL] class OSFileSystem ( FileSystem ) : [comment] [EOL] [EOL] def __init__ ( self ) : [EOL] self . files = set ( ) [EOL] [EOL] def list_files ( self ) : [EOL] return list ( self . files ) [EOL] [EOL] def create_file ( self , name ) : [EOL] if name in self . files : [EOL] return False [EOL] self . files . add ( name ) [EOL] return True [EOL] [EOL] def remove_file ( self , name ) : [EOL] if name not in self . files : [EOL] return False [EOL] self . files . remove ( name ) [EOL] return True [EOL] [EOL] [EOL] class AuthenticatedUserFileSystem ( FileSystem ) : [comment] [EOL] [EOL] def __init__ ( self , user ) : [EOL] self . user = user . user_type [EOL] self . fs = OSFileSystem ( ) [EOL] [EOL] def list_files ( self ) : [EOL] return self . fs . list_files ( ) [EOL] [EOL] def create_file ( self , name ) : [EOL] return self . fs . create_file ( name ) [EOL] [EOL] def remove_file ( self , name ) : [EOL] if self . user is UserType . USER : [EOL] print ( [string] . format ( name ) ) [EOL] return False [EOL] return self . fs . remove_file ( name ) [EOL] [EOL] [EOL] class Client : [EOL] [EOL] def __init__ ( self , fs ) : [EOL] self . fs = fs [EOL] [EOL] def list_files ( self ) : [EOL] print ( self . fs . list_files ( ) ) [EOL] [EOL] def create_file ( self , name ) : [EOL] if self . fs . create_file ( name ) : [EOL] print ( [string] . format ( name ) ) [EOL] else : [EOL] print ( [string] . format ( name ) ) [EOL] [EOL] def remove_file ( self , name ) : [EOL] if self . fs . remove_file ( name ) : [EOL] print ( [string] . format ( name ) ) [EOL] else : [EOL] print ( [string] . format ( name ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] aufs = AuthenticatedUserFileSystem ( User ( UserType . USER ) ) [EOL] user_client = Client ( aufs ) [EOL] user_client . create_file ( [string] ) [EOL] [comment] [EOL] user_client . create_file ( [string] ) [EOL] [comment] [EOL] user_client . list_files ( ) [EOL] [comment] [EOL] user_client . remove_file ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] aufs = AuthenticatedUserFileSystem ( User ( UserType . ADMIN ) ) [EOL] admin_client = Client ( aufs ) [EOL] admin_client . create_file ( [string] ) [EOL] [comment] [EOL] admin_client . create_file ( [string] ) [EOL] [comment] [EOL] admin_client . list_files ( ) [EOL] [comment] [EOL] admin_client . remove_file ( [string] ) [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $UserType$ 0 0 0 0 0 $UserType$ 0 $UserType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FileSystem$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $design_patterns.structural.proxy_os.FileSystem$ 0 0 0 0 0 $design_patterns.structural.proxy_os.FileSystem$ 0 $design_patterns.structural.proxy_os.FileSystem$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import design_patterns [EOL] import typing [EOL] import abc [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] class MenuConsumation ( abc . ABC ) : [comment] [EOL] [EOL] @ abc . abstractmethod def get_price ( self ) : [EOL] pass [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . __class__ . __name__ , self . get_price ( ) ) [EOL] [EOL] [EOL] class CheeseBurger ( MenuConsumation ) : [comment] [EOL] [EOL] def get_price ( self ) : [EOL] return [number] [EOL] [EOL] [EOL] class FrenchFries ( MenuConsumation ) : [comment] [EOL] [EOL] def get_price ( self ) : [EOL] return [number] [EOL] [EOL] [EOL] class ConsumationWithExtra ( MenuConsumation ) : [comment] [EOL] [EOL] def __init__ ( self , consumation ) : [EOL] self . consumation = consumation [EOL] [EOL] def get_price ( self ) : [EOL] return self . consumation . get_price ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( repr ( self . consumation ) , super ( ) . __repr__ ( ) ) [EOL] [EOL] [EOL] class ExtraMaionnaise ( ConsumationWithExtra ) : [comment] [EOL] [EOL] def __init__ ( self , consumation ) : [EOL] super ( ) . __init__ ( consumation ) [EOL] [EOL] def get_price ( self ) : [EOL] return super ( ) . get_price ( ) + [number] [EOL] [EOL] [EOL] class ExtraKetchup ( ConsumationWithExtra ) : [comment] [EOL] [EOL] def __init__ ( self , consumation ) : [EOL] super ( ) . __init__ ( consumation ) [EOL] [EOL] def get_price ( self ) : [EOL] return super ( ) . get_price ( ) + [number] [EOL] [EOL] [EOL] class ShopClient : [EOL] [EOL] def __init__ ( self ) : [EOL] self . order = [ ] [EOL] [EOL] def add_consumation ( self , consumation ) : [EOL] self . order . append ( consumation ) [EOL] [EOL] def print_order ( self ) : [EOL] print ( [string] . format ( self . order ) ) [EOL] [EOL] def print_total ( self ) : [EOL] print ( [string] . format ( sum ( [ c . get_price ( ) for c in self . order ] ) ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] shop = ShopClient ( ) [EOL] shop . add_consumation ( ExtraMaionnaise ( FrenchFries ( ) ) ) [EOL] shop . add_consumation ( ExtraMaionnaise ( ExtraKetchup ( CheeseBurger ( ) ) ) ) [EOL] shop . print_order ( ) [EOL] [comment] [EOL] [comment] [EOL] shop . print_total ( ) [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $design_patterns.structural.decorator_menu.MenuConsumation$ 0 0 0 0 0 $design_patterns.structural.decorator_menu.MenuConsumation$ 0 $design_patterns.structural.decorator_menu.MenuConsumation$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MenuConsumation$ 0 0 0 0 0 0 0 0 0 $MenuConsumation$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MenuConsumation$ 0 0 0 0 0 0 0 0 0 $MenuConsumation$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[MenuConsumation]$ 0 0 0 0 0 0 $None$ 0 0 0 $MenuConsumation$ 0 0 0 0 0 0 0 0 0 $MenuConsumation$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Iterator [EOL] import typing [EOL] import data_structures [EOL] from random import random [EOL] [EOL] [EOL] class NilNode : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , max_key ) : [EOL] self . key = max_key [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . key ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . key ) [EOL] [EOL] [EOL] class SkipListNode : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , level , search_key , value ) : [EOL] self . forward = level * [ None ] [EOL] self . key = search_key [EOL] self . value = value [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . key , self . value ) [EOL] [EOL] def __repr__ ( self ) : [EOL] fw = map ( lambda x : [string] . format ( x [ [number] ] , repr ( x [ [number] ] ) ) , enumerate ( self . forward ) ) [EOL] return [string] . format ( self . key , self . value , [string] . join ( fw ) ) [EOL] [EOL] [EOL] class SkipList : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , p , max_level , min_key , max_key ) : [EOL] [docstring] [EOL] assert [number] < p < [number] <= max_level [EOL] [EOL] self . p = p [EOL] self . max_level = max_level [EOL] self . level = [number] [EOL] [comment] [EOL] self . header = SkipListNode ( max_level , min_key , None ) [EOL] [comment] [EOL] nil = NilNode ( max_key ) [EOL] [comment] [EOL] for i in range ( max_level ) : [EOL] self . header . forward [ i ] = nil [EOL] [EOL] def _traverse_list ( self , search_key , with_updates ) : [EOL] [docstring] [EOL] [EOL] update = None [EOL] if with_updates : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] update = self . max_level * [ None ] [EOL] [EOL] x = self . header [EOL] for i in reversed ( range ( self . level ) ) : [EOL] while x . forward [ i ] . key < search_key : [EOL] x = x . forward [ i ] [EOL] if with_updates : [EOL] update [ i ] = x [EOL] [EOL] assert x . key < search_key <= x . forward [ i ] . key [EOL] [EOL] x = x . forward [ [number] ] [EOL] return x , update [EOL] [EOL] def _get_random_level ( self ) : [EOL] [docstring] [EOL] [EOL] level = [number] [EOL] while random ( ) < self . p : [EOL] level += [number] [EOL] return min ( level , self . max_level ) [EOL] [EOL] def search ( self , search_key ) : [EOL] [docstring] [EOL] [EOL] x , _ = self . _traverse_list ( search_key , False ) [EOL] return x . value if x . key == search_key else None [EOL] [EOL] def insert ( self , search_key , new_value ) : [EOL] [docstring] [EOL] [EOL] x , update = self . _traverse_list ( search_key , True ) [EOL] if x . key == search_key : [comment] [EOL] x . value = new_value [EOL] return [EOL] [EOL] [comment] [EOL] new_level = self . _get_random_level ( ) [EOL] if new_level > self . level : [EOL] for i in range ( self . level , new_level ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] update [ i ] = self . header [EOL] self . level = new_level [EOL] [EOL] x = SkipListNode ( new_level , search_key , new_value ) [EOL] for i in range ( new_level ) : [EOL] [comment] [EOL] x . forward [ i ] = update [ i ] . forward [ i ] [EOL] [comment] [EOL] update [ i ] . forward [ i ] = x [EOL] [EOL] def delete ( self , search_key ) : [EOL] [docstring] [EOL] [EOL] x , update = self . _traverse_list ( search_key , True ) [EOL] if x . key != search_key : [comment] [EOL] return [EOL] [EOL] [comment] [EOL] for i in range ( self . level ) : [EOL] if update [ i ] . forward [ i ] is not x : [EOL] break [EOL] update [ i ] . forward [ i ] = x . forward [ i ] [EOL] [comment] [EOL] [EOL] [comment] [EOL] while self . level > [number] and isinstance ( self . header . forward [ self . level - [number] ] , NilNode ) : [EOL] self . level -= [number] [EOL] [EOL] def _level_generator ( self , level = [number] ) : [EOL] [docstring] [EOL] [EOL] assert level <= self . level [EOL] [EOL] x = self . header [EOL] while not isinstance ( x , NilNode ) : [EOL] yield x [EOL] x = x . forward [ level - [number] ] [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] [EOL] if self . level == [number] : [EOL] return iter ( [ ] ) [EOL] [EOL] gen = self . _level_generator ( ) [EOL] _ = next ( gen ) [comment] [EOL] return gen [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( [string] . join ( map ( str , self ) ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . p , self . level , self . max_level , repr ( self . header ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $data_structures.skip_list.SkipListNode$ 0 0 0 0 0 0 0 0 0 0 0 0 $data_structures.skip_list.NilNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data_structures.skip_list.SkipListNode$ 0 0 0 0 0 0 $data_structures.skip_list.NilNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[None]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[None]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data_structures.skip_list.SkipListNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $data_structures.skip_list.SkipListNode$ 0 0 0 0 0 0 0 $data_structures.skip_list.SkipListNode$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 $data_structures.skip_list.SkipListNode$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $data_structures.skip_list.SkipListNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data_structures.skip_list.SkipListNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any , Literal , Set [EOL] import typing [EOL] import typing_extensions [EOL] import random [EOL] import unittest [EOL] [EOL] from math import log [EOL] from skip_list import SkipList [EOL] [EOL] [EOL] class TestSkipList ( unittest . TestCase ) : [EOL] [EOL] def test_skip_list ( self ) : [EOL] random . seed ( [number] ) [EOL] max_length = [number] [EOL] repetitions_per_length = [number] [EOL] int_range = ( [number] , [number] ) [EOL] min_key = - [number] [EOL] max_key = [number] [EOL] p = [number] / [number] [EOL] [EOL] [comment] [EOL] for length in range ( max_length + [number] ) : [EOL] for _ in range ( length * repetitions_per_length ) : [EOL] keys = set ( ) [EOL] skip_list = SkipList ( p , int ( log ( length , [number] ) ) + [number] , min_key , max_key ) [EOL] [EOL] for _ in range ( length ) : [EOL] value = random . randint ( * int_range ) [EOL] keys . add ( value ) [EOL] skip_list . insert ( value , value ) [EOL] [EOL] [comment] [EOL] array = [ ( k , k ) for k in keys ] [EOL] array . sort ( ) [EOL] [EOL] self . assertEqual ( str ( array ) , str ( skip_list ) , [string] . format ( skip_list ) ) [EOL] [EOL] [comment] [EOL] for k in keys : [EOL] self . assertEqual ( k , skip_list . search ( k ) , [string] . format ( k , skip_list ) ) [EOL] skip_list . delete ( k ) [EOL] [EOL] [comment] [EOL] for k in keys : [EOL] self . assertIsNone ( skip_list . search ( k ) , [string] . format ( k , skip_list ) ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( str ( [ ] ) , str ( skip_list ) , [string] . format ( skip_list ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import data_structures [EOL] from hashlib import md5 [EOL] from itertools import chain [EOL] from BitVector import BitVector [EOL] [EOL] [EOL] class BloomFilter : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , m , * hash_fns ) : [EOL] assert m > [number] [EOL] [EOL] self . m = m [EOL] [comment] [EOL] self . bits = BitVector ( intVal = [number] , size = m ) [EOL] self . hash_fns = list ( hash_fns ) [EOL] [EOL] assert len ( self . hash_fns ) > [number] [EOL] [EOL] def add ( self , item ) : [EOL] [docstring] [EOL] [EOL] for hf in self . hash_fns : [EOL] self . bits [ hf ( item ) % self . m ] = [number] [EOL] [EOL] def __contains__ ( self , item ) : [EOL] [docstring] [EOL] [EOL] return all ( map ( lambda hf : self . bits [ hf ( item ) % self . m ] , self . hash_fns ) ) [EOL] [EOL] [EOL] def md5_to_int ( item ) : [EOL] return int ( md5 ( item . encode ( [string] ) ) . hexdigest ( ) , [number] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] bloom_filter = BloomFilter ( [number] , md5_to_int ) [EOL] present_values = [ [string] , [string] , [string] , [string] ] [EOL] absent_values = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] for i in present_values : [EOL] bloom_filter . add ( i ) [EOL] [EOL] for i in present_values : [EOL] print ( [string] . format ( i , True , i in bloom_filter ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] for i in absent_values : [EOL] print ( [string] . format ( i , False , i in bloom_filter ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Callable , Type [EOL] import typing [EOL] import data_structures [EOL] import builtins [EOL] from hashlib import md5 [EOL] from itertools import chain [EOL] from typing import Callable , List [EOL] from BitVector import BitVector [EOL] [EOL] [EOL] FilterItem = str [EOL] [EOL] class BloomFilter : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , m , * hash_fns ) : [EOL] assert m > [number] [EOL] [EOL] self . m = m [EOL] [comment] [EOL] self . bits = BitVector ( intVal = [number] , size = m ) [comment] [EOL] self . hash_fns = list ( hash_fns ) [EOL] [EOL] assert len ( self . hash_fns ) > [number] [EOL] [EOL] def add ( self , item ) : [EOL] [docstring] [EOL] [EOL] for hf in self . hash_fns : [EOL] self . bits [ hf ( item ) % self . m ] = [number] [EOL] [EOL] def __contains__ ( self , item ) : [EOL] [docstring] [EOL] [EOL] res = all ( map ( lambda hf : self . bits [ hf ( item ) % self . m ] , self . hash_fns ) ) [EOL] return res [EOL] [EOL] [EOL] def md5_to_int ( item ) : [EOL] return int ( md5 ( item . encode ( [string] ) ) . hexdigest ( ) , [number] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] bloom_filter = BloomFilter ( [number] , md5_to_int ) [EOL] present_values = [ [string] , [string] , [string] , [string] ] [EOL] absent_values = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] for i in present_values : [EOL] bloom_filter . add ( i ) [EOL] [EOL] for i in present_values : [EOL] print ( [string] . format ( i , True , i in bloom_filter ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] for i in absent_values : [EOL] print ( [string] . format ( i , False , i in bloom_filter ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $FilterItem$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FilterItem$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $FilterItem$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FilterItem$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0