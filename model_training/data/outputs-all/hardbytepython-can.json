[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] import time [EOL] [EOL] import can [EOL] [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] [EOL] [EOL] def cyclic_multiple_send ( bus ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] messages = [ ] [EOL] [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] task = bus . send_periodic ( messages , [number] ) [EOL] assert isinstance ( task , can . CyclicSendTaskABC ) [EOL] time . sleep ( [number] ) [EOL] task . stop ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def cyclic_multiple_send_modify ( bus ) : [EOL] [docstring] [EOL] messages_odd = [ ] [EOL] messages_odd . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages_odd . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages_odd . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages_even = [ ] [EOL] messages_even . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages_even . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages_even . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] print ( [string] ) [EOL] task = bus . send_periodic ( messages_odd , [number] ) [EOL] assert isinstance ( task , can . CyclicSendTaskABC ) [EOL] time . sleep ( [number] ) [EOL] print ( [string] ) [EOL] task . modify_data ( messages_even ) [EOL] time . sleep ( [number] ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] for interface , channel in [ ( [string] , [string] ) ] : [EOL] print ( f" [string] { interface } [string] " ) [EOL] [EOL] with can . Bus ( interface = interface , channel = channel , bitrate = [number] ) as BUS : [EOL] cyclic_multiple_send ( BUS ) [EOL] cyclic_multiple_send_modify ( BUS ) [EOL] [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] import time [EOL] [EOL] import can [EOL] [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] [EOL] [EOL] def crc_send ( bus ) : [EOL] [docstring] [EOL] msg = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] messages = build_crc_msgs ( msg ) [EOL] [EOL] print ( [string] ) [EOL] task = bus . send_periodic ( messages , [number] ) [EOL] assert isinstance ( task , can . CyclicSendTaskABC ) [EOL] time . sleep ( [number] ) [EOL] [EOL] msg = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] messages = build_crc_msgs ( msg ) [EOL] [EOL] print ( [string] ) [EOL] task . modify_data ( messages ) [EOL] time . sleep ( [number] ) [EOL] task . stop ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def build_crc_msgs ( msg ) : [EOL] [docstring] [EOL] messages = [ ] [EOL] [EOL] for counter in range ( [number] ) : [EOL] checksum = compute_xbr_checksum ( msg , counter ) [EOL] msg . data [ [number] ] = counter + ( checksum << [number] ) [EOL] messages . append ( can . Message ( arbitration_id = msg . arbitration_id , data = msg . data [ : ] ) ) [EOL] [EOL] return messages [EOL] [EOL] [EOL] def compute_xbr_checksum ( message , counter ) : [EOL] [docstring] [EOL] checksum = sum ( message . data [ : [number] ] ) [EOL] checksum += sum ( message . arbitration_id . to_bytes ( length = [number] , byteorder = [string] ) ) [EOL] checksum += counter & [number] [EOL] xbr_checksum = ( ( checksum >> [number] ) + checksum ) & [number] [EOL] [EOL] return xbr_checksum [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] for interface , channel in [ ( [string] , [string] ) ] : [EOL] print ( f" [string] { interface } [string] " ) [EOL] [EOL] with can . Bus ( interface = interface , channel = channel , bitrate = [number] ) as BUS : [EOL] crc_send ( BUS ) [EOL] [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import asyncio [EOL] import typing [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import can [EOL] [EOL] [EOL] def print_message ( msg ) : [EOL] [docstring] [EOL] print ( msg ) [EOL] [EOL] [EOL] async def main ( ) : [EOL] [docstring] [EOL] [EOL] bus = can . Bus ( [string] , bustype = [string] , receive_own_messages = True ) [EOL] reader = can . AsyncBufferedReader ( ) [EOL] logger = can . Logger ( [string] ) [EOL] [EOL] listeners = [ print_message , reader , logger , ] [EOL] [comment] [EOL] loop = asyncio . get_event_loop ( ) [EOL] notifier = can . Notifier ( bus , listeners , loop = loop ) [EOL] [comment] [EOL] bus . send ( can . Message ( arbitration_id = [number] ) ) [EOL] [EOL] print ( [string] ) [EOL] for _ in range ( [number] ) : [EOL] [comment] [EOL] msg = await reader . get_message ( ) [EOL] [comment] [EOL] await asyncio . sleep ( [number] ) [EOL] msg . arbitration_id += [number] [EOL] bus . send ( msg ) [EOL] [comment] [EOL] await reader . get_message ( ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] notifier . stop ( ) [EOL] bus . shutdown ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] [comment] [EOL] LOOP = asyncio . get_event_loop ( ) [EOL] [comment] [EOL] LOOP . run_until_complete ( main ( ) ) [EOL] finally : [EOL] LOOP . close ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import can [EOL] [EOL] [EOL] def send_one ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] with can . interface . Bus ( ) as bus : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] msg = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = True ) [EOL] [EOL] try : [EOL] bus . send ( msg ) [EOL] print ( f" [string] { bus . channel_info }" ) [EOL] except can . CanError : [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] send_one ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import can [EOL] from can . bus import BusState [EOL] [EOL] [EOL] def receive_all ( ) : [EOL] [docstring] [EOL] [EOL] with can . interface . Bus ( bustype = [string] , channel = [string] , bitrate = [number] ) as bus : [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] bus . state = BusState . PASSIVE [EOL] [EOL] try : [EOL] while True : [EOL] msg = bus . recv ( [number] ) [EOL] if msg is not None : [EOL] print ( msg ) [EOL] [EOL] except KeyboardInterrupt : [EOL] pass [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] receive_all ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from time import sleep [EOL] from concurrent . futures import ProcessPoolExecutor [EOL] [EOL] import can [EOL] [EOL] [EOL] def producer ( thread_id , message_count = [number] ) : [EOL] [docstring] [EOL] with can . Bus ( bustype = [string] , channel = [string] ) as bus : [comment] [EOL] for i in range ( message_count ) : [EOL] msg = can . Message ( arbitration_id = [number] + thread_id , data = [ thread_id , i , [number] , [number] , [number] , [number] , [number] , [number] ] , ) [EOL] bus . send ( msg ) [EOL] sleep ( [number] ) [EOL] [EOL] print ( f" [string] { thread_id } [string] { message_count } [string] " ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with ProcessPoolExecutor ( ) as executor : [EOL] executor . map ( producer , range ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] import time [EOL] [EOL] import can [EOL] [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] [EOL] [EOL] def simple_periodic_send ( bus ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] msg = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False ) [EOL] task = bus . send_periodic ( msg , [number] ) [EOL] assert isinstance ( task , can . CyclicSendTaskABC ) [EOL] time . sleep ( [number] ) [EOL] task . stop ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def limited_periodic_send ( bus ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] msg = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = True ) [EOL] task = bus . send_periodic ( msg , [number] , [number] , store_task = False ) [EOL] if not isinstance ( task , can . LimitedDurationCyclicSendTaskABC ) : [EOL] print ( [string] ) [EOL] task . stop ( ) [EOL] return [EOL] [EOL] time . sleep ( [number] ) [EOL] print ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_periodic_send_with_modifying_data ( bus ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] msg = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] ] ) [EOL] task = bus . send_periodic ( msg , [number] ) [EOL] if not isinstance ( task , can . ModifiableCyclicTaskABC ) : [EOL] print ( [string] ) [EOL] task . stop ( ) [EOL] return [EOL] time . sleep ( [number] ) [EOL] print ( [string] ) [EOL] msg . data [ [number] ] = [number] [EOL] task . modify_data ( msg ) [EOL] time . sleep ( [number] ) [EOL] [EOL] task . stop ( ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] msg . data = bytearray ( [ [number] ] ) [EOL] msg . dlc = [number] [EOL] task . modify_data ( msg ) [EOL] time . sleep ( [number] ) [EOL] print ( [string] ) [EOL] task . start ( ) [EOL] time . sleep ( [number] ) [EOL] task . stop ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] reset_msg = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False ) [EOL] [EOL] with can . Bus ( interface = [string] ) as bus : [EOL] bus . send ( reset_msg ) [EOL] [EOL] simple_periodic_send ( bus ) [EOL] [EOL] bus . send ( reset_msg ) [EOL] [EOL] limited_periodic_send ( bus ) [EOL] [EOL] test_periodic_send_with_modifying_data ( bus ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] import sys [EOL] [EOL] import can [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] with can . LogReader ( sys . argv [ [number] ] ) as reader : [EOL] with can . Logger ( sys . argv [ [number] ] ) as writer : [EOL] [EOL] for msg in reader : [EOL] writer . on_message_received ( msg ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import time [EOL] [EOL] import can [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] with can . Bus ( bustype = [string] , receive_own_messages = True ) as bus : [EOL] [EOL] can_filters = [ { [string] : [number] , [string] : [number] , [string] : True } ] [EOL] bus . set_filters ( can_filters ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] notifier = can . Notifier ( bus , [ can . Printer ( ) ] ) [comment] [EOL] [EOL] bus . send ( can . Message ( arbitration_id = [number] , is_extended_id = True ) ) [EOL] bus . send ( can . Message ( arbitration_id = [number] , is_extended_id = True ) ) [EOL] bus . send ( can . Message ( arbitration_id = [number] , is_extended_id = False ) ) [EOL] [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] from can . logger import main [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] from can . player import main [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] from can . viewer import main [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [EOL] import builtins [EOL] from typing import Callable , Any , Type [EOL] import threading [EOL] import test [EOL] import typing [EOL] import unittest [EOL] import threading [EOL] import queue [EOL] import random [EOL] import logging [EOL] [EOL] logging . getLogger ( __file__ ) . setLevel ( logging . WARNING ) [EOL] [EOL] [comment] [EOL] rbool = lambda : bool ( round ( random . random ( ) ) ) [EOL] [EOL] import can [EOL] [EOL] channel = [string] [EOL] can . rc [ [string] ] = [string] [EOL] [EOL] [EOL] @ unittest . skipIf ( [string] not in can . rc , [string] ) class ControllerAreaNetworkTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] num_messages = [number] [EOL] [EOL] [comment] [EOL] error_flags = [ False for _ in range ( num_messages ) ] [EOL] [EOL] remote_flags = [ rbool ( ) for _ in range ( num_messages ) ] [EOL] extended_flags = [ rbool ( ) for _ in range ( num_messages ) ] [EOL] [EOL] ids = list ( range ( num_messages ) ) [EOL] data = list ( bytearray ( [ random . randrange ( [number] , [number] ** [number] - [number] ) for a in range ( random . randrange ( [number] ) ) ] ) for b in range ( num_messages ) ) [EOL] [EOL] def producer ( self , ready_event , msg_read ) : [EOL] self . client_bus = can . interface . Bus ( channel = channel ) [EOL] ready_event . wait ( ) [EOL] for i in range ( self . num_messages ) : [EOL] m = can . Message ( arbitration_id = self . ids [ i ] , is_remote_frame = self . remote_flags [ i ] , is_error_frame = self . error_flags [ i ] , is_extended_id = self . extended_flags [ i ] , data = self . data [ i ] , ) [EOL] [comment] [EOL] if msg_read is not None : [EOL] [comment] [EOL] msg_read . wait ( ) [EOL] msg_read . clear ( ) [EOL] [EOL] self . client_bus . send ( m ) [EOL] [EOL] def testProducer ( self ) : [EOL] [docstring] [EOL] logging . debug ( [string] ) [EOL] ready = threading . Event ( ) [EOL] ready . set ( ) [EOL] self . producer ( ready , None ) [EOL] [EOL] logging . debug ( [string] ) [EOL] [EOL] def testProducerConsumer ( self ) : [EOL] logging . debug ( [string] ) [EOL] ready = threading . Event ( ) [EOL] msg_read = threading . Event ( ) [EOL] [EOL] self . server_bus = can . interface . Bus ( channel = channel ) [EOL] [EOL] t = threading . Thread ( target = self . producer , args = ( ready , msg_read ) ) [EOL] t . start ( ) [EOL] [EOL] [comment] [EOL] while True : [EOL] m = self . server_bus . recv ( timeout = [number] ) [EOL] if m is None : [EOL] print ( [string] ) [EOL] break [EOL] else : [EOL] self . fail ( [string] ) [EOL] ready . set ( ) [EOL] i = [number] [EOL] while i < self . num_messages : [EOL] msg_read . set ( ) [EOL] msg = self . server_bus . recv ( timeout = [number] ) [EOL] self . assertIsNotNone ( msg , [string] ) [EOL] [comment] [EOL] [EOL] self . assertEqual ( msg . is_extended_id , self . extended_flags [ i ] ) [EOL] if not msg . is_remote_frame : [EOL] self . assertEqual ( msg . data , self . data [ i ] ) [EOL] self . assertEqual ( msg . arbitration_id , self . ids [ i ] ) [EOL] [EOL] self . assertEqual ( msg . is_error_frame , self . error_flags [ i ] ) [EOL] self . assertEqual ( msg . is_remote_frame , self . remote_flags [ i ] ) [EOL] [EOL] i += [number] [EOL] t . join ( ) [EOL] [EOL] self . server_bus . flush_tx_buffer ( ) [EOL] self . server_bus . shutdown ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 $threading.Event$ 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Tuple [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] import time [EOL] import can [EOL] [EOL] from . config import TEST_INTERFACE_SOCKETCAN [EOL] [EOL] [EOL] @ unittest . skipUnless ( TEST_INTERFACE_SOCKETCAN , [string] ) class CyclicSocketCan ( unittest . TestCase ) : [EOL] BITRATE = [number] [EOL] TIMEOUT = [number] [EOL] [EOL] INTERFACE_1 = [string] [EOL] CHANNEL_1 = [string] [EOL] INTERFACE_2 = [string] [EOL] CHANNEL_2 = [string] [EOL] [EOL] PERIOD = [number] [EOL] [EOL] DELTA = [number] [EOL] [EOL] def _find_start_index ( self , tx_messages , message ) : [EOL] [docstring] [EOL] start_index = - [number] [EOL] for index , tx_message in enumerate ( tx_messages ) : [EOL] if tx_message . data == message . data : [EOL] start_index = index [EOL] break [EOL] return start_index [EOL] [EOL] def setUp ( self ) : [EOL] self . _send_bus = can . Bus ( interface = self . INTERFACE_1 , channel = self . CHANNEL_1 , bitrate = self . BITRATE ) [EOL] self . _recv_bus = can . Bus ( interface = self . INTERFACE_2 , channel = self . CHANNEL_2 , bitrate = self . BITRATE ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . _send_bus . shutdown ( ) [EOL] self . _recv_bus . shutdown ( ) [EOL] [EOL] def test_cyclic_initializer_list ( self ) : [EOL] messages = [ ] [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] [EOL] task = self . _send_bus . send_periodic ( messages , self . PERIOD ) [EOL] self . assertIsInstance ( task , can . broadcastmanager . CyclicSendTaskABC ) [EOL] [EOL] results = [ ] [EOL] for _ in range ( len ( messages ) * [number] ) : [EOL] result = self . _recv_bus . recv ( self . PERIOD * [number] ) [EOL] if result : [EOL] results . append ( result ) [EOL] [EOL] task . stop ( ) [EOL] [EOL] [comment] [EOL] start_index = self . _find_start_index ( messages , results [ [number] ] ) [EOL] self . assertTrue ( start_index != - [number] ) [EOL] [EOL] [comment] [EOL] for rx_index , rx_message in enumerate ( results ) : [EOL] tx_message = messages [ start_index ] [EOL] [EOL] self . assertIsNotNone ( rx_message ) [EOL] self . assertEqual ( tx_message . arbitration_id , rx_message . arbitration_id ) [EOL] self . assertEqual ( tx_message . dlc , rx_message . dlc ) [EOL] self . assertEqual ( tx_message . data , rx_message . data ) [EOL] self . assertEqual ( tx_message . is_extended_id , rx_message . is_extended_id ) [EOL] self . assertEqual ( tx_message . is_remote_frame , rx_message . is_remote_frame ) [EOL] self . assertEqual ( tx_message . is_error_frame , rx_message . is_error_frame ) [EOL] self . assertEqual ( tx_message . is_fd , rx_message . is_fd ) [EOL] [EOL] start_index = ( start_index + [number] ) % len ( messages ) [EOL] [EOL] def test_cyclic_initializer_tuple ( self ) : [EOL] messages = [ ] [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages = tuple ( messages ) [EOL] [EOL] self . assertIsInstance ( messages , tuple ) [EOL] [EOL] task = self . _send_bus . send_periodic ( messages , self . PERIOD ) [EOL] self . assertIsInstance ( task , can . broadcastmanager . CyclicSendTaskABC ) [EOL] [EOL] results = [ ] [EOL] for _ in range ( len ( messages ) * [number] ) : [EOL] result = self . _recv_bus . recv ( self . PERIOD * [number] ) [EOL] if result : [EOL] results . append ( result ) [EOL] [EOL] task . stop ( ) [EOL] [EOL] [comment] [EOL] start_index = self . _find_start_index ( messages , results [ [number] ] ) [EOL] self . assertTrue ( start_index != - [number] ) [EOL] [EOL] [comment] [EOL] for rx_index , rx_message in enumerate ( results ) : [EOL] tx_message = messages [ start_index ] [EOL] [EOL] self . assertIsNotNone ( rx_message ) [EOL] self . assertEqual ( tx_message . arbitration_id , rx_message . arbitration_id ) [EOL] self . assertEqual ( tx_message . dlc , rx_message . dlc ) [EOL] self . assertEqual ( tx_message . data , rx_message . data ) [EOL] self . assertEqual ( tx_message . is_extended_id , rx_message . is_extended_id ) [EOL] self . assertEqual ( tx_message . is_remote_frame , rx_message . is_remote_frame ) [EOL] self . assertEqual ( tx_message . is_error_frame , rx_message . is_error_frame ) [EOL] self . assertEqual ( tx_message . is_fd , rx_message . is_fd ) [EOL] [EOL] start_index = ( start_index + [number] ) % len ( messages ) [EOL] [EOL] def test_cyclic_initializer_message ( self ) : [EOL] message = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] [EOL] task = self . _send_bus . send_periodic ( message , self . PERIOD ) [EOL] self . assertIsInstance ( task , can . broadcastmanager . CyclicSendTaskABC ) [EOL] [EOL] [comment] [EOL] time . sleep ( [number] * self . PERIOD ) [EOL] task . stop ( ) [EOL] [EOL] for _ in range ( [number] ) : [EOL] tx_message = message [EOL] rx_message = self . _recv_bus . recv ( self . TIMEOUT ) [EOL] [EOL] self . assertIsNotNone ( rx_message ) [EOL] self . assertEqual ( tx_message . arbitration_id , rx_message . arbitration_id ) [EOL] self . assertEqual ( tx_message . dlc , rx_message . dlc ) [EOL] self . assertEqual ( tx_message . data , rx_message . data ) [EOL] self . assertEqual ( tx_message . is_extended_id , rx_message . is_extended_id ) [EOL] self . assertEqual ( tx_message . is_remote_frame , rx_message . is_remote_frame ) [EOL] self . assertEqual ( tx_message . is_error_frame , rx_message . is_error_frame ) [EOL] self . assertEqual ( tx_message . is_fd , rx_message . is_fd ) [EOL] [EOL] def test_cyclic_initializer_invalid_none ( self ) : [EOL] with self . assertRaises ( ValueError ) : [EOL] task = self . _send_bus . send_periodic ( None , self . PERIOD ) [EOL] [EOL] def test_cyclic_initializer_invalid_empty_list ( self ) : [EOL] with self . assertRaises ( ValueError ) : [EOL] task = self . _send_bus . send_periodic ( [ ] , self . PERIOD ) [EOL] [EOL] def test_cyclic_initializer_different_arbitration_ids ( self ) : [EOL] messages = [ ] [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] with self . assertRaises ( ValueError ) : [EOL] task = self . _send_bus . send_periodic ( messages , self . PERIOD ) [EOL] [EOL] def test_start_already_started_task ( self ) : [EOL] messages_a = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] [EOL] task_a = self . _send_bus . send_periodic ( messages_a , self . PERIOD ) [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( ValueError ) as ctx : [EOL] task_a . start ( ) [EOL] self . assertEqual ( [string] , str ( ctx . exception ) , ) [EOL] [EOL] task_a . stop ( ) [EOL] [EOL] def test_create_same_id ( self ) : [EOL] messages_a = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] [EOL] messages_b = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] [EOL] task_a = self . _send_bus . send_periodic ( messages_a , self . PERIOD ) [EOL] self . assertIsInstance ( task_a , can . broadcastmanager . CyclicSendTaskABC ) [EOL] task_b = self . _send_bus . send_periodic ( messages_b , self . PERIOD ) [EOL] self . assertIsInstance ( task_b , can . broadcastmanager . CyclicSendTaskABC ) [EOL] [EOL] time . sleep ( self . PERIOD * [number] ) [EOL] [EOL] task_a . stop ( ) [EOL] task_b . stop ( ) [EOL] [EOL] msgs = [ ] [EOL] for _ in range ( [number] ) : [EOL] msg = self . _recv_bus . recv ( self . PERIOD * [number] ) [EOL] self . assertIsNotNone ( msg ) [EOL] [EOL] msgs . append ( msg ) [EOL] [EOL] self . assertTrue ( len ( msgs ) >= [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] msg_a_data_present = msg_b_data_present = False [EOL] for rx_message in msgs : [EOL] self . assertTrue ( rx_message . arbitration_id == messages_a . arbitration_id == messages_b . arbitration_id ) [EOL] if rx_message . data == messages_a . data : [EOL] msg_a_data_present = True [EOL] if rx_message . data == messages_b . data : [EOL] msg_b_data_present = True [EOL] [EOL] self . assertTrue ( msg_a_data_present ) [EOL] self . assertTrue ( msg_b_data_present ) [EOL] [EOL] def test_modify_data_list ( self ) : [EOL] messages_odd = [ ] [EOL] messages_odd . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages_odd . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages_odd . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages_even = [ ] [EOL] messages_even . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages_even . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] messages_even . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] [EOL] task = self . _send_bus . send_periodic ( messages_odd , self . PERIOD ) [EOL] self . assertIsInstance ( task , can . broadcastmanager . ModifiableCyclicTaskABC ) [EOL] [EOL] results_odd = [ ] [EOL] results_even = [ ] [EOL] for _ in range ( len ( messages_odd ) * [number] ) : [EOL] result = self . _recv_bus . recv ( self . PERIOD * [number] ) [EOL] if result : [EOL] results_odd . append ( result ) [EOL] [EOL] task . modify_data ( messages_even ) [EOL] for _ in range ( len ( messages_even ) * [number] ) : [EOL] result = self . _recv_bus . recv ( self . PERIOD * [number] ) [EOL] if result : [EOL] results_even . append ( result ) [EOL] [EOL] task . stop ( ) [EOL] [EOL] [comment] [EOL] self . assertTrue ( len ( results_even ) != [number] ) [EOL] self . assertTrue ( len ( results_odd ) != [number] ) [EOL] [EOL] [comment] [EOL] start_index_even = self . _find_start_index ( messages_even , results_even [ [number] ] ) [EOL] self . assertTrue ( start_index_even != - [number] ) [EOL] [EOL] start_index_odd = self . _find_start_index ( messages_odd , results_odd [ [number] ] ) [EOL] self . assertTrue ( start_index_odd != - [number] ) [EOL] [EOL] [comment] [EOL] for rx_index , rx_message in enumerate ( results_even ) : [EOL] tx_message = messages_even [ start_index_even ] [EOL] [EOL] self . assertEqual ( tx_message . arbitration_id , rx_message . arbitration_id ) [EOL] self . assertEqual ( tx_message . dlc , rx_message . dlc ) [EOL] self . assertEqual ( tx_message . data , rx_message . data ) [EOL] self . assertEqual ( tx_message . is_extended_id , rx_message . is_extended_id ) [EOL] self . assertEqual ( tx_message . is_remote_frame , rx_message . is_remote_frame ) [EOL] self . assertEqual ( tx_message . is_error_frame , rx_message . is_error_frame ) [EOL] self . assertEqual ( tx_message . is_fd , rx_message . is_fd ) [EOL] [EOL] start_index_even = ( start_index_even + [number] ) % len ( messages_even ) [EOL] [EOL] if rx_index != [number] : [EOL] prev_rx_message = results_even [ rx_index - [number] ] [EOL] [comment] [EOL] self . assertTrue ( abs ( ( rx_message . timestamp - prev_rx_message . timestamp ) - self . PERIOD ) <= self . DELTA ) [EOL] [EOL] for rx_index , rx_message in enumerate ( results_odd ) : [EOL] tx_message = messages_odd [ start_index_odd ] [EOL] [EOL] self . assertEqual ( tx_message . arbitration_id , rx_message . arbitration_id ) [EOL] self . assertEqual ( tx_message . dlc , rx_message . dlc ) [EOL] self . assertEqual ( tx_message . data , rx_message . data ) [EOL] self . assertEqual ( tx_message . is_extended_id , rx_message . is_extended_id ) [EOL] self . assertEqual ( tx_message . is_remote_frame , rx_message . is_remote_frame ) [EOL] self . assertEqual ( tx_message . is_error_frame , rx_message . is_error_frame ) [EOL] self . assertEqual ( tx_message . is_fd , rx_message . is_fd ) [EOL] [EOL] start_index_odd = ( start_index_odd + [number] ) % len ( messages_odd ) [EOL] [EOL] if rx_index != [number] : [EOL] prev_rx_message = results_odd [ rx_index - [number] ] [EOL] [comment] [EOL] self . assertTrue ( abs ( ( rx_message . timestamp - prev_rx_message . timestamp ) - self . PERIOD ) <= self . DELTA ) [EOL] [EOL] def test_modify_data_message ( self ) : [EOL] message_odd = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] message_even = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] task = self . _send_bus . send_periodic ( message_odd , self . PERIOD ) [EOL] self . assertIsInstance ( task , can . broadcastmanager . ModifiableCyclicTaskABC ) [EOL] [EOL] results_odd = [ ] [EOL] results_even = [ ] [EOL] for _ in range ( [number] * [number] ) : [EOL] result = self . _recv_bus . recv ( self . PERIOD * [number] ) [EOL] if result : [EOL] results_odd . append ( result ) [EOL] [EOL] task . modify_data ( message_even ) [EOL] for _ in range ( [number] * [number] ) : [EOL] result = self . _recv_bus . recv ( self . PERIOD * [number] ) [EOL] if result : [EOL] results_even . append ( result ) [EOL] [EOL] task . stop ( ) [EOL] [EOL] [comment] [EOL] for rx_index , rx_message in enumerate ( results_even ) : [EOL] tx_message = message_even [EOL] [EOL] self . assertEqual ( tx_message . arbitration_id , rx_message . arbitration_id ) [EOL] self . assertEqual ( tx_message . dlc , rx_message . dlc ) [EOL] self . assertEqual ( tx_message . data , rx_message . data ) [EOL] self . assertEqual ( tx_message . is_extended_id , rx_message . is_extended_id ) [EOL] self . assertEqual ( tx_message . is_remote_frame , rx_message . is_remote_frame ) [EOL] self . assertEqual ( tx_message . is_error_frame , rx_message . is_error_frame ) [EOL] self . assertEqual ( tx_message . is_fd , rx_message . is_fd ) [EOL] [EOL] if rx_index != [number] : [EOL] prev_rx_message = results_even [ rx_index - [number] ] [EOL] [comment] [EOL] self . assertTrue ( abs ( ( rx_message . timestamp - prev_rx_message . timestamp ) - self . PERIOD ) <= self . DELTA ) [EOL] [EOL] for rx_index , rx_message in enumerate ( results_odd ) : [EOL] tx_message = message_odd [EOL] [EOL] self . assertEqual ( tx_message . arbitration_id , rx_message . arbitration_id ) [EOL] self . assertEqual ( tx_message . dlc , rx_message . dlc ) [EOL] self . assertEqual ( tx_message . data , rx_message . data ) [EOL] self . assertEqual ( tx_message . is_extended_id , rx_message . is_extended_id ) [EOL] self . assertEqual ( tx_message . is_remote_frame , rx_message . is_remote_frame ) [EOL] self . assertEqual ( tx_message . is_error_frame , rx_message . is_error_frame ) [EOL] self . assertEqual ( tx_message . is_fd , rx_message . is_fd ) [EOL] [EOL] if rx_index != [number] : [EOL] prev_rx_message = results_odd [ rx_index - [number] ] [EOL] [comment] [EOL] self . assertTrue ( abs ( ( rx_message . timestamp - prev_rx_message . timestamp ) - self . PERIOD ) <= self . DELTA ) [EOL] [EOL] def test_modify_data_invalid ( self ) : [EOL] message = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] task = self . _send_bus . send_periodic ( message , self . PERIOD ) [EOL] self . assertIsInstance ( task , can . broadcastmanager . ModifiableCyclicTaskABC ) [EOL] [EOL] time . sleep ( [number] * self . PERIOD ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] task . modify_data ( None ) [EOL] [EOL] def test_modify_data_unequal_lengths ( self ) : [EOL] message = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] new_messages = [ ] [EOL] new_messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] new_messages . append ( can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) ) [EOL] [EOL] task = self . _send_bus . send_periodic ( message , self . PERIOD ) [EOL] self . assertIsInstance ( task , can . broadcastmanager . ModifiableCyclicTaskABC ) [EOL] [EOL] time . sleep ( [number] * self . PERIOD ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] task . modify_data ( new_messages ) [EOL] [EOL] def test_modify_data_different_arbitration_id_than_original ( self ) : [EOL] old_message = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] new_message = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] [EOL] task = self . _send_bus . send_periodic ( old_message , self . PERIOD ) [EOL] self . assertIsInstance ( task , can . broadcastmanager . ModifiableCyclicTaskABC ) [EOL] [EOL] time . sleep ( [number] * self . PERIOD ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] task . modify_data ( new_message ) [EOL] [EOL] def test_stop_all_periodic_tasks_and_remove_task ( self ) : [EOL] message_a = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] message_b = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] message_c = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = False , ) [EOL] [EOL] [comment] [EOL] task_a = self . _send_bus . send_periodic ( message_a , self . PERIOD ) [EOL] task_b = self . _send_bus . send_periodic ( message_b , self . PERIOD ) [EOL] task_c = self . _send_bus . send_periodic ( message_c , self . PERIOD ) [EOL] [EOL] self . assertIsInstance ( task_a , can . broadcastmanager . ModifiableCyclicTaskABC ) [EOL] self . assertIsInstance ( task_b , can . broadcastmanager . ModifiableCyclicTaskABC ) [EOL] self . assertIsInstance ( task_c , can . broadcastmanager . ModifiableCyclicTaskABC ) [EOL] [EOL] for _ in range ( [number] ) : [EOL] _ = self . _recv_bus . recv ( self . PERIOD ) [EOL] [EOL] [comment] [EOL] self . _send_bus . stop_all_periodic_tasks ( remove_tasks = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] time . sleep ( [number] * self . PERIOD ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] successfully_stopped = False [EOL] for _ in range ( [number] ) : [EOL] rx_message = self . _recv_bus . recv ( self . PERIOD ) [EOL] [EOL] if rx_message is None : [EOL] successfully_stopped = True [EOL] break [EOL] self . assertTrue ( successfully_stopped , [string] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( [number] , len ( self . _send_bus . _periodic_tasks ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Tuple[typing.Any,...]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import unittest [EOL] [EOL] from can . interfaces . socketcan . utils import find_available_interfaces , error_code_to_str [EOL] [EOL] from . config import IS_LINUX , TEST_INTERFACE_SOCKETCAN [EOL] [EOL] [EOL] class TestSocketCanHelpers ( unittest . TestCase ) : [EOL] @ unittest . skipUnless ( IS_LINUX , [string] ) def test_error_code_to_str ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] test_data = list ( range ( [number] , [number] ) ) + [ - [number] , [number] , [number] , [number] , None ] [EOL] [EOL] for error_code in test_data : [EOL] string = error_code_to_str ( error_code ) [EOL] self . assertTrue ( string ) [comment] [EOL] [EOL] @ unittest . skipUnless ( IS_LINUX , [string] ) def test_find_available_interfaces ( self ) : [EOL] result = list ( find_available_interfaces ( ) ) [EOL] self . assertGreaterEqual ( len ( result ) , [number] ) [EOL] for entry in result : [EOL] self . assertRegex ( entry , [string] ) [EOL] if TEST_INTERFACE_SOCKETCAN : [EOL] self . assertGreaterEqual ( len ( result ) , [number] ) [EOL] self . assertIn ( [string] , result ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from copy import copy [EOL] from time import time [EOL] import gc [EOL] [EOL] import unittest [EOL] import pytest [EOL] [EOL] from can import MessageSync , Message [EOL] [EOL] from . config import IS_CI , IS_APPVEYOR , IS_TRAVIS , IS_OSX [EOL] from . message_helper import ComparingMessagesTestCase [EOL] from . data . example_data import TEST_MESSAGES_BASE [EOL] [EOL] [EOL] TEST_FEWER_MESSAGES = TEST_MESSAGES_BASE [ : : [number] ] [EOL] [EOL] [EOL] def inc ( value ) : [EOL] [docstring] [EOL] if IS_CI : [EOL] return value * [number] [EOL] else : [EOL] return value [EOL] [EOL] [EOL] @ unittest . skipIf ( IS_APPVEYOR or ( IS_TRAVIS and IS_OSX ) , [string] , ) class TestMessageSync ( unittest . TestCase , ComparingMessagesTestCase ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] unittest . TestCase . __init__ ( self , * args , ** kwargs ) [EOL] ComparingMessagesTestCase . __init__ ( self ) [EOL] [EOL] def setup_method ( self , _ ) : [EOL] [comment] [EOL] gc . disable ( ) [EOL] [EOL] def teardown_method ( self , _ ) : [EOL] [comment] [EOL] gc . enable ( ) [EOL] [EOL] @ pytest . mark . timeout ( inc ( [number] ) ) def test_general ( self ) : [EOL] messages = [ Message ( timestamp = [number] ) , Message ( timestamp = [number] ) , Message ( timestamp = [number] + [number] ) , Message ( timestamp = [number] + [number] + [number] ) , Message ( timestamp = [number] ) , ] [EOL] sync = MessageSync ( messages , gap = [number] ) [EOL] [EOL] start = time ( ) [EOL] collected = [ ] [EOL] timings = [ ] [EOL] for message in sync : [EOL] collected . append ( message ) [EOL] now = time ( ) [EOL] timings . append ( now - start ) [EOL] start = now [EOL] [EOL] self . assertMessagesEqual ( messages , collected ) [EOL] self . assertEqual ( len ( timings ) , len ( messages ) , [string] ) [EOL] [EOL] self . assertTrue ( [number] <= timings [ [number] ] < inc ( [number] ) , str ( timings [ [number] ] ) ) [EOL] self . assertTrue ( [number] <= timings [ [number] ] < inc ( [number] ) , str ( timings [ [number] ] ) ) [EOL] self . assertTrue ( [number] <= timings [ [number] ] < inc ( [number] ) , str ( timings [ [number] ] ) ) [EOL] self . assertTrue ( [number] <= timings [ [number] ] < inc ( [number] ) , str ( timings [ [number] ] ) ) [EOL] self . assertTrue ( [number] <= timings [ [number] ] < inc ( [number] ) , str ( timings [ [number] ] ) ) [EOL] [EOL] @ pytest . mark . timeout ( inc ( [number] ) * len ( TEST_FEWER_MESSAGES ) ) def test_skip ( self ) : [EOL] messages = copy ( TEST_FEWER_MESSAGES ) [EOL] sync = MessageSync ( messages , skip = [number] , gap = [number] ) [EOL] [EOL] before = time ( ) [EOL] collected = list ( sync ) [EOL] after = time ( ) [EOL] took = after - before [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert [number] < took < inc ( len ( messages ) * ( [number] + [number] ) ) , [string] . format ( took ) [EOL] [EOL] self . assertMessagesEqual ( messages , collected ) [EOL] [EOL] [EOL] if not IS_APPVEYOR : [comment] [EOL] [EOL] @ pytest . mark . timeout ( inc ( [number] ) ) @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) def test_gap ( timestamp_1 , timestamp_2 ) : [EOL] [docstring] [EOL] messages = [ Message ( arbitration_id = [number] , timestamp = timestamp_1 ) , Message ( arbitration_id = [number] , timestamp = timestamp_2 ) , ] [EOL] sync = MessageSync ( messages , gap = [number] ) [EOL] [EOL] gc . disable ( ) [EOL] before = time ( ) [EOL] collected = list ( sync ) [EOL] after = time ( ) [EOL] gc . enable ( ) [EOL] took = after - before [EOL] [EOL] assert [number] <= took < inc ( [number] ) [EOL] assert messages == collected [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Optional , Type [EOL] import test [EOL] import typing [EOL] import unittest [EOL] import warnings [EOL] [EOL] from can . util import rename_kwargs [EOL] [EOL] [EOL] class RenameKwargsTest ( unittest . TestCase ) : [EOL] expected_kwargs = dict ( a = [number] , b = [number] , c = [number] , d = [number] ) [EOL] [EOL] def _test ( self , kwargs , aliases ) : [EOL] [EOL] [comment] [EOL] with self . assertWarnsRegex ( DeprecationWarning , [string] ) : [EOL] rename_kwargs ( [string] , kwargs , aliases ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert kwargs == self . expected_kwargs [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] warnings . simplefilter ( [string] , DeprecationWarning ) [EOL] try : [EOL] rename_kwargs ( [string] , kwargs , aliases ) [EOL] finally : [EOL] warnings . resetwarnings ( ) [EOL] [EOL] def test_rename ( self ) : [EOL] kwargs = dict ( old_a = [number] , old_b = [number] , c = [number] , d = [number] ) [EOL] aliases = { [string] : [string] , [string] : [string] } [EOL] self . _test ( kwargs , aliases ) [EOL] [EOL] def test_obsolete ( self ) : [EOL] kwargs = dict ( a = [number] , b = [number] , c = [number] , d = [number] , z = [number] ) [EOL] aliases = { [string] : None } [EOL] self . _test ( kwargs , aliases ) [EOL] [EOL] def test_rename_and_obsolete ( self ) : [EOL] kwargs = dict ( old_a = [number] , old_b = [number] , c = [number] , d = [number] , z = [number] ) [EOL] aliases = { [string] : [string] , [string] : [string] , [string] : None } [EOL] self . _test ( kwargs , aliases ) [EOL] [EOL] def test_with_new_and_alias_present ( self ) : [EOL] kwargs = dict ( old_a = [number] , a = [number] , b = [number] , c = [number] , d = [number] , z = [number] ) [EOL] aliases = { [string] : [string] , [string] : [string] , [string] : None } [EOL] with self . assertRaises ( TypeError ) : [EOL] self . _test ( kwargs , aliases ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import unittest [EOL] [EOL] from can import Bus , Message [EOL] [EOL] from . data . example_data import TEST_ALL_MESSAGES [EOL] [EOL] [EOL] EXAMPLE_MSG = Message ( arbitration_id = [number] , is_extended_id = True ) [EOL] HIGHEST_MSG = Message ( arbitration_id = [number] , is_extended_id = True ) [EOL] [EOL] MATCH_EXAMPLE = [ { [string] : [number] , [string] : [number] , [string] : True } ] [EOL] [EOL] MATCH_ONLY_HIGHEST = [ { [string] : [number] , [string] : [number] , [string] : True } ] [EOL] [EOL] [EOL] class TestMessageFiltering ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . bus = Bus ( bustype = [string] , channel = [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . bus . shutdown ( ) [EOL] [EOL] def test_match_all ( self ) : [EOL] [comment] [EOL] self . bus . set_filters ( ) [EOL] self . assertTrue ( self . bus . _matches_filters ( EXAMPLE_MSG ) ) [EOL] [comment] [EOL] self . bus . set_filters ( None ) [EOL] self . assertTrue ( self . bus . _matches_filters ( EXAMPLE_MSG ) ) [EOL] [EOL] def test_match_filters_is_empty ( self ) : [EOL] self . bus . set_filters ( [ ] ) [EOL] for msg in TEST_ALL_MESSAGES : [EOL] self . assertTrue ( self . bus . _matches_filters ( msg ) ) [EOL] [EOL] def test_match_example_message ( self ) : [EOL] self . bus . set_filters ( MATCH_EXAMPLE ) [EOL] self . assertTrue ( self . bus . _matches_filters ( EXAMPLE_MSG ) ) [EOL] self . assertFalse ( self . bus . _matches_filters ( HIGHEST_MSG ) ) [EOL] self . bus . set_filters ( MATCH_ONLY_HIGHEST ) [EOL] self . assertFalse ( self . bus . _matches_filters ( EXAMPLE_MSG ) ) [EOL] self . assertTrue ( self . bus . _matches_filters ( HIGHEST_MSG ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import unittest [EOL] import can [EOL] [EOL] [EOL] class robotellTestCase ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] [comment] [EOL] self . bus = can . Bus ( [string] , bustype = [string] ) [EOL] self . serial = self . bus . serialPortOrig [EOL] self . serial . read ( self . serial . in_waiting ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . bus . shutdown ( ) [EOL] [EOL] def test_recv_extended ( self ) : [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] msg = self . bus . recv ( [number] ) [EOL] self . assertIsNotNone ( msg ) [EOL] self . assertEqual ( msg . arbitration_id , [number] ) [EOL] self . assertEqual ( msg . is_extended_id , True ) [EOL] self . assertEqual ( msg . is_remote_frame , False ) [EOL] self . assertEqual ( msg . dlc , [number] ) [EOL] self . assertSequenceEqual ( msg . data , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] [EOL] def test_send_extended ( self ) : [EOL] msg = can . Message ( arbitration_id = [number] , is_extended_id = True , data = [ [number] , [number] , [number] , [number] , [number] , [number] ] , ) [EOL] self . bus . send ( msg ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] self . assertEqual ( data , bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) , ) [EOL] [EOL] def test_recv_standard ( self ) : [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] msg = self . bus . recv ( [number] ) [EOL] self . assertIsNotNone ( msg ) [EOL] self . assertEqual ( msg . arbitration_id , [number] ) [EOL] self . assertEqual ( msg . is_extended_id , False ) [EOL] self . assertEqual ( msg . is_remote_frame , False ) [EOL] self . assertEqual ( msg . dlc , [number] ) [EOL] self . assertSequenceEqual ( msg . data , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] [EOL] def test_send_standard ( self ) : [EOL] msg = can . Message ( arbitration_id = [number] , is_extended_id = False , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ) [EOL] self . bus . send ( msg ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] self . assertEqual ( data , bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) , ) [EOL] [EOL] def test_recv_extended_remote ( self ) : [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] msg = self . bus . recv ( [number] ) [EOL] self . assertIsNotNone ( msg ) [EOL] self . assertEqual ( msg . arbitration_id , [number] ) [EOL] self . assertEqual ( msg . is_extended_id , True ) [EOL] self . assertEqual ( msg . is_remote_frame , True ) [EOL] self . assertEqual ( msg . dlc , [number] ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] [EOL] def test_send_extended_remote ( self ) : [EOL] msg = can . Message ( arbitration_id = [number] , is_extended_id = True , is_remote_frame = True , dlc = [number] ) [EOL] self . bus . send ( msg ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] self . assertEqual ( data , bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) , ) [EOL] [EOL] def test_partial_recv ( self ) : [EOL] [comment] [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] msg = self . bus . recv ( [number] ) [EOL] self . assertIsNone ( msg ) [EOL] [EOL] [comment] [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] msg = self . bus . recv ( [number] ) [EOL] self . assertIsNotNone ( msg ) [EOL] self . assertEqual ( msg . arbitration_id , [number] ) [EOL] self . assertEqual ( msg . is_extended_id , False ) [EOL] self . assertEqual ( msg . is_remote_frame , False ) [EOL] self . assertEqual ( msg . dlc , [number] ) [EOL] self . assertSequenceEqual ( msg . data , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [comment] [EOL] msg = self . bus . recv ( [number] ) [EOL] self . assertIsNotNone ( msg ) [EOL] self . assertEqual ( msg . arbitration_id , [number] ) [EOL] self . assertEqual ( msg . is_extended_id , True ) [EOL] self . assertEqual ( msg . is_remote_frame , False ) [EOL] self . assertEqual ( msg . dlc , [number] ) [EOL] self . assertSequenceEqual ( msg . data , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [comment] [EOL] msg = self . bus . recv ( [number] ) [EOL] self . assertIsNone ( msg ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] [EOL] def test_serial_number ( self ) : [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] sn = self . bus . get_serial_number ( [number] ) [EOL] self . assertEqual ( sn , [string] ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] self . assertEqual ( data , bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) , ) [EOL] [EOL] sn = self . bus . get_serial_number ( [number] ) [EOL] self . assertIsNone ( sn ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] [EOL] def test_set_bitrate ( self ) : [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . bus . set_bitrate ( [number] ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] self . assertEqual ( data , bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) , ) [EOL] [EOL] def test_set_auto_retransmit ( self ) : [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . bus . set_auto_retransmit ( True ) [EOL] self . bus . set_auto_retransmit ( False ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] self . assertEqual ( data , bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) , ) [EOL] [EOL] def test_set_auto_bus_management ( self ) : [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . bus . set_auto_bus_management ( True ) [EOL] self . bus . set_auto_bus_management ( False ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] self . assertEqual ( data , bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) , ) [EOL] [EOL] def test_set_serial_rate ( self ) : [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . bus . set_serial_rate ( [number] ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] self . assertEqual ( data , bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) , ) [EOL] [EOL] def test_set_hw_filter ( self ) : [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . serial . write ( bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) ) [EOL] self . bus . set_hw_filter ( [number] , True , [number] , [number] , False ) [EOL] self . bus . set_hw_filter ( [number] , True , [number] , [number] , True ) [EOL] self . bus . set_hw_filter ( [number] , False , [number] , [number] , False ) [EOL] data = self . serial . read ( self . serial . in_waiting ) [EOL] self . assertEqual ( data , bytearray ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import time [EOL] import logging [EOL] import unittest [EOL] from unittest . mock import Mock , patch [EOL] [EOL] import pytest [EOL] [EOL] import can [EOL] from can . interfaces import cantact [EOL] [EOL] [EOL] class CantactTest ( unittest . TestCase ) : [EOL] def test_bus_creation ( self ) : [EOL] bus = can . Bus ( channel = [number] , bustype = [string] , _testing = True ) [EOL] self . assertIsInstance ( bus , cantact . CantactBus ) [EOL] cantact . MockInterface . set_bitrate . assert_called ( ) [EOL] cantact . MockInterface . set_bit_timing . assert_not_called ( ) [EOL] cantact . MockInterface . set_enabled . assert_called ( ) [EOL] cantact . MockInterface . set_monitor . assert_called ( ) [EOL] cantact . MockInterface . start . assert_called ( ) [EOL] [EOL] def test_bus_creation_bittiming ( self ) : [EOL] cantact . MockInterface . set_bitrate . reset_mock ( ) [EOL] [EOL] bt = can . BitTiming ( tseg1 = [number] , tseg2 = [number] , brp = [number] , sjw = [number] ) [EOL] bus = can . Bus ( channel = [number] , bustype = [string] , bit_timing = bt , _testing = True ) [EOL] self . assertIsInstance ( bus , cantact . CantactBus ) [EOL] cantact . MockInterface . set_bitrate . assert_not_called ( ) [EOL] cantact . MockInterface . set_bit_timing . assert_called ( ) [EOL] cantact . MockInterface . set_enabled . assert_called ( ) [EOL] cantact . MockInterface . set_monitor . assert_called ( ) [EOL] cantact . MockInterface . start . assert_called ( ) [EOL] [EOL] def test_transmit ( self ) : [EOL] bus = can . Bus ( channel = [number] , bustype = [string] , _testing = True ) [EOL] msg = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = True ) [EOL] bus . send ( msg ) [EOL] cantact . MockInterface . send . assert_called ( ) [EOL] [EOL] def test_recv ( self ) : [EOL] bus = can . Bus ( channel = [number] , bustype = [string] , _testing = True ) [EOL] frame = bus . recv ( timeout = [number] ) [EOL] cantact . MockInterface . recv . assert_called ( ) [EOL] self . assertIsInstance ( frame , can . Message ) [EOL] [EOL] def test_recv_timeout ( self ) : [EOL] bus = can . Bus ( channel = [number] , bustype = [string] , _testing = True ) [EOL] frame = bus . recv ( timeout = [number] ) [EOL] cantact . MockInterface . recv . assert_called ( ) [EOL] self . assertIsNone ( frame ) [EOL] [EOL] def test_shutdown ( self ) : [EOL] bus = can . Bus ( channel = [number] , bustype = [string] , _testing = True ) [EOL] bus . shutdown ( ) [EOL] cantact . MockInterface . stop . assert_called ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , IO , Any , Type [EOL] import test [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] import unittest [EOL] import tempfile [EOL] import os [EOL] from abc import abstractmethod , ABCMeta [EOL] from itertools import zip_longest [EOL] [EOL] import can [EOL] [EOL] from . data . example_data import ( TEST_MESSAGES_BASE , TEST_MESSAGES_REMOTE_FRAMES , TEST_MESSAGES_ERROR_FRAMES , TEST_MESSAGES_CAN_FD , TEST_COMMENTS , sort_messages , ) [EOL] from . message_helper import ComparingMessagesTestCase [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] [EOL] class ReaderWriterExtensionTest ( unittest . TestCase ) : [EOL] message_writers_and_readers = { } [EOL] for suffix , writer in can . Logger . message_writers . items ( ) : [EOL] message_writers_and_readers [ suffix ] = ( writer , can . LogReader . message_readers . get ( suffix ) , ) [EOL] [EOL] def test_extension_matching ( self ) : [EOL] for suffix , ( writer , reader ) in self . message_writers_and_readers . items ( ) : [EOL] suffix_variants = [ suffix . upper ( ) , suffix . lower ( ) , [string] . join ( [ c . upper ( ) if i % [number] else c for i , c in enumerate ( suffix ) ] ) , ] [EOL] for suffix_variant in suffix_variants : [EOL] tmp_file = tempfile . NamedTemporaryFile ( suffix = suffix_variant , delete = False ) [EOL] tmp_file . close ( ) [EOL] try : [EOL] with can . Logger ( tmp_file . name ) as logger : [EOL] assert type ( logger ) == writer [EOL] if reader is not None : [EOL] with can . LogReader ( tmp_file . name ) as player : [EOL] assert type ( player ) == reader [EOL] finally : [EOL] os . remove ( tmp_file . name ) [EOL] [EOL] [EOL] class ReaderWriterTest ( unittest . TestCase , ComparingMessagesTestCase , metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] unittest . TestCase . __init__ ( self , * args , ** kwargs ) [EOL] self . _setup_instance ( ) [EOL] [EOL] @ abstractmethod def _setup_instance ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def _setup_instance_helper ( self , writer_constructor , reader_constructor , binary_file = False , check_remote_frames = True , check_error_frames = True , check_fd = True , check_comments = False , test_append = False , allowed_timestamp_delta = [number] , preserves_channel = True , adds_default_channel = None , ) : [EOL] [docstring] [EOL] [comment] [EOL] self . original_messages = list ( TEST_MESSAGES_BASE ) [EOL] if check_remote_frames : [EOL] self . original_messages += TEST_MESSAGES_REMOTE_FRAMES [EOL] if check_error_frames : [EOL] self . original_messages += TEST_MESSAGES_ERROR_FRAMES [EOL] if check_fd : [EOL] self . original_messages += TEST_MESSAGES_CAN_FD [EOL] [EOL] [comment] [EOL] self . original_messages = sort_messages ( self . original_messages ) [EOL] [EOL] if check_comments : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] attrs = [ attr for attr in dir ( writer_constructor ) if not attr . startswith ( [string] ) ] [EOL] assert ( [string] in attrs ) , [string] . format ( writer_constructor ) [EOL] [EOL] [comment] [EOL] self . original_comments = TEST_COMMENTS if check_comments else ( ) [EOL] [EOL] self . writer_constructor = writer_constructor [EOL] self . reader_constructor = reader_constructor [EOL] self . binary_file = binary_file [EOL] self . test_append_enabled = test_append [EOL] [EOL] ComparingMessagesTestCase . __init__ ( self , allowed_timestamp_delta = allowed_timestamp_delta , preserves_channel = preserves_channel , ) [EOL] [comment] [EOL] [EOL] def setUp ( self ) : [EOL] with tempfile . NamedTemporaryFile ( [string] , delete = False ) as test_file : [EOL] self . test_file_name = test_file . name [EOL] [EOL] def tearDown ( self ) : [EOL] os . remove ( self . test_file_name ) [EOL] del self . test_file_name [EOL] [EOL] def test_path_like_explicit_stop ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] writer = self . writer_constructor ( self . test_file_name ) [EOL] self . _write_all ( writer ) [EOL] self . _ensure_fsync ( writer ) [EOL] writer . stop ( ) [EOL] if hasattr ( writer . file , [string] ) : [EOL] self . assertTrue ( writer . file . closed ) [EOL] [EOL] print ( [string] ) [EOL] reader = self . reader_constructor ( self . test_file_name ) [EOL] read_messages = list ( reader ) [EOL] [comment] [EOL] reader . stop ( ) [EOL] if hasattr ( writer . file , [string] ) : [EOL] self . assertTrue ( writer . file . closed ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( len ( read_messages ) , len ( self . original_messages ) , [string] , ) [EOL] [EOL] self . assertMessagesEqual ( self . original_messages , read_messages ) [EOL] self . assertIncludesComments ( self . test_file_name ) [EOL] [EOL] def test_path_like_context_manager ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] with self . writer_constructor ( self . test_file_name ) as writer : [EOL] self . _write_all ( writer ) [EOL] self . _ensure_fsync ( writer ) [EOL] w = writer [EOL] if hasattr ( w . file , [string] ) : [EOL] self . assertTrue ( w . file . closed ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] with self . reader_constructor ( self . test_file_name ) as reader : [EOL] read_messages = list ( reader ) [EOL] r = reader [EOL] if hasattr ( r . file , [string] ) : [EOL] self . assertTrue ( r . file . closed ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( len ( read_messages ) , len ( self . original_messages ) , [string] , ) [EOL] [EOL] self . assertMessagesEqual ( self . original_messages , read_messages ) [EOL] self . assertIncludesComments ( self . test_file_name ) [EOL] [EOL] def test_file_like_explicit_stop ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] my_file = open ( self . test_file_name , [string] if self . binary_file else [string] ) [EOL] writer = self . writer_constructor ( my_file ) [EOL] self . _write_all ( writer ) [EOL] self . _ensure_fsync ( writer ) [EOL] writer . stop ( ) [EOL] if hasattr ( my_file , [string] ) : [EOL] self . assertTrue ( my_file . closed ) [EOL] [EOL] print ( [string] ) [EOL] my_file = open ( self . test_file_name , [string] if self . binary_file else [string] ) [EOL] reader = self . reader_constructor ( my_file ) [EOL] read_messages = list ( reader ) [EOL] [comment] [EOL] reader . stop ( ) [EOL] if hasattr ( my_file , [string] ) : [EOL] self . assertTrue ( my_file . closed ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( len ( read_messages ) , len ( self . original_messages ) , [string] , ) [EOL] [EOL] self . assertMessagesEqual ( self . original_messages , read_messages ) [EOL] self . assertIncludesComments ( self . test_file_name ) [EOL] [EOL] def test_file_like_context_manager ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] my_file = open ( self . test_file_name , [string] if self . binary_file else [string] ) [EOL] with self . writer_constructor ( my_file ) as writer : [EOL] self . _write_all ( writer ) [EOL] self . _ensure_fsync ( writer ) [EOL] w = writer [EOL] if hasattr ( my_file , [string] ) : [EOL] self . assertTrue ( my_file . closed ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] my_file = open ( self . test_file_name , [string] if self . binary_file else [string] ) [EOL] with self . reader_constructor ( my_file ) as reader : [EOL] read_messages = list ( reader ) [EOL] r = reader [EOL] if hasattr ( my_file , [string] ) : [EOL] self . assertTrue ( my_file . closed ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( len ( read_messages ) , len ( self . original_messages ) , [string] , ) [EOL] [EOL] self . assertMessagesEqual ( self . original_messages , read_messages ) [EOL] self . assertIncludesComments ( self . test_file_name ) [EOL] [EOL] def test_append_mode ( self ) : [EOL] [docstring] [EOL] if not self . test_append_enabled : [EOL] raise unittest . SkipTest ( [string] ) [EOL] [EOL] count = len ( self . original_messages ) [EOL] first_part = self . original_messages [ : count // [number] ] [EOL] second_part = self . original_messages [ count // [number] : ] [EOL] [EOL] [comment] [EOL] with self . writer_constructor ( self . test_file_name ) as writer : [EOL] for message in first_part : [EOL] writer ( message ) [EOL] self . _ensure_fsync ( writer ) [EOL] [EOL] [comment] [EOL] try : [EOL] writer = self . writer_constructor ( self . test_file_name , append = True ) [EOL] except TypeError as e : [EOL] [comment] [EOL] try : [EOL] writer = self . writer_constructor ( self . test_file_name ) [EOL] except TypeError : [EOL] [comment] [EOL] raise e [EOL] with writer : [EOL] for message in second_part : [EOL] writer ( message ) [EOL] self . _ensure_fsync ( writer ) [EOL] with self . reader_constructor ( self . test_file_name ) as reader : [EOL] read_messages = list ( reader ) [EOL] [EOL] self . assertMessagesEqual ( self . original_messages , read_messages ) [EOL] [EOL] def _write_all ( self , writer ) : [EOL] [docstring] [EOL] [comment] [EOL] for msg , comment in zip_longest ( self . original_messages , self . original_comments , fillvalue = None ) : [EOL] [comment] [EOL] if comment is not None : [EOL] print ( [string] , comment ) [EOL] writer . log_event ( comment ) [comment] [EOL] if msg is not None : [EOL] print ( [string] , msg ) [EOL] writer ( msg ) [EOL] [EOL] def _ensure_fsync ( self , io_handler ) : [EOL] if hasattr ( io_handler . file , [string] ) : [EOL] io_handler . file . flush ( ) [EOL] os . fsync ( io_handler . file . fileno ( ) ) [EOL] [EOL] def assertIncludesComments ( self , filename ) : [EOL] [docstring] [EOL] if self . original_comments : [EOL] [comment] [EOL] with open ( filename , [string] if self . binary_file else [string] ) as file : [EOL] output_contents = file . read ( ) [EOL] [comment] [EOL] for comment in self . original_comments : [EOL] self . assertIn ( comment , output_contents ) [EOL] [EOL] [EOL] class TestAscFileFormat ( ReaderWriterTest ) : [EOL] [docstring] [EOL] [EOL] def _setup_instance ( self ) : [EOL] super ( ) . _setup_instance_helper ( can . ASCWriter , can . ASCReader , check_fd = True , check_comments = True , preserves_channel = False , adds_default_channel = [number] , ) [EOL] [EOL] def _read_log_file ( self , filename ) : [EOL] logfile = os . path . join ( os . path . dirname ( __file__ ) , [string] , filename ) [EOL] with can . ASCReader ( logfile ) as reader : [EOL] return list ( reader ) [EOL] [EOL] def test_can_message ( self ) : [EOL] expected_messages = [ can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , is_rx = False , channel = [number] , dlc = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ) , can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , channel = [number] , dlc = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ) , ] [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , expected_messages ) [EOL] [EOL] def test_can_remote_message ( self ) : [EOL] expected_messages = [ can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , channel = [number] , is_remote_frame = True , ) , can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , is_rx = False , channel = [number] , is_remote_frame = True , ) , can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , channel = [number] , dlc = [number] , is_remote_frame = True , ) , ] [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , expected_messages ) [EOL] [EOL] def test_can_fd_remote_message ( self ) : [EOL] expected_messages = [ can . Message ( timestamp = [number] , arbitration_id = [number] , channel = [number] , dlc = [number] , is_rx = False , is_fd = True , is_remote_frame = True , error_state_indicator = True , ) ] [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , expected_messages ) [EOL] [EOL] def test_can_fd_message ( self ) : [EOL] expected_messages = [ can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , channel = [number] , dlc = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , is_fd = True , bitrate_switch = True , ) , can . Message ( timestamp = [number] , arbitration_id = [number] , channel = [number] , dlc = [number] , is_rx = False , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , is_fd = True , error_state_indicator = True , ) , can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , channel = [number] , dlc = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , is_fd = True , bitrate_switch = True , error_state_indicator = True , ) , ] [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , expected_messages ) [EOL] [EOL] def test_can_fd_message_64 ( self ) : [EOL] expected_messages = [ can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , channel = [number] , dlc = [number] , data = [ [number] , [number] , [number] , [number] ] + [number] * [ [number] ] + [ [number] ] , is_fd = True , error_state_indicator = True , ) , can . Message ( timestamp = [number] , arbitration_id = [number] , channel = [number] , dlc = [number] , data = [ [number] , [number] , [number] , [number] ] + [number] * [ [number] ] + [ [number] ] , is_fd = True , bitrate_switch = True , ) , ] [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , expected_messages ) [EOL] [EOL] def test_can_and_canfd_error_frames ( self ) : [EOL] expected_messages = [ can . Message ( timestamp = [number] , channel = [number] , is_error_frame = True ) , can . Message ( timestamp = [number] , channel = [number] , is_error_frame = True ) , can . Message ( timestamp = [number] , channel = [number] , is_error_frame = True ) , can . Message ( timestamp = [number] , channel = [number] , is_rx = False , is_error_frame = True , is_fd = True , ) , ] [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , expected_messages ) [EOL] [EOL] [EOL] class TestBlfFileFormat ( ReaderWriterTest ) : [EOL] [docstring] [EOL] [EOL] def _setup_instance ( self ) : [EOL] super ( ) . _setup_instance_helper ( can . BLFWriter , can . BLFReader , binary_file = True , check_fd = True , check_comments = False , test_append = True , allowed_timestamp_delta = [number] , preserves_channel = False , adds_default_channel = [number] , ) [EOL] [EOL] def _read_log_file ( self , filename ) : [EOL] logfile = os . path . join ( os . path . dirname ( __file__ ) , [string] , filename ) [EOL] with can . BLFReader ( logfile ) as reader : [EOL] return list ( reader ) [EOL] [EOL] def test_can_message ( self ) : [EOL] expected = can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , channel = [number] , dlc = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ) [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , [ expected ] * [number] ) [EOL] self . assertEqual ( actual [ [number] ] . channel , expected . channel ) [EOL] [EOL] def test_can_message_2 ( self ) : [EOL] expected = can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , channel = [number] , dlc = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ) [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , [ expected ] * [number] ) [EOL] self . assertEqual ( actual [ [number] ] . channel , expected . channel ) [EOL] [EOL] def test_can_fd_message ( self ) : [EOL] expected = can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , channel = [number] , dlc = [number] , is_fd = True , bitrate_switch = True , error_state_indicator = True , data = range ( [number] ) , ) [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , [ expected ] * [number] ) [EOL] self . assertEqual ( actual [ [number] ] . channel , expected . channel ) [EOL] [EOL] def test_can_fd_message_64 ( self ) : [EOL] expected = can . Message ( timestamp = [number] , arbitration_id = [number] , is_extended_id = False , is_remote_frame = True , channel = [number] , dlc = [number] , is_fd = True , bitrate_switch = True , error_state_indicator = True , ) [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , [ expected ] * [number] ) [EOL] self . assertEqual ( actual [ [number] ] . channel , expected . channel ) [EOL] [EOL] def test_can_error_frame_ext ( self ) : [EOL] expected = can . Message ( timestamp = [number] , is_error_frame = True , arbitration_id = [number] , is_extended_id = True , channel = [number] , dlc = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ) [EOL] actual = self . _read_log_file ( [string] ) [EOL] self . assertMessagesEqual ( actual , [ expected ] * [number] ) [EOL] self . assertEqual ( actual [ [number] ] . channel , expected . channel ) [EOL] [EOL] [EOL] class TestCanutilsFileFormat ( ReaderWriterTest ) : [EOL] [docstring] [EOL] [EOL] def _setup_instance ( self ) : [EOL] super ( ) . _setup_instance_helper ( can . CanutilsLogWriter , can . CanutilsLogReader , check_fd = False , test_append = True , check_comments = False , preserves_channel = False , adds_default_channel = [string] , ) [EOL] [EOL] [EOL] class TestCsvFileFormat ( ReaderWriterTest ) : [EOL] [docstring] [EOL] [EOL] def _setup_instance ( self ) : [EOL] super ( ) . _setup_instance_helper ( can . CSVWriter , can . CSVReader , check_fd = False , test_append = True , check_comments = False , preserves_channel = False , adds_default_channel = None , ) [EOL] [EOL] [EOL] class TestSqliteDatabaseFormat ( ReaderWriterTest ) : [EOL] [docstring] [EOL] [EOL] def _setup_instance ( self ) : [EOL] super ( ) . _setup_instance_helper ( can . SqliteWriter , can . SqliteReader , check_fd = False , test_append = True , check_comments = False , preserves_channel = False , adds_default_channel = None , ) [EOL] [EOL] @ unittest . skip ( [string] ) def test_file_like_explicit_stop ( self ) : [EOL] pass [EOL] [EOL] @ unittest . skip ( [string] ) def test_file_like_context_manager ( self ) : [EOL] pass [EOL] [EOL] def test_read_all ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] print ( [string] ) [EOL] with self . writer_constructor ( self . test_file_name ) as writer : [EOL] self . _write_all ( writer ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] with self . reader_constructor ( self . test_file_name ) as reader : [EOL] read_messages = list ( reader . read_all ( ) ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( len ( read_messages ) , len ( self . original_messages ) , [string] , ) [EOL] [EOL] self . assertMessagesEqual ( self . original_messages , read_messages ) [EOL] [EOL] [EOL] class TestPrinter ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] messages = ( TEST_MESSAGES_BASE + TEST_MESSAGES_REMOTE_FRAMES + TEST_MESSAGES_ERROR_FRAMES ) [EOL] [EOL] def test_not_crashes_with_stdout ( self ) : [EOL] with can . Printer ( ) as printer : [EOL] for message in self . messages : [EOL] printer ( message ) [EOL] [EOL] def test_not_crashes_with_file ( self ) : [EOL] with tempfile . NamedTemporaryFile ( [string] , delete = False ) as temp_file : [EOL] with can . Printer ( temp_file ) as printer : [EOL] for message in self . messages : [EOL] printer ( message ) [EOL] [EOL] [EOL] [comment] [EOL] del ReaderWriterTest [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.logformats_test.TestPrinter]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Union , Tuple , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import ctypes [EOL] import time [EOL] import logging [EOL] import unittest [EOL] from unittest . mock import Mock , patch [EOL] [EOL] import pytest [EOL] [EOL] import can [EOL] from can . interfaces . kvaser import canlib [EOL] from can . interfaces . kvaser import constants [EOL] [EOL] [EOL] class KvaserTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] canlib . canGetNumberOfChannels = KvaserTest . canGetNumberOfChannels [EOL] canlib . canOpenChannel = Mock ( return_value = [number] ) [EOL] canlib . canIoCtl = Mock ( return_value = [number] ) [EOL] canlib . kvReadTimer = Mock ( ) [EOL] canlib . canSetBusParams = Mock ( ) [EOL] canlib . canSetBusParamsFd = Mock ( ) [EOL] canlib . canBusOn = Mock ( ) [EOL] canlib . canBusOff = Mock ( ) [EOL] canlib . canClose = Mock ( ) [EOL] canlib . canSetBusOutputControl = Mock ( ) [EOL] canlib . canGetChannelData = Mock ( ) [EOL] canlib . canSetAcceptanceFilter = Mock ( ) [EOL] canlib . canWriteSync = Mock ( ) [EOL] canlib . canWrite = self . canWrite [EOL] canlib . canReadWait = self . canReadWait [EOL] canlib . canGetBusStatistics = Mock ( ) [EOL] canlib . canRequestBusStatistics = Mock ( ) [EOL] [EOL] self . msg = { } [EOL] self . msg_in_cue = None [EOL] self . bus = can . Bus ( channel = [number] , bustype = [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] if self . bus : [EOL] self . bus . shutdown ( ) [EOL] self . bus = None [EOL] [EOL] def test_bus_creation ( self ) : [EOL] self . assertIsInstance ( self . bus , canlib . KvaserBus ) [EOL] self . assertTrue ( canlib . canOpenChannel . called ) [EOL] self . assertTrue ( canlib . canBusOn . called ) [EOL] [EOL] def test_bus_shutdown ( self ) : [EOL] self . bus . shutdown ( ) [EOL] self . assertTrue ( canlib . canBusOff . called ) [EOL] self . assertTrue ( canlib . canClose . called ) [EOL] [EOL] def test_filter_setup ( self ) : [EOL] [comment] [EOL] expected_args = [ ( ( [number] , [number] , [number] , [number] ) , ) , ( ( [number] , [number] , [number] , [number] ) , ) , ( ( [number] , [number] , [number] , [number] ) , ) , ( ( [number] , [number] , [number] , [number] ) , ) , ] [EOL] self . assertEqual ( canlib . canSetAcceptanceFilter . call_args_list , expected_args ) [EOL] [EOL] [comment] [EOL] canlib . canSetAcceptanceFilter . reset_mock ( ) [EOL] self . bus . set_filters ( [ { [string] : [number] , [string] : [number] , [string] : True } ] ) [EOL] expected_args = [ ( ( [number] , [number] , [number] , [number] ) , ) , ( ( [number] , [number] , [number] , [number] ) , ) , ] [EOL] self . assertEqual ( canlib . canSetAcceptanceFilter . call_args_list , expected_args ) [EOL] [EOL] [comment] [EOL] canlib . canSetAcceptanceFilter . reset_mock ( ) [EOL] multiple_filters = [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , ] [EOL] self . bus . set_filters ( multiple_filters ) [EOL] expected_args = [ ( ( [number] , [number] , [number] , [number] ) , ) , ( ( [number] , [number] , [number] , [number] ) , ) , ( ( [number] , [number] , [number] , [number] ) , ) , ( ( [number] , [number] , [number] , [number] ) , ) , ] [EOL] self . assertEqual ( canlib . canSetAcceptanceFilter . call_args_list , expected_args ) [EOL] [EOL] def test_send_extended ( self ) : [EOL] msg = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = True ) [EOL] [EOL] self . bus . send ( msg ) [EOL] [EOL] self . assertEqual ( self . msg [ [string] ] , [number] ) [EOL] self . assertEqual ( self . msg [ [string] ] , [number] ) [EOL] self . assertEqual ( self . msg [ [string] ] , constants . canMSG_EXT ) [EOL] self . assertSequenceEqual ( self . msg [ [string] ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_send_standard ( self ) : [EOL] msg = can . Message ( arbitration_id = [number] , data = [ [number] , [number] ] , is_extended_id = False ) [EOL] [EOL] self . bus . send ( msg ) [EOL] [EOL] self . assertEqual ( self . msg [ [string] ] , [number] ) [EOL] self . assertEqual ( self . msg [ [string] ] , [number] ) [EOL] self . assertEqual ( self . msg [ [string] ] , constants . canMSG_STD ) [EOL] self . assertSequenceEqual ( self . msg [ [string] ] , [ [number] , [number] ] ) [EOL] [EOL] @ pytest . mark . timeout ( [number] ) def test_recv_no_message ( self ) : [EOL] self . assertEqual ( self . bus . recv ( timeout = [number] ) , None ) [EOL] [EOL] def test_recv_extended ( self ) : [EOL] self . msg_in_cue = can . Message ( arbitration_id = [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , is_extended_id = True ) [EOL] [EOL] now = time . time ( ) [EOL] msg = self . bus . recv ( ) [EOL] self . assertEqual ( msg . arbitration_id , [number] ) [EOL] self . assertEqual ( msg . dlc , [number] ) [EOL] self . assertEqual ( msg . is_extended_id , True ) [EOL] self . assertSequenceEqual ( msg . data , self . msg_in_cue . data ) [EOL] self . assertTrue ( now - [number] < msg . timestamp < now + [number] ) [EOL] [EOL] def test_recv_standard ( self ) : [EOL] self . msg_in_cue = can . Message ( arbitration_id = [number] , data = [ [number] , [number] ] , is_extended_id = False ) [EOL] [EOL] msg = self . bus . recv ( ) [EOL] self . assertEqual ( msg . arbitration_id , [number] ) [EOL] self . assertEqual ( msg . dlc , [number] ) [EOL] self . assertEqual ( msg . is_extended_id , False ) [EOL] self . assertSequenceEqual ( msg . data , [ [number] , [number] ] ) [EOL] [EOL] def test_available_configs ( self ) : [EOL] configs = canlib . KvaserBus . _detect_available_configs ( ) [EOL] expected = [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , ] [EOL] self . assertListEqual ( configs , expected ) [EOL] [EOL] def test_canfd_default_data_bitrate ( self ) : [EOL] canlib . canSetBusParams . reset_mock ( ) [EOL] canlib . canSetBusParamsFd . reset_mock ( ) [EOL] can . Bus ( channel = [number] , bustype = [string] , fd = True ) [EOL] canlib . canSetBusParams . assert_called_once_with ( [number] , constants . canFD_BITRATE_500K_80P , [number] , [number] , [number] , [number] , [number] ) [EOL] canlib . canSetBusParamsFd . assert_called_once_with ( [number] , constants . canFD_BITRATE_500K_80P , [number] , [number] , [number] ) [EOL] [EOL] def test_canfd_nondefault_data_bitrate ( self ) : [EOL] canlib . canSetBusParams . reset_mock ( ) [EOL] canlib . canSetBusParamsFd . reset_mock ( ) [EOL] data_bitrate = [number] [EOL] can . Bus ( channel = [number] , bustype = [string] , fd = True , data_bitrate = data_bitrate ) [EOL] bitrate_constant = canlib . BITRATE_FD [ data_bitrate ] [EOL] canlib . canSetBusParams . assert_called_once_with ( [number] , constants . canFD_BITRATE_500K_80P , [number] , [number] , [number] , [number] , [number] ) [EOL] canlib . canSetBusParamsFd . assert_called_once_with ( [number] , bitrate_constant , [number] , [number] , [number] ) [EOL] [EOL] def test_canfd_custom_data_bitrate ( self ) : [EOL] canlib . canSetBusParams . reset_mock ( ) [EOL] canlib . canSetBusParamsFd . reset_mock ( ) [EOL] data_bitrate = [number] [EOL] can . Bus ( channel = [number] , bustype = [string] , fd = True , data_bitrate = data_bitrate ) [EOL] canlib . canSetBusParams . assert_called_once_with ( [number] , constants . canFD_BITRATE_500K_80P , [number] , [number] , [number] , [number] , [number] ) [EOL] canlib . canSetBusParamsFd . assert_called_once_with ( [number] , data_bitrate , [number] , [number] , [number] ) [EOL] [EOL] def test_bus_get_stats ( self ) : [EOL] stats = self . bus . get_stats ( ) [EOL] self . assertTrue ( canlib . canRequestBusStatistics . called ) [EOL] self . assertTrue ( canlib . canGetBusStatistics . called ) [EOL] self . assertIsInstance ( stats , canlib . structures . BusStatistics ) [EOL] [EOL] @ staticmethod def canGetNumberOfChannels ( count ) : [EOL] count . _obj . value = [number] [EOL] [EOL] def canWrite ( self , handle , arb_id , buf , dlc , flags ) : [EOL] self . msg [ [string] ] = arb_id [EOL] self . msg [ [string] ] = dlc [EOL] self . msg [ [string] ] = flags [EOL] self . msg [ [string] ] = bytearray ( buf . _obj ) [EOL] [EOL] def canReadWait ( self , handle , arb_id , data , dlc , flags , timestamp , timeout ) : [EOL] if not self . msg_in_cue : [EOL] return constants . canERR_NOMSG [EOL] [EOL] arb_id . _obj . value = self . msg_in_cue . arbitration_id [EOL] dlc . _obj . value = self . msg_in_cue . dlc [EOL] data . _obj . raw = self . msg_in_cue . data [EOL] flags_temp = [number] [EOL] if self . msg_in_cue . is_extended_id : [EOL] flags_temp |= constants . canMSG_EXT [EOL] else : [EOL] flags_temp |= constants . canMSG_STD [EOL] if self . msg_in_cue . is_remote_frame : [EOL] flags_temp |= constants . canMSG_RTR [EOL] if self . msg_in_cue . is_error_frame : [EOL] flags_temp |= constants . canMSG_ERROR_FRAME [EOL] flags . _obj . value = flags_temp [EOL] timestamp . _obj . value = [number] [EOL] [EOL] return constants . canOK [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from copy import copy [EOL] [EOL] [EOL] class ComparingMessagesTestCase : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , allowed_timestamp_delta = [number] , preserves_channel = True ) : [EOL] [docstring] [EOL] self . allowed_timestamp_delta = allowed_timestamp_delta [EOL] self . preserves_channel = preserves_channel [EOL] [EOL] def assertMessageEqual ( self , message_1 , message_2 ) : [EOL] [docstring] [EOL] [EOL] if message_1 . equals ( message_2 , timestamp_delta = self . allowed_timestamp_delta ) : [EOL] return [EOL] elif self . preserves_channel : [EOL] print ( [string] . format ( message_1 ) ) [EOL] print ( [string] . format ( message_2 ) ) [EOL] self . fail ( [string] . format ( self . allowed_timestamp_delta ) ) [EOL] else : [EOL] message_2 = copy ( message_2 ) [comment] [EOL] message_2 . channel = message_1 . channel [EOL] if message_1 . equals ( message_2 , timestamp_delta = self . allowed_timestamp_delta ) : [EOL] return [EOL] else : [EOL] print ( [string] . format ( message_1 ) ) [EOL] print ( [string] . format ( message_2 ) ) [EOL] self . fail ( [string] . format ( self . allowed_timestamp_delta ) ) [EOL] [EOL] def assertMessagesEqual ( self , messages_1 , messages_2 ) : [EOL] [docstring] [EOL] self . assertEqual ( len ( messages_1 ) , len ( messages_2 ) , [string] ) [EOL] [EOL] for message_1 , message_2 in zip ( messages_1 , messages_2 ) : [EOL] self . assertMessageEqual ( message_1 , message_2 ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Dict , Any [EOL] import typing [EOL] import shutil [EOL] import tempfile [EOL] import unittest [EOL] from tempfile import NamedTemporaryFile [EOL] [EOL] import can [EOL] [EOL] [EOL] class LoadFileConfigTest ( unittest . TestCase ) : [EOL] configuration = { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } [EOL] [EOL] def setUp ( self ) : [EOL] [comment] [EOL] self . test_dir = tempfile . mkdtemp ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] [comment] [EOL] shutil . rmtree ( self . test_dir ) [EOL] [EOL] def _gen_configration_file ( self , sections ) : [EOL] with NamedTemporaryFile ( mode = [string] , dir = self . test_dir , delete = False ) as tmp_config_file : [EOL] content = [ ] [EOL] for section in sections : [EOL] content . append ( [string] . format ( section ) ) [EOL] for k , v in self . configuration [ section ] . items ( ) : [EOL] content . append ( [string] . format ( k , v ) ) [EOL] tmp_config_file . write ( [string] . join ( content ) ) [EOL] return tmp_config_file . name [EOL] [EOL] def test_config_file_with_default ( self ) : [EOL] tmp_config = self . _gen_configration_file ( [ [string] ] ) [EOL] config = can . util . load_file_config ( path = tmp_config ) [EOL] self . assertEqual ( config , self . configuration [ [string] ] ) [EOL] [EOL] def test_config_file_with_default_and_section ( self ) : [EOL] tmp_config = self . _gen_configration_file ( [ [string] , [string] ] ) [EOL] [EOL] config = can . util . load_file_config ( path = tmp_config ) [EOL] self . assertEqual ( config , self . configuration [ [string] ] ) [EOL] [EOL] config . update ( can . util . load_file_config ( path = tmp_config , section = [string] ) ) [EOL] self . assertEqual ( config , self . configuration [ [string] ] ) [EOL] [EOL] def test_config_file_with_section_only ( self ) : [EOL] tmp_config = self . _gen_configration_file ( [ [string] ] ) [EOL] config = can . util . load_file_config ( path = tmp_config ) [EOL] config . update ( can . util . load_file_config ( path = tmp_config , section = [string] ) ) [EOL] self . assertEqual ( config , self . configuration [ [string] ] ) [EOL] [EOL] def test_config_file_with_section_and_key_in_default ( self ) : [EOL] expected = self . configuration [ [string] ] . copy ( ) [EOL] expected . update ( self . configuration [ [string] ] ) [EOL] [EOL] tmp_config = self . _gen_configration_file ( [ [string] , [string] ] ) [EOL] config = can . util . load_file_config ( path = tmp_config ) [EOL] config . update ( can . util . load_file_config ( path = tmp_config , section = [string] ) ) [EOL] self . assertEqual ( config , expected ) [EOL] [EOL] def test_config_file_with_section_missing_interface ( self ) : [EOL] expected = self . configuration [ [string] ] . copy ( ) [EOL] tmp_config = self . _gen_configration_file ( [ [string] ] ) [EOL] config = can . util . load_file_config ( path = tmp_config ) [EOL] config . update ( can . util . load_file_config ( path = tmp_config , section = [string] ) ) [EOL] self . assertEqual ( config , expected ) [EOL] [EOL] def test_config_file_extra ( self ) : [EOL] expected = self . configuration [ [string] ] . copy ( ) [EOL] expected . update ( self . configuration [ [string] ] ) [EOL] [EOL] tmp_config = self . _gen_configration_file ( [ [string] , [string] ] ) [EOL] config = can . util . load_file_config ( path = tmp_config ) [EOL] config . update ( can . util . load_file_config ( path = tmp_config , section = [string] ) ) [EOL] self . assertEqual ( config , expected ) [EOL] [EOL] def test_config_file_with_non_existing_section ( self ) : [EOL] expected = self . configuration [ [string] ] . copy ( ) [EOL] [EOL] tmp_config = self . _gen_configration_file ( [ [string] , [string] , [string] , [string] ] ) [EOL] config = can . util . load_file_config ( path = tmp_config ) [EOL] config . update ( can . util . load_file_config ( path = tmp_config , section = [string] ) ) [EOL] self . assertEqual ( config , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import random [EOL] from operator import attrgetter [EOL] [EOL] from can import Message [EOL] [EOL] [comment] [EOL] random . seed ( [number] ) [EOL] [EOL] [EOL] def sort_messages ( messages ) : [EOL] [docstring] [EOL] return list ( sorted ( messages , key = attrgetter ( [string] ) ) ) [EOL] [EOL] [EOL] [comment] [EOL] TEST_TIME = [number] [EOL] [EOL] [EOL] [comment] [EOL] TEST_MESSAGES_BASE = sort_messages ( [ Message ( ) , Message ( data = [ [number] , [number] ] ) , Message ( arbitration_id = [number] , is_extended_id = False , ) , Message ( arbitration_id = [number] , is_extended_id = True , ) , Message ( arbitration_id = [number] ) , Message ( data = [ ] ) , Message ( data = [ [number] , [number] , [number] ] ) , Message ( channel = [number] ) , Message ( channel = [number] ) , Message ( channel = [string] ) , Message ( channel = [string] ) , Message ( arbitration_id = [number] , is_extended_id = True , timestamp = TEST_TIME , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ) , Message ( arbitration_id = [number] , is_extended_id = False , timestamp = TEST_TIME + [number] , data = [ [number] , [number] ] , ) , Message ( arbitration_id = [number] , is_extended_id = True , timestamp = TEST_TIME + [number] , data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ) , Message ( arbitration_id = [number] , is_extended_id = False , timestamp = TEST_TIME + [number] , data = [ [number] , [number] ] , ) , Message ( arbitration_id = [number] , is_extended_id = False , timestamp = TEST_TIME + [number] ) , ] ) [EOL] [EOL] [EOL] TEST_MESSAGES_CAN_FD = sort_messages ( [ Message ( is_fd = True , data = range ( [number] ) ) , Message ( is_fd = True , data = range ( [number] ) ) , Message ( is_fd = True , bitrate_switch = True , is_remote_frame = True ) , Message ( is_fd = True , error_state_indicator = True , is_remote_frame = True ) , Message ( is_fd = True , data = range ( [number] ) , bitrate_switch = True ) , Message ( is_fd = True , data = range ( [number] ) , error_state_indicator = True ) , ] ) [EOL] [EOL] [EOL] TEST_MESSAGES_REMOTE_FRAMES = sort_messages ( [ Message ( arbitration_id = [number] , is_extended_id = True , is_remote_frame = True , timestamp = TEST_TIME + [number] , ) , Message ( arbitration_id = [number] , is_extended_id = False , is_remote_frame = True , timestamp = TEST_TIME + [number] , ) , Message ( arbitration_id = [number] , is_extended_id = False , is_remote_frame = True , timestamp = TEST_TIME + [number] , ) , Message ( arbitration_id = [number] , is_extended_id = True , is_remote_frame = True , timestamp = TEST_TIME + [number] , ) , ] ) [EOL] [EOL] [EOL] TEST_MESSAGES_ERROR_FRAMES = sort_messages ( [ Message ( is_error_frame = True ) , Message ( is_error_frame = True , timestamp = TEST_TIME + [number] ) , Message ( is_error_frame = True , timestamp = TEST_TIME + [number] ) , ] ) [EOL] [EOL] [EOL] TEST_ALL_MESSAGES = sort_messages ( TEST_MESSAGES_BASE + TEST_MESSAGES_REMOTE_FRAMES + TEST_MESSAGES_ERROR_FRAMES ) [EOL] [EOL] [EOL] TEST_COMMENTS = [ [string] , [string] , [string] , ( [string] [string] [string] [string] ) , ] [EOL] [EOL] [EOL] def generate_message ( arbitration_id ) : [EOL] [docstring] [EOL] data = bytearray ( [ random . randrange ( [number] , [number] ** [number] - [number] ) for _ in range ( [number] ) ] ) [EOL] return Message ( arbitration_id = arbitration_id , data = data , is_extended_id = False , timestamp = TEST_TIME , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
from typing import List , Dict , Union , Any [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] import argparse [EOL] import socket [EOL] from datetime import datetime [EOL] [EOL] import can [EOL] from can import Bus , BusState , Logger [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( [string] , description = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , help = [string] , default = None , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , help = [string] , default = [number] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , help = [string] , choices = can . VALID_INTERFACES , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , nargs = argparse . REMAINDER , default = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = int , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = int , help = [string] , ) [EOL] [EOL] state_group = parser . add_mutually_exclusive_group ( required = False ) [EOL] state_group . add_argument ( [string] , help = [string] , action = [string] , ) [EOL] state_group . add_argument ( [string] , help = [string] , action = [string] ) [EOL] [EOL] [comment] [EOL] if len ( sys . argv ) < [number] : [EOL] parser . print_help ( sys . stderr ) [EOL] import errno [EOL] [EOL] raise SystemExit ( errno . EINVAL ) [EOL] [EOL] results = parser . parse_args ( ) [EOL] [EOL] verbosity = results . verbosity [EOL] [EOL] logging_level_name = [ [string] , [string] , [string] , [string] , [string] , [string] ] [ min ( [number] , verbosity ) ] [EOL] can . set_logging_level ( logging_level_name ) [EOL] [EOL] can_filters = [ ] [EOL] if results . filter : [EOL] print ( f" [string] { results . filter }" ) [EOL] for filt in results . filter : [EOL] if [string] in filt : [EOL] _ = filt . split ( [string] ) [EOL] can_id , can_mask = int ( _ [ [number] ] , base = [number] ) , int ( _ [ [number] ] , base = [number] ) [EOL] elif [string] in filt : [EOL] can_id , can_mask = filt . split ( [string] ) [EOL] can_id = int ( can_id , base = [number] ) | [number] [comment] [EOL] can_mask = int ( can_mask , base = [number] ) & socket . CAN_ERR_FLAG [EOL] can_filters . append ( { [string] : can_id , [string] : can_mask } ) [EOL] [EOL] config = { [string] : can_filters , [string] : True } [EOL] if results . interface : [EOL] config [ [string] ] = results . interface [EOL] if results . bitrate : [EOL] config [ [string] ] = results . bitrate [EOL] if results . fd : [EOL] config [ [string] ] = True [EOL] if results . data_bitrate : [EOL] config [ [string] ] = results . data_bitrate [EOL] bus = Bus ( results . channel , ** config ) [EOL] [EOL] if results . active : [EOL] bus . state = BusState . ACTIVE [EOL] elif results . passive : [EOL] bus . state = BusState . PASSIVE [EOL] [EOL] print ( f" [string] { bus . __class__ . __name__ } [string] { bus . channel_info }" ) [EOL] print ( f" [string] { datetime . now ( ) } [string] " ) [EOL] logger = Logger ( results . log_file ) [EOL] [EOL] try : [EOL] while True : [EOL] msg = bus . recv ( [number] ) [EOL] if msg is not None : [EOL] logger ( msg ) [EOL] except KeyboardInterrupt : [EOL] pass [EOL] finally : [EOL] bus . shutdown ( ) [EOL] logger . stop ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence , Any , Type , Union , IO [EOL] import can [EOL] import typing [EOL] [docstring] [EOL] [EOL] import typing [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] import os [EOL] [EOL] import mypy_extensions [EOL] [EOL] CanFilter = mypy_extensions . TypedDict ( [string] , { [string] : int , [string] : int } ) [EOL] CanFilterExtended = mypy_extensions . TypedDict ( [string] , { [string] : int , [string] : int , [string] : bool } ) [EOL] CanFilters = typing . Sequence [ typing . Union [ CanFilter , CanFilterExtended ] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] CanData = typing . Union [ bytes , bytearray , int , typing . Iterable [ int ] ] [EOL] [EOL] [comment] [EOL] ChannelStr = str [EOL] ChannelInt = int [EOL] Channel = typing . Union [ ChannelInt , ChannelStr ] [EOL] [EOL] [comment] [EOL] FileLike = typing . IO [ typing . Any ] [EOL] StringPathLike = typing . Union [ str , [string] ] [EOL] AcceptedIOType = typing . Optional [ typing . Union [ FileLike , StringPathLike ] ] [EOL] [EOL] BusConfig = typing . NewType ( [string] , dict ) [EOL] [EOL] AutoDetectedConfig = mypy_extensions . TypedDict ( [string] , { [string] : str , [string] : Channel } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Tuple [EOL] import _importlib_modulespec [EOL] import can [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import importlib [EOL] import logging [EOL] [EOL] from . bus import BusABC [EOL] from . util import load_config [EOL] from . interfaces import BACKENDS [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] log_autodetect = log . getChild ( [string] ) [EOL] [EOL] [EOL] def _get_class_for_interface ( interface ) : [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] module_name , class_name = BACKENDS [ interface ] [EOL] except KeyError : [EOL] raise NotImplementedError ( [string] . format ( interface ) ) [EOL] [EOL] [comment] [EOL] try : [EOL] module = importlib . import_module ( module_name ) [EOL] except Exception as e : [EOL] raise ImportError ( [string] . format ( module_name , interface , e ) ) [EOL] [EOL] [comment] [EOL] try : [EOL] bus_class = getattr ( module , class_name ) [EOL] except Exception as e : [EOL] raise ImportError ( [string] . format ( class_name , module_name , interface , e ) ) [EOL] [EOL] return bus_class [EOL] [EOL] [EOL] class Bus ( BusABC ) : [comment] [EOL] [docstring] [EOL] [EOL] @ staticmethod def __new__ ( cls , channel = None , * args , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if channel is not None : [EOL] kwargs [ [string] ] = channel [EOL] if [string] in kwargs : [EOL] context = kwargs [ [string] ] [EOL] del kwargs [ [string] ] [EOL] else : [EOL] context = None [EOL] kwargs = load_config ( config = kwargs , context = context ) [EOL] [EOL] [comment] [EOL] cls = _get_class_for_interface ( kwargs [ [string] ] ) [EOL] [EOL] [comment] [EOL] del kwargs [ [string] ] [EOL] [EOL] [comment] [EOL] if [string] not in kwargs : [EOL] raise ValueError ( [string] ) [EOL] else : [EOL] channel = kwargs [ [string] ] [EOL] del kwargs [ [string] ] [EOL] [EOL] if channel is None : [EOL] [comment] [EOL] return cls ( * args , ** kwargs ) [EOL] else : [EOL] return cls ( channel , * args , ** kwargs ) [EOL] [EOL] [EOL] def detect_available_configs ( interfaces = None ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if interfaces is None : [EOL] interfaces = BACKENDS [EOL] elif isinstance ( interfaces , str ) : [EOL] interfaces = ( interfaces , ) [EOL] [comment] [EOL] [EOL] result = [ ] [EOL] for interface in interfaces : [EOL] [EOL] try : [EOL] bus_class = _get_class_for_interface ( interface ) [EOL] except ImportError : [EOL] log_autodetect . debug ( [string] , interface , ) [EOL] continue [EOL] [EOL] [comment] [EOL] try : [EOL] available = list ( bus_class . _detect_available_configs ( ) ) [comment] [EOL] except NotImplementedError : [EOL] log_autodetect . debug ( [string] , interface , ) [EOL] else : [EOL] log_autodetect . debug ( [string] , interface , len ( available ) , ) [EOL] [EOL] [comment] [EOL] for config in available : [EOL] if [string] not in config : [EOL] config [ [string] ] = interface [EOL] [EOL] [comment] [EOL] result += available [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 $typing.Any$ 0 0 0 0 $can.typechecking.BusConfig$ 0 0 $None$ 0 $can.typechecking.BusConfig$ 0 0 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 0 0 0 $None$ 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 0 $can.typechecking.BusConfig$ 0 $None$ 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 0 0 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 0 0 0 0 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $can.typechecking.BusConfig$ 0 0 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] import argparse [EOL] from datetime import datetime [EOL] [EOL] import can [EOL] from can import Bus , LogReader , MessageSync [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( [string] , description = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , help = [string] , default = None , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , help = [string] , default = [number] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , help = [string] , choices = can . VALID_INTERFACES , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = int , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = int , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , help = [string] , action = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , action = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = float , help = [string] , default = [number] , ) [EOL] parser . add_argument ( [string] , [string] , type = float , default = [number] * [number] * [number] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] , ) [EOL] [EOL] [comment] [EOL] if len ( sys . argv ) < [number] : [EOL] parser . print_help ( sys . stderr ) [EOL] import errno [EOL] [EOL] raise SystemExit ( errno . EINVAL ) [EOL] [EOL] results = parser . parse_args ( ) [EOL] [EOL] verbosity = results . verbosity [EOL] [EOL] logging_level_name = [ [string] , [string] , [string] , [string] , [string] , [string] ] [ min ( [number] , verbosity ) ] [EOL] can . set_logging_level ( logging_level_name ) [EOL] [EOL] error_frames = results . error_frames [EOL] [EOL] config = { [string] : True } [EOL] if results . interface : [EOL] config [ [string] ] = results . interface [EOL] if results . bitrate : [EOL] config [ [string] ] = results . bitrate [EOL] if results . fd : [EOL] config [ [string] ] = True [EOL] if results . data_bitrate : [EOL] config [ [string] ] = results . data_bitrate [EOL] bus = Bus ( results . channel , ** config ) [EOL] [EOL] reader = LogReader ( results . infile ) [EOL] [EOL] in_sync = MessageSync ( reader , timestamps = results . timestamps , gap = results . gap , skip = results . skip ) [EOL] [EOL] print ( f" [string] { datetime . now ( ) } [string] " ) [EOL] [EOL] try : [EOL] for m in in_sync : [EOL] if m . is_error_frame and not error_frames : [EOL] continue [EOL] if verbosity >= [number] : [EOL] print ( m ) [EOL] bus . send ( m ) [EOL] except KeyboardInterrupt : [EOL] pass [EOL] finally : [EOL] bus . shutdown ( ) [EOL] reader . stop ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Awaitable , AsyncIterator , Optional [EOL] import asyncio [EOL] import builtins [EOL] import can [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import AsyncIterator , Awaitable , Optional [EOL] [EOL] from can . message import Message [EOL] from can . bus import BusABC [EOL] [EOL] from abc import ABCMeta , abstractmethod [EOL] [EOL] try : [EOL] [comment] [EOL] from queue import SimpleQueue , Empty [EOL] except ImportError : [EOL] [comment] [EOL] from queue import Queue as SimpleQueue , Empty [comment] [EOL] [EOL] import asyncio [EOL] [EOL] [EOL] class Listener ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def on_message_received ( self , msg ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , msg ) : [EOL] self . on_message_received ( msg ) [EOL] [EOL] def on_error ( self , exc ) : [EOL] [docstring] [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] [EOL] [EOL] class RedirectReader ( Listener ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , bus ) : [EOL] self . bus = bus [EOL] [EOL] def on_message_received ( self , msg ) : [EOL] self . bus . send ( msg ) [EOL] [EOL] [EOL] class BufferedReader ( Listener ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . buffer = SimpleQueue ( ) [EOL] self . is_stopped = False [EOL] [EOL] def on_message_received ( self , msg ) : [EOL] [docstring] [EOL] if self . is_stopped : [EOL] raise RuntimeError ( [string] ) [EOL] else : [EOL] self . buffer . put ( msg ) [EOL] [EOL] def get_message ( self , timeout = [number] ) : [EOL] [docstring] [EOL] try : [EOL] return self . buffer . get ( block = not self . is_stopped , timeout = timeout ) [EOL] except Empty : [EOL] return None [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] self . is_stopped = True [EOL] [EOL] [EOL] class AsyncBufferedReader ( Listener ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , loop = None ) : [EOL] [comment] [EOL] self . buffer = asyncio . Queue ( loop = loop ) [EOL] [EOL] def on_message_received ( self , msg ) : [EOL] [docstring] [EOL] self . buffer . put_nowait ( msg ) [EOL] [EOL] async def get_message ( self ) : [EOL] [docstring] [EOL] return await self . buffer . get ( ) [EOL] [EOL] def __aiter__ ( self ) : [EOL] return self [EOL] [EOL] def __anext__ ( self ) : [EOL] return self . buffer . get ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $can.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 $can.message.Message$ 0 0 0 0 0 0 0 $can.message.Message$ 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $can.message.Message$ 0 0 0 0 0 0 0 0 0 $can.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $can.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $can.message.Message$ 0 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[asyncio.events.AbstractEventLoop]$ 0 0 0 0 0 0 0 0 0 $"asyncio.Queue[Message]"$ 0 0 0 0 0 $typing.Optional[asyncio.events.AbstractEventLoop]$ 0 $typing.Optional[asyncio.events.AbstractEventLoop]$ 0 0 0 0 0 0 0 0 $can.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 $can.message.Message$ 0 0 0 0 0 $can.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterator[can.message.Message]$ 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[can.message.Message]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Match , Union , Optional , Dict [EOL] import builtins [EOL] import can [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import functools [EOL] import warnings [EOL] from typing import Dict , Optional , Union [EOL] [EOL] from can import typechecking [EOL] [EOL] import json [EOL] import os [EOL] import os . path [EOL] import platform [EOL] import re [EOL] import logging [EOL] from configparser import ConfigParser [EOL] [EOL] import can [EOL] from can . interfaces import VALID_INTERFACES [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [comment] [EOL] CAN_FD_DLC = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] REQUIRED_KEYS = [ [string] , [string] ] [EOL] [EOL] [EOL] CONFIG_FILES = [ [string] ] [EOL] [EOL] if platform . system ( ) == [string] : [EOL] CONFIG_FILES . extend ( [ [string] , [string] , [string] ] ) [EOL] elif platform . system ( ) == [string] or platform . python_implementation ( ) == [string] : [EOL] CONFIG_FILES . extend ( [ [string] , os . path . join ( os . getenv ( [string] , [string] ) , [string] ) ] ) [EOL] [EOL] [EOL] def load_file_config ( path = None , section = [string] ) : [EOL] [docstring] [EOL] config = ConfigParser ( ) [EOL] if path is None : [EOL] config . read ( [ os . path . expanduser ( path ) for path in CONFIG_FILES ] ) [EOL] else : [EOL] config . read ( path ) [EOL] [EOL] _config = { } [EOL] [EOL] if config . has_section ( section ) : [EOL] _config . update ( dict ( ( key , val ) for key , val in config . items ( section ) ) ) [EOL] [EOL] return _config [EOL] [EOL] [EOL] def load_environment_config ( context = None ) : [EOL] [docstring] [EOL] mapper = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] context_suffix = [string] . format ( context ) if context else [string] [EOL] [EOL] can_config_key = [string] + context_suffix [EOL] config = json . loads ( os . environ . get ( can_config_key , [string] ) ) [EOL] [EOL] for key , val in mapper . items ( ) : [EOL] config_option = os . environ . get ( val + context_suffix , None ) [EOL] if config_option : [EOL] config [ key ] = config_option [EOL] [EOL] return config [EOL] [EOL] [EOL] def load_config ( path = None , config = None , context = None , ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] given_config = config or { } [EOL] config = { } [EOL] [EOL] [comment] [EOL] config_sources = [ given_config , can . rc , lambda _context : load_environment_config ( _context ) , lambda _context : load_environment_config ( ) , lambda _context : load_file_config ( path , _context ) , lambda _context : load_file_config ( path ) , ] [EOL] [EOL] [comment] [EOL] for cfg in config_sources : [EOL] if callable ( cfg ) : [EOL] cfg = cfg ( context ) [EOL] [comment] [EOL] if [string] in cfg : [EOL] if [string] not in cfg or not cfg [ [string] ] : [EOL] cfg [ [string] ] = cfg [ [string] ] [EOL] del cfg [ [string] ] [EOL] [comment] [EOL] for key in cfg : [EOL] if key not in config : [EOL] config [ key ] = cfg [ key ] [EOL] [EOL] [comment] [EOL] for key in REQUIRED_KEYS : [EOL] if key not in config : [EOL] config [ key ] = None [EOL] [EOL] if config [ [string] ] not in VALID_INTERFACES : [EOL] raise NotImplementedError ( [string] . format ( config [ [string] ] ) ) [EOL] [EOL] if [string] in config : [EOL] config [ [string] ] = int ( config [ [string] ] ) [EOL] if [string] in config : [EOL] config [ [string] ] = config [ [string] ] not in ( [string] , [string] , [string] ) [EOL] if [string] in config : [EOL] config [ [string] ] = int ( config [ [string] ] ) [EOL] [EOL] [comment] [EOL] timing_conf = { } [EOL] for key in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) : [EOL] if key in config : [EOL] timing_conf [ key ] = int ( config [ key ] , base = [number] ) [EOL] del config [ key ] [EOL] if timing_conf : [EOL] timing_conf [ [string] ] = config . get ( [string] ) [EOL] config [ [string] ] = can . BitTiming ( ** timing_conf ) [EOL] [EOL] can . log . debug ( [string] . format ( config ) ) [EOL] return config [EOL] [EOL] [EOL] def set_logging_level ( level_name = None ) : [EOL] [docstring] [EOL] can_logger = logging . getLogger ( [string] ) [EOL] [EOL] try : [EOL] can_logger . setLevel ( getattr ( logging , level_name . upper ( ) ) ) [comment] [EOL] except AttributeError : [EOL] can_logger . setLevel ( logging . DEBUG ) [EOL] log . debug ( [string] . format ( level_name ) ) [EOL] [EOL] [EOL] def len2dlc ( length ) : [EOL] [docstring] [EOL] if length <= [number] : [EOL] return length [EOL] for dlc , nof_bytes in enumerate ( CAN_FD_DLC ) : [EOL] if nof_bytes >= length : [EOL] return dlc [EOL] return [number] [EOL] [EOL] [EOL] def dlc2len ( dlc ) : [EOL] [docstring] [EOL] return CAN_FD_DLC [ dlc ] if dlc <= [number] else [number] [EOL] [EOL] [EOL] def channel2int ( channel ) : [EOL] [docstring] [EOL] if channel is None : [EOL] return None [EOL] if isinstance ( channel , int ) : [EOL] return channel [EOL] [comment] [EOL] if hasattr ( channel , [string] ) : [EOL] match = re . match ( [string] , channel ) [EOL] if match : [EOL] return int ( match . group ( [number] ) ) [EOL] return None [EOL] [EOL] [EOL] def deprecated_args_alias ( ** aliases ) : [EOL] [docstring] [EOL] [EOL] def deco ( f ) : [EOL] @ functools . wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] rename_kwargs ( f . __name__ , kwargs , aliases ) [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] return deco [EOL] [EOL] [EOL] def rename_kwargs ( func_name , kwargs , aliases ) : [EOL] [docstring] [EOL] for alias , new in aliases . items ( ) : [EOL] if alias in kwargs : [EOL] value = kwargs . pop ( alias ) [EOL] if new is not None : [EOL] warnings . warn ( [string] . format ( alias , new ) , DeprecationWarning ) [EOL] if new in kwargs : [EOL] raise TypeError ( [string] . format ( func_name , alias , new ) ) [EOL] kwargs [ new ] = value [EOL] else : [EOL] warnings . warn ( [string] . format ( alias ) , DeprecationWarning ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] print ( [string] . join ( CONFIG_FILES ) ) [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( load_config ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $can.typechecking.BusConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import unittest [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import time [EOL] import logging [EOL] from unittest . mock import Mock [EOL] [EOL] from can import BusABC , Message [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] try : [EOL] import cantact [EOL] except ImportError : [EOL] logger . warning ( [string] ) [EOL] [EOL] [EOL] class CantactBus ( BusABC ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def _detect_available_configs ( ) : [EOL] try : [EOL] interface = cantact . Interface ( ) [EOL] except NameError : [EOL] [comment] [EOL] return [ ] [EOL] [EOL] channels = [ ] [EOL] for i in range ( [number] , interface . channel_count ( ) ) : [EOL] channels . append ( { [string] : [string] , [string] : [string] % i } ) [EOL] return channels [EOL] [EOL] def __init__ ( self , channel , bitrate = [number] , poll_interval = [number] , monitor = False , bit_timing = None , _testing = False , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] if _testing : [EOL] self . interface = MockInterface ( ) [EOL] else : [EOL] self . interface = cantact . Interface ( ) [EOL] [EOL] self . channel = int ( channel ) [EOL] self . channel_info = [string] % channel [EOL] [EOL] [comment] [EOL] if bit_timing is None : [EOL] [comment] [EOL] self . interface . set_bitrate ( int ( channel ) , int ( bitrate ) ) [EOL] else : [EOL] [comment] [EOL] self . interface . set_bit_timing ( int ( channel ) , int ( bit_timing . brp ) , int ( bit_timing . tseg1 ) , int ( bit_timing . tseg2 ) , int ( bit_timing . sjw ) , ) [EOL] self . interface . set_enabled ( int ( channel ) , True ) [EOL] self . interface . set_monitor ( int ( channel ) , monitor ) [EOL] self . interface . start ( ) [EOL] [EOL] super ( ) . __init__ ( channel = channel , bitrate = bitrate , poll_interval = poll_interval , ** kwargs ) [EOL] [EOL] def _recv_internal ( self , timeout ) : [EOL] frame = self . interface . recv ( int ( timeout * [number] ) ) [EOL] if frame is None : [EOL] [comment] [EOL] return None , False [EOL] [EOL] msg = Message ( arbitration_id = frame [ [string] ] , is_extended_id = frame [ [string] ] , timestamp = frame [ [string] ] , is_remote_frame = frame [ [string] ] , dlc = frame [ [string] ] , data = frame [ [string] ] [ : frame [ [string] ] ] , channel = frame [ [string] ] , is_rx = ( not frame [ [string] ] ) , ) [EOL] return msg , False [EOL] [EOL] def send ( self , msg , timeout = None ) : [EOL] self . interface . send ( self . channel , msg . arbitration_id , bool ( msg . is_extended_id ) , bool ( msg . is_remote_frame ) , msg . dlc , msg . data , ) [EOL] [EOL] def shutdown ( self ) : [EOL] self . interface . stop ( ) [EOL] [EOL] [EOL] def mock_recv ( timeout ) : [EOL] if timeout > [number] : [EOL] frame = { } [EOL] frame [ [string] ] = [number] [EOL] frame [ [string] ] = False [EOL] frame [ [string] ] = time . time ( ) [EOL] frame [ [string] ] = False [EOL] frame [ [string] ] = False [EOL] frame [ [string] ] = [number] [EOL] frame [ [string] ] = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] frame [ [string] ] = [number] [EOL] return frame [EOL] else : [EOL] [comment] [EOL] return None [EOL] [EOL] [EOL] class MockInterface : [EOL] [docstring] [EOL] [EOL] start = Mock ( ) [EOL] set_bitrate = Mock ( ) [EOL] set_bit_timing = Mock ( ) [EOL] set_enabled = Mock ( ) [EOL] set_monitor = Mock ( ) [EOL] start = Mock ( ) [EOL] stop = Mock ( ) [EOL] send = Mock ( ) [EOL] channel_count = Mock ( return_value = [number] ) [EOL] [EOL] recv = Mock ( side_effect = mock_recv ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0
from typing import Dict , Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] import warnings [EOL] from pkg_resources import iter_entry_points [EOL] [EOL] [EOL] [comment] [EOL] BACKENDS = { [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , } [EOL] [EOL] BACKENDS . update ( { interface . name : ( interface . module_name , interface . attrs [ [number] ] ) for interface in iter_entry_points ( [string] ) } ) [EOL] [EOL] VALID_INTERFACES = frozenset ( list ( BACKENDS . keys ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from can . interfaces . seeedstudio . seeedstudio import SeeedBus [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import struct [EOL] from time import time [EOL] from can import BusABC , Message [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] try : [EOL] import serial [EOL] except ImportError : [EOL] logger . warning ( [string] [string] ) [EOL] serial = None [EOL] [EOL] [EOL] class SeeedBus ( BusABC ) : [EOL] [docstring] [EOL] [EOL] BITRATE = { [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , } [EOL] [EOL] FRAMETYPE = { [string] : [number] , [string] : [number] } [EOL] [EOL] OPERATIONMODE = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] def __init__ ( self , channel , baudrate = [number] , timeout = [number] , frame_type = [string] , operation_mode = [string] , bitrate = [number] , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . bit_rate = bitrate [EOL] self . frame_type = frame_type [EOL] self . op_mode = operation_mode [EOL] self . filter_id = bytearray ( [ [number] , [number] , [number] , [number] ] ) [EOL] self . mask_id = bytearray ( [ [number] , [number] , [number] , [number] ] ) [EOL] if not channel : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . channel_info = [string] + channel [EOL] self . ser = serial . Serial ( channel , baudrate = baudrate , timeout = timeout , rtscts = False ) [EOL] [EOL] super ( SeeedBus , self ) . __init__ ( channel = channel , * args , ** kwargs ) [EOL] self . init_frame ( ) [EOL] [EOL] def shutdown ( self ) : [EOL] [docstring] [EOL] self . ser . close ( ) [EOL] [EOL] def init_frame ( self , timeout = None ) : [EOL] [docstring] [EOL] byte_msg = bytearray ( ) [EOL] byte_msg . append ( [number] ) [comment] [EOL] byte_msg . append ( [number] ) [comment] [EOL] byte_msg . append ( [number] ) [comment] [EOL] byte_msg . append ( SeeedBus . BITRATE [ self . bit_rate ] ) [comment] [EOL] byte_msg . append ( SeeedBus . FRAMETYPE [ self . frame_type ] ) [EOL] byte_msg . extend ( self . filter_id ) [EOL] byte_msg . extend ( self . mask_id ) [EOL] byte_msg . append ( SeeedBus . OPERATIONMODE [ self . op_mode ] ) [EOL] byte_msg . append ( [number] ) [comment] [EOL] [EOL] byte_msg . extend ( [ [number] ] * [number] ) [comment] [EOL] [EOL] crc = sum ( byte_msg [ [number] : ] ) & [number] [EOL] byte_msg . append ( crc ) [EOL] [EOL] logger . debug ( [string] , byte_msg . hex ( ) ) [EOL] self . ser . write ( byte_msg ) [EOL] [EOL] def flush_buffer ( self ) : [EOL] self . ser . flushInput ( ) [EOL] [EOL] def status_frame ( self , timeout = None ) : [EOL] [docstring] [EOL] byte_msg = bytearray ( ) [EOL] byte_msg . append ( [number] ) [comment] [EOL] byte_msg . append ( [number] ) [comment] [EOL] byte_msg . append ( [number] ) [comment] [EOL] byte_msg . append ( [number] ) [comment] [EOL] byte_msg . append ( [number] ) [comment] [EOL] [EOL] byte_msg . extend ( [ [number] ] * [number] ) [EOL] [EOL] crc = sum ( byte_msg [ [number] : ] ) & [number] [EOL] byte_msg . append ( crc ) [EOL] [EOL] logger . debug ( [string] , byte_msg . hex ( ) ) [EOL] self . ser . write ( byte_msg ) [EOL] [EOL] def send ( self , msg , timeout = None ) : [EOL] [docstring] [EOL] [EOL] byte_msg = bytearray ( ) [EOL] byte_msg . append ( [number] ) [EOL] [EOL] m_type = [number] [EOL] if msg . is_extended_id : [EOL] m_type += [number] << [number] [EOL] [EOL] if msg . is_remote_frame : [EOL] m_type += [number] << [number] [EOL] [EOL] m_type += msg . dlc [EOL] byte_msg . append ( m_type ) [EOL] [EOL] if msg . is_extended_id : [EOL] a_id = struct . pack ( [string] , msg . arbitration_id ) [EOL] else : [EOL] a_id = struct . pack ( [string] , msg . arbitration_id ) [EOL] [EOL] byte_msg . extend ( a_id ) [EOL] byte_msg . extend ( msg . data ) [EOL] byte_msg . append ( [number] ) [EOL] [EOL] logger . debug ( [string] , byte_msg . hex ( ) ) [EOL] self . ser . write ( byte_msg ) [EOL] [EOL] def _recv_internal ( self , timeout ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] rx_byte_1 = self . ser . read ( ) [EOL] [EOL] except serial . SerialException : [EOL] return None , False [EOL] [EOL] if rx_byte_1 and ord ( rx_byte_1 ) == [number] : [EOL] rx_byte_2 = ord ( self . ser . read ( ) ) [EOL] time_stamp = time ( ) [EOL] if rx_byte_2 == [number] : [EOL] status = bytearray ( [ [number] , [number] ] ) [EOL] status += bytearray ( self . ser . read ( [number] ) ) [EOL] logger . debug ( [string] , status . hex ( ) ) [EOL] [EOL] else : [EOL] length = int ( rx_byte_2 & [number] ) [EOL] is_extended = bool ( rx_byte_2 & [number] ) [EOL] is_remote = bool ( rx_byte_2 & [number] ) [EOL] if is_extended : [EOL] s_3_4_5_6 = bytearray ( self . ser . read ( [number] ) ) [EOL] arb_id = ( struct . unpack ( [string] , s_3_4_5_6 ) ) [ [number] ] [EOL] [EOL] else : [EOL] s_3_4 = bytearray ( self . ser . read ( [number] ) ) [EOL] arb_id = ( struct . unpack ( [string] , s_3_4 ) ) [ [number] ] [EOL] [EOL] data = bytearray ( self . ser . read ( length ) ) [EOL] end_packet = ord ( self . ser . read ( ) ) [EOL] if end_packet == [number] : [EOL] msg = Message ( timestamp = time_stamp , arbitration_id = arb_id , is_extended_id = is_extended , is_remote_frame = is_remote , dlc = length , data = data , ) [EOL] logger . debug ( [string] , str ( msg ) ) [EOL] return msg , False [EOL] [EOL] else : [EOL] return None , False [EOL] [EOL] return None , None [EOL] [EOL] def fileno ( self ) : [EOL] if hasattr ( self . ser , [string] ) : [EOL] return self . ser . fileno ( ) [EOL] [comment] [EOL] return - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.bytes$ 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 $builtins.bytearray$ 0 $builtins.bytearray$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] try : [EOL] import win32com . client [EOL] except ImportError : [EOL] logging . warning ( [string] ) [EOL] raise [EOL] [EOL] [EOL] def WMIDateStringToDate ( dtmDate ) : [EOL] if dtmDate [ [number] ] == [number] : [EOL] strDateTime = dtmDate [ [number] ] + [string] [EOL] else : [EOL] strDateTime = dtmDate [ [number] ] + dtmDate [ [number] ] + [string] [EOL] [EOL] if dtmDate [ [number] ] == [number] : [EOL] strDateTime = strDateTime + dtmDate [ [number] ] + [string] [EOL] else : [EOL] strDateTime = strDateTime + dtmDate [ [number] ] + dtmDate [ [number] ] + [string] [EOL] strDateTime = ( strDateTime + dtmDate [ [number] ] + dtmDate [ [number] ] + dtmDate [ [number] ] + dtmDate [ [number] ] + [string] + dtmDate [ [number] ] + dtmDate [ [number] ] + [string] + dtmDate [ [number] ] + dtmDate [ [number] ] + [string] + dtmDate [ [number] ] + dtmDate [ [number] ] ) [EOL] return strDateTime [EOL] [EOL] [EOL] def find_serial_devices ( serial_matcher = [string] ) : [EOL] [docstring] [EOL] objWMIService = win32com . client . Dispatch ( [string] ) [EOL] objSWbemServices = objWMIService . ConnectServer ( [string] , [string] ) [EOL] items = objSWbemServices . ExecQuery ( [string] ) [EOL] ids = ( item . Dependent . strip ( [string] ) [ - [number] : ] for item in items ) [EOL] return [ e for e in ids if e . startswith ( serial_matcher ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from . usb2canInterface import Usb2canBus [EOL] from . usb2canabstractionlayer import Usb2CanAbstractionLayer [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import can [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] from ctypes import byref [EOL] [EOL] from can import BusABC , Message , CanError [EOL] from . usb2canabstractionlayer import * [EOL] from . serial_selector import find_serial_devices [EOL] [EOL] [comment] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] def message_convert_tx ( msg ) : [EOL] message_tx = CanalMsg ( ) [EOL] [EOL] length = msg . dlc [EOL] message_tx . sizeData = length [EOL] [EOL] message_tx . id = msg . arbitration_id [EOL] [EOL] for i in range ( length ) : [EOL] message_tx . data [ i ] = msg . data [ i ] [EOL] [EOL] message_tx . flags = [number] [EOL] [EOL] if msg . is_error_frame : [EOL] message_tx . flags |= IS_ERROR_FRAME [EOL] [EOL] if msg . is_remote_frame : [EOL] message_tx . flags |= IS_REMOTE_FRAME [EOL] [EOL] if msg . is_extended_id : [EOL] message_tx . flags |= IS_ID_TYPE [EOL] [EOL] return message_tx [EOL] [EOL] [EOL] def message_convert_rx ( message_rx ) : [EOL] [docstring] [EOL] is_extended_id = bool ( message_rx . flags & IS_ID_TYPE ) [EOL] is_remote_frame = bool ( message_rx . flags & IS_REMOTE_FRAME ) [EOL] is_error_frame = bool ( message_rx . flags & IS_ERROR_FRAME ) [EOL] [EOL] return Message ( timestamp = message_rx . timestamp , is_remote_frame = is_remote_frame , is_extended_id = is_extended_id , is_error_frame = is_error_frame , arbitration_id = message_rx . id , dlc = message_rx . sizeData , data = message_rx . data [ : message_rx . sizeData ] , ) [EOL] [EOL] [EOL] class Usb2canBus ( BusABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , channel = None , dll = [string] , flags = [number] , * args , bitrate = [number] , ** kwargs ) : [EOL] [EOL] self . can = Usb2CanAbstractionLayer ( dll ) [EOL] [EOL] [comment] [EOL] device_id = kwargs . get ( [string] , d = channel ) [EOL] [EOL] [comment] [EOL] if not device_id : [EOL] devices = find_serial_devices ( ) [EOL] if not devices : [EOL] raise CanError ( [string] ) [EOL] device_id = devices [ [number] ] [EOL] [EOL] [comment] [EOL] baudrate = min ( int ( bitrate // [number] ) , [number] ) [EOL] [EOL] self . channel_info = [string] . format ( device_id ) [EOL] [EOL] connector = [string] . format ( device_id , baudrate ) [EOL] self . handle = self . can . open ( connector , flags_t ) [EOL] [EOL] super ( ) . __init__ ( channel = channel , dll = dll , flags_t = flags_t , bitrate = bitrate , * args , ** kwargs ) [EOL] [EOL] def send ( self , msg , timeout = None ) : [EOL] tx = message_convert_tx ( msg ) [EOL] [EOL] if timeout : [EOL] status = self . can . blocking_send ( self . handle , byref ( tx ) , int ( timeout * [number] ) ) [EOL] else : [EOL] status = self . can . send ( self . handle , byref ( tx ) ) [EOL] [EOL] if status != CANAL_ERROR_SUCCESS : [EOL] raise CanError ( [string] . format ( status ) ) [EOL] [EOL] def _recv_internal ( self , timeout ) : [EOL] [EOL] messagerx = CanalMsg ( ) [EOL] [EOL] if timeout == [number] : [EOL] status = self . can . receive ( self . handle , byref ( messagerx ) ) [EOL] [EOL] else : [EOL] time = [number] if timeout is None else int ( timeout * [number] ) [EOL] status = self . can . blocking_receive ( self . handle , byref ( messagerx ) , time ) [EOL] [EOL] if status == CANAL_ERROR_SUCCESS : [EOL] rx = message_convert_rx ( messagerx ) [EOL] elif status in ( CANAL_ERROR_RCV_EMPTY , CANAL_ERROR_TIMEOUT ) : [EOL] rx = None [EOL] else : [EOL] log . error ( [string] , status ) [EOL] rx = None [EOL] [EOL] return rx , False [EOL] [EOL] def shutdown ( self ) : [EOL] [docstring] [EOL] status = self . can . close ( self . handle ) [EOL] [EOL] if status != CANAL_ERROR_SUCCESS : [EOL] raise CanError ( [string] . format ( status ) ) [EOL] [EOL] @ staticmethod def _detect_available_configs ( ) : [EOL] return Usb2canBus . detect_available_configs ( ) [EOL] [EOL] @ staticmethod def detect_available_configs ( serial_matcher = None ) : [EOL] [docstring] [EOL] if serial_matcher : [EOL] channels = find_serial_devices ( serial_matcher ) [EOL] else : [EOL] channels = find_serial_devices ( ) [EOL] [EOL] return [ { [string] : [string] , [string] : c } for c in channels ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $can.interfaces.usb2can.usb2canabstractionlayer.Usb2CanAbstractionLayer$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $can.interfaces.usb2can.usb2canabstractionlayer.Usb2CanAbstractionLayer$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $can.interfaces.usb2can.usb2canabstractionlayer.CanalMsg$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $can.interfaces.usb2can.usb2canabstractionlayer.CanalMsg$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $can.interfaces.usb2can.usb2canabstractionlayer.CanalMsg$ 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $can.interfaces.usb2can.usb2canabstractionlayer.CanalMsg$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[docstring] [EOL] [EOL] from can . interfaces . pcan . pcan import PcanBus [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from can . interfaces . serial . serial_can import SerialBus as Bus [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import struct [EOL] [EOL] from can import BusABC , Message [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] try : [EOL] import serial [EOL] except ImportError : [EOL] logger . warning ( [string] [string] ) [EOL] serial = None [EOL] [EOL] try : [EOL] from serial . tools import list_ports [EOL] except ImportError : [EOL] list_ports = None [EOL] [EOL] [EOL] class SerialBus ( BusABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , channel , baudrate = [number] , timeout = [number] , rtscts = False , * args , ** kwargs ) : [EOL] [docstring] [EOL] if not channel : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . channel_info = [string] + channel [EOL] self . ser = serial . serial_for_url ( channel , baudrate = baudrate , timeout = timeout , rtscts = rtscts ) [EOL] [EOL] super ( ) . __init__ ( channel = channel , * args , ** kwargs ) [EOL] [EOL] def shutdown ( self ) : [EOL] [docstring] [EOL] self . ser . close ( ) [EOL] [EOL] def send ( self , msg , timeout = None ) : [EOL] [docstring] [EOL] try : [EOL] timestamp = struct . pack ( [string] , int ( msg . timestamp * [number] ) ) [EOL] except struct . error : [EOL] raise ValueError ( [string] ) [EOL] try : [EOL] a_id = struct . pack ( [string] , msg . arbitration_id ) [EOL] except struct . error : [EOL] raise ValueError ( [string] ) [EOL] byte_msg = bytearray ( ) [EOL] byte_msg . append ( [number] ) [EOL] for i in range ( [number] , [number] ) : [EOL] byte_msg . append ( timestamp [ i ] ) [EOL] byte_msg . append ( msg . dlc ) [EOL] for i in range ( [number] , [number] ) : [EOL] byte_msg . append ( a_id [ i ] ) [EOL] for i in range ( [number] , msg . dlc ) : [EOL] byte_msg . append ( msg . data [ i ] ) [EOL] byte_msg . append ( [number] ) [EOL] self . ser . write ( byte_msg ) [EOL] [EOL] def _recv_internal ( self , timeout ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] rx_byte = self . ser . read ( ) [EOL] except serial . SerialException : [EOL] return None , False [EOL] [EOL] if rx_byte and ord ( rx_byte ) == [number] : [EOL] s = bytearray ( self . ser . read ( [number] ) ) [EOL] timestamp = ( struct . unpack ( [string] , s ) ) [ [number] ] [EOL] dlc = ord ( self . ser . read ( ) ) [EOL] [EOL] s = bytearray ( self . ser . read ( [number] ) ) [EOL] arb_id = ( struct . unpack ( [string] , s ) ) [ [number] ] [EOL] [EOL] data = self . ser . read ( dlc ) [EOL] [EOL] rxd_byte = ord ( self . ser . read ( ) ) [EOL] if rxd_byte == [number] : [EOL] [comment] [EOL] msg = Message ( timestamp = timestamp / [number] , arbitration_id = arb_id , dlc = dlc , data = data , ) [EOL] return msg , False [EOL] [EOL] else : [EOL] return None , False [EOL] [EOL] def fileno ( self ) : [EOL] if hasattr ( self . ser , [string] ) : [EOL] return self . ser . fileno ( ) [EOL] [comment] [EOL] return - [number] [EOL] [EOL] @ staticmethod def _detect_available_configs ( ) : [EOL] channels = [ ] [EOL] serial_ports = [ ] [EOL] [EOL] if list_ports : [EOL] serial_ports = list_ports . comports ( ) [EOL] [EOL] for port in serial_ports : [EOL] channels . append ( { [string] : [string] , [string] : port . device } ) [EOL] return channels [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[docstring] [EOL] [EOL] from can . interfaces . ixxat . canlib import IXXATBus [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from can import CanError [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class VCITimeout ( CanError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class VCIError ( CanError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class VCIRxQueueEmptyError ( VCIError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] ) [EOL] [EOL] [EOL] class VCIDeviceNotFoundError ( CanError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from enum import IntEnum [EOL] [EOL] [EOL] MAX_MSG_LEN = [number] [EOL] XL_CAN_MAX_DATA_LEN = [number] [EOL] XL_INVALID_PORTHANDLE = - [number] [EOL] [EOL] [EOL] class XL_AC_Flags ( IntEnum ) : [EOL] XL_ACTIVATE_NONE = [number] [EOL] XL_ACTIVATE_RESET_CLOCK = [number] [EOL] [EOL] [EOL] class XL_AcceptanceFilter ( IntEnum ) : [EOL] XL_CAN_STD = [number] [EOL] XL_CAN_EXT = [number] [EOL] [EOL] [EOL] class XL_BusCapabilities ( IntEnum ) : [EOL] XL_BUS_COMPATIBLE_CAN = [number] [EOL] XL_BUS_ACTIVE_CAP_CAN = [number] [EOL] [EOL] [EOL] class XL_BusStatus ( IntEnum ) : [EOL] XL_CHIPSTAT_BUSOFF = [number] [EOL] XL_CHIPSTAT_ERROR_PASSIVE = [number] [EOL] XL_CHIPSTAT_ERROR_WARNING = [number] [EOL] XL_CHIPSTAT_ERROR_ACTIVE = [number] [EOL] [EOL] [EOL] class XL_BusTypes ( IntEnum ) : [EOL] XL_BUS_TYPE_NONE = [number] [EOL] XL_BUS_TYPE_CAN = [number] [EOL] [EOL] [EOL] class XL_CANFD_BusParams_CanOpMode ( IntEnum ) : [EOL] XL_BUS_PARAMS_CANOPMODE_CAN20 = [number] [EOL] XL_BUS_PARAMS_CANOPMODE_CANFD = [number] [EOL] XL_BUS_PARAMS_CANOPMODE_CANFD_NO_ISO = [number] [EOL] [EOL] [EOL] class XL_CANFD_ConfigOptions ( IntEnum ) : [EOL] CANFD_CONFOPT_NO_ISO = [number] [EOL] [EOL] [EOL] class XL_CANFD_RX_EV_ERROR_errorCode ( IntEnum ) : [EOL] XL_CAN_ERRC_BIT_ERROR = [number] [EOL] XL_CAN_ERRC_FORM_ERROR = [number] [EOL] XL_CAN_ERRC_STUFF_ERROR = [number] [EOL] XL_CAN_ERRC_OTHER_ERROR = [number] [EOL] XL_CAN_ERRC_CRC_ERROR = [number] [EOL] XL_CAN_ERRC_ACK_ERROR = [number] [EOL] XL_CAN_ERRC_NACK_ERROR = [number] [EOL] XL_CAN_ERRC_OVLD_ERROR = [number] [EOL] XL_CAN_ERRC_EXCPT_ERROR = [number] [EOL] [EOL] [EOL] class XL_CANFD_RX_EventTags ( IntEnum ) : [EOL] XL_SYNC_PULSE = [number] [EOL] XL_CAN_EV_TAG_RX_OK = [number] [EOL] XL_CAN_EV_TAG_RX_ERROR = [number] [EOL] XL_CAN_EV_TAG_TX_ERROR = [number] [EOL] XL_CAN_EV_TAG_TX_REQUEST = [number] [EOL] XL_CAN_EV_TAG_TX_OK = [number] [EOL] XL_CAN_EV_TAG_CHIP_STATE = [number] [EOL] [EOL] [EOL] class XL_CANFD_RX_MessageFlags ( IntEnum ) : [EOL] XL_CAN_RXMSG_FLAG_NONE = [number] [EOL] XL_CAN_RXMSG_FLAG_EDL = [number] [EOL] XL_CAN_RXMSG_FLAG_BRS = [number] [EOL] XL_CAN_RXMSG_FLAG_ESI = [number] [EOL] XL_CAN_RXMSG_FLAG_RTR = [number] [EOL] XL_CAN_RXMSG_FLAG_EF = [number] [EOL] XL_CAN_RXMSG_FLAG_ARB_LOST = [number] [EOL] XL_CAN_RXMSG_FLAG_WAKEUP = [number] [EOL] XL_CAN_RXMSG_FLAG_TE = [number] [EOL] [EOL] [EOL] class XL_CANFD_TX_EventTags ( IntEnum ) : [EOL] XL_CAN_EV_TAG_TX_MSG = [number] [comment] [EOL] XL_CAN_EV_TAG_TX_ERRFR = [number] [comment] [EOL] [EOL] [EOL] class XL_CANFD_TX_MessageFlags ( IntEnum ) : [EOL] XL_CAN_TXMSG_FLAG_NONE = [number] [EOL] XL_CAN_TXMSG_FLAG_EDL = [number] [EOL] XL_CAN_TXMSG_FLAG_BRS = [number] [EOL] XL_CAN_TXMSG_FLAG_RTR = [number] [EOL] XL_CAN_TXMSG_FLAG_HIGHPRIO = [number] [EOL] XL_CAN_TXMSG_FLAG_WAKEUP = [number] [EOL] [EOL] [EOL] class XL_ChannelCapabilities ( IntEnum ) : [EOL] XL_CHANNEL_FLAG_TIME_SYNC_RUNNING = [number] [EOL] XL_CHANNEL_FLAG_NO_HWSYNC_SUPPORT = [number] [EOL] XL_CHANNEL_FLAG_SPDIF_CAPABLE = [number] [EOL] XL_CHANNEL_FLAG_CANFD_BOSCH_SUPPORT = [number] [EOL] XL_CHANNEL_FLAG_CMACTLICENSE_SUPPORT = [number] [EOL] XL_CHANNEL_FLAG_CANFD_ISO_SUPPORT = [number] [EOL] [EOL] [EOL] class XL_EventTags ( IntEnum ) : [EOL] XL_NO_COMMAND = [number] [EOL] XL_RECEIVE_MSG = [number] [EOL] XL_CHIP_STATE = [number] [EOL] XL_TRANSCEIVER = [number] [EOL] XL_TIMER = [number] [EOL] XL_TRANSMIT_MSG = [number] [EOL] XL_SYNC_PULSE = [number] [EOL] XL_APPLICATION_NOTIFICATION = [number] [EOL] [EOL] [EOL] class XL_InterfaceVersion ( IntEnum ) : [EOL] XL_INTERFACE_VERSION_V2 = [number] [EOL] XL_INTERFACE_VERSION_V3 = [number] [EOL] XL_INTERFACE_VERSION = XL_INTERFACE_VERSION_V3 [EOL] XL_INTERFACE_VERSION_V4 = [number] [EOL] [EOL] [EOL] class XL_MessageFlags ( IntEnum ) : [EOL] XL_CAN_MSG_FLAG_NONE = [number] [EOL] XL_CAN_MSG_FLAG_ERROR_FRAME = [number] [EOL] XL_CAN_MSG_FLAG_OVERRUN = [number] [EOL] XL_CAN_MSG_FLAG_NERR = [number] [EOL] XL_CAN_MSG_FLAG_WAKEUP = [number] [EOL] XL_CAN_MSG_FLAG_REMOTE_FRAME = [number] [EOL] XL_CAN_MSG_FLAG_RESERVED_1 = [number] [EOL] XL_CAN_MSG_FLAG_TX_COMPLETED = [number] [EOL] XL_CAN_MSG_FLAG_TX_REQUEST = [number] [EOL] XL_CAN_MSG_FLAG_SRR_BIT_DOM = [number] [EOL] XL_EVENT_FLAG_OVERRUN = [number] [EOL] [EOL] [EOL] class XL_MessageFlagsExtended ( IntEnum ) : [EOL] XL_CAN_EXT_MSG_ID = [number] [EOL] [EOL] [EOL] class XL_OutputMode ( IntEnum ) : [EOL] XL_OUTPUT_MODE_SILENT = [number] [EOL] XL_OUTPUT_MODE_NORMAL = [number] [EOL] XL_OUTPUT_MODE_TX_OFF = [number] [EOL] XL_OUTPUT_MODE_SJA_1000_SILENT = [number] [EOL] [EOL] [EOL] class XL_Sizes ( IntEnum ) : [EOL] XL_MAX_LENGTH = [number] [EOL] XL_MAX_APPNAME = [number] [EOL] XL_MAX_NAME_LENGTH = [number] [EOL] XLEVENT_SIZE = [number] [EOL] XL_CONFIG_MAX_CHANNELS = [number] [EOL] XL_APPLCONFIG_MAX_CHANNELS = [number] [EOL] [EOL] [EOL] class XL_Status ( IntEnum ) : [EOL] XL_SUCCESS = [number] [comment] [EOL] XL_PENDING = [number] [comment] [EOL] XL_ERR_QUEUE_IS_EMPTY = [number] [comment] [EOL] XL_ERR_QUEUE_IS_FULL = [number] [comment] [EOL] XL_ERR_TX_NOT_POSSIBLE = [number] [comment] [EOL] XL_ERR_NO_LICENSE = [number] [comment] [EOL] XL_ERR_WRONG_PARAMETER = [number] [comment] [EOL] XL_ERR_TWICE_REGISTER = [number] [comment] [EOL] XL_ERR_INVALID_CHAN_INDEX = [number] [comment] [EOL] XL_ERR_INVALID_ACCESS = [number] [comment] [EOL] XL_ERR_PORT_IS_OFFLINE = [number] [comment] [EOL] XL_ERR_CHAN_IS_ONLINE = [number] [comment] [EOL] XL_ERR_NOT_IMPLEMENTED = [number] [comment] [EOL] XL_ERR_INVALID_PORT = [number] [comment] [EOL] XL_ERR_HW_NOT_READY = [number] [comment] [EOL] XL_ERR_CMD_TIMEOUT = [number] [comment] [EOL] XL_ERR_HW_NOT_PRESENT = [number] [comment] [EOL] XL_ERR_NOTIFY_ALREADY_ACTIVE = [number] [comment] [EOL] XL_ERR_NO_RESOURCES = [number] [comment] [EOL] XL_ERR_WRONG_CHIP_TYPE = [number] [comment] [EOL] XL_ERR_WRONG_COMMAND = [number] [comment] [EOL] XL_ERR_INVALID_HANDLE = [number] [comment] [EOL] XL_ERR_RESERVED_NOT_ZERO = [number] [comment] [EOL] XL_ERR_INIT_ACCESS_MISSING = [number] [comment] [EOL] XL_ERR_CANNOT_OPEN_DRIVER = [number] [comment] [EOL] XL_ERR_WRONG_BUS_TYPE = [number] [comment] [EOL] XL_ERR_DLL_NOT_FOUND = [number] [comment] [EOL] XL_ERR_INVALID_CHANNEL_MASK = [number] [comment] [EOL] XL_ERR_NOT_SUPPORTED = [number] [comment] [EOL] XL_ERR_CONNECTION_BROKEN = [number] [comment] [EOL] XL_ERR_CONNECTION_CLOSED = [number] [comment] [EOL] XL_ERR_INVALID_STREAM_NAME = [number] [comment] [EOL] XL_ERR_CONNECTION_FAILED = [number] [comment] [EOL] XL_ERR_STREAM_NOT_FOUND = [number] [comment] [EOL] XL_ERR_STREAM_NOT_CONNECTED = [number] [comment] [EOL] XL_ERR_QUEUE_OVERRUN = [number] [comment] [EOL] XL_ERROR = [number] [comment] [EOL] [EOL] [comment] [EOL] XL_ERR_INVALID_DLC = [number] [comment] [EOL] XL_ERR_INVALID_CANID = [number] [comment] [EOL] XL_ERR_INVALID_FDFLAG_MODE20 = [number] [comment] [EOL] XL_ERR_EDL_RTR = [number] [comment] [EOL] XL_ERR_EDL_NOT_SET = [number] [comment] [EOL] XL_ERR_UNKNOWN_FLAG = [number] [comment] [EOL] [EOL] [EOL] class XL_TimeSyncNewValue ( IntEnum ) : [EOL] XL_SET_TIMESYNC_NO_CHANGE = [number] [EOL] XL_SET_TIMESYNC_ON = [number] [EOL] XL_SET_TIMESYNC_OFF = [number] [EOL] [EOL] [EOL] class XL_HardwareType ( IntEnum ) : [EOL] XL_HWTYPE_NONE = [number] [EOL] XL_HWTYPE_VIRTUAL = [number] [EOL] XL_HWTYPE_CANCARDX = [number] [EOL] XL_HWTYPE_CANAC2PCI = [number] [EOL] XL_HWTYPE_CANCARDY = [number] [EOL] XL_HWTYPE_CANCARDXL = [number] [EOL] XL_HWTYPE_CANCASEXL = [number] [EOL] XL_HWTYPE_CANCASEXL_LOG_OBSOLETE = [number] [EOL] XL_HWTYPE_CANBOARDXL = [number] [EOL] XL_HWTYPE_CANBOARDXL_PXI = [number] [EOL] XL_HWTYPE_VN2600 = [number] [EOL] XL_HWTYPE_VN2610 = XL_HWTYPE_VN2600 [EOL] XL_HWTYPE_VN3300 = [number] [EOL] XL_HWTYPE_VN3600 = [number] [EOL] XL_HWTYPE_VN7600 = [number] [EOL] XL_HWTYPE_CANCARDXLE = [number] [EOL] XL_HWTYPE_VN8900 = [number] [EOL] XL_HWTYPE_VN8950 = [number] [EOL] XL_HWTYPE_VN2640 = [number] [EOL] XL_HWTYPE_VN1610 = [number] [EOL] XL_HWTYPE_VN1630 = [number] [EOL] XL_HWTYPE_VN1640 = [number] [EOL] XL_HWTYPE_VN8970 = [number] [EOL] XL_HWTYPE_VN1611 = [number] [EOL] XL_HWTYPE_VN5610 = [number] [EOL] XL_HWTYPE_VN5620 = [number] [EOL] XL_HWTYPE_VN7570 = [number] [EOL] XL_HWTYPE_IPCLIENT = [number] [EOL] XL_HWTYPE_IPSERVER = [number] [EOL] XL_HWTYPE_VX1121 = [number] [EOL] XL_HWTYPE_VX1131 = [number] [EOL] XL_HWTYPE_VT6204 = [number] [EOL] XL_HWTYPE_VN1630_LOG = [number] [EOL] XL_HWTYPE_VN7610 = [number] [EOL] XL_HWTYPE_VN7572 = [number] [EOL] XL_HWTYPE_VN8972 = [number] [EOL] XL_HWTYPE_VN0601 = [number] [EOL] XL_HWTYPE_VN5640 = [number] [EOL] XL_HWTYPE_VX0312 = [number] [EOL] XL_HWTYPE_VH6501 = [number] [EOL] XL_HWTYPE_VN8800 = [number] [EOL] XL_HWTYPE_IPCL8800 = [number] [EOL] XL_HWTYPE_IPSRV8800 = [number] [EOL] XL_HWTYPE_CSMCAN = [number] [EOL] XL_HWTYPE_VN5610A = [number] [EOL] XL_HWTYPE_VN7640 = [number] [EOL] XL_HWTYPE_VX1135 = [number] [EOL] XL_HWTYPE_VN4610 = [number] [EOL] XL_HWTYPE_VT6306 = [number] [EOL] XL_HWTYPE_VT6104A = [number] [EOL] XL_HWTYPE_VN5430 = [number] [EOL] XL_HWTYPE_VN1530 = [number] [EOL] XL_HWTYPE_VN1531 = [number] [EOL] XL_MAX_HWTYPE = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from can import CanError [EOL] [EOL] [EOL] class VectorError ( CanError ) : [EOL] def __init__ ( self , error_code , error_string , function ) : [EOL] self . error_code = error_code [EOL] super ( ) . __init__ ( f"{ function } [string] { error_string } [string] " ) [EOL] [EOL] [comment] [EOL] self . _args = error_code , error_string , function [EOL] [EOL] def __reduce__ ( self ) : [EOL] return VectorError , self . _args , { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from . canlib import VectorBus [EOL] from . exceptions import VectorError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple , Type [EOL] import ctypes [EOL] import typing [EOL] [docstring] [EOL] [EOL] import ctypes [EOL] [EOL] [EOL] class BusStatistics ( ctypes . Structure ) : [EOL] [docstring] [EOL] [EOL] _fields_ = [ ( [string] , ctypes . c_ulong ) , ( [string] , ctypes . c_ulong ) , ( [string] , ctypes . c_ulong ) , ( [string] , ctypes . c_ulong ) , ( [string] , ctypes . c_ulong ) , ( [string] , ctypes . c_ulong ) , ( [string] , ctypes . c_ulong ) , ] [EOL] [EOL] def __str__ ( self ) : [EOL] return ( [string] [string] ) . format ( self . std_data , self . std_remote , self . ext_data , self . ext_remote , self . err_frame , self . bus_load / [number] , self . overruns , ) [EOL] [EOL] @ property def std_data ( self ) : [EOL] [docstring] [EOL] return self . m_stdData [EOL] [EOL] @ property def std_remote ( self ) : [EOL] [docstring] [EOL] return self . m_stdRemote [EOL] [EOL] @ property def ext_data ( self ) : [EOL] [docstring] [EOL] return self . m_extData [EOL] [EOL] @ property def ext_remote ( self ) : [EOL] [docstring] [EOL] return self . m_extRemote [EOL] [EOL] @ property def err_frame ( self ) : [EOL] [docstring] [EOL] return self . m_errFrame [EOL] [EOL] @ property def bus_load ( self ) : [EOL] [docstring] [EOL] return self . m_busLoad [EOL] [EOL] @ property def overruns ( self ) : [EOL] [docstring] [EOL] return self . m_overruns [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[ctypes.c_ulong]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from can . interfaces . kvaser . canlib import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Sequence , Type , Union , Tuple , Optional , Dict [EOL] import builtins [EOL] import can [EOL] import typing [EOL] import ctypes [EOL] import threading [EOL] import logging [EOL] import socket [EOL] [docstring] [EOL] [EOL] from typing import Dict , List , Optional , Sequence , Tuple , Type , Union [EOL] [EOL] import logging [EOL] import ctypes [EOL] import ctypes . util [EOL] import select [EOL] import socket [EOL] import struct [EOL] import time [EOL] import threading [EOL] import errno [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] log_tx = log . getChild ( [string] ) [EOL] log_rx = log . getChild ( [string] ) [EOL] [EOL] try : [EOL] import fcntl [EOL] except ImportError : [EOL] log . error ( [string] ) [EOL] [EOL] [EOL] import can [EOL] from can import Message , BusABC [EOL] from can . broadcastmanager import ( ModifiableCyclicTaskABC , RestartableCyclicTaskABC , LimitedDurationCyclicSendTaskABC , ) [EOL] from can . typechecking import CanFilters [EOL] from can . interfaces . socketcan . constants import * [comment] [EOL] from can . interfaces . socketcan . utils import pack_filters , find_available_interfaces [EOL] [EOL] [comment] [EOL] def bcm_header_factory ( fields , alignment = [number] , ) : [EOL] curr_stride = [number] [EOL] results = [ ] [EOL] pad_index = [number] [EOL] for field in fields : [EOL] field_alignment = ctypes . alignment ( field [ [number] ] ) [EOL] field_size = ctypes . sizeof ( field [ [number] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] while curr_stride % field_alignment != [number] : [EOL] results . append ( ( [string] . format ( pad_index ) , ctypes . c_uint8 ) ) [EOL] pad_index += [number] [EOL] curr_stride += [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] results . append ( field ) [EOL] curr_stride += field_size [EOL] [EOL] [comment] [EOL] [comment] [EOL] while curr_stride % alignment != [number] : [EOL] results . append ( ( [string] . format ( pad_index ) , ctypes . c_uint8 ) ) [EOL] pad_index += [number] [EOL] curr_stride += [number] [EOL] [EOL] return type ( [string] , ( ctypes . Structure , ) , { [string] : results } ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] BcmMsgHead = bcm_header_factory ( fields = [ ( [string] , ctypes . c_uint32 ) , ( [string] , ctypes . c_uint32 ) , ( [string] , ctypes . c_uint32 ) , ( [string] , ctypes . c_long ) , ( [string] , ctypes . c_long ) , ( [string] , ctypes . c_long ) , ( [string] , ctypes . c_long ) , ( [string] , ctypes . c_uint32 ) , ( [string] , ctypes . c_uint32 ) , ] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] CAN_FRAME_HEADER_STRUCT = struct . Struct ( [string] ) [EOL] [EOL] [EOL] def build_can_frame ( msg ) : [EOL] [docstring] [EOL] can_id = _compose_arbitration_id ( msg ) [EOL] flags = [number] [EOL] if msg . bitrate_switch : [EOL] flags |= CANFD_BRS [EOL] if msg . error_state_indicator : [EOL] flags |= CANFD_ESI [EOL] max_len = [number] if msg . is_fd else [number] [EOL] data = bytes ( msg . data ) . ljust ( max_len , [string] ) [EOL] return CAN_FRAME_HEADER_STRUCT . pack ( can_id , msg . dlc , flags ) + data [EOL] [EOL] [EOL] def build_bcm_header ( opcode , flags , count , ival1_seconds , ival1_usec , ival2_seconds , ival2_usec , can_id , nframes , ) : [EOL] result = BcmMsgHead ( opcode = opcode , flags = flags , count = count , ival1_tv_sec = ival1_seconds , ival1_tv_usec = ival1_usec , ival2_tv_sec = ival2_seconds , ival2_tv_usec = ival2_usec , can_id = can_id , nframes = nframes , ) [EOL] return ctypes . string_at ( ctypes . addressof ( result ) , ctypes . sizeof ( result ) ) [EOL] [EOL] [EOL] def build_bcm_tx_delete_header ( can_id , flags ) : [EOL] opcode = CAN_BCM_TX_DELETE [EOL] return build_bcm_header ( opcode , flags , [number] , [number] , [number] , [number] , [number] , can_id , [number] ) [EOL] [EOL] [EOL] def build_bcm_transmit_header ( can_id , count , initial_period , subsequent_period , msg_flags , nframes = [number] , ) : [EOL] opcode = CAN_BCM_TX_SETUP [EOL] [EOL] flags = msg_flags | SETTIMER | STARTTIMER [EOL] [EOL] if initial_period > [number] : [EOL] [comment] [EOL] flags |= TX_COUNTEVT [EOL] [EOL] def split_time ( value ) : [EOL] [docstring] [EOL] seconds = int ( value ) [EOL] microseconds = int ( [number] * ( value - seconds ) ) [EOL] return seconds , microseconds [EOL] [EOL] ival1_seconds , ival1_usec = split_time ( initial_period ) [EOL] ival2_seconds , ival2_usec = split_time ( subsequent_period ) [EOL] [EOL] return build_bcm_header ( opcode , flags , count , ival1_seconds , ival1_usec , ival2_seconds , ival2_usec , can_id , nframes , ) [EOL] [EOL] [EOL] def build_bcm_update_header ( can_id , msg_flags , nframes = [number] ) : [EOL] return build_bcm_header ( CAN_BCM_TX_SETUP , msg_flags , [number] , [number] , [number] , [number] , [number] , can_id , nframes ) [EOL] [EOL] [EOL] def dissect_can_frame ( frame ) : [EOL] can_id , can_dlc , flags = CAN_FRAME_HEADER_STRUCT . unpack_from ( frame ) [EOL] if len ( frame ) != CANFD_MTU : [EOL] [comment] [EOL] flags = [number] [EOL] return can_id , can_dlc , flags , frame [ [number] : [number] + can_dlc ] [EOL] [EOL] [EOL] def create_bcm_socket ( channel ) : [EOL] [docstring] [EOL] s = socket . socket ( PF_CAN , socket . SOCK_DGRAM , CAN_BCM ) [EOL] s . connect ( ( channel , ) ) [EOL] return s [EOL] [EOL] [EOL] def send_bcm ( bcm_socket , data ) : [EOL] [docstring] [EOL] try : [EOL] return bcm_socket . send ( data ) [EOL] except OSError as e : [EOL] base = [string] . format ( e . errno , e . strerror ) [EOL] [EOL] if e . errno == errno . EINVAL : [EOL] raise can . CanError ( base + [string] ) [EOL] [EOL] elif e . errno == errno . ENETDOWN : [EOL] raise can . CanError ( base + [string] ) [EOL] [EOL] elif e . errno == errno . EBADF : [EOL] raise can . CanError ( base + [string] ) [EOL] [EOL] else : [EOL] raise e [EOL] [EOL] [EOL] def _compose_arbitration_id ( message ) : [EOL] can_id = message . arbitration_id [EOL] if message . is_extended_id : [EOL] log . debug ( [string] ) [EOL] can_id |= CAN_EFF_FLAG [EOL] if message . is_remote_frame : [EOL] log . debug ( [string] ) [EOL] can_id |= CAN_RTR_FLAG [EOL] if message . is_error_frame : [EOL] log . debug ( [string] ) [EOL] can_id |= CAN_ERR_FLAG [EOL] return can_id [EOL] [EOL] [EOL] class CyclicSendTask ( LimitedDurationCyclicSendTaskABC , ModifiableCyclicTaskABC , RestartableCyclicTaskABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , bcm_socket , task_id , messages , period , duration = None , ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] super ( ) . __init__ ( messages , period , duration ) [EOL] [EOL] self . bcm_socket = bcm_socket [EOL] self . task_id = task_id [EOL] self . _tx_setup ( self . messages ) [EOL] [EOL] def _tx_setup ( self , messages ) : [EOL] [comment] [EOL] body = bytearray ( ) [EOL] self . flags = CAN_FD_FRAME if messages [ [number] ] . is_fd else [number] [EOL] [EOL] if self . duration : [EOL] count = int ( self . duration / self . period ) [EOL] ival1 = self . period [EOL] ival2 = [number] [EOL] else : [EOL] count = [number] [EOL] ival1 = [number] [EOL] ival2 = self . period [EOL] [EOL] self . _check_bcm_task ( ) [EOL] [EOL] header = build_bcm_transmit_header ( self . task_id , count , ival1 , ival2 , self . flags , nframes = len ( messages ) ) [EOL] for message in messages : [EOL] body += build_can_frame ( message ) [EOL] log . debug ( [string] ) [EOL] send_bcm ( self . bcm_socket , header + body ) [EOL] [EOL] def _check_bcm_task ( self ) : [EOL] [comment] [EOL] [comment] [EOL] check_header = build_bcm_header ( opcode = CAN_BCM_TX_READ , flags = [number] , count = [number] , ival1_seconds = [number] , ival1_usec = [number] , ival2_seconds = [number] , ival2_usec = [number] , can_id = self . task_id , nframes = [number] , ) [EOL] try : [EOL] self . bcm_socket . send ( check_header ) [EOL] except OSError as e : [EOL] if e . errno != errno . EINVAL : [EOL] raise e [EOL] else : [EOL] raise ValueError ( [string] . format ( self . task_id ) ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] log . debug ( [string] ) [EOL] [EOL] stopframe = build_bcm_tx_delete_header ( self . task_id , self . flags ) [EOL] send_bcm ( self . bcm_socket , stopframe ) [EOL] [EOL] def modify_data ( self , messages ) : [EOL] [docstring] [EOL] messages = self . _check_and_convert_messages ( messages ) [EOL] self . _check_modified_messages ( messages ) [EOL] [EOL] self . messages = messages [EOL] [EOL] body = bytearray ( ) [EOL] header = build_bcm_update_header ( can_id = self . task_id , msg_flags = self . flags , nframes = len ( messages ) ) [EOL] for message in messages : [EOL] body += build_can_frame ( message ) [EOL] log . debug ( [string] ) [EOL] send_bcm ( self . bcm_socket , header + body ) [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] self . _tx_setup ( self . messages ) [EOL] [EOL] [EOL] class MultiRateCyclicSendTask ( CyclicSendTask ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , channel , task_id , messages , count , initial_period , subsequent_period , ) : [EOL] super ( ) . __init__ ( channel , task_id , messages , subsequent_period ) [EOL] [EOL] [comment] [EOL] header = build_bcm_transmit_header ( self . task_id , count , initial_period , subsequent_period , self . flags , nframes = len ( messages ) , ) [EOL] [EOL] body = bytearray ( ) [EOL] for message in messages : [EOL] body += build_can_frame ( message ) [EOL] [EOL] log . info ( [string] ) [EOL] send_bcm ( self . bcm_socket , header + body ) [EOL] [EOL] [EOL] def create_socket ( ) : [EOL] [docstring] [EOL] sock = socket . socket ( PF_CAN , socket . SOCK_RAW , CAN_RAW ) [EOL] [EOL] log . info ( [string] ) [EOL] [EOL] return sock [EOL] [EOL] [EOL] def bind_socket ( sock , channel = [string] ) : [EOL] [docstring] [EOL] log . debug ( [string] , channel ) [EOL] sock . bind ( ( channel , ) ) [EOL] log . debug ( [string] ) [EOL] [EOL] [EOL] def capture_message ( sock , get_channel = False ) : [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] if get_channel : [EOL] cf , _ , msg_flags , addr = sock . recvmsg ( CANFD_MTU ) [EOL] channel = addr [ [number] ] if isinstance ( addr , tuple ) else addr [EOL] else : [EOL] cf , _ , msg_flags , _ = sock . recvmsg ( CANFD_MTU ) [EOL] channel = None [EOL] except socket . error as exc : [EOL] raise can . CanError ( [string] % exc ) [EOL] [EOL] can_id , can_dlc , flags , data = dissect_can_frame ( cf ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] binary_structure = [string] [EOL] res = fcntl . ioctl ( sock . fileno ( ) , SIOCGSTAMP , struct . pack ( binary_structure , [number] , [number] ) ) [EOL] [EOL] seconds , microseconds = struct . unpack ( binary_structure , res ) [EOL] timestamp = seconds + microseconds * [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] is_extended_frame_format = bool ( can_id & CAN_EFF_FLAG ) [EOL] is_remote_transmission_request = bool ( can_id & CAN_RTR_FLAG ) [EOL] is_error_frame = bool ( can_id & CAN_ERR_FLAG ) [EOL] is_fd = len ( cf ) == CANFD_MTU [EOL] bitrate_switch = bool ( flags & CANFD_BRS ) [EOL] error_state_indicator = bool ( flags & CANFD_ESI ) [EOL] [EOL] [comment] [EOL] is_rx = not bool ( msg_flags & socket . MSG_DONTROUTE ) [EOL] [EOL] if is_extended_frame_format : [EOL] [comment] [EOL] [comment] [EOL] arbitration_id = can_id & [number] [EOL] else : [EOL] [comment] [EOL] arbitration_id = can_id & [number] [EOL] [EOL] msg = Message ( timestamp = timestamp , channel = channel , arbitration_id = arbitration_id , is_extended_id = is_extended_frame_format , is_remote_frame = is_remote_transmission_request , is_error_frame = is_error_frame , is_fd = is_fd , is_rx = is_rx , bitrate_switch = bitrate_switch , error_state_indicator = error_state_indicator , dlc = can_dlc , data = data , ) [EOL] [EOL] [comment] [EOL] [EOL] return msg [EOL] [EOL] [EOL] class SocketcanBus ( BusABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , channel = [string] , receive_own_messages = False , fd = False , can_filters = None , ** kwargs , ) : [EOL] [docstring] [EOL] self . socket = create_socket ( ) [EOL] self . channel = channel [EOL] self . channel_info = [string] % channel [EOL] self . _bcm_sockets = { } [EOL] self . _is_filtered = False [EOL] self . _task_id = [number] [EOL] self . _task_id_guard = threading . Lock ( ) [EOL] [EOL] [comment] [EOL] try : [EOL] self . socket . setsockopt ( SOL_CAN_RAW , CAN_RAW_RECV_OWN_MSGS , [number] if receive_own_messages else [number] ) [EOL] except socket . error as error : [EOL] log . error ( [string] , error ) [EOL] [EOL] [comment] [EOL] if fd : [EOL] try : [EOL] self . socket . setsockopt ( SOL_CAN_RAW , CAN_RAW_FD_FRAMES , [number] ) [EOL] except socket . error as error : [EOL] log . error ( [string] , error ) [EOL] [EOL] [comment] [EOL] try : [EOL] self . socket . setsockopt ( SOL_CAN_RAW , CAN_RAW_ERR_FILTER , [number] ) [EOL] except socket . error as error : [EOL] log . error ( [string] , error ) [EOL] [EOL] bind_socket ( self . socket , channel ) [EOL] kwargs . update ( { [string] : receive_own_messages , [string] : fd } ) [EOL] super ( ) . __init__ ( channel = channel , can_filters = can_filters , ** kwargs ) [EOL] [EOL] def shutdown ( self ) : [EOL] [docstring] [EOL] self . stop_all_periodic_tasks ( ) [EOL] for channel , bcm_socket in self . _bcm_sockets . items ( ) : [EOL] log . debug ( [string] , channel ) [EOL] bcm_socket . close ( ) [EOL] log . debug ( [string] ) [EOL] self . socket . close ( ) [EOL] [EOL] def _recv_internal ( self , timeout ) : [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] ready_receive_sockets , _ , _ = select . select ( [ self . socket ] , [ ] , [ ] , timeout ) [EOL] except socket . error as exc : [EOL] [comment] [EOL] raise can . CanError ( f" [string] { exc }" ) [EOL] [EOL] if ready_receive_sockets : [comment] [EOL] get_channel = self . channel == [string] [EOL] msg = capture_message ( self . socket , get_channel ) [EOL] if msg and not msg . channel and self . channel : [EOL] [comment] [EOL] msg . channel = self . channel [EOL] return msg , self . _is_filtered [EOL] [EOL] [comment] [EOL] return None , self . _is_filtered [EOL] [EOL] def send ( self , msg , timeout = None ) : [EOL] [docstring] [EOL] log . debug ( [string] ) [EOL] logger_tx = log . getChild ( [string] ) [EOL] logger_tx . debug ( [string] , msg ) [EOL] [EOL] started = time . time ( ) [EOL] [comment] [EOL] if timeout is None : [EOL] timeout = [number] [EOL] time_left = timeout [EOL] data = build_can_frame ( msg ) [EOL] [EOL] while time_left >= [number] : [EOL] [comment] [EOL] ready = select . select ( [ ] , [ self . socket ] , [ ] , time_left ) [ [number] ] [EOL] if not ready : [EOL] [comment] [EOL] break [EOL] channel = str ( msg . channel ) if msg . channel else None [EOL] sent = self . _send_once ( data , channel ) [EOL] if sent == len ( data ) : [EOL] return [EOL] [comment] [EOL] data = data [ sent : ] [EOL] time_left = timeout - ( time . time ( ) - started ) [EOL] [EOL] raise can . CanError ( [string] ) [EOL] [EOL] def _send_once ( self , data , channel = None ) : [EOL] try : [EOL] if self . channel == [string] and channel : [EOL] [comment] [EOL] sent = self . socket . sendto ( data , ( channel , ) ) [EOL] else : [EOL] sent = self . socket . send ( data ) [EOL] except socket . error as exc : [EOL] raise can . CanError ( [string] % exc ) [EOL] return sent [EOL] [EOL] def _send_periodic_internal ( self , msgs , period , duration = None , ) : [EOL] [docstring] [EOL] msgs = LimitedDurationCyclicSendTaskABC . _check_and_convert_messages ( msgs ) [EOL] [EOL] msgs_channel = str ( msgs [ [number] ] . channel ) if msgs [ [number] ] . channel else None [EOL] bcm_socket = self . _get_bcm_socket ( msgs_channel or self . channel ) [EOL] task_id = self . _get_next_task_id ( ) [EOL] task = CyclicSendTask ( bcm_socket , task_id , msgs , period , duration ) [EOL] return task [EOL] [EOL] def _get_next_task_id ( self ) : [EOL] with self . _task_id_guard : [EOL] self . _task_id = ( self . _task_id + [number] ) % ( [number] ** [number] - [number] ) [EOL] return self . _task_id [EOL] [EOL] def _get_bcm_socket ( self , channel ) : [EOL] if channel not in self . _bcm_sockets : [EOL] self . _bcm_sockets [ channel ] = create_bcm_socket ( self . channel ) [EOL] return self . _bcm_sockets [ channel ] [EOL] [EOL] def _apply_filters ( self , filters ) : [EOL] try : [EOL] self . socket . setsockopt ( SOL_CAN_RAW , CAN_RAW_FILTER , pack_filters ( filters ) ) [EOL] except socket . error as error : [EOL] [comment] [EOL] self . _is_filtered = False [EOL] log . error ( [string] , error , ) [EOL] else : [EOL] self . _is_filtered = True [EOL] [EOL] def fileno ( self ) : [EOL] return self . socket . fileno ( ) [EOL] [EOL] @ staticmethod def _detect_available_configs ( ) : [EOL] return [ { [string] : [string] , [string] : channel } for channel in find_available_interfaces ( ) ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] log . setLevel ( logging . DEBUG ) [EOL] [EOL] def receiver ( event ) : [EOL] receiver_socket = create_socket ( ) [EOL] bind_socket ( receiver_socket , [string] ) [EOL] print ( [string] ) [EOL] event . set ( ) [EOL] print ( f" [string] { capture_message ( receiver_socket ) }" ) [EOL] [EOL] def sender ( event ) : [EOL] event . wait ( ) [EOL] sender_socket = create_socket ( ) [EOL] bind_socket ( sender_socket , [string] ) [EOL] msg = Message ( arbitration_id = [number] , data = [string] ) [EOL] sender_socket . send ( build_can_frame ( msg ) ) [EOL] print ( [string] ) [EOL] [EOL] import threading [EOL] [EOL] e = threading . Event ( ) [EOL] threading . Thread ( target = receiver , args = ( e , ) ) . start ( ) [EOL] threading . Thread ( target = sender , args = ( e , ) ) . start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[can.typechecking.AutoDetectedConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] CAN_ERR_FLAG = [number] [EOL] CAN_RTR_FLAG = [number] [EOL] CAN_EFF_FLAG = [number] [EOL] [EOL] [comment] [EOL] CAN_BCM_TX_SETUP = [number] [EOL] CAN_BCM_TX_DELETE = [number] [EOL] CAN_BCM_TX_READ = [number] [EOL] [EOL] [comment] [EOL] SETTIMER = [number] [EOL] STARTTIMER = [number] [EOL] TX_COUNTEVT = [number] [EOL] TX_ANNOUNCE = [number] [EOL] TX_CP_CAN_ID = [number] [EOL] RX_FILTER_ID = [number] [EOL] RX_CHECK_DLC = [number] [EOL] RX_NO_AUTOTIMER = [number] [EOL] RX_ANNOUNCE_RESUME = [number] [EOL] TX_RESET_MULTI_IDX = [number] [EOL] RX_RTR_FRAME = [number] [EOL] CAN_FD_FRAME = [number] [EOL] [EOL] CAN_RAW = [number] [EOL] CAN_BCM = [number] [EOL] [EOL] SOL_CAN_BASE = [number] [EOL] SOL_CAN_RAW = SOL_CAN_BASE + CAN_RAW [EOL] [EOL] CAN_RAW_FILTER = [number] [EOL] CAN_RAW_ERR_FILTER = [number] [EOL] CAN_RAW_LOOPBACK = [number] [EOL] CAN_RAW_RECV_OWN_MSGS = [number] [EOL] CAN_RAW_FD_FRAMES = [number] [EOL] [EOL] MSK_ARBID = [number] [EOL] MSK_FLAGS = [number] [EOL] [EOL] PF_CAN = [number] [EOL] SOCK_RAW = [number] [EOL] SOCK_DGRAM = [number] [EOL] AF_CAN = PF_CAN [EOL] [EOL] SIOCGIFNAME = [number] [EOL] SIOCGIFINDEX = [number] [EOL] SIOCGSTAMP = [number] [EOL] EXTFLG = [number] [EOL] [EOL] CANFD_BRS = [number] [EOL] CANFD_ESI = [number] [EOL] [EOL] CANFD_MTU = [number] [EOL] [EOL] STD_ACCEPTANCE_MASK_ALL_BITS = [number] ** [number] - [number] [EOL] MAX_11_BIT_ID = STD_ACCEPTANCE_MASK_ALL_BITS [EOL] [EOL] EXT_ACCEPTANCE_MASK_ALL_BITS = [number] ** [number] - [number] [EOL] MAX_29_BIT_ID = EXT_ACCEPTANCE_MASK_ALL_BITS [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0
[docstring] [EOL] [EOL] from . socketcan import SocketcanBus , CyclicSendTask , MultiRateCyclicSendTask [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from . constants import ReturnCode [EOL] from can import CanError [EOL] [EOL] [EOL] class UcanException ( CanError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , result , func , arguments ) : [EOL] self . result = result . value [EOL] self . func = func [EOL] self . arguments = arguments [EOL] self . return_msgs = { } [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def __str__ ( self ) : [EOL] message = self . return_msgs . get ( self . result , [string] ) [EOL] return f" [string] { self . func . __name__ } [string] { self . result } [string] { message }" [EOL] [EOL] [EOL] class UcanError ( UcanException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , result , func , arguments ) : [EOL] super ( ) . __init__ ( result , func , arguments ) [EOL] self . return_msgs = { ReturnCode . ERR_RESOURCE : [string] , ReturnCode . ERR_MAXMODULES : [string] , ReturnCode . ERR_HWINUSE : [string] , ReturnCode . ERR_ILLVERSION : [string] , ReturnCode . ERR_ILLHW : [string] [string] , ReturnCode . ERR_ILLHANDLE : [string] , ReturnCode . ERR_ILLPARAM : [string] , ReturnCode . ERR_BUSY : [string] , ReturnCode . ERR_TIMEOUT : [string] , ReturnCode . ERR_IOFAILED : [string] , ReturnCode . ERR_DLL_TXFULL : [string] , ReturnCode . ERR_MAXINSTANCES : [string] , ReturnCode . ERR_CANNOTINIT : [string] , ReturnCode . ERR_DISCONECT : [string] , ReturnCode . ERR_NOHWCLASS : [string] , ReturnCode . ERR_ILLCHANNEL : [string] , ReturnCode . ERR_RESERVED1 : [string] , ReturnCode . ERR_ILLHWTYPE : [string] , } [EOL] [EOL] [EOL] class UcanCmdError ( UcanException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , result , func , arguments ) : [EOL] super ( ) . __init__ ( result , func , arguments ) [EOL] self . return_msgs = { ReturnCode . ERRCMD_NOTEQU : [string] , ReturnCode . ERRCMD_REGTST : [string] , ReturnCode . ERRCMD_ILLCMD : [string] , ReturnCode . ERRCMD_EEPROM : [string] , ReturnCode . ERRCMD_RESERVED1 : [string] , ReturnCode . ERRCMD_RESERVED2 : [string] , ReturnCode . ERRCMD_RESERVED3 : [string] , ReturnCode . ERRCMD_ILLBDR : [string] [string] , ReturnCode . ERRCMD_NOTINIT : [string] , ReturnCode . ERRCMD_ALREADYINIT : [string] , ReturnCode . ERRCMD_ILLSUBCMD : [string] , ReturnCode . ERRCMD_ILLIDX : [string] , ReturnCode . ERRCMD_RUNNING : [string] [string] , } [EOL] [EOL] [EOL] class UcanWarning ( UcanException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , result , func , arguments ) : [EOL] super ( ) . __init__ ( result , func , arguments ) [EOL] self . return_msgs = { ReturnCode . WARN_NODATA : [string] , ReturnCode . WARN_SYS_RXOVERRUN : [string] , ReturnCode . WARN_DLL_RXOVERRUN : [string] , ReturnCode . WARN_RESERVED1 : [string] , ReturnCode . WARN_RESERVED2 : [string] , ReturnCode . WARN_FW_TXOVERRUN : [string] [string] , ReturnCode . WARN_FW_RXOVERRUN : [string] [string] , ReturnCode . WARN_FW_TXMSGLOST : [string] , ReturnCode . WARN_NULL_PTR : [string] , ReturnCode . WARN_TXLIMIT : [string] [string] , ReturnCode . WARN_BUSY : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from can . interfaces . systec . ucanbus import UcanBus [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Tuple [EOL] import itertools [EOL] import can [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import os [EOL] import tempfile [EOL] from collections import deque , defaultdict [EOL] from itertools import cycle [EOL] from threading import Event [EOL] [EOL] from can import Message , CanError , BusABC [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] try : [EOL] import ics [EOL] except ImportError as ie : [EOL] logger . warning ( [string] [string] , ie , ) [EOL] ics = None [EOL] [EOL] [EOL] try : [EOL] from filelock import FileLock [EOL] except ImportError as ie : [EOL] [EOL] logger . warning ( [string] [string] , ie , ) [EOL] [EOL] class FileLock : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , lock_file , timeout = - [number] ) : [EOL] self . _lock_file = lock_file [EOL] self . timeout = timeout [EOL] [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] return None [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] open_lock = FileLock ( os . path . join ( tempfile . gettempdir ( ) , [string] ) ) [EOL] description_id = cycle ( range ( [number] , [number] ) ) [EOL] [EOL] [EOL] class ICSApiError ( CanError ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] ICS_SPY_ERR_CRITICAL = [number] [EOL] [comment] [EOL] ICS_SPY_ERR_QUESTION = [number] [EOL] [comment] [EOL] ICS_SPY_ERR_EXCLAMATION = [number] [EOL] [comment] [EOL] ICS_SPY_ERR_INFORMATION = [number] [EOL] [EOL] def __init__ ( self , error_number , description_short , description_long , severity , restart_needed , ) : [EOL] super ( ) . __init__ ( description_short ) [EOL] self . error_number = error_number [EOL] self . description_short = description_short [EOL] self . description_long = description_long [EOL] self . severity = severity [EOL] self . restart_needed = restart_needed == [number] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . description_short , self . description_long ) [EOL] [EOL] @ property def is_critical ( self ) : [EOL] return self . severity == self . ICS_SPY_ERR_CRITICAL [EOL] [EOL] [EOL] class NeoViBus ( BusABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , channel , can_filters = None , ** kwargs ) : [EOL] [docstring] [EOL] if ics is None : [EOL] raise ImportError ( [string] ) [EOL] [EOL] super ( ) . __init__ ( channel = channel , can_filters = can_filters , ** kwargs ) [EOL] [EOL] logger . info ( [string] . format ( can_filters ) ) [EOL] logger . info ( [string] . format ( kwargs ) ) [EOL] [EOL] if [string] in kwargs : [EOL] ics . override_library_name ( kwargs . get ( [string] ) ) [EOL] [EOL] if isinstance ( channel , ( list , tuple ) ) : [EOL] self . channels = channel [EOL] elif isinstance ( channel , int ) : [EOL] self . channels = [ channel ] [EOL] else : [EOL] [comment] [EOL] self . channels = [ ch . strip ( ) for ch in channel . split ( [string] ) ] [EOL] self . channels = [ NeoViBus . channel_to_netid ( ch ) for ch in self . channels ] [EOL] [EOL] type_filter = kwargs . get ( [string] ) [EOL] serial = kwargs . get ( [string] ) [EOL] self . dev = self . _find_device ( type_filter , serial ) [EOL] [EOL] with open_lock : [EOL] ics . open_device ( self . dev ) [EOL] [EOL] try : [EOL] if [string] in kwargs : [EOL] for channel in self . channels : [EOL] ics . set_bit_rate ( self . dev , kwargs . get ( [string] ) , channel ) [EOL] [EOL] if kwargs . get ( [string] , False ) : [EOL] if [string] in kwargs : [EOL] for channel in self . channels : [EOL] ics . set_fd_bit_rate ( self . dev , kwargs . get ( [string] ) , channel ) [EOL] except ics . RuntimeError as re : [EOL] logger . error ( re ) [EOL] err = ICSApiError ( * ics . get_last_api_error ( self . dev ) ) [EOL] try : [EOL] self . shutdown ( ) [EOL] finally : [EOL] raise err [EOL] [EOL] self . _use_system_timestamp = bool ( kwargs . get ( [string] , False ) ) [EOL] self . _receive_own_messages = kwargs . get ( [string] , True ) [EOL] [EOL] self . channel_info = [string] % ( self . dev . Name , self . get_serial_number ( self . dev ) , self . channels , ) [EOL] logger . info ( [string] . format ( self . channel_info ) ) [EOL] [EOL] self . rx_buffer = deque ( ) [EOL] self . message_receipts = defaultdict ( Event ) [EOL] [EOL] @ staticmethod def channel_to_netid ( channel_name_or_id ) : [EOL] try : [EOL] channel = int ( channel_name_or_id ) [EOL] except ValueError : [EOL] netid = [string] . format ( channel_name_or_id . upper ( ) ) [EOL] if hasattr ( ics , netid ) : [EOL] channel = getattr ( ics , netid ) [EOL] else : [EOL] raise ValueError ( [string] [string] ) [EOL] return channel [EOL] [EOL] @ staticmethod def get_serial_number ( device ) : [EOL] [docstring] [EOL] if int ( [string] , [number] ) < device . SerialNumber < int ( [string] , [number] ) : [EOL] return ics . base36enc ( device . SerialNumber ) [EOL] else : [EOL] return str ( device . SerialNumber ) [EOL] [EOL] def shutdown ( self ) : [EOL] super ( ) . shutdown ( ) [EOL] ics . close_device ( self . dev ) [EOL] [EOL] @ staticmethod def _detect_available_configs ( ) : [EOL] [docstring] [EOL] if ics is None : [EOL] return [ ] [EOL] [EOL] try : [EOL] devices = ics . find_devices ( ) [EOL] except Exception as e : [EOL] logger . debug ( [string] , e ) [EOL] return [ ] [EOL] [EOL] [comment] [EOL] return [ { [string] : [string] , [string] : NeoViBus . get_serial_number ( device ) } for device in devices ] [EOL] [EOL] def _find_device ( self , type_filter = None , serial = None ) : [EOL] if type_filter is not None : [EOL] devices = ics . find_devices ( type_filter ) [EOL] else : [EOL] devices = ics . find_devices ( ) [EOL] [EOL] for device in devices : [EOL] if serial is None or self . get_serial_number ( device ) == str ( serial ) : [EOL] dev = device [EOL] break [EOL] else : [EOL] msg = [ [string] ] [EOL] [EOL] if type_filter is not None : [EOL] msg . append ( [string] . format ( type_filter ) ) [EOL] if serial is not None : [EOL] msg . append ( [string] . format ( serial ) ) [EOL] msg . append ( [string] ) [EOL] raise Exception ( [string] . join ( msg ) ) [EOL] return dev [EOL] [EOL] def _process_msg_queue ( self , timeout = [number] ) : [EOL] try : [EOL] messages , errors = ics . get_messages ( self . dev , False , timeout ) [EOL] except ics . RuntimeError : [EOL] return [EOL] for ics_msg in messages : [EOL] if ics_msg . NetworkID not in self . channels : [EOL] continue [EOL] [EOL] is_tx = bool ( ics_msg . StatusBitField & ics . SPY_STATUS_TX_MSG ) [EOL] [EOL] if is_tx : [EOL] if bool ( ics_msg . StatusBitField & ics . SPY_STATUS_GLOBAL_ERR ) : [EOL] continue [EOL] if ics_msg . DescriptionID : [EOL] receipt_key = ( ics_msg . ArbIDOrHeader , ics_msg . DescriptionID ) [EOL] self . message_receipts [ receipt_key ] . set ( ) [EOL] if not self . _receive_own_messages : [EOL] continue [EOL] [EOL] self . rx_buffer . append ( ics_msg ) [EOL] if errors : [EOL] logger . warning ( [string] , errors ) [EOL] [EOL] for msg in ics . get_error_messages ( self . dev ) : [EOL] error = ICSApiError ( * msg ) [EOL] logger . warning ( error ) [EOL] [EOL] def _get_timestamp_for_msg ( self , ics_msg ) : [EOL] if self . _use_system_timestamp : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return ics_msg . TimeSystem [EOL] else : [EOL] [comment] [EOL] return ics . get_timestamp_for_msg ( self . dev , ics_msg ) [EOL] [EOL] def _ics_msg_to_message ( self , ics_msg ) : [EOL] is_fd = ics_msg . Protocol == ics . SPY_PROTOCOL_CANFD [EOL] [EOL] if is_fd : [EOL] if ics_msg . ExtraDataPtrEnabled : [EOL] data = ics_msg . ExtraDataPtr [ : ics_msg . NumberBytesData ] [EOL] else : [EOL] data = ics_msg . Data [ : ics_msg . NumberBytesData ] [EOL] [EOL] return Message ( timestamp = self . _get_timestamp_for_msg ( ics_msg ) , arbitration_id = ics_msg . ArbIDOrHeader , data = data , dlc = ics_msg . NumberBytesData , is_extended_id = bool ( ics_msg . StatusBitField & ics . SPY_STATUS_XTD_FRAME ) , is_fd = is_fd , is_rx = not bool ( ics_msg . StatusBitField & ics . SPY_STATUS_TX_MSG ) , is_remote_frame = bool ( ics_msg . StatusBitField & ics . SPY_STATUS_REMOTE_FRAME ) , error_state_indicator = bool ( ics_msg . StatusBitField3 & ics . SPY_STATUS3_CANFD_ESI ) , bitrate_switch = bool ( ics_msg . StatusBitField3 & ics . SPY_STATUS3_CANFD_BRS ) , channel = ics_msg . NetworkID , ) [EOL] else : [EOL] return Message ( timestamp = self . _get_timestamp_for_msg ( ics_msg ) , arbitration_id = ics_msg . ArbIDOrHeader , data = ics_msg . Data [ : ics_msg . NumberBytesData ] , dlc = ics_msg . NumberBytesData , is_extended_id = bool ( ics_msg . StatusBitField & ics . SPY_STATUS_XTD_FRAME ) , is_fd = is_fd , is_rx = not bool ( ics_msg . StatusBitField & ics . SPY_STATUS_TX_MSG ) , is_remote_frame = bool ( ics_msg . StatusBitField & ics . SPY_STATUS_REMOTE_FRAME ) , channel = ics_msg . NetworkID , ) [EOL] [EOL] def _recv_internal ( self , timeout = [number] ) : [EOL] if not self . rx_buffer : [EOL] self . _process_msg_queue ( timeout = timeout ) [EOL] try : [EOL] ics_msg = self . rx_buffer . popleft ( ) [EOL] msg = self . _ics_msg_to_message ( ics_msg ) [EOL] except IndexError : [EOL] return None , False [EOL] return msg , False [EOL] [EOL] def send ( self , msg , timeout = [number] ) : [EOL] [docstring] [EOL] if not ics . validate_hobject ( self . dev ) : [EOL] raise CanError ( [string] ) [EOL] message = ics . SpyMessage ( ) [EOL] [EOL] flag0 = [number] [EOL] if msg . is_extended_id : [EOL] flag0 |= ics . SPY_STATUS_XTD_FRAME [EOL] if msg . is_remote_frame : [EOL] flag0 |= ics . SPY_STATUS_REMOTE_FRAME [EOL] [EOL] flag3 = [number] [EOL] if msg . is_fd : [EOL] message . Protocol = ics . SPY_PROTOCOL_CANFD [EOL] if msg . bitrate_switch : [EOL] flag3 |= ics . SPY_STATUS3_CANFD_BRS [EOL] if msg . error_state_indicator : [EOL] flag3 |= ics . SPY_STATUS3_CANFD_ESI [EOL] [EOL] message . ArbIDOrHeader = msg . arbitration_id [EOL] msg_data = msg . data [EOL] message . NumberBytesData = len ( msg_data ) [EOL] message . Data = tuple ( msg_data [ : [number] ] ) [EOL] if msg . is_fd and len ( msg_data ) > [number] : [EOL] message . ExtraDataPtrEnabled = [number] [EOL] message . ExtraDataPtr = tuple ( msg_data ) [EOL] message . StatusBitField = flag0 [EOL] message . StatusBitField2 = [number] [EOL] message . StatusBitField3 = flag3 [EOL] if msg . channel is not None : [EOL] message . NetworkID = msg . channel [EOL] elif len ( self . channels ) == [number] : [EOL] message . NetworkID = self . channels [ [number] ] [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] msg_desc_id = next ( description_id ) [EOL] message . DescriptionID = msg_desc_id [EOL] receipt_key = ( msg . arbitration_id , msg_desc_id ) [EOL] [EOL] if timeout != [number] : [EOL] self . message_receipts [ receipt_key ] . clear ( ) [EOL] [EOL] try : [EOL] ics . transmit_messages ( self . dev , message ) [EOL] except ics . RuntimeError : [EOL] raise ICSApiError ( * ics . get_last_api_error ( self . dev ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if timeout != [number] and not self . message_receipts [ receipt_key ] . wait ( timeout ) : [EOL] raise CanError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $can.interfaces.ics_neovi.neovi_bus.FileLock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $can.interfaces.ics_neovi.neovi_bus.FileLock$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $can.interfaces.ics_neovi.neovi_bus.ICSApiError$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $can.interfaces.ics_neovi.neovi_bus.ICSApiError$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $None$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $can.interfaces.ics_neovi.neovi_bus.ICSApiError$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $can.interfaces.ics_neovi.neovi_bus.ICSApiError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $None$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $itertools.cycle[builtins.int]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Tuple[unknown,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from can . interfaces . ics_neovi . neovi_bus import NeoViBus [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import can [EOL] [docstring] [EOL] [EOL] from abc import ABCMeta [EOL] from typing import Optional , cast [EOL] [EOL] import can [EOL] import can . typechecking [EOL] [EOL] [EOL] class BaseIOHandler ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file , mode = [string] ) : [EOL] [docstring] [EOL] if file is None or ( hasattr ( file , [string] ) and hasattr ( file , [string] ) ) : [EOL] [comment] [EOL] self . file = cast ( Optional [ can . typechecking . FileLike ] , file ) [EOL] else : [EOL] [comment] [EOL] self . file = open ( cast ( can . typechecking . StringPathLike , file ) , mode ) [EOL] [EOL] [comment] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , * args ) : [EOL] self . stop ( ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] if self . file is not None : [EOL] [comment] [EOL] self . file . close ( ) [EOL] [EOL] [EOL] [comment] [EOL] class MessageWriter ( BaseIOHandler , can . Listener , metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] class MessageReader ( BaseIOHandler , metaclass = ABCMeta ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"BaseIOHandler"$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Optional [EOL] import threading [EOL] import can [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import time [EOL] import threading [EOL] import logging [EOL] import sqlite3 [EOL] [EOL] from can . listener import BufferedReader [EOL] from can . message import Message [EOL] from . generic import BaseIOHandler [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class SqliteReader ( BaseIOHandler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file , table_name = [string] ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( file = None ) [EOL] self . _conn = sqlite3 . connect ( file ) [EOL] self . _cursor = self . _conn . cursor ( ) [EOL] self . table_name = table_name [EOL] [EOL] def __iter__ ( self ) : [EOL] for frame_data in self . _cursor . execute ( [string] . format ( self . table_name ) ) : [EOL] yield SqliteReader . _assemble_message ( frame_data ) [EOL] [EOL] @ staticmethod def _assemble_message ( frame_data ) : [EOL] timestamp , can_id , is_extended , is_remote , is_error , dlc , data = frame_data [EOL] return Message ( timestamp = timestamp , is_remote_frame = bool ( is_remote ) , is_extended_id = bool ( is_extended ) , is_error_frame = bool ( is_error ) , arbitration_id = can_id , dlc = dlc , data = data , ) [EOL] [EOL] def __len__ ( self ) : [EOL] [comment] [EOL] result = self . _cursor . execute ( [string] . format ( self . table_name ) ) [EOL] return int ( result . fetchone ( ) [ [number] ] ) [EOL] [EOL] def read_all ( self ) : [EOL] [docstring] [EOL] result = self . _cursor . execute ( [string] . format ( self . table_name ) ) . fetchall ( ) [EOL] return ( SqliteReader . _assemble_message ( frame ) for frame in result ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] super ( ) . stop ( ) [EOL] self . _conn . close ( ) [EOL] [EOL] [EOL] class SqliteWriter ( BaseIOHandler , BufferedReader ) : [EOL] [docstring] [EOL] [EOL] GET_MESSAGE_TIMEOUT = [number] [EOL] [docstring] [EOL] [EOL] MAX_TIME_BETWEEN_WRITES = [number] [EOL] [docstring] [EOL] [EOL] MAX_BUFFER_SIZE_BEFORE_WRITES = [number] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file , table_name = [string] ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( file = None ) [EOL] self . table_name = table_name [EOL] self . _db_filename = file [EOL] self . _stop_running_event = threading . Event ( ) [EOL] self . _conn = None [EOL] self . _writer_thread = threading . Thread ( target = self . _db_writer_thread ) [EOL] self . _writer_thread . start ( ) [EOL] self . num_frames = [number] [EOL] self . last_write = time . time ( ) [EOL] self . _insert_template = ( f" [string] { self . table_name } [string] " ) [EOL] [EOL] def _create_db ( self ) : [EOL] [docstring] [EOL] log . debug ( [string] ) [EOL] self . _conn = sqlite3 . connect ( self . _db_filename ) [EOL] [EOL] [comment] [EOL] self . _conn . cursor ( ) . execute ( [string] . format ( self . table_name ) ) [EOL] self . _conn . commit ( ) [EOL] [EOL] def _db_writer_thread ( self ) : [EOL] self . _create_db ( ) [EOL] [EOL] try : [EOL] while True : [EOL] messages = [ ] [comment] [EOL] [EOL] msg = self . get_message ( self . GET_MESSAGE_TIMEOUT ) [EOL] while msg is not None : [EOL] [comment] [EOL] [EOL] messages . append ( ( msg . timestamp , msg . arbitration_id , msg . is_extended_id , msg . is_remote_frame , msg . is_error_frame , msg . dlc , memoryview ( msg . data ) , ) ) [EOL] [EOL] if ( time . time ( ) - self . last_write > self . MAX_TIME_BETWEEN_WRITES or len ( messages ) > self . MAX_BUFFER_SIZE_BEFORE_WRITES ) : [EOL] break [EOL] else : [EOL] [comment] [EOL] msg = self . get_message ( self . GET_MESSAGE_TIMEOUT ) [EOL] [EOL] count = len ( messages ) [EOL] if count > [number] : [EOL] with self . _conn : [EOL] [comment] [EOL] self . _conn . executemany ( self . _insert_template , messages ) [EOL] self . _conn . commit ( ) [comment] [EOL] self . num_frames += count [EOL] self . last_write = time . time ( ) [EOL] [EOL] [comment] [EOL] if self . _stop_running_event . is_set ( ) : [EOL] break [EOL] [EOL] finally : [EOL] self . _conn . close ( ) [EOL] log . info ( [string] , self . num_frames ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] BufferedReader . stop ( self ) [EOL] self . _stop_running_event . set ( ) [EOL] self . _writer_thread . join ( ) [EOL] BaseIOHandler . stop ( self ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[can.message.Message]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Union [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [EOL] from base64 import b64encode , b64decode [EOL] [EOL] from can . message import Message [EOL] from can . listener import Listener [EOL] from . generic import BaseIOHandler [EOL] [EOL] [EOL] class CSVWriter ( BaseIOHandler , Listener ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file , append = False ) : [EOL] [docstring] [EOL] mode = [string] if append else [string] [EOL] super ( ) . __init__ ( file , mode = mode ) [EOL] [EOL] [comment] [EOL] if not append : [EOL] self . file . write ( [string] ) [EOL] [EOL] def on_message_received ( self , msg ) : [EOL] row = [string] . join ( [ repr ( msg . timestamp ) , hex ( msg . arbitration_id ) , [string] if msg . is_extended_id else [string] , [string] if msg . is_remote_frame else [string] , [string] if msg . is_error_frame else [string] , str ( msg . dlc ) , b64encode ( msg . data ) . decode ( [string] ) , ] ) [EOL] self . file . write ( row ) [EOL] self . file . write ( [string] ) [EOL] [EOL] [EOL] class CSVReader ( BaseIOHandler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( file , mode = [string] ) [EOL] [EOL] def __iter__ ( self ) : [EOL] [comment] [EOL] try : [EOL] next ( self . file ) [EOL] except StopIteration : [EOL] [comment] [EOL] return [EOL] [EOL] for line in self . file : [EOL] [EOL] timestamp , arbitration_id , extended , remote , error , dlc , data = line . split ( [string] ) [EOL] [EOL] yield Message ( timestamp = float ( timestamp ) , is_remote_frame = ( remote == [string] ) , is_extended_id = ( extended == [string] ) , is_error_frame = ( error == [string] ) , arbitration_id = int ( arbitration_id , base = [number] ) , dlc = int ( dlc ) , data = b64decode ( data ) , ) [EOL] [EOL] self . stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Iterable , Any , Type [EOL] import builtins [EOL] import can [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pathlib [EOL] from time import time , sleep [EOL] import typing [EOL] [EOL] from pkg_resources import iter_entry_points [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] import can [EOL] [EOL] from . generic import BaseIOHandler [EOL] from . asc import ASCReader [EOL] from . blf import BLFReader [EOL] from . canutils import CanutilsLogReader [EOL] from . csv import CSVReader [EOL] from . sqlite import SqliteReader [EOL] [EOL] [EOL] class LogReader ( BaseIOHandler ) : [EOL] [docstring] [EOL] [EOL] fetched_plugins = False [EOL] message_readers = { [string] : ASCReader , [string] : BLFReader , [string] : CSVReader , [string] : SqliteReader , [string] : CanutilsLogReader , } [EOL] [EOL] @ staticmethod def __new__ ( cls , filename , * args , ** kwargs ) : [EOL] [docstring] [EOL] if not LogReader . fetched_plugins : [EOL] LogReader . message_readers . update ( { reader . name : reader . load ( ) for reader in iter_entry_points ( [string] ) } ) [EOL] LogReader . fetched_plugins = True [EOL] [EOL] suffix = pathlib . PurePath ( filename ) . suffix . lower ( ) [EOL] try : [EOL] return LogReader . message_readers [ suffix ] ( filename , * args , ** kwargs ) [EOL] except KeyError : [EOL] raise ValueError ( f' [string] { suffix } [string] ' ) from None [EOL] [EOL] [EOL] class MessageSync : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , messages , timestamps = True , gap = [number] , skip = [number] , ) : [EOL] [docstring] [EOL] self . raw_messages = messages [EOL] self . timestamps = timestamps [EOL] self . gap = gap [EOL] self . skip = skip [EOL] [EOL] def __iter__ ( self ) : [EOL] playback_start_time = time ( ) [EOL] recorded_start_time = None [EOL] [EOL] for message in self . raw_messages : [EOL] [EOL] [comment] [EOL] if self . timestamps : [EOL] if recorded_start_time is None : [EOL] recorded_start_time = message . timestamp [EOL] [EOL] now = time ( ) [EOL] current_offset = now - playback_start_time [EOL] recorded_offset_from_start = message . timestamp - recorded_start_time [EOL] remaining_gap = max ( [number] , recorded_offset_from_start - current_offset ) [EOL] [EOL] sleep_period = max ( self . gap , min ( self . skip , remaining_gap ) ) [EOL] else : [EOL] sleep_period = self . gap [EOL] [EOL] sleep ( sleep_period ) [EOL] [EOL] yield message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable["can.Message"]$ 0 $builtins.bool$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable["can.Message"]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Generator["can.Message",None,None]$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0
from typing import Literal , Union [EOL] import typing_extensions [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] from can . listener import Listener [EOL] from . generic import BaseIOHandler [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class Printer ( BaseIOHandler , Listener ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file = None , append = False ) : [EOL] [docstring] [EOL] self . write_to_file = file is not None [EOL] mode = [string] if append else [string] [EOL] super ( ) . __init__ ( file , mode = mode ) [EOL] [EOL] def on_message_received ( self , msg ) : [EOL] if self . write_to_file : [EOL] self . file . write ( str ( msg ) + [string] ) [EOL] else : [EOL] print ( msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0