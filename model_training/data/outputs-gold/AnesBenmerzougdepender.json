import pathlib [EOL] from pathlib import Path [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] install_requires = open ( [string] ) . read ( ) [EOL] [EOL] [EOL] HERE = Path ( __file__ ) . parent [EOL] [EOL] README = ( HERE / [string] ) . read_text ( ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] [string] , long_description = README , long_description_content_type = [string] , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , ] , url = [string] , author = [string] , author_email = [string] , install_requires = install_requires , include_package_data = True , packages = find_packages ( exclude = [ [string] , [string] ] ) , entry_points = { [string] : [ [string] ] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import depender [EOL] from depender . graph . structure import StructureGraph [EOL] [EOL] [EOL] def test_structure_layout ( graph ) : [EOL] graph . layout ( base_distance_x = [number] , base_distance_y = [number] ) [EOL] [comment] [EOL] assert graph . nodes [ [string] ] [ [string] ] == [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == [number] [EOL] [comment] [EOL] assert graph . nodes [ [string] ] [ [string] ] == [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph . nodes [ [string] ] [ [string] ] == - [number] [EOL] [EOL] [EOL] def test_structure_layout_with_label ( graph_with_labels ) : [EOL] graph_with_labels . layout ( base_distance_x = [number] , base_distance_y = [number] ) [EOL] [comment] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == [number] [EOL] [comment] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL] assert graph_with_labels . nodes [ [string] ] [ [string] ] == - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import depender [EOL] import pytest [EOL] from depender . graph . structure import StructureGraph [EOL] [EOL] [EOL] @ pytest . fixture def graph ( ) : [EOL] [docstring] [EOL] graph = StructureGraph ( ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] return graph [EOL] [EOL] [EOL] @ pytest . fixture def graph_with_labels ( ) : [EOL] [docstring] [EOL] graph = StructureGraph ( ) [EOL] [comment] [EOL] graph . add_node ( [string] , width = [number] ) [EOL] graph . add_node ( [string] , width = [number] ) [EOL] graph . add_node ( [string] , width = [number] ) [EOL] graph . add_node ( [string] , width = [number] ) [EOL] graph . add_node ( [string] , width = [number] ) [EOL] graph . add_node ( [string] , width = [number] ) [EOL] graph . add_node ( [string] , width = [number] ) [EOL] graph . add_node ( [string] , width = [number] ) [EOL] [comment] [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] graph . add_edge ( [string] , [string] ) [EOL] return graph [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $depender.graph.structure.StructureGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $depender.graph.structure.StructureGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Union , Dict [EOL] import pathlib [EOL] import typing [EOL] import depender [EOL] import builtins [EOL] import sys [EOL] from importlib . util import find_spec [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] import click [EOL] from click_spinner import spinner [comment] [EOL] from depender . backend import get_backend [EOL] from depender . parse . code import CodeParser [EOL] from depender . parse . structure import StructureParser [EOL] [EOL] CONTEXT_SETTINGS = dict ( help_option_names = [ [string] , [string] ] , ignore_unknown_options = True ) [EOL] [EOL] [EOL] @ click . command ( context_settings = CONTEXT_SETTINGS ) @ click . argument ( [string] , nargs = [number] ) @ click . argument ( [string] , nargs = - [number] , type = click . Path ( exists = False , file_okay = False , resolve_path = False ) , ) @ click . option ( [string] , [string] , type = click . Path ( exists = False , dir_okay = True , resolve_path = True ) , default = [string] , show_default = True , help = [string] , ) @ click . option ( [string] , [string] , type = click . STRING , default = None , show_default = True , help = [string] [string] , ) @ click . option ( [string] , type = click . Choice ( [ [string] , [string] ] ) , default = [string] , show_default = True , help = [string] , ) @ click . option ( [string] , [string] , type = click . STRING , default = [string] , show_default = True , help = [string] , ) @ click . option ( [string] , type = click . BOOL , default = False , is_flag = True , show_default = True , help = [string] , ) @ click . option ( [string] , type = click . BOOL , default = False , is_flag = True , show_default = True , help = [string] , ) @ click . option ( [string] , type = click . INT , default = [number] , show_default = True , help = [string] , ) @ click . version_option ( ) def main ( path_or_name , excluded_dirs , output_dir , format , backend , image_dimensions , include_external , no_follow_links , depth , ) : [EOL] [docstring] [EOL] try : [EOL] spec = find_spec ( path_or_name ) [EOL] except ModuleNotFoundError : [EOL] spec = None [EOL] [comment] [EOL] package_path = Path ( path_or_name ) [EOL] if package_path . is_file ( ) and package_path . suffix == [string] : [EOL] click . echo ( f" [string] { package_path . absolute ( ) } [string] " ) [EOL] is_module = True [EOL] elif package_path . is_dir ( ) and package_path . joinpath ( [string] ) . is_file ( ) : [EOL] click . echo ( f" [string] { package_path . absolute ( ) } [string] " ) [EOL] is_module = False [EOL] elif spec is not None : [EOL] package_path = Path ( spec . origin ) [EOL] if package_path . name == [string] : [EOL] click . echo ( f" [string] { path_or_name } [string] " ) [EOL] package_path = package_path . parent [EOL] is_module = False [EOL] else : [EOL] click . echo ( f" [string] { path_or_name } [string] " ) [EOL] is_module = True [EOL] else : [EOL] click . echo ( f" [string] { package_path } [string] " ) [EOL] sys . exit ( [number] ) [EOL] [comment] [EOL] image_width , image_height = map ( int , image_dimensions . split ( [string] ) ) [EOL] [comment] [EOL] code_parser = CodeParser ( ) [EOL] structure_parser = StructureParser ( ) [EOL] [comment] [EOL] backend = get_backend ( backend ) ( output_dir = output_dir , format = format , figure_dimensions = ( image_width , image_height ) , ) [EOL] click . echo ( [string] ) [EOL] with spinner ( ) : [EOL] code_graph = code_parser . parse_project ( package_path = package_path , is_module = is_module , excluded_directories = excluded_dirs , include_external = include_external , follow_links = not no_follow_links , ) [EOL] structure_graph = structure_parser . parse_project ( package_path = package_path , excluded_directories = excluded_dirs , follow_links = not no_follow_links , depth = depth , ) [EOL] [comment] [EOL] click . echo ( [string] ) [EOL] with spinner ( ) : [EOL] backend . plot_dependency_matrix ( code_graph ) [EOL] backend . plot_dependency_graph ( code_graph ) [EOL] backend . plot_structure_graph ( structure_graph ) [EOL] click . echo ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def get_backend ( name ) : [EOL] if name == [string] : [EOL] from . matplotlib import MatplotlibBackend [EOL] [EOL] return MatplotlibBackend [EOL] elif name == [string] : [EOL] from . graphviz import GraphivizBackend [EOL] [EOL] return GraphivizBackend [EOL] else : [EOL] raise ValueError ( [string] . format ( name ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import io [EOL] import depender [EOL] from io import BytesIO [EOL] [EOL] import graphviz [EOL] import matplotlib . image as mpimg [EOL] import matplotlib . pyplot as plt [EOL] from depender . backend . base import BaseBackend [EOL] from depender . graph import DependencyGraph , StructureGraph [EOL] from matplotlib . colors import to_hex [EOL] [EOL] [EOL] class GraphivizBackend ( BaseBackend ) : [EOL] def plot ( self , * args , ** kwargs ) : [EOL] dot = args [ [number] ] [EOL] dot_str = graphviz . pipe ( engine = [string] , format = [string] , data = dot . source . encode ( ) ) [EOL] [comment] [EOL] sio = BytesIO ( ) [EOL] sio . write ( dot_str ) [EOL] sio . seek ( [number] ) [EOL] fig , ax = plt . subplots ( figsize = ( self . figure_dimensions [ [number] ] / self . dpi , self . figure_dimensions [ [number] ] / self . dpi , ) , dpi = self . dpi , ) [EOL] ax . axis ( [string] ) [EOL] img = mpimg . imread ( sio ) [EOL] [comment] [EOL] ax . imshow ( img , aspect = [string] ) [EOL] fig . tight_layout ( ) [EOL] plt . show ( ) [EOL] [EOL] def save_to_file ( self , * args , ** kwargs ) : [EOL] dot = args [ [number] ] [EOL] filename = kwargs . pop ( [string] , [string] ) [EOL] dot . render ( engine = [string] , format = self . format , filepath = self . output_dir / filename ) [EOL] [EOL] def plot_dependency_matrix ( self , graph , ** kwargs ) : [EOL] graph . layout ( matrix = True ) [EOL] table = self . _create_dependency_table ( graph ) [EOL] dot = graphviz . Graph ( name = [string] ) [EOL] dot . graph_attr [ [string] ] = str ( self . dpi ) [EOL] dot . node ( [string] , shape = [string] , label = table ) [EOL] if self . format is None : [EOL] self . plot ( dot ) [EOL] else : [EOL] self . save_to_file ( dot , filename = [string] ) [EOL] [EOL] def plot_dependency_graph ( self , graph , ** kwargs ) : [EOL] graph . layout ( graph = True ) [EOL] dot = graphviz . Digraph ( name = [string] ) [EOL] dot . graph_attr [ [string] ] = str ( self . dpi ) [EOL] degrees = { node : graph . out_degree ( node ) - graph . in_degree ( node ) for node in graph . nodes } [EOL] min_degree , max_degree = min ( degrees . values ( ) ) , max ( degrees . values ( ) ) [EOL] cmap = plt . get_cmap ( [string] ) [EOL] for node , degree in degrees . items ( ) : [EOL] color = cmap ( ( degree - min_degree ) * cmap . N // ( max_degree - min_degree ) ) [EOL] color = ( * color [ : [number] ] , [number] ) [EOL] color = to_hex ( color , keep_alpha = True ) [EOL] dot . node ( node , fillcolor = color , style = [string] ) [EOL] for edge in graph . edges : [EOL] dot . edge ( * edge ) [EOL] if self . format is None : [EOL] self . plot ( dot ) [EOL] else : [EOL] self . save_to_file ( dot , filename = [string] ) [EOL] [EOL] def plot_structure_graph ( self , graph , ** kwargs ) : [EOL] dot = graphviz . Digraph ( name = [string] ) [EOL] dot . graph_attr [ [string] ] = [string] [EOL] dot . graph_attr [ [string] ] = [string] [EOL] cmap = plt . get_cmap ( [string] ) [EOL] for node , attrs in graph . nodes . items ( ) : [EOL] if attrs [ [string] ] == [string] : [EOL] color = cmap ( [number] ) [EOL] shape = [string] [EOL] elif attrs [ [string] ] == [string] : [EOL] color = cmap ( [number] ) [EOL] shape = [string] [EOL] else : [EOL] color = cmap ( [number] ) [EOL] shape = [string] [EOL] color = ( * color [ : [number] ] , [number] ) [EOL] color = to_hex ( color , keep_alpha = True ) [EOL] dot . node ( node , label = attrs [ [string] ] , shape = shape , fillcolor = color , style = [string] ) [EOL] for edge in graph . edges : [EOL] dot . edge ( * edge ) [EOL] if self . format is None : [EOL] self . plot ( dot ) [EOL] else : [EOL] self . save_to_file ( dot , filename = [string] ) [EOL] [EOL] def _create_dependency_table ( self , graph ) : [EOL] node_names = list ( graph . nodes ) [EOL] node_count = graph . number_of_nodes ( ) [EOL] matrix = [ [ [number] for _ in range ( node_count ) ] for _ in range ( node_count ) ] [EOL] max_count = [number] [EOL] for ( source , sink , values ) in graph . edges . data ( ) : [EOL] matrix [ graph . nodes [ source ] [ [string] ] ] [ graph . nodes [ sink ] [ [string] ] ] = values [ [string] ] [EOL] max_count = max ( max_count , values [ [string] ] ) [EOL] max_count = max ( max_count , [number] ) [EOL] table = list ( ) [EOL] table . append ( [string] ) [EOL] header_str = [string] [EOL] for name in node_names : [EOL] header_str += [string] . format ( name ) [EOL] header_str += [string] [EOL] table . append ( header_str ) [EOL] cmap = plt . get_cmap ( [string] ) [EOL] for i , row in enumerate ( matrix ) : [EOL] row_str = [string] . format ( node_names [ i ] ) [EOL] for count in row : [EOL] color = cmap ( count * cmap . N // max_count ) [EOL] color = ( * color [ : [number] ] , [number] ) [EOL] color = to_hex ( color , keep_alpha = True ) [EOL] row_str += [string] . format ( color , count ) [EOL] row_str += [string] [EOL] table . append ( row_str ) [EOL] table . append ( [string] ) [EOL] return [string] . join ( table ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 $io.BytesIO$ 0 0 0 $typing.Any$ 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $depender.graph.DependencyGraph$ 0 0 0 0 0 0 $depender.graph.DependencyGraph$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $depender.graph.DependencyGraph$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $depender.graph.DependencyGraph$ 0 0 0 0 0 0 $depender.graph.DependencyGraph$ 0 0 0 $depender.graph.DependencyGraph$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $depender.graph.DependencyGraph$ 0 0 0 0 0 0 $depender.graph.DependencyGraph$ 0 0 0 0 0 0 0 0 $depender.graph.DependencyGraph$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $depender.graph.DependencyGraph$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $depender.graph.StructureGraph$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $depender.graph.StructureGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $depender.graph.StructureGraph$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0
from typing import Optional , Union , Tuple [EOL] import pathlib [EOL] import typing [EOL] import depender [EOL] import builtins [EOL] from abc import ABC , abstractmethod [EOL] from pathlib import Path [EOL] from typing import Optional , Tuple , Union [EOL] [EOL] from depender . graph . dependency import DependencyGraph [EOL] from depender . graph . structure import StructureGraph [EOL] [EOL] [EOL] class BaseBackend ( ABC ) : [EOL] def __init__ ( self , output_dir , format = None , figure_dimensions = ( [number] , [number] ) , dpi = [number] , ) : [EOL] self . output_dir = Path ( output_dir ) [EOL] self . format = format [EOL] self . figure_dimensions = figure_dimensions [EOL] self . dpi = dpi [EOL] [EOL] @ abstractmethod def plot ( self , * args , ** kwargs ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def save_to_file ( self , * args , ** kwargs ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def plot_dependency_matrix ( self , graph , ** kwargs ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def plot_dependency_graph ( self , graph , ** kwargs ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def plot_structure_graph ( self , graph , ** kwargs ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $depender.graph.dependency.DependencyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $depender.graph.dependency.DependencyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $depender.graph.structure.StructureGraph$ 0 0 0 0 0 0 0 0 0
from . dependency import DependencyGraph [comment] [EOL] from . structure import StructureGraph [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union , Dict , Any [EOL] import typing [EOL] import builtins [EOL] from networkx import DiGraph [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class StructureGraph ( DiGraph ) : [EOL] def add_node ( self , node_for_adding , ** attr ) : [EOL] properties = { } [EOL] [comment] [EOL] if node_for_adding not in self . nodes : [EOL] properties = { [string] : [ ] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] properties . update ( ** attr ) [EOL] super ( ) . add_node ( node_for_adding , ** properties ) [EOL] [EOL] def add_nodes_from ( self , nodes_for_adding , ** attr ) : [EOL] super ( ) . add_nodes_from ( nodes_for_adding , ** attr ) [EOL] [comment] [EOL] for node_for_adding in nodes_for_adding : [EOL] self . add_node ( node_for_adding , ** attr ) [EOL] [EOL] def add_edge ( self , source , sink , ** kwargs ) : [EOL] self . add_node ( source ) [EOL] self . add_node ( sink ) [EOL] super ( ) . add_edge ( source , sink , ** kwargs ) [EOL] [comment] [EOL] self . nodes [ source ] [ [string] ] += [ sink ] [EOL] self . nodes [ sink ] [ [string] ] = source [EOL] self . nodes [ sink ] [ [string] ] = sink [EOL] self . nodes [ sink ] [ [string] ] = len ( list ( self . successors ( source ) ) ) [EOL] [comment] [EOL] if len ( list ( self . successors ( source ) ) ) > [number] : [EOL] self . nodes [ sink ] [ [string] ] = next ( iter ( self . successors ( source ) ) ) [EOL] self . nodes [ sink ] [ [string] ] = list ( self . successors ( source ) ) [ - [number] ] [EOL] [EOL] @ property def root_node ( self ) : [EOL] if not self . nodes : [EOL] raise AttributeError ( [string] ) [EOL] return next ( iter ( self . nodes ) ) [EOL] [EOL] def layout ( self , ** kwargs ) : [EOL] base_distance_x = kwargs . pop ( [string] , [number] ) [EOL] base_distance_y = kwargs . pop ( [string] , [number] ) [EOL] root_node = self . root_node [EOL] if root_node is not None : [EOL] self . _first_walk ( root_node , base_distance = base_distance_x ) [EOL] self . _second_walk ( root_node , - self . nodes [ root_node ] [ [string] ] , base_distance = base_distance_y ) [EOL] [EOL] def _first_walk ( self , current_node , base_distance = [number] ) : [EOL] [comment] [EOL] children = self . nodes [ current_node ] [ [string] ] [EOL] children_count = len ( children ) [EOL] if children_count == [number] : [EOL] left_sibling = self . nodes [ current_node ] . get ( [string] , None ) [EOL] if left_sibling : [EOL] self . nodes [ current_node ] [ [string] ] = ( self . nodes [ left_sibling ] [ [string] ] + ( self . nodes [ left_sibling ] [ [string] ] + self . nodes [ current_node ] [ [string] ] ) / [number] + base_distance ) [EOL] else : [EOL] self . nodes [ current_node ] [ [string] ] = [number] [EOL] else : [EOL] [comment] [EOL] default_ancestor = children [ [number] ] [EOL] for child in children : [EOL] self . _first_walk ( child , base_distance ) [EOL] default_ancestor = self . _apportion ( child , default_ancestor , base_distance ) [EOL] [EOL] self . _execute_shifts ( current_node ) [EOL] [comment] [EOL] if len ( children ) % [number] == [number] : [EOL] midpoint = ( self . nodes [ children [ [number] ] ] [ [string] ] + self . nodes [ children [ - [number] ] ] [ [string] ] ) / [number] [EOL] else : [EOL] midpoint = self . nodes [ children [ len ( children ) // [number] ] ] [ [string] ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] left_sibling = self . nodes [ current_node ] . get ( [string] , None ) [EOL] if left_sibling : [EOL] self . nodes [ current_node ] [ [string] ] = ( self . nodes [ left_sibling ] [ [string] ] + ( self . nodes [ left_sibling ] [ [string] ] + self . nodes [ current_node ] [ [string] ] ) / [number] + base_distance ) [EOL] self . nodes [ current_node ] [ [string] ] = ( self . nodes [ current_node ] [ [string] ] - midpoint ) [EOL] else : [EOL] self . nodes [ current_node ] [ [string] ] = midpoint [EOL] [EOL] def _second_walk ( self , current_node , modifier = [number] , depth = [number] , base_distance = [number] , ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] self . nodes [ current_node ] [ [string] ] += modifier [EOL] modifier += self . nodes [ current_node ] [ [string] ] [EOL] [comment] [EOL] self . nodes [ current_node ] [ [string] ] = - depth * ( self . nodes [ current_node ] [ [string] ] + base_distance ) [EOL] for child in self . nodes [ current_node ] [ [string] ] : [EOL] self . _second_walk ( child , modifier , depth + [number] , base_distance ) [EOL] [EOL] def _apportion ( self , current_node , default_ancestor , base_distance ) : [EOL] [docstring] [EOL] left_sibling = self . nodes [ current_node ] [ [string] ] [EOL] leftmost_sibling = self . nodes [ current_node ] [ [string] ] [EOL] if left_sibling is not None and leftmost_sibling is not None : [EOL] v_inner_right = v_outer_right = current_node [EOL] v_inner_left = left_sibling [EOL] v_outer_left = leftmost_sibling [EOL] sir = self . nodes [ v_inner_right ] [ [string] ] [EOL] sor = self . nodes [ v_outer_right ] [ [string] ] [EOL] sil = self . nodes [ v_inner_left ] [ [string] ] [EOL] sol = self . nodes [ v_outer_left ] [ [string] ] [EOL] [comment] [EOL] next_inner_left = self . _next_right ( v_inner_left ) [EOL] next_inner_right = self . _next_left ( v_inner_right ) [EOL] next_outer_left = self . _next_left ( v_outer_left ) [EOL] next_outer_right = self . _next_right ( v_outer_right ) [EOL] while ( next_inner_left [EOL] and next_inner_right [EOL] and next_outer_right [EOL] and next_outer_left ) : [EOL] v_inner_left = next_inner_left [EOL] v_inner_right = next_inner_right [EOL] v_outer_left = next_outer_left [EOL] v_outer_right = next_outer_right [EOL] self . nodes [ v_outer_right ] [ [string] ] = current_node [EOL] [comment] [EOL] shift = ( ( self . nodes [ v_inner_left ] [ [string] ] + sil ) - ( self . nodes [ v_inner_right ] [ [string] ] + sir ) + ( self . nodes [ v_inner_left ] [ [string] ] + self . nodes [ v_inner_right ] [ [string] ] ) / [number] + base_distance ) [EOL] if shift > [number] : [EOL] a = self . _ancestor ( v_inner_left , current_node , default_ancestor ) [EOL] self . _move_subtree ( a , current_node , shift ) [EOL] sir = sir + shift [EOL] sor = sor + shift [EOL] sil += self . nodes [ v_inner_left ] [ [string] ] [EOL] sir += self . nodes [ v_inner_right ] [ [string] ] [EOL] sol += self . nodes [ v_outer_left ] [ [string] ] [EOL] sor += self . nodes [ v_outer_right ] [ [string] ] [EOL] [comment] [EOL] next_inner_left = self . _next_right ( v_inner_left ) [EOL] next_inner_right = self . _next_left ( v_inner_right ) [EOL] next_outer_left = self . _next_left ( v_outer_left ) [EOL] next_outer_right = self . _next_right ( v_outer_right ) [EOL] if self . _next_right ( v_inner_left ) and not self . _next_right ( v_outer_right ) : [EOL] self . nodes [ v_outer_right ] [ [string] ] = self . _next_right ( v_inner_left ) [EOL] self . nodes [ v_outer_right ] [ [string] ] += sil - sor [EOL] if self . _next_left ( v_inner_right ) and not self . _next_left ( v_outer_left ) : [EOL] self . nodes [ v_outer_left ] [ [string] ] = self . _next_left ( v_inner_right ) [EOL] self . nodes [ v_outer_left ] [ [string] ] += sir - sol [EOL] default_ancestor = current_node [EOL] return default_ancestor [EOL] [EOL] def _move_subtree ( self , left_ancestor , right_ancestor , shift ) : [EOL] [docstring] [EOL] num_subtrees_between_ancestors = ( self . nodes [ right_ancestor ] [ [string] ] - self . nodes [ left_ancestor ] [ [string] ] ) [EOL] self . nodes [ right_ancestor ] [ [string] ] -= shift / num_subtrees_between_ancestors [EOL] self . nodes [ right_ancestor ] [ [string] ] += shift [EOL] self . nodes [ left_ancestor ] [ [string] ] += shift / num_subtrees_between_ancestors [EOL] self . nodes [ right_ancestor ] [ [string] ] += shift [EOL] self . nodes [ right_ancestor ] [ [string] ] += shift [EOL] [EOL] def _execute_shifts ( self , node ) : [EOL] shift = change = [number] [comment] [EOL] for child in list ( reversed ( self . nodes [ node ] [ [string] ] ) ) : [EOL] self . nodes [ child ] [ [string] ] += shift [EOL] self . nodes [ child ] [ [string] ] += shift [EOL] change += self . nodes [ child ] [ [string] ] [EOL] shift += self . nodes [ child ] [ [string] ] + change [EOL] [EOL] def _next_left ( self , node ) : [EOL] [docstring] [EOL] children = self . nodes [ node ] [ [string] ] [EOL] thread = self . nodes [ node ] [ [string] ] [EOL] if children : [EOL] return children [ [number] ] [EOL] else : [EOL] return thread [EOL] [EOL] def _next_right ( self , node ) : [EOL] [docstring] [EOL] children = self . nodes [ node ] [ [string] ] [EOL] thread = self . nodes [ node ] [ [string] ] [EOL] if children : [EOL] return children [ - [number] ] [EOL] else : [EOL] return thread [EOL] [EOL] def _ancestor ( self , node_1 , node_2 , default_ancestor ) : [EOL] [docstring] [EOL] node_1_ancestor = self . nodes [ node_1 ] [ [string] ] [EOL] node_2_parent = self . nodes [ node_2 ] [ [string] ] [EOL] if node_1_ancestor and node_2_parent : [EOL] if node_1_ancestor in self . nodes [ node_2_parent ] [ [string] ] : [EOL] return node_1_ancestor [EOL] return default_ancestor [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import warnings [EOL] [EOL] from networkx import DiGraph , NetworkXException , planar_layout [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class DependencyGraph ( DiGraph ) : [EOL] def layout ( self , ** kwargs ) : [EOL] matrix = kwargs . pop ( [string] , False ) [EOL] graph = kwargs . pop ( [string] , False ) [EOL] if matrix : [EOL] for i , node in enumerate ( self ) : [EOL] self . nodes [ node ] [ [string] ] = i [EOL] for ( source , sink , _ ) in self . edges . data ( ) : [EOL] if [string] not in self . edges [ ( source , sink ) ] : [EOL] self . edges [ ( source , sink ) ] [ [string] ] = [number] [EOL] self . edges [ ( source , sink ) ] [ [string] ] += [number] [EOL] if graph : [EOL] try : [EOL] with warnings . catch_warnings ( ) : [EOL] warnings . simplefilter ( [string] ) [EOL] positions = planar_layout ( self ) [EOL] for node , pos in positions . items ( ) : [EOL] self . nodes [ node ] [ [string] ] = pos [EOL] except NetworkXException : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List , Union , Any [EOL] import ast [EOL] import _ast [EOL] import depender [EOL] import builtins [EOL] import pathlib [EOL] import typing [EOL] import ast [EOL] import importlib [EOL] import importlib . util [EOL] from pathlib import Path [EOL] from typing import List , Union [EOL] [EOL] from depender . graph . dependency import DependencyGraph [EOL] [EOL] [EOL] class CodeParser : [EOL] def __init__ ( self ) : [EOL] self . graph = DependencyGraph ( ) [EOL] [EOL] def parse_project ( self , package_path , is_module , excluded_directories , include_external = True , parse_importlib = True , follow_links = True , ) : [EOL] if isinstance ( package_path , str ) : [EOL] package_path = Path ( package_path ) . resolve ( ) [EOL] [comment] [EOL] excluded_directories = list ( map ( lambda x : package_path . joinpath ( x ) . resolve ( ) , excluded_directories ) ) [EOL] [EOL] package_name = package_path . stem [EOL] [EOL] if is_module : [EOL] file_list = [ ( package_path , package_name ) ] [EOL] else : [EOL] [comment] [EOL] file_list = self . find_all_package_modules ( package_path , excluded_directories , self . graph ) [EOL] [comment] [EOL] for filepath , module_dot_path in file_list : [EOL] self . parse_file ( filepath , module_dot_path , package_name , include_external , parse_importlib , ) [EOL] return self . graph [EOL] [EOL] def find_all_package_modules ( self , package_path , excluded_directories , graph , ) : [EOL] file_list = list ( ) [EOL] for file in package_path . rglob ( [string] ) : [EOL] [comment] [EOL] if [string] in file . name : [EOL] continue [EOL] relative_path = file . relative_to ( package_path . parent ) . with_suffix ( [string] ) [EOL] module_dot_path = [string] . join ( relative_path . parts ) [EOL] file_list . append ( ( file , module_dot_path ) ) [EOL] graph . add_node ( module_dot_path , label = module_dot_path ) [EOL] return file_list [EOL] [EOL] def parse_file ( self , filepath , module_dot_path , package_name , include_external , parse_importlib , ) : [EOL] with filepath . open ( [string] ) as f : [EOL] module_tree = ast . parse ( f . read ( ) ) [EOL] for node in ast . walk ( module_tree ) : [EOL] if isinstance ( node , ast . Import ) : [EOL] self . parse_first_form_import ( import_node = node , importing_module = module_dot_path , package_name = package_name , include_external = include_external , ) [EOL] [EOL] elif isinstance ( node , ast . ImportFrom ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if node . module is None : [EOL] self . parse_first_form_import ( import_node = node , importing_module = module_dot_path , package_name = package_name , include_external = include_external , ) [EOL] else : [EOL] self . parse_second_form_import ( import_node = node , importing_module = module_dot_path , package_name = package_name , include_external = include_external , ) [EOL] [EOL] elif isinstance ( node , ast . Call ) and parse_importlib : [EOL] if ( isinstance ( node . func , ast . Name ) [EOL] and node . func . id == [string] ) : [EOL] try : [EOL] import_node = str ( ast . literal_eval ( node . args [ [number] ] ) ) [EOL] package = [string] [EOL] if node . keywords and node . keywords [ [number] ] . arg : [EOL] package = node . keywords [ [number] ] . arg [EOL] self . parse_importlib_import ( import_node = import_node , package = package , importing_module = module_dot_path , include_external = include_external , ) [EOL] except ValueError : [EOL] pass [EOL] elif isinstance ( node . func , ast . Attribute ) and isinstance ( node . func . value , ast . Name ) : [EOL] if ( node . func . value . id == [string] [EOL] and node . func . attr == [string] ) : [EOL] try : [EOL] import_node = str ( ast . literal_eval ( node . args [ [number] ] ) ) [EOL] package = [string] [EOL] if node . keywords and node . keywords [ [number] ] . arg : [EOL] package = node . keywords [ [number] ] . arg [EOL] self . parse_importlib_import ( import_node = import_node , package = package , importing_module = module_dot_path , include_external = include_external , ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] def parse_first_form_import ( self , import_node , package_name , importing_module , include_external , ) : [EOL] for alias in import_node . names : [EOL] imported_module = importlib . util . resolve_name ( alias . name , package_name ) [EOL] [EOL] [comment] [EOL] if self . graph . has_node ( imported_module ) : [EOL] self . graph . add_node ( imported_module , label = imported_module ) [EOL] self . graph . add_edge ( importing_module , imported_module ) [EOL] [EOL] [comment] [EOL] elif include_external is True : [EOL] package = imported_module . split ( [string] ) [ [number] ] [EOL] self . graph . add_node ( package , label = package + [string] ) [EOL] self . graph . add_edge ( importing_module , package ) [EOL] [EOL] def parse_second_form_import ( self , import_node , package_name , importing_module , include_external , ) : [EOL] imported_from_module = importlib . util . resolve_name ( import_node . module , package_name ) [comment] [EOL] [EOL] [comment] [EOL] if self . graph . has_node ( imported_from_module ) : [EOL] self . graph . add_node ( imported_from_module , label = imported_from_module ) [EOL] self . graph . add_edge ( importing_module , imported_from_module ) [EOL] else : [EOL] for imported_module in import_node . names : [EOL] module_dot_path = [string] . join ( [ imported_from_module , imported_module . name ] ) [EOL] if self . graph . has_node ( module_dot_path ) : [EOL] self . graph . add_node ( module_dot_path , label = module_dot_path ) [EOL] self . graph . add_edge ( importing_module , module_dot_path ) [EOL] if include_external : [EOL] package = imported_from_module . split ( [string] ) [ [number] ] [EOL] self . graph . add_node ( package , label = package ) [EOL] self . graph . add_edge ( importing_module , package ) [EOL] [EOL] def parse_importlib_import ( self , import_node , package , importing_module , include_external , ) : [EOL] imported_module = importlib . util . resolve_name ( import_node , package ) [EOL] [EOL] [comment] [EOL] if self . graph . has_node ( imported_module ) : [EOL] self . graph . add_node ( imported_module , label = imported_module ) [EOL] self . graph . add_edge ( importing_module , imported_module ) [EOL] [EOL] [comment] [EOL] elif include_external is True : [EOL] package = imported_module . split ( [string] ) [ [number] ] [EOL] self . graph . add_node ( package , label = package + [string] ) [EOL] self . graph . add_edge ( importing_module , package ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0
	0
from typing import List , Union [EOL] import pathlib [EOL] import typing [EOL] import depender [EOL] import builtins [EOL] from pathlib import Path [EOL] from typing import List , Union [EOL] [EOL] from depender . graph import StructureGraph [EOL] from depender . parse . utilities import traverse_directory [EOL] [EOL] [EOL] class StructureParser : [EOL] def __init__ ( self ) : [EOL] self . graph = StructureGraph ( ) [EOL] [EOL] def parse_project ( self , package_path , excluded_directories , follow_links = True , depth = [number] , ) : [EOL] if isinstance ( package_path , str ) : [EOL] package_path = Path ( package_path ) [EOL] [comment] [EOL] excluded_directories = list ( map ( lambda x : package_path . joinpath ( x ) . resolve ( ) , excluded_directories ) ) [EOL] for root , dirs , files in traverse_directory ( package_path , excluded_directories , depth = depth , followlinks = follow_links ) : [EOL] [EOL] if not self . graph . has_node ( str ( root ) ) : [EOL] self . graph . add_node ( str ( root ) , label = root . name , type = [string] ) [EOL] [EOL] for i , element in enumerate ( dirs + files ) : [EOL] if [string] == element . name : [EOL] continue [EOL] if [string] == element . suffix : [EOL] continue [EOL] [EOL] [comment] [EOL] full_path = root / element [EOL] [EOL] if full_path . is_file ( ) : [EOL] self . graph . add_node ( str ( full_path ) , label = full_path . name , type = [string] ) [EOL] else : [EOL] self . graph . add_node ( str ( full_path ) , label = full_path . name , type = [string] ) [EOL] [EOL] [comment] [EOL] self . graph . add_edge ( str ( root ) , str ( full_path ) ) [EOL] return self . graph [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $depender.graph.StructureGraph$ 0 0 0 $pathlib.Path$ 0 $typing.List[typing.Union[pathlib.Path,builtins.str]]$ 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 $typing.List[typing.Union[pathlib.Path,builtins.str]]$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[pathlib.Path,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $typing.List[typing.Union[pathlib.Path,builtins.str]]$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0
from typing import Iterable , List , Tuple , Any [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from pathlib import Path [EOL] from typing import Iterable , List , Tuple [EOL] [EOL] [EOL] def traverse_directory ( directory , excluded_directories , depth , followlinks , breadth_first = False , ) : [EOL] root_depth = len ( directory . parents ) [EOL] dirlist = list ( ) [EOL] [EOL] for root , dirs , files in os . walk ( directory . resolve ( ) , followlinks = followlinks ) : [EOL] root = Path ( root ) . resolve ( ) [EOL] [comment] [EOL] if check_if_skip_directory ( root , excluded_directories ) : [EOL] continue [EOL] [comment] [EOL] current_depth = len ( root . parents ) - root_depth [EOL] if current_depth > depth >= [number] : [EOL] continue [EOL] [comment] [EOL] dirs = list ( map ( lambda dir : Path ( dir ) , dirs ) ) [EOL] files = list ( map ( lambda file : Path ( file ) , files ) ) [EOL] [comment] [EOL] dirs = skip_hidden_directories ( dirs ) [EOL] dirlist . append ( ( root , dirs , files ) ) [EOL] [comment] [EOL] if breadth_first : [EOL] dirlist = sorted ( dirlist , key = lambda x : len ( x [ [number] ] . parents ) ) [EOL] for root , dirs , files in dirlist : [EOL] yield root , dirs , files [EOL] [EOL] [EOL] def check_if_skip_directory ( directory , excluded_directories ) : [EOL] if directory in excluded_directories or [string] in directory . name : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def skip_hidden_directories ( directories ) : [EOL] for directory in directories [ : ] : [EOL] if str ( directory ) [ [number] ] == [string] : [EOL] directories . remove ( directory ) [EOL] return directories [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[pathlib.Path,typing.List[pathlib.Path],typing.List[pathlib.Path]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0