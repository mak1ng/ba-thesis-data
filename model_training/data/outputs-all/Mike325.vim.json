[comment] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import os [EOL] import sys [EOL] import logging [EOL] import ycm_core [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] libDirs = [ [string] , [string] , ] [EOL] [EOL] flags = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] LINUX_INCLUDES = [ [string] , [string] ] [EOL] [EOL] WINDOWS_INCLUDES = [ ] [EOL] [EOL] SOURCE_EXTENSIONS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] SOURCE_DIRECTORIES = [ [string] , ] [EOL] [EOL] HEADER_EXTENSIONS = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] flags += WINDOWS_INCLUDES if os . name == [string] else LINUX_INCLUDES [EOL] [EOL] database = None [EOL] compilation_database_folder = [string] [EOL] [EOL] [comment] [EOL] if os . path . exists ( compilation_database_folder ) : [EOL] database = ycm_core . CompilationDatabase ( compilation_database_folder ) [EOL] else : [EOL] database = None [EOL] [EOL] [EOL] def DirectoryOfThisScript ( ) : [EOL] return os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] [EOL] [EOL] def MakeRelativePathsInFlagsAbsolute ( flags , working_directory ) : [EOL] if not working_directory : [EOL] return list ( flags ) [EOL] [EOL] new_flags = [ ] [EOL] make_next_absolute = False [EOL] path_flags = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] for libDir in libDirs : [EOL] [EOL] [comment] [EOL] if libDir . startswith ( [string] ) : [EOL] libDir = os . path . expanduser ( libDir ) [EOL] [EOL] [comment] [EOL] if not libDir . startswith ( [string] ) : [EOL] libDir = os . path . join ( working_directory , libDir ) [EOL] [EOL] [comment] [EOL] [EOL] for path , dirs , files in os . walk ( libDir ) : [EOL] [comment] [EOL] [comment] [EOL] if any ( IsHeaderFile ( x ) for x in files ) and path . find ( [string] ) == - [number] and path . find ( [string] ) == - [number] : [EOL] logger . info ( [string] % path ) [EOL] flags . append ( [string] + path ) [EOL] [EOL] for flag in flags : [EOL] new_flag = flag [EOL] [EOL] if make_next_absolute : [EOL] make_next_absolute = False [EOL] if not flag . startswith ( [string] ) : [EOL] new_flag = os . path . join ( working_directory , flag ) [EOL] [EOL] for path_flag in path_flags : [EOL] if flag == path_flag : [EOL] make_next_absolute = True [EOL] break [EOL] [EOL] if flag . startswith ( path_flag ) : [EOL] path = flag [ len ( path_flag ) : ] [EOL] new_flag = path_flag + os . path . join ( working_directory , path ) [EOL] break [EOL] [EOL] if new_flag : [EOL] new_flags . append ( new_flag ) [EOL] return new_flags [EOL] [EOL] [EOL] def NormalizePath ( path ) : [EOL] return path if os . name != [string] else path . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def IsHeaderFile ( filename ) : [EOL] extension = os . path . splitext ( filename ) [ [number] ] [EOL] return extension in HEADER_EXTENSIONS [EOL] [EOL] [EOL] def GetCompilationInfoForFile ( filename ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if IsHeaderFile ( filename ) : [EOL] basename = os . path . splitext ( filename ) [ [number] ] [EOL] for extension in SOURCE_EXTENSIONS : [EOL] replacement_file = basename + extension [EOL] if os . path . exists ( replacement_file ) : [EOL] compilation_info = database . GetCompilationInfoForFile ( replacement_file ) [EOL] if compilation_info . compiler_flags_ : [EOL] return compilation_info [EOL] return None [EOL] return database . GetCompilationInfoForFile ( filename ) [EOL] [EOL] [EOL] def PathToPythonUsedDuringBuild ( ) : [EOL] try : [EOL] filepath = os . path . join ( DirectoryOfThisScript ( ) , [string] ) [EOL] with open ( filepath ) as f : [EOL] return f . read ( ) . strip ( ) [EOL] [comment] [EOL] except ( IOError , OSError ) : [EOL] return sys . executable [EOL] [EOL] [EOL] def Settings ( ** kwargs ) : [EOL] [EOL] language = kwargs [ [string] ] [EOL] filename = kwargs [ [string] ] [EOL] client_data = None if [string] not in kwargs else kwargs [ [string] ] [EOL] [EOL] if language == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if database : [EOL] [comment] [EOL] [comment] [EOL] compilation_info = GetCompilationInfoForFile ( filename ) [EOL] [EOL] if not compilation_info : [EOL] return None [EOL] [EOL] final_flags = compilation_info . compiler_flags_ [EOL] relative_to = compilation_info . compiler_working_dir_ [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] relative_to = DirectoryOfThisScript ( ) [EOL] final_flags = flags [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return { [string] : final_flags , [string] : relative_to , [string] : filename , [string] : True , } [EOL] [EOL] if language == [string] : [EOL] if client_data is not None and [string] in client_data : [EOL] pypath = client_data [ [string] ] [EOL] else : [EOL] pypath = PathToPythonUsedDuringBuild ( ) [EOL] [EOL] logger . info ( [string] . format ( pypath ) ) [EOL] [EOL] return { [string] : pypath } [EOL] [EOL] return { } [EOL] [EOL] [EOL] def FlagsForFile ( filename , ** kwargs ) : [EOL] [docstring] [EOL] settings = kwargs [EOL] settings [ [string] ] = filename [EOL] [EOL] if [string] not in settings : [EOL] settings [ [string] ] = [string] [EOL] [EOL] extension = os . path . splitext ( settings [ [string] ] ) [ [number] ] [EOL] [EOL] if extension in SOURCE_EXTENSIONS or extension in HEADER_EXTENSIONS : [EOL] settings [ [string] ] = [string] [EOL] elif extension == [string] : [EOL] settings [ [string] ] = [string] [EOL] [EOL] return Settings ( ** settings ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import argparse [EOL] from __future__ import print_function [EOL] from __future__ import division [EOL] from __future__ import unicode_literals [EOL] from __future__ import with_statement [EOL] [EOL] import argparse [EOL] import logging [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __header__ = [string] [EOL] [EOL] _version = [string] [EOL] _author = [string] [EOL] _mail = [string] [EOL] [EOL] [EOL] def _parseArgs ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , default = [string] , type = str , help = [string] ) [EOL] [EOL] return parser . parse_args ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] args = _parseArgs ( ) [EOL] [EOL] if args . show_version : [EOL] print ( _version ) [EOL] return [number] [EOL] [EOL] if args . logging : [EOL] try : [EOL] level = int ( args . logging ) [EOL] except Exception : [EOL] if args . logging . lower ( ) == [string] : [EOL] level = logging . DEBUG [EOL] elif args . logging . lower ( ) == [string] : [EOL] level = logging . INFO [EOL] elif args . logging . lower ( ) == [string] or args . logging . lower ( ) == [string] : [EOL] level = logging . WARN [EOL] elif args . logging . lower ( ) == [string] : [EOL] level = logging . ERROR [EOL] elif args . logging . lower ( ) == [string] : [EOL] level = logging . CRITICAL [EOL] else : [EOL] level = [number] [EOL] [EOL] logging . basicConfig ( level = level , format = [string] ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] else : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import os [EOL] import sys [EOL] import logging [EOL] import ycm_core [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] libDirs = [ [string] , [string] , ] [EOL] [EOL] flags = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] LINUX_INCLUDES = [ [string] , [string] ] [EOL] [EOL] WINDOWS_INCLUDES = [ ] [EOL] [EOL] SOURCE_EXTENSIONS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] SOURCE_DIRECTORIES = [ [string] , ] [EOL] [EOL] HEADER_EXTENSIONS = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] flags += WINDOWS_INCLUDES if os . name == [string] else LINUX_INCLUDES [EOL] [EOL] database = None [EOL] compilation_database_folder = [string] [EOL] [EOL] [comment] [EOL] if os . path . exists ( compilation_database_folder ) : [EOL] database = ycm_core . CompilationDatabase ( compilation_database_folder ) [EOL] else : [EOL] database = None [EOL] [EOL] [EOL] def DirectoryOfThisScript ( ) : [EOL] return os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] [EOL] [EOL] def MakeRelativePathsInFlagsAbsolute ( flags , working_directory ) : [EOL] if not working_directory : [EOL] return list ( flags ) [EOL] [EOL] new_flags = [ ] [EOL] make_next_absolute = False [EOL] path_flags = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] for libDir in libDirs : [EOL] [EOL] [comment] [EOL] if libDir . startswith ( [string] ) : [EOL] libDir = os . path . expanduser ( libDir ) [EOL] [EOL] [comment] [EOL] if not libDir . startswith ( [string] ) : [EOL] libDir = os . path . join ( working_directory , libDir ) [EOL] [EOL] [comment] [EOL] [EOL] for path , dirs , files in os . walk ( libDir ) : [EOL] [comment] [EOL] [comment] [EOL] if any ( IsHeaderFile ( x ) for x in files ) and path . find ( [string] ) == - [number] and path . find ( [string] ) == - [number] : [EOL] logger . info ( [string] % path ) [EOL] flags . append ( [string] + path ) [EOL] [EOL] for flag in flags : [EOL] new_flag = flag [EOL] [EOL] if make_next_absolute : [EOL] make_next_absolute = False [EOL] if not flag . startswith ( [string] ) : [EOL] new_flag = os . path . join ( working_directory , flag ) [EOL] [EOL] for path_flag in path_flags : [EOL] if flag == path_flag : [EOL] make_next_absolute = True [EOL] break [EOL] [EOL] if flag . startswith ( path_flag ) : [EOL] path = flag [ len ( path_flag ) : ] [EOL] new_flag = path_flag + os . path . join ( working_directory , path ) [EOL] break [EOL] [EOL] if new_flag : [EOL] new_flags . append ( new_flag ) [EOL] return new_flags [EOL] [EOL] [EOL] def NormalizePath ( path ) : [EOL] return path if os . name != [string] else path . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def IsHeaderFile ( filename ) : [EOL] extension = os . path . splitext ( filename ) [ [number] ] [EOL] return extension in HEADER_EXTENSIONS [EOL] [EOL] [EOL] def GetCompilationInfoForFile ( filename ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if IsHeaderFile ( filename ) : [EOL] basename = os . path . splitext ( filename ) [ [number] ] [EOL] for extension in SOURCE_EXTENSIONS : [EOL] replacement_file = basename + extension [EOL] if os . path . exists ( replacement_file ) : [EOL] compilation_info = database . GetCompilationInfoForFile ( replacement_file ) [EOL] if compilation_info . compiler_flags_ : [EOL] return compilation_info [EOL] return None [EOL] return database . GetCompilationInfoForFile ( filename ) [EOL] [EOL] [EOL] def PathToPythonUsedDuringBuild ( ) : [EOL] try : [EOL] filepath = os . path . join ( DirectoryOfThisScript ( ) , [string] ) [EOL] with open ( filepath ) as f : [EOL] return f . read ( ) . strip ( ) [EOL] [comment] [EOL] except ( IOError , OSError ) : [EOL] return sys . executable [EOL] [EOL] [EOL] def Settings ( ** kwargs ) : [EOL] [EOL] language = kwargs [ [string] ] [EOL] filename = kwargs [ [string] ] [EOL] client_data = None if [string] not in kwargs else kwargs [ [string] ] [EOL] [EOL] if language == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if database : [EOL] [comment] [EOL] [comment] [EOL] compilation_info = GetCompilationInfoForFile ( filename ) [EOL] [EOL] if not compilation_info : [EOL] return None [EOL] [EOL] final_flags = compilation_info . compiler_flags_ [EOL] relative_to = compilation_info . compiler_working_dir_ [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] relative_to = DirectoryOfThisScript ( ) [EOL] final_flags = flags [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return { [string] : final_flags , [string] : relative_to , [string] : filename , [string] : True , } [EOL] [EOL] if language == [string] : [EOL] if client_data is not None and [string] in client_data : [EOL] pypath = client_data [ [string] ] [EOL] else : [EOL] pypath = PathToPythonUsedDuringBuild ( ) [EOL] [EOL] logger . info ( [string] . format ( pypath ) ) [EOL] [EOL] return { [string] : pypath } [EOL] [EOL] return { } [EOL] [EOL] [EOL] def FlagsForFile ( filename , ** kwargs ) : [EOL] [docstring] [EOL] settings = kwargs [EOL] settings [ [string] ] = filename [EOL] [EOL] if [string] not in settings : [EOL] settings [ [string] ] = [string] [EOL] [EOL] extension = os . path . splitext ( settings [ [string] ] ) [ [number] ] [EOL] [EOL] if extension in SOURCE_EXTENSIONS or extension in HEADER_EXTENSIONS : [EOL] settings [ [string] ] = [string] [EOL] elif extension == [string] : [EOL] settings [ [string] ] = [string] [EOL] [EOL] return Settings ( ** settings ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0