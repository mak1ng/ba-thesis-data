[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Type , Any , Optional , Union , Awaitable [EOL] import typing [EOL] import types [EOL] import datetime [EOL] import builtins [EOL] import collections [EOL] import datetime [EOL] import types [EOL] [EOL] from tornado import gen , ioloop [EOL] from tornado . concurrent import Future , future_set_result_unless_cancelled [EOL] [EOL] from typing import Union , Optional , Type , Any , Awaitable [EOL] import typing [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] from typing import Deque , Set [comment] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class _TimeoutGarbageCollector ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _waiters = collections . deque ( ) [comment] [EOL] self . _timeouts = [number] [EOL] [EOL] def _garbage_collect ( self ) : [EOL] [comment] [EOL] self . _timeouts += [number] [EOL] if self . _timeouts > [number] : [EOL] self . _timeouts = [number] [EOL] self . _waiters = collections . deque ( w for w in self . _waiters if not w . done ( ) ) [EOL] [EOL] [EOL] class Condition ( _TimeoutGarbageCollector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . io_loop = ioloop . IOLoop . current ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] result = [string] % ( self . __class__ . __name__ , ) [EOL] if self . _waiters : [EOL] result += [string] % len ( self . _waiters ) [EOL] return result + [string] [EOL] [EOL] def wait ( self , timeout = None ) : [EOL] [docstring] [EOL] waiter = Future ( ) [comment] [EOL] self . _waiters . append ( waiter ) [EOL] if timeout : [EOL] [EOL] def on_timeout ( ) : [EOL] if not waiter . done ( ) : [EOL] future_set_result_unless_cancelled ( waiter , False ) [EOL] self . _garbage_collect ( ) [EOL] [EOL] io_loop = ioloop . IOLoop . current ( ) [EOL] timeout_handle = io_loop . add_timeout ( timeout , on_timeout ) [EOL] waiter . add_done_callback ( lambda _ : io_loop . remove_timeout ( timeout_handle ) ) [EOL] return waiter [EOL] [EOL] def notify ( self , n = [number] ) : [EOL] [docstring] [EOL] waiters = [ ] [comment] [EOL] while n and self . _waiters : [EOL] waiter = self . _waiters . popleft ( ) [EOL] if not waiter . done ( ) : [comment] [EOL] n -= [number] [EOL] waiters . append ( waiter ) [EOL] [EOL] for waiter in waiters : [EOL] future_set_result_unless_cancelled ( waiter , True ) [EOL] [EOL] def notify_all ( self ) : [EOL] [docstring] [EOL] self . notify ( len ( self . _waiters ) ) [EOL] [EOL] [EOL] class Event ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _value = False [EOL] self . _waiters = set ( ) [comment] [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , [string] if self . is_set ( ) else [string] , ) [EOL] [EOL] def is_set ( self ) : [EOL] [docstring] [EOL] return self . _value [EOL] [EOL] def set ( self ) : [EOL] [docstring] [EOL] if not self . _value : [EOL] self . _value = True [EOL] [EOL] for fut in self . _waiters : [EOL] if not fut . done ( ) : [EOL] fut . set_result ( None ) [EOL] [EOL] def clear ( self ) : [EOL] [docstring] [EOL] self . _value = False [EOL] [EOL] def wait ( self , timeout = None ) : [EOL] [docstring] [EOL] fut = Future ( ) [comment] [EOL] if self . _value : [EOL] fut . set_result ( None ) [EOL] return fut [EOL] self . _waiters . add ( fut ) [EOL] fut . add_done_callback ( lambda fut : self . _waiters . remove ( fut ) ) [EOL] if timeout is None : [EOL] return fut [EOL] else : [EOL] timeout_fut = gen . with_timeout ( timeout , fut ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] timeout_fut . add_done_callback ( lambda tf : fut . cancel ( ) if not fut . done ( ) else None ) [EOL] return timeout_fut [EOL] [EOL] [EOL] class _ReleasingContextManager ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , obj ) : [EOL] self . _obj = obj [EOL] [EOL] def __enter__ ( self ) : [EOL] pass [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb , ) : [EOL] self . _obj . release ( ) [EOL] [EOL] [EOL] class Semaphore ( _TimeoutGarbageCollector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value = [number] ) : [EOL] super ( ) . __init__ ( ) [EOL] if value < [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . _value = value [EOL] [EOL] def __repr__ ( self ) : [EOL] res = super ( ) . __repr__ ( ) [EOL] extra = ( [string] if self . _value == [number] else [string] . format ( self . _value ) ) [EOL] if self . _waiters : [EOL] extra = [string] . format ( extra , len ( self . _waiters ) ) [EOL] return [string] . format ( res [ [number] : - [number] ] , extra ) [EOL] [EOL] def release ( self ) : [EOL] [docstring] [EOL] self . _value += [number] [EOL] while self . _waiters : [EOL] waiter = self . _waiters . popleft ( ) [EOL] if not waiter . done ( ) : [EOL] self . _value -= [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] waiter . set_result ( _ReleasingContextManager ( self ) ) [EOL] break [EOL] [EOL] def acquire ( self , timeout = None ) : [EOL] [docstring] [EOL] waiter = Future ( ) [comment] [EOL] if self . _value > [number] : [EOL] self . _value -= [number] [EOL] waiter . set_result ( _ReleasingContextManager ( self ) ) [EOL] else : [EOL] self . _waiters . append ( waiter ) [EOL] if timeout : [EOL] [EOL] def on_timeout ( ) : [EOL] if not waiter . done ( ) : [EOL] waiter . set_exception ( gen . TimeoutError ( ) ) [EOL] self . _garbage_collect ( ) [EOL] [EOL] io_loop = ioloop . IOLoop . current ( ) [EOL] timeout_handle = io_loop . add_timeout ( timeout , on_timeout ) [EOL] waiter . add_done_callback ( lambda _ : io_loop . remove_timeout ( timeout_handle ) ) [EOL] return waiter [EOL] [EOL] def __enter__ ( self ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] def __exit__ ( self , typ , value , traceback , ) : [EOL] self . __enter__ ( ) [EOL] [EOL] async def __aenter__ ( self ) : [EOL] await self . acquire ( ) [EOL] [EOL] async def __aexit__ ( self , typ , value , tb , ) : [EOL] self . release ( ) [EOL] [EOL] [EOL] class BoundedSemaphore ( Semaphore ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value = [number] ) : [EOL] super ( ) . __init__ ( value = value ) [EOL] self . _initial_value = value [EOL] [EOL] def release ( self ) : [EOL] [docstring] [EOL] if self . _value >= self . _initial_value : [EOL] raise ValueError ( [string] ) [EOL] super ( ) . release ( ) [EOL] [EOL] [EOL] class Lock ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _block = BoundedSemaphore ( value = [number] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . _block ) [EOL] [EOL] def acquire ( self , timeout = None ) : [EOL] [docstring] [EOL] return self . _block . acquire ( timeout ) [EOL] [EOL] def release ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _block . release ( ) [EOL] except ValueError : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] def __enter__ ( self ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] def __exit__ ( self , typ , value , tb , ) : [EOL] self . __enter__ ( ) [EOL] [EOL] async def __aenter__ ( self ) : [EOL] await self . acquire ( ) [EOL] [EOL] async def __aexit__ ( self , typ , value , tb , ) : [EOL] self . release ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[builtins.bool]$ 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[None]$ 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $"Optional[Type[BaseException]]"$ 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Optional[types.TracebackType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[_ReleasingContextManager]$ 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $"Optional[Type[BaseException]]"$ 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Optional[types.TracebackType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $"Optional[Type[BaseException]]"$ 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Optional[types.TracebackType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[_ReleasingContextManager]$ 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.float,datetime.timedelta]]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $"Optional[Type[BaseException]]"$ 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Optional[types.TracebackType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $"Optional[Type[BaseException]]"$ 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Optional[types.TracebackType]$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = [string] [EOL] version_info = ( [number] , [number] , [number] , - [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import subprocess [EOL] import os [EOL] import shutil [EOL] import subprocess [EOL] from subprocess import Popen [EOL] import sys [EOL] from tempfile import mkdtemp [EOL] import time [EOL] import unittest [EOL] [EOL] [EOL] class AutoreloadTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . path = mkdtemp ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] try : [EOL] shutil . rmtree ( self . path ) [EOL] except OSError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] shutil . rmtree ( self . path ) [EOL] [EOL] def test_reload_module ( self ) : [EOL] main = [string] [EOL] [EOL] [comment] [EOL] os . mkdir ( os . path . join ( self . path , [string] ) ) [EOL] open ( os . path . join ( self . path , [string] ) , [string] ) . close ( ) [EOL] with open ( os . path . join ( self . path , [string] ) , [string] ) as f : [EOL] f . write ( main ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] pythonpath = os . getcwd ( ) [EOL] if [string] in os . environ : [EOL] pythonpath += os . pathsep + os . environ [ [string] ] [EOL] [EOL] p = Popen ( [ sys . executable , [string] , [string] ] , stdout = subprocess . PIPE , cwd = self . path , env = dict ( os . environ , PYTHONPATH = pythonpath ) , universal_newlines = True , ) [EOL] out = p . communicate ( ) [ [number] ] [EOL] self . assertEqual ( out , [string] ) [EOL] [EOL] def test_reload_wrapper_preservation ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] main = [string] [EOL] [EOL] [comment] [EOL] os . mkdir ( os . path . join ( self . path , [string] ) ) [EOL] init_file = os . path . join ( self . path , [string] , [string] ) [EOL] open ( init_file , [string] ) . close ( ) [EOL] main_file = os . path . join ( self . path , [string] , [string] ) [EOL] with open ( main_file , [string] ) as f : [EOL] f . write ( main ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] pythonpath = os . getcwd ( ) [EOL] if [string] in os . environ : [EOL] pythonpath += os . pathsep + os . environ [ [string] ] [EOL] [EOL] autoreload_proc = Popen ( [ sys . executable , [string] , [string] , [string] , [string] ] , stdout = subprocess . PIPE , cwd = self . path , env = dict ( os . environ , PYTHONPATH = pythonpath ) , universal_newlines = True , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] if autoreload_proc . poll ( ) is not None : [EOL] break [EOL] time . sleep ( [number] ) [EOL] else : [EOL] autoreload_proc . kill ( ) [EOL] raise Exception ( [string] ) [EOL] [EOL] out = autoreload_proc . communicate ( ) [ [number] ] [EOL] self . assertEqual ( out , [string] * [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
import tornado [EOL] from tornado . ioloop import IOLoop [EOL] from tornado . netutil import ThreadedResolver [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] resolver = ThreadedResolver ( ) [EOL] IOLoop . current ( ) . run_sync ( lambda : resolver . resolve ( [string] , [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.netutil.ThreadedResolver$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.netutil.ThreadedResolver$ 0 0 0 0 0 0 0 0 0
import asyncio [EOL] import sys [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if sys . platform == [string] and hasattr ( asyncio , [string] ) : [EOL] asyncio . set_event_loop_policy ( asyncio . WindowsSelectorEventLoopPolicy ( ) ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from tornado . test . runtests import all , main [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] all = all [EOL] [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Type , Any , Optional , Union , TypeVar , Awaitable [EOL] import tornado [EOL] import concurrent [EOL] import builtins [EOL] import typing [EOL] import asyncio [EOL] [docstring] [EOL] [EOL] import concurrent . futures [EOL] import functools [EOL] import sys [EOL] [EOL] from threading import get_ident [EOL] from tornado . gen import convert_yielded [EOL] from tornado . ioloop import IOLoop , _Selectable [EOL] [EOL] import asyncio [EOL] [EOL] import typing [EOL] from typing import Any , TypeVar , Awaitable , Callable , Union , Optional [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] from typing import Set , Dict , Tuple [comment] [EOL] [EOL] _T = TypeVar ( [string] ) [EOL] [EOL] [EOL] class BaseAsyncIOLoop ( IOLoop ) : [EOL] def initialize ( self , asyncio_loop , ** kwargs ) : [EOL] self . asyncio_loop = asyncio_loop [EOL] [comment] [EOL] self . handlers = { } [comment] [EOL] [comment] [EOL] self . readers = set ( ) [comment] [EOL] self . writers = set ( ) [comment] [EOL] self . closing = False [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for loop in list ( IOLoop . _ioloop_for_asyncio ) : [EOL] if loop . is_closed ( ) : [EOL] del IOLoop . _ioloop_for_asyncio [ loop ] [EOL] IOLoop . _ioloop_for_asyncio [ asyncio_loop ] = self [EOL] [EOL] self . _thread_identity = [number] [EOL] [EOL] super ( ) . initialize ( ** kwargs ) [EOL] [EOL] def assign_thread_identity ( ) : [EOL] self . _thread_identity = get_ident ( ) [EOL] [EOL] self . add_callback ( assign_thread_identity ) [EOL] [EOL] def close ( self , all_fds = False ) : [EOL] self . closing = True [EOL] for fd in list ( self . handlers ) : [EOL] fileobj , handler_func = self . handlers [ fd ] [EOL] self . remove_handler ( fd ) [EOL] if all_fds : [EOL] self . close_fd ( fileobj ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] del IOLoop . _ioloop_for_asyncio [ self . asyncio_loop ] [EOL] self . asyncio_loop . close ( ) [EOL] [EOL] def add_handler ( self , fd , handler , events ) : [EOL] fd , fileobj = self . split_fd ( fd ) [EOL] if fd in self . handlers : [EOL] raise ValueError ( [string] % fd ) [EOL] self . handlers [ fd ] = ( fileobj , handler ) [EOL] if events & IOLoop . READ : [EOL] self . asyncio_loop . add_reader ( fd , self . _handle_events , fd , IOLoop . READ ) [EOL] self . readers . add ( fd ) [EOL] if events & IOLoop . WRITE : [EOL] self . asyncio_loop . add_writer ( fd , self . _handle_events , fd , IOLoop . WRITE ) [EOL] self . writers . add ( fd ) [EOL] [EOL] def update_handler ( self , fd , events ) : [EOL] fd , fileobj = self . split_fd ( fd ) [EOL] if events & IOLoop . READ : [EOL] if fd not in self . readers : [EOL] self . asyncio_loop . add_reader ( fd , self . _handle_events , fd , IOLoop . READ ) [EOL] self . readers . add ( fd ) [EOL] else : [EOL] if fd in self . readers : [EOL] self . asyncio_loop . remove_reader ( fd ) [EOL] self . readers . remove ( fd ) [EOL] if events & IOLoop . WRITE : [EOL] if fd not in self . writers : [EOL] self . asyncio_loop . add_writer ( fd , self . _handle_events , fd , IOLoop . WRITE ) [EOL] self . writers . add ( fd ) [EOL] else : [EOL] if fd in self . writers : [EOL] self . asyncio_loop . remove_writer ( fd ) [EOL] self . writers . remove ( fd ) [EOL] [EOL] def remove_handler ( self , fd ) : [EOL] fd , fileobj = self . split_fd ( fd ) [EOL] if fd not in self . handlers : [EOL] return [EOL] if fd in self . readers : [EOL] self . asyncio_loop . remove_reader ( fd ) [EOL] self . readers . remove ( fd ) [EOL] if fd in self . writers : [EOL] self . asyncio_loop . remove_writer ( fd ) [EOL] self . writers . remove ( fd ) [EOL] del self . handlers [ fd ] [EOL] [EOL] def _handle_events ( self , fd , events ) : [EOL] fileobj , handler_func = self . handlers [ fd ] [EOL] handler_func ( fileobj , events ) [EOL] [EOL] def start ( self ) : [EOL] try : [EOL] old_loop = asyncio . get_event_loop ( ) [EOL] except ( RuntimeError , AssertionError ) : [EOL] old_loop = None [comment] [EOL] try : [EOL] self . _setup_logging ( ) [EOL] asyncio . set_event_loop ( self . asyncio_loop ) [EOL] self . asyncio_loop . run_forever ( ) [EOL] finally : [EOL] asyncio . set_event_loop ( old_loop ) [EOL] [EOL] def stop ( self ) : [EOL] self . asyncio_loop . stop ( ) [EOL] [EOL] def call_at ( self , when , callback , * args , ** kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return self . asyncio_loop . call_later ( max ( [number] , when - self . time ( ) ) , self . _run_callback , functools . partial ( callback , * args , ** kwargs ) , ) [EOL] [EOL] def remove_timeout ( self , timeout ) : [EOL] timeout . cancel ( ) [comment] [EOL] [EOL] def add_callback ( self , callback , * args , ** kwargs ) : [EOL] if get_ident ( ) == self . _thread_identity : [EOL] call_soon = self . asyncio_loop . call_soon [EOL] else : [EOL] call_soon = self . asyncio_loop . call_soon_threadsafe [EOL] try : [EOL] call_soon ( self . _run_callback , functools . partial ( callback , * args , ** kwargs ) ) [EOL] except RuntimeError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] def add_callback_from_signal ( self , callback , * args , ** kwargs ) : [EOL] try : [EOL] self . asyncio_loop . call_soon_threadsafe ( self . _run_callback , functools . partial ( callback , * args , ** kwargs ) ) [EOL] except RuntimeError : [EOL] pass [EOL] [EOL] def run_in_executor ( self , executor , func , * args ) : [EOL] return self . asyncio_loop . run_in_executor ( executor , func , * args ) [EOL] [EOL] def set_default_executor ( self , executor ) : [EOL] return self . asyncio_loop . set_default_executor ( executor ) [EOL] [EOL] [EOL] class AsyncIOMainLoop ( BaseAsyncIOLoop ) : [EOL] [docstring] [EOL] [EOL] def initialize ( self , ** kwargs ) : [comment] [EOL] super ( ) . initialize ( asyncio . get_event_loop ( ) , ** kwargs ) [EOL] [EOL] def make_current ( self ) : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] class AsyncIOLoop ( BaseAsyncIOLoop ) : [EOL] [docstring] [EOL] [EOL] def initialize ( self , ** kwargs ) : [comment] [EOL] self . is_current = False [EOL] loop = asyncio . new_event_loop ( ) [EOL] try : [EOL] super ( ) . initialize ( loop , ** kwargs ) [EOL] except Exception : [EOL] [comment] [EOL] [comment] [EOL] loop . close ( ) [EOL] raise [EOL] [EOL] def close ( self , all_fds = False ) : [EOL] if self . is_current : [EOL] self . clear_current ( ) [EOL] super ( ) . close ( all_fds = all_fds ) [EOL] [EOL] def make_current ( self ) : [EOL] if not self . is_current : [EOL] try : [EOL] self . old_asyncio = asyncio . get_event_loop ( ) [EOL] except ( RuntimeError , AssertionError ) : [EOL] self . old_asyncio = None [comment] [EOL] self . is_current = True [EOL] asyncio . set_event_loop ( self . asyncio_loop ) [EOL] [EOL] def _clear_current_hook ( self ) : [EOL] if self . is_current : [EOL] asyncio . set_event_loop ( self . old_asyncio ) [EOL] self . is_current = False [EOL] [EOL] [EOL] def to_tornado_future ( asyncio_future ) : [EOL] [docstring] [EOL] return asyncio_future [EOL] [EOL] [EOL] def to_asyncio_future ( tornado_future ) : [EOL] [docstring] [EOL] return convert_yielded ( tornado_future ) [EOL] [EOL] [EOL] if sys . platform == [string] and hasattr ( asyncio , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] _BasePolicy = asyncio . WindowsSelectorEventLoopPolicy [comment] [EOL] else : [EOL] _BasePolicy = asyncio . DefaultEventLoopPolicy [EOL] [EOL] [EOL] class AnyThreadEventLoopPolicy ( _BasePolicy ) : [comment] [EOL] [docstring] [EOL] [EOL] def get_event_loop ( self ) : [EOL] try : [EOL] return super ( ) . get_event_loop ( ) [EOL] except ( RuntimeError , AssertionError ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] loop = self . new_event_loop ( ) [EOL] self . set_event_loop ( loop ) [EOL] return loop [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Callable[...,None]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,None]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 $builtins.float$ 0 $typing.Callable[...,None]$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,None]$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[_T]$ 0 0 0 $typing.Optional[concurrent.futures.Executor]$ 0 $typing.Callable[...,_T]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[concurrent.futures.Executor]$ 0 $typing.Callable[...,_T]$ 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $concurrent.futures.Executor$ 0 0 0 0 0 0 0 0 0 0 $concurrent.futures.Executor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[asyncio.events.AbstractEventLoopPolicy]$ 0 0 0 0 0 0 0 0 0 $typing.Type[asyncio.events.AbstractEventLoopPolicy]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[asyncio.events.AbstractEventLoopPolicy]$ 0 0 0 0 0 0 0 0 $asyncio.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Type , List , Any , Union , Dict , Tuple [EOL] import typing [EOL] import demos [EOL] import tornado [EOL] import aiopg [EOL] import bcrypt [EOL] import markdown [EOL] import os . path [EOL] import psycopg2 [EOL] import re [EOL] import tornado . escape [EOL] import tornado . httpserver [EOL] import tornado . ioloop [EOL] import tornado . locks [EOL] import tornado . options [EOL] import tornado . web [EOL] import unicodedata [EOL] [EOL] from tornado . options import define , options [EOL] [EOL] define ( [string] , default = [number] , help = [string] , type = int ) [EOL] define ( [string] , default = [string] , help = [string] ) [EOL] define ( [string] , default = [number] , help = [string] ) [EOL] define ( [string] , default = [string] , help = [string] ) [EOL] define ( [string] , default = [string] , help = [string] ) [EOL] define ( [string] , default = [string] , help = [string] ) [EOL] [EOL] [EOL] class NoResultError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] async def maybe_create_tables ( db ) : [EOL] try : [EOL] with ( await db . cursor ( ) ) as cur : [EOL] await cur . execute ( [string] ) [EOL] await cur . fetchone ( ) [EOL] except psycopg2 . ProgrammingError : [EOL] with open ( [string] ) as f : [EOL] schema = f . read ( ) [EOL] with ( await db . cursor ( ) ) as cur : [EOL] await cur . execute ( schema ) [EOL] [EOL] [EOL] class Application ( tornado . web . Application ) : [EOL] def __init__ ( self , db ) : [EOL] self . db = db [EOL] handlers = [ ( [string] , HomeHandler ) , ( [string] , ArchiveHandler ) , ( [string] , FeedHandler ) , ( [string] , EntryHandler ) , ( [string] , ComposeHandler ) , ( [string] , AuthCreateHandler ) , ( [string] , AuthLoginHandler ) , ( [string] , AuthLogoutHandler ) , ] [EOL] settings = dict ( blog_title = [string] , template_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) , static_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) , ui_modules = { [string] : EntryModule } , xsrf_cookies = True , cookie_secret = [string] , login_url = [string] , debug = True , ) [EOL] super ( ) . __init__ ( handlers , ** settings ) [EOL] [EOL] [EOL] class BaseHandler ( tornado . web . RequestHandler ) : [EOL] def row_to_obj ( self , row , cur ) : [EOL] [docstring] [EOL] obj = tornado . util . ObjectDict ( ) [EOL] for val , desc in zip ( row , cur . description ) : [EOL] obj [ desc . name ] = val [EOL] return obj [EOL] [EOL] async def execute ( self , stmt , * args ) : [EOL] [docstring] [EOL] with ( await self . application . db . cursor ( ) ) as cur : [EOL] await cur . execute ( stmt , args ) [EOL] [EOL] async def query ( self , stmt , * args ) : [EOL] [docstring] [EOL] with ( await self . application . db . cursor ( ) ) as cur : [EOL] await cur . execute ( stmt , args ) [EOL] return [ self . row_to_obj ( row , cur ) for row in await cur . fetchall ( ) ] [EOL] [EOL] async def queryone ( self , stmt , * args ) : [EOL] [docstring] [EOL] results = await self . query ( stmt , * args ) [EOL] if len ( results ) == [number] : [EOL] raise NoResultError ( ) [EOL] elif len ( results ) > [number] : [EOL] raise ValueError ( [string] % len ( results ) ) [EOL] return results [ [number] ] [EOL] [EOL] async def prepare ( self ) : [EOL] [comment] [EOL] [comment] [EOL] user_id = self . get_secure_cookie ( [string] ) [EOL] if user_id : [EOL] self . current_user = await self . queryone ( [string] , int ( user_id ) ) [EOL] [EOL] async def any_author_exists ( self ) : [EOL] return bool ( await self . query ( [string] ) ) [EOL] [EOL] [EOL] class HomeHandler ( BaseHandler ) : [EOL] async def get ( self ) : [EOL] entries = await self . query ( [string] ) [EOL] if not entries : [EOL] self . redirect ( [string] ) [EOL] return [EOL] self . render ( [string] , entries = entries ) [EOL] [EOL] [EOL] class EntryHandler ( BaseHandler ) : [EOL] async def get ( self , slug ) : [EOL] entry = await self . queryone ( [string] , slug ) [EOL] if not entry : [EOL] raise tornado . web . HTTPError ( [number] ) [EOL] self . render ( [string] , entry = entry ) [EOL] [EOL] [EOL] class ArchiveHandler ( BaseHandler ) : [EOL] async def get ( self ) : [EOL] entries = await self . query ( [string] ) [EOL] self . render ( [string] , entries = entries ) [EOL] [EOL] [EOL] class FeedHandler ( BaseHandler ) : [EOL] async def get ( self ) : [EOL] entries = await self . query ( [string] ) [EOL] self . set_header ( [string] , [string] ) [EOL] self . render ( [string] , entries = entries ) [EOL] [EOL] [EOL] class ComposeHandler ( BaseHandler ) : [EOL] @ tornado . web . authenticated async def get ( self ) : [EOL] id = self . get_argument ( [string] , None ) [EOL] entry = None [EOL] if id : [EOL] entry = await self . queryone ( [string] , int ( id ) ) [EOL] self . render ( [string] , entry = entry ) [EOL] [EOL] @ tornado . web . authenticated async def post ( self ) : [EOL] id = self . get_argument ( [string] , None ) [EOL] title = self . get_argument ( [string] ) [EOL] text = self . get_argument ( [string] ) [EOL] html = markdown . markdown ( text ) [EOL] if id : [EOL] try : [EOL] entry = await self . queryone ( [string] , int ( id ) ) [EOL] except NoResultError : [EOL] raise tornado . web . HTTPError ( [number] ) [EOL] slug = entry . slug [EOL] await self . execute ( [string] [string] , title , text , html , int ( id ) , ) [EOL] else : [EOL] slug = unicodedata . normalize ( [string] , title ) [EOL] slug = re . sub ( [string] , [string] , slug ) [EOL] slug = [string] . join ( slug . lower ( ) . strip ( ) . split ( ) ) [EOL] slug = slug . encode ( [string] , [string] ) . decode ( [string] ) [EOL] if not slug : [EOL] slug = [string] [EOL] while True : [EOL] e = await self . query ( [string] , slug ) [EOL] if not e : [EOL] break [EOL] slug += [string] [EOL] await self . execute ( [string] [string] , self . current_user . id , title , slug , text , html , ) [EOL] self . redirect ( [string] + slug ) [EOL] [EOL] [EOL] class AuthCreateHandler ( BaseHandler ) : [EOL] def get ( self ) : [EOL] self . render ( [string] ) [EOL] [EOL] async def post ( self ) : [EOL] if await self . any_author_exists ( ) : [EOL] raise tornado . web . HTTPError ( [number] , [string] ) [EOL] hashed_password = await tornado . ioloop . IOLoop . current ( ) . run_in_executor ( None , bcrypt . hashpw , tornado . escape . utf8 ( self . get_argument ( [string] ) ) , bcrypt . gensalt ( ) , ) [EOL] author = await self . queryone ( [string] [string] , self . get_argument ( [string] ) , self . get_argument ( [string] ) , tornado . escape . to_unicode ( hashed_password ) , ) [EOL] self . set_secure_cookie ( [string] , str ( author . id ) ) [EOL] self . redirect ( self . get_argument ( [string] , [string] ) ) [EOL] [EOL] [EOL] class AuthLoginHandler ( BaseHandler ) : [EOL] async def get ( self ) : [EOL] [comment] [EOL] if not await self . any_author_exists ( ) : [EOL] self . redirect ( [string] ) [EOL] else : [EOL] self . render ( [string] , error = None ) [EOL] [EOL] async def post ( self ) : [EOL] try : [EOL] author = await self . queryone ( [string] , self . get_argument ( [string] ) ) [EOL] except NoResultError : [EOL] self . render ( [string] , error = [string] ) [EOL] return [EOL] password_equal = await tornado . ioloop . IOLoop . current ( ) . run_in_executor ( None , bcrypt . checkpw , tornado . escape . utf8 ( self . get_argument ( [string] ) ) , tornado . escape . utf8 ( author . hashed_password ) , ) [EOL] if password_equal : [EOL] self . set_secure_cookie ( [string] , str ( author . id ) ) [EOL] self . redirect ( self . get_argument ( [string] , [string] ) ) [EOL] else : [EOL] self . render ( [string] , error = [string] ) [EOL] [EOL] [EOL] class AuthLogoutHandler ( BaseHandler ) : [EOL] def get ( self ) : [EOL] self . clear_cookie ( [string] ) [EOL] self . redirect ( self . get_argument ( [string] , [string] ) ) [EOL] [EOL] [EOL] class EntryModule ( tornado . web . UIModule ) : [EOL] def render ( self , entry ) : [EOL] return self . render_string ( [string] , entry = entry ) [EOL] [EOL] [EOL] async def main ( ) : [EOL] tornado . options . parse_command_line ( ) [EOL] [EOL] [comment] [EOL] async with aiopg . create_pool ( host = options . db_host , port = options . db_port , user = options . db_user , password = options . db_password , dbname = options . db_database , ) as db : [EOL] await maybe_create_tables ( db ) [EOL] app = Application ( db ) [EOL] app . listen ( options . port ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] shutdown_event = tornado . locks . Event ( ) [EOL] await shutdown_event . wait ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] tornado . ioloop . IOLoop . current ( ) . run_sync ( main ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[typing.Union[demos.blog.blog.ArchiveHandler,demos.blog.blog.AuthCreateHandler,demos.blog.blog.AuthLoginHandler,demos.blog.blog.AuthLogoutHandler,demos.blog.blog.ComposeHandler,demos.blog.blog.EntryHandler,demos.blog.blog.FeedHandler,demos.blog.blog.HomeHandler]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Type[demos.blog.blog.EntryModule]],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[typing.Union[demos.blog.blog.ArchiveHandler,demos.blog.blog.AuthCreateHandler,demos.blog.blog.AuthLoginHandler,demos.blog.blog.AuthLogoutHandler,demos.blog.blog.ComposeHandler,demos.blog.blog.EntryHandler,demos.blog.blog.FeedHandler,demos.blog.blog.HomeHandler]]]]$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Type[demos.blog.blog.EntryModule]],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.util.ObjectDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.util.ObjectDict$ 0 0 0 0 0 0 0 0 0 $tornado.util.ObjectDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Type , List , Any , Union , Dict , Tuple [EOL] import typing [EOL] import demos [EOL] import tornado [EOL] import os . path [EOL] import tornado . auth [EOL] import tornado . escape [EOL] import tornado . httpserver [EOL] import tornado . ioloop [EOL] import tornado . options [EOL] import tornado . web [EOL] [EOL] from tornado . options import define , options [EOL] [EOL] define ( [string] , default = [number] , help = [string] , type = int ) [EOL] define ( [string] , help = [string] , type = str ) [EOL] define ( [string] , help = [string] , type = str ) [EOL] [EOL] [EOL] class Application ( tornado . web . Application ) : [EOL] def __init__ ( self ) : [EOL] handlers = [ ( [string] , MainHandler ) , ( [string] , AuthLoginHandler ) , ( [string] , AuthLogoutHandler ) , ] [EOL] settings = dict ( cookie_secret = [string] , login_url = [string] , template_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) , static_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) , xsrf_cookies = True , facebook_api_key = options . facebook_api_key , facebook_secret = options . facebook_secret , ui_modules = { [string] : PostModule } , debug = True , autoescape = None , ) [EOL] tornado . web . Application . __init__ ( self , handlers , ** settings ) [EOL] [EOL] [EOL] class BaseHandler ( tornado . web . RequestHandler ) : [EOL] def get_current_user ( self ) : [EOL] user_json = self . get_secure_cookie ( [string] ) [EOL] if not user_json : [EOL] return None [EOL] return tornado . escape . json_decode ( user_json ) [EOL] [EOL] [EOL] class MainHandler ( BaseHandler , tornado . auth . FacebookGraphMixin ) : [EOL] @ tornado . web . authenticated async def get ( self ) : [EOL] stream = await self . facebook_request ( [string] , self . _on_stream , access_token = self . current_user [ [string] ] ) [EOL] if stream is None : [EOL] [comment] [EOL] self . redirect ( [string] ) [EOL] return [EOL] self . render ( [string] , stream = stream ) [EOL] [EOL] [EOL] class AuthLoginHandler ( BaseHandler , tornado . auth . FacebookGraphMixin ) : [EOL] async def get ( self ) : [EOL] my_url = ( self . request . protocol + [string] + self . request . host + [string] + tornado . escape . url_escape ( self . get_argument ( [string] , [string] ) ) ) [EOL] if self . get_argument ( [string] , False ) : [EOL] user = await self . get_authenticated_user ( redirect_uri = my_url , client_id = self . settings [ [string] ] , client_secret = self . settings [ [string] ] , code = self . get_argument ( [string] ) , ) [EOL] self . set_secure_cookie ( [string] , tornado . escape . json_encode ( user ) ) [EOL] self . redirect ( self . get_argument ( [string] , [string] ) ) [EOL] return [EOL] self . authorize_redirect ( redirect_uri = my_url , client_id = self . settings [ [string] ] , extra_params = { [string] : [string] } , ) [EOL] [EOL] [EOL] class AuthLogoutHandler ( BaseHandler , tornado . auth . FacebookGraphMixin ) : [EOL] def get ( self ) : [EOL] self . clear_cookie ( [string] ) [EOL] self . redirect ( self . get_argument ( [string] , [string] ) ) [EOL] [EOL] [EOL] class PostModule ( tornado . web . UIModule ) : [EOL] def render ( self , post ) : [EOL] return self . render_string ( [string] , post = post ) [EOL] [EOL] [EOL] def main ( ) : [EOL] tornado . options . parse_command_line ( ) [EOL] if not ( options . facebook_api_key and options . facebook_secret ) : [EOL] print ( [string] ) [EOL] return [EOL] http_server = tornado . httpserver . HTTPServer ( Application ( ) ) [EOL] http_server . listen ( options . port ) [EOL] tornado . ioloop . IOLoop . current ( ) . start ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[typing.Union[demos.facebook.facebook.AuthLoginHandler,demos.facebook.facebook.AuthLogoutHandler,demos.facebook.facebook.MainHandler]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[typing.Union[demos.facebook.facebook.AuthLoginHandler,demos.facebook.facebook.AuthLogoutHandler,demos.facebook.facebook.MainHandler]]]]$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import demos [EOL] import time [EOL] from datetime import timedelta [EOL] [EOL] from html . parser import HTMLParser [EOL] from urllib . parse import urljoin , urldefrag [EOL] [EOL] from tornado import gen , httpclient , ioloop , queues [EOL] [EOL] base_url = [string] [EOL] concurrency = [number] [EOL] [EOL] [EOL] async def get_links_from_url ( url ) : [EOL] [docstring] [EOL] response = await httpclient . AsyncHTTPClient ( ) . fetch ( url ) [EOL] print ( [string] % url ) [EOL] [EOL] html = response . body . decode ( errors = [string] ) [EOL] return [ urljoin ( url , remove_fragment ( new_url ) ) for new_url in get_links ( html ) ] [EOL] [EOL] [EOL] def remove_fragment ( url ) : [EOL] pure_url , frag = urldefrag ( url ) [EOL] return pure_url [EOL] [EOL] [EOL] def get_links ( html ) : [EOL] class URLSeeker ( HTMLParser ) : [EOL] def __init__ ( self ) : [EOL] HTMLParser . __init__ ( self ) [EOL] self . urls = [ ] [EOL] [EOL] def handle_starttag ( self , tag , attrs ) : [EOL] href = dict ( attrs ) . get ( [string] ) [EOL] if href and tag == [string] : [EOL] self . urls . append ( href ) [EOL] [EOL] url_seeker = URLSeeker ( ) [EOL] url_seeker . feed ( html ) [EOL] return url_seeker . urls [EOL] [EOL] [EOL] async def main ( ) : [EOL] q = queues . Queue ( ) [EOL] start = time . time ( ) [EOL] fetching , fetched , dead = set ( ) , set ( ) , set ( ) [EOL] [EOL] async def fetch_url ( current_url ) : [EOL] if current_url in fetching : [EOL] return [EOL] [EOL] print ( [string] % current_url ) [EOL] fetching . add ( current_url ) [EOL] urls = await get_links_from_url ( current_url ) [EOL] fetched . add ( current_url ) [EOL] [EOL] for new_url in urls : [EOL] [comment] [EOL] if new_url . startswith ( base_url ) : [EOL] await q . put ( new_url ) [EOL] [EOL] async def worker ( ) : [EOL] async for url in q : [EOL] if url is None : [EOL] return [EOL] try : [EOL] await fetch_url ( url ) [EOL] except Exception as e : [EOL] print ( [string] % ( e , url ) ) [EOL] dead . add ( url ) [EOL] finally : [EOL] q . task_done ( ) [EOL] [EOL] await q . put ( base_url ) [EOL] [EOL] [comment] [EOL] workers = gen . multi ( [ worker ( ) for _ in range ( concurrency ) ] ) [EOL] await q . join ( timeout = timedelta ( seconds = [number] ) ) [EOL] assert fetching == ( fetched | dead ) [EOL] print ( [string] % ( time . time ( ) - start , len ( fetched ) ) ) [EOL] print ( [string] % len ( dead ) ) [EOL] [EOL] [comment] [EOL] for _ in range ( concurrency ) : [EOL] await q . put ( None ) [EOL] await workers [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] io_loop = ioloop . IOLoop . current ( ) [EOL] io_loop . run_sync ( main ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import tornado [EOL] import demos [EOL] import asyncio [EOL] import tornado . escape [EOL] import tornado . ioloop [EOL] import tornado . locks [EOL] import tornado . web [EOL] import os . path [EOL] import uuid [EOL] [EOL] from tornado . options import define , options , parse_command_line [EOL] [EOL] define ( [string] , default = [number] , help = [string] , type = int ) [EOL] define ( [string] , default = True , help = [string] ) [EOL] [EOL] [EOL] class MessageBuffer ( object ) : [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . cond = tornado . locks . Condition ( ) [EOL] self . cache = [ ] [EOL] self . cache_size = [number] [EOL] [EOL] def get_messages_since ( self , cursor ) : [EOL] [docstring] [EOL] results = [ ] [EOL] for msg in reversed ( self . cache ) : [EOL] if msg [ [string] ] == cursor : [EOL] break [EOL] results . append ( msg ) [EOL] results . reverse ( ) [EOL] return results [EOL] [EOL] def add_message ( self , message ) : [EOL] self . cache . append ( message ) [EOL] if len ( self . cache ) > self . cache_size : [EOL] self . cache = self . cache [ - self . cache_size : ] [EOL] self . cond . notify_all ( ) [EOL] [EOL] [EOL] [comment] [EOL] global_message_buffer = MessageBuffer ( ) [EOL] [EOL] [EOL] class MainHandler ( tornado . web . RequestHandler ) : [EOL] def get ( self ) : [EOL] self . render ( [string] , messages = global_message_buffer . cache ) [EOL] [EOL] [EOL] class MessageNewHandler ( tornado . web . RequestHandler ) : [EOL] [docstring] [EOL] [EOL] def post ( self ) : [EOL] message = { [string] : str ( uuid . uuid4 ( ) ) , [string] : self . get_argument ( [string] ) } [EOL] [comment] [EOL] [comment] [EOL] message [ [string] ] = tornado . escape . to_unicode ( self . render_string ( [string] , message = message ) ) [EOL] if self . get_argument ( [string] , None ) : [EOL] self . redirect ( self . get_argument ( [string] ) ) [EOL] else : [EOL] self . write ( message ) [EOL] global_message_buffer . add_message ( message ) [EOL] [EOL] [EOL] class MessageUpdatesHandler ( tornado . web . RequestHandler ) : [EOL] [docstring] [EOL] [EOL] async def post ( self ) : [EOL] cursor = self . get_argument ( [string] , None ) [EOL] messages = global_message_buffer . get_messages_since ( cursor ) [EOL] while not messages : [EOL] [comment] [EOL] [comment] [EOL] self . wait_future = global_message_buffer . cond . wait ( ) [EOL] try : [EOL] await self . wait_future [EOL] except asyncio . CancelledError : [EOL] return [EOL] messages = global_message_buffer . get_messages_since ( cursor ) [EOL] if self . request . connection . stream . closed ( ) : [EOL] return [EOL] self . write ( dict ( messages = messages ) ) [EOL] [EOL] def on_connection_close ( self ) : [EOL] self . wait_future . cancel ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parse_command_line ( ) [EOL] app = tornado . web . Application ( [ ( [string] , MainHandler ) , ( [string] , MessageNewHandler ) , ( [string] , MessageUpdatesHandler ) , ] , cookie_secret = [string] , template_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) , static_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) , xsrf_cookies = True , debug = options . debug , ) [EOL] app . listen ( options . port ) [EOL] tornado . ioloop . IOLoop . current ( ) . start ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.locks.Condition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $demos.chat.chatdemo.MessageBuffer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $demos.chat.chatdemo.MessageBuffer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $demos.chat.chatdemo.MessageBuffer$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $demos.chat.chatdemo.MessageBuffer$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $demos.chat.chatdemo.MessageBuffer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $demos.chat.chatdemo.MessageBuffer$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from tornado import gen [EOL] [EOL] [EOL] @ gen . coroutine def hello ( ) : [EOL] yield gen . sleep ( [number] ) [EOL] raise gen . Return ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from tornado import gen [EOL] from tornado . web import RequestHandler [EOL] [EOL] [EOL] class MyHandler ( RequestHandler ) : [EOL] def get ( self ) : [EOL] self . write ( [string] ) [EOL] [EOL] async def post ( self ) : [EOL] await gen . sleep ( [number] ) [EOL] self . write ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from tornado . web import RequestHandler [EOL] [EOL] [EOL] class MyHandler ( RequestHandler ) : [EOL] def get ( self ) : [comment] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import sys [EOL] from lib2to3 . main import main [EOL] [EOL] sys . exit ( main ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import pathlib [EOL] import tornado [EOL] import asyncio [EOL] import json [EOL] import pathlib [EOL] import sys [EOL] from tornado . httpclient import AsyncHTTPClient [EOL] [EOL] BASE_URL = [string] [EOL] [EOL] [EOL] async def fetch_job ( directory , job ) : [EOL] http = AsyncHTTPClient ( ) [EOL] artifacts = await http . fetch ( f"{ BASE_URL } [string] { job } [string] " ) [EOL] paths = [ pathlib . PurePosixPath ( a [ [string] ] ) for a in json . loads ( artifacts . body ) ] [EOL] [EOL] for path in paths : [EOL] artifact = await http . fetch ( f"{ BASE_URL } [string] { job } [string] { path }" ) [EOL] with open ( directory . joinpath ( path . name ) , [string] ) as f : [EOL] f . write ( artifact . body ) [EOL] [EOL] [EOL] async def main ( ) : [EOL] http = AsyncHTTPClient ( ) [EOL] try : [EOL] _ , version = sys . argv [EOL] except ValueError : [EOL] print ( [string] , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL] [EOL] directory = pathlib . Path ( f" [string] { version }" ) [EOL] directory . mkdir ( exist_ok = True ) [EOL] [EOL] build = await http . fetch ( f"{ BASE_URL } [string] { version }" ) [EOL] jobs = [ job [ [string] ] for job in json . loads ( build . body ) [ [string] ] [ [string] ] ] [EOL] [EOL] await asyncio . gather ( * ( fetch_job ( directory , job ) for job in jobs ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] asyncio . run ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0