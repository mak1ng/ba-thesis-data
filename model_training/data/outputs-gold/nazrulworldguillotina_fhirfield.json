from typing import List [EOL] import typing [EOL] from zope . interface import Invalid [EOL] [EOL] [EOL] class SearchQueryError ( Invalid ) : [EOL] [docstring] [EOL] [EOL] [EOL] class SearchQueryValidationError ( SearchQueryError ) : [EOL] [docstring] [EOL] [EOL] [EOL] __all__ = [ str ( x ) for x in ( [string] , [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] import sys [EOL] [EOL] import click [EOL] [EOL] [EOL] @ click . command ( ) def main ( args = None ) : [EOL] [docstring] [EOL] click . echo ( [string] [string] ) [EOL] click . echo ( [string] ) [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Union , List , Type , Pattern , Dict , Any [EOL] import builtins [EOL] import typing [EOL] import _importlib_modulespec [EOL] import zope [EOL] [docstring] [EOL] import inspect [EOL] import io [EOL] import json [EOL] import pkgutil [EOL] import re [EOL] import sys [EOL] import time [EOL] import warnings [EOL] from importlib import import_module [EOL] from typing import Union [EOL] from urllib . parse import unquote_plus [EOL] [EOL] from guillotina . configure . config import reraise [EOL] from multidict import MultiDict [EOL] from multidict import MultiDictProxy [EOL] from zope . interface import Invalid [EOL] [EOL] import ujson [EOL] [EOL] from . exc import SearchQueryError [EOL] from . variables import EMPTY_STRING [EOL] from . variables import FHIR_ES_MAPPINGS_CACHE [EOL] from . variables import FHIR_RESOURCE_LIST [comment] [EOL] from . variables import FHIR_RESOURCE_MAPPING_DIR [EOL] from . variables import FHIR_RESOURCE_CLASS_CACHE [comment] [EOL] from . variables import FHIR_SEARCH_PARAMETER_SEARCHABLE [EOL] from . variables import NO_VALUE [EOL] [EOL] [EOL] __docformat__ = [string] [EOL] [EOL] PATH_WITH_DOT_AS = re . compile ( [string] , re . I ) [EOL] PATH_WITH_DOT_IS = re . compile ( [string] , re . I ) [EOL] PATH_WITH_DOT_WHERE = re . compile ( [string] , re . I ) [EOL] NoneType = type ( None ) [EOL] [EOL] [EOL] def search_fhir_resource_cls ( resource_type , cache = True , fhir_release = None ) : [comment] [EOL] [docstring] [EOL] if resource_type in FHIR_RESOURCE_CLASS_CACHE and cache : [EOL] return [string] . format ( FHIR_RESOURCE_CLASS_CACHE [ resource_type ] , resource_type , ) [EOL] [EOL] [comment] [EOL] prime_module = [string] [EOL] if fhir_release : [EOL] prime_module = f'{ prime_module } [string] { fhir_release }' [EOL] [EOL] prime_module_level = len ( prime_module . split ( [string] ) ) [EOL] prime_module = import_module ( prime_module ) [EOL] [EOL] for importer , module_name , ispkg in pkgutil . walk_packages ( prime_module . __path__ , prime_module . __name__ + [string] , onerror = lambda x : None ) : [EOL] if ispkg or ( prime_module_level + [number] ) < len ( module_name . split ( [string] ) ) : [EOL] continue [EOL] [EOL] module_obj = import_module ( module_name ) [EOL] [EOL] for klass_name , klass in inspect . getmembers ( module_obj , inspect . isclass ) : [EOL] [EOL] if klass_name == resource_type : [EOL] FHIR_RESOURCE_CLASS_CACHE [ resource_type ] = module_name [EOL] return f"{ module_name } [string] { resource_type }" [EOL] [EOL] return None [EOL] [EOL] [EOL] def resource_type_to_resource_cls ( resource_type , fhir_release = None ) : [EOL] [docstring] [EOL] dotted_path = search_fhir_resource_cls ( resource_type , fhir_release = fhir_release ) [EOL] if dotted_path is None : [EOL] raise Invalid ( f" [string] { resource_type } [string] " ) [EOL] [EOL] return import_string ( dotted_path ) [EOL] [EOL] [EOL] def import_string ( dotted_path ) : [EOL] [docstring] [EOL] module_path , class_name = None , None [EOL] try : [EOL] module_path , class_name = dotted_path . rsplit ( [string] , [number] ) [EOL] except ( ValueError , AttributeError ) : [EOL] [EOL] t , v , tb = sys . exc_info ( ) [EOL] msg = [string] . format ( dotted_path ) [EOL] try : [EOL] reraise ( ImportError ( msg ) , None , tb ) [EOL] finally : [EOL] del t , v , tb [EOL] [EOL] module = import_module ( module_path ) [EOL] [EOL] try : [EOL] return getattr ( module , class_name ) [EOL] except AttributeError : [EOL] msg = [string] . format ( module_path , class_name ) [EOL] t , v , tb = sys . exc_info ( ) [EOL] try : [EOL] return reraise ( ImportError ( msg ) , None , tb ) [EOL] finally : [EOL] del t , v , tb [EOL] [EOL] [EOL] def parse_json_str ( str_val , encoding = [string] ) : [EOL] [docstring] [EOL] json_dict = ... [EOL] [EOL] if str_val in ( NO_VALUE , EMPTY_STRING , None ) : [EOL] [comment] [EOL] return None [EOL] [EOL] try : [EOL] json_dict = json . loads ( str_val , encoding = encoding ) [EOL] except ValueError as exc : [EOL] msg = [string] . format ( exc ) [EOL] t , v , tb = sys . exc_info ( ) [EOL] try : [EOL] reraise ( Invalid ( msg ) , None , tb ) [EOL] finally : [EOL] del t , v , tb [EOL] [EOL] return json_dict [EOL] [EOL] [EOL] def fhir_search_path_meta_info ( path ) : [EOL] [docstring] [EOL] resource_type = path . split ( [string] ) [ [number] ] [EOL] properties = path . split ( [string] ) [ [number] : ] [EOL] [EOL] model_cls = resource_type_to_resource_cls ( resource_type ) [EOL] result = None [EOL] for prop in properties : [EOL] for ( name , jsname , typ , is_list , of_many , not_optional , ) in model_cls ( ) . elementProperties ( ) : [EOL] if prop != name : [EOL] continue [EOL] if typ not in ( int , float , bool , str ) : [EOL] model_cls = typ [EOL] [EOL] result = ( jsname , is_list , of_many ) [EOL] break [EOL] [EOL] return result [EOL] [EOL] [EOL] def filter_logic_in_path ( raw_path ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] replacer = [string] [EOL] as_match = PATH_WITH_DOT_AS . search ( raw_path ) [EOL] is_match = PATH_WITH_DOT_IS . search ( raw_path ) [EOL] where_match = PATH_WITH_DOT_IS . search ( raw_path ) [EOL] [EOL] if as_match : [EOL] word = as_match . group ( ) [EOL] path = raw_path . replace ( word , replacer ) [EOL] [EOL] new_word = word [ [number] ] . upper ( ) + word [ [number] : - [number] ] [EOL] path = path . replace ( replacer , new_word ) [EOL] [EOL] elif is_match : [EOL] [EOL] word = is_match . group ( ) [EOL] path = raw_path . replace ( word , replacer ) [EOL] [EOL] new_word = word [ [number] ] . upper ( ) + word [ [number] : - [number] ] [EOL] path = path . replace ( replacer , new_word ) [EOL] [EOL] elif where_match : [EOL] [EOL] word = where_match . group ( ) [EOL] path = raw_path . replace ( word , [string] ) [EOL] [EOL] else : [EOL] path = raw_path [EOL] [EOL] return path [EOL] [EOL] [EOL] def _translate_param_name_to_real_path_key ( * args ) : [EOL] [docstring] [EOL] keys = list ( ) [EOL] keys . append ( args [ [number] ] . __name__ ) [EOL] keys . append ( args [ [number] ] ) [EOL] [EOL] try : [EOL] keys . append ( args [ [number] ] ) [EOL] except IndexError : [EOL] keys . append ( [string] ) [EOL] [EOL] keys . append ( time . time ( ) // ( [number] * [number] * [number] ) ) [EOL] [EOL] return keys [EOL] [EOL] [EOL] def translate_param_name_to_real_path ( param_name , resource_type = None ) : [EOL] [docstring] [EOL] resource_type = resource_type or [string] [EOL] [EOL] try : [EOL] paths = FHIR_SEARCH_PARAMETER_SEARCHABLE . get ( param_name , [ ] ) [ [number] ] [EOL] except IndexError : [EOL] return [EOL] [EOL] for path in paths : [EOL] if path . startswith ( resource_type ) : [EOL] path = filter_logic_in_path ( path ) [EOL] return path [EOL] [EOL] [EOL] def parse_query_string ( request , allow_none = False ) : [EOL] [docstring] [EOL] query_string = request . get ( [string] , [string] ) [EOL] params = MultiDict ( ) [EOL] [EOL] for q in query_string . split ( [string] ) : [EOL] parts = q . split ( [string] ) [EOL] param_name = unquote_plus ( parts [ [number] ] ) [EOL] try : [EOL] value = parts [ [number] ] and unquote_plus ( parts [ [number] ] ) or None [EOL] except IndexError : [EOL] if not allow_none : [EOL] continue [EOL] value = None [EOL] [EOL] params . add ( param_name , value ) [EOL] [EOL] return MultiDictProxy ( params ) [EOL] [EOL] [EOL] def fhir_resource_mapping ( resource_type , cache = True ) : [EOL] [docstring] [EOL] if resource_type in FHIR_ES_MAPPINGS_CACHE and cache : [EOL] [EOL] return FHIR_ES_MAPPINGS_CACHE [ resource_type ] [EOL] [EOL] try : [EOL] FHIR_RESOURCE_LIST [ resource_type . lower ( ) ] [EOL] except KeyError : [EOL] msg = f"{ resource_type } [string] " [EOL] [EOL] t , v , tb = sys . exc_info ( ) [EOL] try : [EOL] reraise ( Invalid ( msg ) , None , tb ) [EOL] finally : [EOL] del t , v , tb [EOL] mapping_json = FHIR_RESOURCE_MAPPING_DIR / f"{ resource_type } [string] " [EOL] [EOL] if not mapping_json . exists ( ) : [EOL] [EOL] warnings . warn ( f" [string] { resource_type } [string] " [string] , UserWarning , ) [EOL] [EOL] return fhir_resource_mapping ( [string] , cache = True ) [EOL] [EOL] with io . open ( str ( mapping_json ) , [string] , encoding = [string] ) as f : [EOL] [EOL] mapping_dict = ujson . load ( f ) [EOL] [comment] [EOL] [EOL] FHIR_ES_MAPPINGS_CACHE [ resource_type ] = mapping_dict [ [string] ] [EOL] [EOL] return FHIR_ES_MAPPINGS_CACHE [ resource_type ] [EOL] [EOL] [EOL] def validate_resource_type ( resource_type ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] FHIR_RESOURCE_LIST [ resource_type . lower ( ) ] [EOL] except KeyError : [EOL] msg = ( f"{ resource_type } [string] " [string] ) [EOL] [EOL] t , v , tb = sys . exc_info ( ) [EOL] try : [EOL] reraise ( Invalid ( msg ) , None , tb ) [EOL] finally : [EOL] del t , v , tb [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.dict,NoneType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.tuple,NoneType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $NoneType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] class FhirPath : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] from guillotina import configure [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] __author__ = [string] [EOL] __email__ = [string] [EOL] __version__ = [string] [EOL] [EOL] app_settings = { } [EOL] [EOL] [EOL] def includeme ( root ) : [EOL] configure . scan ( [string] ) [EOL] configure . scan ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] def patch_fhir_base_model ( ) : [EOL] [docstring] [EOL] from zope . interface import implementer [EOL] import fhir . resources . resource as fmr [EOL] from guillotina_fhirfield . interfaces import IFhirResource [EOL] [comment] [EOL] fmr . Resource = implementer ( IFhirResource ) ( fmr . Resource ) [EOL] [EOL] [EOL] patch_fhir_base_model ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Union , List , Literal , Dict , Any [EOL] import typing_extensions [EOL] import multidict [EOL] import builtins [EOL] import typing [EOL] import src [EOL] from guillotina_fhirfield . field import fhir_field_from_resource_type [EOL] from multidict import MultiDictProxy [EOL] from zope . interface import Invalid [EOL] [EOL] from guillotina_fhirfield . exc import SearchQueryValidationError [EOL] from guillotina_fhirfield . helpers import fhir_search_path_meta_info [EOL] from guillotina_fhirfield . helpers import PATH_WITH_DOT_AS [EOL] from guillotina_fhirfield . helpers import PATH_WITH_DOT_IS [EOL] from guillotina_fhirfield . helpers import PATH_WITH_DOT_WHERE [EOL] from guillotina_fhirfield . helpers import fhir_resource_mapping [EOL] from guillotina_fhirfield . variables import ERROR_MESSAGES [EOL] from guillotina_fhirfield . variables import ERROR_PARAM_UNKNOWN [EOL] from guillotina_fhirfield . variables import ERROR_PARAM_UNSUPPORTED [EOL] from guillotina_fhirfield . variables import ERROR_PARAM_WRONG_DATATYPE [EOL] from guillotina_fhirfield . variables import FHIR_ES_MAPPINGS_CACHE [EOL] from guillotina_fhirfield . variables import FHIR_FIELD_DEBUG [EOL] from guillotina_fhirfield . variables import FHIR_RESOURCE_LIST [comment] [EOL] from guillotina_fhirfield . variables import FHIR_RESOURCE_CLASS_CACHE [comment] [EOL] from guillotina_fhirfield . variables import FHIR_SEARCH_PARAMETER_SEARCHABLE [EOL] from guillotina_fhirfield . variables import FSPR_VALUE_PRIFIXES_MAP [EOL] from guillotina_fhirfield . variables import LOGGER [EOL] from guillotina_fhirfield . variables import SEARCH_PARAM_MODIFIERS [EOL] from dateutil . parser import parse as dt_parse [EOL] [EOL] from . import mapping_types [EOL] import copy [EOL] import ast [EOL] import re [EOL] [EOL] escape_comma_replacer = [string] [EOL] [EOL] [EOL] def has_escape_comma ( val ) : [EOL] return [string] in val [EOL] [EOL] [EOL] class ElasticSearchQueryBuilder : [EOL] [docstring] [EOL] def __init__ ( self , params , resource_type , type_name = None ) : [EOL] [EOL] self . resource_type = resource_type [EOL] self . type_name = type_name [EOL] self . params = params [EOL] self . validate ( ) [EOL] [EOL] self . field_name = self . _predict_field_name ( ) [EOL] [EOL] self . query_tree = { [string] : { [string] : { [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] } } } [EOL] [EOL] [comment] [EOL] [EOL] def _predict_field_name ( self ) : [EOL] [docstring] [EOL] fields = fhir_field_from_resource_type ( self . resource_type , cache = True ) [EOL] [EOL] if not fields : [EOL] raise Invalid ( [string] ) [EOL] [EOL] field_name = next ( iter ( fields ) ) [EOL] [EOL] if self . type_name : [EOL] if self . type_name not in fields [ field_name ] [ [string] ] : [EOL] raise Invalid ( [string] + self . type_name ) [EOL] [EOL] return field_name [EOL] [EOL] def _make_address_query ( self , path , value , logic_in_path = None , nested = None , modifier = None ) : [EOL] [docstring] [EOL] query_context = [string] [EOL] multiple_paths = len ( path . split ( [string] ) ) == [number] [EOL] nested_path = path [EOL] [EOL] if multiple_paths : [EOL] query_context = [string] [EOL] [EOL] else : [EOL] nested_path = [string] . join ( path . split ( [string] ) [ : - [number] ] ) [EOL] query_context = [string] [EOL] [EOL] matches = list ( ) [EOL] if multiple_paths : [EOL] matches . append ( { [string] : { path + [string] : value } } ) [EOL] matches . append ( { [string] : { path + [string] : value } } ) [EOL] matches . append ( { [string] : { path + [string] : value } } ) [EOL] matches . append ( { [string] : { path + [string] : value } } ) [EOL] else : [EOL] matches . append ( { [string] : { path : value } } ) [EOL] [EOL] if nested : [EOL] query = { [string] : { [string] : nested_path , [string] : { [string] : { query_context : matches } } , } } [EOL] if query_context == [string] : [EOL] query [ [string] ] [ [string] ] [ [string] ] [ [string] ] = [number] [EOL] else : [EOL] query = { [string] : { query_context : matches } } [EOL] if query_context == [string] : [EOL] query [ [string] ] [ [string] ] = [number] [EOL] [comment] [EOL] return modifier == [string] and [string] or [string] , query [EOL] [EOL] def make_codeableconcept_query ( self , path , value , nested = None , modifier = None , logic_in_path = None ) : [EOL] [docstring] [EOL] if modifier == [string] : [EOL] occurrence_type = [string] [EOL] [EOL] elif modifier == [string] : [EOL] occurrence_type = [string] [EOL] [EOL] elif modifier in ( [string] , [string] ) : [EOL] [comment] [EOL] occurrence_type = [string] [EOL] [EOL] else : [EOL] occurrence_type = [string] [EOL] [EOL] queries = list ( ) [EOL] has_escape_comma_ = has_escape_comma ( value ) [EOL] [EOL] if has_escape_comma_ : [EOL] value = value . replace ( [string] , escape_comma_replacer ) [EOL] [EOL] for val in value . split ( [string] ) : [EOL] if has_escape_comma_ and has_escape_comma ( val ) : [EOL] val = val . replace ( escape_comma_replacer , [string] ) [EOL] [EOL] query = self . _make_codeableconcept_query ( path , val . strip ( ) , nested = nested , modifier = modifier , logic_in_path = logic_in_path , ) [EOL] queries . append ( query ) [EOL] [EOL] if len ( queries ) == [number] : [EOL] return occurrence_type , queries [ [number] ] [EOL] [EOL] if nested : [EOL] combined = { [string] : { [string] : path , [string] : { [string] : { [string] : [number] , [string] : list ( ) } } , } } [EOL] should_path = combined [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] else : [EOL] combined = { [string] : { [string] : [number] , [string] : list ( ) } } [EOL] should_path = combined [ [string] ] [ [string] ] [EOL] [EOL] for query in queries : [EOL] if [string] in query : [EOL] query_ = query [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] else : [EOL] query_ = query [ [string] ] [ [string] ] [EOL] if len ( query_ ) == [number] : [EOL] should_path . append ( query_ [ [number] ] ) [EOL] elif len ( query_ ) > [number] : [EOL] should_path . append ( { [string] : { [string] : query_ } } ) [EOL] [EOL] return occurrence_type , combined [EOL] [EOL] def _make_codeableconcept_query ( self , path , value , nested = None , modifier = None , logic_in_path = None ) : [EOL] [docstring] [EOL] matches = list ( ) [EOL] [EOL] if modifier == [string] : [EOL] [comment] [EOL] matches . append ( { [string] : { path + [string] : value } } ) [EOL] else : [EOL] coding_query = self . _make_coding_query ( path + [string] , value , nested = True , logic_in_path = logic_in_path ) [EOL] [EOL] matches . append ( coding_query ) [EOL] [EOL] if nested : [EOL] query = { [string] : { [string] : path , [string] : { [string] : { [string] : matches } } } } [EOL] else : [EOL] query = { [string] : { [string] : matches } } [EOL] return query [EOL] [EOL] def make_coding_query ( self , path , value , nested = None , modifier = None , logic_in_path = None ) : [EOL] queries = list ( ) [EOL] has_escape_comma_ = has_escape_comma ( value ) [EOL] [EOL] if has_escape_comma_ : [EOL] value = value . replace ( [string] , escape_comma_replacer ) [EOL] [EOL] for val in value . split ( [string] ) : [EOL] if has_escape_comma_ and has_escape_comma ( val ) : [EOL] val = val . replace ( escape_comma_replacer , [string] ) [EOL] [EOL] query = self . _make_coding_query ( path , val . strip ( ) , nested = nested , modifier = modifier , logic_in_path = logic_in_path , ) [EOL] queries . append ( query ) [EOL] [EOL] if len ( queries ) == [number] : [EOL] [comment] [EOL] return [string] , queries [ [number] ] [EOL] [EOL] if nested : [EOL] combined = { [string] : { [string] : path , [string] : { [string] : { [string] : [number] , [string] : list ( ) } } , } } [EOL] should_path = combined [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] else : [EOL] combined = { [string] : { [string] : [number] , [string] : list ( ) } } [EOL] should_path = combined [ [string] ] [ [string] ] [EOL] [EOL] for query in queries : [EOL] if [string] in query : [EOL] query_bool = query [ [string] ] [ [string] ] [ [string] ] [EOL] else : [EOL] query_bool = query [ [string] ] [EOL] [EOL] should_path . append ( { [string] : query_bool } ) [EOL] [EOL] return [string] , combined [EOL] [EOL] def _make_coding_query ( self , path , value , nested = None , modifier = None , logic_in_path = None ) : [EOL] [docstring] [EOL] if modifier == [string] : [EOL] match_key = [string] [EOL] elif modifier == [string] : [EOL] match_key = [string] [EOL] elif modifier in ( [string] , [string] ) : [EOL] [comment] [EOL] match_key = [string] [EOL] else : [EOL] match_key = [string] [EOL] [EOL] matches = list ( ) [EOL] has_pipe = [string] in value [EOL] [EOL] if modifier == [string] : [EOL] [EOL] matches . append ( { [string] : { path + [string] : value } } ) [EOL] [EOL] elif has_pipe : [EOL] [EOL] if value . startswith ( [string] ) : [EOL] matches . append ( { [string] : { path + [string] : value [ [number] : ] } } ) [EOL] elif value . endswith ( [string] ) : [EOL] matches . append ( { [string] : { path + [string] : value [ : - [number] ] } } ) [EOL] else : [EOL] parts = value . split ( [string] ) [EOL] try : [EOL] matches . append ( { [string] : { path + [string] : parts [ [number] ] } } ) [EOL] [EOL] matches . append ( { [string] : { path + [string] : parts [ [number] ] } } ) [EOL] [EOL] except IndexError : [EOL] pass [EOL] [EOL] else : [EOL] matches . append ( { [string] : { path + [string] : value } } ) [EOL] [EOL] if nested : [EOL] query = { [string] : { [string] : path , [string] : { [string] : { match_key : matches } } } } [EOL] else : [EOL] query = { [string] : { match_key : matches } } [EOL] [EOL] return query [EOL] [EOL] def _make_contactpoint_query ( self , path , value , logic_in_path = None , nested = None , modifier = None ) : [EOL] [docstring] [EOL] occurrence_type = [string] [EOL] [EOL] if modifier == [string] : [EOL] occurrence_type = [string] [EOL] [EOL] elif modifier == [string] : [EOL] occurrence_type = [string] [EOL] [EOL] elif modifier in ( [string] , [string] ) : [EOL] [comment] [EOL] occurrence_type = [string] [EOL] [EOL] matches = list ( ) [EOL] matches . append ( { [string] : { path + [string] : value } } ) [EOL] [EOL] if logic_in_path : [EOL] parts = logic_in_path . split ( [string] ) [EOL] matches . append ( { [string] : { path + [string] + parts [ [number] ] : parts [ [number] ] } } ) [EOL] [EOL] if nested : [EOL] query = { [string] : { [string] : path , [string] : { [string] : { [string] : matches } } } } [EOL] else : [EOL] query = { [string] : { [string] : matches } } [EOL] [EOL] return occurrence_type , query [EOL] [EOL] def make_date_query ( self , path , value , modifier = None ) : [EOL] [docstring] [EOL] queries = list ( ) [EOL] has_escape_comma_ = has_escape_comma ( value ) [EOL] if has_escape_comma_ : [EOL] value = value . replace ( [string] , escape_comma_replacer ) [EOL] [EOL] for val in value . split ( [string] ) : [EOL] if has_escape_comma_ and has_escape_comma ( val ) : [EOL] val = val . replace ( escape_comma_replacer , [string] ) [EOL] [EOL] occurance_type , query = self . _make_date_query ( path , val . strip ( ) , modifier = modifier ) [EOL] queries . append ( ( occurance_type , query ) ) [EOL] [EOL] if len ( queries ) == [number] : [EOL] return queries [ [number] ] [EOL] elif len ( queries ) > [number] : [EOL] same_occurance = len ( set ( map ( lambda x : x [ [number] ] , queries ) ) ) == [number] [EOL] combined = { [string] : { [string] : list ( ) , [string] : [number] } } [EOL] for occurance_type , query in queries : [EOL] if same_occurance or occurance_type in ( [string] , [string] ) : [EOL] combined [ [string] ] [ [string] ] . append ( query ) [EOL] else : [EOL] query_ = { [string] : { [string] : query } } [EOL] combined [ [string] ] [ [string] ] . append ( query_ ) [EOL] [comment] [EOL] return [string] , combined [EOL] [EOL] def _make_date_query ( self , path , value , modifier = None ) : [EOL] [docstring] [EOL] occurance_type = [string] [EOL] prefix = [string] [EOL] [EOL] if value [ [number] : [number] ] in FSPR_VALUE_PRIFIXES_MAP : [EOL] prefix = value [ [number] : [number] ] [EOL] value = value [ [number] : ] [EOL] _iso8601 = dt_parse ( value ) . isoformat ( ) [EOL] [EOL] if [string] in _iso8601 : [EOL] parts = _iso8601 . split ( [string] ) [EOL] timezone = [string] . format ( parts [ [number] ] ) [EOL] value = parts [ [number] ] [EOL] else : [EOL] timezone = None [EOL] value = _iso8601 [EOL] [EOL] query = dict ( ) [EOL] [EOL] if prefix in ( [string] , [string] ) : [EOL] query [ [string] ] = { path : { FSPR_VALUE_PRIFIXES_MAP . get ( [string] ) : value , FSPR_VALUE_PRIFIXES_MAP . get ( [string] ) : value , } } [EOL] [EOL] elif prefix in ( [string] , [string] , [string] , [string] ) : [EOL] query [ [string] ] = { path : { FSPR_VALUE_PRIFIXES_MAP . get ( prefix ) : value } } [EOL] [EOL] if timezone : [EOL] query [ [string] ] [ path ] [ [string] ] = timezone [EOL] [EOL] if ( prefix != [string] and modifier == [string] ) or ( prefix == [string] and modifier != [string] ) : [EOL] occurance_type = [string] [EOL] [EOL] return occurance_type , query [EOL] [EOL] def _make_exists_query ( self , path , value , nested , modifier = None ) : [EOL] [docstring] [EOL] query = dict ( ) [EOL] occurrence_type = [string] [EOL] exists_q = { [string] : { [string] : path } } [EOL] [EOL] if ( modifier == [string] and value == [string] ) or ( modifier == [string] and value == [string] ) : [EOL] occurrence_type = [string] [EOL] [EOL] if nested : [EOL] query = { [string] : { [string] : path , [string] : exists_q } } [EOL] else : [EOL] query = exists_q [EOL] [EOL] return occurrence_type , query [EOL] [EOL] def _make_humanname_query ( self , path , value , nested = None , modifier = None ) : [EOL] [docstring] [EOL] fullpath = path + [string] [EOL] if len ( path . split ( [string] ) ) == [number] : [EOL] fullpath = path + [string] [EOL] else : [EOL] fullpath = path [EOL] path = [string] . join ( path . split ( [string] ) [ : - [number] ] ) [EOL] [EOL] if fullpath . split ( [string] ) [ - [number] ] == [string] : [EOL] array_ = True [EOL] else : [EOL] array_ = False [EOL] [EOL] if fullpath . split ( [string] ) [ - [number] ] == [string] : [EOL] occurrence_type , query = self . _make_match_query ( fullpath , value , modifier ) [EOL] [EOL] else : [EOL] [EOL] occurrence_type , query = self . _make_token_query ( fullpath , value , array_ = array_ , modifier = modifier ) [EOL] [EOL] if nested : [EOL] query = { [string] : { [string] : path , [string] : query } } [EOL] return occurrence_type , query [EOL] [EOL] def _make_identifier_query ( self , path , value , nested = None , modifier = None ) : [EOL] [docstring] [EOL] matches = list ( ) [EOL] has_pipe = [string] in value [EOL] [EOL] if modifier == [string] : [EOL] occurrence_type = [string] [EOL] else : [EOL] occurrence_type = [string] [EOL] [EOL] if modifier == [string] : [EOL] [comment] [EOL] matches . append ( { [string] : { path + [string] : value } } ) [EOL] [EOL] elif has_pipe : [EOL] if value . startswith ( [string] ) : [EOL] matches . append ( { [string] : { path + [string] : value [ [number] : ] } } ) [EOL] elif value . endswith ( [string] ) : [EOL] matches . append ( { [string] : { path + [string] : value [ : - [number] ] } } ) [EOL] else : [EOL] parts = value . split ( [string] ) [EOL] try : [EOL] matches . append ( { [string] : { path + [string] : parts [ [number] ] } } ) [EOL] [EOL] matches . append ( { [string] : { path + [string] : parts [ [number] ] } } ) [EOL] [EOL] except IndexError : [EOL] pass [EOL] else : [EOL] matches . append ( { [string] : { path + [string] : value } } ) [EOL] [EOL] if nested : [EOL] query = { [string] : { [string] : path , [string] : { [string] : { [string] : matches } } } } [EOL] else : [EOL] if len ( matches ) == [number] : [EOL] query = matches [ [number] ] [EOL] else : [EOL] query = { [string] : { [string] : matches } } [EOL] [EOL] return occurrence_type , query [EOL] [EOL] def _make_match_query ( self , path , value , modifier = None ) : [EOL] [docstring] [EOL] [EOL] if modifier == [string] : [EOL] occurrence_type = [string] [EOL] else : [EOL] occurrence_type = [string] [EOL] [EOL] query = { [string] : { path : value } } [EOL] [EOL] return occurrence_type , query [EOL] [EOL] def make_number_query ( self , path , value , modifier = None ) : [EOL] [docstring] [EOL] queries = list ( ) [EOL] mapped_definition = self . get_mapped_definition ( path ) [EOL] for val in value . split ( [string] ) : [EOL] occurrence_type , query = self . _make_number_query ( path , val . strip ( ) , mapped_definition = mapped_definition , modifier = modifier , ) [EOL] queries . append ( ( occurrence_type , query ) ) [EOL] [EOL] if len ( queries ) == [number] : [EOL] return queries [ [number] ] [EOL] [EOL] elif len ( queries ) > [number] : [EOL] combined = { [string] : { [string] : list ( ) , [string] : [number] } } [EOL] for occurrence_type , query in queries : [EOL] if occurrence_type == [string] : [EOL] combined [ [string] ] [ [string] ] . append ( { [string] : { [string] : query } } ) [EOL] else : [EOL] combined [ [string] ] [ [string] ] . append ( query ) [EOL] [comment] [EOL] return [string] , combined [EOL] [EOL] def _make_number_query ( self , path , value , mapped_definition , modifier = None ) : [EOL] [docstring] [EOL] occurrence_type = [string] [EOL] prefix , val = self . parse_prefix ( value ) [EOL] path_ = path [EOL] if [string] in mapped_definition : [EOL] if [string] in mapped_definition [ [string] ] : [EOL] path_ = path + [string] [EOL] type_ = mapped_definition [ [string] ] [ [string] ] [ [string] ] [EOL] else : [EOL] type_ = mapped_definition [ [string] ] [EOL] [EOL] if type_ == [string] : [EOL] val = float ( val ) [EOL] else : [EOL] val = int ( val ) [EOL] [EOL] query = dict ( ) [EOL] if prefix in ( [string] , [string] ) : [EOL] query [ [string] ] = { path_ : { FSPR_VALUE_PRIFIXES_MAP . get ( [string] ) : val , FSPR_VALUE_PRIFIXES_MAP . get ( [string] ) : val , } } [EOL] [EOL] elif prefix in ( [string] , [string] , [string] , [string] ) : [EOL] query [ [string] ] = { path_ : { FSPR_VALUE_PRIFIXES_MAP . get ( prefix ) : val } } [EOL] [EOL] if ( prefix != [string] and modifier == [string] ) or ( prefix == [string] and modifier != [string] ) : [EOL] occurrence_type = [string] [EOL] [EOL] return occurrence_type , query [EOL] [EOL] def make_quantity_query ( self , path , value , modifier = None ) : [EOL] [docstring] [EOL] queries = list ( ) [EOL] has_escape_comma_ = has_escape_comma ( value ) [EOL] if has_escape_comma_ : [EOL] value = value . replace ( [string] , escape_comma_replacer ) [EOL] [EOL] for val in value . split ( [string] ) : [EOL] if has_escape_comma_ and has_escape_comma ( val ) : [EOL] val = val . replace ( escape_comma_replacer , [string] ) [EOL] [EOL] query = self . _make_quantity_query ( path , val . strip ( ) , modifier = modifier ) [EOL] queries . append ( query ) [EOL] [EOL] if len ( queries ) == [number] : [EOL] [comment] [EOL] return [string] , queries [ [number] ] [EOL] elif len ( queries ) > [number] : [EOL] combined = { [string] : { [string] : list ( ) , [string] : [number] } } [EOL] for query in queries : [EOL] combined [ [string] ] [ [string] ] . append ( query ) [EOL] [comment] [EOL] return [string] , combined [EOL] [EOL] def _make_quantity_query ( self , path , value , modifier = None ) : [EOL] [docstring] [EOL] matches = list ( ) [EOL] value_parts = value . split ( [string] ) [EOL] mapped_definition = self . get_mapped_definition ( path ) [EOL] query = { [string] : { } } [EOL] if value_parts [ [number] ] : [EOL] occurrence_type , value_query = self . _make_number_query ( path , value_parts [ [number] ] , mapped_definition = mapped_definition , modifier = modifier , ) [EOL] query [ [string] ] = { occurrence_type : [ value_query ] } [EOL] [comment] [EOL] system = None [EOL] code = None [EOL] unit = None [EOL] [EOL] if len ( value_parts ) == [number] : [EOL] system = value_parts [ [number] ] [EOL] code = value_parts [ [number] ] [EOL] elif len ( value_parts ) == [number] : [EOL] unit = value_parts [ [number] ] [EOL] [EOL] if system : [EOL] matches . append ( { [string] : { path + [string] : system } } ) [EOL] if code : [EOL] matches . append ( { [string] : { path + [string] : code } } ) [EOL] if unit : [EOL] matches . append ( { [string] : { path + [string] : unit } } ) [EOL] [EOL] if matches : [EOL] if modifier == [string] : [EOL] if [string] in query [ [string] ] : [EOL] query [ [string] ] = { [string] : list ( ) } [EOL] query [ [string] ] [ [string] ] . extend ( matches ) [EOL] [EOL] else : [EOL] if [string] not in query [ [string] ] : [EOL] query [ [string] ] . update ( { [string] : list ( ) } ) [EOL] [EOL] query [ [string] ] [ [string] ] . extend ( matches ) [EOL] [EOL] return query [EOL] [EOL] def make_reference_query ( self , path , value , nested = None , modifier = None ) : [EOL] [docstring] [EOL] occurrence_type = [string] [EOL] queries = list ( ) [EOL] has_escape_comma_ = has_escape_comma ( value ) [EOL] [EOL] if has_escape_comma_ : [EOL] value = value . replace ( [string] , escape_comma_replacer ) [EOL] [EOL] for val in value . split ( [string] ) : [EOL] if has_escape_comma_ and has_escape_comma ( val ) : [EOL] val = val . replace ( escape_comma_replacer , [string] ) [EOL] [EOL] query = self . _make_reference_query ( path , val . strip ( ) , nested = nested ) [EOL] queries . append ( query ) [EOL] [EOL] if modifier == [string] : [EOL] occurrence_type = [string] [EOL] [EOL] if len ( queries ) == [number] : [EOL] return occurrence_type , queries [ [number] ] [EOL] elif len ( queries ) > [number] : [EOL] if nested : [EOL] combined = { [string] : { [string] : path , [string] : { [string] : { [string] : [number] , [string] : list ( ) } } , } } [EOL] should_path = combined [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] else : [EOL] combined = { [string] : { [string] : [number] , [string] : list ( ) } } [EOL] should_path = combined [ [string] ] [ [string] ] [EOL] [EOL] for query in queries : [EOL] if [string] in query : [EOL] query = query [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] should_path . append ( query ) [EOL] [EOL] return occurrence_type , combined [EOL] [EOL] def _make_reference_query ( self , path , value , nested = None ) : [EOL] [docstring] [EOL] fullpath = path + [string] [EOL] [EOL] query = dict ( match = { fullpath : value } ) [EOL] [EOL] if nested : [EOL] query = { [string] : { [string] : path , [string] : { [string] : { [string] : query } } } } [EOL] [EOL] return query [EOL] [EOL] def _make_term_query ( self , path , value , array_ = None ) : [EOL] [docstring] [EOL] [comment] [EOL] use_terms = array_ or type ( value ) in ( list , tuple , set ) [EOL] [EOL] if use_terms : [EOL] if type ( value ) not in ( list , tuple , set ) : [EOL] terms = [ value ] [EOL] else : [EOL] terms = value [EOL] query = { [string] : { path : terms } } [EOL] else : [EOL] query = { [string] : { path : value } } [EOL] [EOL] return query [EOL] [EOL] def _make_token_query ( self , path , value , array_ = None , modifier = None ) : [EOL] [docstring] [EOL] occurrence_type = [string] [EOL] has_escape_comma_ = has_escape_comma ( value ) [EOL] if has_escape_comma_ : [EOL] value = value . replace ( [string] , escape_comma_replacer ) [EOL] [EOL] if value in ( [string] , [string] ) : [EOL] if value == [string] : [EOL] value = True [EOL] else : [EOL] value = False [EOL] elif isinstance ( value , ( str , bytes ) ) and [string] in value : [EOL] container = list ( ) [EOL] for val in value . split ( [string] ) : [EOL] if has_escape_comma_ and has_escape_comma ( val ) : [EOL] val = val . replace ( escape_comma_replacer , [string] ) [EOL] container . append ( val . strip ( ) ) [EOL] value = container [EOL] [EOL] if modifier == [string] : [EOL] occurrence_type = [string] [EOL] else : [EOL] occurrence_type = [string] [EOL] [EOL] term_query = self . _make_term_query ( path , value , array_ ) [EOL] [EOL] query = [ term_query ] [EOL] return occurrence_type , query [EOL] [EOL] [comment] [EOL] [EOL] def build ( self ) : [EOL] [docstring] [EOL] for param_name , value in self . params . items ( ) : [EOL] [docstring] [EOL] query = None [EOL] [EOL] parts = param_name . split ( [string] ) [EOL] try : [EOL] param_name = parts [ [number] ] [EOL] modifier = parts [ [number] ] [EOL] except IndexError : [EOL] modifier = None [EOL] [EOL] query_meta = self . resolve_query_meta ( param_name ) [EOL] occurrence_type , query = self . _build_query ( param_name , value , modifier , query_meta = query_meta ) [EOL] [EOL] [comment] [EOL] assert query , [string] . format ( query ) [EOL] if isinstance ( query , ( tuple , list ) ) : [EOL] self . query_tree [ [string] ] [ occurrence_type ] . extend ( query ) [EOL] else : [EOL] self . query_tree [ [string] ] [ occurrence_type ] . append ( query ) [EOL] [EOL] [comment] [EOL] query = self . _make_term_query ( self . field_name + [string] , self . resource_type ) [EOL] [EOL] [comment] [EOL] self . query_tree [ [string] ] [ [string] ] . append ( query ) [EOL] [EOL] query_tree = copy . deepcopy ( self . query_tree ) [EOL] for ot in self . query_tree [ [string] ] : [EOL] if len ( query_tree [ [string] ] [ ot ] ) == [number] : [EOL] del query_tree [ [string] ] [ ot ] [EOL] [EOL] return query_tree [EOL] [EOL] def _build_query ( self , param_name , value , modifier , query_meta ) : [EOL] [docstring] [EOL] path , raw_path , param_type , logic_in_path , map_cls = query_meta [EOL] [EOL] if modifier in ( [string] , [string] ) : [EOL] [EOL] nested = self . is_nested_mapping ( path = path ) [EOL] [EOL] occurrence_type , query = self . _make_exists_query ( path = path , value = value , nested = nested , modifier = modifier ) [EOL] [EOL] elif param_type == [string] : [EOL] occurrence_type , query = self . make_date_query ( path , value , modifier ) [EOL] [EOL] elif param_type == [string] : [EOL] [EOL] nested = self . is_nested_mapping ( path ) [EOL] [EOL] occurrence_type , query = self . make_reference_query ( path , value , nested = nested , modifier = modifier ) [EOL] [EOL] elif param_type == [string] : [EOL] [EOL] meta_info = fhir_search_path_meta_info ( raw_path ) [EOL] array_ = meta_info [ [number] ] is True [EOL] [EOL] occurrence_type , query = self . _make_token_query ( path , value , array_ = array_ , modifier = modifier ) [EOL] [EOL] elif param_type == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] occurrence_type , query = self . build_string_query ( value , path , raw_path , logic_in_path = logic_in_path , map_cls = map_cls , modifier = modifier , ) [EOL] [EOL] elif param_type == [string] : [EOL] [EOL] occurrence_type , query = self . make_quantity_query ( path , value , modifier = modifier ) [EOL] [EOL] elif param_type == [string] : [EOL] occurrence_type , query = self . make_number_query ( path , value , modifier = modifier ) [EOL] [EOL] elif param_type == [string] : [EOL] [comment] [EOL] occurrence_type , query = self . build_token_query ( value , path , raw_path , logic_in_path = logic_in_path , map_cls = map_cls , modifier = modifier , ) [EOL] [EOL] elif param_type == [string] : [EOL] occurrence_type , query = self . build_composite_query ( value , param_name , path ) [EOL] [EOL] return occurrence_type , query [EOL] [EOL] def build_composite_query ( self , value , param_name , path ) : [EOL] [docstring] [EOL] params = None [EOL] queries = list ( ) [EOL] if param_name . startswith ( [string] ) : [EOL] parts = param_name . split ( [string] ) [EOL] params = ( ( parts [ [number] ] , self . resolve_query_meta ( parts [ [number] ] ) ) , ( [string] . join ( parts [ [number] : ] ) , self . resolve_query_meta ( [string] . join ( parts [ [number] : ] ) ) ) , ) [EOL] [EOL] assert params is not None [EOL] [EOL] for composite_val in value . split ( [string] ) : [EOL] value_parts = composite_val . split ( [string] ) [EOL] [EOL] occurrence_type , query1 = self . _build_query ( params [ [number] ] [ [number] ] , value_parts [ [number] ] , modifier = None , query_meta = params [ [number] ] [ [number] ] ) [EOL] [EOL] occurrence_type , query2 = self . _build_query ( params [ [number] ] [ [number] ] , value_parts [ [number] ] , modifier = None , query_meta = params [ [number] ] [ [number] ] ) [EOL] queries . append ( self . merge_query ( query1 , query2 ) ) [EOL] [EOL] if len ( queries ) == [number] : [EOL] return [string] , queries [ [number] ] [EOL] else : [EOL] [EOL] query = dict ( bool = dict ( should = list ( ) , minimum_should_match = [number] ) ) [EOL] [EOL] for qr in queries : [EOL] query [ [string] ] [ [string] ] . append ( qr ) [EOL] [EOL] return [string] , query [EOL] [EOL] def build_token_query ( self , value , path , raw_path , logic_in_path = None , map_cls = None , modifier = None ) : [EOL] [docstring] [EOL] mapped_definition = self . get_mapped_definition ( path ) [EOL] map_properties = mapped_definition . get ( [string] , None ) [EOL] nested = self . is_nested_mapping ( mapped_definition = mapped_definition ) [EOL] [EOL] if ( map_properties == mapping_types . Identifier . get ( [string] ) or map_cls == [string] ) : [EOL] query = self . _make_identifier_query ( path , value , nested = nested , modifier = modifier ) [EOL] elif ( map_properties == mapping_types . CodeableConcept . get ( [string] ) or map_cls == [string] ) : [EOL] [EOL] query = self . make_codeableconcept_query ( path , value , nested = nested , modifier = modifier , logic_in_path = logic_in_path , ) [EOL] [EOL] elif ( map_properties == mapping_types . Coding . get ( [string] ) or map_cls == [string] ) : [EOL] [EOL] query = self . make_coding_query ( path , value , nested = nested , modifier = modifier , logic_in_path = logic_in_path , ) [EOL] [EOL] elif ( map_properties == mapping_types . Address . get ( [string] ) or map_cls == [string] ) : [EOL] [comment] [EOL] query = self . _make_address_query ( path , value , logic_in_path = logic_in_path , nested = nested , modifier = modifier , ) [EOL] [EOL] elif ( map_properties == mapping_types . ContactPoint . get ( [string] ) or map_cls == [string] ) : [EOL] [comment] [EOL] query = self . _make_contactpoint_query ( path , value , logic_in_path = logic_in_path , nested = nested , modifier = modifier , ) [EOL] [EOL] elif ( map_properties == mapping_types . HumanName . get ( [string] ) or map_cls == [string] ) : [EOL] [comment] [EOL] query = self . _make_humanname_query ( path , value , nested = nested , modifier = modifier ) [EOL] [EOL] else : [EOL] path_info = fhir_search_path_meta_info ( raw_path ) [EOL] array_ = path_info [ [number] ] is True [EOL] query = self . _make_token_query ( path , value , array_ = array_ , modifier = modifier ) [EOL] [EOL] return query [EOL] [EOL] def build_string_query ( self , value , path , raw_path , logic_in_path = None , map_cls = None , modifier = None ) : [EOL] [docstring] [EOL] mapped_definition = self . get_mapped_definition ( path ) [EOL] map_properties = mapped_definition . get ( [string] , None ) [EOL] nested = self . is_nested_mapping ( mapped_definition = mapped_definition ) [EOL] [EOL] if map_properties in ( mapping_types . SearchableText , mapping_types . Text ) : [EOL] [EOL] query = self . _make_match_query ( path , value , modifier ) [EOL] [EOL] elif ( map_properties == mapping_types . Address . get ( [string] ) or map_cls == [string] ) : [EOL] [comment] [EOL] query = self . _make_address_query ( path , value , logic_in_path = logic_in_path , nested = nested , modifier = modifier , ) [EOL] [EOL] elif ( map_properties == mapping_types . HumanName . get ( [string] ) or map_cls == [string] ) : [EOL] [comment] [EOL] query = self . _make_humanname_query ( path , value , nested = nested , modifier = modifier ) [EOL] [EOL] else : [EOL] path_info = fhir_search_path_meta_info ( raw_path ) [EOL] array_ = path_info [ [number] ] is True [EOL] query = self . _make_token_query ( path , value , array_ = array_ , modifier = modifier ) [EOL] [EOL] return query [EOL] [EOL] def clean_params ( self ) : [EOL] [docstring] [EOL] unwanted = list ( ) [EOL] cleaned_params = list ( ) [EOL] for index , item in enumerate ( self . params ) : [EOL] param , value = item [EOL] [comment] [EOL] [comment] [EOL] if value and [string] in value : [EOL] value = value . replace ( [string] , [string] ) [EOL] [EOL] parts = param . split ( [string] ) [EOL] [EOL] if parts [ [number] ] not in FHIR_SEARCH_PARAMETER_SEARCHABLE : [EOL] unwanted . append ( ( param , ERROR_PARAM_UNKNOWN ) ) [EOL] continue [EOL] [EOL] if parts [ [number] ] in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) : [EOL] cleaned_params . append ( item ) [EOL] [EOL] continue [EOL] [EOL] supported_paths = FHIR_SEARCH_PARAMETER_SEARCHABLE [ parts [ [number] ] ] [ [number] ] [EOL] [EOL] for path in supported_paths : [EOL] if path . startswith ( self . resource_type ) : [EOL] cleaned_params . append ( item ) [EOL] break [EOL] else : [EOL] unwanted . append ( ( param , ERROR_PARAM_UNSUPPORTED ) ) [EOL] [EOL] FHIR_FIELD_DEBUG and unwanted and LOGGER . info ( [string] [string] . format ( unwanted ) ) [EOL] [EOL] [comment] [EOL] self . params = cleaned_params [EOL] [EOL] return unwanted [EOL] [EOL] def validate ( self ) : [EOL] [docstring] [EOL] unwanted = self . clean_params ( ) [EOL] [EOL] if len ( unwanted ) > [number] : [EOL] errors = self . process_error_message ( unwanted ) [EOL] [EOL] raise SearchQueryValidationError ( f" [string] { errors }" ) [EOL] [EOL] error_fields = list ( ) [EOL] [EOL] for param , value in self . params : [EOL] [docstring] [EOL] parts = param . split ( [string] ) [EOL] try : [EOL] name = parts [ [number] ] [EOL] modifier = parts [ [number] ] [EOL] except IndexError : [EOL] modifier = None [EOL] [EOL] if modifier and ( modifier not in SEARCH_PARAM_MODIFIERS ) : [EOL] error_fields . append ( ( name , ( [string] [string] . format ( SEARCH_PARAM_MODIFIERS ) ) , ) ) [EOL] continue [EOL] [EOL] if modifier in ( [string] , [string] ) and value not in ( [string] , [string] ) : [EOL] error_fields . append ( ( param , ERROR_PARAM_WRONG_DATATYPE ) ) [EOL] continue [EOL] [EOL] param_type = FHIR_SEARCH_PARAMETER_SEARCHABLE [ name ] [ [number] ] [EOL] [EOL] if param_type == [string] : [EOL] self . validate_date ( name , modifier , value , error_fields ) [EOL] elif param_type == [string] : [EOL] self . validate_token ( name , modifier , value , error_fields ) [EOL] [EOL] if error_fields : [EOL] errors = self . process_error_message ( error_fields ) [EOL] raise SearchQueryValidationError ( ( [string] ) . format ( errors ) ) [EOL] [EOL] def validate_date ( self , field , modifier , value , container ) : [EOL] [docstring] [EOL] if modifier and modifier not in ( [string] , [string] ) : [EOL] container . append ( ( field , ( [string] [string] ) , ) ) [EOL] return [EOL] [EOL] for val in value . split ( [string] ) : [EOL] self . _validate_date ( field , val . strip ( ) , container ) [EOL] [EOL] def _validate_date ( self , field , value , container ) : [EOL] [docstring] [EOL] prefix = value [ [number] : [number] ] [EOL] if prefix in FSPR_VALUE_PRIFIXES_MAP : [EOL] date_val = value [ [number] : ] [EOL] else : [EOL] date_val = value [EOL] [EOL] try : [EOL] dt_parse ( date_val ) [EOL] except ValueError : [EOL] container . append ( ( field , [string] . format ( value ) ) ) [EOL] [EOL] def validate_token ( self , field , modifier , value , container ) : [EOL] [docstring] [EOL] has_escape_comma_ = has_escape_comma ( value ) [EOL] [EOL] if has_escape_comma_ : [EOL] value = value . replace ( [string] , escape_comma_replacer ) [EOL] [EOL] for val in value . split ( [string] ) : [EOL] if has_escape_comma_ and has_escape_comma ( val ) : [EOL] val = val . replace ( escape_comma_replacer , [string] ) [EOL] self . _validate_token ( field , modifier , val , container ) [EOL] [EOL] def _validate_token ( self , field , modifier , value , container ) : [EOL] [docstring] [EOL] if modifier == [string] and [string] in value : [EOL] container . append ( ( field , ( [string] [string] ) , ) ) [EOL] elif len ( value . split ( [string] ) ) > [number] : [EOL] [EOL] container . append ( ( field , [string] ) ) [EOL] [EOL] def process_error_message ( self , errors ) : [EOL] [docstring] [EOL] container = list ( ) [EOL] for field , code in errors : [EOL] try : [EOL] container . append ( { [string] : field , [string] : ERROR_MESSAGES [ code ] , } ) [EOL] except KeyError : [EOL] container . append ( { [string] : field , [string] : code , } ) [EOL] return container [EOL] [EOL] def find_path ( self , param_name ) : [EOL] [docstring] [EOL] if param_name in FHIR_SEARCH_PARAMETER_SEARCHABLE : [EOL] paths = FHIR_SEARCH_PARAMETER_SEARCHABLE [ param_name ] [ [number] ] [EOL] [EOL] for path in paths : [EOL] [EOL] if path . startswith ( [string] ) : [EOL] return path [EOL] [EOL] if path . startswith ( self . resource_type ) : [EOL] return path [EOL] [EOL] def resolve_query_meta ( self , param_name ) : [EOL] [docstring] [EOL] param_type = FHIR_SEARCH_PARAMETER_SEARCHABLE [ param_name ] [ [number] ] [EOL] map_cls = None [EOL] logic_in_path = None [EOL] [comment] [EOL] replacer = [string] [EOL] raw_path = self . find_path ( param_name ) [EOL] [EOL] if PATH_WITH_DOT_AS . search ( raw_path ) : [EOL] word = PATH_WITH_DOT_AS . search ( raw_path ) . group ( ) [EOL] path = raw_path . replace ( word , replacer ) [EOL] [EOL] new_word = word [ [number] ] . upper ( ) + word [ [number] : - [number] ] [EOL] path = path . replace ( replacer , new_word ) [EOL] [EOL] logic_in_path = [string] [EOL] [EOL] elif PATH_WITH_DOT_IS . search ( raw_path ) : [EOL] [EOL] word = PATH_WITH_DOT_IS . search ( raw_path ) . group ( ) [EOL] path = raw_path . replace ( word , replacer ) [EOL] [EOL] new_word = word [ [number] ] . upper ( ) + word [ [number] : - [number] ] [EOL] path = path . replace ( replacer , new_word ) [EOL] [EOL] logic_in_path = [string] [EOL] [EOL] elif PATH_WITH_DOT_WHERE . search ( raw_path ) : [EOL] [EOL] word = PATH_WITH_DOT_WHERE . search ( raw_path ) . group ( ) [EOL] path = raw_path . replace ( word , [string] ) [EOL] parts = word [ [number] : - [number] ] . split ( [string] ) [EOL] [EOL] logic_in_path = [string] . join ( [ [string] , parts [ [number] ] , ast . literal_eval ( parts [ [number] ] ) ] ) [EOL] [EOL] else : [EOL] path = raw_path [EOL] [EOL] if logic_in_path in ( [string] , [string] ) : [EOL] [comment] [EOL] map_name = path . split ( [string] ) [ [number] ] [EOL] [EOL] if re . search ( [string] , map_name ) : [EOL] param_type = [string] [EOL] if [string] in map_name : [EOL] map_cls = [string] [EOL] [EOL] elif re . search ( [string] , map_name ) : [EOL] param_type = [string] [EOL] if [string] in map_name : [EOL] map_cls = [string] [EOL] [EOL] elif re . search ( [string] , map_name ) : [EOL] param_type = [string] [EOL] if [string] in map_name : [EOL] map_cls = [string] [EOL] [EOL] elif [string] in map_name : [EOL] param_type = [string] [EOL] [EOL] elif [string] in map_name : [EOL] param_type = [string] [EOL] map_cls = [string] [EOL] [EOL] [comment] [EOL] if path . startswith ( [string] ) : [EOL] path = path . replace ( [string] , self . field_name ) [EOL] else : [EOL] path = path . replace ( self . resource_type , self . field_name ) [EOL] [EOL] return path , raw_path , param_type , logic_in_path , map_cls [EOL] [EOL] def get_mapped_definition ( self , path ) : [EOL] [docstring] [EOL] mapping = fhir_resource_mapping ( self . resource_type ) [EOL] mapped_field = path . replace ( self . field_name + [string] , [string] ) . split ( [string] ) [ [number] ] [EOL] [EOL] mapped_definition = mapping [ [string] ] [ mapped_field ] [EOL] [EOL] return mapped_definition [EOL] [EOL] def is_nested_mapping ( self , path = None , mapped_definition = None ) : [EOL] [docstring] [EOL] if path : [EOL] mapped_definition = self . get_mapped_definition ( path ) [EOL] [EOL] if [string] in mapped_definition : [EOL] return mapped_definition [ [string] ] == [string] [EOL] [EOL] return False [EOL] [EOL] def parse_prefix ( self , value , default = [string] ) : [EOL] [docstring] [EOL] if value [ [number] : [number] ] in FSPR_VALUE_PRIFIXES_MAP : [EOL] prefix = value [ [number] : [number] ] [EOL] value = value [ [number] : ] [EOL] else : [EOL] prefix = default [EOL] [EOL] return prefix , value [EOL] [EOL] def merge_query ( self , * queries ) : [EOL] [docstring] [EOL] assert len ( queries ) > [number] , [string] [EOL] first_query = queries [ [number] ] [EOL] [EOL] for query in queries [ [number] : ] : [EOL] if [string] in query [ [string] ] [ [string] ] : [EOL] if [string] not in first_query [ [string] ] [ [string] ] : [EOL] first_query [ [string] ] [ [string] ] [ [string] ] = list ( ) [EOL] first_query [ [string] ] [ [string] ] [ [string] ] . extend ( first_query [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] if [string] in query [ [string] ] [ [string] ] : [EOL] if [string] not in first_query [ [string] ] [ [string] ] : [EOL] first_query [ [string] ] [ [string] ] [ [string] ] = list ( ) [EOL] first_query [ [string] ] [ [string] ] [ [string] ] . extend ( first_query [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] if [string] in query [ [string] ] [ [string] ] : [EOL] if [string] not in first_query [ [string] ] [ [string] ] : [EOL] first_query [ [string] ] [ [string] ] [ [string] ] = list ( ) [EOL] first_query [ [string] ] [ [string] ] [ [string] ] . extend ( first_query [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] return first_query [EOL] [EOL] [EOL] def build_elasticsearch_query ( params , resource_type = None , type_name = None ) : [EOL] [docstring] [EOL] [EOL] [EOL] builder = ElasticSearchQueryBuilder ( params , resource_type , type_name = type_name ) [EOL] [EOL] return builder . build ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.int]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.int]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.int]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.int]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.int]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.int]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.bytes$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Any,typing.Any],typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing_extensions.Literal,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Any,typing.Any],typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Any,typing.Any],typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Any,typing.Any],typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Any,typing.Any],typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Any,typing.Any],typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Any,typing.Any],typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing_extensions.Literal,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing_extensions.Literal,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing_extensions.Literal,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing_extensions.Literal,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing_extensions.Literal,typing.List[typing.Any]]]]$ 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing_extensions.Literal,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing_extensions.Literal,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import typing [EOL] import src [EOL] from guillotina import configure [EOL] from guillotina . content import Folder [EOL] from guillotina . component import get_utility [EOL] from guillotina . interfaces import ICatalogUtility [EOL] from guillotina . directives import index_field [EOL] from guillotina_elasticsearch . directives import index [EOL] from guillotina_elasticsearch . interfaces import IContentIndex [EOL] from guillotina . api . service import Service [EOL] from guillotina . interfaces import IContainer [EOL] [EOL] from guillotina_fhirfield . field import FhirField [EOL] from guillotina_fhirfield . helpers import fhir_resource_mapping [EOL] from guillotina_fhirfield . interfaces import IFhirContent [EOL] [EOL] [EOL] class IOrganization ( IFhirContent , IContentIndex ) : [EOL] [EOL] index_field ( [string] , type = [string] , field_mapping = fhir_resource_mapping ( [string] ) , fhir_field_indexer = True , resource_type = [string] ) [EOL] [EOL] organization_resource = FhirField ( title = [string] , resource_type = [string] ) [EOL] [EOL] [EOL] @ configure . contenttype ( type_name = [string] , schema = IOrganization ) class Organization ( Folder ) : [EOL] [docstring] [EOL] index ( schemas = [ IOrganization ] , settings = { } ) [EOL] resource_type = [string] [EOL] [EOL] [EOL] @ configure . service ( context = IContainer , method = [string] , permission = [string] , name = [string] , summary = [string] , responses = { [string] : { [string] : [string] , [string] : { [string] : { } } } } ) class FhirServiceSearch ( Service ) : [EOL] [EOL] async def prepare ( self ) : [EOL] pass [EOL] [EOL] async def __call__ ( self ) : [EOL] catalog = get_utility ( ICatalogUtility ) [EOL] result = await catalog . stats ( self . context ) [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.guillotina_fhirfield.tests.fhir_contents.IOrganization]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] from pytest_docker_fixtures import images [EOL] images . configure ( [string] , [string] , [string] ) [EOL] [comment] [EOL] pytest_plugins = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from guillotina import testing [EOL] from guillotina_elasticsearch . tests . fixtures import elasticsearch [EOL] [EOL] [EOL] def base_settings_configurator ( settings ) : [EOL] [EOL] if [string] not in settings : [EOL] settings [ [string] ] = list ( ) [EOL] [EOL] if [string] in settings [ [string] ] : [EOL] settings [ [string] ] . append ( [string] ) [EOL] [EOL] settings [ [string] ] . append ( [string] ) [EOL] settings [ [string] ] . append ( [string] ) [EOL] [EOL] settings [ [string] ] = { [string] : [string] , [string] : { [string] : [ [string] . format ( getattr ( elasticsearch , [string] , [string] ) , getattr ( elasticsearch , [string] , [string] ) , ) ] , [string] : None } } [EOL] settings [ [string] ] [ [string] ] = { [string] : [string] , [string] : [string] , [string] : { } } [EOL] [EOL] [EOL] testing . configure_with ( base_settings_configurator ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Any , Tuple [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] from zope . interface import Invalid [EOL] [EOL] import json [EOL] import uuid [EOL] from guillotina . db . oid import get_short_oid [EOL] from guillotina . component import get_utility [EOL] from guillotina . interfaces import ICatalogUtility [EOL] from guillotina_fhirfield . helpers import fhir_resource_mapping [EOL] from guillotina_fhirfield . variables import FHIR_ES_MAPPINGS_CACHE [EOL] from guillotina_fhirfield . variables import FHIR_RESOURCE_MAPPING_DIR [EOL] from . helpers import FHIR_FIXTURE_PATH [EOL] [EOL] [EOL] async def test_fhir_resource_mapping ( dummy_guillotina ) : [comment] [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] assert len ( FHIR_ES_MAPPINGS_CACHE ) == [number] [EOL] [EOL] patient_mapping = fhir_resource_mapping ( [string] ) [EOL] [EOL] with open ( str ( FHIR_RESOURCE_MAPPING_DIR / [string] ) , [string] ) as f : [EOL] [EOL] patient_mapping_dict = json . load ( f ) [EOL] [EOL] assert patient_mapping == patient_mapping_dict [ [string] ] [EOL] assert len ( FHIR_ES_MAPPINGS_CACHE ) == [number] [EOL] [EOL] [comment] [EOL] address_mapping = fhir_resource_mapping ( [string] ) [EOL] [EOL] with open ( str ( FHIR_RESOURCE_MAPPING_DIR / [string] ) , [string] ) as f : [EOL] [EOL] default_mapping_dict = json . load ( f ) [EOL] [EOL] assert address_mapping == default_mapping_dict [ [string] ] [EOL] [EOL] with pytest . raises ( Invalid ) : [EOL] [EOL] fhir_resource_mapping ( [string] ) [EOL] [EOL] [EOL] async def test_elasticsearch_query_builder ( es_requester ) : [EOL] [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] , encoding = [string] ) as f : [EOL] organization_json = json . load ( f ) [EOL] [EOL] async with es_requester as requester : [EOL] id_ = str ( uuid . uuid4 ( ) ) [EOL] organization_json [ [string] ] = id_ [EOL] resp , status = await requester ( [string] , [string] , data = json . dumps ( { [string] : [string] , [string] : [string] , [string] : id_ , [string] : organization_json } ) ) [EOL] [EOL] catalog = get_utility ( ICatalogUtility ) [EOL] assert status == [number] [EOL] [EOL] [comment] [EOL] index_ = [string] . format ( get_short_oid ( resp [ [string] ] ) ) [EOL] result = await catalog . conn . indices . get_alias ( index = index_ ) [EOL] [EOL] assert index_ in str ( result ) [EOL] [EOL] index_ = [string] . format ( get_short_oid ( resp [ [string] ] ) ) [EOL] [EOL] result = await catalog . conn . indices . get_alias ( index = index_ ) [EOL] assert index_ in str ( result ) [EOL] [EOL] [comment] [EOL] data = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ) [EOL] response , status = await requester ( [string] , [string] , params = data ) [EOL] import pdb ; [EOL] pdb . set_trace ( ) [EOL] assert status == [number] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Dict [EOL] import typing [EOL] import src [EOL] [docstring] [EOL] [EOL] import pickle [EOL] [EOL] import pytest [EOL] from guillotina . component import get_multi_adapter [EOL] from guillotina . component import get_utility [EOL] from guillotina . component import query_adapter [EOL] from guillotina . interfaces import IFactorySerializeToJson [EOL] from guillotina . interfaces import IJSONToValue [EOL] from guillotina . interfaces import IResourceFactory [EOL] from guillotina . interfaces import ISchemaFieldSerializeToJson [EOL] from guillotina . interfaces import ISchemaSerializeToJson [EOL] from guillotina . interfaces import IValueToJson [EOL] from guillotina . schema . exceptions import ConstraintNotSatisfied [EOL] from guillotina . schema . exceptions import WrongContainedType [EOL] from guillotina . schema . exceptions import WrongType [EOL] from zope . interface import Invalid [EOL] from zope . interface import implementer [EOL] [EOL] import ujson as json [EOL] from guillotina_fhirfield . field import FhirField [EOL] from guillotina_fhirfield . field import FhirFieldValue [EOL] from guillotina_fhirfield . field import fhir_field_from_resource_type [EOL] from guillotina_fhirfield . field import fhir_field_from_schema [EOL] from guillotina_fhirfield . helpers import parse_json_str [EOL] from guillotina_fhirfield . helpers import resource_type_to_resource_cls [EOL] from guillotina_fhirfield . interfaces import IFhirField [EOL] from guillotina_fhirfield . interfaces import IFhirFieldValue [EOL] from guillotina_fhirfield . interfaces import IFhirResource [EOL] [EOL] from . fhir_contents import IOrganization [EOL] from . helpers import FHIR_FIXTURE_PATH [EOL] [EOL] [EOL] async def test_field_init_validate ( dummy_guillotina ) : [comment] [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] FhirField ( title = [string] ) [EOL] except Invalid as exc : [EOL] raise AssertionError ( [string] . format ( exc ) ) [EOL] [comment] [EOL] try : [EOL] FhirField ( title = [string] , resource_class = [string] , resource_interface = [string] , ) [EOL] except Invalid as exc : [EOL] raise AssertionError ( [string] . format ( exc ) ) [EOL] [EOL] try : [EOL] FhirField ( title = [string] , resource_type = [string] ) [EOL] except Invalid as exc : [EOL] raise AssertionError ( [string] . format ( exc ) ) [EOL] [EOL] [comment] [EOL] try : [EOL] FhirField ( title = [string] , resource_type = [string] , resource_class = [string] , ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid : [EOL] pass [EOL] [EOL] [comment] [EOL] try : [EOL] FhirField ( title = [string] , resource_class = [string] , ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid : [EOL] pass [EOL] [EOL] [comment] [EOL] try : [EOL] FhirField ( title = [string] , resource_class = [string] ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [comment] [EOL] try : [EOL] FhirField ( title = [string] , resource_type = [string] ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [comment] [EOL] try : [EOL] FhirField ( title = [string] , resource_interface = [string] , ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid : [EOL] pass [EOL] [EOL] [EOL] async def test_field_init_validation_with_noninterface ( dummy_guillotina ) : [EOL] [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] FhirField ( title = [string] , resource_interface = [string] , ) [EOL] raise AssertionError ( [string] ) [EOL] except WrongType as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [EOL] async def test_field_init_validation_with_wrong_dotted_path ( dummy_guillotina ) : [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] FhirField ( title = [string] , resource_interface = [string] , ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [EOL] async def test_field_pre_value_validate ( dummy_guillotina ) : [EOL] [docstring] [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] ) as f : [EOL] json_str = f . read ( ) [EOL] [EOL] fhir_field = FhirField ( title = [string] ) [EOL] [EOL] try : [EOL] fhir_field . _pre_value_validate ( json_str ) [EOL] except Invalid as e : [EOL] raise AssertionError ( [string] . format ( e ) ) [EOL] [EOL] fhir_dict = json . loads ( json_str ) [EOL] resource_type = fhir_dict . pop ( [string] ) [EOL] [EOL] try : [EOL] fhir_field . _pre_value_validate ( fhir_dict ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid : [EOL] pass [EOL] [EOL] fhir_dict . pop ( [string] ) [EOL] fhir_dict [ [string] ] = resource_type [EOL] try : [EOL] fhir_field . _pre_value_validate ( fhir_dict ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid : [EOL] pass [EOL] [EOL] fhir_dict . pop ( [string] ) [EOL] try : [EOL] fhir_field . _pre_value_validate ( fhir_dict ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid : [EOL] pass [EOL] [EOL] [EOL] async def test_field_validate ( dummy_guillotina ) : [EOL] [docstring] [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] ) as f : [EOL] json_dict = json . load ( f ) [EOL] [EOL] organization = resource_type_to_resource_cls ( [string] ) ( json_dict ) [EOL] fhir_resource_value = FhirFieldValue ( obj = organization ) [EOL] [EOL] fhir_field = FhirField ( title = [string] ) [EOL] [EOL] try : [EOL] fhir_field . _validate ( fhir_resource_value ) [EOL] except Invalid as exc : [EOL] raise AssertionError ( [string] . format ( exc ) ) [EOL] [EOL] [comment] [EOL] try : [EOL] fhir_field . _validate ( dict ( hello = [string] ) ) [EOL] raise AssertionError ( [string] ) [EOL] except WrongType as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] type_ , address_ = fhir_resource_value . type , fhir_resource_value . address [EOL] fhir_resource_value . type = [number] [EOL] fhir_resource_value . address = [string] [EOL] [EOL] try : [EOL] fhir_field . _validate ( fhir_resource_value ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [comment] [EOL] fhir_resource_value . type = type_ [EOL] fhir_resource_value . address = address_ [EOL] [comment] [EOL] fhir_field = FhirField ( title = [string] , resource_class = [string] ) [EOL] [EOL] try : [EOL] fhir_field . _validate ( fhir_resource_value ) [EOL] raise AssertionError ( [string] ) [EOL] except WrongContainedType as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [comment] [EOL] fhir_field = FhirField ( title = [string] , resource_type = [string] ) [EOL] [EOL] try : [EOL] fhir_field . _validate ( fhir_resource_value ) [EOL] raise AssertionError ( [string] ) [EOL] except ConstraintNotSatisfied as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [comment] [EOL] fhir_field = FhirField ( title = [string] , resource_interface = [string] , ) [EOL] [EOL] try : [EOL] fhir_field . _validate ( fhir_resource_value ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [EOL] async def test_field_from_dict ( dummy_guillotina ) : [EOL] [docstring] [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] ) as f : [EOL] json_dict = json . load ( f ) [EOL] [EOL] fhir_field = FhirField ( title = [string] , resource_class = [string] , ) [EOL] [EOL] try : [EOL] fhir_resource_value = fhir_field . from_dict ( json_dict ) [EOL] except Invalid as exc : [EOL] raise AssertionError ( [string] . format ( exc ) ) [EOL] [EOL] assert fhir_resource_value . resource_type == json_dict [ [string] ] [EOL] [EOL] fhir_field = FhirField ( title = [string] , resource_type = [string] ) [EOL] [EOL] fhir_resource_value = fhir_field . from_dict ( json_dict ) [EOL] try : [EOL] fhir_resource_value . as_json ( ) [EOL] except Exception : [EOL] raise AssertionError ( [string] ) [EOL] [EOL] [comment] [EOL] fhir_field = FhirField ( title = [string] ) [EOL] fhir_resource_value = fhir_field . from_dict ( json_dict ) [EOL] assert fhir_resource_value . resource_type == json_dict [ [string] ] [EOL] [EOL] [comment] [EOL] try : [EOL] invalid_data = ( [string] , [string] , [string] ) [EOL] fhir_field . from_dict ( invalid_data ) [EOL] except WrongType as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [comment] [EOL] try : [EOL] invalid_data = dict ( hello = [string] , foo = [string] ) [EOL] fhir_field . from_dict ( invalid_data ) [EOL] [EOL] raise AssertionError ( [string] ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [comment] [EOL] fhir_field = FhirField ( title = [string] , resource_class = [string] ) [EOL] [EOL] try : [EOL] fhir_field . from_dict ( json_dict ) [EOL] raise AssertionError ( [string] ) [EOL] except ConstraintNotSatisfied as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [EOL] async def test_field_from_unicode ( dummy_guillotina ) : [EOL] [docstring] [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] ) as f : [EOL] json_str = f . read ( ) [EOL] [EOL] fhir_field = FhirField ( title = [string] , resource_class = [string] , ) [EOL] [EOL] try : [EOL] fhir_field . from_unicode ( json_str ) [EOL] except Invalid as exc : [EOL] raise AssertionError ( [string] . format ( exc ) ) [EOL] [EOL] [comment] [EOL] try : [EOL] invalid_data = [string] [EOL] fhir_field . from_unicode ( invalid_data ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [EOL] async def test_field_from_unicode_with_empty_str ( dummy_guillotina ) : [EOL] [docstring] [EOL] fhir_field = FhirField ( title = [string] , resource_class = [string] , required = False , ) [EOL] [EOL] value = fhir_field . from_unicode ( [string] ) [EOL] assert value is None [EOL] [EOL] [EOL] async def test_field_default_value ( dummy_guillotina ) : [EOL] [docstring] [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] ) as f : [EOL] json_dict = json . load ( f ) [EOL] [EOL] fhir_field = FhirField ( title = [string] , resource_class = [string] , default = json_dict , ) [EOL] assert json_dict == fhir_field . default . as_json ( ) [EOL] [EOL] fhir_field2 = FhirField ( title = [string] , resource_class = [string] , default = json . dumps ( json_dict ) , ) [EOL] [EOL] assert fhir_field2 . default . as_json ( ) == fhir_field . default . as_json ( ) [EOL] [EOL] fhir_field3 = FhirField ( title = [string] , resource_class = [string] , default = None , ) [EOL] assert fhir_field3 . default is None [EOL] [EOL] [EOL] async def test_field_with_wrong_default_value ( dummy_guillotina ) : [EOL] [docstring] [EOL] try : [EOL] FhirField ( title = [string] , resource_class = [string] , default = False , ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] try : [EOL] FhirField ( title = [string] , resource_class = [string] , default = { [string] : [string] } , ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [EOL] async def test_field_resource_type_constraint ( dummy_guillotina ) : [EOL] [docstring] [EOL] fhir_field = FhirField ( title = [string] , resource_type = [string] ) [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] ) as f : [EOL] json_dict = json . load ( f ) [EOL] [EOL] try : [EOL] fhir_field . from_dict ( json_dict ) [EOL] except Invalid as e : [EOL] assert e . __class__ . __name__ == [string] [EOL] assert [string] in str ( e ) [EOL] [EOL] [EOL] async def test_fhir_field_value ( dummy_guillotina ) : [EOL] [docstring] [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] ) as f : [EOL] fhir_json = json . load ( f ) [EOL] [EOL] model = resource_type_to_resource_cls ( fhir_json [ [string] ] ) [EOL] fhir_resource = model ( fhir_json ) [EOL] fhir_resource_value = FhirFieldValue ( obj = fhir_resource ) [EOL] [EOL] [comment] [EOL] assert bool ( fhir_resource_value ) is True [EOL] assert IFhirResource . providedBy ( fhir_resource_value . foreground_origin ( ) ) is True [EOL] assert isinstance ( fhir_resource_value . stringify ( ) , str ) is True [EOL] [EOL] [comment] [EOL] patch_data = { [string] : [number] } [EOL] try : [EOL] fhir_resource_value . patch ( patch_data ) [EOL] raise AssertionError ( [string] ) [EOL] except WrongType : [EOL] pass [EOL] patch_data = [ { [string] : [string] , [string] : [string] , [string] : [string] } ] [EOL] [comment] [EOL] try : [EOL] fhir_resource_value . patch ( patch_data ) [EOL] raise AssertionError ( [string] [string] ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] patch_data = [ { [string] : [string] , [string] : [string] , [string] : [string] } ] [EOL] fhir_resource_value . patch ( patch_data ) [EOL] [EOL] assert [string] == fhir_resource_value . text . status [EOL] [EOL] [comment] [EOL] json_str = fhir_resource_value . stringify ( ) [EOL] json_dict = parse_json_str ( json_str ) [EOL] [EOL] try : [EOL] model ( json_dict ) . as_json ( ) [EOL] except Exception : [EOL] raise AssertionError ( [string] ) [EOL] [EOL] [comment] [EOL] assert fhir_resource_value . __class__ . __module__ in repr ( fhir_resource_value ) [EOL] [EOL] empty_resource = FhirFieldValue ( ) [EOL] [comment] [EOL] assert bool ( empty_resource ) is False [EOL] [EOL] assert empty_resource . foreground_origin ( ) is None [EOL] [EOL] assert ( fhir_resource_value == empty_resource ) is False [EOL] assert ( empty_resource == fhir_resource_value ) is False [EOL] assert ( empty_resource != fhir_resource_value ) is True [EOL] [EOL] [comment] [EOL] try : [EOL] empty_resource . patch ( patch_data ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid : [EOL] pass [EOL] [EOL] [comment] [EOL] fhir_resource_value . identifier [ [number] ] . use = [string] [EOL] [EOL] [comment] [EOL] assert fhir_resource_value . as_json ( ) [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] [comment] [EOL] try : [EOL] empty_resource . id = [string] [EOL] raise AssertionError ( [string] ) [EOL] except AttributeError : [EOL] pass [EOL] [EOL] assert [string] in repr ( empty_resource ) [EOL] assert [string] == str ( empty_resource ) [EOL] [EOL] [comment] [EOL] try : [EOL] FhirFieldValue ( obj = dict ( hello = [string] ) ) [EOL] raise AssertionError ( [string] ) [EOL] except WrongType : [EOL] pass [EOL] [EOL] @ implementer ( IFhirResource ) class TestBrokenInterfaceObject ( object ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] broken_obj = TestBrokenInterfaceObject ( ) [EOL] try : [EOL] fhir_resource_value . _validate_object ( broken_obj ) [EOL] raise AssertionError ( [string] ) [EOL] except Invalid as exc : [EOL] assert [string] in str ( exc ) [EOL] [EOL] [EOL] async def test_fhir_field_value_pickling ( dummy_guillotina ) : [EOL] [docstring] [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] ) as f : [EOL] fhir_json = json . load ( f ) [EOL] [EOL] model = resource_type_to_resource_cls ( fhir_json [ [string] ] ) [EOL] fhir_resource = model ( fhir_json ) [EOL] fhir_resource_value = FhirFieldValue ( obj = fhir_resource ) [EOL] [EOL] serialized = pickle . dumps ( fhir_resource_value ) [EOL] deserialized = pickle . loads ( serialized ) [EOL] [EOL] assert len ( deserialized . stringify ( ) ) == len ( fhir_resource_value . stringify ( ) ) [EOL] [EOL] [EOL] async def test_fhir_field_value_serializer ( dummy_request ) : [EOL] [docstring] [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] ) as f : [EOL] fhir_json = json . load ( f ) [EOL] [EOL] model = resource_type_to_resource_cls ( fhir_json [ [string] ] ) [EOL] fhir_resource = model ( fhir_json ) [EOL] value = FhirFieldValue ( obj = fhir_resource ) [EOL] [EOL] serialized = query_adapter ( value , IValueToJson ) [EOL] assert serialized == value . as_json ( ) [EOL] [EOL] serialized = query_adapter ( FhirFieldValue ( ) , IValueToJson ) [EOL] [EOL] assert serialized is None [EOL] [EOL] [EOL] async def test_fhir_field_deserializer ( dummy_request ) : [EOL] [docstring] [EOL] with open ( str ( FHIR_FIXTURE_PATH / [string] ) , [string] ) as f : [EOL] fhir_json = json . load ( f ) [EOL] [EOL] fhir_field = FhirField ( title = [string] , resource_class = [string] , required = False , ) [EOL] [EOL] deserialized = query_adapter ( fhir_field , IJSONToValue , args = [ fhir_json , None ] ) [EOL] assert IFhirFieldValue . providedBy ( deserialized ) is True [EOL] assert deserialized . as_json ( ) == fhir_json [EOL] [EOL] deserialized = query_adapter ( fhir_field , IJSONToValue , args = [ json . dumps ( fhir_json ) , None ] ) [EOL] assert IFhirFieldValue . providedBy ( deserialized ) is True [EOL] [EOL] deserialized = query_adapter ( fhir_field , IJSONToValue , args = [ None , None ] ) [EOL] assert deserialized is None [EOL] [EOL] [EOL] async def test_fhir_field_schema_serializer ( dummy_request ) : [EOL] [docstring] [EOL] fhir_field = FhirField ( title = [string] , resource_class = [string] , ) [EOL] [EOL] serializer = get_multi_adapter ( ( fhir_field , IOrganization , dummy_request ) , ISchemaFieldSerializeToJson ) [EOL] [EOL] schema_json = await serializer ( ) [EOL] assert schema_json [ [string] ] == [string] [EOL] assert schema_json [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_schema_serializer_with_fhir_field ( dummy_request ) : [EOL] [docstring] [EOL] serializer = get_multi_adapter ( ( IOrganization , dummy_request ) , ISchemaSerializeToJson ) [EOL] [EOL] serialized_schema = await serializer ( ) [EOL] assert [string] in serialized_schema [ [string] ] [EOL] assert [string] in serialized_schema [ [string] ] [EOL] [EOL] [EOL] async def test_factory_serializer_with_fhir_field ( dummy_request ) : [EOL] [docstring] [EOL] factory = get_utility ( IResourceFactory , name = [string] ) [EOL] [EOL] serializer = get_multi_adapter ( ( factory , dummy_request ) , IFactorySerializeToJson ) [EOL] [EOL] serialized_factory = await serializer ( ) [EOL] assert [string] in serialized_factory [ [string] ] [EOL] assert [string] in serialized_factory [ [string] ] [EOL] [EOL] [EOL] async def test_fhir_field_from_schema ( dummy_guillotina ) : [EOL] [docstring] [EOL] [EOL] expected_fhir_field = fhir_field_from_schema ( IOrganization , [string] ) [EOL] [EOL] assert expected_fhir_field is not None [EOL] [EOL] assert IFhirField . providedBy ( expected_fhir_field ) [EOL] [comment] [EOL] assert fhir_field_from_schema ( IOrganization , [string] ) is None [EOL] [EOL] [EOL] async def test_fhir_field_from_resource_type ( dummy_guillotina ) : [EOL] [docstring] [EOL] [EOL] fields = fhir_field_from_resource_type ( [string] ) [EOL] [docstring] [EOL] assert len ( fields ) == [number] [EOL] assert [string] in fields [EOL] [EOL] [comment] [EOL] assert fhir_field_from_resource_type ( [string] ) is None [EOL] [EOL] with pytest . raises ( Invalid ) : [EOL] fhir_field_from_resource_type ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import click [EOL] [docstring] [EOL] [EOL] from click . testing import CliRunner [EOL] [EOL] from guillotina_fhirfield import cli [EOL] [EOL] [EOL] async def test_content ( dummy_request , dummy_guillotina ) : [comment] [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_command_line_interface ( ) : [EOL] [docstring] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli . main ) [EOL] assert result . exit_code == [number] [EOL] assert [string] in result . output [EOL] help_result = runner . invoke ( cli . main , [ [string] ] ) [EOL] assert help_result . exit_code == [number] [EOL] assert [string] in help_result . output [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0