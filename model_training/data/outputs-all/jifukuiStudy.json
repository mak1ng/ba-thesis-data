[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , List , Any , Tuple , Callable [EOL] import typing [EOL] import sys [EOL] import os [EOL] import sphinx [EOL] [EOL] [comment] [EOL] major , minor , patch = map ( int , sphinx . __version__ . split ( [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] from load_config import loadConfig [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] if minor > [number] : [EOL] extensions . append ( [string] ) [EOL] else : [EOL] extensions . append ( [string] ) [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] makefile_version = None [EOL] makefile_patchlevel = None [EOL] for line in open ( [string] ) : [EOL] key , val = [ x . strip ( ) for x in line . split ( [string] , [number] ) ] [EOL] if key == [string] : [EOL] makefile_version = val [EOL] elif key == [string] : [EOL] makefile_patchlevel = val [EOL] if makefile_version and makefile_patchlevel : [EOL] break [EOL] except : [EOL] pass [EOL] finally : [EOL] if makefile_version and makefile_patchlevel : [EOL] version = release = makefile_version + [string] + makefile_patchlevel [EOL] else : [EOL] sys . stderr . write ( [string] ) [EOL] version = release = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] todo_include_todos = False [EOL] [EOL] primary_domain = [string] [EOL] highlight_language = [string] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] import sphinx_rtd_theme [EOL] html_theme = [string] [EOL] html_theme_path = [ sphinx_rtd_theme . get_html_theme_path ( ) ] [EOL] except ImportError : [EOL] sys . stderr . write ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] html_static_path = [ [string] ] [EOL] [EOL] html_context = { [string] : [ [string] , ] , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( [string] , [string] , [string] , [string] , [string] ) , ( [string] , [string] , [string] , [string] , [string] ) , ( [string] , [string] , [string] , [string] , [string] ) , ( [string] , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_title = project [EOL] epub_author = author [EOL] epub_publisher = author [EOL] epub_copyright = copyright [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_exclude_files = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pdf_documents = [ ( [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] kerneldoc_bin = [string] [EOL] kerneldoc_srctree = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] loadConfig ( globals ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Pattern , Optional , Any , Type , Tuple , Match [EOL] import subprocess [EOL] import doc [EOL] import typing [EOL] import Documentation [EOL] import Study [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] import re [EOL] import glob [EOL] [EOL] from docutils import nodes , statemachine [EOL] from docutils . statemachine import ViewList [EOL] from docutils . parsers . rst import directives [EOL] from sphinx . util . compat import Directive [EOL] from sphinx . ext . autodoc import AutodocReporter [EOL] [EOL] __version__ = [string] [EOL] [EOL] class KernelDocDirective ( Directive ) : [EOL] [docstring] [EOL] required_argument = [number] [EOL] optional_arguments = [number] [EOL] option_spec = { [string] : directives . unchanged_required , [string] : directives . unchanged_required , [string] : directives . unchanged , [string] : directives . unchanged , } [EOL] has_content = False [EOL] [EOL] def run ( self ) : [EOL] env = self . state . document . settings . env [EOL] cmd = [ env . config . kerneldoc_bin , [string] , [string] ] [EOL] [EOL] filename = env . config . kerneldoc_srctree + [string] + self . arguments [ [number] ] [EOL] export_file_patterns = [ ] [EOL] [EOL] [comment] [EOL] env . note_dependency ( os . path . abspath ( filename ) ) [EOL] [EOL] tab_width = self . options . get ( [string] , self . state . document . settings . tab_width ) [EOL] [EOL] [comment] [EOL] if [string] in self . options : [EOL] cmd += [ [string] ] [EOL] export_file_patterns = str ( self . options . get ( [string] ) ) . split ( ) [EOL] elif [string] in self . options : [EOL] cmd += [ [string] ] [EOL] export_file_patterns = str ( self . options . get ( [string] ) ) . split ( ) [EOL] elif [string] in self . options : [EOL] cmd += [ [string] , str ( self . options . get ( [string] ) ) ] [EOL] elif [string] in self . options : [EOL] for f in str ( self . options . get ( [string] ) ) . split ( ) : [EOL] cmd += [ [string] , f ] [EOL] [EOL] for pattern in export_file_patterns : [EOL] for f in glob . glob ( env . config . kerneldoc_srctree + [string] + pattern ) : [EOL] env . note_dependency ( os . path . abspath ( f ) ) [EOL] cmd += [ [string] , f ] [EOL] [EOL] cmd += [ filename ] [EOL] [EOL] try : [EOL] env . app . verbose ( [string] % ( [string] . join ( cmd ) ) ) [EOL] [EOL] p = subprocess . Popen ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE , universal_newlines = True ) [EOL] out , err = p . communicate ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if sys . version_info . major < [number] : [EOL] out , err = unicode ( out , [string] ) , unicode ( err , [string] ) [EOL] [EOL] if p . returncode != [number] : [EOL] sys . stderr . write ( err ) [EOL] [EOL] env . app . warn ( [string] % ( [string] . join ( cmd ) , p . returncode ) ) [EOL] return [ nodes . error ( None , nodes . paragraph ( text = [string] ) ) ] [EOL] elif env . config . kerneldoc_verbosity > [number] : [EOL] sys . stderr . write ( err ) [EOL] [EOL] lines = statemachine . string2lines ( out , tab_width , convert_whitespace = True ) [EOL] result = ViewList ( ) [EOL] [EOL] lineoffset = [number] ; [EOL] line_regex = re . compile ( [string] ) [EOL] for line in lines : [EOL] match = line_regex . search ( line ) [EOL] if match : [EOL] [comment] [EOL] lineoffset = int ( match . group ( [number] ) ) - [number] [EOL] [comment] [EOL] else : [EOL] result . append ( line , filename , lineoffset ) [EOL] lineoffset += [number] [EOL] [EOL] node = nodes . section ( ) [EOL] buf = self . state . memo . title_styles , self . state . memo . section_level , self . state . memo . reporter [EOL] self . state . memo . reporter = AutodocReporter ( result , self . state . memo . reporter ) [EOL] self . state . memo . title_styles , self . state . memo . section_level = [ ] , [number] [EOL] try : [EOL] self . state . nested_parse ( result , [number] , node , match_titles = [number] ) [EOL] finally : [EOL] self . state . memo . title_styles , self . state . memo . section_level , self . state . memo . reporter = buf [EOL] [EOL] return node . children [EOL] [EOL] except Exception as e : [comment] [EOL] env . app . warn ( [string] % ( [string] . join ( cmd ) , str ( e ) ) ) [EOL] return [ nodes . error ( None , nodes . paragraph ( text = [string] ) ) ] [EOL] [EOL] def setup ( app ) : [EOL] app . add_config_value ( [string] , None , [string] ) [EOL] app . add_config_value ( [string] , None , [string] ) [EOL] app . add_config_value ( [string] , [number] , [string] ) [EOL] [EOL] app . add_directive ( [string] , KernelDocDirective ) [EOL] [EOL] return dict ( version = __version__ , parallel_read_safe = True , parallel_write_safe = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] from sphinx . util . pycompat import execfile_ [EOL] [EOL] [comment] [EOL] def loadConfig ( namespace ) : [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] config_file = os . environ . get ( [string] , None ) [EOL] if ( config_file is not None [EOL] and os . path . normpath ( namespace [ [string] ] ) != os . path . normpath ( config_file ) ) : [EOL] config_file = os . path . abspath ( config_file ) [EOL] [EOL] if os . path . isfile ( config_file ) : [EOL] sys . stdout . write ( [string] % config_file ) [EOL] config = namespace . copy ( ) [EOL] config [ [string] ] = config_file [EOL] execfile_ ( config_file , config ) [EOL] del config [ [string] ] [EOL] namespace . update ( config ) [EOL] else : [EOL] sys . stderr . write ( [string] % config_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , List , Type , Dict [EOL] import typing [EOL] import Documentation [EOL] import Study [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import sys [EOL] [EOL] from docutils import nodes [EOL] from docutils . parsers . rst import directives , roles [EOL] from docutils . parsers . rst . directives . tables import Table [EOL] from docutils . utils import SystemMessagePropagation [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] __version__ = [string] [EOL] [EOL] PY3 = sys . version_info [ [number] ] == [number] [EOL] PY2 = sys . version_info [ [number] ] == [number] [EOL] [EOL] if PY3 : [EOL] [comment] [EOL] unicode = str [EOL] basestring = str [EOL] [EOL] [comment] [EOL] def setup ( app ) : [EOL] [comment] [EOL] [EOL] app . add_directive ( [string] , FlatTable ) [EOL] roles . register_local_role ( [string] , c_span ) [EOL] roles . register_local_role ( [string] , r_span ) [EOL] [EOL] return dict ( version = __version__ , parallel_read_safe = True , parallel_write_safe = True ) [EOL] [EOL] [comment] [EOL] def c_span ( name , rawtext , text , lineno , inliner , options = None , content = None ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] options = options if options is not None else { } [EOL] content = content if content is not None else [ ] [EOL] nodelist = [ colSpan ( span = int ( text ) ) ] [EOL] msglist = [ ] [EOL] return nodelist , msglist [EOL] [EOL] [comment] [EOL] def r_span ( name , rawtext , text , lineno , inliner , options = None , content = None ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] options = options if options is not None else { } [EOL] content = content if content is not None else [ ] [EOL] nodelist = [ rowSpan ( span = int ( text ) ) ] [EOL] msglist = [ ] [EOL] return nodelist , msglist [EOL] [EOL] [EOL] [comment] [EOL] class rowSpan ( nodes . General , nodes . Element ) : pass [comment] [EOL] class colSpan ( nodes . General , nodes . Element ) : pass [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class FlatTable ( Table ) : [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] option_spec = { [string] : directives . unchanged , [string] : directives . class_option , [string] : directives . nonnegative_int , [string] : directives . nonnegative_int , [string] : directives . positive_int_list , [string] : directives . flag } [EOL] [EOL] def run ( self ) : [EOL] [EOL] if not self . content : [EOL] error = self . state_machine . reporter . error ( [string] % self . name , nodes . literal_block ( self . block_text , self . block_text ) , line = self . lineno ) [EOL] return [ error ] [EOL] [EOL] title , messages = self . make_title ( ) [EOL] node = nodes . Element ( ) [comment] [EOL] self . state . nested_parse ( self . content , self . content_offset , node ) [EOL] [EOL] tableBuilder = ListTableBuilder ( self ) [EOL] tableBuilder . parseFlatTableNode ( node ) [EOL] tableNode = tableBuilder . buildTableNode ( ) [EOL] [comment] [EOL] if title : [EOL] tableNode . insert ( [number] , title ) [EOL] return [ tableNode ] + messages [EOL] [EOL] [EOL] [comment] [EOL] class ListTableBuilder ( object ) : [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , directive ) : [EOL] self . directive = directive [EOL] self . rows = [ ] [EOL] self . max_cols = [number] [EOL] [EOL] def buildTableNode ( self ) : [EOL] [EOL] colwidths = self . directive . get_column_widths ( self . max_cols ) [EOL] stub_columns = self . directive . options . get ( [string] , [number] ) [EOL] header_rows = self . directive . options . get ( [string] , [number] ) [EOL] [EOL] table = nodes . table ( ) [EOL] tgroup = nodes . tgroup ( cols = len ( colwidths ) ) [EOL] table += tgroup [EOL] [EOL] [EOL] for colwidth in colwidths : [EOL] colspec = nodes . colspec ( colwidth = colwidth ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if stub_columns : [EOL] colspec . attributes [ [string] ] = [number] [EOL] stub_columns -= [number] [EOL] tgroup += colspec [EOL] stub_columns = self . directive . options . get ( [string] , [number] ) [EOL] [EOL] if header_rows : [EOL] thead = nodes . thead ( ) [EOL] tgroup += thead [EOL] for row in self . rows [ : header_rows ] : [EOL] thead += self . buildTableRowNode ( row ) [EOL] [EOL] tbody = nodes . tbody ( ) [EOL] tgroup += tbody [EOL] [EOL] for row in self . rows [ header_rows : ] : [EOL] tbody += self . buildTableRowNode ( row ) [EOL] return table [EOL] [EOL] def buildTableRowNode ( self , row_data , classes = None ) : [EOL] classes = [ ] if classes is None else classes [EOL] row = nodes . row ( ) [EOL] for cell in row_data : [EOL] if cell is None : [EOL] continue [EOL] cspan , rspan , cellElements = cell [EOL] [EOL] attributes = { [string] : classes } [EOL] if rspan : [EOL] attributes [ [string] ] = rspan [EOL] if cspan : [EOL] attributes [ [string] ] = cspan [EOL] entry = nodes . entry ( ** attributes ) [EOL] entry . extend ( cellElements ) [EOL] row += entry [EOL] return row [EOL] [EOL] def raiseError ( self , msg ) : [EOL] error = self . directive . state_machine . reporter . error ( msg , nodes . literal_block ( self . directive . block_text , self . directive . block_text ) , line = self . directive . lineno ) [EOL] raise SystemMessagePropagation ( error ) [EOL] [EOL] def parseFlatTableNode ( self , node ) : [EOL] [docstring] [EOL] [EOL] if len ( node ) != [number] or not isinstance ( node [ [number] ] , nodes . bullet_list ) : [EOL] self . raiseError ( [string] [string] % self . directive . name ) [EOL] [EOL] for rowNum , rowItem in enumerate ( node [ [number] ] ) : [EOL] row = self . parseRowItem ( rowItem , rowNum ) [EOL] self . rows . append ( row ) [EOL] self . roundOffTableDefinition ( ) [EOL] [EOL] def roundOffTableDefinition ( self ) : [EOL] [docstring] [EOL] [EOL] y = [number] [EOL] while y < len ( self . rows ) : [EOL] x = [number] [EOL] [EOL] while x < len ( self . rows [ y ] ) : [EOL] cell = self . rows [ y ] [ x ] [EOL] if cell is None : [EOL] x += [number] [EOL] continue [EOL] cspan , rspan = cell [ : [number] ] [EOL] [comment] [EOL] for c in range ( cspan ) : [EOL] try : [EOL] self . rows [ y ] . insert ( x + c + [number] , None ) [EOL] except : [comment] [EOL] [comment] [EOL] pass [comment] [EOL] [comment] [EOL] for r in range ( rspan ) : [EOL] for c in range ( cspan + [number] ) : [EOL] try : [EOL] self . rows [ y + r + [number] ] . insert ( x + c , None ) [EOL] except : [comment] [EOL] [comment] [EOL] pass [comment] [EOL] x += [number] [EOL] y += [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] for row in self . rows : [EOL] if self . max_cols < len ( row ) : [EOL] self . max_cols = len ( row ) [EOL] [EOL] [comment] [EOL] [EOL] fill_cells = False [EOL] if [string] in self . directive . options : [EOL] fill_cells = True [EOL] [EOL] for row in self . rows : [EOL] x = self . max_cols - len ( row ) [EOL] if x and not fill_cells : [EOL] if row [ - [number] ] is None : [EOL] row . append ( ( x - [number] , [number] , [ ] ) ) [EOL] else : [EOL] cspan , rspan , content = row [ - [number] ] [EOL] row [ - [number] ] = ( cspan + x , rspan , content ) [EOL] elif x and fill_cells : [EOL] for i in range ( x ) : [EOL] row . append ( ( [number] , [number] , nodes . comment ( ) ) ) [EOL] [EOL] def pprint ( self ) : [EOL] [comment] [EOL] retVal = [string] [EOL] for row in self . rows : [EOL] retVal += [string] [EOL] for col in row : [EOL] if col is None : [EOL] retVal += ( [string] % col ) [EOL] retVal += [string] [EOL] else : [EOL] content = col [ [number] ] [ [number] ] . astext ( ) [EOL] if len ( content ) > [number] : [EOL] content = content [ : [number] ] + [string] [EOL] retVal += ( [string] % ( col [ [number] ] , col [ [number] ] , content ) ) [EOL] retVal += [string] [EOL] retVal = retVal [ : - [number] ] [EOL] retVal += [string] [EOL] retVal = retVal [ : - [number] ] [EOL] return retVal + [string] [EOL] [EOL] def parseRowItem ( self , rowItem , rowNum ) : [EOL] row = [ ] [EOL] childNo = [number] [EOL] error = False [EOL] cell = None [EOL] target = None [EOL] [EOL] for child in rowItem : [EOL] if ( isinstance ( child , nodes . comment ) or isinstance ( child , nodes . system_message ) ) : [EOL] pass [EOL] elif isinstance ( child , nodes . target ) : [EOL] target = child [EOL] elif isinstance ( child , nodes . bullet_list ) : [EOL] childNo += [number] [EOL] cell = child [EOL] else : [EOL] error = True [EOL] break [EOL] [EOL] if childNo != [number] or error : [EOL] self . raiseError ( [string] [string] [string] % ( self . directive . name , rowNum + [number] ) ) [EOL] [EOL] for cellItem in cell : [EOL] cspan , rspan , cellElements = self . parseCellItem ( cellItem ) [EOL] if target is not None : [EOL] cellElements . insert ( [number] , target ) [EOL] row . append ( ( cspan , rspan , cellElements ) ) [EOL] return row [EOL] [EOL] def parseCellItem ( self , cellItem ) : [EOL] [comment] [EOL] [comment] [EOL] cspan = rspan = [number] [EOL] if not len ( cellItem ) : [EOL] return cspan , rspan , [ ] [EOL] for elem in cellItem [ [number] ] : [EOL] if isinstance ( elem , colSpan ) : [EOL] cspan = elem . get ( [string] ) [EOL] elem . parent . remove ( elem ) [EOL] continue [EOL] if isinstance ( elem , rowSpan ) : [EOL] rspan = elem . get ( [string] ) [EOL] elem . parent . remove ( elem ) [EOL] continue [EOL] return cspan , rspan , cellItem [ : ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $Study.sourcecode.linux-4.9.Documentation.sphinx.rstFlatTable.ListTableBuilder$ 0 0 0 0 0 0 $Study.sourcecode.linux-4.9.Documentation.sphinx.rstFlatTable.ListTableBuilder$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $Study.sourcecode.linux-4.9.Documentation.sphinx.rstFlatTable.ListTableBuilder$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import os . path [EOL] [EOL] from docutils import io , nodes , statemachine [EOL] from docutils . utils . error_reporting import SafeString , ErrorString [EOL] from docutils . parsers . rst import directives [EOL] from docutils . parsers . rst . directives . body import CodeBlock , NumberLines [EOL] from docutils . parsers . rst . directives . misc import Include [EOL] [EOL] __version__ = [string] [EOL] [EOL] [comment] [EOL] def setup ( app ) : [EOL] [comment] [EOL] [EOL] app . add_directive ( [string] , KernelInclude ) [EOL] return dict ( version = __version__ , parallel_read_safe = True , parallel_write_safe = True ) [EOL] [EOL] [comment] [EOL] class KernelInclude ( Include ) : [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] def run ( self ) : [EOL] path = os . path . realpath ( os . path . expandvars ( self . arguments [ [number] ] ) ) [EOL] [EOL] [comment] [EOL] if path . startswith ( os . sep + [string] ) : [EOL] raise self . severe ( [string] % ( self . name , path ) ) [EOL] [EOL] self . arguments [ [number] ] = path [EOL] [EOL] [comment] [EOL] return self . _run ( ) [EOL] [EOL] def _run ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if not self . state . document . settings . file_insertion_enabled : [EOL] raise self . warning ( [string] % self . name ) [EOL] source = self . state_machine . input_lines . source ( self . lineno - self . state_machine . input_offset - [number] ) [EOL] source_dir = os . path . dirname ( os . path . abspath ( source ) ) [EOL] path = directives . path ( self . arguments [ [number] ] ) [EOL] if path . startswith ( [string] ) and path . endswith ( [string] ) : [EOL] path = os . path . join ( self . standard_include_path , path [ [number] : - [number] ] ) [EOL] path = os . path . normpath ( os . path . join ( source_dir , path ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] path = nodes . reprunicode ( path ) [EOL] encoding = self . options . get ( [string] , self . state . document . settings . input_encoding ) [EOL] e_handler = self . state . document . settings . input_encoding_error_handler [EOL] tab_width = self . options . get ( [string] , self . state . document . settings . tab_width ) [EOL] try : [EOL] self . state . document . settings . record_dependencies . add ( path ) [EOL] include_file = io . FileInput ( source_path = path , encoding = encoding , error_handler = e_handler ) [EOL] except UnicodeEncodeError as error : [EOL] raise self . severe ( [string] [string] [string] % ( self . name , SafeString ( path ) ) ) [EOL] except IOError as error : [EOL] raise self . severe ( [string] % ( self . name , ErrorString ( error ) ) ) [EOL] startline = self . options . get ( [string] , None ) [EOL] endline = self . options . get ( [string] , None ) [EOL] try : [EOL] if startline or ( endline is not None ) : [EOL] lines = include_file . readlines ( ) [EOL] rawtext = [string] . join ( lines [ startline : endline ] ) [EOL] else : [EOL] rawtext = include_file . read ( ) [EOL] except UnicodeError as error : [EOL] raise self . severe ( [string] % ( self . name , ErrorString ( error ) ) ) [EOL] [comment] [EOL] [comment] [EOL] after_text = self . options . get ( [string] , None ) [EOL] if after_text : [EOL] [comment] [EOL] after_index = rawtext . find ( after_text ) [EOL] if after_index < [number] : [EOL] raise self . severe ( [string] [string] % self . name ) [EOL] rawtext = rawtext [ after_index + len ( after_text ) : ] [EOL] before_text = self . options . get ( [string] , None ) [EOL] if before_text : [EOL] [comment] [EOL] before_index = rawtext . find ( before_text ) [EOL] if before_index < [number] : [EOL] raise self . severe ( [string] [string] % self . name ) [EOL] rawtext = rawtext [ : before_index ] [EOL] [EOL] include_lines = statemachine . string2lines ( rawtext , tab_width , convert_whitespace = True ) [EOL] if [string] in self . options : [EOL] [comment] [EOL] if tab_width >= [number] : [EOL] text = rawtext . expandtabs ( tab_width ) [EOL] else : [EOL] text = rawtext [EOL] literal_block = nodes . literal_block ( rawtext , source = path , classes = self . options . get ( [string] , [ ] ) ) [EOL] literal_block . line = [number] [EOL] self . add_name ( literal_block ) [EOL] if [string] in self . options : [EOL] try : [EOL] startline = int ( self . options [ [string] ] or [number] ) [EOL] except ValueError : [EOL] raise self . error ( [string] [string] ) [EOL] endline = startline + len ( include_lines ) [EOL] if text . endswith ( [string] ) : [EOL] text = text [ : - [number] ] [EOL] tokens = NumberLines ( [ ( [ ] , text ) ] , startline , endline ) [EOL] for classes , value in tokens : [EOL] if classes : [EOL] literal_block += nodes . inline ( value , value , classes = classes ) [EOL] else : [EOL] literal_block += nodes . Text ( value , value ) [EOL] else : [EOL] literal_block += nodes . Text ( text , text ) [EOL] return [ literal_block ] [EOL] if [string] in self . options : [EOL] self . options [ [string] ] = path [EOL] codeblock = CodeBlock ( self . name , [ self . options . pop ( [string] ) ] , self . options , include_lines , self . lineno , self . content_offset , self . block_text , self . state , self . state_machine ) [EOL] return codeblock . run ( ) [EOL] self . state_machine . insert_input ( include_lines , path ) [EOL] return [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Type , List , Any , Dict [EOL] import typing [EOL] import Documentation [EOL] import Study [EOL] [docstring] [EOL] [EOL] from docutils import nodes [EOL] from docutils . parsers . rst import directives [EOL] [EOL] import sphinx [EOL] from sphinx import addnodes [EOL] from sphinx . domains . c import c_funcptr_sig_re , c_sig_re [EOL] from sphinx . domains . c import CObject as Base_CObject [EOL] from sphinx . domains . c import CDomain as Base_CDomain [EOL] [EOL] __version__ = [string] [EOL] [EOL] [comment] [EOL] major , minor , patch = map ( int , sphinx . __version__ . split ( [string] ) ) [EOL] [EOL] def setup ( app ) : [EOL] [EOL] app . override_domain ( CDomain ) [EOL] [EOL] return dict ( version = __version__ , parallel_read_safe = True , parallel_write_safe = True ) [EOL] [EOL] class CObject ( Base_CObject ) : [EOL] [EOL] [docstring] [EOL] option_spec = { [string] : directives . unchanged } [EOL] [EOL] def handle_func_like_macro ( self , sig , signode ) : [EOL] [docstring] [EOL] [EOL] if not self . objtype == [string] : [EOL] return False [EOL] [EOL] m = c_funcptr_sig_re . match ( sig ) [EOL] if m is None : [EOL] m = c_sig_re . match ( sig ) [EOL] if m is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] rettype , fullname , arglist , _const = m . groups ( ) [EOL] arglist = arglist . strip ( ) [EOL] if rettype or not arglist : [EOL] return False [EOL] [EOL] arglist = arglist . replace ( [string] , [string] ) . replace ( [string] , [string] ) [comment] [EOL] arglist = [ a . strip ( ) for a in arglist . split ( [string] ) ] [EOL] [EOL] [comment] [EOL] if len ( arglist [ [number] ] . split ( [string] ) ) > [number] : [EOL] return False [EOL] [EOL] [comment] [EOL] signode += addnodes . desc_name ( fullname , fullname ) [EOL] paramlist = addnodes . desc_parameterlist ( ) [EOL] signode += paramlist [EOL] [EOL] for argname in arglist : [EOL] param = addnodes . desc_parameter ( [string] , [string] , noemph = True ) [EOL] [comment] [EOL] param += nodes . emphasis ( argname , argname ) [EOL] paramlist += param [EOL] [EOL] return fullname [EOL] [EOL] def handle_signature ( self , sig , signode ) : [EOL] [docstring] [EOL] [EOL] fullname = self . handle_func_like_macro ( sig , signode ) [EOL] if not fullname : [EOL] fullname = super ( CObject , self ) . handle_signature ( sig , signode ) [EOL] [EOL] if [string] in self . options : [EOL] if self . objtype == [string] : [EOL] fullname = self . options [ [string] ] [EOL] else : [EOL] [comment] [EOL] pass [EOL] return fullname [EOL] [EOL] def add_target_and_index ( self , name , sig , signode ) : [EOL] [comment] [EOL] [comment] [EOL] targetname = [string] + name [EOL] if targetname not in self . state . document . ids : [EOL] signode [ [string] ] . append ( targetname ) [EOL] signode [ [string] ] . append ( targetname ) [EOL] signode [ [string] ] = ( not self . names ) [EOL] self . state . document . note_explicit_target ( signode ) [EOL] inv = self . env . domaindata [ [string] ] [ [string] ] [EOL] if ( name in inv and self . env . config . nitpicky ) : [EOL] if self . objtype == [string] : [EOL] if ( [string] , name ) not in self . env . config . nitpick_ignore : [EOL] self . state_machine . reporter . warning ( [string] % name + [string] + self . env . doc2path ( inv [ name ] [ [number] ] ) , line = self . lineno ) [EOL] inv [ name ] = ( self . env . docname , self . objtype ) [EOL] [EOL] indextext = self . get_index_text ( name ) [EOL] if indextext : [EOL] if major == [number] and minor < [number] : [EOL] [comment] [EOL] [comment] [EOL] self . indexnode [ [string] ] . append ( ( [string] , indextext , targetname , [string] ) ) [EOL] else : [EOL] self . indexnode [ [string] ] . append ( ( [string] , indextext , targetname , [string] , None ) ) [EOL] [EOL] class CDomain ( Base_CDomain ) : [EOL] [EOL] [docstring] [EOL] name = [string] [EOL] label = [string] [EOL] directives = { [string] : CObject , [string] : CObject , [string] : CObject , [string] : CObject , [string] : CObject , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import Any , List , Tuple , Dict [EOL] import typing [EOL] project = [string] [EOL] [EOL] [comment] [EOL] nitpicky = True [EOL] [EOL] [comment] [EOL] intersphinx_mapping = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] nitpick_ignore = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Pattern , Dict , List , Any , Set [EOL] import typing [EOL] import multiprocessing [EOL] import argparse [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import argparse [EOL] import difflib [EOL] import os [EOL] import re [EOL] import signal [EOL] import subprocess [EOL] import sys [EOL] from multiprocessing import Pool , cpu_count [EOL] [EOL] [EOL] [comment] [EOL] OPERATORS = [string] [EOL] SYMBOL = [string] [EOL] DEF = [string] + SYMBOL + [string] [EOL] EXPR = [string] + OPERATORS + [string] + SYMBOL + [string] [EOL] DEFAULT = [string] [EOL] STMT = [string] + DEFAULT + [string] + EXPR [EOL] SOURCE_SYMBOL = [string] + SYMBOL + [string] [EOL] [EOL] [comment] [EOL] REGEX_FILE_KCONFIG = re . compile ( [string] ) [EOL] REGEX_SYMBOL = re . compile ( [string] + SYMBOL + [string] ) [EOL] REGEX_SOURCE_SYMBOL = re . compile ( SOURCE_SYMBOL ) [EOL] REGEX_KCONFIG_DEF = re . compile ( DEF ) [EOL] REGEX_KCONFIG_EXPR = re . compile ( EXPR ) [EOL] REGEX_KCONFIG_STMT = re . compile ( STMT ) [EOL] REGEX_KCONFIG_HELP = re . compile ( [string] ) [EOL] REGEX_FILTER_SYMBOLS = re . compile ( [string] ) [EOL] REGEX_NUMERIC = re . compile ( [string] ) [EOL] REGEX_QUOTES = re . compile ( [string] ) [EOL] [EOL] [EOL] def parse_options ( ) : [EOL] [docstring] [EOL] usage = [string] [string] [string] [string] [string] [string] [EOL] [EOL] parser = argparse . ArgumentParser ( description = usage ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , action = [string] , default = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , action = [string] , default = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , action = [string] , default = False , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , action = [string] , default = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , action = [string] , default = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = False , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = True , help = [string] [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] if args . commit and args . diff : [EOL] sys . exit ( [string] ) [EOL] [EOL] if args . diff and not re . match ( [string] , args . diff ) : [EOL] sys . exit ( [string] [string] ) [EOL] [EOL] if args . commit or args . diff : [EOL] if not args . force and tree_is_dirty ( ) : [EOL] sys . exit ( [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] if args . commit : [EOL] args . find = False [EOL] [EOL] if args . ignore : [EOL] try : [EOL] re . match ( args . ignore , [string] ) [EOL] except : [EOL] sys . exit ( [string] ) [EOL] [EOL] return args [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] args = parse_options ( ) [EOL] [EOL] global COLOR [EOL] COLOR = args . color and sys . stdout . isatty ( ) [EOL] [EOL] if args . sim and not args . commit and not args . diff : [EOL] sims = find_sims ( args . sim , args . ignore ) [EOL] if sims : [EOL] print ( [string] % ( yel ( [string] ) , [string] . join ( sims ) ) ) [EOL] else : [EOL] print ( [string] % yel ( [string] ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [comment] [EOL] defined = { } [EOL] undefined = { } [EOL] [EOL] if args . commit or args . diff : [EOL] head = get_head ( ) [EOL] [EOL] [comment] [EOL] commit_a = None [EOL] commit_b = None [EOL] if args . commit : [EOL] commit_a = args . commit + [string] [EOL] commit_b = args . commit [EOL] elif args . diff : [EOL] split = args . diff . split ( [string] ) [EOL] commit_a = split [ [number] ] [EOL] commit_b = split [ [number] ] [EOL] undefined_a = { } [EOL] undefined_b = { } [EOL] [EOL] [comment] [EOL] reset ( commit_a ) [EOL] undefined_a , _ = check_symbols ( args . ignore ) [EOL] [EOL] [comment] [EOL] reset ( commit_b ) [EOL] undefined_b , defined = check_symbols ( args . ignore ) [EOL] [EOL] [comment] [EOL] for symbol in sorted ( undefined_b ) : [EOL] [comment] [EOL] if symbol not in undefined_a : [EOL] files = sorted ( undefined_b . get ( symbol ) ) [EOL] undefined [ symbol ] = files [EOL] [comment] [EOL] else : [EOL] files = sorted ( undefined_b . get ( symbol ) - undefined_a . get ( symbol ) ) [EOL] if files : [EOL] undefined [ symbol ] = files [EOL] [EOL] [comment] [EOL] reset ( head ) [EOL] [EOL] [comment] [EOL] else : [EOL] undefined , defined = check_symbols ( args . ignore ) [EOL] [EOL] [comment] [EOL] for symbol in sorted ( undefined ) : [EOL] print ( red ( symbol ) ) [EOL] [EOL] files = sorted ( undefined . get ( symbol ) ) [EOL] print ( [string] % ( yel ( [string] ) , [string] . join ( files ) ) ) [EOL] [EOL] sims = find_sims ( symbol , args . ignore , defined ) [EOL] sims_out = yel ( [string] ) [EOL] if sims : [EOL] print ( [string] % ( sims_out , [string] . join ( sims ) ) ) [EOL] else : [EOL] print ( [string] % ( sims_out , [string] ) ) [EOL] [EOL] if args . find : [EOL] print ( [string] % yel ( [string] ) ) [EOL] commits = find_commits ( symbol , args . diff ) [EOL] if commits : [EOL] for commit in commits : [EOL] commit = commit . split ( [string] , [number] ) [EOL] print ( [string] % ( yel ( commit [ [number] ] ) , commit [ [number] ] ) ) [EOL] else : [EOL] print ( [string] ) [EOL] print ( ) [comment] [EOL] [EOL] [EOL] def reset ( commit ) : [EOL] [docstring] [EOL] execute ( [ [string] , [string] , [string] , commit ] ) [EOL] [EOL] [EOL] def yel ( string ) : [EOL] [docstring] [EOL] return [string] % string if COLOR else string [EOL] [EOL] [EOL] def red ( string ) : [EOL] [docstring] [EOL] return [string] % string if COLOR else string [EOL] [EOL] [EOL] def execute ( cmd ) : [EOL] [docstring] [EOL] try : [EOL] stdout = subprocess . check_output ( cmd , stderr = subprocess . STDOUT , shell = False ) [EOL] stdout = stdout . decode ( errors = [string] ) [EOL] except subprocess . CalledProcessError as fail : [EOL] exit ( fail ) [EOL] return stdout [EOL] [EOL] [EOL] def find_commits ( symbol , diff ) : [EOL] [docstring] [EOL] commits = execute ( [ [string] , [string] , [string] , [string] , [string] , symbol , diff ] ) [EOL] return [ x for x in commits . split ( [string] ) if x ] [EOL] [EOL] [EOL] def tree_is_dirty ( ) : [EOL] [docstring] [EOL] stdout = execute ( [ [string] , [string] , [string] ] ) [EOL] for line in stdout : [EOL] if re . findall ( [string] , line [ : [number] ] ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def get_head ( ) : [EOL] [docstring] [EOL] stdout = execute ( [ [string] , [string] , [string] ] ) [EOL] return stdout . strip ( [string] ) [EOL] [EOL] [EOL] def partition ( lst , size ) : [EOL] [docstring] [EOL] return [ lst [ i : : size ] for i in range ( size ) ] [EOL] [EOL] [EOL] def init_worker ( ) : [EOL] [docstring] [EOL] signal . signal ( signal . SIGINT , signal . SIG_IGN ) [EOL] [EOL] [EOL] def find_sims ( symbol , ignore , defined = [ ] ) : [EOL] [docstring] [EOL] if defined : [EOL] return sorted ( difflib . get_close_matches ( symbol , set ( defined ) , [number] ) ) [EOL] [EOL] pool = Pool ( cpu_count ( ) , init_worker ) [EOL] kfiles = [ ] [EOL] for gitfile in get_files ( ) : [EOL] if REGEX_FILE_KCONFIG . match ( gitfile ) : [EOL] kfiles . append ( gitfile ) [EOL] [EOL] arglist = [ ] [EOL] for part in partition ( kfiles , cpu_count ( ) ) : [EOL] arglist . append ( ( part , ignore ) ) [EOL] [EOL] for res in pool . map ( parse_kconfig_files , arglist ) : [EOL] defined . extend ( res [ [number] ] ) [EOL] [EOL] return sorted ( difflib . get_close_matches ( symbol , set ( defined ) , [number] ) ) [EOL] [EOL] [EOL] def get_files ( ) : [EOL] [docstring] [EOL] [comment] [EOL] stdout = execute ( [ [string] , [string] ] ) [EOL] if len ( stdout ) > [number] and stdout [ - [number] ] == [string] : [EOL] stdout = stdout [ : - [number] ] [EOL] [EOL] files = [ ] [EOL] for gitfile in stdout . rsplit ( [string] ) : [EOL] if [string] in gitfile or [string] in gitfile or [string] in gitfile or os . path . isdir ( gitfile ) or gitfile . startswith ( [string] ) : [EOL] continue [EOL] files . append ( gitfile ) [EOL] return files [EOL] [EOL] [EOL] def check_symbols ( ignore ) : [EOL] [docstring] [EOL] pool = Pool ( cpu_count ( ) , init_worker ) [EOL] try : [EOL] return check_symbols_helper ( pool , ignore ) [EOL] except KeyboardInterrupt : [EOL] pool . terminate ( ) [EOL] pool . join ( ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def check_symbols_helper ( pool , ignore ) : [EOL] [docstring] [EOL] source_files = [ ] [EOL] kconfig_files = [ ] [EOL] defined_symbols = [ ] [EOL] referenced_symbols = dict ( ) [comment] [EOL] [EOL] for gitfile in get_files ( ) : [EOL] if REGEX_FILE_KCONFIG . match ( gitfile ) : [EOL] kconfig_files . append ( gitfile ) [EOL] else : [EOL] if ignore and not re . match ( ignore , gitfile ) : [EOL] continue [EOL] [comment] [EOL] source_files . append ( gitfile ) [EOL] [EOL] [comment] [EOL] arglist = partition ( source_files , cpu_count ( ) ) [EOL] for res in pool . map ( parse_source_files , arglist ) : [EOL] referenced_symbols . update ( res ) [EOL] [EOL] [comment] [EOL] arglist = [ ] [EOL] for part in partition ( kconfig_files , cpu_count ( ) ) : [EOL] arglist . append ( ( part , ignore ) ) [EOL] for res in pool . map ( parse_kconfig_files , arglist ) : [EOL] defined_symbols . extend ( res [ [number] ] ) [EOL] referenced_symbols . update ( res [ [number] ] ) [EOL] defined_symbols = set ( defined_symbols ) [EOL] [EOL] [comment] [EOL] inv_map = dict ( ) [EOL] for _file , symbols in referenced_symbols . items ( ) : [EOL] for symbol in symbols : [EOL] inv_map [ symbol ] = inv_map . get ( symbol , set ( ) ) [EOL] inv_map [ symbol ] . add ( _file ) [EOL] referenced_symbols = inv_map [EOL] [EOL] undefined = { } [comment] [EOL] for symbol in sorted ( referenced_symbols ) : [EOL] [comment] [EOL] if symbol == [string] or symbol == [string] or symbol == [string] or symbol == [string] : [EOL] continue [EOL] if symbol not in defined_symbols : [EOL] if symbol . endswith ( [string] ) : [EOL] [comment] [EOL] if symbol [ : - len ( [string] ) ] in defined_symbols : [EOL] continue [EOL] undefined [ symbol ] = referenced_symbols . get ( symbol ) [EOL] return undefined , defined_symbols [EOL] [EOL] [EOL] def parse_source_files ( source_files ) : [EOL] [docstring] [EOL] referenced_symbols = dict ( ) [EOL] for sfile in source_files : [EOL] referenced_symbols [ sfile ] = parse_source_file ( sfile ) [EOL] return referenced_symbols [EOL] [EOL] [EOL] def parse_source_file ( sfile ) : [EOL] [docstring] [EOL] lines = [ ] [EOL] references = [ ] [EOL] [EOL] if not os . path . exists ( sfile ) : [EOL] return references [EOL] [EOL] with open ( sfile , [string] , encoding = [string] , errors = [string] ) as stream : [EOL] lines = stream . readlines ( ) [EOL] [EOL] for line in lines : [EOL] if [string] not in line : [EOL] continue [EOL] symbols = REGEX_SOURCE_SYMBOL . findall ( line ) [EOL] for symbol in symbols : [EOL] if not REGEX_FILTER_SYMBOLS . search ( symbol ) : [EOL] continue [EOL] references . append ( symbol ) [EOL] [EOL] return references [EOL] [EOL] [EOL] def get_symbols_in_line ( line ) : [EOL] [docstring] [EOL] return REGEX_SYMBOL . findall ( line ) [EOL] [EOL] [EOL] def parse_kconfig_files ( args ) : [EOL] [docstring] [EOL] kconfig_files = args [ [number] ] [EOL] ignore = args [ [number] ] [EOL] defined_symbols = [ ] [EOL] referenced_symbols = dict ( ) [EOL] [EOL] for kfile in kconfig_files : [EOL] defined , references = parse_kconfig_file ( kfile ) [EOL] defined_symbols . extend ( defined ) [EOL] if ignore and re . match ( ignore , kfile ) : [EOL] [comment] [EOL] continue [EOL] referenced_symbols [ kfile ] = references [EOL] return ( defined_symbols , referenced_symbols ) [EOL] [EOL] [EOL] def parse_kconfig_file ( kfile ) : [EOL] [docstring] [EOL] lines = [ ] [EOL] defined = [ ] [EOL] references = [ ] [EOL] skip = False [EOL] [EOL] if not os . path . exists ( kfile ) : [EOL] return defined , references [EOL] [EOL] with open ( kfile , [string] , encoding = [string] , errors = [string] ) as stream : [EOL] lines = stream . readlines ( ) [EOL] [EOL] for i in range ( len ( lines ) ) : [EOL] line = lines [ i ] [EOL] line = line . strip ( [string] ) [EOL] line = line . split ( [string] ) [ [number] ] [comment] [EOL] [EOL] if REGEX_KCONFIG_DEF . match ( line ) : [EOL] symbol_def = REGEX_KCONFIG_DEF . findall ( line ) [EOL] defined . append ( symbol_def [ [number] ] ) [EOL] skip = False [EOL] elif REGEX_KCONFIG_HELP . match ( line ) : [EOL] skip = True [EOL] elif skip : [EOL] [comment] [EOL] pass [EOL] elif REGEX_KCONFIG_STMT . match ( line ) : [EOL] line = REGEX_QUOTES . sub ( [string] , line ) [EOL] symbols = get_symbols_in_line ( line ) [EOL] [comment] [EOL] while line . endswith ( [string] ) : [EOL] i += [number] [EOL] line = lines [ i ] [EOL] line = line . strip ( [string] ) [EOL] symbols . extend ( get_symbols_in_line ( line ) ) [EOL] for symbol in set ( symbols ) : [EOL] if REGEX_NUMERIC . match ( symbol ) : [EOL] [comment] [EOL] continue [EOL] references . append ( symbol ) [EOL] [EOL] return defined , references [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import gdb [EOL] [EOL] from linux import tasks , utils [EOL] [EOL] [EOL] MAX_CPUS = [number] [EOL] [EOL] [EOL] def get_current_cpu ( ) : [EOL] if utils . get_gdbserver_type ( ) == utils . GDBSERVER_QEMU : [EOL] return gdb . selected_thread ( ) . num - [number] [EOL] elif utils . get_gdbserver_type ( ) == utils . GDBSERVER_KGDB : [EOL] tid = gdb . selected_thread ( ) . ptid [ [number] ] [EOL] if tid > ( [number] - MAX_CPUS - [number] ) : [EOL] return [number] - tid - [number] [EOL] else : [EOL] return tasks . get_thread_info ( tasks . get_task_by_pid ( tid ) ) [ [string] ] [EOL] else : [EOL] raise gdb . GdbError ( [string] [string] ) [EOL] [EOL] [EOL] def per_cpu ( var_ptr , cpu ) : [EOL] if cpu == - [number] : [EOL] cpu = get_current_cpu ( ) [EOL] if utils . is_target_arch ( [string] ) : [EOL] offset = gdb . parse_and_eval ( [string] . format ( str ( cpu ) ) ) [EOL] else : [EOL] try : [EOL] offset = gdb . parse_and_eval ( [string] . format ( str ( cpu ) ) ) [EOL] except gdb . error : [EOL] [comment] [EOL] offset = [number] [EOL] pointer = var_ptr . cast ( utils . get_long_type ( ) ) + offset [EOL] return pointer . cast ( var_ptr . type ) . dereference ( ) [EOL] [EOL] [EOL] cpu_mask = { } [EOL] [EOL] [EOL] def cpu_mask_invalidate ( event ) : [EOL] global cpu_mask [EOL] cpu_mask = { } [EOL] gdb . events . stop . disconnect ( cpu_mask_invalidate ) [EOL] if hasattr ( gdb . events , [string] ) : [EOL] gdb . events . new_objfile . disconnect ( cpu_mask_invalidate ) [EOL] [EOL] [EOL] def cpu_list ( mask_name ) : [EOL] global cpu_mask [EOL] mask = None [EOL] if mask_name in cpu_mask : [EOL] mask = cpu_mask [ mask_name ] [EOL] if mask is None : [EOL] mask = gdb . parse_and_eval ( mask_name + [string] ) [EOL] if hasattr ( gdb , [string] ) : [EOL] cpu_mask [ mask_name ] = mask [EOL] gdb . events . stop . connect ( cpu_mask_invalidate ) [EOL] if hasattr ( gdb . events , [string] ) : [EOL] gdb . events . new_objfile . connect ( cpu_mask_invalidate ) [EOL] bits_per_entry = mask [ [number] ] . type . sizeof * [number] [EOL] num_entries = mask . type . sizeof * [number] / bits_per_entry [EOL] entry = - [number] [EOL] bits = [number] [EOL] [EOL] while True : [EOL] while bits == [number] : [EOL] entry += [number] [EOL] if entry == num_entries : [EOL] return [EOL] bits = mask [ entry ] [EOL] if bits != [number] : [EOL] bit = [number] [EOL] break [EOL] [EOL] while bits & [number] == [number] : [EOL] bits >>= [number] [EOL] bit += [number] [EOL] [EOL] cpu = entry * bits_per_entry + bit [EOL] [EOL] bits >>= [number] [EOL] bit += [number] [EOL] [EOL] yield int ( cpu ) [EOL] [EOL] [EOL] def each_online_cpu ( ) : [EOL] for cpu in cpu_list ( [string] ) : [EOL] yield cpu [EOL] [EOL] [EOL] def each_present_cpu ( ) : [EOL] for cpu in cpu_list ( [string] ) : [EOL] yield cpu [EOL] [EOL] [EOL] def each_possible_cpu ( ) : [EOL] for cpu in cpu_list ( [string] ) : [EOL] yield cpu [EOL] [EOL] [EOL] def each_active_cpu ( ) : [EOL] for cpu in cpu_list ( [string] ) : [EOL] yield cpu [EOL] [EOL] [EOL] class LxCpus ( gdb . Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxCpus , self ) . __init__ ( [string] , gdb . COMMAND_DATA ) [EOL] [EOL] def invoke ( self , arg , from_tty ) : [EOL] gdb . write ( [string] . format ( list ( each_possible_cpu ( ) ) ) ) [EOL] gdb . write ( [string] . format ( list ( each_present_cpu ( ) ) ) ) [EOL] gdb . write ( [string] . format ( list ( each_online_cpu ( ) ) ) ) [EOL] gdb . write ( [string] . format ( list ( each_active_cpu ( ) ) ) ) [EOL] [EOL] LxCpus ( ) [EOL] [EOL] [EOL] class PerCpu ( gdb . Function ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( PerCpu , self ) . __init__ ( [string] ) [EOL] [EOL] def invoke ( self , var_name , cpu = - [number] ) : [EOL] var_ptr = gdb . parse_and_eval ( [string] + var_name . string ( ) ) [EOL] return per_cpu ( var_ptr , cpu ) [EOL] [EOL] [EOL] PerCpu ( ) [EOL] [EOL] [EOL] class LxCurrentFunc ( gdb . Function ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxCurrentFunc , self ) . __init__ ( [string] ) [EOL] [EOL] def invoke ( self , cpu = - [number] ) : [EOL] var_ptr = gdb . parse_and_eval ( [string] ) [EOL] return per_cpu ( var_ptr , cpu ) . dereference ( ) [EOL] [EOL] [EOL] LxCurrentFunc ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type [EOL] import typing [EOL] import Study [EOL] import scripts [EOL] import gdb [EOL] [EOL] from linux import cpus , utils , lists [EOL] [EOL] [EOL] module_type = utils . CachedType ( [string] ) [EOL] [EOL] [EOL] def module_list ( ) : [EOL] global module_type [EOL] modules = utils . gdb_eval_or_none ( [string] ) [EOL] if modules is None : [EOL] return [EOL] [EOL] module_ptr_type = module_type . get_type ( ) . pointer ( ) [EOL] [EOL] for module in lists . list_for_each_entry ( modules , module_ptr_type , [string] ) : [EOL] yield module [EOL] [EOL] [EOL] def find_module_by_name ( name ) : [EOL] for module in module_list ( ) : [EOL] if module [ [string] ] . string ( ) == name : [EOL] return module [EOL] return None [EOL] [EOL] [EOL] class LxModule ( gdb . Function ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxModule , self ) . __init__ ( [string] ) [EOL] [EOL] def invoke ( self , mod_name ) : [EOL] mod_name = mod_name . string ( ) [EOL] module = find_module_by_name ( mod_name ) [EOL] if module : [EOL] return module . dereference ( ) [EOL] else : [EOL] raise gdb . GdbError ( [string] + mod_name ) [EOL] [EOL] [EOL] LxModule ( ) [EOL] [EOL] [EOL] class LxLsmod ( gdb . Command ) : [EOL] [docstring] [EOL] [EOL] _module_use_type = utils . CachedType ( [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxLsmod , self ) . __init__ ( [string] , gdb . COMMAND_DATA ) [EOL] [EOL] def invoke ( self , arg , from_tty ) : [EOL] gdb . write ( [string] . format ( [string] if utils . get_long_type ( ) . sizeof == [number] else [string] ) ) [EOL] [EOL] for module in module_list ( ) : [EOL] layout = module [ [string] ] [EOL] gdb . write ( [string] . format ( address = str ( layout [ [string] ] ) . split ( ) [ [number] ] , name = module [ [string] ] . string ( ) , size = str ( layout [ [string] ] ) , ref = str ( module [ [string] ] [ [string] ] - [number] ) ) ) [EOL] [EOL] t = self . _module_use_type . get_type ( ) . pointer ( ) [EOL] first = True [EOL] sources = module [ [string] ] [EOL] for use in lists . list_for_each_entry ( sources , t , [string] ) : [EOL] gdb . write ( [string] . format ( separator = [string] if first else [string] , name = use [ [string] ] [ [string] ] . string ( ) ) ) [EOL] first = False [EOL] [EOL] gdb . write ( [string] ) [EOL] [EOL] [EOL] LxLsmod ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import gdb [EOL] [EOL] from linux import utils [EOL] [EOL] list_head = utils . CachedType ( [string] ) [EOL] [EOL] [EOL] def list_for_each ( head ) : [EOL] if head . type == list_head . get_type ( ) . pointer ( ) : [EOL] head = head . dereference ( ) [EOL] elif head . type != list_head . get_type ( ) : [EOL] raise gdb . GdbError ( [string] . format ( head . type ) ) [EOL] [EOL] node = head [ [string] ] . dereference ( ) [EOL] while node . address != head . address : [EOL] yield node . address [EOL] node = node [ [string] ] . dereference ( ) [EOL] [EOL] [EOL] def list_for_each_entry ( head , gdbtype , member ) : [EOL] for node in list_for_each ( head ) : [EOL] if node . type != list_head . get_type ( ) . pointer ( ) : [EOL] raise TypeError ( [string] . format ( node . type ) ) [EOL] yield utils . container_of ( node , gdbtype , member ) [EOL] [EOL] [EOL] def list_check ( head ) : [EOL] nb = [number] [EOL] if ( head . type == list_head . get_type ( ) . pointer ( ) ) : [EOL] head = head . dereference ( ) [EOL] elif ( head . type != list_head . get_type ( ) ) : [EOL] raise gdb . GdbError ( [string] ) [EOL] c = head [EOL] try : [EOL] gdb . write ( [string] . format ( c ) ) [EOL] except gdb . MemoryError : [EOL] gdb . write ( [string] ) [EOL] return [EOL] while True : [EOL] p = c [ [string] ] . dereference ( ) [EOL] n = c [ [string] ] . dereference ( ) [EOL] try : [EOL] if p [ [string] ] != c . address : [EOL] gdb . write ( [string] [string] [string] . format ( current_addr = c . address , current = c , p_addr = p . address , p = p , ) ) [EOL] return [EOL] except gdb . MemoryError : [EOL] gdb . write ( [string] [string] . format ( current_addr = c . address , current = c ) ) [EOL] return [EOL] try : [EOL] if n [ [string] ] != c . address : [EOL] gdb . write ( [string] [string] [string] . format ( current_addr = c . address , current = c , n_addr = n . address , n = n , ) ) [EOL] return [EOL] except gdb . MemoryError : [EOL] gdb . write ( [string] [string] . format ( current_addr = c . address , current = c ) ) [EOL] return [EOL] c = n [EOL] nb += [number] [EOL] if c == head : [EOL] gdb . write ( [string] . format ( nb ) ) [EOL] return [EOL] [EOL] [EOL] class LxListChk ( gdb . Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxListChk , self ) . __init__ ( [string] , gdb . COMMAND_DATA , gdb . COMPLETE_EXPRESSION ) [EOL] [EOL] def invoke ( self , arg , from_tty ) : [EOL] argv = gdb . string_to_argv ( arg ) [EOL] if len ( argv ) != [number] : [EOL] raise gdb . GdbError ( [string] ) [EOL] list_check ( gdb . parse_and_eval ( argv [ [number] ] ) ) [EOL] [EOL] LxListChk ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Any [EOL] import typing [EOL] import Study [EOL] import scripts [EOL] import gdb [EOL] [EOL] [EOL] class CachedType : [EOL] def __init__ ( self , name ) : [EOL] self . _type = None [EOL] self . _name = name [EOL] [EOL] def _new_objfile_handler ( self , event ) : [EOL] self . _type = None [EOL] gdb . events . new_objfile . disconnect ( self . _new_objfile_handler ) [EOL] [EOL] def get_type ( self ) : [EOL] if self . _type is None : [EOL] self . _type = gdb . lookup_type ( self . _name ) [EOL] if self . _type is None : [EOL] raise gdb . GdbError ( [string] . format ( self . _name ) ) [EOL] if hasattr ( gdb , [string] ) and hasattr ( gdb . events , [string] ) : [EOL] gdb . events . new_objfile . connect ( self . _new_objfile_handler ) [EOL] return self . _type [EOL] [EOL] [EOL] long_type = CachedType ( [string] ) [EOL] [EOL] [EOL] def get_long_type ( ) : [EOL] global long_type [EOL] return long_type . get_type ( ) [EOL] [EOL] [EOL] def offset_of ( typeobj , field ) : [EOL] element = gdb . Value ( [number] ) . cast ( typeobj ) [EOL] return int ( str ( element [ field ] . address ) . split ( ) [ [number] ] , [number] ) [EOL] [EOL] [EOL] def container_of ( ptr , typeobj , member ) : [EOL] return ( ptr . cast ( get_long_type ( ) ) - offset_of ( typeobj , member ) ) . cast ( typeobj ) [EOL] [EOL] [EOL] class ContainerOf ( gdb . Function ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ContainerOf , self ) . __init__ ( [string] ) [EOL] [EOL] def invoke ( self , ptr , typename , elementname ) : [EOL] return container_of ( ptr , gdb . lookup_type ( typename . string ( ) ) . pointer ( ) , elementname . string ( ) ) [EOL] [EOL] ContainerOf ( ) [EOL] [EOL] [EOL] BIG_ENDIAN = [number] [EOL] LITTLE_ENDIAN = [number] [EOL] target_endianness = None [EOL] [EOL] [EOL] def get_target_endianness ( ) : [EOL] global target_endianness [EOL] if target_endianness is None : [EOL] endian = gdb . execute ( [string] , to_string = True ) [EOL] if [string] in endian : [EOL] target_endianness = LITTLE_ENDIAN [EOL] elif [string] in endian : [EOL] target_endianness = BIG_ENDIAN [EOL] else : [EOL] raise gdb . GdbError ( [string] . format ( str ( endian ) ) ) [EOL] return target_endianness [EOL] [EOL] [EOL] def read_memoryview ( inf , start , length ) : [EOL] return memoryview ( inf . read_memory ( start , length ) ) [EOL] [EOL] [EOL] def read_u16 ( buffer ) : [EOL] value = [ [number] , [number] ] [EOL] [EOL] if type ( buffer [ [number] ] ) is str : [EOL] value [ [number] ] = ord ( buffer [ [number] ] ) [EOL] value [ [number] ] = ord ( buffer [ [number] ] ) [EOL] else : [EOL] value [ [number] ] = buffer [ [number] ] [EOL] value [ [number] ] = buffer [ [number] ] [EOL] [EOL] if get_target_endianness ( ) == LITTLE_ENDIAN : [EOL] return value [ [number] ] + ( value [ [number] ] << [number] ) [EOL] else : [EOL] return value [ [number] ] + ( value [ [number] ] << [number] ) [EOL] [EOL] [EOL] def read_u32 ( buffer ) : [EOL] if get_target_endianness ( ) == LITTLE_ENDIAN : [EOL] return read_u16 ( buffer [ [number] : [number] ] ) + ( read_u16 ( buffer [ [number] : [number] ] ) << [number] ) [EOL] else : [EOL] return read_u16 ( buffer [ [number] : [number] ] ) + ( read_u16 ( buffer [ [number] : [number] ] ) << [number] ) [EOL] [EOL] [EOL] def read_u64 ( buffer ) : [EOL] if get_target_endianness ( ) == LITTLE_ENDIAN : [EOL] return read_u32 ( buffer [ [number] : [number] ] ) + ( read_u32 ( buffer [ [number] : [number] ] ) << [number] ) [EOL] else : [EOL] return read_u32 ( buffer [ [number] : [number] ] ) + ( read_u32 ( buffer [ [number] : [number] ] ) << [number] ) [EOL] [EOL] [EOL] target_arch = None [EOL] [EOL] [EOL] def is_target_arch ( arch ) : [EOL] if hasattr ( gdb . Frame , [string] ) : [EOL] return arch in gdb . newest_frame ( ) . architecture ( ) . name ( ) [EOL] else : [EOL] global target_arch [EOL] if target_arch is None : [EOL] target_arch = gdb . execute ( [string] , to_string = True ) [EOL] return arch in target_arch [EOL] [EOL] [EOL] GDBSERVER_QEMU = [number] [EOL] GDBSERVER_KGDB = [number] [EOL] gdbserver_type = None [EOL] [EOL] [EOL] def get_gdbserver_type ( ) : [EOL] def exit_handler ( event ) : [EOL] global gdbserver_type [EOL] gdbserver_type = None [EOL] gdb . events . exited . disconnect ( exit_handler ) [EOL] [EOL] def probe_qemu ( ) : [EOL] try : [EOL] return gdb . execute ( [string] , to_string = True ) != [string] [EOL] except : [EOL] return False [EOL] [EOL] def probe_kgdb ( ) : [EOL] try : [EOL] thread_info = gdb . execute ( [string] , to_string = True ) [EOL] return [string] in thread_info [EOL] except : [EOL] return False [EOL] [EOL] global gdbserver_type [EOL] if gdbserver_type is None : [EOL] if probe_qemu ( ) : [EOL] gdbserver_type = GDBSERVER_QEMU [EOL] elif probe_kgdb ( ) : [EOL] gdbserver_type = GDBSERVER_KGDB [EOL] if gdbserver_type is not None and hasattr ( gdb , [string] ) : [EOL] gdb . events . exited . connect ( exit_handler ) [EOL] return gdbserver_type [EOL] [EOL] [EOL] def gdb_eval_or_none ( expresssion ) : [EOL] try : [EOL] return gdb . parse_and_eval ( expresssion ) [EOL] except : [EOL] return None [EOL] [EOL] [EOL] def dentry_name ( d ) : [EOL] parent = d [ [string] ] [EOL] if parent == d or parent == [number] : [EOL] return [string] [EOL] p = dentry_name ( d [ [string] ] ) + [string] [EOL] return p + d [ [string] ] . string ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 $builtins.int$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import gdb [EOL] [EOL] from linux import utils [EOL] [EOL] [EOL] task_type = utils . CachedType ( [string] ) [EOL] [EOL] [EOL] def task_lists ( ) : [EOL] task_ptr_type = task_type . get_type ( ) . pointer ( ) [EOL] init_task = gdb . parse_and_eval ( [string] ) . address [EOL] t = g = init_task [EOL] [EOL] while True : [EOL] while True : [EOL] yield t [EOL] [EOL] t = utils . container_of ( t [ [string] ] [ [string] ] , task_ptr_type , [string] ) [EOL] if t == g : [EOL] break [EOL] [EOL] t = g = utils . container_of ( g [ [string] ] [ [string] ] , task_ptr_type , [string] ) [EOL] if t == init_task : [EOL] return [EOL] [EOL] [EOL] def get_task_by_pid ( pid ) : [EOL] for task in task_lists ( ) : [EOL] if int ( task [ [string] ] ) == pid : [EOL] return task [EOL] return None [EOL] [EOL] [EOL] class LxTaskByPidFunc ( gdb . Function ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxTaskByPidFunc , self ) . __init__ ( [string] ) [EOL] [EOL] def invoke ( self , pid ) : [EOL] task = get_task_by_pid ( pid ) [EOL] if task : [EOL] return task . dereference ( ) [EOL] else : [EOL] raise gdb . GdbError ( [string] + str ( pid ) ) [EOL] [EOL] [EOL] LxTaskByPidFunc ( ) [EOL] [EOL] [EOL] class LxPs ( gdb . Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxPs , self ) . __init__ ( [string] , gdb . COMMAND_DATA ) [EOL] [EOL] def invoke ( self , arg , from_tty ) : [EOL] for task in task_lists ( ) : [EOL] gdb . write ( [string] . format ( address = task , pid = task [ [string] ] , comm = task [ [string] ] . string ( ) ) ) [EOL] [EOL] LxPs ( ) [EOL] [EOL] [EOL] thread_info_type = utils . CachedType ( [string] ) [EOL] [EOL] ia64_task_size = None [EOL] [EOL] [EOL] def get_thread_info ( task ) : [EOL] thread_info_ptr_type = thread_info_type . get_type ( ) . pointer ( ) [EOL] if utils . is_target_arch ( [string] ) : [EOL] global ia64_task_size [EOL] if ia64_task_size is None : [EOL] ia64_task_size = gdb . parse_and_eval ( [string] ) [EOL] thread_info_addr = task . address + ia64_task_size [EOL] thread_info = thread_info_addr . cast ( thread_info_ptr_type ) [EOL] else : [EOL] thread_info = task [ [string] ] . cast ( thread_info_ptr_type ) [EOL] return thread_info . dereference ( ) [EOL] [EOL] [EOL] class LxThreadInfoFunc ( gdb . Function ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxThreadInfoFunc , self ) . __init__ ( [string] ) [EOL] [EOL] def invoke ( self , task ) : [EOL] return get_thread_info ( task ) [EOL] [EOL] [EOL] LxThreadInfoFunc ( ) [EOL] [EOL] [EOL] class LxThreadInfoByPidFunc ( gdb . Function ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxThreadInfoByPidFunc , self ) . __init__ ( [string] ) [EOL] [EOL] def invoke ( self , pid ) : [EOL] task = get_task_by_pid ( pid ) [EOL] if task : [EOL] return get_thread_info ( task . dereference ( ) ) [EOL] else : [EOL] raise gdb . GdbError ( [string] + str ( pid ) ) [EOL] [EOL] LxThreadInfoByPidFunc ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type , Dict , List [EOL] import typing [EOL] import Study [EOL] import scripts [EOL] import gdb [EOL] import os [EOL] import re [EOL] [EOL] from linux import modules [EOL] [EOL] [EOL] if hasattr ( gdb , [string] ) : [EOL] class LoadModuleBreakpoint ( gdb . Breakpoint ) : [EOL] def __init__ ( self , spec , gdb_command ) : [EOL] super ( LoadModuleBreakpoint , self ) . __init__ ( spec , internal = True ) [EOL] self . silent = True [EOL] self . gdb_command = gdb_command [EOL] [EOL] def stop ( self ) : [EOL] module = gdb . parse_and_eval ( [string] ) [EOL] module_name = module [ [string] ] . string ( ) [EOL] cmd = self . gdb_command [EOL] [EOL] [comment] [EOL] cmd . module_files_updated = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] show_pagination = gdb . execute ( [string] , to_string = True ) [EOL] pagination = show_pagination . endswith ( [string] ) [EOL] gdb . execute ( [string] ) [EOL] [EOL] if module_name in cmd . loaded_modules : [EOL] gdb . write ( [string] [string] . format ( module_name ) ) [EOL] cmd . load_all_symbols ( ) [EOL] else : [EOL] cmd . load_module_symbols ( module ) [EOL] [EOL] [comment] [EOL] gdb . execute ( [string] % ( [string] if pagination else [string] ) ) [EOL] [EOL] return False [EOL] [EOL] [EOL] class LxSymbols ( gdb . Command ) : [EOL] [docstring] [EOL] [EOL] module_paths = [ ] [EOL] module_files = [ ] [EOL] module_files_updated = False [EOL] loaded_modules = [ ] [EOL] breakpoint = None [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxSymbols , self ) . __init__ ( [string] , gdb . COMMAND_FILES , gdb . COMPLETE_FILENAME ) [EOL] [EOL] def _update_module_files ( self ) : [EOL] self . module_files = [ ] [EOL] for path in self . module_paths : [EOL] gdb . write ( [string] . format ( path ) ) [EOL] for root , dirs , files in os . walk ( path ) : [EOL] for name in files : [EOL] if name . endswith ( [string] ) : [EOL] self . module_files . append ( root + [string] + name ) [EOL] self . module_files_updated = True [EOL] [EOL] def _get_module_file ( self , module_name ) : [EOL] module_pattern = [string] . format ( module_name . replace ( [string] , [string] ) ) [EOL] for name in self . module_files : [EOL] if re . match ( module_pattern , name ) and os . path . exists ( name ) : [EOL] return name [EOL] return None [EOL] [EOL] def _section_arguments ( self , module ) : [EOL] try : [EOL] sect_attrs = module [ [string] ] . dereference ( ) [EOL] except gdb . error : [EOL] return [string] [EOL] attrs = sect_attrs [ [string] ] [EOL] section_name_to_address = { attrs [ n ] [ [string] ] . string ( ) : attrs [ n ] [ [string] ] for n in range ( int ( sect_attrs [ [string] ] ) ) } [EOL] args = [ ] [EOL] for section_name in [ [string] , [string] , [string] , [string] ] : [EOL] address = section_name_to_address . get ( section_name ) [EOL] if address : [EOL] args . append ( [string] . format ( name = section_name , addr = str ( address ) ) ) [EOL] return [string] . join ( args ) [EOL] [EOL] def load_module_symbols ( self , module ) : [EOL] module_name = module [ [string] ] . string ( ) [EOL] module_addr = str ( module [ [string] ] [ [string] ] ) . split ( ) [ [number] ] [EOL] [EOL] module_file = self . _get_module_file ( module_name ) [EOL] if not module_file and not self . module_files_updated : [EOL] self . _update_module_files ( ) [EOL] module_file = self . _get_module_file ( module_name ) [EOL] [EOL] if module_file : [EOL] gdb . write ( [string] . format ( addr = module_addr , filename = module_file ) ) [EOL] cmdline = [string] . format ( filename = module_file , addr = module_addr , sections = self . _section_arguments ( module ) ) [EOL] gdb . execute ( cmdline , to_string = True ) [EOL] if module_name not in self . loaded_modules : [EOL] self . loaded_modules . append ( module_name ) [EOL] else : [EOL] gdb . write ( [string] . format ( module_name ) ) [EOL] [EOL] def load_all_symbols ( self ) : [EOL] gdb . write ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] saved_states = [ ] [EOL] if hasattr ( gdb , [string] ) and not gdb . breakpoints ( ) is None : [EOL] for bp in gdb . breakpoints ( ) : [EOL] saved_states . append ( { [string] : bp , [string] : bp . enabled } ) [EOL] [EOL] [comment] [EOL] gdb . execute ( [string] , to_string = True ) [EOL] gdb . execute ( [string] ) [EOL] [EOL] self . loaded_modules = [ ] [EOL] module_list = modules . module_list ( ) [EOL] if not module_list : [EOL] gdb . write ( [string] ) [EOL] else : [EOL] [ self . load_module_symbols ( module ) for module in module_list ] [EOL] [EOL] for saved_state in saved_states : [EOL] saved_state [ [string] ] . enabled = saved_state [ [string] ] [EOL] [EOL] def invoke ( self , arg , from_tty ) : [EOL] self . module_paths = [ os . path . expanduser ( p ) for p in arg . split ( ) ] [EOL] self . module_paths . append ( os . getcwd ( ) ) [EOL] [EOL] [comment] [EOL] self . module_files = [ ] [EOL] self . module_files_updated = False [EOL] [EOL] self . load_all_symbols ( ) [EOL] [EOL] if hasattr ( gdb , [string] ) : [EOL] if self . breakpoint is not None : [EOL] self . breakpoint . delete ( ) [EOL] self . breakpoint = None [EOL] self . breakpoint = LoadModuleBreakpoint ( [string] , self ) [EOL] else : [EOL] gdb . write ( [string] [string] ) [EOL] [EOL] [EOL] LxSymbols ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import gdb [EOL] [EOL] from linux import utils [EOL] [EOL] [EOL] class LxDmesg ( gdb . Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( LxDmesg , self ) . __init__ ( [string] , gdb . COMMAND_DATA ) [EOL] [EOL] def invoke ( self , arg , from_tty ) : [EOL] log_buf_addr = int ( str ( gdb . parse_and_eval ( [string] ) ) . split ( ) [ [number] ] , [number] ) [EOL] log_first_idx = int ( gdb . parse_and_eval ( [string] ) ) [EOL] log_next_idx = int ( gdb . parse_and_eval ( [string] ) ) [EOL] log_buf_len = int ( gdb . parse_and_eval ( [string] ) ) [EOL] [EOL] inf = gdb . inferiors ( ) [ [number] ] [EOL] start = log_buf_addr + log_first_idx [EOL] if log_first_idx < log_next_idx : [EOL] log_buf_2nd_half = - [number] [EOL] length = log_next_idx - log_first_idx [EOL] log_buf = utils . read_memoryview ( inf , start , length ) . tobytes ( ) [EOL] else : [EOL] log_buf_2nd_half = log_buf_len - log_first_idx [EOL] a = utils . read_memoryview ( inf , start , log_buf_2nd_half ) [EOL] b = utils . read_memoryview ( inf , log_buf_addr , log_next_idx ) [EOL] log_buf = a . tobytes ( ) + b . tobytes ( ) [EOL] [EOL] pos = [number] [EOL] while pos < log_buf . __len__ ( ) : [EOL] length = utils . read_u16 ( log_buf [ pos + [number] : pos + [number] ] ) [EOL] if length == [number] : [EOL] if log_buf_2nd_half == - [number] : [EOL] gdb . write ( [string] ) [EOL] break [EOL] pos = log_buf_2nd_half [EOL] continue [EOL] [EOL] text_len = utils . read_u16 ( log_buf [ pos + [number] : pos + [number] ] ) [EOL] text = log_buf [ pos + [number] : pos + [number] + text_len ] . decode ( ) [EOL] time_stamp = utils . read_u64 ( log_buf [ pos : pos + [number] ] ) [EOL] [EOL] for line in text . splitlines ( ) : [EOL] gdb . write ( [string] . format ( time = time_stamp / [number] , line = line ) ) [EOL] [EOL] pos += length [EOL] [EOL] [EOL] LxDmesg ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , List , Optional , Any , Match , Counter [EOL] import typing [EOL] import collections [EOL] from collections import Counter [EOL] import glob [EOL] import re [EOL] import sys [EOL] [EOL] def parse_map_file ( path ) : [EOL] [docstring] [EOL] syms = [ ] [EOL] with open ( path ) as f : [EOL] for line in f : [EOL] m = re . match ( [string] , line ) [EOL] if m : [EOL] syms . append ( m . group ( [number] ) ) [EOL] return syms [EOL] [EOL] def parse_test_case ( path ) : [EOL] [docstring] [EOL] with open ( path ) as f : [EOL] for line in f : [EOL] for m in re . finditer ( [string] , line ) : [EOL] yield m . group ( [number] ) [EOL] [EOL] def find_test_cases ( ) : [EOL] for path in glob . glob ( [string] ) : [EOL] yield path [EOL] [EOL] api_syms = parse_map_file ( [string] ) [EOL] [EOL] syms_in_test_cases = { } [EOL] for path in find_test_cases ( ) : [EOL] syms_in_test_cases [ path ] = list ( parse_test_case ( path ) ) [EOL] [EOL] uses = Counter ( ) [EOL] for sym in sorted ( api_syms ) : [EOL] print ( [string] % sym ) [EOL] uses [ sym ] = [number] [EOL] for path in syms_in_test_cases : [EOL] count = syms_in_test_cases [ path ] . count ( sym ) [EOL] uses [ sym ] += count [EOL] if count : [EOL] print ( [string] % ( path , count ) ) [EOL] if uses [ sym ] == [number] : [EOL] print ( [string] ) [EOL] sys . stdout . write ( [string] ) [EOL] [EOL] layout = [string] [EOL] print ( layout % ( [string] , [string] , [string] ) ) [EOL] for sym , count in uses . most_common ( ) : [EOL] print ( layout % ( sym , count , [string] * count if count else [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Callable , Dict [EOL] import typing [EOL] import os [EOL] import re [EOL] import sys [EOL] import time [EOL] import subprocess [EOL] [EOL] class Errors : [EOL] def __init__ ( self ) : [EOL] self . num_errors = [number] [EOL] [EOL] def report ( self , filename , string ) : [EOL] if filename : [EOL] string = filename + [string] + string [EOL] sys . stderr . write ( string + [string] ) [EOL] self . num_errors += [number] [EOL] [EOL] def ok ( self ) : [EOL] return self . num_errors == [number] [EOL] [EOL] class GenericFilter : [EOL] def __init__ ( self ) : [EOL] self . skip_files = set ( ) [EOL] self . skip_dirs = set ( ) [EOL] self . skip_extensions = set ( ) [EOL] self . fossilised_files = set ( ) [EOL] self . own_files = set ( ) [EOL] [EOL] self . skip_files |= set ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] [EOL] def get_line_filter ( self , dir , filename ) : [EOL] if filename . startswith ( [string] ) : [EOL] [comment] [EOL] return re . compile ( [string] ) [EOL] [EOL] return None [EOL] [EOL] def skip_file ( self , dir , filename ) : [EOL] if filename in self . skip_files : [EOL] return True [EOL] [EOL] ( base , extension ) = os . path . splitext ( os . path . join ( dir , filename ) ) [EOL] if extension in self . skip_extensions : [EOL] return True [EOL] [EOL] if extension == [string] : [EOL] [comment] [EOL] if os . path . exists ( base + [string] ) : [EOL] return True [EOL] [EOL] [comment] [EOL] if ( os . path . exists ( base + [string] ) [EOL] and os . path . exists ( base + [string] ) ) : [EOL] return True [EOL] [EOL] [comment] [EOL] if filename == [string] : [EOL] if os . path . exists ( base + [string] ) : [EOL] return True [EOL] if os . path . exists ( base + [string] ) : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def skip_dir ( self , dir , subdir ) : [EOL] return subdir in self . skip_dirs [EOL] [EOL] def is_fossilised_file ( self , dir , filename ) : [EOL] if filename in self . fossilised_files : [EOL] return True [EOL] [comment] [EOL] if filename != [string] and filename . find ( [string] ) >= [number] : [EOL] return True [EOL] return False [EOL] [EOL] def by_package_author ( self , dir , filename ) : [EOL] return filename in self . own_files [EOL] [EOL] class Copyright : [EOL] def __init__ ( self , errors ) : [EOL] self . errors = errors [EOL] [EOL] [comment] [EOL] ranges = [string] [EOL] [EOL] [comment] [EOL] name = [string] [EOL] [EOL] [comment] [EOL] self . year_re = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] self . continuation_re = re . compile ( ranges + [string] + name ) [EOL] [EOL] [comment] [EOL] self . copyright_re = re . compile ( [string] [string] [string] [string] [string] [string] [string] [string] + ranges + [string] [string] [string] [string] + name + [string] + name + [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . other_copyright_re = re . compile ( [string] , re . IGNORECASE ) [EOL] self . comment_re = re . compile ( [string] ) [EOL] self . holders = { [string] : [string] } [EOL] self . holder_prefixes = set ( ) [EOL] [EOL] [comment] [EOL] self . use_quilt = False [EOL] [EOL] [comment] [EOL] self . max_year = None [EOL] [EOL] [comment] [EOL] self . separator = [string] [EOL] [EOL] def add_package_author ( self , holder , canon_form = None ) : [EOL] if not canon_form : [EOL] canon_form = holder [EOL] self . holders [ holder ] = canon_form [EOL] index = holder . find ( [string] ) [EOL] while index >= [number] : [EOL] self . holder_prefixes . add ( holder [ : index ] ) [EOL] index = holder . find ( [string] , index + [number] ) [EOL] [EOL] def add_external_author ( self , holder ) : [EOL] self . holders [ holder ] = None [EOL] [EOL] class BadYear ( ) : [EOL] def __init__ ( self , year ) : [EOL] self . year = year [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] + self . year [EOL] [EOL] def parse_year ( self , string ) : [EOL] year = int ( string ) [EOL] if len ( string ) == [number] : [EOL] if year > [number] : [EOL] return year + [number] [EOL] elif len ( string ) == [number] : [EOL] return year [EOL] raise self . BadYear ( string ) [EOL] [EOL] def year_range ( self , years ) : [EOL] year_list = [ self . parse_year ( year ) for year in self . year_re . findall ( years ) ] [EOL] assert len ( year_list ) > [number] [EOL] return ( min ( year_list ) , max ( year_list ) ) [EOL] [EOL] def set_use_quilt ( self , use_quilt ) : [EOL] self . use_quilt = use_quilt [EOL] [EOL] def include_year ( self , year ) : [EOL] assert not self . max_year [EOL] self . max_year = year [EOL] [EOL] def canonicalise_years ( self , dir , filename , filter , years ) : [EOL] [comment] [EOL] if years . startswith ( [string] ) : [EOL] return years [EOL] [EOL] ( min_year , max_year ) = self . year_range ( years ) [EOL] [EOL] [comment] [EOL] if self . max_year and not filter . is_fossilised_file ( dir , filename ) : [EOL] max_year = max ( max_year , self . max_year ) [EOL] [EOL] [comment] [EOL] if min_year == max_year : [EOL] return [string] % min_year [EOL] else : [EOL] return [string] % ( min_year , max_year ) [EOL] [EOL] def strip_continuation ( self , line ) : [EOL] line = line . lstrip ( ) [EOL] match = self . comment_re . match ( line ) [EOL] if match : [EOL] line = line [ match . end ( ) : ] . lstrip ( ) [EOL] return line [EOL] [EOL] def is_complete ( self , match ) : [EOL] holder = match . group ( [number] ) [EOL] return ( holder [EOL] and ( holder not in self . holder_prefixes or holder in self . holders ) ) [EOL] [EOL] def update_copyright ( self , dir , filename , filter , file , line , match ) : [EOL] orig_line = line [EOL] next_line = None [EOL] pathname = os . path . join ( dir , filename ) [EOL] [EOL] intro = match . group ( [number] ) [EOL] if intro . startswith ( [string] ) : [EOL] [comment] [EOL] after_years = line [ match . end ( [number] ) : ] . strip ( ) [EOL] if after_years != [string] : [EOL] self . errors . report ( pathname , [string] + after_years ) [EOL] return ( False , orig_line , next_line ) [EOL] else : [EOL] [comment] [EOL] while not self . is_complete ( match ) : [EOL] try : [EOL] next_line = file . next ( ) [EOL] except StopIteration : [EOL] break [EOL] [EOL] [comment] [EOL] [comment] [EOL] continuation = self . strip_continuation ( next_line ) [EOL] if not self . continuation_re . match ( continuation ) : [EOL] break [EOL] [EOL] [comment] [EOL] orig_line += next_line [EOL] line = line . rstrip ( ) + [string] + continuation [EOL] next_line = None [EOL] [EOL] [comment] [EOL] match = self . copyright_re . match ( line , match . start ( ) ) [EOL] assert match [EOL] [EOL] holder = match . group ( [number] ) [EOL] [EOL] [comment] [EOL] if filter . by_package_author ( dir , filename ) : [EOL] assert holder not in self . holders [EOL] [EOL] elif not holder : [EOL] self . errors . report ( pathname , [string] ) [EOL] return ( False , orig_line , next_line ) [EOL] [EOL] elif holder not in self . holders : [EOL] self . errors . report ( pathname , [string] + holder ) [EOL] return ( False , orig_line , next_line ) [EOL] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] canon_form = self . holders [ holder ] [EOL] if not canon_form : [EOL] return ( False , orig_line , next_line ) [EOL] [EOL] [comment] [EOL] line = ( line [ : match . start ( [number] ) ] + canon_form + line [ match . end ( [number] ) : ] ) [EOL] [EOL] [comment] [EOL] line = line [ : match . start ( [number] ) ] + line [ match . end ( [number] ) : ] [EOL] [EOL] [comment] [EOL] years = match . group ( [number] ) . strip ( ) [EOL] try : [EOL] canon_form = self . canonicalise_years ( dir , filename , filter , years ) [EOL] except self . BadYear as e : [EOL] self . errors . report ( pathname , str ( e ) ) [EOL] return ( False , orig_line , next_line ) [EOL] [EOL] line = ( line [ : match . start ( [number] ) ] + ( [string] if intro . startswith ( [string] ) else [string] ) + canon_form + self . separator + line [ match . end ( [number] ) : ] ) [EOL] [EOL] [comment] [EOL] if intro . endswith ( [string] ) : [EOL] intro += [string] [EOL] elif intro . endswith ( [string] ) : [EOL] intro = intro [ : - [number] ] + [string] [EOL] line = line [ : match . start ( [number] ) ] + intro + line [ match . end ( [number] ) : ] [EOL] [EOL] [comment] [EOL] line = line . rstrip ( ) + [string] [EOL] [EOL] return ( line != orig_line , line , next_line ) [EOL] [EOL] def process_file ( self , dir , filename , filter ) : [EOL] pathname = os . path . join ( dir , filename ) [EOL] if filename . endswith ( [string] ) : [EOL] [comment] [EOL] try : [EOL] os . remove ( pathname ) [EOL] except OSError : [EOL] pass [EOL] return [EOL] [EOL] lines = [ ] [EOL] changed = False [EOL] line_filter = filter . get_line_filter ( dir , filename ) [EOL] mode = None [EOL] with open ( pathname , [string] ) as file : [EOL] prev = None [EOL] mode = os . fstat ( file . fileno ( ) ) . st_mode [EOL] for line in file : [EOL] while line : [EOL] next_line = None [EOL] [comment] [EOL] if not ( line_filter and line_filter . match ( line ) ) : [EOL] match = self . copyright_re . search ( line ) [EOL] if match : [EOL] res = self . update_copyright ( dir , filename , filter , file , line , match ) [EOL] ( this_changed , line , next_line ) = res [EOL] changed = changed or this_changed [EOL] [EOL] [comment] [EOL] elif self . other_copyright_re . search ( line ) : [EOL] self . errors . report ( pathname , [string] % line . strip ( ) ) [EOL] lines . append ( line ) [EOL] line = next_line [EOL] [EOL] [comment] [EOL] if changed and self . errors . ok ( ) : [EOL] tmp_pathname = pathname + [string] [EOL] with open ( tmp_pathname , [string] ) as file : [EOL] for line in lines : [EOL] file . write ( line ) [EOL] os . fchmod ( file . fileno ( ) , mode ) [EOL] if self . use_quilt : [EOL] subprocess . call ( [ [string] , [string] , pathname ] ) [EOL] os . rename ( tmp_pathname , pathname ) [EOL] [EOL] def process_tree ( self , tree , filter ) : [EOL] for ( dir , subdirs , filenames ) in os . walk ( tree ) : [EOL] [comment] [EOL] for i in xrange ( len ( subdirs ) - [number] , - [number] , - [number] ) : [EOL] if filter . skip_dir ( dir , subdirs [ i ] ) : [EOL] del subdirs [ i ] [EOL] [EOL] [comment] [EOL] for filename in filenames : [EOL] if filter . skip_file ( dir , filename ) : [EOL] sys . stdout . write ( [string] % os . path . join ( dir , filename ) ) [EOL] else : [EOL] self . process_file ( dir , filename , filter ) [EOL] [EOL] class CmdLine : [EOL] def __init__ ( self , copyright = Copyright ) : [EOL] self . errors = Errors ( ) [EOL] self . copyright = copyright ( self . errors ) [EOL] self . dirs = [ ] [EOL] self . default_dirs = [ ] [EOL] self . chosen_dirs = [ ] [EOL] self . option_handlers = dict ( ) [EOL] self . option_help = [ ] [EOL] [EOL] self . add_option ( [string] , [string] , self . o_help ) [EOL] self . add_option ( [string] , [string] , self . o_quilt ) [EOL] self . add_option ( [string] , [string] , self . o_this_year ) [EOL] [EOL] def add_option ( self , name , help , handler ) : [EOL] self . option_help . append ( ( name , help ) ) [EOL] self . option_handlers [ name ] = handler [EOL] [EOL] def add_dir ( self , dir , filter = GenericFilter ( ) ) : [EOL] self . dirs . append ( ( dir , filter ) ) [EOL] [EOL] def o_help ( self , option = None ) : [EOL] sys . stdout . write ( [string] [string] % sys . argv [ [number] ] ) [EOL] format = [string] [EOL] for ( what , help ) in self . option_help : [EOL] sys . stdout . write ( format % ( what , help ) ) [EOL] sys . stdout . write ( [string] ) [EOL] [EOL] format = [string] [EOL] i = [number] [EOL] for ( dir , filter ) in self . dirs : [EOL] i += [number] [EOL] if i % [number] == [number] or i == len ( self . dirs ) : [EOL] sys . stdout . write ( dir + [string] ) [EOL] else : [EOL] sys . stdout . write ( format % dir ) [EOL] sys . exit ( [number] ) [EOL] [EOL] def o_quilt ( self , option ) : [EOL] self . copyright . set_use_quilt ( True ) [EOL] [EOL] def o_this_year ( self , option ) : [EOL] self . copyright . include_year ( time . localtime ( ) . tm_year ) [EOL] [EOL] def main ( self ) : [EOL] for arg in sys . argv [ [number] : ] : [EOL] if arg [ : [number] ] != [string] : [EOL] self . chosen_dirs . append ( arg ) [EOL] elif arg in self . option_handlers : [EOL] self . option_handlers [ arg ] ( arg ) [EOL] else : [EOL] self . errors . report ( None , [string] + arg ) [EOL] if self . errors . ok ( ) : [EOL] if len ( self . chosen_dirs ) == [number] : [EOL] self . chosen_dirs = self . default_dirs [EOL] if len ( self . chosen_dirs ) == [number] : [EOL] self . o_help ( ) [EOL] else : [EOL] for chosen_dir in self . chosen_dirs : [EOL] canon_dir = os . path . join ( chosen_dir , [string] ) [EOL] count = [number] [EOL] for ( dir , filter ) in self . dirs : [EOL] if ( dir + os . sep ) . startswith ( canon_dir ) : [EOL] count += [number] [EOL] self . copyright . process_tree ( dir , filter ) [EOL] if count == [number] : [EOL] self . errors . report ( None , [string] + chosen_dir ) [EOL] sys . exit ( [number] if self . errors . ok ( ) else [number] ) [EOL] [EOL] [comment] [EOL] [EOL] class TopLevelFilter ( GenericFilter ) : [EOL] def skip_dir ( self , dir , subdir ) : [EOL] return True [EOL] [EOL] class ConfigFilter ( GenericFilter ) : [EOL] def __init__ ( self ) : [EOL] GenericFilter . __init__ ( self ) [EOL] [EOL] def skip_file ( self , dir , filename ) : [EOL] if filename . endswith ( [string] ) : [EOL] pathname = os . path . join ( dir , filename ) [EOL] with open ( pathname ) as file : [EOL] [comment] [EOL] if file . readline ( ) . find ( [string] ) >= [number] : [EOL] return True [EOL] return GenericFilter . skip_file ( self , dir , filename ) [EOL] [EOL] class GCCFilter ( GenericFilter ) : [EOL] def __init__ ( self ) : [EOL] GenericFilter . __init__ ( self ) [EOL] [EOL] self . skip_files |= set ( [ [string] , ] ) [EOL] [EOL] self . skip_dirs |= set ( [ [string] , [string] , ] ) [EOL] [EOL] self . skip_extensions |= set ( [ [string] , [string] , ] ) [EOL] [EOL] self . fossilised_files |= set ( [ [string] , ] ) [EOL] [EOL] class TestsuiteFilter ( GenericFilter ) : [EOL] def __init__ ( self ) : [EOL] GenericFilter . __init__ ( self ) [EOL] [EOL] self . skip_extensions |= set ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def skip_file ( self , dir , filename ) : [EOL] [comment] [EOL] [comment] [EOL] if filename == [string] and os . path . basename ( dir ) == [string] : [EOL] return True [EOL] [comment] [EOL] if filename == [string] and os . path . basename ( dir ) == [string] : [EOL] return True [EOL] return GenericFilter . skip_file ( self , dir , filename ) [EOL] [EOL] class LibCppFilter ( GenericFilter ) : [EOL] def __init__ ( self ) : [EOL] GenericFilter . __init__ ( self ) [EOL] [EOL] self . skip_extensions |= set ( [ [string] , [string] , ] ) [EOL] [EOL] class LibGCCFilter ( GenericFilter ) : [EOL] def __init__ ( self ) : [EOL] GenericFilter . __init__ ( self ) [EOL] [EOL] self . skip_dirs |= set ( [ [string] , ] ) [EOL] [EOL] class LibStdCxxFilter ( GenericFilter ) : [EOL] def __init__ ( self ) : [EOL] GenericFilter . __init__ ( self ) [EOL] [EOL] self . skip_files |= set ( [ [string] , ] ) [EOL] [EOL] self . skip_dirs |= set ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] self . own_files |= set ( [ [string] , ] ) [EOL] [EOL] def get_line_filter ( self , dir , filename ) : [EOL] if filename == [string] : [EOL] return re . compile ( [string] ) [EOL] return GenericFilter . get_line_filter ( self , dir , filename ) [EOL] [EOL] class GCCCopyright ( Copyright ) : [EOL] def __init__ ( self , errors ) : [EOL] Copyright . __init__ ( self , errors ) [EOL] [EOL] canon_fsf = [string] [EOL] self . add_package_author ( [string] , canon_fsf ) [EOL] self . add_package_author ( [string] , canon_fsf ) [EOL] self . add_package_author ( [string] , canon_fsf ) [EOL] self . add_package_author ( [string] , canon_fsf ) [EOL] self . add_package_author ( [string] , canon_fsf ) [EOL] self . add_package_author ( [string] , canon_fsf ) [EOL] self . add_package_author ( [string] , canon_fsf ) [EOL] self . add_package_author ( [string] , canon_fsf ) [EOL] [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] self . add_external_author ( [string] ) [EOL] [EOL] class GCCCmdLine ( CmdLine ) : [EOL] def __init__ ( self ) : [EOL] CmdLine . __init__ ( self , GCCCopyright ) [EOL] [EOL] self . add_dir ( [string] , TopLevelFilter ( ) ) [EOL] [comment] [EOL] self . add_dir ( [string] , ConfigFilter ( ) ) [EOL] [comment] [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] , GCCFilter ( ) ) [EOL] self . add_dir ( os . path . join ( [string] , [string] ) , TestsuiteFilter ( ) ) [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] ) [EOL] [comment] [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] ) [EOL] [comment] [EOL] self . add_dir ( [string] , LibCppFilter ( ) ) [EOL] self . add_dir ( [string] ) [EOL] [comment] [EOL] self . add_dir ( [string] , LibGCCFilter ( ) ) [EOL] self . add_dir ( [string] ) [EOL] [comment] [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] ) [EOL] [comment] [EOL] self . add_dir ( [string] ) [EOL] [comment] [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] , LibStdCxxFilter ( ) ) [EOL] self . add_dir ( [string] ) [EOL] self . add_dir ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] self . default_dirs = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] GCCCmdLine ( ) . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.object,builtins.str,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.object,builtins.str,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.object,builtins.str,None],builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.object,builtins.str,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , IO [EOL] import typing [EOL] import argparse [EOL] import sys [EOL] import os [EOL] import subprocess [EOL] import tempfile [EOL] import argparse [EOL] [EOL] script_location = os . path . realpath ( __file__ ) [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , metavar = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , dest = [string] , choices = [ [string] , [string] , [string] , [string] , [string] ] , default = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] benchmarks = os . listdir ( args . location ) [EOL] [EOL] for b in sorted ( benchmarks ) : [EOL] dumps = [ ] [EOL] for root , dirs , files in os . walk ( os . path . join ( args . location , b ) ) : [EOL] for x in files : [EOL] if x . endswith ( [string] ) : [EOL] dumps . append ( os . path . join ( root , x ) ) [EOL] [EOL] if len ( dumps ) == [number] : [EOL] continue [EOL] [EOL] temp = tempfile . NamedTemporaryFile ( delete = False ) [EOL] for d in dumps : [EOL] temp . write ( open ( d , [string] ) . read ( ) ) [EOL] [EOL] temp . close ( ) [EOL] [EOL] print ( ) [EOL] print ( b ) [EOL] sys . stdout . flush ( ) [EOL] p = [ os . path . join ( os . path . dirname ( script_location ) , [string] ) , temp . name , [string] , args . sorting ] [EOL] p = subprocess . check_call ( p ) [EOL] sys . stdout . flush ( ) [EOL] [EOL] os . remove ( temp . name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Tuple , Any , TextIO [EOL] import typing [EOL] import sys [EOL] import getopt [EOL] import re [EOL] import io [EOL] from datetime import datetime [EOL] from operator import attrgetter [EOL] [EOL] [comment] [EOL] [comment] [EOL] strict = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] sort_logs = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] def safe_open ( filename ) : [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] return open ( filename , [string] , errors = [string] ) [EOL] return open ( filename , [string] ) [EOL] [EOL] [comment] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] sys . stdout = io . TextIOWrapper ( sys . stdout . buffer , errors = [string] ) [EOL] [EOL] class Named : [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] [EOL] class ToolRun ( Named ) : [EOL] def __init__ ( self , name ) : [EOL] Named . __init__ ( self , name ) [EOL] [comment] [EOL] self . variations = dict ( ) [EOL] [EOL] [comment] [EOL] def get_variation ( self , name ) : [EOL] if name not in self . variations : [EOL] self . variations [ name ] = VariationRun ( name ) [EOL] return self . variations [ name ] [EOL] [EOL] class VariationRun ( Named ) : [EOL] def __init__ ( self , name ) : [EOL] Named . __init__ ( self , name ) [EOL] [comment] [EOL] [comment] [EOL] self . header = None [EOL] [comment] [EOL] self . harnesses = dict ( ) [EOL] [comment] [EOL] [comment] [EOL] self . counts = [ ] [EOL] [EOL] [comment] [EOL] def get_harness ( self , name ) : [EOL] if name not in self . harnesses : [EOL] self . harnesses [ name ] = HarnessRun ( name ) [EOL] return self . harnesses [ name ] [EOL] [EOL] class HarnessRun ( Named ) : [EOL] def __init__ ( self , name ) : [EOL] Named . __init__ ( self , name ) [EOL] [comment] [EOL] [comment] [EOL] self . segments = dict ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . empty = [ ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . results = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def add_segment ( self , key , segment ) : [EOL] if key : [EOL] assert key not in self . segments [EOL] self . segments [ key ] = segment [EOL] else : [EOL] self . empty . append ( segment ) [EOL] [EOL] class Segment : [EOL] def __init__ ( self , filename , start ) : [EOL] self . filename = filename [EOL] self . start = start [EOL] self . lines = [number] [EOL] [EOL] class Prog : [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . variations = [ ] [EOL] [comment] [EOL] self . known_variations = set ( ) [EOL] [comment] [EOL] self . tools = [ ] [EOL] [comment] [EOL] self . do_sum = True [EOL] [comment] [EOL] self . test_run_re = re . compile ( [string] ) [EOL] self . tool_re = re . compile ( [string] ) [EOL] self . result_re = re . compile ( [string] [string] [string] ) [EOL] self . completed_re = re . compile ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . start_line = None [EOL] self . native_line = [string] [EOL] self . target_line = [string] [EOL] self . host_line = [string] [EOL] self . acats_premable = [string] [EOL] [comment] [EOL] [comment] [EOL] self . acats_failures = [ ] [EOL] self . version_output = [string] [EOL] self . end_line = None [EOL] [comment] [EOL] self . count_names = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . runs = dict ( ) [EOL] [EOL] def usage ( self ) : [EOL] name = sys . argv [ [number] ] [EOL] sys . stderr . write ( [string] + name + [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] def fatal ( self , what , string ) : [EOL] if not what : [EOL] what = sys . argv [ [number] ] [EOL] sys . stderr . write ( what + [string] + string + [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [comment] [EOL] def parse_cmdline ( self ) : [EOL] try : [EOL] ( options , self . files ) = getopt . getopt ( sys . argv [ [number] : ] , [string] ) [EOL] if len ( self . files ) == [number] : [EOL] self . usage ( ) [EOL] for ( option , value ) in options : [EOL] if option == [string] : [EOL] self . variations . append ( value ) [EOL] elif option == [string] : [EOL] self . tools . append ( value ) [EOL] else : [EOL] self . do_sum = False [EOL] except getopt . GetoptError as e : [EOL] self . fatal ( None , e . msg ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def parse_time ( self , time ) : [EOL] try : [EOL] return datetime . strptime ( time , [string] ) [EOL] except ValueError : [EOL] return datetime . now ( ) [EOL] [EOL] [comment] [EOL] def parse_int ( self , filename , value ) : [EOL] try : [EOL] return int ( value ) [EOL] except ValueError : [EOL] self . fatal ( filename , [string] + value ) [EOL] [EOL] [comment] [EOL] def zero_counts ( self ) : [EOL] return [ [number] for x in self . count_names ] [EOL] [EOL] [comment] [EOL] def get_tool ( self , name ) : [EOL] if name not in self . runs : [EOL] self . runs [ name ] = ToolRun ( name ) [EOL] return self . runs [ name ] [EOL] [EOL] [comment] [EOL] def accumulate_counts ( self , toc , fromc ) : [EOL] for i in range ( len ( self . count_names ) ) : [EOL] toc [ i ] += fromc [ i ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def parse_variations ( self , filename , file ) : [EOL] num_variations = [number] [EOL] while True : [EOL] line = file . readline ( ) [EOL] if line == [string] : [EOL] self . fatal ( filename , [string] ) [EOL] if line == [string] : [EOL] break [EOL] self . known_variations . add ( line . strip ( ) ) [EOL] num_variations += [number] [EOL] return num_variations [EOL] [EOL] [comment] [EOL] [comment] [EOL] def parse_run ( self , filename , file , tool , variation , num_variations ) : [EOL] header = None [EOL] harness = None [EOL] segment = None [EOL] final_using = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not variation . header : [EOL] segment = Segment ( filename , file . tell ( ) ) [EOL] variation . header = segment [EOL] [EOL] [comment] [EOL] if len ( variation . counts ) == [number] : [EOL] variation . counts = self . zero_counts ( ) [EOL] [EOL] [comment] [EOL] if num_variations == [number] : [EOL] end = [string] + tool . name + [string] [EOL] else : [EOL] end = ( [string] + tool . name + [string] + variation . name + [string] ) [EOL] while True : [EOL] line = file . readline ( ) [EOL] if line == [string] : [EOL] self . fatal ( filename , [string] ) [EOL] if line == end : [EOL] break [EOL] [EOL] [comment] [EOL] if line . startswith ( [string] ) and line . endswith ( [string] ) : [EOL] [comment] [EOL] if harness : [EOL] segment . lines -= final_using [EOL] harness . add_segment ( first_key , segment ) [EOL] name = line [ len ( [string] ) : - len ( [string] ) ] [EOL] harness = variation . get_harness ( name ) [EOL] segment = Segment ( filename , file . tell ( ) ) [EOL] first_key = None [EOL] final_using = [number] [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] match = self . result_re . match ( line ) [EOL] if match and ( harness or not line . startswith ( [string] ) ) : [EOL] if not harness : [EOL] self . fatal ( filename , [string] ) [EOL] name = match . group ( [number] ) [EOL] [comment] [EOL] if name . startswith ( [string] ) : [EOL] name = [string] + name [EOL] key = ( name , len ( harness . results ) ) [EOL] harness . results . append ( ( key , line ) ) [EOL] if not first_key and sort_logs : [EOL] first_key = key [EOL] if line . startswith ( [string] ) : [EOL] for i in range ( len ( self . count_names ) ) : [EOL] if [string] in self . count_names [ i ] : [EOL] variation . counts [ i ] += [number] [EOL] break [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if line . startswith ( [string] ) : [EOL] final_using += [number] [EOL] else : [EOL] final_using = [number] [EOL] [EOL] [comment] [EOL] if segment : [EOL] segment . lines += [number] [EOL] [EOL] [comment] [EOL] if harness : [EOL] segment . lines -= final_using [EOL] harness . add_segment ( first_key , segment ) [EOL] [EOL] while True : [EOL] before = file . tell ( ) [EOL] line = file . readline ( ) [EOL] if line == [string] : [EOL] break [EOL] if line == [string] : [EOL] continue [EOL] if not line . startswith ( [string] ) : [EOL] file . seek ( before ) [EOL] break [EOL] found = False [EOL] for i in range ( len ( self . count_names ) ) : [EOL] if line . startswith ( self . count_names [ i ] ) : [EOL] count = line [ len ( self . count_names [ i ] ) : - [number] ] . strip ( ) [EOL] variation . counts [ i ] += self . parse_int ( filename , count ) [EOL] found = True [EOL] break [EOL] if not found : [EOL] self . fatal ( filename , [string] + line [ : - [number] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def parse_acats_run ( self , filename , file ) : [EOL] [comment] [EOL] [comment] [EOL] record = ( self . acats_premable == [string] ) [EOL] if record : [EOL] self . acats_premable = [string] [EOL] while True : [EOL] line = file . readline ( ) [EOL] if line == [string] : [EOL] self . fatal ( filename , [string] ) [EOL] if line == [string] : [EOL] break [EOL] if record : [EOL] self . acats_premable += line [EOL] [EOL] [comment] [EOL] tool = self . get_tool ( [string] ) [EOL] variation = tool . get_variation ( [string] ) [EOL] self . parse_run ( filename , file , tool , variation , [number] ) [EOL] [EOL] [comment] [EOL] while True : [EOL] before = file . tell ( ) [EOL] line = file . readline ( ) [EOL] if line . startswith ( [string] ) : [EOL] self . acats_failures . append ( line [ len ( [string] ) : - [number] ] ) [EOL] continue [EOL] file . seek ( before ) [EOL] break [EOL] [EOL] [comment] [EOL] [comment] [EOL] def parse_final_summary ( self , filename , file ) : [EOL] record = ( self . version_output == [string] ) [EOL] while True : [EOL] line = file . readline ( ) [EOL] if line == [string] : [EOL] break [EOL] if line . startswith ( [string] ) : [EOL] continue [EOL] if record : [EOL] self . version_output += line [EOL] if line == [string] : [EOL] break [EOL] [EOL] [comment] [EOL] def parse_file ( self , filename , file ) : [EOL] tool = None [EOL] target = None [EOL] num_variations = [number] [EOL] while True : [EOL] line = file . readline ( ) [EOL] if line == [string] : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] if line . startswith ( [string] ) : [EOL] num_variations = self . parse_variations ( filename , file ) [EOL] continue [EOL] [EOL] [comment] [EOL] if line . startswith ( [string] ) : [EOL] name = line [ len ( [string] ) : - [number] ] [EOL] if not tool : [EOL] self . fatal ( filename , [string] ) [EOL] if name not in self . known_variations : [EOL] self . fatal ( filename , [string] + name ) [EOL] self . parse_run ( filename , file , tool , tool . get_variation ( name ) , num_variations ) [EOL] [comment] [EOL] [comment] [EOL] if num_variations == [number] : [EOL] self . parse_final_summary ( filename , file ) [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] match = self . test_run_re . match ( line ) [EOL] if match : [EOL] time = self . parse_time ( match . group ( [number] ) ) [EOL] if not self . start_line or self . start_line [ [number] ] > time : [EOL] self . start_line = ( time , line ) [EOL] continue [EOL] [EOL] [comment] [EOL] if line . startswith ( [string] ) : [EOL] self . native_line = line [EOL] continue [EOL] [EOL] [comment] [EOL] if line . startswith ( [string] ) : [EOL] self . target_line = line [EOL] continue [EOL] [EOL] [comment] [EOL] if line . startswith ( [string] ) : [EOL] self . host_line = line [EOL] continue [EOL] [EOL] [comment] [EOL] if line == [string] : [EOL] self . parse_acats_run ( filename , file ) [EOL] continue [EOL] [EOL] [comment] [EOL] match = self . tool_re . match ( line ) [EOL] if match : [EOL] tool = self . get_tool ( match . group ( [number] ) ) [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] if tool and line == [string] + tool . name + [string] : [EOL] if file . readline ( ) != [string] : [EOL] self . fatal ( filename , [string] ) [EOL] self . parse_final_summary ( filename , file ) [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] match = self . completed_re . match ( line ) [EOL] if match : [EOL] time = self . parse_time ( match . group ( [number] ) ) [EOL] if not self . end_line or self . end_line [ [number] ] < time : [EOL] self . end_line = ( time , line ) [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] if strict and line . strip ( ) != [string] : [EOL] self . fatal ( filename , [string] + line [ : - [number] ] ) [EOL] [EOL] [comment] [EOL] def output_segment ( self , segment ) : [EOL] with safe_open ( segment . filename ) as file : [EOL] file . seek ( segment . start ) [EOL] for i in range ( segment . lines ) : [EOL] sys . stdout . write ( file . readline ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def output_summary ( self , tool , counts ) : [EOL] for i in range ( len ( self . count_names ) ) : [EOL] name = self . count_names [ i ] [EOL] [comment] [EOL] [comment] [EOL] if ( counts [ i ] > [number] or ( tool . name == [string] [EOL] and name . startswith ( [string] ) ) ) : [EOL] sys . stdout . write ( [string] % ( name , counts [ i ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def output_variation ( self , tool , variation ) : [EOL] self . output_segment ( variation . header ) [EOL] for harness in sorted ( variation . harnesses . values ( ) , key = attrgetter ( [string] ) ) : [EOL] sys . stdout . write ( [string] + harness . name + [string] ) [EOL] if self . do_sum : [EOL] harness . results . sort ( ) [EOL] for ( key , line ) in harness . results : [EOL] sys . stdout . write ( line ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] for key in sorted ( harness . segments . keys ( ) ) : [EOL] self . output_segment ( harness . segments [ key ] ) [EOL] for segment in harness . empty : [EOL] self . output_segment ( segment ) [EOL] if len ( self . variations ) > [number] : [EOL] sys . stdout . write ( [string] + tool . name + [string] + variation . name + [string] ) [EOL] self . output_summary ( tool , variation . counts ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def output_tool ( self , tool ) : [EOL] counts = self . zero_counts ( ) [EOL] if tool . name == [string] : [EOL] [comment] [EOL] [comment] [EOL] sys . stdout . write ( [string] + tool . name + [string] ) [EOL] for variation in tool . variations . values ( ) : [EOL] self . output_variation ( tool , variation ) [EOL] self . accumulate_counts ( counts , variation . counts ) [EOL] sys . stdout . write ( [string] + tool . name + [string] ) [EOL] else : [EOL] [comment] [EOL] sys . stdout . write ( [string] + tool . name + [string] [string] ) [EOL] for name in self . variations : [EOL] if name in tool . variations : [EOL] sys . stdout . write ( [string] + name + [string] ) [EOL] sys . stdout . write ( [string] ) [EOL] for name in self . variations : [EOL] if name in tool . variations : [EOL] variation = tool . variations [ name ] [EOL] sys . stdout . write ( [string] + variation . name + [string] ) [EOL] self . output_variation ( tool , variation ) [EOL] self . accumulate_counts ( counts , variation . counts ) [EOL] sys . stdout . write ( [string] + tool . name + [string] ) [EOL] self . output_summary ( tool , counts ) [EOL] [EOL] def main ( self ) : [EOL] self . parse_cmdline ( ) [EOL] try : [EOL] [comment] [EOL] for filename in self . files : [EOL] with safe_open ( filename ) as file : [EOL] self . parse_file ( filename , file ) [EOL] [EOL] [comment] [EOL] if len ( self . variations ) == [number] : [EOL] self . variations = sorted ( self . known_variations ) [EOL] else : [EOL] for name in self . variations : [EOL] if name not in self . known_variations : [EOL] self . fatal ( None , [string] + name ) [EOL] if len ( self . tools ) == [number] : [EOL] self . tools = sorted ( self . runs . keys ( ) ) [EOL] [EOL] [comment] [EOL] if self . start_line : [EOL] sys . stdout . write ( self . start_line [ [number] ] ) [EOL] sys . stdout . write ( self . native_line ) [EOL] sys . stdout . write ( self . target_line ) [EOL] sys . stdout . write ( self . host_line ) [EOL] sys . stdout . write ( self . acats_premable ) [EOL] [EOL] [comment] [EOL] for name in self . tools : [EOL] if name not in self . runs : [EOL] self . fatal ( None , [string] + name ) [EOL] self . output_tool ( self . runs [ name ] ) [EOL] [EOL] [comment] [EOL] if len ( self . acats_failures ) > [number] : [EOL] sys . stdout . write ( [string] + [string] . join ( self . acats_failures ) + [string] ) [EOL] sys . stdout . write ( self . version_output ) [EOL] if self . end_line : [EOL] sys . stdout . write ( self . end_line [ [number] ] ) [EOL] except IOError as e : [EOL] self . fatal ( e . filename , e . strerror ) [EOL] [EOL] Prog ( ) . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $typing.Tuple[typing.Any,builtins.int]$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Tuple[typing.Any,builtins.int]$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.int]$ 0 0 0 0 $typing.Tuple[typing.Any,builtins.int]$ 0 $typing.Tuple[typing.Any,builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $typing.Tuple[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Dict [EOL] import typing [EOL] import requests [EOL] import argparse [EOL] import requests [EOL] import json [EOL] import argparse [EOL] [EOL] base_url = [string] [EOL] [EOL] def mark_as_spam ( id , api_key , verbose ) : [EOL] print ( [string] % id ) [EOL] [comment] [EOL] u = base_url + [string] + str ( id ) [EOL] r = requests . get ( u ) [EOL] response = json . loads ( r . text ) [EOL] [EOL] if [string] in response and response [ [string] ] : [EOL] print ( response [ [string] ] ) [EOL] return [EOL] [EOL] [comment] [EOL] bug = response [ [string] ] [ [number] ] [EOL] creator = bug [ [string] ] [EOL] cc_list = bug [ [string] ] [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ id ] , [string] : api_key , [string] : { [string] : [string] } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : cc_list } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] r = requests . put ( u , json = data ) [EOL] if verbose : [EOL] print ( r ) [EOL] print ( r . text ) [EOL] [EOL] [comment] [EOL] r = requests . get ( u + [string] ) [EOL] response = json . loads ( r . text ) [EOL] for c in response [ [string] ] [ str ( id ) ] [ [string] ] : [EOL] if c [ [string] ] == creator : [EOL] comment_id = c [ [string] ] [EOL] u2 = [string] % ( base_url , comment_id ) [EOL] print ( u2 ) [EOL] r = requests . put ( u2 , json = { [string] : comment_id , [string] : [ [string] ] , [string] : api_key } ) [EOL] if verbose : [EOL] print ( r ) [EOL] print ( r . text ) [EOL] [EOL] [comment] [EOL] r = requests . get ( u + [string] ) [EOL] response = json . loads ( r . text ) [EOL] attachments = response [ [string] ] [ str ( id ) ] [EOL] for a in attachments : [EOL] attachment_id = a [ [string] ] [EOL] url = [string] % ( base_url , attachment_id ) [EOL] r = requests . put ( url , json = { [string] : [ attachment_id ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : api_key } ) [EOL] if verbose : [EOL] print ( r ) [EOL] print ( r . text ) [EOL] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] chunks = args . range . split ( [string] ) [EOL] for c in chunks : [EOL] parts = list ( map ( lambda x : int ( x ) , c . split ( [string] ) ) ) [EOL] if len ( parts ) == [number] : [EOL] r = [ parts [ [number] ] ] [EOL] else : [EOL] r = range ( parts [ [number] ] , parts [ [number] ] + [number] ) [EOL] [EOL] for id in r : [EOL] mark_as_spam ( id , args . api_key , args . verbose ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 $builtins.range$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $builtins.range$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0
[EOL]	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import gdb [EOL] [EOL] [comment] [EOL] def gdb_has_xmethods ( ) : [EOL] try : [EOL] import gdb . xmethod [EOL] return True [EOL] except ImportError : [EOL] return False [EOL] [EOL] def register_libstdcxx_printers ( obj ) : [EOL] [comment] [EOL] from . printers import register_libstdcxx_printers [EOL] register_libstdcxx_printers ( obj ) [EOL] [EOL] if gdb_has_xmethods ( ) : [EOL] from . xmethods import register_libstdcxx_xmethods [EOL] register_libstdcxx_xmethods ( obj ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Any , Match [EOL] import typing [EOL] import gdb [EOL] import gdb . xmethod [EOL] import re [EOL] [EOL] matcher_name_prefix = [string] [EOL] [EOL] def get_bool_type ( ) : [EOL] return gdb . lookup_type ( [string] ) [EOL] [EOL] def get_std_size_type ( ) : [EOL] return gdb . lookup_type ( [string] ) [EOL] [EOL] class LibStdCxxXMethod ( gdb . xmethod . XMethod ) : [EOL] def __init__ ( self , name , worker_class ) : [EOL] gdb . xmethod . XMethod . __init__ ( self , name ) [EOL] self . worker_class = worker_class [EOL] [EOL] [comment] [EOL] [EOL] class ArrayWorkerBase ( gdb . xmethod . XMethodWorker ) : [EOL] def __init__ ( self , val_type , size ) : [EOL] self . _val_type = val_type [EOL] self . _size = size [EOL] [EOL] def null_value ( self ) : [EOL] nullptr = gdb . parse_and_eval ( [string] ) [EOL] return nullptr . cast ( self . _val_type . pointer ( ) ) . dereference ( ) [EOL] [EOL] class ArraySizeWorker ( ArrayWorkerBase ) : [EOL] def __init__ ( self , val_type , size ) : [EOL] ArrayWorkerBase . __init__ ( self , val_type , size ) [EOL] [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return self . _size [EOL] [EOL] class ArrayEmptyWorker ( ArrayWorkerBase ) : [EOL] def __init__ ( self , val_type , size ) : [EOL] ArrayWorkerBase . __init__ ( self , val_type , size ) [EOL] [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return get_bool_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return ( int ( self . _size ) == [number] ) [EOL] [EOL] class ArrayFrontWorker ( ArrayWorkerBase ) : [EOL] def __init__ ( self , val_type , size ) : [EOL] ArrayWorkerBase . __init__ ( self , val_type , size ) [EOL] [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj ) : [EOL] if int ( self . _size ) > [number] : [EOL] return obj [ [string] ] [ [number] ] [EOL] else : [EOL] return self . null_value ( ) [EOL] [EOL] class ArrayBackWorker ( ArrayWorkerBase ) : [EOL] def __init__ ( self , val_type , size ) : [EOL] ArrayWorkerBase . __init__ ( self , val_type , size ) [EOL] [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj ) : [EOL] if int ( self . _size ) > [number] : [EOL] return obj [ [string] ] [ self . _size - [number] ] [EOL] else : [EOL] return self . null_value ( ) [EOL] [EOL] class ArrayAtWorker ( ArrayWorkerBase ) : [EOL] def __init__ ( self , val_type , size ) : [EOL] ArrayWorkerBase . __init__ ( self , val_type , size ) [EOL] [EOL] def get_arg_types ( self ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def get_result_type ( self , obj , index ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj , index ) : [EOL] if int ( index ) >= int ( self . _size ) : [EOL] raise IndexError ( [string] % ( ( int ( index ) , self . _size ) ) ) [EOL] return obj [ [string] ] [ index ] [EOL] [EOL] class ArraySubscriptWorker ( ArrayWorkerBase ) : [EOL] def __init__ ( self , val_type , size ) : [EOL] ArrayWorkerBase . __init__ ( self , val_type , size ) [EOL] [EOL] def get_arg_types ( self ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def get_result_type ( self , obj , index ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj , index ) : [EOL] if int ( self . _size ) > [number] : [EOL] return obj [ [string] ] [ index ] [EOL] else : [EOL] return self . null_value ( ) [EOL] [EOL] class ArrayMethodsMatcher ( gdb . xmethod . XMethodMatcher ) : [EOL] def __init__ ( self ) : [EOL] gdb . xmethod . XMethodMatcher . __init__ ( self , matcher_name_prefix + [string] ) [EOL] self . _method_dict = { [string] : LibStdCxxXMethod ( [string] , ArraySizeWorker ) , [string] : LibStdCxxXMethod ( [string] , ArrayEmptyWorker ) , [string] : LibStdCxxXMethod ( [string] , ArrayFrontWorker ) , [string] : LibStdCxxXMethod ( [string] , ArrayBackWorker ) , [string] : LibStdCxxXMethod ( [string] , ArrayAtWorker ) , [string] : LibStdCxxXMethod ( [string] , ArraySubscriptWorker ) , } [EOL] self . methods = [ self . _method_dict [ m ] for m in self . _method_dict ] [EOL] [EOL] def match ( self , class_type , method_name ) : [EOL] if not re . match ( [string] , class_type . tag ) : [EOL] return None [EOL] method = self . _method_dict . get ( method_name ) [EOL] if method is None or not method . enabled : [EOL] return None [EOL] try : [EOL] value_type = class_type . template_argument ( [number] ) [EOL] size = class_type . template_argument ( [number] ) [EOL] except : [EOL] return None [EOL] return method . worker_class ( value_type , size ) [EOL] [EOL] [comment] [EOL] [EOL] class DequeWorkerBase ( gdb . xmethod . XMethodWorker ) : [EOL] def __init__ ( self , val_type ) : [EOL] self . _val_type = val_type [EOL] self . _bufsize = [number] // val_type . sizeof or [number] [EOL] [EOL] def size ( self , obj ) : [EOL] first_node = obj [ [string] ] [ [string] ] [ [string] ] [EOL] last_node = obj [ [string] ] [ [string] ] [ [string] ] [EOL] cur = obj [ [string] ] [ [string] ] [ [string] ] [EOL] first = obj [ [string] ] [ [string] ] [ [string] ] [EOL] return ( last_node - first_node ) * self . _bufsize + ( cur - first ) [EOL] [EOL] def index ( self , obj , idx ) : [EOL] first_node = obj [ [string] ] [ [string] ] [ [string] ] [EOL] index_node = first_node + int ( idx ) // self . _bufsize [EOL] return index_node [ [number] ] [ idx % self . _bufsize ] [EOL] [EOL] class DequeEmptyWorker ( DequeWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return get_bool_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return ( obj [ [string] ] [ [string] ] [ [string] ] == obj [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] class DequeSizeWorker ( DequeWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return self . size ( obj ) [EOL] [EOL] class DequeFrontWorker ( DequeWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return obj [ [string] ] [ [string] ] [ [string] ] [ [number] ] [EOL] [EOL] class DequeBackWorker ( DequeWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj ) : [EOL] if ( obj [ [string] ] [ [string] ] [ [string] ] == obj [ [string] ] [ [string] ] [ [string] ] ) : [EOL] prev_node = obj [ [string] ] [ [string] ] [ [string] ] - [number] [EOL] return prev_node [ [number] ] [ self . _bufsize - [number] ] [EOL] else : [EOL] return obj [ [string] ] [ [string] ] [ [string] ] [ - [number] ] [EOL] [EOL] class DequeSubscriptWorker ( DequeWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def get_result_type ( self , obj , subscript ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj , subscript ) : [EOL] return self . index ( obj , subscript ) [EOL] [EOL] class DequeAtWorker ( DequeWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def get_result_type ( self , obj , index ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj , index ) : [EOL] deque_size = int ( self . size ( obj ) ) [EOL] if int ( index ) >= deque_size : [EOL] raise IndexError ( [string] % ( int ( index ) , deque_size ) ) [EOL] else : [EOL] return self . index ( obj , index ) [EOL] [EOL] class DequeMethodsMatcher ( gdb . xmethod . XMethodMatcher ) : [EOL] def __init__ ( self ) : [EOL] gdb . xmethod . XMethodMatcher . __init__ ( self , matcher_name_prefix + [string] ) [EOL] self . _method_dict = { [string] : LibStdCxxXMethod ( [string] , DequeEmptyWorker ) , [string] : LibStdCxxXMethod ( [string] , DequeSizeWorker ) , [string] : LibStdCxxXMethod ( [string] , DequeFrontWorker ) , [string] : LibStdCxxXMethod ( [string] , DequeBackWorker ) , [string] : LibStdCxxXMethod ( [string] , DequeSubscriptWorker ) , [string] : LibStdCxxXMethod ( [string] , DequeAtWorker ) } [EOL] self . methods = [ self . _method_dict [ m ] for m in self . _method_dict ] [EOL] [EOL] def match ( self , class_type , method_name ) : [EOL] if not re . match ( [string] , class_type . tag ) : [EOL] return None [EOL] method = self . _method_dict . get ( method_name ) [EOL] if method is None or not method . enabled : [EOL] return None [EOL] return method . worker_class ( class_type . template_argument ( [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] class ForwardListWorkerBase ( gdb . xmethod . XMethodMatcher ) : [EOL] def __init__ ( self , val_type , node_type ) : [EOL] self . _val_type = val_type [EOL] self . _node_type = node_type [EOL] [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] class ForwardListEmptyWorker ( ForwardListWorkerBase ) : [EOL] def get_result_type ( self , obj ) : [EOL] return get_bool_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return obj [ [string] ] [ [string] ] [ [string] ] == [number] [EOL] [EOL] class ForwardListFrontWorker ( ForwardListWorkerBase ) : [EOL] def get_result_type ( self , obj ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj ) : [EOL] node = obj [ [string] ] [ [string] ] [ [string] ] . cast ( self . _node_type ) [EOL] val_address = node [ [string] ] [ [string] ] . address [EOL] return val_address . cast ( self . _val_type . pointer ( ) ) . dereference ( ) [EOL] [EOL] class ForwardListMethodsMatcher ( gdb . xmethod . XMethodMatcher ) : [EOL] def __init__ ( self ) : [EOL] matcher_name = matcher_name_prefix + [string] [EOL] gdb . xmethod . XMethodMatcher . __init__ ( self , matcher_name ) [EOL] self . _method_dict = { [string] : LibStdCxxXMethod ( [string] , ForwardListEmptyWorker ) , [string] : LibStdCxxXMethod ( [string] , ForwardListFrontWorker ) } [EOL] self . methods = [ self . _method_dict [ m ] for m in self . _method_dict ] [EOL] [EOL] def match ( self , class_type , method_name ) : [EOL] if not re . match ( [string] , class_type . tag ) : [EOL] return None [EOL] method = self . _method_dict . get ( method_name ) [EOL] if method is None or not method . enabled : [EOL] return None [EOL] val_type = class_type . template_argument ( [number] ) [EOL] node_type = gdb . lookup_type ( str ( class_type ) + [string] ) . pointer ( ) [EOL] return method . worker_class ( val_type , node_type ) [EOL] [EOL] [comment] [EOL] [EOL] class ListWorkerBase ( gdb . xmethod . XMethodWorker ) : [EOL] def __init__ ( self , val_type , node_type ) : [EOL] self . _val_type = val_type [EOL] self . _node_type = node_type [EOL] [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_value_from_node ( self , node ) : [EOL] node = node . dereference ( ) [EOL] if node . type . fields ( ) [ [number] ] . name == [string] : [EOL] [comment] [EOL] return node [ [string] ] [EOL] [comment] [EOL] addr = node [ [string] ] . address [EOL] return addr . cast ( self . _val_type . pointer ( ) ) . dereference ( ) [EOL] [EOL] class ListEmptyWorker ( ListWorkerBase ) : [EOL] def get_result_type ( self , obj ) : [EOL] return get_bool_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] base_node = obj [ [string] ] [ [string] ] [EOL] if base_node [ [string] ] == base_node . address : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] class ListSizeWorker ( ListWorkerBase ) : [EOL] def get_result_type ( self , obj ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] begin_node = obj [ [string] ] [ [string] ] [ [string] ] [EOL] end_node = obj [ [string] ] [ [string] ] . address [EOL] size = [number] [EOL] while begin_node != end_node : [EOL] begin_node = begin_node [ [string] ] [EOL] size += [number] [EOL] return size [EOL] [EOL] class ListFrontWorker ( ListWorkerBase ) : [EOL] def get_result_type ( self , obj ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj ) : [EOL] node = obj [ [string] ] [ [string] ] [ [string] ] . cast ( self . _node_type ) [EOL] return self . get_value_from_node ( node ) [EOL] [EOL] class ListBackWorker ( ListWorkerBase ) : [EOL] def get_result_type ( self , obj ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj ) : [EOL] prev_node = obj [ [string] ] [ [string] ] [ [string] ] . cast ( self . _node_type ) [EOL] return self . get_value_from_node ( prev_node ) [EOL] [EOL] class ListMethodsMatcher ( gdb . xmethod . XMethodMatcher ) : [EOL] def __init__ ( self ) : [EOL] gdb . xmethod . XMethodMatcher . __init__ ( self , matcher_name_prefix + [string] ) [EOL] self . _method_dict = { [string] : LibStdCxxXMethod ( [string] , ListEmptyWorker ) , [string] : LibStdCxxXMethod ( [string] , ListSizeWorker ) , [string] : LibStdCxxXMethod ( [string] , ListFrontWorker ) , [string] : LibStdCxxXMethod ( [string] , ListBackWorker ) } [EOL] self . methods = [ self . _method_dict [ m ] for m in self . _method_dict ] [EOL] [EOL] def match ( self , class_type , method_name ) : [EOL] if not re . match ( [string] , class_type . tag ) : [EOL] return None [EOL] method = self . _method_dict . get ( method_name ) [EOL] if method is None or not method . enabled : [EOL] return None [EOL] val_type = class_type . template_argument ( [number] ) [EOL] node_type = gdb . lookup_type ( str ( class_type ) + [string] ) . pointer ( ) [EOL] return method . worker_class ( val_type , node_type ) [EOL] [EOL] [comment] [EOL] [EOL] class VectorWorkerBase ( gdb . xmethod . XMethodWorker ) : [EOL] def __init__ ( self , val_type ) : [EOL] self . _val_type = val_type [EOL] [EOL] def size ( self , obj ) : [EOL] if self . _val_type . code == gdb . TYPE_CODE_BOOL : [EOL] start = obj [ [string] ] [ [string] ] [ [string] ] [EOL] finish = obj [ [string] ] [ [string] ] [ [string] ] [EOL] finish_offset = obj [ [string] ] [ [string] ] [ [string] ] [EOL] bit_size = start . dereference ( ) . type . sizeof * [number] [EOL] return ( finish - start ) * bit_size + finish_offset [EOL] else : [EOL] return obj [ [string] ] [ [string] ] - obj [ [string] ] [ [string] ] [EOL] [EOL] def get ( self , obj , index ) : [EOL] if self . _val_type . code == gdb . TYPE_CODE_BOOL : [EOL] start = obj [ [string] ] [ [string] ] [ [string] ] [EOL] bit_size = start . dereference ( ) . type . sizeof * [number] [EOL] valp = start + index // bit_size [EOL] offset = index % bit_size [EOL] return ( valp . dereference ( ) & ( [number] << offset ) ) > [number] [EOL] else : [EOL] return obj [ [string] ] [ [string] ] [ index ] [EOL] [EOL] class VectorEmptyWorker ( VectorWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return get_bool_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return int ( self . size ( obj ) ) == [number] [EOL] [EOL] class VectorSizeWorker ( VectorWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return self . size ( obj ) [EOL] [EOL] class VectorFrontWorker ( VectorWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return self . get ( obj , [number] ) [EOL] [EOL] class VectorBackWorker ( VectorWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return self . get ( obj , int ( self . size ( obj ) ) - [number] ) [EOL] [EOL] class VectorAtWorker ( VectorWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def get_result_type ( self , obj , index ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj , index ) : [EOL] size = int ( self . size ( obj ) ) [EOL] if int ( index ) >= size : [EOL] raise IndexError ( [string] % ( ( int ( index ) , size ) ) ) [EOL] return self . get ( obj , int ( index ) ) [EOL] [EOL] class VectorSubscriptWorker ( VectorWorkerBase ) : [EOL] def get_arg_types ( self ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def get_result_type ( self , obj , subscript ) : [EOL] return self . _val_type [EOL] [EOL] def __call__ ( self , obj , subscript ) : [EOL] return self . get ( obj , int ( subscript ) ) [EOL] [EOL] class VectorMethodsMatcher ( gdb . xmethod . XMethodMatcher ) : [EOL] def __init__ ( self ) : [EOL] gdb . xmethod . XMethodMatcher . __init__ ( self , matcher_name_prefix + [string] ) [EOL] self . _method_dict = { [string] : LibStdCxxXMethod ( [string] , VectorSizeWorker ) , [string] : LibStdCxxXMethod ( [string] , VectorEmptyWorker ) , [string] : LibStdCxxXMethod ( [string] , VectorFrontWorker ) , [string] : LibStdCxxXMethod ( [string] , VectorBackWorker ) , [string] : LibStdCxxXMethod ( [string] , VectorAtWorker ) , [string] : LibStdCxxXMethod ( [string] , VectorSubscriptWorker ) , } [EOL] self . methods = [ self . _method_dict [ m ] for m in self . _method_dict ] [EOL] [EOL] def match ( self , class_type , method_name ) : [EOL] if not re . match ( [string] , class_type . tag ) : [EOL] return None [EOL] method = self . _method_dict . get ( method_name ) [EOL] if method is None or not method . enabled : [EOL] return None [EOL] return method . worker_class ( class_type . template_argument ( [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] class AssociativeContainerWorkerBase ( gdb . xmethod . XMethodWorker ) : [EOL] def __init__ ( self , unordered ) : [EOL] self . _unordered = unordered [EOL] [EOL] def node_count ( self , obj ) : [EOL] if self . _unordered : [EOL] return obj [ [string] ] [ [string] ] [EOL] else : [EOL] return obj [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] class AssociativeContainerEmptyWorker ( AssociativeContainerWorkerBase ) : [EOL] def get_result_type ( self , obj ) : [EOL] return get_bool_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return int ( self . node_count ( obj ) ) == [number] [EOL] [EOL] class AssociativeContainerSizeWorker ( AssociativeContainerWorkerBase ) : [EOL] def get_result_type ( self , obj ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return self . node_count ( obj ) [EOL] [EOL] class AssociativeContainerMethodsMatcher ( gdb . xmethod . XMethodMatcher ) : [EOL] def __init__ ( self , name ) : [EOL] gdb . xmethod . XMethodMatcher . __init__ ( self , matcher_name_prefix + name ) [EOL] self . _name = name [EOL] self . _method_dict = { [string] : LibStdCxxXMethod ( [string] , AssociativeContainerSizeWorker ) , [string] : LibStdCxxXMethod ( [string] , AssociativeContainerEmptyWorker ) , } [EOL] self . methods = [ self . _method_dict [ m ] for m in self . _method_dict ] [EOL] [EOL] def match ( self , class_type , method_name ) : [EOL] if not re . match ( [string] % self . _name , class_type . tag ) : [EOL] return None [EOL] method = self . _method_dict . get ( method_name ) [EOL] if method is None or not method . enabled : [EOL] return None [EOL] unordered = [string] in self . _name [EOL] return method . worker_class ( unordered ) [EOL] [EOL] [comment] [EOL] [EOL] class UniquePtrGetWorker ( gdb . xmethod . XMethodWorker ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , elem_type ) : [EOL] self . _is_array = elem_type . code == gdb . TYPE_CODE_ARRAY [EOL] if self . _is_array : [EOL] self . _elem_type = elem_type . target ( ) [EOL] else : [EOL] self . _elem_type = elem_type [EOL] [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return self . _elem_type . pointer ( ) [EOL] [EOL] def _supports ( self , method_name ) : [EOL] [docstring] [EOL] return method_name == [string] or not self . _is_array [EOL] [EOL] def __call__ ( self , obj ) : [EOL] impl_type = obj . dereference ( ) . type . fields ( ) [ [number] ] . type . tag [EOL] if re . match ( [string] , impl_type ) : [comment] [EOL] return obj [ [string] ] [ [string] ] [ [string] ] [EOL] elif re . match ( [string] , impl_type ) : [EOL] return obj [ [string] ] [ [string] ] [EOL] return None [EOL] [EOL] class UniquePtrDerefWorker ( UniquePtrGetWorker ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , elem_type ) : [EOL] UniquePtrGetWorker . __init__ ( self , elem_type ) [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return self . _elem_type [EOL] [EOL] def _supports ( self , method_name ) : [EOL] [docstring] [EOL] return not self . _is_array [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return UniquePtrGetWorker . __call__ ( self , obj ) . dereference ( ) [EOL] [EOL] class UniquePtrSubscriptWorker ( UniquePtrGetWorker ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , elem_type ) : [EOL] UniquePtrGetWorker . __init__ ( self , elem_type ) [EOL] [EOL] def get_arg_types ( self ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def get_result_type ( self , obj , index ) : [EOL] return self . _elem_type [EOL] [EOL] def _supports ( self , method_name ) : [EOL] [docstring] [EOL] return self . _is_array [EOL] [EOL] def __call__ ( self , obj , index ) : [EOL] return UniquePtrGetWorker . __call__ ( self , obj ) [ index ] [EOL] [EOL] class UniquePtrMethodsMatcher ( gdb . xmethod . XMethodMatcher ) : [EOL] def __init__ ( self ) : [EOL] gdb . xmethod . XMethodMatcher . __init__ ( self , matcher_name_prefix + [string] ) [EOL] self . _method_dict = { [string] : LibStdCxxXMethod ( [string] , UniquePtrGetWorker ) , [string] : LibStdCxxXMethod ( [string] , UniquePtrGetWorker ) , [string] : LibStdCxxXMethod ( [string] , UniquePtrDerefWorker ) , [string] : LibStdCxxXMethod ( [string] , UniquePtrSubscriptWorker ) , } [EOL] self . methods = [ self . _method_dict [ m ] for m in self . _method_dict ] [EOL] [EOL] def match ( self , class_type , method_name ) : [EOL] if not re . match ( [string] , class_type . tag ) : [EOL] return None [EOL] method = self . _method_dict . get ( method_name ) [EOL] if method is None or not method . enabled : [EOL] return None [EOL] worker = method . worker_class ( class_type . template_argument ( [number] ) ) [EOL] if worker . _supports ( method_name ) : [EOL] return worker [EOL] return None [EOL] [EOL] [comment] [EOL] [EOL] class SharedPtrGetWorker ( gdb . xmethod . XMethodWorker ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , elem_type ) : [EOL] self . _is_array = elem_type . code == gdb . TYPE_CODE_ARRAY [EOL] if self . _is_array : [EOL] self . _elem_type = elem_type . target ( ) [EOL] else : [EOL] self . _elem_type = elem_type [EOL] [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return self . _elem_type . pointer ( ) [EOL] [EOL] def _supports ( self , method_name ) : [EOL] [docstring] [EOL] return method_name == [string] or not self . _is_array [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return obj [ [string] ] [EOL] [EOL] class SharedPtrDerefWorker ( SharedPtrGetWorker ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , elem_type ) : [EOL] SharedPtrGetWorker . __init__ ( self , elem_type ) [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return self . _elem_type [EOL] [EOL] def _supports ( self , method_name ) : [EOL] [docstring] [EOL] return not self . _is_array [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return SharedPtrGetWorker . __call__ ( self , obj ) . dereference ( ) [EOL] [EOL] class SharedPtrSubscriptWorker ( SharedPtrGetWorker ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , elem_type ) : [EOL] SharedPtrGetWorker . __init__ ( self , elem_type ) [EOL] [EOL] def get_arg_types ( self ) : [EOL] return get_std_size_type ( ) [EOL] [EOL] def get_result_type ( self , obj , index ) : [EOL] return self . _elem_type [EOL] [EOL] def _supports ( self , method_name ) : [EOL] [docstring] [EOL] return self . _is_array [EOL] [EOL] def __call__ ( self , obj , index ) : [EOL] [comment] [EOL] m = re . match ( [string] , str ( self . _elem_type ) ) [EOL] if m and index >= int ( m . group ( [number] ) ) : [EOL] raise IndexError ( [string] % ( self . _elem_type , int ( index ) , int ( m . group ( [number] ) ) ) ) [EOL] return SharedPtrGetWorker . __call__ ( self , obj ) [ index ] [EOL] [EOL] class SharedPtrUseCountWorker ( gdb . xmethod . XMethodWorker ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , elem_type ) : [EOL] SharedPtrUseCountWorker . __init__ ( self , elem_type ) [EOL] [EOL] def get_arg_types ( self ) : [EOL] return None [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return gdb . lookup_type ( [string] ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] refcounts = [ [string] ] [ [string] ] [EOL] return refcounts [ [string] ] if refcounts else [number] [EOL] [EOL] class SharedPtrUniqueWorker ( SharedPtrUseCountWorker ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , elem_type ) : [EOL] SharedPtrUseCountWorker . __init__ ( self , elem_type ) [EOL] [EOL] def get_result_type ( self , obj ) : [EOL] return gdb . lookup_type ( [string] ) [EOL] [EOL] def __call__ ( self , obj ) : [EOL] return SharedPtrUseCountWorker . __call__ ( self , obj ) == [number] [EOL] [EOL] class SharedPtrMethodsMatcher ( gdb . xmethod . XMethodMatcher ) : [EOL] def __init__ ( self ) : [EOL] gdb . xmethod . XMethodMatcher . __init__ ( self , matcher_name_prefix + [string] ) [EOL] self . _method_dict = { [string] : LibStdCxxXMethod ( [string] , SharedPtrGetWorker ) , [string] : LibStdCxxXMethod ( [string] , SharedPtrGetWorker ) , [string] : LibStdCxxXMethod ( [string] , SharedPtrDerefWorker ) , [string] : LibStdCxxXMethod ( [string] , SharedPtrSubscriptWorker ) , [string] : LibStdCxxXMethod ( [string] , SharedPtrUseCountWorker ) , [string] : LibStdCxxXMethod ( [string] , SharedPtrUniqueWorker ) , } [EOL] self . methods = [ self . _method_dict [ m ] for m in self . _method_dict ] [EOL] [EOL] def match ( self , class_type , method_name ) : [EOL] if not re . match ( [string] , class_type . tag ) : [EOL] return None [EOL] method = self . _method_dict . get ( method_name ) [EOL] if method is None or not method . enabled : [EOL] return None [EOL] worker = method . worker_class ( class_type . template_argument ( [number] ) ) [EOL] if worker . _supports ( method_name ) : [EOL] return worker [EOL] return None [EOL]  [EOL] def register_libstdcxx_xmethods ( locus ) : [EOL] gdb . xmethod . register_xmethod_matcher ( locus , ArrayMethodsMatcher ( ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , ForwardListMethodsMatcher ( ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , DequeMethodsMatcher ( ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , ListMethodsMatcher ( ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , VectorMethodsMatcher ( ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , AssociativeContainerMethodsMatcher ( [string] ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , AssociativeContainerMethodsMatcher ( [string] ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , AssociativeContainerMethodsMatcher ( [string] ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , AssociativeContainerMethodsMatcher ( [string] ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , AssociativeContainerMethodsMatcher ( [string] ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , AssociativeContainerMethodsMatcher ( [string] ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , AssociativeContainerMethodsMatcher ( [string] ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , AssociativeContainerMethodsMatcher ( [string] ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , UniquePtrMethodsMatcher ( ) ) [EOL] gdb . xmethod . register_xmethod_matcher ( locus , SharedPtrMethodsMatcher ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Literal , Optional , IO , Any , Match , Callable [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] import os . path [EOL] import re [EOL] import sys [EOL] import tempfile [EOL] [EOL] import gdb [EOL] import gdb . printing [EOL] import gdb . types [EOL] [EOL] [comment] [EOL] tree_code_dict = gdb . types . make_enum_dict ( gdb . lookup_type ( [string] ) ) [EOL] [EOL] [comment] [EOL] IDENTIFIER_NODE = tree_code_dict [ [string] ] [EOL] TYPE_DECL = tree_code_dict [ [string] ] [EOL] [EOL] [comment] [EOL] tree_code_class_dict = gdb . types . make_enum_dict ( gdb . lookup_type ( [string] ) ) [EOL] tcc_type = tree_code_class_dict [ [string] ] [EOL] tcc_declaration = tree_code_class_dict [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def intptr ( gdbval ) : [EOL] return long ( gdbval ) if sys . version_info . major == [number] else int ( gdbval ) [EOL] [EOL] class Tree : [EOL] [docstring] [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] [EOL] def is_nonnull ( self ) : [EOL] return intptr ( self . gdbval ) [EOL] [EOL] def TREE_CODE ( self ) : [EOL] [docstring] [EOL] return self . gdbval [ [string] ] [ [string] ] [EOL] [EOL] def DECL_NAME ( self ) : [EOL] [docstring] [EOL] return Tree ( self . gdbval [ [string] ] [ [string] ] ) [EOL] [EOL] def TYPE_NAME ( self ) : [EOL] [docstring] [EOL] return Tree ( self . gdbval [ [string] ] [ [string] ] ) [EOL] [EOL] def IDENTIFIER_POINTER ( self ) : [EOL] [docstring] [EOL] return self . gdbval [ [string] ] [ [string] ] [ [string] ] . string ( ) [EOL] [EOL] class TreePrinter : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] self . node = Tree ( gdbval ) [EOL] [EOL] def to_string ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if intptr ( self . gdbval ) == [number] : [EOL] return [string] [EOL] [EOL] val_TREE_CODE = self . node . TREE_CODE ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] val_tree_code_type = gdb . parse_and_eval ( [string] ) [EOL] val_tclass = val_tree_code_type [ val_TREE_CODE ] [EOL] [EOL] val_tree_code_name = gdb . parse_and_eval ( [string] ) [EOL] val_code_name = val_tree_code_name [ intptr ( val_TREE_CODE ) ] [EOL] [comment] [EOL] [EOL] result = [string] % ( val_code_name . string ( ) , intptr ( self . gdbval ) ) [EOL] if intptr ( val_tclass ) == tcc_declaration : [EOL] tree_DECL_NAME = self . node . DECL_NAME ( ) [EOL] if tree_DECL_NAME . is_nonnull ( ) : [EOL] result += [string] % tree_DECL_NAME . IDENTIFIER_POINTER ( ) [EOL] else : [EOL] pass [comment] [EOL] elif intptr ( val_tclass ) == tcc_type : [EOL] tree_TYPE_NAME = Tree ( self . gdbval [ [string] ] [ [string] ] ) [EOL] if tree_TYPE_NAME . is_nonnull ( ) : [EOL] if tree_TYPE_NAME . TREE_CODE ( ) == IDENTIFIER_NODE : [EOL] result += [string] % tree_TYPE_NAME . IDENTIFIER_POINTER ( ) [EOL] elif tree_TYPE_NAME . TREE_CODE ( ) == TYPE_DECL : [EOL] if tree_TYPE_NAME . DECL_NAME ( ) . is_nonnull ( ) : [EOL] result += [string] % tree_TYPE_NAME . DECL_NAME ( ) . IDENTIFIER_POINTER ( ) [EOL] if self . node . TREE_CODE ( ) == IDENTIFIER_NODE : [EOL] result += [string] % self . node . IDENTIFIER_POINTER ( ) [EOL] [comment] [EOL] result += [string] [EOL] return result [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class CGraphNodePrinter : [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] [EOL] def to_string ( self ) : [EOL] result = [string] % intptr ( self . gdbval ) [EOL] if intptr ( self . gdbval ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tree_decl = Tree ( self . gdbval [ [string] ] ) [EOL] result += [string] % tree_decl . DECL_NAME ( ) . IDENTIFIER_POINTER ( ) [EOL] result += [string] [EOL] return result [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class DWDieRefPrinter : [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] [EOL] def to_string ( self ) : [EOL] if intptr ( self . gdbval ) == [number] : [EOL] return [string] [EOL] result = [string] % intptr ( self . gdbval ) [EOL] result += [string] % self . gdbval [ [string] ] [EOL] if intptr ( self . gdbval [ [string] ] ) != [number] : [EOL] result += [string] % ( intptr ( self . gdbval [ [string] ] ) , self . gdbval [ [string] ] [ [string] ] ) [EOL] [EOL] result += [string] [EOL] return result [EOL] [EOL] [comment] [EOL] [EOL] class GimplePrinter : [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] [EOL] def to_string ( self ) : [EOL] if intptr ( self . gdbval ) == [number] : [EOL] return [string] [EOL] val_gimple_code = self . gdbval [ [string] ] [EOL] val_gimple_code_name = gdb . parse_and_eval ( [string] ) [EOL] val_code_name = val_gimple_code_name [ intptr ( val_gimple_code ) ] [EOL] result = [string] % ( val_code_name . string ( ) , intptr ( self . gdbval ) ) [EOL] result += [string] [EOL] return result [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def bb_index_to_str ( index ) : [EOL] if index == [number] : [EOL] return [string] [EOL] elif index == [number] : [EOL] return [string] [EOL] else : [EOL] return [string] % index [EOL] [EOL] class BasicBlockPrinter : [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] [EOL] def to_string ( self ) : [EOL] result = [string] % intptr ( self . gdbval ) [EOL] if intptr ( self . gdbval ) : [EOL] result += [string] % bb_index_to_str ( intptr ( self . gdbval [ [string] ] ) ) [EOL] result += [string] [EOL] return result [EOL] [EOL] class CfgEdgePrinter : [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] [EOL] def to_string ( self ) : [EOL] result = [string] % intptr ( self . gdbval ) [EOL] if intptr ( self . gdbval ) : [EOL] src = bb_index_to_str ( intptr ( self . gdbval [ [string] ] [ [string] ] ) ) [EOL] dest = bb_index_to_str ( intptr ( self . gdbval [ [string] ] [ [string] ] ) ) [EOL] result += [string] % ( src , dest ) [EOL] result += [string] [EOL] return result [EOL] [EOL] [comment] [EOL] [EOL] class Rtx : [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] [EOL] def GET_CODE ( self ) : [EOL] return self . gdbval [ [string] ] [EOL] [EOL] def GET_RTX_LENGTH ( code ) : [EOL] val_rtx_length = gdb . parse_and_eval ( [string] ) [EOL] return intptr ( val_rtx_length [ code ] ) [EOL] [EOL] def GET_RTX_NAME ( code ) : [EOL] val_rtx_name = gdb . parse_and_eval ( [string] ) [EOL] return val_rtx_name [ code ] . string ( ) [EOL] [EOL] def GET_RTX_FORMAT ( code ) : [EOL] val_rtx_format = gdb . parse_and_eval ( [string] ) [EOL] return val_rtx_format [ code ] . string ( ) [EOL] [EOL] class RtxPrinter : [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] self . rtx = Rtx ( gdbval ) [EOL] [EOL] def to_string ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] gdb . execute ( [string] % intptr ( self . gdbval ) ) [EOL] return [string] [EOL] [EOL] [comment] [EOL] result = ( [string] % ( intptr ( self . gdbval ) ) ) [EOL] code = self . rtx . GET_CODE ( ) [EOL] result += [string] % GET_RTX_NAME ( code ) [EOL] format_ = GET_RTX_FORMAT ( code ) [EOL] for i in range ( GET_RTX_LENGTH ( code ) ) : [EOL] print ( format_ [ i ] ) [EOL] result += [string] [EOL] return result [EOL] [EOL] [comment] [EOL] [EOL] class PassPrinter : [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] [EOL] def to_string ( self ) : [EOL] result = [string] % intptr ( self . gdbval ) [EOL] if intptr ( self . gdbval ) : [EOL] result += ( [string] % ( self . gdbval [ [string] ] . string ( ) , intptr ( self . gdbval [ [string] ] ) ) ) [EOL] result += [string] [EOL] return result [EOL] [EOL] [comment] [EOL] [EOL] class VecPrinter : [EOL] [comment] [EOL] def __init__ ( self , gdbval ) : [EOL] self . gdbval = gdbval [EOL] [EOL] def display_hint ( self ) : [EOL] return [string] [EOL] [EOL] def to_string ( self ) : [EOL] [comment] [EOL] [comment] [EOL] return [string] % intptr ( self . gdbval ) [EOL] [EOL] def children ( self ) : [EOL] if intptr ( self . gdbval ) == [number] : [EOL] return [EOL] m_vecpfx = self . gdbval [ [string] ] [EOL] m_num = m_vecpfx [ [string] ] [EOL] m_vecdata = self . gdbval [ [string] ] [EOL] for i in range ( m_num ) : [EOL] yield ( [string] % i , m_vecdata [ i ] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class GdbSubprinter ( gdb . printing . SubPrettyPrinter ) : [EOL] def __init__ ( self , name , class_ ) : [EOL] super ( GdbSubprinter , self ) . __init__ ( name ) [EOL] self . class_ = class_ [EOL] [EOL] def handles_type ( self , str_type ) : [EOL] raise NotImplementedError [EOL] [EOL] class GdbSubprinterTypeList ( GdbSubprinter ) : [EOL] [docstring] [EOL] def __init__ ( self , str_types , name , class_ ) : [EOL] super ( GdbSubprinterTypeList , self ) . __init__ ( name , class_ ) [EOL] self . str_types = frozenset ( str_types ) [EOL] [EOL] def handles_type ( self , str_type ) : [EOL] return str_type in self . str_types [EOL] [EOL] class GdbSubprinterRegex ( GdbSubprinter ) : [EOL] [docstring] [EOL] def __init__ ( self , regex , name , class_ ) : [EOL] super ( GdbSubprinterRegex , self ) . __init__ ( name , class_ ) [EOL] self . regex = re . compile ( regex ) [EOL] [EOL] def handles_type ( self , str_type ) : [EOL] return self . regex . match ( str_type ) [EOL] [EOL] class GdbPrettyPrinters ( gdb . printing . PrettyPrinter ) : [EOL] def __init__ ( self , name ) : [EOL] super ( GdbPrettyPrinters , self ) . __init__ ( name , [ ] ) [EOL] [EOL] def add_printer_for_types ( self , name , class_ , types ) : [EOL] self . subprinters . append ( GdbSubprinterTypeList ( name , class_ , types ) ) [EOL] [EOL] def add_printer_for_regex ( self , name , class_ , regex ) : [EOL] self . subprinters . append ( GdbSubprinterRegex ( name , class_ , regex ) ) [EOL] [EOL] def __call__ ( self , gdbval ) : [EOL] type_ = gdbval . type . unqualified ( ) [EOL] str_type = str ( type_ ) [EOL] for printer in self . subprinters : [EOL] if printer . enabled and printer . handles_type ( str_type ) : [EOL] return printer . class_ ( gdbval ) [EOL] [EOL] [comment] [EOL] return None [EOL] [EOL] [EOL] def build_pretty_printer ( ) : [EOL] pp = GdbPrettyPrinters ( [string] ) [EOL] pp . add_printer_for_types ( [ [string] ] , [string] , TreePrinter ) [EOL] pp . add_printer_for_types ( [ [string] ] , [string] , CGraphNodePrinter ) [EOL] pp . add_printer_for_types ( [ [string] ] , [string] , DWDieRefPrinter ) [EOL] pp . add_printer_for_types ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , [string] , GimplePrinter ) [EOL] pp . add_printer_for_types ( [ [string] , [string] ] , [string] , BasicBlockPrinter ) [EOL] pp . add_printer_for_types ( [ [string] , [string] ] , [string] , CfgEdgePrinter ) [EOL] pp . add_printer_for_types ( [ [string] ] , [string] , RtxPrinter ) [EOL] pp . add_printer_for_types ( [ [string] ] , [string] , PassPrinter ) [EOL] [EOL] pp . add_printer_for_regex ( [string] , [string] , VecPrinter ) [EOL] [EOL] return pp [EOL] [EOL] gdb . printing . register_pretty_printer ( gdb . current_objfile ( ) , build_pretty_printer ( ) ) [EOL] [EOL] def find_gcc_source_dir ( ) : [EOL] [comment] [EOL] sym_g = gdb . lookup_global_symbol ( [string] ) [EOL] path = sym_g . symtab . filename [comment] [EOL] srcdir = os . path . split ( path ) [ [number] ] [comment] [EOL] return srcdir [EOL] [EOL] class PassNames : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] srcdir = find_gcc_source_dir ( ) [EOL] self . names = [ ] [EOL] with open ( os . path . join ( srcdir , [string] ) ) as f : [EOL] for line in f : [EOL] m = re . match ( [string] , line ) [EOL] if m : [EOL] self . names . append ( m . group ( [number] ) ) [EOL] [EOL] class BreakOnPass ( gdb . Command ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] gdb . Command . __init__ ( self , [string] , gdb . COMMAND_BREAKPOINTS ) [EOL] self . pass_names = None [EOL] [EOL] def complete ( self , text , word ) : [EOL] [comment] [EOL] if not self . pass_names : [EOL] self . pass_names = PassNames ( ) [EOL] [EOL] return [ name for name in sorted ( self . pass_names . names ) if name . startswith ( text ) ] [EOL] [EOL] def invoke ( self , arg , from_tty ) : [EOL] sym = [string] % arg [EOL] breakpoint = gdb . Breakpoint ( sym ) [EOL] [EOL] BreakOnPass ( ) [EOL] [EOL] class DumpFn ( gdb . Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] gdb . Command . __init__ ( self , [string] , gdb . COMMAND_USER ) [EOL] [EOL] def invoke ( self , arg , from_tty ) : [EOL] [comment] [EOL] args = gdb . string_to_argv ( arg ) [EOL] if len ( args ) >= [number] and args [ [number] ] == [string] : [EOL] if len ( args ) == [number] : [EOL] print ( [string] ) [EOL] return [EOL] filename = args [ [number] ] [EOL] editor_mode = False [EOL] base_arg = [number] [EOL] else : [EOL] editor = os . getenv ( [string] , [string] ) [EOL] if editor == [string] : [EOL] print ( [string] ) [EOL] return [EOL] editor_mode = True [EOL] base_arg = [number] [EOL] if len ( args ) - base_arg > [number] : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] if len ( args ) - base_arg >= [number] : [EOL] funcname = args [ base_arg ] [EOL] printfuncname = [string] % funcname [EOL] else : [EOL] funcname = [string] [EOL] printfuncname = [string] [EOL] func = gdb . parse_and_eval ( funcname ) [EOL] if func == [number] : [EOL] print ( [string] % printfuncname ) [EOL] return [EOL] func = [string] % func [EOL] [EOL] [comment] [EOL] if len ( args ) - base_arg >= [number] : [EOL] flags = gdb . parse_and_eval ( args [ base_arg + [number] ] ) [EOL] else : [EOL] flags = [number] [EOL] [EOL] [comment] [EOL] if editor_mode : [EOL] f = tempfile . NamedTemporaryFile ( delete = False , suffix = [string] ) [EOL] filename = f . name [EOL] f . close ( ) [EOL] [EOL] [comment] [EOL] fp = gdb . parse_and_eval ( [string] % filename ) [EOL] if fp == [number] : [EOL] print ( [string] % filename ) [EOL] return [EOL] fp = [string] % fp [EOL] [EOL] [comment] [EOL] _ = gdb . parse_and_eval ( [string] % ( func , fp , flags ) ) [EOL] [EOL] [comment] [EOL] ret = gdb . parse_and_eval ( [string] % fp ) [EOL] if ret != [number] : [EOL] print ( [string] % filename ) [EOL] return [EOL] [EOL] [comment] [EOL] if editor_mode : [EOL] os . system ( [string] % ( editor , filename , filename ) ) [EOL] [EOL] DumpFn ( ) [EOL] [EOL] class DotFn ( gdb . Command ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] gdb . Command . __init__ ( self , [string] , gdb . COMMAND_USER ) [EOL] [EOL] def invoke ( self , arg , from_tty ) : [EOL] [comment] [EOL] args = gdb . string_to_argv ( arg ) [EOL] if len ( args ) > [number] : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] if len ( args ) >= [number] : [EOL] funcname = args [ [number] ] [EOL] printfuncname = [string] % funcname [EOL] else : [EOL] funcname = [string] [EOL] printfuncname = [string] [EOL] func = gdb . parse_and_eval ( funcname ) [EOL] if func == [number] : [EOL] print ( [string] % printfuncname ) [EOL] return [EOL] func = [string] % func [EOL] [EOL] [comment] [EOL] if len ( args ) >= [number] : [EOL] flags = gdb . parse_and_eval ( args [ [number] ] ) [EOL] else : [EOL] flags = [number] [EOL] [EOL] [comment] [EOL] f = tempfile . NamedTemporaryFile ( delete = False ) [EOL] filename = f . name [EOL] [EOL] [comment] [EOL] f . close ( ) [EOL] fp = gdb . parse_and_eval ( [string] % filename ) [EOL] if fp == [number] : [EOL] print ( [string] ) [EOL] return [EOL] fp = [string] % fp [EOL] [EOL] [comment] [EOL] _ = gdb . parse_and_eval ( [string] % fp ) [EOL] _ = gdb . parse_and_eval ( [string] % ( fp , func , flags ) ) [EOL] _ = gdb . parse_and_eval ( [string] % fp ) [EOL] [EOL] [comment] [EOL] ret = gdb . parse_and_eval ( [string] % fp ) [EOL] if ret != [number] : [EOL] print ( [string] % filename ) [EOL] return [EOL] [EOL] [comment] [EOL] os . system ( [string] % ( filename , filename ) ) [EOL] [EOL] DotFn ( ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Callable[[None,None],None]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.IO[builtins.bytes]$ 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , List , Any , Tuple , Callable [EOL] import typing [EOL] import sys , os [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = [string] [EOL] copyright = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def __read_file ( name ) : [EOL] gcc_srcdir = [string] [EOL] path = os . path . join ( gcc_srcdir , name ) [EOL] if os . path . exists ( path ) : [EOL] return open ( path ) . read ( ) . strip ( ) [EOL] else : [EOL] return [string] [EOL] gcc_BASEVER = __read_file ( [string] ) [EOL] gcc_DEVPHASE = __read_file ( [string] ) [EOL] gcc_DATESTAMP = __read_file ( [string] ) [EOL] gcc_REVISION = __read_file ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = gcc_BASEVER [EOL] [comment] [EOL] release = ( [string] % ( gcc_BASEVER , gcc_DEVPHASE , gcc_DATESTAMP , ( [string] % gcc_REVISION ) if gcc_REVISION else [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( [string] , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( [string] , [string] , [string] , [ [string] ] , [number] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] PAGE_BLANK = [string] [EOL] [EOL] TOC_DEPTH = [string] [EOL] [EOL] TOC_CMD = [string] [EOL] [EOL] TOC = [string] [EOL] [EOL] LATEX_HYPHEN = [string] [EOL] [EOL] [EOL] def doc_settings ( full_document_name , version ) : [EOL] return [string] . join ( [ [string] + full_document_name + [string] , [string] + version + [string] ] ) [EOL]	0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , List , Any , Tuple , DefaultDict , Set [EOL] import typing [EOL] import subprocess [EOL] import argparse [EOL] import subprocess [EOL] import os [EOL] import errno [EOL] import collections [EOL] import glob [EOL] import argparse [EOL] [EOL] class Platform ( object ) : [EOL] pass [EOL] [EOL] class simulator_platform ( Platform ) : [EOL] directory = [string] [EOL] sdk = [string] [EOL] arch = [string] [EOL] triple = [string] [EOL] version_min = [string] [EOL] [EOL] prefix = [string] [EOL] suffix = [string] [EOL] src_dir = [string] [EOL] src_files = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] class simulator64_platform ( Platform ) : [EOL] directory = [string] [EOL] sdk = [string] [EOL] arch = [string] [EOL] triple = [string] [EOL] version_min = [string] [EOL] [EOL] prefix = [string] [EOL] suffix = [string] [EOL] src_dir = [string] [EOL] src_files = [ [string] , [string] ] [EOL] [EOL] [EOL] class device_platform ( Platform ) : [EOL] directory = [string] [EOL] sdk = [string] [EOL] arch = [string] [EOL] triple = [string] [EOL] version_min = [string] [EOL] [EOL] prefix = [string] [EOL] suffix = [string] [EOL] src_dir = [string] [EOL] src_files = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] class device64_platform ( Platform ) : [EOL] directory = [string] [EOL] sdk = [string] [EOL] arch = [string] [EOL] triple = [string] [EOL] version_min = [string] [EOL] [EOL] prefix = [string] [EOL] suffix = [string] [EOL] src_dir = [string] [EOL] src_files = [ [string] , [string] ] [EOL] [EOL] [EOL] class desktop32_platform ( Platform ) : [EOL] directory = [string] [EOL] sdk = [string] [EOL] arch = [string] [EOL] triple = [string] [EOL] version_min = [string] [EOL] src_dir = [string] [EOL] src_files = [ [string] , [string] , [string] ] [EOL] [EOL] prefix = [string] [EOL] suffix = [string] [EOL] [EOL] [EOL] class desktop64_platform ( Platform ) : [EOL] directory = [string] [EOL] sdk = [string] [EOL] arch = [string] [EOL] triple = [string] [EOL] version_min = [string] [EOL] [EOL] prefix = [string] [EOL] suffix = [string] [EOL] src_dir = [string] [EOL] src_files = [ [string] , [string] ] [EOL] [EOL] [EOL] def mkdir_p ( path ) : [EOL] try : [EOL] os . makedirs ( path ) [EOL] except OSError as exc : [comment] [EOL] if exc . errno == errno . EEXIST : [EOL] pass [EOL] else : [EOL] raise [EOL] [EOL] [EOL] def move_file ( src_dir , dst_dir , filename , file_suffix = None , prefix = [string] , suffix = [string] ) : [EOL] mkdir_p ( dst_dir ) [EOL] out_filename = filename [EOL] [EOL] if file_suffix : [EOL] split_name = os . path . splitext ( filename ) [EOL] out_filename = [string] % ( split_name [ [number] ] , file_suffix , split_name [ [number] ] ) [EOL] [EOL] with open ( os . path . join ( src_dir , filename ) ) as in_file : [EOL] with open ( os . path . join ( dst_dir , out_filename ) , [string] ) as out_file : [EOL] if prefix : [EOL] out_file . write ( prefix ) [EOL] [EOL] out_file . write ( in_file . read ( ) ) [EOL] [EOL] if suffix : [EOL] out_file . write ( suffix ) [EOL] [EOL] [EOL] def list_files ( src_dir , pattern = None , filelist = None ) : [EOL] if pattern : filelist = glob . iglob ( os . path . join ( src_dir , pattern ) ) [EOL] for file in filelist : [EOL] yield os . path . basename ( file ) [EOL] [EOL] [EOL] def copy_files ( src_dir , dst_dir , pattern = None , filelist = None , file_suffix = None , prefix = None , suffix = None ) : [EOL] for filename in list_files ( src_dir , pattern = pattern , filelist = filelist ) : [EOL] move_file ( src_dir , dst_dir , filename , file_suffix = file_suffix , prefix = prefix , suffix = suffix ) [EOL] [EOL] [EOL] def copy_src_platform_files ( platform ) : [EOL] src_dir = os . path . join ( [string] , platform . src_dir ) [EOL] dst_dir = os . path . join ( platform . directory , [string] , platform . src_dir ) [EOL] copy_files ( src_dir , dst_dir , filelist = platform . src_files , file_suffix = platform . arch , prefix = platform . prefix , suffix = platform . suffix ) [EOL] [EOL] [EOL] def build_target ( platform , platform_headers ) : [EOL] def xcrun_cmd ( cmd ) : [EOL] return [string] % ( platform . sdk , cmd , platform . arch ) [EOL] [EOL] tag = [string] % ( platform . sdk , platform . arch ) [EOL] build_dir = [string] % tag [EOL] mkdir_p ( build_dir ) [EOL] env = dict ( CC = xcrun_cmd ( [string] ) , LD = xcrun_cmd ( [string] ) , CFLAGS = [string] % ( platform . version_min ) ) [EOL] working_dir = os . getcwd ( ) [EOL] try : [EOL] os . chdir ( build_dir ) [EOL] subprocess . check_call ( [ [string] , [string] , platform . triple ] , env = env ) [EOL] finally : [EOL] os . chdir ( working_dir ) [EOL] [EOL] for src_dir in [ build_dir , os . path . join ( build_dir , [string] ) ] : [EOL] copy_files ( src_dir , os . path . join ( platform . directory , [string] ) , pattern = [string] , file_suffix = platform . arch , prefix = platform . prefix , suffix = platform . suffix ) [EOL] [EOL] for filename in list_files ( src_dir , pattern = [string] ) : [EOL] platform_headers [ filename ] . add ( ( platform . prefix , platform . arch , platform . suffix ) ) [EOL] [EOL] [EOL] def make_tramp ( ) : [EOL] with open ( [string] , [string] ) as tramp_out : [EOL] p = subprocess . Popen ( [ [string] , [string] ] , stdout = tramp_out ) [EOL] p . wait ( ) [EOL] [EOL] [EOL] def generate_source_and_headers ( generate_osx = True , generate_ios = True ) : [EOL] copy_files ( [string] , [string] , pattern = [string] ) [EOL] copy_files ( [string] , [string] , pattern = [string] ) [EOL] [EOL] if generate_ios : [EOL] make_tramp ( ) [EOL] copy_src_platform_files ( simulator_platform ) [EOL] copy_src_platform_files ( simulator64_platform ) [EOL] copy_src_platform_files ( device_platform ) [EOL] copy_src_platform_files ( device64_platform ) [EOL] if generate_osx : [EOL] copy_src_platform_files ( desktop32_platform ) [EOL] copy_src_platform_files ( desktop64_platform ) [EOL] [EOL] platform_headers = collections . defaultdict ( set ) [EOL] [EOL] if generate_ios : [EOL] build_target ( simulator_platform , platform_headers ) [EOL] build_target ( simulator64_platform , platform_headers ) [EOL] build_target ( device_platform , platform_headers ) [EOL] build_target ( device64_platform , platform_headers ) [EOL] if generate_osx : [EOL] build_target ( desktop32_platform , platform_headers ) [EOL] build_target ( desktop64_platform , platform_headers ) [EOL] [EOL] mkdir_p ( [string] ) [EOL] for header_name , tag_tuples in platform_headers . iteritems ( ) : [EOL] basename , suffix = os . path . splitext ( header_name ) [EOL] with open ( os . path . join ( [string] , header_name ) , [string] ) as header : [EOL] for tag_tuple in tag_tuples : [EOL] header . write ( [string] % ( tag_tuple [ [number] ] , basename , tag_tuple [ [number] ] , suffix , tag_tuple [ [number] ] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , action = [string] , default = False ) [EOL] parser . add_argument ( [string] , action = [string] , default = False ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] generate_source_and_headers ( generate_osx = not args . only_ios , generate_ios = not args . only_osx ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , List , Optional , Any , Match [EOL] import typing [EOL] import argparse [EOL] import requests [EOL] import requests [EOL] import json [EOL] import argparse [EOL] import re [EOL] [EOL] from semantic_version import Version [EOL] [EOL] base_url = [string] [EOL] statuses = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] search_summary = [string] [EOL] regex = [string] [EOL] [EOL] class Bug : [EOL] def __init__ ( self , data ) : [EOL] self . data = data [EOL] self . versions = None [EOL] self . fail_versions = [ ] [EOL] self . is_regression = False [EOL] [EOL] self . parse_summary ( ) [EOL] self . parse_known_to_fail ( ) [EOL] [EOL] def parse_summary ( self ) : [EOL] m = re . match ( regex , self . data [ [string] ] ) [EOL] if m != None : [EOL] self . versions = m . group ( [number] ) . split ( [string] ) [EOL] self . is_regression = True [EOL] self . regex_match = m [EOL] [EOL] def parse_known_to_fail ( self ) : [EOL] v = self . data [ [string] ] . strip ( ) [EOL] if v != [string] : [EOL] self . fail_versions = [ x for x in re . split ( [string] , v ) if x != [string] ] [EOL] [EOL] def name ( self ) : [EOL] return [string] % ( self . data [ [string] ] , self . data [ [string] ] ) [EOL] [EOL] def remove_release ( self , release ) : [EOL] [comment] [EOL] if len ( self . versions ) == [number] : [EOL] return [EOL] self . versions = list ( filter ( lambda x : x != release , self . versions ) ) [EOL] [EOL] def add_release ( self , releases ) : [EOL] parts = releases . split ( [string] ) [EOL] assert len ( parts ) == [number] [EOL] for i , v in enumerate ( self . versions ) : [EOL] if v == parts [ [number] ] : [EOL] self . versions . insert ( i + [number] , parts [ [number] ] ) [EOL] break [EOL] [EOL] def add_known_to_fail ( self , release ) : [EOL] if release in self . fail_versions : [EOL] return False [EOL] else : [EOL] self . fail_versions . append ( release ) [EOL] return True [EOL] [EOL] def update_summary ( self , api_key , doit ) : [EOL] summary = self . data [ [string] ] [EOL] new_summary = self . serialize_summary ( ) [EOL] if new_summary != summary : [EOL] print ( self . name ( ) ) [EOL] print ( [string] % ( summary , new_summary ) ) [EOL] self . modify_bug ( api_key , { [string] : new_summary } , doit ) [EOL] [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def change_milestone ( self , api_key , old_milestone , new_milestone , comment , new_fail_version , doit ) : [EOL] old_major = Bug . get_major_version ( old_milestone ) [EOL] new_major = Bug . get_major_version ( new_milestone ) [EOL] [EOL] print ( self . name ( ) ) [EOL] args = { } [EOL] if old_major == new_major : [EOL] args [ [string] ] = new_milestone [EOL] print ( [string] % ( old_milestone , new_milestone ) ) [EOL] elif self . is_regression and new_major in self . versions : [EOL] args [ [string] ] = new_milestone [EOL] print ( [string] % ( old_milestone , new_milestone ) ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] if [string] in args and comment != None : [EOL] print ( [string] % comment ) [EOL] args [ [string] ] = { [string] : comment } [EOL] [EOL] if new_fail_version != None : [EOL] if self . add_known_to_fail ( new_fail_version ) : [EOL] s = self . serialize_known_to_fail ( ) [EOL] print ( [string] % ( self . data [ [string] ] , s ) ) [EOL] args [ [string] ] = s [EOL] [EOL] if len ( args . keys ( ) ) != [number] : [EOL] self . modify_bug ( api_key , args , doit ) [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] def serialize_summary ( self ) : [EOL] assert self . versions != None [EOL] assert self . is_regression == True [EOL] [EOL] new_version = [string] . join ( self . versions ) [EOL] new_summary = self . regex_match . group ( [number] ) + new_version + self . regex_match . group ( [number] ) + self . regex_match . group ( [number] ) [EOL] return new_summary [EOL] [EOL] def serialize_known_to_fail ( self ) : [EOL] assert type ( self . fail_versions ) is list [EOL] return [string] . join ( sorted ( self . fail_versions , key = lambda x : Version ( x , partial = True ) ) ) [EOL] [EOL] def modify_bug ( self , api_key , params , doit ) : [EOL] u = base_url + [string] + str ( self . data [ [string] ] ) [EOL] [EOL] data = { [string] : [ self . data [ [string] ] ] , [string] : api_key } [EOL] [EOL] data . update ( params ) [EOL] [EOL] if doit : [EOL] r = requests . put ( u , data = json . dumps ( data ) , headers = { [string] : [string] } ) [EOL] print ( r ) [EOL] [EOL] @ staticmethod def get_major_version ( release ) : [EOL] parts = release . split ( [string] ) [EOL] assert len ( parts ) == [number] or len ( parts ) == [number] [EOL] return [string] . join ( parts [ : - [number] ] ) [EOL] [EOL] @ staticmethod def get_bugs ( api_key , query ) : [EOL] u = base_url + [string] [EOL] r = requests . get ( u , params = query ) [EOL] return [ Bug ( x ) for x in r . json ( ) [ [string] ] ] [EOL] [EOL] def search ( api_key , remove , add , limit , doit ) : [EOL] bugs = Bug . get_bugs ( api_key , { [string] : api_key , [string] : search_summary , [string] : statuses } ) [EOL] bugs = list ( filter ( lambda x : x . is_regression , bugs ) ) [EOL] [EOL] modified = [number] [EOL] for bug in bugs : [EOL] if remove != None : [EOL] bug . remove_release ( remove ) [EOL] if add != None : [EOL] bug . add_release ( add ) [EOL] [EOL] if bug . update_summary ( api_key , doit ) : [EOL] modified += [number] [EOL] if modified == limit : [EOL] break [EOL] [EOL] print ( [string] % modified ) [EOL] [EOL] def replace_milestone ( api_key , limit , old_milestone , new_milestone , comment , add_known_to_fail , doit ) : [EOL] bugs = Bug . get_bugs ( api_key , { [string] : api_key , [string] : statuses , [string] : old_milestone } ) [EOL] [EOL] modified = [number] [EOL] for bug in bugs : [EOL] if bug . change_milestone ( api_key , old_milestone , new_milestone , comment , add_known_to_fail , doit ) : [EOL] modified += [number] [EOL] if modified == limit : [EOL] break [EOL] [EOL] print ( [string] % modified ) [EOL] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [comment] [EOL] args . limit = int ( args . limit ) if args . limit != None else [number] ** [number] [EOL] [EOL] if args . remove != None or args . add != None : [EOL] search ( args . api_key , args . remove , args . add , args . limit , args . doit ) [EOL] if args . new_target_milestone != None : [EOL] t = args . new_target_milestone . split ( [string] ) [EOL] assert len ( t ) == [number] [EOL] replace_milestone ( args . api_key , args . limit , t [ [number] ] , t [ [number] ] , args . comment , args . add_known_to_fail , args . doit ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Any [EOL] import typing [EOL] import struct [EOL] [EOL] def __wt2struct ( fmt ) : [EOL] if not fmt : [EOL] return None , fmt [EOL] [comment] [EOL] if fmt [ [number] ] in [string] : [EOL] tfmt = fmt [ [number] ] [EOL] fmt = fmt [ [number] : ] [EOL] else : [EOL] tfmt = [string] [EOL] return tfmt , fmt . replace ( [string] , [string] ) [EOL] [EOL] def unpack ( fmt , s ) : [EOL] tfmt , fmt = __wt2struct ( fmt ) [EOL] if not fmt : [EOL] return ( ) [EOL] result = ( ) [EOL] pfmt = tfmt [EOL] sizebytes = [number] [EOL] for offset , f in enumerate ( fmt ) : [EOL] if f . isdigit ( ) : [EOL] sizebytes += [number] [EOL] [comment] [EOL] if f in [string] and sizebytes > [number] : [EOL] f = [string] [EOL] if f not in [string] : [EOL] pfmt += f [EOL] sizebytes = [number] [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] if len ( pfmt ) > [number] : [EOL] size = struct . calcsize ( pfmt ) [EOL] result += struct . unpack_from ( pfmt , s ) [EOL] s = s [ size : ] [EOL] if f == [string] : [EOL] l = s . find ( [string] ) [EOL] result += ( s [ : l ] , ) [EOL] s = s [ l + [number] : ] [EOL] if f == [string] : [EOL] if offset == len ( fmt ) - [number] : [EOL] result += ( s , ) [EOL] else : [EOL] l = struct . unpack_from ( tfmt + [string] , s ) [ [number] ] [EOL] s = s [ struct . calcsize ( tfmt + [string] ) : ] [EOL] result += ( s [ : l ] , ) [EOL] s = s [ l : ] [EOL] pfmt = tfmt [EOL] sizebytes = [number] [EOL] [EOL] if len ( pfmt ) > [number] : [EOL] result += struct . unpack ( pfmt , s ) [EOL] return result [EOL] [EOL] def pack ( fmt , * values ) : [EOL] pfmt , fmt = __wt2struct ( fmt ) [EOL] if not fmt : [EOL] return [string] [EOL] i = sizebytes = [number] [EOL] for offset , f in enumerate ( fmt ) : [EOL] if f == [string] : [EOL] [comment] [EOL] if sizebytes == [number] : [EOL] l = values [ i ] . find ( [string] ) + [number] [EOL] if not l : [EOL] l = len ( values [ i ] ) + [number] [EOL] pfmt += str ( l ) [EOL] sizebytes = len ( str ( l ) ) [EOL] f = [string] [EOL] elif f == [string] : [EOL] if sizebytes == [number] and offset != len ( fmt ) - [number] : [EOL] l = len ( values [ i ] ) [EOL] pfmt += [string] + str ( l ) [EOL] values = values [ : i ] + ( l , ) + values [ i : ] [EOL] sizebytes = len ( str ( l ) ) [EOL] f = [string] [EOL] pfmt += f [EOL] if f . isdigit ( ) : [EOL] sizebytes += [number] [EOL] continue [EOL] if f != [string] and sizebytes > [number] : [EOL] i += int ( pfmt [ - sizebytes : ] ) [EOL] else : [EOL] i += [number] [EOL] sizebytes = [number] [EOL] return struct . pack ( pfmt , * values ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class LogRecordType : [EOL] def __init__ ( self , name , desc , fields ) : [EOL] self . name = name [EOL] self . desc = desc [EOL] self . fields = fields [EOL] [EOL] def macro_name ( self ) : [EOL] return [string] % self . name . upper ( ) [EOL] [EOL] def prname ( self ) : [EOL] return [string] + self . name [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] rectypes = [ LogRecordType ( [string] , [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) , LogRecordType ( [string] , [string] , [ ( [string] , [string] ) ] ) , LogRecordType ( [string] , [string] , [ ( [string] , [string] ) , ( [string] , [string] ) ] ) , LogRecordType ( [string] , [string] , [ ( [string] , [string] ) ] ) , LogRecordType ( [string] , [string] , [ ] ) , ] [EOL] [EOL] class LogOperationType : [EOL] def __init__ ( self , name , desc , fields ) : [EOL] self . name = name [EOL] self . desc = desc [EOL] self . fields = fields [EOL] [EOL] def macro_name ( self ) : [EOL] return [string] % self . name . upper ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] optypes = [ LogOperationType ( [string] , [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) , LogOperationType ( [string] , [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) , LogOperationType ( [string] , [string] , [ ( [string] , [string] ) , ( [string] , [string] ) ] ) , LogOperationType ( [string] , [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) , LogOperationType ( [string] , [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) , LogOperationType ( [string] , [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) , LogOperationType ( [string] , [string] , [ ( [string] , [string] ) , ( [string] , [string] ) ] ) , LogOperationType ( [string] , [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) , LogOperationType ( [string] , [string] , [ ] ) , LogOperationType ( [string] , [string] , [ ( [string] , [string] ) ] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Optional , Pattern , Match [EOL] import typing [EOL] import io [EOL] import os , re , sys [EOL] import api_data [EOL] from dist import compare_srcfile [EOL] [EOL] [comment] [EOL] tmp_file = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] f = [string] [EOL] o = [string] [EOL] tfile = open ( tmp_file , [string] ) [EOL] [EOL] tfile . write ( [string] ) [EOL] [EOL] cclass_re = re . compile ( [string] ) [EOL] cfunc_re = re . compile ( [string] ) [EOL] [EOL] curr_class = [string] [EOL] for line in open ( f , [string] ) : [EOL] [EOL] m = cclass_re . match ( line ) [EOL] if m : [EOL] curr_class = m . group ( [number] ) [EOL] [EOL] if curr_class == [string] : [EOL] continue [EOL] [EOL] m = cfunc_re . match ( line ) [EOL] if m : [EOL] tfile . write ( [string] + curr_class . lower ( ) + [string] + curr_class . upper ( ) + [string] + m . group ( [number] ) + [string] ) [EOL] [EOL] tfile . close ( ) [EOL] compare_srcfile ( tmp_file , o ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import io [EOL] import re , sys [EOL] from dist import all_c_files , all_h_files , compare_srcfile [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def flag_declare ( name ) : [EOL] tmp_file = [string] [EOL] with open ( name , [string] ) as f : [EOL] tfile = open ( tmp_file , [string] ) [EOL] [EOL] lcnt = [number] [EOL] parsing = False [EOL] for line in f : [EOL] lcnt = lcnt + [number] [EOL] if line . find ( [string] ) != - [number] : [EOL] header = line [EOL] defines = [ ] [EOL] parsing = True [EOL] elif line . find ( [string] ) != - [number] : [EOL] [comment] [EOL] if len ( defines ) > [number] : [EOL] print >> sys . stderr , name + [string] + str ( lcnt ) + [string] [EOL] sys . exit ( [number] ) [EOL] [EOL] [comment] [EOL] fmt = [string] % ( ( len ( defines ) + [number] ) / [number] ) [EOL] [EOL] tfile . write ( header ) [EOL] v = [number] [EOL] for d in sorted ( defines ) : [EOL] tfile . write ( re . sub ( [string] , fmt % v , d ) ) [EOL] v = v * [number] [EOL] tfile . write ( line ) [EOL] [EOL] parsing = False [EOL] elif parsing and line . find ( [string] ) == - [number] : [EOL] print >> sys . stderr , name + [string] + str ( lcnt ) + [string] [EOL] sys . exit ( [number] ) [EOL] elif parsing : [EOL] defines . append ( line ) [EOL] else : [EOL] tfile . write ( line ) [EOL] [EOL] tfile . close ( ) [EOL] compare_srcfile ( tmp_file , name ) [EOL] [EOL] [comment] [EOL] for name in all_h_files ( ) : [EOL] flag_declare ( name ) [EOL] for name in all_c_files ( ) : [EOL] flag_declare ( name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , List , Optional , Literal , Any [EOL] import typing [EOL] import typing_extensions [EOL] import wiredtiger , wttest , suite_random [EOL] from wtscenario import make_scenarios [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class test_join02 ( wttest . WiredTigerTestCase ) : [EOL] table_name1 = [string] [EOL] nentries = [number] [EOL] [EOL] keyscen = [ ( [string] , dict ( keyformat = [string] ) ) , ( [string] , dict ( keyformat = [string] ) ) , ( [string] , dict ( keyformat = [string] ) ) , ( [string] , dict ( keyformat = [string] ) ) ] [EOL] [EOL] bloomscen = [ ( [string] , dict ( usebloom = True ) ) , ( [string] , dict ( usebloom = False ) ) ] [EOL] [EOL] scenarios = make_scenarios ( keyscen , bloomscen ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def range ( self ) : [EOL] return range ( [number] , self . nentries + [number] ) [EOL] [EOL] def gen_key ( self , i ) : [EOL] if self . keyformat == [string] : [EOL] return [ [string] % i ] [comment] [EOL] elif self . keyformat == [string] : [EOL] return [ i , [string] % i ] [EOL] else : [EOL] return [ i ] [EOL] [EOL] def gen_values ( self , i ) : [EOL] s = str ( i ) [EOL] x = [string] * i [EOL] rs = s [ : : - [number] ] [EOL] f = int ( s [ [number] : [number] ] ) [EOL] return [ i , s , x , rs , f ] [EOL] [EOL] def reinit_joinconfig ( self ) : [EOL] self . rand = suite_random . suite_random ( self . seed ) [EOL] self . seed += [number] [EOL] [EOL] def get_joinconfig ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . usebloom : [EOL] c = [number] if ( self . rand . rand32 ( ) % [number] ) != [number] else [number] [EOL] k = [number] if ( self . rand . rand32 ( ) % [number] ) != [number] else [number] [EOL] b = [number] if ( self . rand . rand32 ( ) % [number] ) != [number] else [number] [EOL] return [string] + str ( c ) + [string] + str ( b ) + [string] + str ( k ) [EOL] else : [EOL] return [string] [EOL] [EOL] def do_join ( self , jc , curleft , curright , choice , mbr ) : [EOL] c0 = choice [ [number] ] [EOL] if c0 == None : [EOL] return mbr [EOL] [comment] [EOL] if jc . first_join : [EOL] joinconfig = [string] [EOL] jc . first_join = False [EOL] else : [EOL] joinconfig = self . get_joinconfig ( ) [EOL] if c0 != None : [EOL] [comment] [EOL] [comment] [EOL] curleft . reset ( ) [EOL] curleft . set_key ( * curleft . low ) [EOL] self . assertEquals ( [number] , curleft . search ( ) ) [EOL] self . session . join ( jc , curleft , [string] + c0 + joinconfig ) [EOL] if c0 == [string] : [EOL] mbr = mbr . intersection ( curleft . eqmembers ) [EOL] elif c0 == [string] : [EOL] mbr = mbr . intersection ( set ( curleft . eqmembers . union ( curleft . gtmembers ) ) ) [EOL] elif c0 == [string] : [EOL] mbr = mbr . intersection ( curleft . gtmembers ) [EOL] c1 = choice [ [number] ] if len ( choice ) > [number] else None [EOL] if c1 != None : [EOL] [comment] [EOL] [comment] [EOL] curright . reset ( ) [EOL] curright . set_key ( * curright . high ) [EOL] self . assertEquals ( [number] , curright . search ( ) ) [EOL] self . session . join ( jc , curright , [string] + c1 + joinconfig ) [EOL] if c1 == [string] : [EOL] mbr = mbr . intersection ( set ( curright . eqmembers . union ( curright . ltmembers ) ) ) [EOL] elif c1 == [string] : [EOL] mbr = mbr . intersection ( curright . ltmembers ) [EOL] return mbr [EOL] [EOL] def iterate ( self , jc , mbr ) : [EOL] [comment] [EOL] [comment] [EOL] while jc . next ( ) == [number] : [EOL] keys = jc . get_keys ( ) [EOL] [ v0 , v1 , v2 , v3 , v4 ] = jc . get_values ( ) [EOL] k0 = keys [ [number] ] [EOL] k1 = keys [ [number] ] if len ( keys ) > [number] else None [EOL] if self . keyformat == [string] : [EOL] i = int ( str ( k0 [ [number] : ] ) ) [EOL] elif self . keyformat == [string] : [EOL] i = k0 [EOL] self . assertEquals ( i , int ( str ( k1 [ [number] : ] ) ) ) [EOL] else : [EOL] i = k0 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertEquals ( self . gen_values ( i ) , [ v0 , v1 , v2 , v3 , v4 ] ) [EOL] if not i in mbr : [EOL] self . tty ( [string] + str ( i ) + [string] + str ( mbr ) ) [EOL] self . assertTrue ( i in mbr ) [EOL] mbr . remove ( i ) [EOL] self . assertEquals ( [number] , len ( mbr ) ) [EOL] [EOL] def mkmbr ( self , expr ) : [EOL] return frozenset ( [ x for x in self . range ( ) if expr ( x ) ] ) [EOL] [EOL] def test_basic_join ( self ) : [EOL] self . seed = [number] [EOL] if self . keyformat == [string] : [EOL] keycols = [string] [EOL] else : [EOL] keycols = [string] [EOL] self . session . create ( [string] , [string] + self . keyformat + [string] + keycols + [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] c = self . session . open_cursor ( [string] , None , None ) [EOL] for i in self . range ( ) : [EOL] c . set_key ( * self . gen_key ( i ) ) [EOL] c . set_value ( * self . gen_values ( i ) ) [EOL] c . insert ( ) [EOL] c . close ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] c0a = self . session . open_cursor ( [string] , None , None ) [EOL] c0b = self . session . open_cursor ( [string] , None , None ) [EOL] c1a = self . session . open_cursor ( [string] , None , None ) [EOL] c1b = self . session . open_cursor ( [string] , None , None ) [EOL] c2a = self . session . open_cursor ( [string] , None , None ) [EOL] c2b = self . session . open_cursor ( [string] , None , None ) [EOL] c3a = self . session . open_cursor ( [string] , None , None ) [EOL] c3b = self . session . open_cursor ( [string] , None , None ) [EOL] c4a = self . session . open_cursor ( [string] , None , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] c0a . name = [string] [EOL] c0b . name = [string] [EOL] if self . keyformat == [string] or self . keyformat == [string] : [EOL] c0a . low = [ [number] ] [EOL] c0b . high = [ [number] ] [EOL] elif self . keyformat == [string] : [EOL] c0a . low = [ [string] ] [EOL] c0b . high = [ [string] ] [EOL] elif self . keyformat == [string] : [EOL] c0a . low = [ [number] , [string] ] [EOL] c0b . high = [ [number] , [string] ] [EOL] c0a . gtmembers = self . mkmbr ( lambda x : x > [number] ) [EOL] c0a . eqmembers = self . mkmbr ( lambda x : x == [number] ) [EOL] c0b . ltmembers = self . mkmbr ( lambda x : x < [number] ) [EOL] c0b . eqmembers = self . mkmbr ( lambda x : x == [number] ) [EOL] [EOL] c1a . low = [ [string] ] [EOL] c1a . gtmembers = self . mkmbr ( lambda x : str ( x ) > [string] ) [EOL] c1a . eqmembers = self . mkmbr ( lambda x : str ( x ) == [string] ) [EOL] c1a . name = [string] [EOL] c1b . high = [ [string] ] [EOL] c1b . ltmembers = self . mkmbr ( lambda x : str ( x ) < [string] ) [EOL] c1b . eqmembers = self . mkmbr ( lambda x : str ( x ) == [string] ) [EOL] c1b . name = [string] [EOL] [EOL] c2a . low = [ [string] * [number] ] [EOL] c2a . gtmembers = self . mkmbr ( lambda x : x > [number] ) [EOL] c2a . eqmembers = self . mkmbr ( lambda x : x == [number] ) [EOL] c2a . name = [string] [EOL] c2b . high = [ [string] * [number] ] [EOL] c2b . ltmembers = self . mkmbr ( lambda x : x < [number] ) [EOL] c2b . eqmembers = self . mkmbr ( lambda x : x == [number] ) [EOL] c2b . name = [string] [EOL] [EOL] c3a . low = [ [string] ] [EOL] c3a . gtmembers = self . mkmbr ( lambda x : str ( x ) [ : : - [number] ] > [string] ) [EOL] c3a . eqmembers = self . mkmbr ( lambda x : str ( x ) [ : : - [number] ] == [string] ) [EOL] c3a . name = [string] [EOL] c3b . high = [ [string] ] [EOL] c3b . ltmembers = self . mkmbr ( lambda x : str ( x ) [ : : - [number] ] < [string] ) [EOL] c3b . eqmembers = self . mkmbr ( lambda x : str ( x ) [ : : - [number] ] == [string] ) [EOL] c3b . name = [string] [EOL] [EOL] c4a . low = [ [number] ] [EOL] c4a . gtmembers = self . mkmbr ( lambda x : str ( x ) [ [number] : [number] ] > [string] ) [EOL] c4a . eqmembers = self . mkmbr ( lambda x : str ( x ) [ [number] : [number] ] == [string] ) [EOL] c4a . name = [string] [EOL] [EOL] choices = [ [ None ] , [ [string] ] , [ [string] ] , [ [string] ] , [ None , [string] ] , [ None , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] [EOL] smallchoices = [ [ None ] , [ [string] ] , [ [string] ] , [ [string] , [string] ] ] [EOL] for i0 in smallchoices : [EOL] for i1 in choices : [EOL] for i2 in smallchoices : [EOL] for i3 in smallchoices : [EOL] for i4 in [ [ None ] , [ [string] ] , [ [string] ] , [ [string] ] ] : [EOL] if i0 [ [number] ] == None and i1 [ [number] ] == None and i2 [ [number] ] == None and i3 [ [number] ] == None and i4 [ [number] ] == None : [EOL] continue [EOL] self . reinit_joinconfig ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] jc = self . session . open_cursor ( [string] , None , None ) [EOL] jc . first_join = True [EOL] mbr = set ( self . range ( ) ) [EOL] [EOL] [comment] [EOL] mbr = self . do_join ( jc , c3a , c3b , i3 , mbr ) [EOL] mbr = self . do_join ( jc , c2a , c2b , i2 , mbr ) [EOL] mbr = self . do_join ( jc , c4a , None , i4 , mbr ) [EOL] mbr = self . do_join ( jc , c1a , c1b , i1 , mbr ) [EOL] mbr = self . do_join ( jc , c0a , c0b , i0 , mbr ) [EOL] self . iterate ( jc , mbr ) [EOL] jc . close ( ) [EOL] c0a . close ( ) [EOL] c0b . close ( ) [EOL] c1a . close ( ) [EOL] c1b . close ( ) [EOL] c2a . close ( ) [EOL] c2b . close ( ) [EOL] c3a . close ( ) [EOL] c3b . close ( ) [EOL] c4a . close ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[None],typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[None],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[None],typing.List[builtins.str]]]$ 0 0 0 0 0 $typing.List[typing.Union[typing.List[None],typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 $typing.List[typing.Union[typing.List[None],typing.List[builtins.str]]]$ 0 0 0 0 0 $typing.List[typing.Union[typing.List[None],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] [EOL] def timestamp_str ( t ) : [EOL] return [string] % t [EOL] [EOL] class test_txn17 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] def test_txn_api ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if wiredtiger . timestamp_build ( ) : [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . timestamp_transaction ( [string] + timestamp_str ( [number] << [number] ) ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . commit_transaction ( ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . rollback_transaction ( ) , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . session . begin_transaction ( ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . begin_transaction ( ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . checkpoint ( ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . transaction_sync ( ) , [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Set [EOL] import typing [EOL] import fnmatch , os , shutil , time [EOL] from suite_subprocess import suite_subprocess [EOL] import wttest [EOL] [EOL] class test_txn16 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] t1 = [string] [EOL] t2 = [string] [EOL] t3 = [string] [EOL] nentries = [number] [EOL] create_params = [string] [EOL] [comment] [EOL] [comment] [EOL] conn_config = [string] + [string] + [string] [EOL] conn_on = [string] + [string] + [string] [EOL] conn_off = [string] [EOL] [EOL] def populate_table ( self , uri ) : [EOL] self . session . create ( uri , self . create_params ) [EOL] c = self . session . open_cursor ( uri , None , None ) [EOL] [comment] [EOL] [comment] [EOL] for i in range ( self . nentries ) : [EOL] c [ i ] = i + [number] [EOL] if i % [number] == [number] : [EOL] self . session . checkpoint ( ) [EOL] c . close ( ) [EOL] [EOL] def copy_dir ( self , olddir , newdir ) : [EOL] [docstring] [EOL] [comment] [EOL] shutil . rmtree ( newdir , ignore_errors = True ) [EOL] os . mkdir ( newdir ) [EOL] for fname in os . listdir ( olddir ) : [EOL] fullname = os . path . join ( olddir , fname ) [EOL] [comment] [EOL] if os . path . isfile ( fullname ) and [string] not in fullname and [string] not in fullname and [string] not in fullname : [EOL] shutil . copy ( fullname , newdir ) [EOL] [comment] [EOL] self . close_conn ( ) [EOL] [EOL] def run_toggle ( self , homedir ) : [EOL] loop = [number] [EOL] [comment] [EOL] [comment] [EOL] orig_logs = fnmatch . filter ( os . listdir ( homedir ) , [string] ) [EOL] while loop < [number] : [EOL] [comment] [EOL] on_conn = self . wiredtiger_open ( homedir , self . conn_on ) [EOL] on_conn . close ( ) [EOL] if loop > [number] : [EOL] [comment] [EOL] cur_logs = fnmatch . filter ( os . listdir ( homedir ) , [string] ) [EOL] scur = set ( cur_logs ) [EOL] sorig = set ( orig_logs ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( scur . isdisjoint ( sorig ) , True ) [EOL] if loop > [number] : [EOL] [comment] [EOL] for l in cur_logs : [EOL] self . assertEqual ( l in last_logs , True ) [EOL] for l in last_logs : [EOL] self . assertEqual ( l in cur_logs , True ) [EOL] last_logs = cur_logs [EOL] loop += [number] [EOL] [comment] [EOL] cur_logs = fnmatch . filter ( os . listdir ( homedir ) , [string] ) [EOL] for l in cur_logs : [EOL] path = homedir + [string] + l [EOL] os . remove ( path ) [EOL] off_conn = self . wiredtiger_open ( homedir , self . conn_off ) [EOL] off_conn . close ( ) [EOL] [EOL] def test_recovery ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . populate_table ( self . t1 ) [EOL] self . populate_table ( self . t2 ) [EOL] self . populate_table ( self . t3 ) [EOL] self . copy_dir ( [string] , [string] ) [EOL] self . run_toggle ( [string] ) [EOL] self . run_toggle ( [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import fnmatch , os [EOL] import wiredtiger , wttest [EOL] from suite_subprocess import suite_subprocess [EOL] from wtdataset import SimpleDataSet , simple_key [EOL] from wtscenario import make_scenarios [EOL] [EOL] class test_compat03 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] [comment] [EOL] [comment] [EOL] entries = [number] [EOL] logmax = [string] [EOL] tablename = [string] [EOL] uri = [string] + tablename [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] min_logv = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] future_logv = [number] [EOL] future_rel = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] compat_release = [ ( [string] , dict ( rel = [string] , log_rel = [number] ) ) , ( [string] , dict ( rel = future_rel , log_rel = future_logv ) ) , ( [string] , dict ( rel = [string] , log_rel = [number] ) ) , ( [string] , dict ( rel = [string] , log_rel = [number] ) ) , ( [string] , dict ( rel = [string] , log_rel = [number] ) ) , ( [string] , dict ( rel = [string] , log_rel = [number] ) ) , ] [EOL] compat_max = [ ( [string] , dict ( max_req = [string] , log_max = [number] ) ) , ( [string] , dict ( max_req = future_rel , log_max = future_logv ) ) , ( [string] , dict ( max_req = [string] , log_max = [number] ) ) , ( [string] , dict ( max_req = [string] , log_max = [number] ) ) , ( [string] , dict ( max_req = [string] , log_max = [number] ) ) , ( [string] , dict ( max_req = [string] , log_max = [number] ) ) , ] [EOL] compat_min = [ ( [string] , dict ( min_req = [string] , log_min = [number] ) ) , ( [string] , dict ( min_req = future_rel , log_min = future_logv ) ) , ( [string] , dict ( min_req = [string] , log_min = [number] ) ) , ( [string] , dict ( min_req = [string] , log_min = [number] ) ) , ( [string] , dict ( min_req = [string] , log_min = [number] ) ) , ( [string] , dict ( min_req = [string] , log_min = [number] ) ) , ] [EOL] base_config = [ ( [string] , dict ( basecfg = [string] ) ) , ( [string] , dict ( basecfg = [string] ) ) , ] [EOL] scenarios = make_scenarios ( compat_release , compat_max , compat_min , base_config ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_compat03 ( self ) : [EOL] testdir = [string] [EOL] os . mkdir ( testdir ) [EOL] config_str = [string] % self . basecfg [EOL] log_str = [string] % self . logmax [EOL] compat_str = [string] [EOL] if ( self . rel != [string] ) : [EOL] compat_str += [string] % self . rel [EOL] if ( self . max_req != [string] ) : [EOL] compat_str += [string] % self . max_req [EOL] if ( self . min_req != [string] ) : [EOL] compat_str += [string] % self . min_req [EOL] config_str += log_str + compat_str [EOL] self . pr ( [string] + config_str ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( ( self . log_min >= self . future_logv ) or ( self . log_max >= self . future_logv ) or ( self . log_rel >= self . future_logv ) or ( self . max_req != [string] and self . log_max < self . log_rel ) or ( self . min_req != [string] and self . log_min > self . log_rel ) or ( self . max_req != [string] and self . min_req != [string] and self . log_max < self . log_min ) ) : [EOL] expect_err = True [EOL] else : [EOL] expect_err = False [EOL] [EOL] if ( expect_err == True ) : [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . wiredtiger_open ( testdir , config_str ) , msg ) [EOL] else : [EOL] self . pr ( [string] ) [EOL] conn = self . wiredtiger_open ( testdir , config_str ) [EOL] conn . close ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import wiredtiger , wttest [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_bug017 ( wttest . WiredTigerTestCase ) : [EOL] [EOL] def test_bug017_run ( self ) : [EOL] self . session . create ( [string] , [string] + [string] ) [EOL] [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . open_cursor ( [string] , None ) , msg ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from helper import copy_wiredtiger_home [EOL] import wiredtiger , wttest [EOL] from wiredtiger import stat [EOL] from wtdataset import SimpleDataSet [EOL] [EOL] def timestamp_str ( t ) : [EOL] return [string] % t [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_las03 ( wttest . WiredTigerTestCase ) : [EOL] [comment] [EOL] def conn_config ( self ) : [EOL] return [string] [EOL] [EOL] def get_stat ( self , stat ) : [EOL] stat_cursor = self . session . open_cursor ( [string] ) [EOL] val = stat_cursor [ stat ] [ [number] ] [EOL] stat_cursor . close ( ) [EOL] return val [EOL] [EOL] def large_updates ( self , session , uri , value , ds , nrows , nops ) : [EOL] [comment] [EOL] [comment] [EOL] cursor = session . open_cursor ( uri ) [EOL] for i in range ( nrows + [number] , nrows + nops + [number] ) : [EOL] session . begin_transaction ( ) [EOL] cursor [ ds . key ( i ) ] = value [EOL] session . commit_transaction ( [string] + timestamp_str ( i ) ) [EOL] cursor . close ( ) [EOL] [EOL] def test_checkpoint_las_reads ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] [comment] [EOL] uri = [string] [EOL] nrows = [number] [EOL] ds = SimpleDataSet ( self , uri , nrows , key_format = [string] , value_format = [string] ) [EOL] ds . populate ( ) [EOL] bigvalue = [string] * [number] [EOL] [EOL] [comment] [EOL] cursor = self . session . open_cursor ( uri ) [EOL] for i in range ( [number] , [number] ) : [EOL] cursor [ ds . key ( nrows + i ) ] = bigvalue [EOL] cursor . close ( ) [EOL] self . session . checkpoint ( ) [EOL] [EOL] [comment] [EOL] bigvalue2 = [string] * [number] [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] las_writes_start = self . get_stat ( stat . conn . cache_write_lookaside ) [EOL] self . large_updates ( self . session , uri , bigvalue2 , ds , nrows , [number] ) [EOL] [EOL] [comment] [EOL] self . session . checkpoint ( ) [EOL] las_writes = self . get_stat ( stat . conn . cache_write_lookaside ) - las_writes_start [EOL] self . assertGreaterEqual ( las_writes , [number] ) [EOL] [EOL] for ts in range ( [number] , [number] ) : [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( ts ) ) [EOL] [EOL] [comment] [EOL] self . large_updates ( self . session , uri , bigvalue2 , ds , nrows , [number] ) [EOL] [EOL] las_reads_start = self . get_stat ( stat . conn . cache_read_lookaside ) [EOL] self . session . checkpoint ( ) [EOL] las_reads = self . get_stat ( stat . conn . cache_read_lookaside ) - las_reads_start [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertLessEqual ( las_reads , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Iterable , Any , Callable [EOL] import typing [EOL] import fnmatch , os , shutil , time [EOL] from suite_subprocess import suite_subprocess [EOL] from wtscenario import make_scenarios [EOL] import wttest [EOL] [EOL] class test_txn14 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] t1 = [string] [EOL] create_params = [string] [EOL] entries = [number] [EOL] extra_entries = [number] [EOL] conn_config = [string] [EOL] [EOL] sync_list = [ ( [string] , dict ( sync = [string] ) ) , ( [string] , dict ( sync = [string] ) ) , ( [string] , dict ( sync = [string] ) ) , ] [EOL] scenarios = make_scenarios ( sync_list ) [EOL] [EOL] def simulate_crash_restart ( self , olddir , newdir ) : [EOL] [docstring] [EOL] [comment] [EOL] shutil . rmtree ( newdir , ignore_errors = True ) [EOL] os . mkdir ( newdir ) [EOL] for fname in os . listdir ( olddir ) : [EOL] fullname = os . path . join ( olddir , fname ) [EOL] [comment] [EOL] if os . path . isfile ( fullname ) and [string] not in fullname and [string] not in fullname and [string] not in fullname : [EOL] shutil . copy ( fullname , newdir ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . close_conn ( ) [EOL] self . conn = self . setUpConnectionOpen ( newdir ) [EOL] self . session = self . setUpSessionOpen ( self . conn ) [EOL] [EOL] def test_log_flush ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . create ( self . t1 , self . create_params ) [EOL] c = self . session . open_cursor ( self . t1 , None , None ) [EOL] for i in range ( self . entries ) : [EOL] c [ i ] = i + [number] [EOL] cfgarg = [string] % self . sync [EOL] self . pr ( [string] + cfgarg ) [EOL] self . session . log_flush ( cfgarg ) [EOL] for i in range ( self . extra_entries ) : [EOL] c [ i + self . entries ] = i + self . entries + [number] [EOL] c . close ( ) [EOL] self . session . log_flush ( cfgarg ) [EOL] if self . sync == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . transaction_sync ( [string] ) [EOL] self . simulate_crash_restart ( [string] , [string] ) [EOL] c = self . session . open_cursor ( self . t1 , None , None ) [EOL] i = [number] [EOL] for key , value in c : [EOL] self . assertEqual ( i , key ) [EOL] self . assertEqual ( i + [number] , value ) [EOL] i += [number] [EOL] all = self . entries + self . extra_entries [EOL] self . assertEqual ( i , all ) [EOL] c . close ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] [EOL] def timestamp_str ( t ) : [EOL] return [string] % t [EOL] [EOL] class test_prepare02 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] def test_prepare_session_operations ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] self . session . create ( [string] , [string] ) [EOL] cursor = self . session . open_cursor ( [string] , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . session . begin_transaction ( ) [EOL] self . session . prepare_transaction ( [string] ) [EOL] msg = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . reconfigure ( ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . open_cursor ( [string] , None ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . alter ( [string] , [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . create ( [string] , [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . compact ( [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . drop ( [string] , None ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( cursor , cursor , [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . log_flush ( [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . log_printf ( [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . rebalance ( [string] , None ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . rename ( [string] , [string] , None ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . reset ( ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . salvage ( [string] , None ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . truncate ( [string] , None , None , None ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . upgrade ( [string] , None ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . verify ( [string] , None ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . begin_transaction ( ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . prepare_transaction ( [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . timestamp_transaction ( [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . checkpoint ( ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . snapshot ( [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . transaction_sync ( ) , msg ) [EOL] self . session . rollback_transaction ( ) [EOL] [EOL] [comment] [EOL] self . session . begin_transaction ( ) [EOL] c1 = self . session . open_cursor ( [string] , None ) [EOL] self . session . prepare_transaction ( [string] ) [EOL] self . session . commit_transaction ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . session . begin_transaction ( ) [EOL] c1 = self . session . open_cursor ( [string] , None ) [EOL] self . session . prepare_transaction ( [string] ) [EOL] self . session . timestamp_transaction ( [string] ) [EOL] self . session . commit_transaction ( ) [EOL] [EOL] [comment] [EOL] self . session . begin_transaction ( ) [EOL] self . session . prepare_transaction ( [string] ) [EOL] self . session . rollback_transaction ( ) [EOL] [EOL] [comment] [EOL] self . session . begin_transaction ( ) [EOL] self . session . prepare_transaction ( [string] ) [EOL] self . session . close ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Set [EOL] import typing [EOL] import fnmatch , os , time [EOL] from suite_subprocess import suite_subprocess [EOL] from wtdataset import SimpleDataSet [EOL] import wttest [EOL] [EOL] class test_txn11 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] archive = [string] [EOL] conn_config = [string] [EOL] logmax = [string] [EOL] nrows = [number] [EOL] tablename = [string] [EOL] source_uri = [string] + tablename + [string] [EOL] uri = [string] + tablename [EOL] [EOL] [comment] [EOL] def conn_config ( self ) : [EOL] return [string] % self . archive + [string] % self . logmax + [string] [EOL] [EOL] def run_checkpoints ( self ) : [EOL] orig_logs = fnmatch . filter ( os . listdir ( self . home ) , [string] ) [EOL] checkpoints = [number] [EOL] sorig = set ( orig_logs ) [EOL] while checkpoints < [number] : [EOL] self . session . checkpoint ( ) [EOL] cur_logs = fnmatch . filter ( os . listdir ( self . home ) , [string] ) [EOL] scur = set ( cur_logs ) [EOL] if scur . isdisjoint ( sorig ) : [EOL] break [EOL] checkpoints += [number] [EOL] return [EOL] [EOL] def test_ops ( self ) : [EOL] [comment] [EOL] SimpleDataSet ( self , self . source_uri , self . nrows ) . populate ( ) [EOL] [EOL] [comment] [EOL] self . run_checkpoints ( ) [EOL] [EOL] self . archive = [string] [EOL] [comment] [EOL] self . reopen_conn ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import glob [EOL] import os . path [EOL] import time [EOL] import helper , wiredtiger , wttest [EOL] from wiredtiger import stat [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_stat_log01 ( wttest . WiredTigerTestCase ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] def setUpConnectionOpen ( self , dir ) : [EOL] return None [EOL] [EOL] def setUpSessionOpen ( self , conn ) : [EOL] return None [EOL] [EOL] def test_stats_log_default ( self ) : [EOL] self . conn = self . wiredtiger_open ( None , [string] ) [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] self . check_stats_file ( [string] ) [EOL] [EOL] def test_stats_log_name ( self ) : [EOL] os . mkdir ( [string] ) [EOL] self . conn = self . wiredtiger_open ( None , [string] ) [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] self . check_stats_file ( [string] ) [EOL] [EOL] def test_stats_log_on_close_and_log ( self ) : [EOL] self . conn = self . wiredtiger_open ( None , [string] ) [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] self . close_conn ( ) [EOL] self . check_stats_file ( [string] ) [EOL] [EOL] def test_stats_log_on_close ( self ) : [EOL] self . conn = self . wiredtiger_open ( None , [string] ) [EOL] [comment] [EOL] self . close_conn ( ) [EOL] self . check_stats_file ( [string] ) [EOL] [EOL] def check_stats_file ( self , dir ) : [EOL] files = glob . glob ( dir + [string] + [string] ) [EOL] self . assertTrue ( files ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from suite_subprocess import suite_subprocess [EOL] from wtdataset import SimpleDataSet [EOL] import wiredtiger , wttest [EOL] [EOL] class test_txn06 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] conn_config = [string] [EOL] tablename = [string] [EOL] uri = [string] + tablename [EOL] source_uri = [string] + tablename + [string] [EOL] nrows = [number] [EOL] [EOL] def test_long_running ( self ) : [EOL] [comment] [EOL] SimpleDataSet ( self , self . source_uri , self . nrows ) . populate ( ) [EOL] [EOL] [comment] [EOL] c_src = self . session . create ( self . uri , [string] ) [EOL] c_src = self . session . open_cursor ( self . source_uri ) [EOL] c = self . session . open_cursor ( self . uri ) [EOL] for k , v in c_src : [EOL] c [ k ] = v [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import threading [EOL] import sys , threading , wiredtiger , wttest [EOL] from suite_subprocess import suite_subprocess [EOL] from wiredtiger import WiredTigerError [EOL] from wtscenario import make_scenarios [EOL] [EOL] class Callback ( wiredtiger . AsyncCallback ) : [EOL] def __init__ ( self , current ) : [EOL] self . current = current [EOL] self . ncompact = [number] [EOL] self . ninsert = [number] [EOL] self . nremove = [number] [EOL] self . nsearch = [number] [EOL] self . nupdate = [number] [EOL] self . nerror = [number] [EOL] self . lock = threading . RLock ( ) [EOL] [EOL] def notify_error ( self , key , value , optype , exp , desc ) : [EOL] self . tty ( [string] + str ( key ) + [string] + str ( value ) + [string] + str ( optype ) + [string] + [string] + str ( exp ) + [string] + desc ) [EOL] [EOL] def notify ( self , op , op_ret , flags ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] optype = op . get_type ( ) [EOL] if optype != wiredtiger . WT_AOP_COMPACT : [EOL] key = op . get_key ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if op_ret != [number] : [EOL] value = op_ret [EOL] elif optype != wiredtiger . WT_AOP_REMOVE : [EOL] value = op . get_value ( ) [EOL] else : [EOL] value = self . current [ key ] [EOL] [EOL] if optype == wiredtiger . WT_AOP_INSERT : [EOL] self . lock . acquire ( ) [EOL] self . ninsert += [number] [EOL] self . lock . release ( ) [EOL] elif optype == wiredtiger . WT_AOP_COMPACT : [EOL] self . lock . acquire ( ) [EOL] self . ncompact += [number] [EOL] self . lock . release ( ) [EOL] [comment] [EOL] return [number] [EOL] elif optype == wiredtiger . WT_AOP_REMOVE : [EOL] self . lock . acquire ( ) [EOL] self . nremove += [number] [EOL] self . lock . release ( ) [EOL] elif optype == wiredtiger . WT_AOP_SEARCH : [EOL] self . lock . acquire ( ) [EOL] self . nsearch += [number] [EOL] self . lock . release ( ) [EOL] elif optype == wiredtiger . WT_AOP_UPDATE : [EOL] self . lock . acquire ( ) [EOL] self . nupdate += [number] [EOL] self . lock . release ( ) [EOL] else : [EOL] self . notify_error ( key , value , optype , [number] , [string] ) [EOL] self . lock . acquire ( ) [EOL] self . nerror += [number] [EOL] self . lock . release ( ) [EOL] if self . current [ key ] != value : [EOL] self . notify_error ( key , value , optype , self . current [ key ] , [string] ) [EOL] self . lock . acquire ( ) [EOL] self . nerror += [number] [EOL] self . lock . release ( ) [EOL] except (BaseException) as err : [EOL] self . tty ( [string] + str ( err ) ) [EOL] raise [EOL] [EOL] return [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class test_async02 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] [docstring] [EOL] table_name1 = [string] [EOL] nentries = [number] [EOL] async_ops = nentries / [number] [EOL] async_threads = [number] [EOL] current = { } [EOL] [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( tablekind = [string] , uri = [string] ) ) , ( [string] , dict ( tablekind = [string] , uri = [string] ) ) , ( [string] , dict ( tablekind = [string] , uri = [string] ) ) , ( [string] , dict ( tablekind = [string] , uri = [string] ) ) , ( [string] , dict ( tablekind = [string] , uri = [string] ) ) , ( [string] , dict ( tablekind = [string] , uri = [string] ) ) , ( [string] , dict ( tablekind = [string] , uri = [string] ) ) , ] ) [EOL] [EOL] [comment] [EOL] def conn_config ( self ) : [EOL] return [string] % self . async_ops + [string] % self . async_threads [EOL] [EOL] def genkey ( self , i ) : [EOL] if self . tablekind == [string] : [EOL] return [string] + str ( i ) [EOL] else : [EOL] return long ( i + [number] ) [EOL] [EOL] def genvalue ( self , i ) : [EOL] if self . tablekind == [string] : [EOL] return int ( i & [number] ) [EOL] else : [EOL] return [string] + str ( i ) [EOL] [EOL] [comment] [EOL] def create_session ( self , tablearg ) : [EOL] if self . tablekind == [string] : [EOL] keyformat = [string] [EOL] else : [EOL] keyformat = [string] [comment] [EOL] if self . tablekind == [string] : [EOL] valformat = [string] [EOL] else : [EOL] valformat = [string] [EOL] create_args = keyformat + [string] + valformat [EOL] [EOL] self . pr ( [string] + create_args ) [EOL] self . session . create ( tablearg , create_args ) [EOL] [EOL] def test_ops ( self ) : [EOL] tablearg = self . uri + [string] + self . table_name1 [EOL] self . create_session ( tablearg ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . current = { } [EOL] for i in range ( [number] , self . nentries ) : [EOL] k = self . genkey ( i ) [EOL] v = self . genvalue ( i ) [EOL] self . current [ k ] = v [EOL] [EOL] [comment] [EOL] [comment] [EOL] callback = Callback ( self . current ) [EOL] for i in range ( [number] , self . nentries ) : [EOL] self . pr ( [string] ) [EOL] op = self . conn . async_new_op ( tablearg , None , callback ) [EOL] k = self . genkey ( i ) [EOL] v = self . genvalue ( i ) [EOL] op . set_key ( k ) [EOL] op . set_value ( v ) [EOL] op . insert ( ) [EOL] [EOL] self . conn . async_flush ( ) [EOL] self . pr ( [string] ) [EOL] [EOL] k = self . genkey ( self . nentries / [number] ) [EOL] v = self . genvalue ( self . nentries / [number] ) [EOL] k1 = self . genkey ( self . nentries + [number] ) [EOL] v1 = self . genvalue ( self . nentries + [number] ) [EOL] self . current [ k ] = wiredtiger . WT_DUPLICATE_KEY [EOL] self . current [ k1 ] = wiredtiger . WT_NOTFOUND [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] op = self . conn . async_new_op ( tablearg , [string] , callback ) [EOL] op . set_key ( k ) [EOL] op . set_value ( v ) [EOL] op . insert ( ) [EOL] op = self . conn . async_new_op ( tablearg , [string] , callback ) [EOL] op . set_key ( k1 ) [EOL] op . set_value ( v1 ) [EOL] op . update ( ) [EOL] op = self . conn . async_new_op ( tablearg , [string] , callback ) [EOL] op . set_key ( k1 ) [EOL] op . remove ( ) [EOL] [EOL] [comment] [EOL] self . conn . async_flush ( ) [EOL] self . pr ( [string] ) [EOL] [EOL] [comment] [EOL] self . assertTrue ( callback . nerror == [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $threading._RLock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import wiredtiger , wttest [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_version ( wttest . WiredTigerTestCase ) : [EOL] [EOL] [comment] [EOL] def test_version ( self ) : [EOL] version = wiredtiger . wiredtiger_version ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import fnmatch , os , shutil , time [EOL] from suite_subprocess import suite_subprocess [EOL] import wttest [EOL] [EOL] class test_txn10 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] t1 = [string] [EOL] t2 = [string] [EOL] create_params = [string] [EOL] conn_config = [string] + [string] [EOL] [EOL] def simulate_crash_restart ( self , olddir , newdir ) : [EOL] [docstring] [EOL] [comment] [EOL] shutil . rmtree ( newdir , ignore_errors = True ) [EOL] os . mkdir ( newdir ) [EOL] for fname in os . listdir ( olddir ) : [EOL] fullname = os . path . join ( olddir , fname ) [EOL] [comment] [EOL] if os . path . isfile ( fullname ) and [string] not in fullname and [string] not in fullname and [string] not in fullname : [EOL] shutil . copy ( fullname , newdir ) [EOL] [comment] [EOL] self . close_conn ( ) [EOL] self . conn = self . setUpConnectionOpen ( newdir ) [EOL] self . session = self . setUpSessionOpen ( self . conn ) [EOL] [EOL] def test_recovery ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . create ( self . t1 , self . create_params ) [EOL] self . reopen_conn ( ) [EOL] self . session . create ( self . t2 , self . create_params ) [EOL] c = self . session . open_cursor ( self . t2 , None , None ) [EOL] for i in range ( [number] ) : [EOL] c [ i ] = i + [number] [EOL] c . close ( ) [EOL] self . simulate_crash_restart ( [string] , [string] ) [EOL] c = self . session . open_cursor ( self . t2 , None , None ) [EOL] i = [number] [EOL] for key , value in c : [EOL] self . assertEqual ( i , key ) [EOL] self . assertEqual ( i + [number] , value ) [EOL] i += [number] [EOL] self . assertEqual ( i , [number] ) [EOL] c . close ( ) [EOL] c = self . session . open_cursor ( self . t1 , None , None ) [EOL] i = [number] [EOL] for key , value in c : [EOL] i += [number] [EOL] self . assertEqual ( i , [number] ) [EOL] c . close ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] from wtscenario import make_scenarios [EOL] [EOL] def timestamp_str ( t ) : [EOL] return [string] % t [EOL] [EOL] class test_timestamp10 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] conn_config = [string] [EOL] coll1_uri = [string] [EOL] coll2_uri = [string] [EOL] coll3_uri = [string] [EOL] oplog_uri = [string] [EOL] [EOL] nentries = [number] [EOL] table_cnt = [number] [EOL] [EOL] types = [ ( [string] , dict ( use_stable = [string] , run_wt = [number] ) ) , ( [string] , dict ( use_stable = [string] , run_wt = [number] ) ) , ( [string] , dict ( use_stable = [string] , run_wt = [number] ) ) , ( [string] , dict ( use_stable = [string] , run_wt = [number] ) ) , ( [string] , dict ( use_stable = [string] , run_wt = [number] ) ) , ( [string] , dict ( use_stable = [string] , run_wt = [number] ) ) , ( [string] , dict ( use_stable = [string] , run_wt = [number] ) ) , ( [string] , dict ( use_stable = [string] , run_wt = [number] ) ) , ( [string] , dict ( use_stable = [string] , run_wt = [number] ) ) , ] [EOL] scenarios = make_scenarios ( types ) [EOL] [EOL] def data_and_checkpoint ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . create ( self . oplog_uri , [string] ) [EOL] self . session . create ( self . coll1_uri , [string] ) [EOL] self . session . create ( self . coll2_uri , [string] ) [EOL] self . session . create ( self . coll3_uri , [string] ) [EOL] c_op = self . session . open_cursor ( self . oplog_uri ) [EOL] c = [ ] [EOL] c . append ( self . session . open_cursor ( self . coll1_uri ) ) [EOL] c . append ( self . session . open_cursor ( self . coll2_uri ) ) [EOL] c . append ( self . session . open_cursor ( self . coll3_uri ) ) [EOL] [EOL] [comment] [EOL] for table in range ( [number] , self . table_cnt + [number] ) : [EOL] curs = c [ table - [number] ] [EOL] start = self . nentries * table [EOL] end = start + self . nentries [EOL] ts = ( end - [number] ) [EOL] self . pr ( [string] + str ( table ) ) [EOL] for i in range ( start , end ) : [EOL] self . session . begin_transaction ( ) [EOL] c_op [ i ] = i [EOL] curs [ i ] = i [EOL] self . pr ( [string] + str ( i ) ) [EOL] self . session . commit_transaction ( [string] + timestamp_str ( i ) ) [EOL] [comment] [EOL] [comment] [EOL] self . pr ( [string] + str ( ts ) ) [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( ts ) + [string] + timestamp_str ( ts ) ) [EOL] [comment] [EOL] self . session . checkpoint ( ) [EOL] q = self . conn . query_timestamp ( [string] ) [EOL] self . assertTimestampsEqual ( q , timestamp_str ( ts ) ) [EOL] return ts [EOL] [EOL] def close_and_recover ( self , expected_rec_ts ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . use_stable == [string] : [EOL] close_cfg = [string] [EOL] elif self . use_stable == [string] : [EOL] close_cfg = [string] [EOL] else : [EOL] close_cfg = [string] [EOL] self . close_conn ( close_cfg ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( [number] , self . run_wt ) : [EOL] self . runWt ( [ [string] , [string] , [string] , [string] , [string] ] , outfilename = [string] ) [EOL] [EOL] self . open_conn ( ) [EOL] q = self . conn . query_timestamp ( [string] ) [EOL] self . pr ( [string] + q ) [EOL] self . assertTimestampsEqual ( q , timestamp_str ( expected_rec_ts ) ) [EOL] [EOL] def test_timestamp_recovery ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] [comment] [EOL] last_stable = self . data_and_checkpoint ( ) [EOL] [EOL] expected = [number] [EOL] [comment] [EOL] if self . use_stable != [string] : [EOL] expected = last_stable [EOL] [comment] [EOL] self . close_and_recover ( expected ) [EOL] [EOL] [comment] [EOL] c_op = self . session . open_cursor ( self . oplog_uri ) [EOL] c = [ ] [EOL] c . append ( self . session . open_cursor ( self . coll1_uri ) ) [EOL] c . append ( self . session . open_cursor ( self . coll2_uri ) ) [EOL] c . append ( self . session . open_cursor ( self . coll3_uri ) ) [EOL] for table in range ( [number] , self . table_cnt + [number] ) : [EOL] curs = c [ table - [number] ] [EOL] start = self . nentries * table [EOL] end = start + self . nentries [EOL] ts = ( end - [number] ) [EOL] for i in range ( start , end ) : [EOL] [comment] [EOL] self . assertEquals ( c_op [ i ] , i ) [EOL] curs . set_key ( i ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . use_stable == [string] or i <= ts or table != self . table_cnt : [EOL] self . assertEquals ( curs [ i ] , i ) [EOL] else : [EOL] self . assertEqual ( curs . search ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import wiredtiger , wttest [EOL] from wtscenario import make_scenarios [EOL] [EOL] class PackTester : [EOL] def __init__ ( self , formatcode , validlow , validhigh , equals ) : [EOL] self . formatcode = formatcode [EOL] self . validlow = validlow [EOL] self . validhigh = validhigh [EOL] self . recno = [number] [EOL] self . forw = None [comment] [EOL] self . forw_idx = None [comment] [EOL] self . back = None [comment] [EOL] self . back_idx = None [comment] [EOL] self . session = None [EOL] self . equals = equals [EOL] self . forw_uri = None [EOL] self . back_uri = None [EOL] self . forw_idx_uri = None [EOL] self . back_idx_uri = None [EOL] [EOL] def initialize ( self , session ) : [EOL] self . session = session [EOL] pfx = [string] [EOL] x = self . formatcode [EOL] if x . isupper ( ) : [EOL] x = x + [string] [comment] [EOL] tab = pfx + x + [string] [EOL] forw_uri = [string] + tab [EOL] forw_idx_uri = [string] + tab + [string] [EOL] tab = pfx + x + [string] [EOL] back_uri = [string] + tab [EOL] back_idx_uri = [string] + tab + [string] [EOL] [EOL] session . create ( forw_uri , [string] + [string] + self . formatcode ) [EOL] session . create ( forw_idx_uri , [string] ) [EOL] session . create ( back_uri , [string] + [string] + self . formatcode + [string] ) [EOL] session . create ( back_idx_uri , [string] ) [EOL] self . forw_uri = forw_uri [EOL] self . back_uri = back_uri [EOL] self . forw_idx_uri = forw_idx_uri [EOL] self . back_idx_uri = back_idx_uri [EOL] self . truncate ( ) [EOL] [EOL] def closeall ( self ) : [EOL] if self . forw != None : [EOL] self . forw . close ( ) [EOL] self . forw_idx . close ( ) [EOL] self . back . close ( ) [EOL] self . back_idx . close ( ) [EOL] self . forw = None [EOL] self . forw_idx = None [EOL] self . back = None [EOL] self . back_idx = None [EOL] [EOL] def truncate ( self ) : [EOL] self . closeall ( ) [EOL] self . session . truncate ( self . forw_uri , None , None , None ) [EOL] self . session . truncate ( self . back_uri , None , None , None ) [EOL] self . forw = self . session . open_cursor ( self . forw_uri , None , None ) [EOL] self . forw_idx = self . session . open_cursor ( self . forw_idx_uri + [string] , None , None ) [EOL] [EOL] self . back = self . session . open_cursor ( self . back_uri , None , None ) [EOL] self . back_idx = self . session . open_cursor ( self . back_idx_uri + [string] , None , None ) [EOL] [EOL] def check_range ( self , low , high ) : [EOL] if low < self . validlow : [EOL] low = self . validlow [EOL] if high > self . validhigh : [EOL] high = self . validhigh [EOL] i = low [EOL] forw = self . forw [EOL] forw_idx = self . forw_idx [EOL] back = self . back [EOL] back_idx = self . back_idx [EOL] while i <= high : [EOL] forw [ self . recno ] = i [EOL] back [ i ] = self . recno [EOL] self . equals ( forw [ self . recno ] , i ) [EOL] self . equals ( forw_idx [ i ] , self . recno ) [EOL] self . equals ( back [ i ] , self . recno ) [EOL] self . equals ( back_idx [ self . recno ] , i ) [EOL] forw . reset ( ) [EOL] forw_idx . reset ( ) [EOL] back . reset ( ) [EOL] back_idx . reset ( ) [EOL] self . recno += [number] [EOL] i += [number] [EOL] [EOL] [comment] [EOL] class test_intpack ( wttest . WiredTigerTestCase ) : [EOL] name = [string] [EOL] [EOL] [comment] [EOL] base_range = [number] if wttest . islongtest ( ) else [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( formatcode = [string] , low = - [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = - [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = - [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = - [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = - [number] , high = [number] , nbits = [number] ) ) , ( [string] , dict ( formatcode = [string] , low = [number] , high = [number] , nbits = [number] ) ) , ] ) [EOL] [EOL] def test_packing ( self ) : [EOL] pt = PackTester ( self . formatcode , self . low , self . high , self . assertEquals ) [EOL] self . assertEquals ( [number] ** self . nbits , self . high - self . low + [number] ) [EOL] pt . initialize ( self . session ) [EOL] pt . check_range ( - self . base_range , self . base_range ) [EOL] if self . nbits >= [number] : [EOL] e32 = [number] ** [number] [EOL] pt . check_range ( e32 - [number] , e32 + [number] ) [EOL] pt . check_range ( - e32 - [number] , - e32 + [number] ) [EOL] if self . nbits >= [number] : [EOL] e64 = [number] ** [number] [EOL] pt . check_range ( e64 - [number] , e64 + [number] ) [EOL] pt . check_range ( - e64 - [number] , - e64 + [number] ) [EOL] pt . truncate ( ) [EOL] i = [number] [EOL] while i < [number] << [number] : [EOL] pt . check_range ( - i - [number] , - i + [number] ) [EOL] pt . check_range ( i - [number] , i + [number] ) [EOL] i <<= [number] [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import shutil , os , wiredtiger , wttest [EOL] from wtscenario import make_scenarios [EOL] [EOL] def timestamp_str ( t ) : [EOL] return [string] % t [EOL] [EOL] class test_timestamp12 ( wttest . WiredTigerTestCase ) : [EOL] conn_config = [string] [EOL] coll_uri = [string] [EOL] oplog_uri = [string] [EOL] closecfg = [ ( [string] , dict ( close_cfg = [string] , all_expected = False ) ) , ( [string] , dict ( close_cfg = [string] , all_expected = False ) ) , ( [string] , dict ( close_cfg = [string] , all_expected = True ) ) , ] [EOL] scenarios = make_scenarios ( closecfg ) [EOL] [EOL] def verify_expected ( self , op_exp , coll_exp ) : [EOL] c_op = self . session . open_cursor ( self . oplog_uri ) [EOL] c_coll = self . session . open_cursor ( self . coll_uri ) [EOL] op_actual = dict ( ( k , v ) for k , v in c_op if v != [number] ) [EOL] coll_actual = dict ( ( k , v ) for k , v in c_coll if v != [number] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertTrue ( op_actual == op_exp ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertTrue ( coll_actual == coll_exp ) [EOL] [EOL] def test_timestamp_recovery ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . create ( self . oplog_uri , [string] ) [EOL] self . session . create ( self . coll_uri , [string] ) [EOL] c_op = self . session . open_cursor ( self . oplog_uri ) [EOL] c_coll = self . session . open_cursor ( self . coll_uri ) [EOL] [EOL] [comment] [EOL] nentries = [number] [EOL] first_range = range ( [number] , nentries ) [EOL] second_range = range ( nentries , nentries * [number] ) [EOL] all_keys = range ( [number] , nentries * [number] ) [EOL] for i in first_range : [EOL] self . session . begin_transaction ( ) [EOL] c_op [ i ] = [number] [EOL] c_coll [ i ] = [number] [EOL] self . session . commit_transaction ( [string] + timestamp_str ( i ) ) [EOL] [comment] [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( nentries - [number] ) + [string] + timestamp_str ( nentries - [number] ) ) [EOL] [EOL] [comment] [EOL] for i in second_range : [EOL] self . session . begin_transaction ( ) [EOL] c_op [ i ] = [number] [EOL] c_coll [ i ] = [number] [EOL] self . pr ( [string] + str ( i ) ) [EOL] self . session . commit_transaction ( [string] + timestamp_str ( i ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . close_conn ( self . close_cfg ) [EOL] self . open_conn ( ) [EOL] [EOL] [comment] [EOL] op_exp = dict ( ( k , [number] ) for k in all_keys ) [EOL] if self . all_expected == True : [EOL] coll_exp = dict ( ( k , [number] ) for k in all_keys ) [EOL] else : [EOL] coll_exp = dict ( ( k , [number] ) for k in first_range ) [EOL] [EOL] self . verify_expected ( op_exp , coll_exp ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.range$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.range$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.range$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import os , shutil [EOL] import wiredtiger , wttest [EOL] [EOL] from suite_subprocess import suite_subprocess [EOL] from wtscenario import make_scenarios [EOL] from wtdataset import SimpleDataSet , SimpleIndexDataSet , SimpleLSMDataSet , ComplexDataSet , ComplexLSMDataSet , ProjectionDataSet , ProjectionIndexDataSet [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class test_dump ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] dir = [string] [comment] [EOL] [EOL] name = [string] [EOL] name2 = [string] [EOL] nentries = [number] [EOL] [EOL] dumpfmt = [ ( [string] , dict ( hex = [number] ) ) , ( [string] , dict ( hex = [number] ) ) ] [EOL] keyfmt = [ ( [string] , dict ( keyfmt = [string] ) ) , ( [string] , dict ( keyfmt = [string] ) ) , ( [string] , dict ( keyfmt = [string] ) ) ] [EOL] types = [ ( [string] , dict ( uri = [string] , dataset = SimpleDataSet ) ) , ( [string] , dict ( uri = [string] , dataset = SimpleDataSet ) ) , ( [string] , dict ( uri = [string] , dataset = SimpleDataSet ) ) , ( [string] , dict ( uri = [string] , dataset = SimpleIndexDataSet ) ) , ( [string] , dict ( uri = [string] , dataset = SimpleLSMDataSet ) ) , ( [string] , dict ( uri = [string] , dataset = ComplexDataSet ) ) , ( [string] , dict ( uri = [string] , dataset = ComplexLSMDataSet ) ) , ( [string] , dict ( uri = [string] , dataset = ProjectionDataSet , projection = True ) ) , ( [string] , dict ( uri = [string] , dataset = ProjectionIndexDataSet , projection = True ) ) , ] [EOL] scenarios = make_scenarios ( types , keyfmt , dumpfmt ) [EOL] [EOL] def skip ( self ) : [EOL] return ( self . dataset . is_lsm ( ) or self . uri == [string] ) and self . keyfmt == [string] [EOL] [EOL] [comment] [EOL] def value_lines ( self , fname ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] mode = [number] [EOL] lines = [ ] [EOL] for line in open ( fname ) . readlines ( ) : [EOL] if mode == [number] : [EOL] if line == [string] : [EOL] mode = [number] [EOL] elif mode == [number] : [EOL] mode = [number] [EOL] else : [EOL] [comment] [EOL] lines . append ( line ) [EOL] mode = [number] [EOL] return sorted ( lines ) [EOL] [EOL] def compare_dump_values ( self , f1 , f2 ) : [EOL] l1 = self . value_lines ( f1 ) [EOL] l2 = self . value_lines ( f2 ) [EOL] self . assertEqual ( l1 , l2 ) [EOL] [EOL] [comment] [EOL] def test_dump ( self ) : [EOL] [comment] [EOL] if self . skip ( ) : [EOL] return [EOL] [EOL] [comment] [EOL] uri = self . uri + self . name [EOL] uri2 = self . uri + self . name2 [EOL] pop = self . dataset ( self , uri , self . nentries , key_format = self . keyfmt ) [EOL] pop . populate ( ) [EOL] [EOL] [comment] [EOL] os . mkdir ( self . dir ) [EOL] if self . hex == [number] : [EOL] self . runWt ( [ [string] , [string] , uri ] , outfilename = [string] ) [EOL] else : [EOL] self . runWt ( [ [string] , uri ] , outfilename = [string] ) [EOL] [EOL] [comment] [EOL] self . runWt ( [ [string] , self . dir , [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] self . runWt ( [ [string] ] , outfilename = [string] ) [EOL] self . runWt ( [ [string] , self . dir , [string] ] , outfilename = [string] ) [EOL] s1 = set ( open ( [string] ) . read ( ) . split ( ) ) [EOL] s2 = set ( open ( [string] ) . read ( ) . split ( ) ) [EOL] self . assertEqual ( not s1 . symmetric_difference ( s2 ) , True ) [EOL] [EOL] [comment] [EOL] self . reopen_conn ( self . dir ) [EOL] pop . check ( ) [EOL] [EOL] [comment] [EOL] self . reopen_conn ( [string] ) [EOL] self . runWt ( [ [string] , self . dir , [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] pop . check ( ) [EOL] [EOL] [comment] [EOL] self . runWt ( [ [string] , self . dir , [string] , [string] , [string] , [string] ] , errfilename = [string] , failure = True ) [EOL] self . check_non_empty_file ( [string] ) [EOL] [EOL] [comment] [EOL] if self . dataset == ComplexDataSet : [EOL] indexuri = [string] + self . name + [string] [EOL] hexopt = [ [string] ] if self . hex == [number] else [ ] [EOL] self . runWt ( [ [string] , self . dir , [string] ] + hexopt + [ indexuri ] , outfilename = [string] ) [EOL] self . check_non_empty_file ( [string] ) [EOL] self . compare_dump_values ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] shutil . rmtree ( self . dir ) [EOL] os . mkdir ( self . dir ) [EOL] self . runWt ( [ [string] , self . dir , [string] , [string] , self . name2 , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] self . reopen_conn ( self . dir ) [EOL] pop = self . dataset ( self , uri2 , self . nentries , key_format = self . keyfmt ) [EOL] pop . check ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class test_dump_projection ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] dir = [string] [comment] [EOL] [EOL] name = [string] [EOL] nentries = [number] [EOL] uri = [string] [EOL] [EOL] [comment] [EOL] def test_dump ( self ) : [EOL] [EOL] [comment] [EOL] uri = self . uri + self . name [EOL] pop = ProjectionDataSet ( self , uri , self . nentries , key_format = [string] ) [EOL] pop . populate ( ) [EOL] [EOL] [comment] [EOL] self . runWt ( [ [string] , [string] , uri + [string] ] , outfilename = [string] , errfilename = [string] , failure = True ) [EOL] self . check_non_empty_file ( [string] ) [EOL] self . runWt ( [ [string] , [string] , uri + [string] ] , outfilename = [string] , errfilename = [string] , failure = True ) [EOL] self . check_non_empty_file ( [string] ) [EOL] self . runWt ( [ [string] , [string] , uri + pop . projection [ : - [number] ] ] , outfilename = [string] , errfilename = [string] , failure = True ) [EOL] self . check_non_empty_file ( [string] ) [EOL] [EOL] [comment] [EOL] self . runWt ( [ [string] , [string] , uri + pop . projection ] , outfilename = [string] ) [EOL] [EOL] [comment] [EOL] os . mkdir ( self . dir ) [EOL] self . runWt ( [ [string] , self . dir , [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] self . runWt ( [ [string] ] , outfilename = [string] ) [EOL] self . runWt ( [ [string] , self . dir , [string] ] , outfilename = [string] ) [EOL] s1 = set ( open ( [string] ) . read ( ) . split ( ) ) [EOL] s2 = set ( open ( [string] ) . read ( ) . split ( ) ) [EOL] self . assertEqual ( not s1 . symmetric_difference ( s2 ) , True ) [EOL] [EOL] [comment] [EOL] self . reopen_conn ( self . dir ) [EOL] pop_reload = ProjectionDataSet ( self , uri , self . nentries , key_format = [string] ) [EOL] pop_reload . check ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import wiredtiger , wttest [EOL] from wtdataset import SimpleDataSet , ComplexDataSet , ComplexLSMDataSet [EOL] from wtscenario import make_scenarios [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_cursor06 ( wttest . WiredTigerTestCase ) : [EOL] name = [string] [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( type = [string] , keyfmt = [string] , dataset = SimpleDataSet ) ) , ( [string] , dict ( type = [string] , keyfmt = [string] , dataset = SimpleDataSet ) ) , ( [string] , dict ( type = [string] , keyfmt = [string] , dataset = SimpleDataSet ) ) , ( [string] , dict ( type = [string] , keyfmt = [string] , dataset = SimpleDataSet ) ) , ( [string] , dict ( type = [string] , keyfmt = [string] , dataset = SimpleDataSet ) ) , ( [string] , dict ( type = [string] , keyfmt = [string] , dataset = ComplexDataSet ) ) , ( [string] , dict ( type = [string] , keyfmt = [string] , dataset = ComplexDataSet ) ) , ( [string] , dict ( type = [string] , keyfmt = [string] , dataset = ComplexLSMDataSet ) ) , ] ) [EOL] [EOL] def populate ( self , uri ) : [EOL] self . ds = self . dataset ( self , uri , [number] , key_format = self . keyfmt ) [EOL] self . ds . populate ( ) [EOL] [EOL] def set_kv ( self , cursor ) : [EOL] cursor . set_key ( self . ds . key ( [number] ) ) [EOL] cursor . set_value ( self . ds . value ( [number] ) ) [EOL] [EOL] def test_reconfigure_overwrite ( self ) : [EOL] uri = self . type + self . name [EOL] for open_config in ( None , [string] , [string] ) : [EOL] self . session . drop ( uri , [string] ) [EOL] self . populate ( uri ) [EOL] cursor = self . session . open_cursor ( uri , None , open_config ) [EOL] if open_config != [string] : [EOL] self . set_kv ( cursor ) [EOL] cursor . insert ( ) [EOL] for i in range ( [number] , [number] ) : [EOL] cursor . reconfigure ( [string] ) [EOL] self . set_kv ( cursor ) [EOL] self . assertRaises ( wiredtiger . WiredTigerError , lambda : cursor . insert ( ) ) [EOL] cursor . reconfigure ( [string] ) [EOL] self . set_kv ( cursor ) [EOL] cursor . insert ( ) [EOL] cursor . close ( ) [EOL] [EOL] def test_reconfigure_readonly ( self ) : [EOL] uri = self . type + self . name [EOL] for open_config in ( None , [string] , [string] ) : [EOL] self . session . drop ( uri , [string] ) [EOL] self . populate ( uri ) [EOL] cursor = self . session . open_cursor ( uri , None , open_config ) [EOL] msg = [string] [EOL] if open_config == [string] : [EOL] self . set_kv ( cursor ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : cursor . update ( ) , msg ) [EOL] else : [EOL] self . set_kv ( cursor ) [EOL] cursor . update ( ) [EOL] cursor . close ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import os , struct [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_util09 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] tablename = [string] [EOL] nentries = [number] [EOL] session_params = [string] [EOL] [EOL] def populate_file ( self , filename , low , high ) : [EOL] [docstring] [EOL] keys = { } [EOL] with open ( [string] , [string] ) as f : [EOL] for i in range ( low , high ) : [EOL] key = str ( i ) + str ( i ) [EOL] val = key + key + key [EOL] f . write ( key + [string] ) [EOL] f . write ( val + [string] ) [EOL] keys [ key ] = val [EOL] [comment] [EOL] return keys [EOL] [EOL] def check_keys ( self , tablename , keys ) : [EOL] [docstring] [EOL] cursor = self . session . open_cursor ( [string] + tablename , None , None ) [EOL] for key , val in cursor : [EOL] self . assertEqual ( keys [ key ] , val ) [EOL] del keys [ key ] [EOL] cursor . close ( ) [EOL] self . assertEqual ( len ( keys ) , [number] ) [EOL] [EOL] def test_loadtext_empty ( self ) : [EOL] [docstring] [EOL] self . session . create ( [string] + self . tablename , self . session_params ) [EOL] keys = self . populate_file ( [string] , [number] , [number] ) [EOL] self . runWt ( [ [string] , [string] , [string] , [string] + self . tablename ] ) [EOL] self . check_keys ( self . tablename , keys ) [EOL] [EOL] def test_loadtext_empty_stdin ( self ) : [EOL] [docstring] [EOL] self . session . create ( [string] + self . tablename , self . session_params ) [EOL] keys = self . populate_file ( [string] , [number] , [number] ) [EOL] self . runWt ( [ [string] , [string] + self . tablename ] , infilename = [string] ) [EOL] self . check_keys ( self . tablename , keys ) [EOL] [EOL] def test_loadtext_populated ( self ) : [EOL] [docstring] [EOL] self . session . create ( [string] + self . tablename , self . session_params ) [EOL] keys = self . populate_file ( [string] , [number] , [number] ) [EOL] self . runWt ( [ [string] , [string] , [string] , [string] + self . tablename ] ) [EOL] self . check_keys ( self . tablename , keys ) [EOL] [EOL] def test_loadtext_populated_stdin ( self ) : [EOL] [docstring] [EOL] self . session . create ( [string] + self . tablename , self . session_params ) [EOL] keys = self . populate_file ( [string] , [number] , [number] ) [EOL] self . runWt ( [ [string] , [string] + self . tablename ] , infilename = [string] ) [EOL] self . check_keys ( self . tablename , keys ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import wiredtiger , wttest [EOL] from wtdataset import SimpleDataSet , ComplexLSMDataSet [EOL] from wtscenario import make_scenarios [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class test_checkpoint ( wttest . WiredTigerTestCase ) : [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( uri = [string] , fmt = [string] ) ) , ( [string] , dict ( uri = [string] , fmt = [string] ) ) ] ) [EOL] [EOL] [comment] [EOL] checkpoints = { [string] : ( ( [number] , [number] ) , [number] ) , [string] : ( ( [number] , [number] ) , [number] ) , [string] : ( ( [number] , [number] ) , [number] ) , [string] : ( ( [number] , [number] ) , [number] ) , [string] : ( ( [number] , [number] ) , [number] ) , [string] : ( ( [number] , [number] ) , [number] ) , [string] : ( ( [number] , [number] ) , [number] ) , [string] : ( ( [number] , [number] ) , [number] ) , [string] : ( ( [number] , [number] ) , [number] ) } [EOL] [EOL] [comment] [EOL] def add_records ( self , name ) : [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] start , stop = self . checkpoints [ name ] [ [number] ] [EOL] for i in range ( start , stop + [number] ) : [EOL] cursor [ [string] % i ] = ( [string] % i ) + name [EOL] cursor . close ( ) [EOL] self . checkpoints [ name ] = ( self . checkpoints [ name ] [ [number] ] , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def build_file_with_checkpoints ( self ) : [EOL] for checkpoint_name , entry in self . checkpoints . iteritems ( ) : [EOL] self . add_records ( checkpoint_name ) [EOL] self . session . checkpoint ( [string] + checkpoint_name ) [EOL] [EOL] [comment] [EOL] def list_expected ( self , name ) : [EOL] records = { } [EOL] for checkpoint_name , entry in self . checkpoints . iteritems ( ) : [EOL] start , stop = entry [ [number] ] [EOL] for i in range ( start , stop + [number] ) : [EOL] records [ [string] % i ] = [string] % i + checkpoint_name [EOL] if name == checkpoint_name : [EOL] break [EOL] return records [EOL] [EOL] [comment] [EOL] def list_checkpoint ( self , name ) : [EOL] records = { } [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] + name ) [EOL] while cursor . next ( ) == [number] : [EOL] records [ cursor . get_key ( ) ] = cursor . get_value ( ) [EOL] cursor . close ( ) [EOL] return records [EOL] [EOL] [comment] [EOL] [comment] [EOL] def check ( self ) : [EOL] [comment] [EOL] self . session . verify ( self . uri , None ) [EOL] [EOL] for checkpoint_name , entry in self . checkpoints . iteritems ( ) : [EOL] if entry [ [number] ] == [number] : [EOL] self . assertRaises ( wiredtiger . WiredTigerError , lambda : self . session . open_cursor ( self . uri , None , [string] + checkpoint_name ) ) [EOL] else : [EOL] list_expected = self . list_expected ( checkpoint_name ) [EOL] list_checkpoint = self . list_checkpoint ( checkpoint_name ) [EOL] self . assertEqual ( list_expected , list_checkpoint ) [EOL] [EOL] [comment] [EOL] def test_checkpoint ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . session . create ( self . uri , [string] + self . fmt + [string] ) [EOL] self . build_file_with_checkpoints ( ) [EOL] self . check ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for i in [ [number] , [number] , [number] , [number] ] : [EOL] checkpoint_name = [string] + str ( i ) [EOL] self . session . checkpoint ( [string] + checkpoint_name + [string] ) [EOL] self . checkpoints [ checkpoint_name ] = ( self . checkpoints [ checkpoint_name ] [ [number] ] , [number] ) [EOL] self . check ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . session . checkpoint ( [string] ) [EOL] for checkpoint_name , entry in self . checkpoints . iteritems ( ) : [EOL] self . checkpoints [ checkpoint_name ] = ( self . checkpoints [ checkpoint_name ] [ [number] ] , [number] ) [EOL] self . check ( ) [EOL] [EOL] [comment] [EOL] class test_checkpoint_cursor ( wttest . WiredTigerTestCase ) : [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( uri = [string] , fmt = [string] ) ) , ( [string] , dict ( uri = [string] , fmt = [string] ) ) ] ) [EOL] [EOL] [comment] [EOL] def test_checkpoint_dne ( self ) : [EOL] SimpleDataSet ( self , self . uri , [number] , key_format = self . fmt ) . populate ( ) [EOL] self . assertRaises ( wiredtiger . WiredTigerError , lambda : self . session . open_cursor ( self . uri , None , [string] ) ) [EOL] self . assertRaises ( wiredtiger . WiredTigerError , lambda : self . session . open_cursor ( self . uri , None , [string] ) ) [EOL] [EOL] [comment] [EOL] def test_checkpoint_multiple_open ( self ) : [EOL] SimpleDataSet ( self , self . uri , [number] , key_format = self . fmt ) . populate ( ) [EOL] self . session . checkpoint ( [string] ) [EOL] c1 = self . session . open_cursor ( self . uri , None , [string] ) [EOL] c2 = self . session . open_cursor ( self . uri , None , [string] ) [EOL] c3 = self . session . open_cursor ( self . uri , None , [string] ) [EOL] c4 = self . session . open_cursor ( self . uri , None , None ) [EOL] c4 . close , c3 . close , c2 . close , c1 . close [EOL] [EOL] self . session . checkpoint ( [string] ) [EOL] c1 = self . session . open_cursor ( self . uri , None , [string] ) [EOL] c2 = self . session . open_cursor ( self . uri , None , [string] ) [EOL] c3 = self . session . open_cursor ( self . uri , None , [string] ) [EOL] c4 = self . session . open_cursor ( self . uri , None , None ) [EOL] c4 . close , c3 . close , c2 . close , c1 . close [EOL] [EOL] [comment] [EOL] def test_checkpoint_inuse ( self ) : [EOL] SimpleDataSet ( self , self . uri , [number] , key_format = self . fmt ) . populate ( ) [EOL] self . session . checkpoint ( [string] ) [EOL] self . session . checkpoint ( [string] ) [EOL] self . session . checkpoint ( [string] ) [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . checkpoint ( [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . checkpoint ( [string] ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . checkpoint ( [string] ) , msg ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . session . checkpoint ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cursor . close ( ) [EOL] self . session . checkpoint ( [string] ) [EOL] self . session . checkpoint ( [string] ) [EOL] self . session . checkpoint ( [string] ) [EOL] [EOL] [comment] [EOL] class test_checkpoint_target ( wttest . WiredTigerTestCase ) : [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( uri = [string] , fmt = [string] ) ) , ( [string] , dict ( uri = [string] , fmt = [string] ) ) ] ) [EOL] [EOL] def update ( self , uri , ds , value ) : [EOL] cursor = self . session . open_cursor ( uri , None , [string] ) [EOL] cursor [ ds . key ( [number] ) ] = value [EOL] cursor . close ( ) [EOL] [EOL] def check ( self , uri , ds , value ) : [EOL] cursor = self . session . open_cursor ( uri , None , [string] ) [EOL] self . assertEquals ( cursor [ ds . key ( [number] ) ] , value ) [EOL] cursor . close ( ) [EOL] [EOL] def test_checkpoint_target ( self ) : [EOL] [comment] [EOL] uri = self . uri + [string] [EOL] ds1 = SimpleDataSet ( self , uri , [number] , key_format = self . fmt ) [EOL] ds1 . populate ( ) [EOL] self . update ( uri , ds1 , [string] ) [EOL] [EOL] uri = self . uri + [string] [EOL] ds2 = SimpleDataSet ( self , uri , [number] , key_format = self . fmt ) [EOL] ds2 . populate ( ) [EOL] self . update ( uri , ds2 , [string] ) [EOL] [EOL] uri = self . uri + [string] [EOL] ds3 = SimpleDataSet ( self , uri , [number] , key_format = self . fmt ) [EOL] ds3 . populate ( ) [EOL] self . update ( uri , ds3 , [string] ) [EOL] [EOL] [comment] [EOL] self . session . checkpoint ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . update ( self . uri + [string] , ds1 , [string] ) [EOL] self . update ( self . uri + [string] , ds2 , [string] ) [EOL] self . update ( self . uri + [string] , ds3 , [string] ) [EOL] target = [string] + self . uri + [string] + [string] + self . uri + [string] [EOL] self . session . checkpoint ( [string] + target ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . check ( self . uri + [string] , ds1 , [string] ) [EOL] self . check ( self . uri + [string] , ds2 , [string] ) [EOL] self . check ( self . uri + [string] , ds3 , [string] ) [EOL] [EOL] [comment] [EOL] class test_checkpoint_cursor_update ( wttest . WiredTigerTestCase ) : [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( uri = [string] , fmt = [string] ) ) , ( [string] , dict ( uri = [string] , fmt = [string] ) ) , ( [string] , dict ( uri = [string] , fmt = [string] ) ) , ( [string] , dict ( uri = [string] , fmt = [string] ) ) ] ) [EOL] [EOL] def test_checkpoint_cursor_update ( self ) : [EOL] ds = SimpleDataSet ( self , self . uri , [number] , key_format = self . fmt ) [EOL] ds . populate ( ) [EOL] self . session . checkpoint ( [string] ) [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] cursor . set_value ( [string] ) [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : cursor . insert ( ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : cursor . remove ( ) , msg ) [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : cursor . update ( ) , msg ) [EOL] cursor . close ( ) [EOL] [EOL] [comment] [EOL] class test_checkpoint_last ( wttest . WiredTigerTestCase ) : [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( uri = [string] , fmt = [string] ) ) , ( [string] , dict ( uri = [string] , fmt = [string] ) ) ] ) [EOL] [EOL] def test_checkpoint_last ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] uri = self . uri [EOL] ds = SimpleDataSet ( self , uri , [number] , key_format = self . fmt ) [EOL] ds . populate ( ) [EOL] [EOL] for value in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] [comment] [EOL] cursor = self . session . open_cursor ( uri , None , [string] ) [EOL] cursor [ ds . key ( [number] ) ] = value [EOL] cursor . close ( ) [EOL] [EOL] [comment] [EOL] self . session . checkpoint ( ) [EOL] [EOL] [comment] [EOL] cursor = self . session . open_cursor ( uri , None , [string] ) [EOL] self . assertEquals ( cursor [ ds . key ( [number] ) ] , value ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class test_checkpoint_illegal_name ( wttest . WiredTigerTestCase ) : [EOL] def test_checkpoint_illegal_name ( self ) : [EOL] ds = SimpleDataSet ( self , [string] , [number] , key_format = [string] ) [EOL] ds . populate ( ) [EOL] msg = [string] [EOL] for conf in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . checkpoint ( conf ) , msg ) [EOL] msg = [string] [EOL] for conf in ( [string] , [string] ) : [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . checkpoint ( conf ) , msg ) [EOL] [EOL] [comment] [EOL] class test_checkpoint_lsm_name ( wttest . WiredTigerTestCase ) : [EOL] def test_checkpoint_lsm_name ( self ) : [EOL] ds = ComplexLSMDataSet ( self , [string] , [number] ) [EOL] ds . populate ( ) [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . checkpoint ( [string] ) , msg ) [EOL] [EOL] class test_checkpoint_empty ( wttest . WiredTigerTestCase ) : [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( uri = [string] ) ) , ( [string] , dict ( uri = [string] ) ) , ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_checkpoint_empty_one ( self ) : [EOL] self . session . create ( self . uri , [string] ) [EOL] self . session . checkpoint ( [string] ) [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] [EOL] [comment] [EOL] def test_checkpoint_empty_two ( self ) : [EOL] self . session . create ( self . uri , [string] ) [EOL] self . session . checkpoint ( ) [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] [EOL] [comment] [EOL] def test_checkpoint_empty_three ( self ) : [EOL] self . session . create ( self . uri , [string] ) [EOL] self . session . checkpoint ( [string] ) [EOL] self . session . checkpoint ( ) [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] [EOL] [comment] [EOL] def test_checkpoint_empty_four ( self ) : [EOL] self . session . create ( self . uri , [string] ) [EOL] self . session . checkpoint ( ) [EOL] self . session . checkpoint ( [string] ) [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_checkpoint_empty_five ( self ) : [EOL] self . session . create ( self . uri , [string] ) [EOL] self . session . checkpoint ( [string] ) [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] self . assertEquals ( cursor . next ( ) , wiredtiger . WT_NOTFOUND ) [EOL] cursor . close ( ) [EOL] [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] cursor [ [string] ] = [string] [EOL] self . session . checkpoint ( ) [EOL] [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] self . assertEquals ( cursor . next ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [EOL] def test_checkpoint_empty_six ( self ) : [EOL] self . session . create ( self . uri , [string] ) [EOL] self . session . checkpoint ( ) [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] self . assertEquals ( cursor . next ( ) , wiredtiger . WT_NOTFOUND ) [EOL] cursor . close ( ) [EOL] [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] cursor [ [string] ] = [string] [EOL] self . session . checkpoint ( [string] ) [EOL] [EOL] cursor = self . session . open_cursor ( self . uri , None , [string] ) [EOL] self . assertEquals ( cursor . next ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import wiredtiger , wttest [EOL] from wtdataset import SimpleDataSet , SimpleIndexDataSet [EOL] from wtdataset import SimpleLSMDataSet , ComplexDataSet , ComplexLSMDataSet [EOL] from wtscenario import make_scenarios [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class test_cursor11 ( wttest . WiredTigerTestCase ) : [EOL] [EOL] keyfmt = [ ( [string] , dict ( keyfmt = [string] ) ) , ( [string] , dict ( keyfmt = [string] ) ) , ( [string] , dict ( keyfmt = [string] ) ) , ] [EOL] types = [ ( [string] , dict ( uri = [string] , ds = SimpleDataSet ) ) , ( [string] , dict ( uri = [string] , ds = SimpleDataSet ) ) , ( [string] , dict ( uri = [string] , ds = ComplexDataSet ) ) , ( [string] , dict ( uri = [string] , ds = ComplexLSMDataSet ) ) , ( [string] , dict ( uri = [string] , ds = SimpleIndexDataSet ) ) , ( [string] , dict ( uri = [string] , ds = SimpleDataSet ) ) , ( [string] , dict ( uri = [string] , ds = SimpleLSMDataSet ) ) , ] [EOL] scenarios = make_scenarios ( types , keyfmt ) [EOL] [EOL] def skip ( self ) : [EOL] return self . keyfmt == [string] and ( self . ds . is_lsm ( ) or self . uri == [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_cursor_remove_with_position ( self ) : [EOL] if self . skip ( ) : [EOL] return [EOL] [EOL] [comment] [EOL] uri = self . uri + [string] [EOL] ds = self . ds ( self , uri , [number] , key_format = self . keyfmt ) [EOL] ds . populate ( ) [EOL] s = self . conn . open_session ( ) [EOL] c = s . open_cursor ( uri , None ) [EOL] [EOL] c . set_key ( ds . key ( [number] ) ) [EOL] self . assertEquals ( c . search ( ) , [number] ) [EOL] self . assertEquals ( c . next ( ) , [number] ) [EOL] self . assertEquals ( c . get_key ( ) , ds . key ( [number] ) ) [EOL] c . remove ( ) [EOL] self . assertEquals ( c . get_key ( ) , ds . key ( [number] ) ) [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , c . get_value , msg ) [EOL] self . assertEquals ( c . next ( ) , [number] ) [EOL] self . assertEquals ( c . get_key ( ) , ds . key ( [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_cursor_remove_without_position ( self ) : [EOL] if self . skip ( ) : [EOL] return [EOL] [EOL] [comment] [EOL] uri = self . uri + [string] [EOL] ds = self . ds ( self , uri , [number] , key_format = self . keyfmt ) [EOL] ds . populate ( ) [EOL] s = self . conn . open_session ( ) [EOL] c = s . open_cursor ( uri , None ) [EOL] [EOL] c . set_key ( ds . key ( [number] ) ) [EOL] c . remove ( ) [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , c . get_key , msg ) [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , c . get_value , msg ) [EOL] self . assertEquals ( c . next ( ) , [number] ) [EOL] self . assertEquals ( c . get_key ( ) , ds . key ( [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_cursor_remove_with_key_and_position ( self ) : [EOL] if self . skip ( ) : [EOL] return [EOL] [EOL] [comment] [EOL] uri = self . uri + [string] [EOL] ds = self . ds ( self , uri , [number] , key_format = self . keyfmt ) [EOL] ds . populate ( ) [EOL] s = self . conn . open_session ( ) [EOL] c = s . open_cursor ( uri , None ) [EOL] [EOL] c . set_key ( ds . key ( [number] ) ) [EOL] self . assertEquals ( c . search ( ) , [number] ) [EOL] c . set_key ( ds . key ( [number] ) ) [EOL] c . remove ( ) [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , c . get_key , msg ) [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , c . get_value , msg ) [EOL] self . assertEquals ( c . next ( ) , [number] ) [EOL] self . assertEquals ( c . get_key ( ) , ds . key ( [number] ) ) [EOL] [EOL] [comment] [EOL] def test_cursor_insert ( self ) : [EOL] if self . skip ( ) : [EOL] return [EOL] [EOL] [comment] [EOL] uri = self . uri + [string] [EOL] ds = self . ds ( self , uri , [number] , key_format = self . keyfmt ) [EOL] ds . populate ( ) [EOL] s = self . conn . open_session ( ) [EOL] c = s . open_cursor ( uri , None ) [EOL] [EOL] c . set_key ( ds . key ( [number] ) ) [EOL] c . set_value ( ds . value ( [number] ) ) [EOL] c . insert ( ) [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , c . get_key , msg ) [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , c . get_value , msg ) [EOL] self . assertEquals ( c . next ( ) , [number] ) [EOL] self . assertEquals ( c . get_key ( ) , ds . key ( [number] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import random [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] from wtscenario import make_scenarios [EOL] [EOL] def timestamp_str ( t ) : [EOL] return [string] % t [EOL] [EOL] class test_timestamp05 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] uri = [string] [EOL] [EOL] def test_create ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] s = self . session [EOL] conn = self . conn [EOL] [EOL] [comment] [EOL] conn . set_timestamp ( [string] ) [EOL] [EOL] [comment] [EOL] s . begin_transaction ( ) [EOL] s . create ( self . uri , [string] ) [EOL] s . commit_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] [EOL] [comment] [EOL] c = s . open_cursor ( self . uri ) [EOL] c [ [number] ] = [string] [EOL] [EOL] [comment] [EOL] s . checkpoint ( [string] ) [EOL] [EOL] def test_bulk ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] s = self . session [EOL] conn = self . conn [EOL] [EOL] s . create ( self . uri , [string] ) [EOL] c = s . open_cursor ( self . uri , None , [string] ) [EOL] [EOL] [comment] [EOL] nkeys = [number] [EOL] keys = range ( [number] , nkeys + [number] ) [EOL] [EOL] for k in keys : [EOL] c [ k ] = [string] [EOL] [EOL] [comment] [EOL] conn . set_timestamp ( [string] ) [EOL] [EOL] [comment] [EOL] s . begin_transaction ( ) [EOL] c . close ( ) [EOL] s . commit_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] [EOL] [comment] [EOL] c = s . open_cursor ( self . uri ) [EOL] c [ [number] ] = [string] [EOL] [EOL] [comment] [EOL] s . checkpoint ( [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.range$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import wiredtiger , wtscenario , wttest [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class test_unicode01 ( wttest . WiredTigerTestCase ) : [EOL] def test_unicode ( self ) : [EOL] self . session . create ( [string] , [string] . encode ( [string] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import fnmatch , os , shutil , time [EOL] from helper import copy_wiredtiger_home [EOL] from suite_subprocess import suite_subprocess [EOL] import wttest [EOL] [EOL] class test_durability01 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] uri = [string] [EOL] create_params = [string] [EOL] [EOL] def check_crash_restart ( self , olddir , newdir ) : [EOL] [docstring] [EOL] [comment] [EOL] copy_wiredtiger_home ( olddir , newdir ) [EOL] [EOL] [comment] [EOL] conn = self . setUpConnectionOpen ( newdir ) [EOL] session = self . setUpSessionOpen ( conn ) [EOL] session . verify ( self . uri ) [EOL] conn . close ( ) [EOL] [EOL] def test_durability ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . create ( self . uri , self . create_params ) [EOL] for i in range ( [number] ) : [EOL] c = self . session . open_cursor ( self . uri ) [EOL] c [ i ] = i [EOL] c . close ( ) [EOL] if i % [number] == [number] : [EOL] self . session . checkpoint ( ) [EOL] else : [EOL] self . session . verify ( self . uri ) [EOL] self . check_crash_restart ( [string] , [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import random [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] from wtscenario import make_scenarios [EOL] [EOL] class test_timestamp13 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] tablename = [string] [EOL] uri = [string] + tablename [EOL] [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( extra_config = [string] ) ) , ( [string] , dict ( extra_config = [string] ) ) , ( [string] , dict ( extra_config = [string] ) ) , ] ) [EOL] [EOL] conn_config = [string] [EOL] [EOL] def test_degenerate_timestamps ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] self . session . create ( self . uri , [string] + self . extra_config ) [EOL] [EOL] query_choices = [ [string] , [string] , [string] , [string] ] [EOL] [comment] [EOL] for query in query_choices : [EOL] self . assertRaises ( wiredtiger . WiredTigerError , lambda : self . session . query_timestamp ( [string] + query ) ) [EOL] [EOL] self . session . begin_transaction ( ) [EOL] [comment] [EOL] for query in query_choices : [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] + query ) , [string] ) [EOL] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . query_timestamp ( [string] ) , [string] ) [EOL] [EOL] self . session . commit_transaction ( ) [EOL] [comment] [EOL] for query in query_choices : [EOL] self . assertRaises ( wiredtiger . WiredTigerError , lambda : self . session . query_timestamp ( [string] + query ) ) [EOL] [EOL] def test_query_read_commit_timestamps ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] self . session . create ( self . uri , [string] + self . extra_config ) [EOL] [EOL] self . session . begin_transaction ( [string] ) [EOL] self . session . timestamp_transaction ( [string] ) [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . session . timestamp_transaction ( [string] ) [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] ) , [string] ) [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . session . timestamp_transaction ( [string] ) [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] ) , [string] ) [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] ) , [string] ) [EOL] self . session . commit_transaction ( ) [EOL] [EOL] def test_query_round_read_timestamp ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] self . session . create ( self . uri , [string] + self . extra_config ) [EOL] [EOL] self . conn . set_timestamp ( [string] ) [EOL] self . session . begin_transaction ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . timestamp_transaction ( [string] ) [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . conn . set_timestamp ( [string] ) [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] ) , [string] ) [EOL] self . session . commit_transaction ( ) [EOL] [EOL] def test_query_prepare_timestamp ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] self . session . create ( self . uri , [string] + self . extra_config ) [EOL] [EOL] self . session . begin_transaction ( ) [EOL] self . session . prepare_transaction ( [string] ) [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] ) , [string] ) [EOL] [EOL] self . session . timestamp_transaction ( [string] ) [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] ) , [string] ) [EOL] self . assertTimestampsEqual ( self . session . query_timestamp ( [string] ) , [string] ) [EOL] self . session . commit_transaction ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import fnmatch , os , time [EOL] import wiredtiger , wttest [EOL] from wtscenario import make_scenarios [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_config07 ( wttest . WiredTigerTestCase ) : [EOL] uri = [string] [EOL] entries = [number] [EOL] K = [number] [EOL] log_size = K * K [EOL] [EOL] extend_len = [ ( [string] , dict ( log_extend_len = [string] , expected_log_size = log_size ) ) , ( [string] , dict ( log_extend_len = [string] , expected_log_size = log_size ) ) , ( [string] , dict ( log_extend_len = [string] , expected_log_size = [number] ) ) , ( [string] , dict ( log_extend_len = [string] , expected_log_size = [number] * K ) ) , ( [string] , dict ( log_extend_len = [string] , expected_log_size = None ) ) , ( [string] , dict ( log_extend_len = [string] , expected_log_size = None ) ) , ( [string] , dict ( log_extend_len = [string] , expected_log_size = [number] * K ) ) , ( [string] , dict ( log_extend_len = [string] , expected_log_size = [number] * K ) ) , ( [string] , dict ( log_extend_len = [string] , expected_log_size = log_size ) ) , ( [string] , dict ( log_extend_len = [string] , expected_log_size = [number] * K ) ) , ] [EOL] [EOL] scenarios = make_scenarios ( extend_len ) [EOL] [EOL] def populate ( self ) : [EOL] cur = self . session . open_cursor ( self . uri , None , None ) [EOL] for i in range ( [number] , self . entries ) : [EOL] [comment] [EOL] [comment] [EOL] cur [ i ] = [string] * [number] [EOL] cur . close ( ) [EOL] [EOL] def checkLogFileSize ( self , size ) : [EOL] [comment] [EOL] [comment] [EOL] for i in range ( [number] , [number] ) : [EOL] logs = fnmatch . filter ( os . listdir ( [string] ) , [string] ) [EOL] if logs : [EOL] f = logs [ - [number] ] [EOL] file_size = os . stat ( f ) . st_size [EOL] self . assertEqual ( size , file_size ) [EOL] break [EOL] time . sleep ( [number] ) [EOL] self . assertTrue ( logs ) [EOL] [EOL] def test_log_extend ( self ) : [EOL] self . conn . close ( ) [EOL] msg = [string] [EOL] [EOL] config = [string] + self . log_extend_len [EOL] configarg = [string] + [string] + config [EOL] [EOL] [comment] [EOL] if self . expected_log_size is None : [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . wiredtiger_open ( [string] , configarg ) , msg ) [EOL] return [EOL] [EOL] self . conn = self . wiredtiger_open ( [string] , configarg ) [EOL] self . session = self . conn . open_session ( None ) [EOL] [EOL] [comment] [EOL] self . session . create ( self . uri , [string] ) [EOL] self . populate ( ) [EOL] self . session . checkpoint ( ) [EOL] [EOL] self . checkLogFileSize ( self . expected_log_size ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import os , shutil [EOL] import wiredtiger , wttest [EOL] from wtscenario import make_scenarios [EOL] [EOL] def timestamp_str ( t ) : [EOL] return [string] % t [EOL] [EOL] class test_backup08 ( wttest . WiredTigerTestCase ) : [EOL] conn_config = [string] [EOL] dir = [string] [EOL] coll1_uri = [string] [EOL] coll2_uri = [string] [EOL] coll3_uri = [string] [EOL] oplog_uri = [string] [EOL] [EOL] nentries = [number] [EOL] table_cnt = [number] [EOL] [EOL] types = [ ( [string] , dict ( use_stable = [string] ) ) , ( [string] , dict ( use_stable = [string] ) ) , ( [string] , dict ( use_stable = [string] ) ) , ] [EOL] scenarios = make_scenarios ( types ) [EOL] [EOL] def data_and_checkpoint ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . create ( self . oplog_uri , [string] ) [EOL] self . session . create ( self . coll1_uri , [string] ) [EOL] self . session . create ( self . coll2_uri , [string] ) [EOL] self . session . create ( self . coll3_uri , [string] ) [EOL] c_op = self . session . open_cursor ( self . oplog_uri ) [EOL] c = [ ] [EOL] c . append ( self . session . open_cursor ( self . coll1_uri ) ) [EOL] c . append ( self . session . open_cursor ( self . coll2_uri ) ) [EOL] c . append ( self . session . open_cursor ( self . coll3_uri ) ) [EOL] [EOL] [comment] [EOL] for table in range ( [number] , self . table_cnt + [number] ) : [EOL] curs = c [ table - [number] ] [EOL] start = self . nentries * table [EOL] end = start + self . nentries [EOL] ts = ( end - [number] ) [EOL] self . pr ( [string] + str ( table ) ) [EOL] for i in range ( start , end ) : [EOL] self . session . begin_transaction ( ) [EOL] c_op [ i ] = i [EOL] curs [ i ] = i [EOL] self . pr ( [string] + str ( i ) ) [EOL] self . session . commit_transaction ( [string] + timestamp_str ( i ) ) [EOL] [comment] [EOL] [comment] [EOL] self . pr ( [string] + str ( ts ) ) [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( ts ) + [string] + timestamp_str ( ts ) ) [EOL] [comment] [EOL] [comment] [EOL] expected = ts [EOL] ckpt_config = [string] [EOL] if self . use_stable == [string] : [EOL] expected = [number] [EOL] ckpt_config = [string] [EOL] elif self . use_stable == [string] : [EOL] ckpt_config = [string] [EOL] self . session . checkpoint ( ckpt_config ) [EOL] q = self . conn . query_timestamp ( [string] ) [EOL] self . assertTimestampsEqual ( q , timestamp_str ( expected ) ) [EOL] return expected [EOL] [EOL] def backup_and_recover ( self , expected_rec_ts ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] os . mkdir ( self . dir ) [EOL] cursor = self . session . open_cursor ( [string] ) [EOL] while True : [EOL] ret = cursor . next ( ) [EOL] if ret != [number] : [EOL] break [EOL] shutil . copy ( cursor . get_key ( ) , self . dir ) [EOL] self . assertEqual ( ret , wiredtiger . WT_NOTFOUND ) [EOL] cursor . close ( ) [EOL] [EOL] backup_conn = self . wiredtiger_open ( self . dir ) [EOL] q = backup_conn . query_timestamp ( [string] ) [EOL] self . pr ( [string] + q ) [EOL] self . assertTimestampsEqual ( q , timestamp_str ( expected_rec_ts ) ) [EOL] [EOL] def test_timestamp_backup ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ckpt_ts = self . data_and_checkpoint ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . backup_and_recover ( ckpt_ts ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import os [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_util16 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] tablename = [string] [EOL] tablename2 = [string] [EOL] nentries = [number] [EOL] [EOL] def test_rename_process ( self ) : [EOL] [docstring] [EOL] params = [string] [EOL] self . session . create ( [string] + self . tablename , params ) [EOL] self . assertTrue ( os . path . exists ( self . tablename + [string] ) ) [EOL] cursor = self . session . open_cursor ( [string] + self . tablename , None , None ) [EOL] for i in range ( [number] , self . nentries ) : [EOL] cursor [ str ( i ) ] = str ( i ) [EOL] cursor . close ( ) [EOL] [EOL] self . runWt ( [ [string] , [string] + self . tablename , [string] + self . tablename2 ] ) [EOL] self . assertTrue ( os . path . exists ( self . tablename2 + [string] ) ) [EOL] cursor = self . session . open_cursor ( [string] + self . tablename2 , None , None ) [EOL] count = [number] [EOL] while cursor . next ( ) == [number] : [EOL] count += [number] [EOL] cursor . close ( ) [EOL] self . assertEquals ( self . nentries , count ) [EOL] [EOL] self . runWt ( [ [string] , [string] + self . tablename2 , [string] + self . tablename ] ) [EOL] self . assertTrue ( os . path . exists ( self . tablename + [string] ) ) [EOL] cursor = self . session . open_cursor ( [string] + self . tablename , None , None ) [EOL] count = [number] [EOL] while cursor . next ( ) == [number] : [EOL] count += [number] [EOL] cursor . close ( ) [EOL] self . assertEquals ( self . nentries , count ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Dict [EOL] import typing [EOL] import string , os [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_util01 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] [docstring] [EOL] [EOL] tablename = [string] [EOL] nentries = [number] [EOL] stringclass = [string] . __class__ [EOL] [EOL] def compare_config ( self , expected_cfg , actual_cfg ) : [EOL] [comment] [EOL] [comment] [EOL] da = dict ( kv . split ( [string] ) for kv in actual_cfg . strip ( ) . replace ( [string] , [string] ) . split ( [string] ) ) [EOL] de = da . copy ( ) [EOL] de . update ( kv . split ( [string] ) for kv in expected_cfg . strip ( ) . split ( [string] ) ) [EOL] return da == de [EOL] [EOL] def compare_files ( self , filename1 , filename2 ) : [EOL] inheader = isconfig = False [EOL] for l1 , l2 in zip ( open ( filename1 , [string] ) , open ( filename2 , [string] ) ) : [EOL] if isconfig : [EOL] if not self . compare_config ( l1 , l2 ) : [EOL] return False [EOL] elif l1 != l2 : [EOL] return False [EOL] if inheader : [EOL] isconfig = not isconfig [EOL] if l1 . strip ( ) == [string] : [EOL] inheader = True [EOL] if l1 . strip ( ) == [string] : [EOL] inheader = isconfig = False [EOL] return True [EOL] [EOL] def get_string ( self , i , len ) : [EOL] [docstring] [EOL] ret = [string] [EOL] if i == [number] : [EOL] for j in range ( [number] , len ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ret += chr ( j % [number] + [number] ) [EOL] else : [EOL] for j in range ( [number] , len / [number] ) : [EOL] k = i + j [EOL] [comment] [EOL] ret += chr ( k % [number] + [number] ) + chr ( ( k * [number] ) % [number] + [number] ) + chr ( ( k * [number] ) % [number] + [number] ) [EOL] return ret [EOL] [EOL] def get_key ( self , i ) : [EOL] return ( [string] % i ) + [string] + self . get_string ( i , [number] ) [EOL] [EOL] def get_value ( self , i ) : [EOL] return self . get_string ( i , [number] ) [EOL] [EOL] def dumpstr ( self , s , hexoutput ) : [EOL] [docstring] [EOL] result = [string] [EOL] for c in s : [EOL] if hexoutput : [EOL] result += [string] % ord ( c ) [EOL] elif c == [string] : [EOL] result += [string] [EOL] elif c == [string] or ( c in string . printable and not c in string . whitespace ) : [EOL] result += c [EOL] else : [EOL] result += [string] + [string] % ord ( c ) [EOL] if hexoutput : [EOL] result += [string] [EOL] else : [EOL] result += [string] [EOL] return result [EOL] [EOL] def table_config ( self ) : [EOL] return [string] [EOL] [EOL] def dump ( self , usingapi , hexoutput ) : [EOL] params = self . table_config ( ) [EOL] self . session . create ( [string] + self . tablename , params ) [EOL] cursor = self . session . open_cursor ( [string] + self . tablename , None , None ) [EOL] ver = wiredtiger . wiredtiger_version ( ) [EOL] verstring = str ( ver [ [number] ] ) + [string] + str ( ver [ [number] ] ) + [string] + str ( ver [ [number] ] ) [EOL] with open ( [string] , [string] ) as expectout : [EOL] if not usingapi : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] expectout . write ( [string] + verstring + [string] ) [EOL] if hexoutput : [EOL] expectout . write ( [string] ) [EOL] else : [EOL] expectout . write ( [string] ) [EOL] expectout . write ( [string] ) [EOL] expectout . write ( [string] + self . tablename + [string] ) [EOL] expectout . write ( [string] + params + [string] ) [EOL] expectout . write ( [string] ) [EOL] for i in range ( [number] , self . nentries ) : [EOL] key = self . get_key ( i ) [EOL] value = self . get_value ( i ) [EOL] cursor [ key ] = value [EOL] expectout . write ( self . dumpstr ( key , hexoutput ) ) [EOL] expectout . write ( self . dumpstr ( value , hexoutput ) ) [EOL] cursor . close ( ) [EOL] [EOL] self . pr ( [string] ) [EOL] with open ( [string] , [string] ) as dumpout : [EOL] if usingapi : [EOL] if hexoutput : [EOL] dumpopt = [string] [EOL] else : [EOL] dumpopt = [string] [EOL] dumpcurs = self . session . open_cursor ( [string] + self . tablename , None , dumpopt ) [EOL] for key , val in dumpcurs : [EOL] dumpout . write ( str ( key ) + [string] + str ( val ) + [string] ) [EOL] dumpcurs . close ( ) [EOL] else : [EOL] dumpargs = [ [string] ] [EOL] if hexoutput : [EOL] dumpargs . append ( [string] ) [EOL] dumpargs . append ( self . tablename ) [EOL] self . runWt ( dumpargs , outfilename = [string] ) [EOL] [EOL] self . assertTrue ( self . compare_files ( [string] , [string] ) ) [EOL] [EOL] def test_dump_process ( self ) : [EOL] self . dump ( False , False ) [EOL] [EOL] def test_dump_process_hex ( self ) : [EOL] self . dump ( False , True ) [EOL] [EOL] def test_dump_api ( self ) : [EOL] self . dump ( True , False ) [EOL] [EOL] def test_dump_api_hex ( self ) : [EOL] self . dump ( True , True ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import os , time [EOL] import wiredtiger , wttest [EOL] from wtdataset import SimpleDataSet , ComplexDataSet [EOL] from wtscenario import make_scenarios [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_upgrade ( wttest . WiredTigerTestCase ) : [EOL] name = [string] [EOL] [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( uri = [string] ) ) , ( [string] , dict ( uri = [string] ) ) ] ) [EOL] [EOL] [comment] [EOL] def upgrade ( self , dataset , with_cursor ) : [EOL] uri = self . uri + self . name [EOL] dataset ( self , uri , [number] ) . populate ( ) [EOL] [EOL] [comment] [EOL] if with_cursor : [EOL] cursor = self . session . open_cursor ( uri , None , None ) [EOL] self . assertRaises ( wiredtiger . WiredTigerError , lambda : self . session . drop ( uri , None ) ) [EOL] cursor . close ( ) [EOL] [EOL] self . session . upgrade ( uri , None ) [EOL] self . session . drop ( uri ) [EOL] [EOL] [comment] [EOL] def test_upgrade ( self ) : [EOL] [comment] [EOL] self . upgrade ( SimpleDataSet , False ) [EOL] self . upgrade ( SimpleDataSet , True ) [EOL] [EOL] [comment] [EOL] if self . uri == [string] : [EOL] self . upgrade ( ComplexDataSet , False ) [EOL] self . upgrade ( ComplexDataSet , True ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from helper import copy_wiredtiger_home [EOL] import random [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] from wtscenario import make_scenarios [EOL] [EOL] def timestamp_str ( t ) : [EOL] return [string] % t [EOL] [EOL] class test_prepare_lookaside02 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] tablename = [string] [EOL] uri = [string] + tablename [EOL] txn_config = [string] [EOL] [EOL] types = [ ( [string] , dict ( s_config = [string] ) ) , ( [string] , dict ( s_config = [string] ) ) , ( [string] , dict ( s_config = [string] ) ) , ] [EOL] [EOL] [comment] [EOL] txn_end = [ ( [string] , dict ( txn_commit = True ) ) , ( [string] , dict ( txn_commit = False ) ) , ] [EOL] [EOL] scenarios = make_scenarios ( types , txn_end ) [EOL] [EOL] def test_prepare_conflict ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] self . session . create ( self . uri , self . s_config ) [EOL] c = self . session . open_cursor ( self . uri ) [EOL] [EOL] [comment] [EOL] orig_keys = range ( [number] , [number] ) [EOL] keys = orig_keys [ : ] [EOL] random . shuffle ( keys ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . session . begin_transaction ( self . txn_config ) [EOL] c [ [number] ] = [number] [EOL] [comment] [EOL] self . session . prepare_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] if self . txn_commit == True : [EOL] self . session . commit_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] else : [EOL] self . session . rollback_transaction ( ) [EOL] [EOL] [comment] [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] self . session . checkpoint ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . begin_transaction ( self . txn_config ) [EOL] [comment] [EOL] c [ [number] ] = [number] [EOL] [comment] [EOL] c [ [number] ] = [number] [EOL] c [ [number] ] = [number] [EOL] self . session . prepare_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] if self . txn_commit == True : [EOL] self . session . commit_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] else : [EOL] self . session . rollback_transaction ( ) [EOL] [EOL] [comment] [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] self . session . checkpoint ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . begin_transaction ( self . txn_config ) [EOL] [comment] [EOL] c . set_key ( [number] ) [EOL] c . remove ( ) [EOL] c . set_key ( [number] ) [EOL] c . remove ( ) [EOL] c [ [number] ] = [number] [EOL] c [ [number] ] = [number] [EOL] c . set_key ( [number] ) [EOL] c . remove ( ) [EOL] self . session . prepare_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] if self . txn_commit == True : [EOL] self . session . commit_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] else : [EOL] self . session . rollback_transaction ( ) [EOL] [EOL] [comment] [EOL] self . session . begin_transaction ( self . txn_config ) [EOL] c [ [number] ] = [number] [EOL] c [ [number] ] = [number] [EOL] c [ [number] ] = [number] [EOL] self . session . commit_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] [EOL] [comment] [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] self . session . checkpoint ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . reopen_conn ( ) [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] [EOL] self . session . create ( self . uri , self . s_config ) [EOL] cur = self . session . open_cursor ( self . uri ) [EOL] self . session . begin_transaction ( self . txn_config ) [EOL] cur [ [number] ] = [number] [EOL] cur [ [number] ] = [number] [EOL] cur [ [number] ] = [number] [EOL] [comment] [EOL] cur [ [number] ] = [number] [EOL] [comment] [EOL] cur . set_key ( [number] ) [EOL] cur . remove ( ) [EOL] self . session . prepare_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] if self . txn_commit == True : [EOL] self . session . commit_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] else : [EOL] self . session . rollback_transaction ( ) [EOL] [EOL] [comment] [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] self . session . checkpoint ( ) [EOL] [EOL] cur . close ( ) [EOL] self . session . close ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 $builtins.range$ 0 $builtins.range$ 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import fnmatch , os , shutil , time [EOL] from wtscenario import make_scenarios [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def corrupt ( fname , truncate , offset , writeit ) : [EOL] with open ( fname , [string] ) as log : [EOL] if offset : [EOL] if offset < [number] : [comment] [EOL] log . seek ( [number] , [number] ) [EOL] else : [EOL] log . seek ( offset ) [EOL] if truncate : [EOL] log . truncate ( ) [EOL] if writeit : [EOL] log . write ( writeit ) [EOL] [EOL] class test_txn19 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] base_config = [string] + [string] [EOL] conn_config = base_config [EOL] corruption_type = [ ( [string] , dict ( kind = [string] , f = lambda fname : os . remove ( fname ) ) ) , ( [string] , dict ( kind = [string] , f = lambda fname : corrupt ( fname , True , [number] , None ) ) ) , ( [string] , dict ( kind = [string] , f = lambda fname : corrupt ( fname , True , [number] * [number] , None ) ) ) , ( [string] , dict ( kind = [string] , f = lambda fname : corrupt ( fname , False , [number] , [string] * [number] ) ) ) , ( [string] , dict ( kind = [string] , f = lambda fname : corrupt ( fname , True , [number] , [string] * [number] ) ) ) , ( [string] , dict ( kind = [string] , f = lambda fname : corrupt ( fname , False , - [number] , [string] * [number] ) ) ) , ( [string] , dict ( kind = [string] , f = lambda fname : corrupt ( fname , False , [number] , [string] * [number] ) ) ) , ( [string] , dict ( kind = [string] , f = lambda fname : corrupt ( fname , False , [number] * [number] , [string] * [number] ) ) ) , ( [string] , dict ( kind = [string] , f = lambda fname : corrupt ( fname , False , - [number] , [string] * [number] ) ) ) , ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] corruption_pos = [ ( [string] + str ( x ) + [string] + str ( y ) + [string] + str ( z ) , dict ( corruptpos = x , corruptpos2 = y , chkpt = z ) ) for ( x , y , z ) in ( ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ) ] [EOL] nrecords = [ ( [string] , dict ( nrecords = [number] ) ) , ( [string] , dict ( nrecords = [number] ) ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def includeFunc ( name , dictarg ) : [EOL] kind = dictarg [ [string] ] [EOL] corruptpos = dictarg [ [string] ] [EOL] chkpt = dictarg [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if corruptpos == [number] : [EOL] return kind == [string] [EOL] [EOL] [comment] [EOL] return True [EOL] [EOL] scenarios = make_scenarios ( corruption_type , corruption_pos , nrecords , include = includeFunc , prune = [number] , prunelong = [number] ) [EOL] [EOL] uri = [string] [EOL] create_params = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def record_to_logfile ( self , recordnum ) : [EOL] return recordnum / [number] + [number] [EOL] [EOL] [comment] [EOL] def logfile_to_record ( self , logfile ) : [EOL] return ( logfile - [number] ) * [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def corrupted ( self ) : [EOL] [comment] [EOL] if self . corruptpos == [number] : [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . kind == [string] : [EOL] return False [EOL] return True [EOL] [EOL] def show_logs ( self , homedir , msg ) : [EOL] loglist = [ ] [EOL] for i in range ( [number] , [number] ) : [EOL] basename = [string] + str ( i ) [EOL] fullname = homedir + os . sep + basename [EOL] if os . path . isfile ( fullname ) : [EOL] loglist . append ( i ) [EOL] if os . stat ( fullname ) . st_size == [number] : [EOL] self . tty ( [string] + msg + [string] + str ( i ) + [string] ) [EOL] self . tty ( [string] + msg + [string] + str ( loglist ) ) [EOL] [EOL] def copy_for_crash_restart ( self , olddir , newdir ) : [EOL] [docstring] [EOL] [comment] [EOL] shutil . rmtree ( newdir , ignore_errors = True ) [EOL] os . mkdir ( newdir ) [EOL] for fname in os . listdir ( olddir ) : [EOL] fullname = os . path . join ( olddir , fname ) [EOL] [comment] [EOL] if os . path . isfile ( fullname ) and [string] not in fullname and [string] not in fullname and [string] not in fullname : [EOL] shutil . copy ( fullname , newdir ) [EOL] [EOL] [comment] [EOL] def valuegen ( self , i ) : [EOL] return str ( i ) + [string] * ( [number] * [number] ) [comment] [EOL] [EOL] [comment] [EOL] def inserts ( self , keylist ) : [EOL] c = self . session . open_cursor ( self . uri ) [EOL] for i in keylist : [EOL] if self . chkpt > [number] and self . logfile_to_record ( self . chkpt ) == i : [EOL] self . session . checkpoint ( ) [EOL] c [ i ] = self . valuegen ( i ) [EOL] c . close ( ) [EOL] [EOL] def checks ( self , expectlist ) : [EOL] c = self . session . open_cursor ( self . uri , None , None ) [EOL] gotlist = [ ] [EOL] for key , value in c : [EOL] gotlist . append ( key ) [EOL] self . assertEqual ( self . valuegen ( key ) , value ) [EOL] self . assertEqual ( expectlist , gotlist ) [EOL] c . close ( ) [EOL] [EOL] def log_number_to_file_name ( self , homedir , n ) : [EOL] self . assertLess ( n , [number] ) [comment] [EOL] return homedir + os . sep + [string] + str ( n ) [EOL] [EOL] def corrupt_log ( self , homedir ) : [EOL] if not self . corrupted ( ) : [EOL] return [EOL] self . f ( self . log_number_to_file_name ( homedir , self . corruptpos ) ) [EOL] [EOL] [comment] [EOL] if self . corruptpos2 != [number] : [EOL] self . f ( self . log_number_to_file_name ( homedir , self . corruptpos2 ) ) [EOL] [EOL] def corrupt_last_file ( self ) : [EOL] return self . corruptpos == self . record_to_logfile ( self . nrecords ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def corrupt_hole_in_last_file ( self ) : [EOL] return self . corrupt_last_file ( ) and ( ( self . kind == [string] and self . nrecords % [number] == [number] ) or self . kind == [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def log_corrupt_but_valid ( self ) : [EOL] if self . corrupt_last_file ( ) and self . kind == [string] : [EOL] return True [EOL] if self . kind == [string] or self . kind == [string] or self . kind == [string] : [EOL] return True [EOL] return False [EOL] [EOL] [comment] [EOL] def expect_warning_corruption ( self ) : [EOL] if self . kind == [string] and self . chkpt <= self . corruptpos : [EOL] return True [EOL] if self . corrupt_hole_in_last_file ( ) : [EOL] return True [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] def expect_salvage_messages ( self ) : [EOL] return self . expect_recovery_failure ( ) [EOL] [EOL] def expect_recovery_failure ( self ) : [EOL] return self . corrupted ( ) and self . corruptpos >= self . chkpt and not self . log_corrupt_but_valid ( ) [EOL] [EOL] def recovered_records ( self ) : [EOL] if not self . corrupted ( ) or self . chkpt > self . corruptpos : [EOL] return self . nrecords [EOL] if self . kind == [string] : [EOL] [comment] [EOL] found = self . logfile_to_record ( self . corruptpos + [number] ) [EOL] else : [EOL] found = self . logfile_to_record ( self . corruptpos ) [EOL] return min ( found , self . nrecords ) [EOL] [EOL] def test_corrupt_log ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] self . session . create ( self . uri , self . create_params ) [EOL] self . inserts ( [ x for x in range ( [number] , self . nrecords ) ] ) [EOL] newdir = [string] [EOL] self . copy_for_crash_restart ( self . home , newdir ) [EOL] self . close_conn ( ) [EOL] [comment] [EOL] self . corrupt_log ( newdir ) [EOL] [comment] [EOL] salvage_config = self . base_config + [string] [EOL] errfile = [string] [EOL] outfile = [string] [EOL] expect_fail = self . expect_recovery_failure ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . runWt ( [ [string] , newdir , [string] , self . base_config , [string] , [string] ] , errfilename = errfile , outfilename = outfile , failure = expect_fail , closeconn = False ) [EOL] [EOL] if expect_fail : [EOL] self . check_file_contains_one_of ( errfile , [ [string] , [string] , [string] ] ) [EOL] else : [EOL] self . check_empty_file ( errfile ) [EOL] if self . expect_warning_corruption ( ) : [EOL] self . check_file_contains ( outfile , [string] ) [EOL] self . check_file_contains ( outfile , self . uri ) [EOL] [EOL] found_records = self . recovered_records ( ) [EOL] expect = [ x for x in range ( [number] , found_records ) ] [EOL] [EOL] [comment] [EOL] if self . expect_salvage_messages ( ) : [EOL] errpat = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . kind == [string] : [EOL] outpat = [string] [EOL] else : [EOL] outpat = [string] [EOL] else : [EOL] errpat = [string] [EOL] outpat = [string] [EOL] with self . expectedStdoutPattern ( outpat ) : [EOL] with self . expectedStderrPattern ( errpat ) : [EOL] self . conn = self . wiredtiger_open ( newdir , salvage_config ) [EOL] self . session = self . setUpSessionOpen ( self . conn ) [EOL] self . checks ( expect ) [EOL] [EOL] [comment] [EOL] newdir2 = [string] [EOL] self . inserts ( [ self . nrecords , self . nrecords + [number] ] ) [EOL] expect . extend ( [ self . nrecords , self . nrecords + [number] ] ) [EOL] self . copy_for_crash_restart ( newdir , newdir2 ) [EOL] self . checks ( expect ) [EOL] self . reopen_conn ( newdir ) [EOL] self . checks ( expect ) [EOL] self . reopen_conn ( newdir2 , self . conn_config ) [EOL] self . checks ( expect ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import os [EOL] import wiredtiger , wttest [EOL] from wtdataset import SimpleDataSet [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_bug020 ( wttest . WiredTigerTestCase ) : [EOL] def test_bug020 ( self ) : [EOL] SimpleDataSet ( self , [string] , [number] ) . populate ( ) [EOL] self . close_conn ( ) [EOL] os . rename ( [string] , [string] ) [EOL] expectMessage = [string] [EOL] with self . expectedStdoutPattern ( expectMessage ) : [EOL] self . open_conn ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import wiredtiger , wttest [EOL] from wtdataset import SimpleDataSet [EOL] from wtscenario import make_scenarios [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class test_cursor_pin ( wttest . WiredTigerTestCase ) : [EOL] uri = [string] [EOL] nentries = [number] [EOL] config = [string] [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( keyfmt = [string] ) ) , ( [string] , dict ( keyfmt = [string] ) ) , ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_smoke ( self ) : [EOL] ds = SimpleDataSet ( self , self . uri , self . nentries , config = self . config , key_format = self . keyfmt ) [EOL] ds . populate ( ) [EOL] self . reopen_conn ( ) [EOL] c = self . session . open_cursor ( self . uri , None ) [EOL] c . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( c . search ( ) , [number] ) [EOL] self . assertEqual ( c . get_value ( ) , ds . value ( [number] ) ) [EOL] c . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( c . search ( ) , [number] ) [EOL] self . assertEqual ( c . get_value ( ) , ds . value ( [number] ) ) [EOL] c . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( c . search ( ) , [number] ) [EOL] self . assertEqual ( c . get_value ( ) , ds . value ( [number] ) ) [EOL] [EOL] [comment] [EOL] def forward ( self , c , ds , max , notfound ) : [EOL] for i in range ( [number] , max + [number] ) : [EOL] c . set_key ( ds . key ( i ) ) [EOL] if i in notfound : [EOL] self . assertEqual ( c . search ( ) , wiredtiger . WT_NOTFOUND ) [EOL] else : [EOL] self . assertEqual ( c . search ( ) , [number] ) [EOL] self . assertEqual ( c . get_value ( ) , ds . value ( i ) ) [EOL] [EOL] [comment] [EOL] def backward ( self , c , ds , max , notfound ) : [EOL] for i in range ( max , [number] , - [number] ) : [EOL] c . set_key ( ds . key ( i ) ) [EOL] if i in notfound : [EOL] self . assertEqual ( c . search ( ) , wiredtiger . WT_NOTFOUND ) [EOL] else : [EOL] self . assertEqual ( c . search ( ) , [number] ) [EOL] self . assertEqual ( c . get_value ( ) , ds . value ( i ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_basic ( self ) : [EOL] ds = SimpleDataSet ( self , self . uri , self . nentries , config = self . config , key_format = self . keyfmt ) [EOL] ds . populate ( ) [EOL] self . reopen_conn ( ) [EOL] c = self . session . open_cursor ( self . uri , None ) [EOL] self . forward ( c , ds , self . nentries , [ ] ) [EOL] self . backward ( c , ds , self . nentries , [ ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_missing ( self ) : [EOL] ds = SimpleDataSet ( self , self . uri , self . nentries , config = self . config , key_format = self . keyfmt ) [EOL] ds . populate ( ) [EOL] c = self . session . open_cursor ( self . uri , None ) [EOL] for i in range ( self . nentries + [number] , self . nentries + [number] ) : [EOL] c [ ds . key ( i ) ] = ds . value ( i ) [EOL] self . reopen_conn ( ) [EOL] c = self . session . open_cursor ( self . uri , None ) [EOL] self . forward ( c , ds , self . nentries + [number] , list ( range ( self . nentries + [number] , self . nentries + [number] ) ) ) [EOL] self . backward ( c , ds , self . nentries + [number] , list ( range ( self . nentries + [number] , self . nentries + [number] ) ) ) [EOL] [EOL] [comment] [EOL] for i in range ( self . nentries + [number] , self . nentries + [number] ) : [EOL] c [ ds . key ( i ) ] = ds . value ( i ) [EOL] self . forward ( c , ds , self . nentries + [number] , list ( range ( self . nentries + [number] , self . nentries + [number] ) + range ( self . nentries + [number] , self . nentries + [number] ) ) ) [EOL] self . backward ( c , ds , self . nentries + [number] , list ( range ( self . nentries + [number] , self . nentries + [number] ) + range ( self . nentries + [number] , self . nentries + [number] ) ) ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from helper import copy_wiredtiger_home [EOL] import wiredtiger , wttest [EOL] from wtdataset import SimpleDataSet [EOL] [EOL] def timestamp_str ( t ) : [EOL] return [string] % t [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_prepare_lookaside01 ( wttest . WiredTigerTestCase ) : [EOL] [comment] [EOL] def conn_config ( self ) : [EOL] return [string] [EOL] [EOL] def prepare_updates ( self , uri , ds , nrows , nsessions , nkeys ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] self . conn . set_timestamp ( [string] + timestamp_str ( [number] ) ) [EOL] [EOL] [comment] [EOL] bigvalue1 = [string] * [number] [EOL] cursor = self . session . open_cursor ( uri ) [EOL] for i in range ( [number] , nsessions * nkeys ) : [EOL] self . session . begin_transaction ( ) [EOL] cursor . set_key ( ds . key ( nrows + i ) ) [EOL] cursor . set_value ( bigvalue1 ) [EOL] self . assertEquals ( cursor . update ( ) , [number] ) [EOL] self . session . commit_transaction ( [string] + timestamp_str ( i ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] sessions = [ [number] ] * nsessions [EOL] cursors = [ [number] ] * nsessions [EOL] bigvalue2 = [string] * [number] [EOL] for j in range ( [number] , nsessions ) : [EOL] sessions [ j ] = self . conn . open_session ( ) [EOL] sessions [ j ] . begin_transaction ( [string] ) [EOL] cursors [ j ] = sessions [ j ] . open_cursor ( uri ) [EOL] [comment] [EOL] start = ( j * nkeys ) [EOL] end = start + nkeys [EOL] for i in range ( start , end ) : [EOL] cursors [ j ] . set_key ( ds . key ( nrows + i ) ) [EOL] cursors [ j ] . set_value ( bigvalue2 ) [EOL] self . assertEquals ( cursors [ j ] . update ( ) , [number] ) [EOL] sessions [ j ] . prepare_transaction ( [string] + timestamp_str ( [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] bigvalue3 = [string] * [number] [EOL] cursor = self . session . open_cursor ( uri ) [EOL] for i in range ( [number] , nsessions * nkeys ) : [EOL] self . session . begin_transaction ( ) [EOL] cursor . set_key ( ds . key ( nrows + i ) ) [EOL] cursor . set_value ( bigvalue3 ) [EOL] self . assertEquals ( cursor . update ( ) , [number] ) [EOL] self . session . commit_transaction ( [string] + timestamp_str ( i + [number] ) ) [EOL] cursor . close ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for j in range ( [number] , nsessions ) : [EOL] cursors [ j ] . close ( ) [EOL] sessions [ j ] . close ( ) [EOL] [EOL] def test_prepare_lookaside ( self ) : [EOL] if not wiredtiger . timestamp_build ( ) : [EOL] self . skipTest ( [string] ) [EOL] [EOL] [comment] [EOL] uri = [string] [EOL] nrows = [number] [EOL] ds = SimpleDataSet ( self , uri , nrows , key_format = [string] , value_format = [string] ) [EOL] ds . populate ( ) [EOL] bigvalue = [string] * [number] [EOL] [EOL] [comment] [EOL] cursor = self . session . open_cursor ( uri ) [EOL] for i in range ( [number] , [number] ) : [EOL] cursor . set_key ( ds . key ( nrows + i ) ) [EOL] cursor . set_value ( bigvalue ) [EOL] self . assertEquals ( cursor . insert ( ) , [number] ) [EOL] cursor . close ( ) [EOL] self . session . checkpoint ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] nsessions = [number] [EOL] nkeys = [number] [EOL] self . prepare_updates ( uri , ds , nrows , nsessions , nkeys ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Literal , Type [EOL] import typing [EOL] import typing_extensions [EOL] import helper , wiredtiger , wttest [EOL] from wiredtiger import stat [EOL] from wtdataset import SimpleDataSet , simple_key [EOL] from wtscenario import make_scenarios [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_stat01 ( wttest . WiredTigerTestCase ) : [EOL] [docstring] [EOL] [EOL] config = [string] [EOL] nentries = [number] [EOL] [EOL] types = [ ( [string] , dict ( uri = [string] ) ) , ( [string] , dict ( uri = [string] ) ) ] [EOL] keyfmt = [ ( [string] , dict ( keyfmt = [string] ) ) , ( [string] , dict ( keyfmt = [string] ) ) , ] [EOL] scenarios = make_scenarios ( types , keyfmt ) [EOL] [EOL] conn_config = [string] [EOL] [EOL] def statstr_to_int ( self , str ) : [EOL] [docstring] [EOL] parts = str . rpartition ( [string] ) [EOL] return int ( parts [ [number] ] . rstrip ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def check_stats ( self , statcursor , min , lookfor ) : [EOL] stringclass = [string] . __class__ [EOL] intclass = [number] . __class__ [EOL] [EOL] [comment] [EOL] statcursor . reset ( ) [EOL] [EOL] found = False [EOL] foundval = [number] [EOL] for id , desc , valstr , val in statcursor : [EOL] self . assertEqual ( type ( desc ) , stringclass ) [EOL] self . assertEqual ( type ( valstr ) , stringclass ) [EOL] self . assertEqual ( type ( val ) , intclass ) [EOL] self . assertEqual ( val , self . statstr_to_int ( valstr ) ) [EOL] self . printVerbose ( [number] , [string] + desc + [string] + valstr + [string] + str ( val ) ) [EOL] if desc == lookfor : [EOL] found = True [EOL] foundval = val [EOL] [EOL] self . assertTrue ( found , [string] + lookfor ) [EOL] self . assertTrue ( foundval >= min ) [EOL] [EOL] [comment] [EOL] def test_basic_conn_stats ( self ) : [EOL] [comment] [EOL] SimpleDataSet ( self , self . uri , [number] , config = self . config , key_format = self . keyfmt ) . populate ( ) [EOL] self . session . checkpoint ( None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] allstat_cursor = self . session . open_cursor ( [string] , None , None ) [EOL] self . check_stats ( allstat_cursor , [number] , [string] ) [EOL] [EOL] values = allstat_cursor [ stat . conn . block_write ] [EOL] self . assertEqual ( values [ [number] ] , [string] ) [EOL] val = self . statstr_to_int ( values [ [number] ] ) [EOL] self . assertEqual ( val , values [ [number] ] ) [EOL] allstat_cursor . close ( ) [EOL] [EOL] [comment] [EOL] def test_basic_data_source_stats ( self ) : [EOL] [comment] [EOL] config = self . config + [string] + self . keyfmt [EOL] self . session . create ( self . uri , config ) [EOL] cursor = self . session . open_cursor ( self . uri , None , None ) [EOL] value = [string] [EOL] for i in range ( [number] , self . nentries ) : [EOL] value = value + [number] * [string] [EOL] cursor [ simple_key ( cursor , i ) ] = value [EOL] cursor . close ( ) [EOL] [EOL] [comment] [EOL] self . reopen_conn ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cursor = self . session . open_cursor ( [string] + self . uri , None , None ) [EOL] self . check_stats ( cursor , [number] , [string] ) [EOL] self . check_stats ( cursor , [number] , [string] ) [EOL] self . check_stats ( cursor , [number] , [string] ) [EOL] [EOL] values = cursor [ stat . dsrc . btree_overflow ] [EOL] self . assertEqual ( values [ [number] ] , [string] ) [EOL] val = self . statstr_to_int ( values [ [number] ] ) [EOL] self . assertEqual ( val , values [ [number] ] ) [EOL] cursor . close ( ) [EOL] [EOL] cursor = self . session . open_cursor ( [string] + self . uri , None , [string] ) [EOL] values = cursor [ stat . dsrc . block_size ] [EOL] self . assertNotEqual ( values [ [number] ] , [number] ) [EOL] cursor . close ( ) [EOL] [EOL] [comment] [EOL] def test_checkpoint_stats ( self ) : [EOL] ds = SimpleDataSet ( self , self . uri , self . nentries , config = self . config , key_format = self . keyfmt ) [EOL] for name in ( [string] , [string] , [string] ) : [EOL] ds . populate ( ) [EOL] self . session . checkpoint ( [string] + name ) [EOL] cursor = self . session . open_cursor ( [string] + self . uri , None , [string] + name ) [EOL] self . assertEqual ( cursor [ stat . dsrc . btree_entries ] [ [number] ] , self . nentries ) [EOL] cursor . close ( ) [EOL] [EOL] def test_missing_file_stats ( self ) : [EOL] self . assertRaises ( wiredtiger . WiredTigerError , lambda : self . session . open_cursor ( [string] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing_extensions.Literal]$ 0 0 0 0 0 $typing.Type[typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import wiredtiger , wttest [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_debug_info ( wttest . WiredTigerTestCase ) : [EOL] conn_config = [string] [EOL] uri = [string] [EOL] def conn_cursors ( self ) : [EOL] [EOL] self . session . create ( self . uri , [string] ) [EOL] c = self . session . open_cursor ( self . uri , None ) [EOL] keys = range ( [number] , [number] ) [EOL] for k in keys : [EOL] c [ k ] = [number] [EOL] c . close ( ) [EOL] c = self . session . open_cursor ( self . uri , None ) [EOL] val = c [ [number] ] [EOL] self . conn . debug_info ( [string] ) [EOL] c . close ( ) [EOL] [EOL] def conn_cursors_special ( self , special_uri ) : [EOL] c = self . session . open_cursor ( special_uri , None , None ) [EOL] self . conn . debug_info ( [string] ) [EOL] c . close ( ) [EOL] [EOL] def test_debug ( self ) : [EOL] with self . expectedStdoutPattern ( [string] ) : [EOL] self . conn . debug_info ( [string] ) [EOL] [EOL] with self . expectedStdoutPattern ( [string] ) : [EOL] self . conn . debug_info ( [string] ) [EOL] [EOL] with self . expectedStdoutPattern ( [string] ) : [EOL] self . conn_cursors ( ) [EOL] [EOL] special = [ [string] , [string] , [string] , [string] ] [EOL] for s in special : [EOL] pat = [string] + s [EOL] with self . expectedStdoutPattern ( pat ) : [EOL] self . conn_cursors_special ( s ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import io [EOL] import fnmatch , os , shutil , sys [EOL] from suite_subprocess import suite_subprocess [EOL] import wiredtiger , wttest [EOL] from wtscenario import make_scenarios [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class test_schema08 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] [comment] [EOL] [comment] [EOL] conn_config = [string] [EOL] types = [ ( [string] , dict ( uri = [string] , use_cg = False , use_index = False ) ) , ( [string] , dict ( uri = [string] , use_cg = False , use_index = False ) ) , ( [string] , dict ( uri = [string] , use_cg = True , use_index = False ) ) , ( [string] , dict ( uri = [string] , use_cg = False , use_index = True ) ) , ( [string] , dict ( uri = [string] , use_cg = False , use_index = False ) ) , ] [EOL] ops = [ ( [string] , dict ( schema_ops = [string] ) ) , ( [string] , dict ( schema_ops = [string] ) ) , ( [string] , dict ( schema_ops = [string] ) ) , ( [string] , dict ( schema_ops = [string] ) ) , ] [EOL] ckpt = [ ( [string] , dict ( ckpt = False ) ) , ( [string] , dict ( ckpt = True ) ) , ] [EOL] scenarios = make_scenarios ( types , ops , ckpt ) [EOL] count = [number] [EOL] lsns = [ ] [EOL] backup_pfx = [string] [EOL] [EOL] def do_alter ( self , uri , suburi ) : [EOL] alter_param = [string] [EOL] self . session . alter ( uri , alter_param ) [EOL] if suburi != None : [EOL] self . session . alter ( suburi , alter_param ) [EOL] [EOL] def do_ops ( self , uri , suburi ) : [EOL] if ( self . schema_ops == [string] ) : [EOL] return [EOL] if ( self . schema_ops == [string] ) : [EOL] self . do_alter ( uri , suburi ) [EOL] elif ( self . schema_ops == [string] ) : [EOL] self . session . drop ( uri , None ) [EOL] elif ( self . schema_ops == [string] ) : [EOL] newuri = self . uri + [string] [EOL] self . session . rename ( uri , newuri , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def find_logrecs ( self ) : [EOL] self . count = [number] [EOL] self . session . log_flush ( [string] ) [EOL] c = self . session . open_cursor ( [string] , None , None ) [EOL] self . lsns . append ( [number] ) [EOL] while c . next ( ) == [number] : [EOL] [comment] [EOL] keys = c . get_key ( ) [EOL] [comment] [EOL] [comment] [EOL] self . assertTrue ( keys [ [number] ] == [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if keys [ [number] ] == [number] and keys [ [number] ] != [number] : [EOL] self . count += [number] [EOL] self . lsns . append ( keys [ [number] ] ) [EOL] c . close ( ) [EOL] self . pr ( [string] + str ( self . count ) + [string] ) [EOL] self . pr ( str ( self . lsns ) ) [EOL] [EOL] def make_backups ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] olddir = [string] [EOL] log1 = [string] [EOL] for lsn in self . lsns : [EOL] newdir = self . backup_pfx + str ( lsn ) [EOL] shutil . rmtree ( newdir , ignore_errors = True ) [EOL] os . mkdir ( newdir ) [EOL] for fname in os . listdir ( olddir ) : [EOL] fullname = os . path . join ( olddir , fname ) [EOL] [comment] [EOL] if os . path . isfile ( fullname ) and [string] not in fullname and [string] not in fullname and [string] not in fullname : [EOL] shutil . copy ( fullname , newdir ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if lsn != [number] : [EOL] logf = os . path . join ( newdir + [string] + log1 ) [EOL] f = open ( logf , [string] ) [EOL] f . truncate ( lsn ) [EOL] f . close ( ) [EOL] [comment] [EOL] [EOL] def run_recovery ( self , uri , suburi ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] olddir = [string] [EOL] for lsn in self . lsns : [EOL] newdir = self . backup_pfx + str ( lsn ) [EOL] outfile = newdir + [string] [EOL] self . runWt ( [ [string] , [string] , newdir , [string] , [string] ] , outfilename = outfile ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_schema08_create ( self ) : [EOL] self . count = [number] [EOL] self . lsns = [ ] [EOL] uri = self . uri + [string] [EOL] create_params = [string] [EOL] [EOL] cgparam = [string] [EOL] suburi = None [EOL] if self . use_cg or self . use_index : [EOL] cgparam = [string] [EOL] if self . use_cg : [EOL] cgparam += [string] [EOL] [EOL] [comment] [EOL] self . session . create ( uri , create_params + cgparam ) [EOL] [EOL] [comment] [EOL] if self . ckpt : [EOL] self . session . checkpoint ( ) [EOL] [EOL] [comment] [EOL] if self . use_cg : [EOL] [comment] [EOL] cgparam = [string] [EOL] suburi = [string] [EOL] self . session . create ( suburi , cgparam ) [EOL] [EOL] if self . use_index : [EOL] [comment] [EOL] suburi = [string] [EOL] self . session . create ( suburi , cgparam ) [EOL] [EOL] self . do_ops ( uri , suburi ) [EOL] self . find_logrecs ( ) [EOL] [comment] [EOL] self . make_backups ( ) [EOL] self . run_recovery ( uri , suburi ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $io.TextIOWrapper$ 0 0 0 $builtins.str$ 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import itertools , wiredtiger , wttest [EOL] from suite_subprocess import suite_subprocess [EOL] from wtscenario import make_scenarios [EOL] from wiredtiger import stat [EOL] from wtdataset import SimpleDataSet , ComplexDataSet , ComplexLSMDataSet [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_stat_cursor_config ( wttest . WiredTigerTestCase ) : [EOL] pfx = [string] [EOL] conn_config = [string] [EOL] [EOL] uri = [ ( [string] , dict ( uri = [string] + pfx , dataset = SimpleDataSet , cfg = [string] ) ) , ( [string] , dict ( uri = [string] + pfx , dataset = SimpleDataSet , cfg = [string] ) ) , ( [string] , dict ( uri = [string] + pfx , dataset = SimpleDataSet , cfg = [string] , conn_config = [string] ) ) , ( [string] , dict ( uri = [string] + pfx , dataset = SimpleDataSet , cfg = [string] , conn_config = [string] ) ) , ( [string] , dict ( uri = [string] + pfx , dataset = ComplexDataSet , cfg = [string] ) ) , ( [string] , dict ( uri = [string] + pfx , dataset = ComplexLSMDataSet , cfg = [string] , conn_config = [string] ) ) , ] [EOL] [EOL] scenarios = make_scenarios ( uri ) [EOL] [EOL] def openAndWalkStatCursor ( self ) : [EOL] c = self . session . open_cursor ( [string] + self . uri , None , [string] ) [EOL] count = [number] [EOL] while c . next ( ) == [number] : [EOL] count += [number] [EOL] c . close ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_stat_cursor_size ( self ) : [EOL] ds = self . dataset ( self , self . uri , [number] , config = self . cfg ) [EOL] ds . populate ( ) [EOL] self . openAndWalkStatCursor ( ) [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] for i in range ( [number] , [number] + [number] ) : [EOL] if i % [number] == [number] : [EOL] self . openAndWalkStatCursor ( ) [EOL] cursor [ ds . key ( i ) ] = ds . value ( i ) [EOL] cursor . close ( ) [EOL] self . openAndWalkStatCursor ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import wiredtiger , wttest [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_join08 ( wttest . WiredTigerTestCase ) : [EOL] nentries = [number] [EOL] [EOL] [comment] [EOL] conn_config = [string] [EOL] [EOL] def gen_key ( self , i ) : [EOL] return [ i + [number] ] [EOL] [EOL] def gen_values ( self , i ) : [EOL] s = str ( i ) [EOL] rs = s [ : : - [number] ] [EOL] sort3 = ( self . nentries * ( i % [number] ) ) + i [comment] [EOL] return [ s , rs , sort3 ] [EOL] [EOL] def test_join_errors ( self ) : [EOL] self . session . create ( [string] , [string] [string] ) [EOL] self . session . create ( [string] , [string] [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] jc = self . session . open_cursor ( [string] , None , None ) [EOL] tc = self . session . open_cursor ( [string] , None , None ) [EOL] fc = self . session . open_cursor ( [string] , None , None ) [EOL] ic0 = self . session . open_cursor ( [string] , None , None ) [EOL] ic0again = self . session . open_cursor ( [string] , None , None ) [EOL] ic1 = self . session . open_cursor ( [string] , None , None ) [EOL] icB = self . session . open_cursor ( [string] , None , None ) [EOL] tcB = self . session . open_cursor ( [string] , None , None ) [EOL] [EOL] tc . set_key ( [number] ) [EOL] tc . set_value ( [string] , [string] ) [EOL] tc . insert ( ) [EOL] tcB . set_key ( [number] ) [EOL] tcB . set_value ( [string] , [string] ) [EOL] tcB . insert ( ) [EOL] fc . next ( ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( tc , ic0 , [string] ) , [string] ) [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , fc , [string] ) , [string] ) [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , ic0 , [string] ) , [string] ) [EOL] ic0 . set_key ( [string] ) [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , ic0 , [string] ) , [string] ) [EOL] ic0 . set_key ( [string] ) [EOL] self . assertEqual ( ic0 . search ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , ic0 , [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] ic0 . set_key ( [string] ) [EOL] ic0 . search ( ) [EOL] ic0again . next ( ) [EOL] icB . next ( ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , icB , [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , ic1 , [string] ) , [string] ) [EOL] ic1 . next ( ) [EOL] [EOL] [comment] [EOL] self . session . join ( jc , ic1 , [string] ) , [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , ic0 , [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] self . session . join ( jc , ic0 , [string] ) , [EOL] [EOL] bloom_config = [string] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , ic0 , [string] + bloom_config ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , ic0again , [string] + bloom_config ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , ic0again , [string] + bloom_config ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , ic0again , [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : self . session . join ( jc , ic0again , [string] [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] self . session . join ( jc , ic0again , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : jc . get_keys ( ) , [string] ) [EOL] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : jc . get_values ( ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : ic0 . next ( ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : ic0 . prev ( ) , [string] ) [EOL] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : ic0 . reset ( ) , [string] ) [EOL] [EOL] [comment] [EOL] msg = [string] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : jc . search ( ) , msg ) [EOL] [EOL] self . assertRaisesWithMessage ( wiredtiger . WiredTigerError , lambda : jc . prev ( ) , msg ) [EOL] [EOL] self . assertEquals ( jc . next ( ) , [number] ) [EOL] self . assertEquals ( jc . next ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] jc . close ( ) [EOL] self . assertEquals ( ic0 . next ( ) , wiredtiger . WT_NOTFOUND ) [EOL] self . assertEquals ( ic0 . prev ( ) , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def cursor_close_common ( self , joinfirst ) : [EOL] self . session . create ( [string] , [string] + [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] c = self . session . open_cursor ( [string] , None , None ) [EOL] for i in range ( [number] , self . nentries ) : [EOL] c . set_key ( * self . gen_key ( i ) ) [EOL] c . set_value ( * self . gen_values ( i ) ) [EOL] c . insert ( ) [EOL] c . close ( ) [EOL] [EOL] if joinfirst : [EOL] jc = self . session . open_cursor ( [string] , None , None ) [EOL] c0 = self . session . open_cursor ( [string] , None , None ) [EOL] c1 = self . session . open_cursor ( [string] , None , None ) [EOL] c0 . next ( ) [comment] [EOL] c1 . next ( ) [EOL] if not joinfirst : [EOL] jc = self . session . open_cursor ( [string] , None , None ) [EOL] self . session . join ( jc , c0 , [string] ) [EOL] self . session . join ( jc , c1 , [string] ) [EOL] self . session . close ( ) [EOL] self . session = None [EOL] [EOL] def test_cursor_close1 ( self ) : [EOL] self . cursor_close_common ( True ) [EOL] [EOL] def test_cursor_close2 ( self ) : [EOL] self . cursor_close_common ( False ) [EOL] [EOL] [comment] [EOL] def test_simple_stats ( self ) : [EOL] self . session . create ( [string] , [string] ) [EOL] self . session . create ( [string] , [string] ) [EOL] [EOL] cursor = self . session . open_cursor ( [string] , None , None ) [EOL] cursor [ [number] ] = [number] [EOL] cursor [ [number] ] = [number] [EOL] cursor [ [number] ] = [number] [EOL] cursor . close ( ) [EOL] [EOL] cursor = self . session . open_cursor ( [string] , None , None ) [EOL] cursor . set_key ( [number] ) [EOL] cursor . search ( ) [EOL] [EOL] jcursor = self . session . open_cursor ( [string] , None , None ) [EOL] self . session . join ( jcursor , cursor , [string] ) [EOL] [EOL] while jcursor . next ( ) == [number] : [EOL] [ k ] = jcursor . get_keys ( ) [EOL] [ v ] = jcursor . get_values ( ) [EOL] [EOL] statcur = self . session . open_cursor ( [string] , jcursor , None ) [EOL] found = False [EOL] while statcur . next ( ) == [number] : [EOL] [ desc , pvalue , value ] = statcur . get_values ( ) [EOL] [comment] [EOL] found = True [EOL] self . assertEquals ( found , True ) [EOL] [EOL] jcursor . close ( ) [EOL] cursor . close ( ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import os , struct [EOL] from suite_subprocess import suite_subprocess [EOL] from wtscenario import make_scenarios [EOL] import wiredtiger , wttest [EOL] from wiredtiger import stat [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_stat04 ( wttest . WiredTigerTestCase , suite_subprocess ) : [EOL] uripfx = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] keyfmt = [ ( [string] , dict ( keyfmt = [string] , valuefmt = [string] , storekind = [string] ) ) , ( [string] , dict ( keyfmt = [string] , valuefmt = [string] , storekind = [string] ) ) , ] [EOL] nentries = [ ( [string] , dict ( nentries = [number] , valuesize = [number] ) ) , ( [string] , dict ( nentries = [number] , valuesize = [number] ) ) , ( [string] , dict ( nentries = [number] , valuesize = [number] ) ) , ( [string] , dict ( nentries = [number] , valuesize = [number] ) ) , ] [EOL] scenarios = make_scenarios ( keyfmt , nentries ) [EOL] conn_config = [string] [EOL] [EOL] def init_test ( self ) : [EOL] self . valuepfx = self . valuesize * [string] [EOL] [EOL] def genkey ( self , n ) : [EOL] if self . keyfmt == [string] : [EOL] return [string] + str ( n ) [EOL] else : [EOL] return n + [number] [EOL] [EOL] def genvalue ( self , n ) : [EOL] if self . valuefmt == [string] : [EOL] return self . valuepfx + str ( n ) [EOL] else : [EOL] return n & [number] [EOL] [EOL] def checkcount ( self , uri , expectpairs ) : [EOL] statcursor = self . session . open_cursor ( [string] + uri , None , [string] ) [EOL] self . assertEqual ( statcursor [ stat . dsrc . btree_entries ] [ [number] ] , expectpairs ) [EOL] statcursor . close ( ) [EOL] [EOL] def test_stat_nentries ( self ) : [EOL] [docstring] [EOL] [EOL] self . init_test ( ) [EOL] uri = self . uripfx + self . storekind + [string] + str ( self . nentries ) [EOL] self . session . create ( uri , [string] + self . keyfmt + [string] + self . valuefmt ) [EOL] cursor = self . session . open_cursor ( uri , None , None ) [EOL] [EOL] count = [number] [EOL] [comment] [EOL] for i in range ( [number] , self . nentries ) : [EOL] if count % [number] == [number] : [EOL] self . checkcount ( uri , count ) [EOL] cursor [ self . genkey ( i ) ] = self . genvalue ( i ) [EOL] count += [number] [EOL] [EOL] [comment] [EOL] for i in range ( [number] , self . nentries / [number] ) : [EOL] cursor . set_key ( self . genkey ( i * [number] % self . nentries ) ) [EOL] if cursor . remove ( ) == [number] : [EOL] count -= [number] [EOL] self . checkcount ( uri , count ) [EOL] cursor . close ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . reopen_conn ( ) [EOL] self . checkcount ( uri , count ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import wiredtiger , wttest , exceptions [EOL] [EOL] [comment] [EOL] class test_autoclose ( wttest . WiredTigerTestCase ) : [EOL] [docstring] [EOL] uri = [string] [EOL] [EOL] def create_table ( self ) : [EOL] self . session . create ( self . uri , [string] ) [EOL] [EOL] def drop_table ( self ) : [EOL] self . session . drop ( self . uri , None ) [EOL] [EOL] def open_cursor ( self ) : [EOL] cursor = self . session . open_cursor ( self . uri , None , None ) [EOL] return cursor [EOL] [EOL] def test_close_cursor1 ( self ) : [EOL] [docstring] [EOL] self . create_table ( ) [EOL] [EOL] inscursor = self . open_cursor ( ) [EOL] inscursor [ [string] ] = [string] [EOL] inscursor . close ( ) [EOL] self . assertRaisesHavingMessage ( exceptions . RuntimeError , lambda : inscursor . next ( ) , [string] ) [EOL] self . drop_table ( ) [EOL] self . close_conn ( ) [EOL] [EOL] def test_close_cursor2 ( self ) : [EOL] [docstring] [EOL] self . create_table ( ) [EOL] [EOL] inscursor = self . open_cursor ( ) [EOL] inscursor [ [string] ] = [string] [EOL] self . session . close ( ) [EOL] self . assertRaisesHavingMessage ( exceptions . RuntimeError , lambda : inscursor . next ( ) , [string] ) [EOL] self . close_conn ( ) [EOL] [EOL] def test_close_cursor3 ( self ) : [EOL] [docstring] [EOL] self . create_table ( ) [EOL] [EOL] inscursor = self . open_cursor ( ) [EOL] inscursor [ [string] ] = [string] [EOL] self . close_conn ( ) [EOL] self . assertRaisesHavingMessage ( exceptions . RuntimeError , lambda : inscursor . next ( ) , [string] ) [EOL] [EOL] def test_close_cursor4 ( self ) : [EOL] [docstring] [EOL] self . create_table ( ) [EOL] inscursor = self . open_cursor ( ) [EOL] inscursor [ [string] ] = [string] [EOL] inscursor . set_key ( [string] ) [EOL] inscursor2 = self . session . open_cursor ( None , inscursor , None ) [EOL] self . session . truncate ( None , inscursor , inscursor2 , [string] ) [EOL] inscursor . close ( ) [EOL] inscursor2 . close ( ) [EOL] self . session . truncate ( self . uri , None , None , [string] ) [EOL] [EOL] def test_close_cursor5 ( self ) : [EOL] [docstring] [EOL] self . create_table ( ) [EOL] [EOL] inscursor = self . open_cursor ( ) [EOL] inscursor [ [string] ] = [string] [EOL] inscursor . set_key ( [string] ) [EOL] inscursor2 = self . session . open_cursor ( None , inscursor , None ) [EOL] inscursor . compare ( inscursor2 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] inscursor2 . close ( ) [EOL] self . assertRaises ( exceptions . TypeError , lambda : inscursor . compare ( inscursor2 ) ) [EOL] [EOL] inscursor2 = None [EOL] self . assertRaisesHavingMessage ( exceptions . RuntimeError , lambda : inscursor . compare ( inscursor2 ) , [string] ) [EOL] [EOL] def test_close_session1 ( self ) : [EOL] [docstring] [EOL] self . session . close ( ) [EOL] self . assertRaisesHavingMessage ( exceptions . RuntimeError , lambda : self . create_table ( ) , [string] ) [EOL] self . close_conn ( ) [EOL] [EOL] def test_close_session2 ( self ) : [EOL] [docstring] [EOL] self . close_conn ( ) [EOL] self . assertRaisesHavingMessage ( exceptions . RuntimeError , lambda : self . create_table ( ) , [string] ) [EOL] [EOL] def test_close_connection1 ( self ) : [EOL] [docstring] [EOL] conn = self . conn [EOL] self . close_conn ( ) [EOL] self . assertRaisesHavingMessage ( exceptions . RuntimeError , lambda : conn . open_session ( None ) , [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import wiredtiger , wttest [EOL] from wiredtiger import stat [EOL] [EOL] class test_bug009 ( wttest . WiredTigerTestCase ) : [EOL] name = [string] [EOL] uri = [string] + name [EOL] [EOL] def test_reconciliation_prefix_compression ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . session . create ( self . uri , [string] + [string] + [string] + [string] ) [EOL] [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cursor [ [string] ] = [string] * [number] [EOL] cursor [ [string] ] = [string] * [number] [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import wiredtiger , wttest [EOL] from wtdataset import SimpleDataSet [EOL] from wtscenario import make_scenarios [EOL] [EOL] [comment] [EOL] [comment] [EOL] class test_bug008 ( wttest . WiredTigerTestCase ) : [EOL] uri = [string] [comment] [EOL] scenarios = make_scenarios ( [ ( [string] , dict ( key_format = [string] , value_format = [string] , empty = [number] , colvar = [number] ) ) , ( [string] , dict ( key_format = [string] , value_format = [string] , empty = [number] , colvar = [number] ) ) , ( [string] , dict ( key_format = [string] , value_format = [string] , empty = [number] , colvar = [number] ) ) ] ) [EOL] [EOL] [comment] [EOL] def test_search_empty ( self ) : [EOL] [comment] [EOL] ds = SimpleDataSet ( self , self . uri , [number] , key_format = self . key_format , value_format = self . value_format ) [EOL] ds . create ( ) [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] [EOL] [comment] [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . search ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [EOL] [comment] [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . search_near ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_search_eot ( self ) : [EOL] [comment] [EOL] [comment] [EOL] ds = SimpleDataSet ( self , self . uri , [number] , key_format = self . key_format , value_format = self . value_format ) [EOL] ds . populate ( ) [EOL] self . reopen_conn ( ) [EOL] [EOL] [comment] [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] [EOL] [comment] [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . search ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . get_value ( ) , ds . value ( [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . search_near ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . get_value ( ) , ds . value ( [number] ) ) [EOL] [EOL] [comment] [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . search ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . search_near ( ) , - [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . get_value ( ) , ds . value ( [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_search_duplicate ( self ) : [EOL] if self . colvar == [number] : [EOL] return [EOL] [EOL] [comment] [EOL] ds = SimpleDataSet ( self , self . uri , [number] , key_format = self . key_format , value_format = self . value_format ) [EOL] ds . populate ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] for i in range ( [number] , [number] ) : [EOL] cursor [ ds . key ( i ) ] = [string] [EOL] for i in range ( [number] , [number] ) : [EOL] cursor . set_key ( ds . key ( i ) ) [EOL] self . assertEqual ( cursor . remove ( ) , [number] ) [EOL] for i in range ( [number] , [number] ) : [EOL] cursor . set_key ( ds . key ( i ) ) [EOL] self . assertEqual ( cursor . remove ( ) , [number] ) [EOL] cursor . close ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . reopen_conn ( ) [EOL] [EOL] [comment] [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . search_near ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , ds . key ( [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . search_near ( ) , - [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , ds . key ( [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_search_invisible_one ( self ) : [EOL] [comment] [EOL] ds = SimpleDataSet ( self , self . uri , [number] , key_format = self . key_format , value_format = self . value_format ) [EOL] ds . populate ( ) [EOL] [EOL] [comment] [EOL] for i in range ( [number] , [number] ) : [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] cursor . set_key ( ds . key ( i ) ) [EOL] self . assertEqual ( cursor . remove ( ) , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . reopen_conn ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . session . begin_transaction ( ) [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] for i in range ( [number] , [number] ) : [EOL] cursor [ ds . key ( i ) ] = ds . value ( i + [number] ) [EOL] for i in range ( [number] , [number] ) : [EOL] cursor [ ds . key ( i ) ] = ds . value ( i + [number] ) [EOL] for i in range ( [number] , [number] ) : [EOL] cursor [ ds . key ( i ) ] = ds . value ( i + [number] ) [EOL] [EOL] [comment] [EOL] s = self . conn . open_session ( ) [EOL] cursor = s . open_cursor ( self . uri , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( [number] , [number] ) : [EOL] cursor . set_key ( ds . key ( i ) ) [EOL] if self . empty : [EOL] [comment] [EOL] self . assertEqual ( cursor . search ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , i ) [EOL] self . assertEqual ( cursor . get_value ( ) , [number] ) [EOL] else : [EOL] self . assertEqual ( cursor . search ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( [number] , [number] ) : [EOL] cursor . set_key ( ds . key ( i ) ) [EOL] self . assertEqual ( cursor . search ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , ds . key ( i ) ) [EOL] [EOL] [comment] [EOL] for i in range ( [number] , [number] ) : [EOL] cursor . set_key ( ds . key ( i ) ) [EOL] if self . empty : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( cursor . search ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , i ) [EOL] self . assertEqual ( cursor . get_value ( ) , [number] ) [EOL] else : [EOL] [comment] [EOL] self . assertEqual ( cursor . search ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( [number] , [number] ) : [EOL] cursor . set_key ( ds . key ( i ) ) [EOL] if self . empty : [EOL] [comment] [EOL] self . assertEqual ( cursor . search_near ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , i ) [EOL] self . assertEqual ( cursor . get_value ( ) , [number] ) [EOL] else : [EOL] self . assertEqual ( cursor . search_near ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , ds . key ( [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( [number] , [number] ) : [EOL] cursor . set_key ( ds . key ( i ) ) [EOL] self . assertEqual ( cursor . search_near ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , ds . key ( i ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( [number] , [number] ) : [EOL] cursor . set_key ( ds . key ( i ) ) [EOL] if self . empty : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( cursor . search_near ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , i ) [EOL] self . assertEqual ( cursor . get_value ( ) , [number] ) [EOL] else : [EOL] self . assertEqual ( cursor . search_near ( ) , - [number] ) [EOL] self . assertEqual ( cursor . get_key ( ) , ds . key ( [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_search_invisible_two ( self ) : [EOL] [comment] [EOL] [comment] [EOL] ds = SimpleDataSet ( self , self . uri , [number] , key_format = self . key_format , value_format = self . value_format ) [EOL] ds . populate ( ) [EOL] self . reopen_conn ( ) [EOL] [EOL] [comment] [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] for i in range ( [number] , [number] ) : [EOL] cursor [ ds . key ( i ) ] = ds . value ( i ) [EOL] cursor . close ( ) [EOL] [EOL] [comment] [EOL] self . session . begin_transaction ( ) [EOL] cursor = self . session . open_cursor ( self . uri , None ) [EOL] for i in range ( [number] , [number] ) : [EOL] cursor [ ds . key ( i ) ] = ds . value ( i ) [EOL] [EOL] [comment] [EOL] s = self . conn . open_session ( ) [EOL] cursor = s . open_cursor ( self . uri , None ) [EOL] [EOL] [comment] [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] if self . empty : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cursor . search ( ) [EOL] self . assertEqual ( cursor . get_key ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_value ( ) , [number] ) [EOL] else : [EOL] [comment] [EOL] self . assertEqual ( cursor . search ( ) , wiredtiger . WT_NOTFOUND ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cursor . set_key ( ds . key ( [number] ) ) [EOL] cursor . search_near ( ) [EOL] if self . empty : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cursor . search ( ) [EOL] self . assertEqual ( cursor . get_key ( ) , [number] ) [EOL] self . assertEqual ( cursor . get_value ( ) , [number] ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( cursor . get_key ( ) , ds . key ( [number] ) ) [EOL] self . assertEqual ( cursor . get_value ( ) , ds . value ( [number] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] wttest . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import email [EOL] import io [EOL] [docstring] [EOL] [EOL] from setuptools import setup [EOL] from distutils . command . build_py import build_py [EOL] import email [EOL] import os [EOL] import sys [EOL] [EOL] import testtools [EOL] cmd_class = { } [EOL] if getattr ( testtools , [string] , None ) is not None : [EOL] cmd_class [ [string] ] = testtools . TestCommand [EOL] [EOL] [EOL] class testtools_build_py ( build_py ) : [EOL] def build_module ( self , module , module_file , package ) : [EOL] if sys . version_info >= ( [number] , ) and module == [string] : [EOL] return [EOL] return build_py . build_module ( self , module , module_file , package ) [EOL] cmd_class [ [string] ] = testtools_build_py [EOL] [EOL] [EOL] def get_version_from_pkg_info ( ) : [EOL] [docstring] [EOL] pkg_info_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] try : [EOL] pkg_info_file = open ( pkg_info_path , [string] ) [EOL] except ( IOError , OSError ) : [EOL] return None [EOL] try : [EOL] pkg_info = email . message_from_file ( pkg_info_file ) [EOL] except email . MessageError : [EOL] return None [EOL] return pkg_info . get ( [string] , None ) [EOL] [EOL] [EOL] def get_version ( ) : [EOL] [docstring] [EOL] version = [string] . join ( str ( component ) for component in testtools . __version__ [ [number] : [number] ] ) [EOL] phase = testtools . __version__ [ [number] ] [EOL] if phase == [string] : [EOL] return version [EOL] pkg_info_version = get_version_from_pkg_info ( ) [EOL] if pkg_info_version : [EOL] return pkg_info_version [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [string] % ( version , ) [EOL] [EOL] [EOL] def get_long_description ( ) : [EOL] manual_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] return open ( manual_path ) . read ( ) [EOL] [EOL] [EOL] setup ( name = [string] , author = [string] , author_email = [string] , url = [string] , description = ( [string] [string] ) , long_description = get_long_description ( ) , version = get_version ( ) , classifiers = [ [string] , [string] , ] , packages = [ [string] , [string] , [string] , [string] , [string] , ] , cmdclass = cmd_class , zip_safe = False , install_requires = [ [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , List , Any , Iterator , Set [EOL] import typing [EOL] import unittest [EOL] import threading [EOL] [docstring] [EOL] [EOL] __metaclass__ = type [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] import sys [EOL] import threading [EOL] import unittest [EOL] [EOL] from extras import safe_hasattr , try_imports [EOL] [EOL] Queue = try_imports ( [ [string] , [string] ] ) [EOL] [EOL] import testtools [EOL] [EOL] [EOL] def iterate_tests ( test_suite_or_case ) : [EOL] [docstring] [EOL] try : [EOL] suite = iter ( test_suite_or_case ) [EOL] except TypeError : [EOL] yield test_suite_or_case [EOL] else : [EOL] for test in suite : [EOL] for subtest in iterate_tests ( test ) : [EOL] yield subtest [EOL] [EOL] [EOL] class ConcurrentTestSuite ( unittest . TestSuite ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , suite , make_tests , wrap_result = None ) : [EOL] [docstring] [EOL] super ( ConcurrentTestSuite , self ) . __init__ ( [ suite ] ) [EOL] self . make_tests = make_tests [EOL] if wrap_result : [EOL] self . _wrap_result = wrap_result [EOL] [EOL] def _wrap_result ( self , thread_safe_result , thread_number ) : [EOL] [docstring] [EOL] return thread_safe_result [EOL] [EOL] def run ( self , result ) : [EOL] [docstring] [EOL] tests = self . make_tests ( self ) [EOL] try : [EOL] threads = { } [EOL] queue = Queue ( ) [EOL] semaphore = threading . Semaphore ( [number] ) [EOL] for i , test in enumerate ( tests ) : [EOL] process_result = self . _wrap_result ( testtools . ThreadsafeForwardingResult ( result , semaphore ) , i ) [EOL] reader_thread = threading . Thread ( target = self . _run_test , args = ( test , process_result , queue ) ) [EOL] threads [ test ] = reader_thread , process_result [EOL] reader_thread . start ( ) [EOL] while threads : [EOL] finished_test = queue . get ( ) [EOL] threads [ finished_test ] [ [number] ] . join ( ) [EOL] del threads [ finished_test ] [EOL] except : [EOL] for thread , process_result in threads . values ( ) : [EOL] process_result . stop ( ) [EOL] raise [EOL] [EOL] def _run_test ( self , test , process_result , queue ) : [EOL] try : [EOL] try : [EOL] test . run ( process_result ) [EOL] except Exception as e : [EOL] [comment] [EOL] case = testtools . ErrorHolder ( [string] , error = sys . exc_info ( ) ) [EOL] case . run ( process_result ) [EOL] finally : [EOL] queue . put ( test ) [EOL] [EOL] [EOL] class ConcurrentStreamTestSuite ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , make_tests ) : [EOL] [docstring] [EOL] super ( ConcurrentStreamTestSuite , self ) . __init__ ( ) [EOL] self . make_tests = make_tests [EOL] [EOL] def run ( self , result ) : [EOL] [docstring] [EOL] tests = self . make_tests ( ) [EOL] try : [EOL] threads = { } [EOL] queue = Queue ( ) [EOL] for test , route_code in tests : [EOL] to_queue = testtools . StreamToQueue ( queue , route_code ) [EOL] process_result = testtools . ExtendedToStreamDecorator ( testtools . TimestampingStreamResult ( to_queue ) ) [EOL] runner_thread = threading . Thread ( target = self . _run_test , args = ( test , process_result , route_code ) ) [EOL] threads [ to_queue ] = runner_thread , process_result [EOL] runner_thread . start ( ) [EOL] while threads : [EOL] event_dict = queue . get ( ) [EOL] event = event_dict . pop ( [string] ) [EOL] if event == [string] : [EOL] result . status ( ** event_dict ) [EOL] elif event == [string] : [EOL] thread = threads . pop ( event_dict [ [string] ] ) [ [number] ] [EOL] thread . join ( ) [EOL] elif event == [string] : [EOL] pass [EOL] else : [EOL] raise ValueError ( [string] % ( event , ) ) [EOL] except : [EOL] for thread , process_result in threads . values ( ) : [EOL] [comment] [EOL] [comment] [EOL] process_result . stop ( ) [EOL] raise [EOL] [EOL] def _run_test ( self , test , process_result , route_code ) : [EOL] process_result . startTestRun ( ) [EOL] try : [EOL] try : [EOL] test . run ( process_result ) [EOL] except Exception as e : [EOL] [comment] [EOL] case = testtools . ErrorHolder ( [string] % ( route_code , ) , error = sys . exc_info ( ) ) [EOL] case . run ( process_result ) [EOL] finally : [EOL] process_result . stopTestRun ( ) [EOL] [EOL] [EOL] class FixtureSuite ( unittest . TestSuite ) : [EOL] [EOL] def __init__ ( self , fixture , tests ) : [EOL] super ( FixtureSuite , self ) . __init__ ( tests ) [EOL] self . _fixture = fixture [EOL] [EOL] def run ( self , result ) : [EOL] self . _fixture . setUp ( ) [EOL] try : [EOL] super ( FixtureSuite , self ) . run ( result ) [EOL] finally : [EOL] self . _fixture . cleanUp ( ) [EOL] [EOL] def sort_tests ( self ) : [EOL] self . _tests = sorted_tests ( self , True ) [EOL] [EOL] [EOL] def _flatten_tests ( suite_or_case , unpack_outer = False ) : [EOL] try : [EOL] tests = iter ( suite_or_case ) [EOL] except TypeError : [EOL] [comment] [EOL] return [ ( suite_or_case . id ( ) , suite_or_case ) ] [EOL] if ( type ( suite_or_case ) in ( unittest . TestSuite , ) or unpack_outer ) : [EOL] [comment] [EOL] result = [ ] [EOL] for test in tests : [EOL] [comment] [EOL] result . extend ( _flatten_tests ( test ) ) [EOL] return result [EOL] else : [EOL] [comment] [EOL] suite_id = None [EOL] tests = iterate_tests ( suite_or_case ) [EOL] for test in tests : [EOL] suite_id = test . id ( ) [EOL] break [EOL] [comment] [EOL] if safe_hasattr ( suite_or_case , [string] ) : [EOL] suite_or_case . sort_tests ( ) [EOL] return [ ( suite_id , suite_or_case ) ] [EOL] [EOL] [EOL] def filter_by_ids ( suite_or_case , test_ids ) : [EOL] [docstring] [EOL] [comment] [EOL] if safe_hasattr ( suite_or_case , [string] ) : [EOL] return suite_or_case . filter_by_ids ( test_ids ) [EOL] [comment] [EOL] if safe_hasattr ( suite_or_case , [string] ) : [EOL] if suite_or_case . id ( ) in test_ids : [EOL] return suite_or_case [EOL] else : [EOL] return unittest . TestSuite ( ) [EOL] [comment] [EOL] if isinstance ( suite_or_case , unittest . TestSuite ) : [EOL] filtered = [ ] [EOL] for item in suite_or_case : [EOL] filtered . append ( filter_by_ids ( item , test_ids ) ) [EOL] suite_or_case . _tests [ : ] = filtered [EOL] [comment] [EOL] return suite_or_case [EOL] [EOL] [EOL] def sorted_tests ( suite_or_case , unpack_outer = False ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] seen = set ( ) [EOL] for test_case in iterate_tests ( suite_or_case ) : [EOL] test_id = test_case . id ( ) [EOL] if test_id not in seen : [EOL] seen . add ( test_id ) [EOL] else : [EOL] raise ValueError ( [string] % ( test_id , ) ) [EOL] tests = _flatten_tests ( suite_or_case , unpack_outer = unpack_outer ) [EOL] tests . sort ( ) [EOL] return unittest . TestSuite ( [ test for ( sort_key , test ) in tests ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $threading.Semaphore$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $threading.Semaphore$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $threading.Thread$ 0 $typing.Any$ 0 $threading.Thread$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $threading.Thread$ 0 $typing.Any$ 0 $threading.Thread$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.case.TestCase]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class TagContext ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , parent = None ) : [EOL] [docstring] [EOL] self . parent = parent [EOL] self . _tags = set ( ) [EOL] if parent : [EOL] self . _tags . update ( parent . get_current_tags ( ) ) [EOL] [EOL] def get_current_tags ( self ) : [EOL] [docstring] [EOL] return set ( self . _tags ) [EOL] [EOL] def change_tags ( self , new_tags , gone_tags ) : [EOL] [docstring] [EOL] self . _tags . update ( new_tags ) [EOL] self . _tags . difference_update ( gone_tags ) [EOL] return self . get_current_tags ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] import warnings [EOL] warnings . warn ( [string] [string] , DeprecationWarning , stacklevel = [number] ) [EOL] [EOL] from testtools . testsuite import iterate_tests [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] __all__ = [ [string] , ] [EOL] [EOL] [EOL] def reraise ( exc_class , exc_obj , exc_tb , _marker = object ( ) ) : [EOL] [docstring] [EOL] raise exc_obj . with_traceback ( exc_tb ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Any [EOL] import typing [EOL] from __future__ import with_statement [EOL] [EOL] import sys [EOL] [EOL] from testtools import ( ExpectedException , TestCase , ) [EOL] from testtools . matchers import ( AfterPreprocessing , Equals , EndsWith , ) [EOL] [EOL] [EOL] class TestExpectedException ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_pass_on_raise ( self ) : [EOL] with ExpectedException ( ValueError , [string] ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def test_pass_on_raise_matcher ( self ) : [EOL] with ExpectedException ( ValueError , AfterPreprocessing ( str , Equals ( [string] ) ) ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def test_raise_on_text_mismatch ( self ) : [EOL] try : [EOL] with ExpectedException ( ValueError , [string] ) : [EOL] raise ValueError ( [string] ) [EOL] except AssertionError : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] self . assertEqual ( [string] , str ( e ) ) [EOL] else : [EOL] self . fail ( [string] ) [EOL] [EOL] def test_raise_on_general_mismatch ( self ) : [EOL] matcher = AfterPreprocessing ( str , Equals ( [string] ) ) [EOL] value_error = ValueError ( [string] ) [EOL] try : [EOL] with ExpectedException ( ValueError , matcher ) : [EOL] raise value_error [EOL] except AssertionError : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] self . assertEqual ( matcher . match ( value_error ) . describe ( ) , str ( e ) ) [EOL] else : [EOL] self . fail ( [string] ) [EOL] [EOL] def test_raise_on_error_mismatch ( self ) : [EOL] try : [EOL] with ExpectedException ( TypeError , [string] ) : [EOL] raise ValueError ( [string] ) [EOL] except ValueError : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] self . assertEqual ( [string] , str ( e ) ) [EOL] else : [EOL] self . fail ( [string] ) [EOL] [EOL] def test_raise_if_no_exception ( self ) : [EOL] try : [EOL] with ExpectedException ( TypeError , [string] ) : [EOL] pass [EOL] except AssertionError : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] self . assertEqual ( [string] , str ( e ) ) [EOL] else : [EOL] self . fail ( [string] ) [EOL] [EOL] def test_pass_on_raise_any_message ( self ) : [EOL] with ExpectedException ( ValueError ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def test_annotate ( self ) : [EOL] def die ( ) : [EOL] with ExpectedException ( ValueError , msg = [string] ) : [EOL] pass [EOL] exc = self . assertRaises ( AssertionError , die ) [EOL] self . assertThat ( exc . args [ [number] ] , EndsWith ( [string] ) ) [EOL] [EOL] def test_annotated_matcher ( self ) : [EOL] def die ( ) : [EOL] with ExpectedException ( ValueError , [string] , msg = [string] ) : [EOL] pass [EOL] exc = self . assertRaises ( AssertionError , die ) [EOL] self . assertThat ( exc . args [ [number] ] , EndsWith ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.ValueError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.ValueError$ 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.ValueError$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Union , List , Any , Tuple [EOL] import typing [EOL] import re [EOL] [EOL] from testtools import TestCase [EOL] from testtools . compat import ( text_repr , _b , _u , ) [EOL] from testtools . matchers . _basic import ( _BinaryMismatch , Contains , DoesNotEndWith , DoesNotStartWith , EndsWith , Equals , Is , IsInstance , LessThan , GreaterThan , HasLength , MatchesRegex , NotEquals , SameMembers , StartsWith , ) [EOL] from testtools . tests . helpers import FullStackRunTest [EOL] from testtools . tests . matchers . helpers import TestMatchersInterface [EOL] [EOL] [EOL] class Test_BinaryMismatch ( TestCase ) : [EOL] [docstring] [EOL] [EOL] _long_string = [string] [EOL] _long_b = _b ( _long_string ) [EOL] _long_u = _u ( _long_string ) [EOL] [EOL] class CustomRepr ( object ) : [EOL] def __init__ ( self , repr_string ) : [EOL] self . _repr_string = repr_string [EOL] def __repr__ ( self ) : [EOL] return _u ( [string] ) + _u ( self . _repr_string ) + _u ( [string] ) [EOL] [EOL] def test_short_objects ( self ) : [EOL] o1 , o2 = self . CustomRepr ( [string] ) , self . CustomRepr ( [string] ) [EOL] mismatch = _BinaryMismatch ( o1 , [string] , o2 ) [EOL] self . assertEqual ( mismatch . describe ( ) , [string] % ( o1 , o2 ) ) [EOL] [EOL] def test_short_mixed_strings ( self ) : [EOL] b , u = _b ( [string] ) , _u ( [string] ) [EOL] mismatch = _BinaryMismatch ( b , [string] , u ) [EOL] self . assertEqual ( mismatch . describe ( ) , [string] % ( b , u ) ) [EOL] [EOL] def test_long_bytes ( self ) : [EOL] one_line_b = self . _long_b . replace ( _b ( [string] ) , _b ( [string] ) ) [EOL] mismatch = _BinaryMismatch ( one_line_b , [string] , self . _long_b ) [EOL] self . assertEqual ( mismatch . describe ( ) , [string] % ( [string] , text_repr ( one_line_b ) , text_repr ( self . _long_b , multiline = True ) ) ) [EOL] [EOL] def test_long_unicode ( self ) : [EOL] one_line_u = self . _long_u . replace ( [string] , [string] ) [EOL] mismatch = _BinaryMismatch ( one_line_u , [string] , self . _long_u ) [EOL] self . assertEqual ( mismatch . describe ( ) , [string] % ( [string] , text_repr ( one_line_u ) , text_repr ( self . _long_u , multiline = True ) ) ) [EOL] [EOL] def test_long_mixed_strings ( self ) : [EOL] mismatch = _BinaryMismatch ( self . _long_b , [string] , self . _long_u ) [EOL] self . assertEqual ( mismatch . describe ( ) , [string] % ( [string] , text_repr ( self . _long_b , multiline = True ) , text_repr ( self . _long_u , multiline = True ) ) ) [EOL] [EOL] def test_long_bytes_and_object ( self ) : [EOL] obj = object ( ) [EOL] mismatch = _BinaryMismatch ( self . _long_b , [string] , obj ) [EOL] self . assertEqual ( mismatch . describe ( ) , [string] % ( [string] , text_repr ( self . _long_b , multiline = True ) , repr ( obj ) ) ) [EOL] [EOL] def test_long_unicode_and_object ( self ) : [EOL] obj = object ( ) [EOL] mismatch = _BinaryMismatch ( self . _long_u , [string] , obj ) [EOL] self . assertEqual ( mismatch . describe ( ) , [string] % ( [string] , text_repr ( self . _long_u , multiline = True ) , repr ( obj ) ) ) [EOL] [EOL] [EOL] class TestEqualsInterface ( TestCase , TestMatchersInterface ) : [EOL] [EOL] matches_matcher = Equals ( [number] ) [EOL] matches_matches = [ [number] ] [EOL] matches_mismatches = [ [number] ] [EOL] [EOL] str_examples = [ ( [string] , Equals ( [number] ) ) , ( [string] , Equals ( [string] ) ) ] [EOL] [EOL] describe_examples = [ ( [string] , [number] , Equals ( [number] ) ) ] [EOL] [EOL] [EOL] class TestNotEqualsInterface ( TestCase , TestMatchersInterface ) : [EOL] [EOL] matches_matcher = NotEquals ( [number] ) [EOL] matches_matches = [ [number] ] [EOL] matches_mismatches = [ [number] ] [EOL] [EOL] str_examples = [ ( [string] , NotEquals ( [number] ) ) , ( [string] , NotEquals ( [string] ) ) ] [EOL] [EOL] describe_examples = [ ( [string] , [number] , NotEquals ( [number] ) ) ] [EOL] [EOL] [EOL] class TestIsInterface ( TestCase , TestMatchersInterface ) : [EOL] [EOL] foo = object ( ) [EOL] bar = object ( ) [EOL] [EOL] matches_matcher = Is ( foo ) [EOL] matches_matches = [ foo ] [EOL] matches_mismatches = [ bar , [number] ] [EOL] [EOL] str_examples = [ ( [string] , Is ( [number] ) ) ] [EOL] [EOL] describe_examples = [ ( [string] , [number] , Is ( [number] ) ) ] [EOL] [EOL] [EOL] class TestIsInstanceInterface ( TestCase , TestMatchersInterface ) : [EOL] [EOL] class Foo :pass [EOL] [EOL] matches_matcher = IsInstance ( Foo ) [EOL] matches_matches = [ Foo ( ) ] [EOL] matches_mismatches = [ object ( ) , [number] , Foo ] [EOL] [EOL] str_examples = [ ( [string] , IsInstance ( str ) ) , ( [string] , IsInstance ( str , int ) ) , ] [EOL] [EOL] describe_examples = [ ( [string] , [string] , IsInstance ( int ) ) , ( [string] , [string] , IsInstance ( int , type ) ) , ] [EOL] [EOL] [EOL] class TestLessThanInterface ( TestCase , TestMatchersInterface ) : [EOL] [EOL] matches_matcher = LessThan ( [number] ) [EOL] matches_matches = [ - [number] , [number] ] [EOL] matches_mismatches = [ [number] , [number] , [number] ] [EOL] [EOL] str_examples = [ ( [string] , LessThan ( [number] ) ) , ] [EOL] [EOL] describe_examples = [ ( [string] , [number] , LessThan ( [number] ) ) , ( [string] , [number] , LessThan ( [number] ) ) , ] [EOL] [EOL] [EOL] class TestGreaterThanInterface ( TestCase , TestMatchersInterface ) : [EOL] [EOL] matches_matcher = GreaterThan ( [number] ) [EOL] matches_matches = [ [number] , [number] ] [EOL] matches_mismatches = [ - [number] , [number] , [number] ] [EOL] [EOL] str_examples = [ ( [string] , GreaterThan ( [number] ) ) , ] [EOL] [EOL] describe_examples = [ ( [string] , [number] , GreaterThan ( [number] ) ) , ( [string] , [number] , GreaterThan ( [number] ) ) , ] [EOL] [EOL] [EOL] class TestContainsInterface ( TestCase , TestMatchersInterface ) : [EOL] [EOL] matches_matcher = Contains ( [string] ) [EOL] matches_matches = [ [string] , [string] , [string] ] [EOL] matches_mismatches = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] str_examples = [ ( [string] , Contains ( [number] ) ) , ( [string] , Contains ( [string] ) ) , ] [EOL] [EOL] describe_examples = [ ( [string] , [number] , Contains ( [number] ) ) ] [EOL] [EOL] [EOL] class DoesNotStartWithTests ( TestCase ) : [EOL] [EOL] run_tests_with = FullStackRunTest [EOL] [EOL] def test_describe ( self ) : [EOL] mismatch = DoesNotStartWith ( [string] , [string] ) [EOL] self . assertEqual ( [string] , mismatch . describe ( ) ) [EOL] [EOL] def test_describe_non_ascii_unicode ( self ) : [EOL] string = _u ( [string] ) [EOL] suffix = _u ( [string] ) [EOL] mismatch = DoesNotStartWith ( string , suffix ) [EOL] self . assertEqual ( [string] % ( text_repr ( string ) , text_repr ( suffix ) ) , mismatch . describe ( ) ) [EOL] [EOL] def test_describe_non_ascii_bytes ( self ) : [EOL] string = _b ( [string] ) [EOL] suffix = _b ( [string] ) [EOL] mismatch = DoesNotStartWith ( string , suffix ) [EOL] self . assertEqual ( [string] % ( string , suffix ) , mismatch . describe ( ) ) [EOL] [EOL] [EOL] class StartsWithTests ( TestCase ) : [EOL] [EOL] run_tests_with = FullStackRunTest [EOL] [EOL] def test_str ( self ) : [EOL] matcher = StartsWith ( [string] ) [EOL] self . assertEqual ( [string] , str ( matcher ) ) [EOL] [EOL] def test_str_with_bytes ( self ) : [EOL] b = _b ( [string] ) [EOL] matcher = StartsWith ( b ) [EOL] self . assertEqual ( [string] % ( b , ) , str ( matcher ) ) [EOL] [EOL] def test_str_with_unicode ( self ) : [EOL] u = _u ( [string] ) [EOL] matcher = StartsWith ( u ) [EOL] self . assertEqual ( [string] % ( u , ) , str ( matcher ) ) [EOL] [EOL] def test_match ( self ) : [EOL] matcher = StartsWith ( [string] ) [EOL] self . assertIs ( None , matcher . match ( [string] ) ) [EOL] [EOL] def test_mismatch_returns_does_not_start_with ( self ) : [EOL] matcher = StartsWith ( [string] ) [EOL] self . assertIsInstance ( matcher . match ( [string] ) , DoesNotStartWith ) [EOL] [EOL] def test_mismatch_sets_matchee ( self ) : [EOL] matcher = StartsWith ( [string] ) [EOL] mismatch = matcher . match ( [string] ) [EOL] self . assertEqual ( [string] , mismatch . matchee ) [EOL] [EOL] def test_mismatch_sets_expected ( self ) : [EOL] matcher = StartsWith ( [string] ) [EOL] mismatch = matcher . match ( [string] ) [EOL] self . assertEqual ( [string] , mismatch . expected ) [EOL] [EOL] [EOL] class DoesNotEndWithTests ( TestCase ) : [EOL] [EOL] run_tests_with = FullStackRunTest [EOL] [EOL] def test_describe ( self ) : [EOL] mismatch = DoesNotEndWith ( [string] , [string] ) [EOL] self . assertEqual ( [string] , mismatch . describe ( ) ) [EOL] [EOL] def test_describe_non_ascii_unicode ( self ) : [EOL] string = _u ( [string] ) [EOL] suffix = _u ( [string] ) [EOL] mismatch = DoesNotEndWith ( string , suffix ) [EOL] self . assertEqual ( [string] % ( text_repr ( string ) , text_repr ( suffix ) ) , mismatch . describe ( ) ) [EOL] [EOL] def test_describe_non_ascii_bytes ( self ) : [EOL] string = _b ( [string] ) [EOL] suffix = _b ( [string] ) [EOL] mismatch = DoesNotEndWith ( string , suffix ) [EOL] self . assertEqual ( [string] % ( string , suffix ) , mismatch . describe ( ) ) [EOL] [EOL] [EOL] class EndsWithTests ( TestCase ) : [EOL] [EOL] run_tests_with = FullStackRunTest [EOL] [EOL] def test_str ( self ) : [EOL] matcher = EndsWith ( [string] ) [EOL] self . assertEqual ( [string] , str ( matcher ) ) [EOL] [EOL] def test_str_with_bytes ( self ) : [EOL] b = _b ( [string] ) [EOL] matcher = EndsWith ( b ) [EOL] self . assertEqual ( [string] % ( b , ) , str ( matcher ) ) [EOL] [EOL] def test_str_with_unicode ( self ) : [EOL] u = _u ( [string] ) [EOL] matcher = EndsWith ( u ) [EOL] self . assertEqual ( [string] % ( u , ) , str ( matcher ) ) [EOL] [EOL] def test_match ( self ) : [EOL] matcher = EndsWith ( [string] ) [EOL] self . assertIs ( None , matcher . match ( [string] ) ) [EOL] [EOL] def test_mismatch_returns_does_not_end_with ( self ) : [EOL] matcher = EndsWith ( [string] ) [EOL] self . assertIsInstance ( matcher . match ( [string] ) , DoesNotEndWith ) [EOL] [EOL] def test_mismatch_sets_matchee ( self ) : [EOL] matcher = EndsWith ( [string] ) [EOL] mismatch = matcher . match ( [string] ) [EOL] self . assertEqual ( [string] , mismatch . matchee ) [EOL] [EOL] def test_mismatch_sets_expected ( self ) : [EOL] matcher = EndsWith ( [string] ) [EOL] mismatch = matcher . match ( [string] ) [EOL] self . assertEqual ( [string] , mismatch . expected ) [EOL] [EOL] [EOL] class TestSameMembers ( TestCase , TestMatchersInterface ) : [EOL] [EOL] matches_matcher = SameMembers ( [ [number] , [number] , [number] , [number] , { [string] : [string] } ] ) [EOL] matches_matches = [ [ [number] , [number] , [number] , [number] , { [string] : [string] } ] , [ [number] , { [string] : [string] } , [number] , [number] , [number] ] , [ [number] , [number] , [number] , { [string] : [string] } , [number] ] , ( [number] , { [string] : [string] } , [number] , [number] , [number] ) , ] [EOL] matches_mismatches = [ set ( [ [number] , [number] , [number] ] ) , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , { [string] : [string] } ] , [string] , ] [EOL] [EOL] describe_examples = [ ( ( [string] [string] [string] [string] [string] [string] ) , [ [string] , [string] , [string] , [string] , [string] , [string] , ] , SameMembers ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) ) , ] [EOL] [EOL] str_examples = [ ( [string] , SameMembers ( [ [number] , [number] , [number] ] ) ) , ] [EOL] [EOL] [EOL] class TestMatchesRegex ( TestCase , TestMatchersInterface ) : [EOL] [EOL] matches_matcher = MatchesRegex ( [string] ) [EOL] matches_matches = [ [string] , [string] ] [EOL] matches_mismatches = [ [string] ] [EOL] [EOL] str_examples = [ ( [string] , MatchesRegex ( [string] ) ) , ( [string] , MatchesRegex ( [string] , re . M ) ) , ( [string] , MatchesRegex ( [string] , re . I | re . M ) ) , ( [string] % ( _b ( [string] ) , ) , MatchesRegex ( _b ( [string] ) ) ) , ( [string] % ( _u ( [string] ) , ) , MatchesRegex ( _u ( [string] ) ) ) , ] [EOL] [EOL] describe_examples = [ ( [string] , [string] , MatchesRegex ( [string] ) ) , ( [string] , [string] , MatchesRegex ( [string] ) ) , ( [string] % ( _b ( [string] ) , ) , _b ( [string] ) , MatchesRegex ( _b ( [string] ) ) ) , ( [string] % ( _u ( [string] ) , ) , _u ( [string] ) , MatchesRegex ( _u ( [string] ) ) ) , ] [EOL] [EOL] [EOL] class TestHasLength ( TestCase , TestMatchersInterface ) : [EOL] [EOL] matches_matcher = HasLength ( [number] ) [EOL] matches_matches = [ [ [number] , [number] ] ] [EOL] matches_mismatches = [ [ ] , [ [number] ] , [ [number] , [number] , [number] ] ] [EOL] [EOL] str_examples = [ ( [string] , HasLength ( [number] ) ) , ] [EOL] [EOL] describe_examples = [ ( [string] , [ ] , HasLength ( [number] ) ) , ] [EOL] [EOL] [EOL] def test_suite ( ) : [EOL] from unittest import TestLoader [EOL] return TestLoader ( ) . loadTestsFromName ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.object]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int]],typing.Tuple[builtins.int,typing.Dict[builtins.str,builtins.str],builtins.int,builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from testtools import ( Matcher , TestCase , ) [EOL] from testtools . compat import ( str_is_unicode , text_repr , _u , ) [EOL] from testtools . matchers import ( Equals , MatchesException , Raises , ) [EOL] from testtools . matchers . _impl import ( Mismatch , MismatchDecorator , MismatchError , ) [EOL] from testtools . tests . helpers import FullStackRunTest [EOL] [EOL] [comment] [EOL] Matcher [EOL] [EOL] [EOL] class TestMismatch ( TestCase ) : [EOL] [EOL] run_tests_with = FullStackRunTest [EOL] [EOL] def test_constructor_arguments ( self ) : [EOL] mismatch = Mismatch ( [string] , { [string] : [string] } ) [EOL] self . assertEqual ( [string] , mismatch . describe ( ) ) [EOL] self . assertEqual ( { [string] : [string] } , mismatch . get_details ( ) ) [EOL] [EOL] def test_constructor_no_arguments ( self ) : [EOL] mismatch = Mismatch ( ) [EOL] self . assertThat ( mismatch . describe , Raises ( MatchesException ( NotImplementedError ) ) ) [EOL] self . assertEqual ( { } , mismatch . get_details ( ) ) [EOL] [EOL] [EOL] class TestMismatchError ( TestCase ) : [EOL] [EOL] def test_is_assertion_error ( self ) : [EOL] [comment] [EOL] [comment] [EOL] def raise_mismatch_error ( ) : [EOL] raise MismatchError ( [number] , Equals ( [number] ) , Equals ( [number] ) . match ( [number] ) ) [EOL] self . assertRaises ( AssertionError , raise_mismatch_error ) [EOL] [EOL] def test_default_description_is_mismatch ( self ) : [EOL] mismatch = Equals ( [number] ) . match ( [number] ) [EOL] e = MismatchError ( [number] , Equals ( [number] ) , mismatch ) [EOL] self . assertEqual ( mismatch . describe ( ) , str ( e ) ) [EOL] [EOL] def test_default_description_unicode ( self ) : [EOL] matchee = _u ( [string] ) [EOL] matcher = Equals ( _u ( [string] ) ) [EOL] mismatch = matcher . match ( matchee ) [EOL] e = MismatchError ( matchee , matcher , mismatch ) [EOL] self . assertEqual ( mismatch . describe ( ) , str ( e ) ) [EOL] [EOL] def test_verbose_description ( self ) : [EOL] matchee = [number] [EOL] matcher = Equals ( [number] ) [EOL] mismatch = matcher . match ( [number] ) [EOL] e = MismatchError ( matchee , matcher , mismatch , True ) [EOL] expected = ( [string] [string] [string] % ( matchee , matcher , matcher . match ( matchee ) . describe ( ) , ) ) [EOL] self . assertEqual ( expected , str ( e ) ) [EOL] [EOL] def test_verbose_unicode ( self ) : [EOL] [comment] [EOL] [comment] [EOL] matchee = _u ( [string] ) [EOL] matcher = Equals ( _u ( [string] ) ) [EOL] mismatch = matcher . match ( matchee ) [EOL] expected = ( [string] [string] [string] % ( text_repr ( matchee ) , matcher , mismatch . describe ( ) , ) ) [EOL] e = MismatchError ( matchee , matcher , mismatch , True ) [EOL] if str_is_unicode : [EOL] actual = str ( e ) [EOL] else : [EOL] actual = unicode ( e ) [EOL] [comment] [EOL] self . assertEqual ( expected . replace ( matchee , matchee . encode ( [string] ) ) , str ( e ) . decode ( [string] ) ) [EOL] self . assertEqual ( expected , actual ) [EOL] [EOL] [EOL] class TestMismatchDecorator ( TestCase ) : [EOL] [EOL] run_tests_with = FullStackRunTest [EOL] [EOL] def test_forwards_description ( self ) : [EOL] x = Mismatch ( [string] , { [string] : [string] } ) [EOL] decorated = MismatchDecorator ( x ) [EOL] self . assertEqual ( x . describe ( ) , decorated . describe ( ) ) [EOL] [EOL] def test_forwards_details ( self ) : [EOL] x = Mismatch ( [string] , { [string] : [string] } ) [EOL] decorated = MismatchDecorator ( x ) [EOL] self . assertEqual ( x . get_details ( ) , decorated . get_details ( ) ) [EOL] [EOL] def test_repr ( self ) : [EOL] x = Mismatch ( [string] , { [string] : [string] } ) [EOL] decorated = MismatchDecorator ( x ) [EOL] self . assertEqual ( [string] % ( x , ) , repr ( decorated ) ) [EOL] [EOL] [EOL] def test_suite ( ) : [EOL] from unittest import TestLoader [EOL] return TestLoader ( ) . loadTestsFromName ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from testtools . tests . helpers import FullStackRunTest [EOL] [EOL] [EOL] class TestMatchersInterface ( object ) : [EOL] [EOL] run_tests_with = FullStackRunTest [EOL] [EOL] def test_matches_match ( self ) : [EOL] matcher = self . matches_matcher [EOL] matches = self . matches_matches [EOL] mismatches = self . matches_mismatches [EOL] for candidate in matches : [EOL] self . assertEqual ( None , matcher . match ( candidate ) ) [EOL] for candidate in mismatches : [EOL] mismatch = matcher . match ( candidate ) [EOL] self . assertNotEqual ( None , mismatch ) [EOL] self . assertNotEqual ( None , getattr ( mismatch , [string] , None ) ) [EOL] [EOL] def test__str__ ( self ) : [EOL] [comment] [EOL] from testtools . matchers . _doctest import DocTestMatches [EOL] examples = self . str_examples [EOL] for expected , matcher in examples : [EOL] self . assertThat ( matcher , DocTestMatches ( expected ) ) [EOL] [EOL] def test_describe_difference ( self ) : [EOL] [comment] [EOL] examples = self . describe_examples [EOL] for difference , matchee , matcher in examples : [EOL] mismatch = matcher . match ( matchee ) [EOL] self . assertEqual ( difference , mismatch . describe ( ) ) [EOL] [EOL] def test_mismatch_details ( self ) : [EOL] [comment] [EOL] [comment] [EOL] examples = self . describe_examples [EOL] for difference , matchee , matcher in examples : [EOL] mismatch = matcher . match ( matchee ) [EOL] details = mismatch . get_details ( ) [EOL] self . assertEqual ( dict ( details ) , details ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] from testtools . tags import TagContext [EOL] [EOL] [EOL] class LoggingBase ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _events = [ ] [EOL] self . shouldStop = False [EOL] self . _was_successful = True [EOL] self . testsRun = [number] [EOL] [EOL] [EOL] class Python26TestResult ( LoggingBase ) : [EOL] [docstring] [EOL] [EOL] def addError ( self , test , err ) : [EOL] self . _was_successful = False [EOL] self . _events . append ( ( [string] , test , err ) ) [EOL] [EOL] def addFailure ( self , test , err ) : [EOL] self . _was_successful = False [EOL] self . _events . append ( ( [string] , test , err ) ) [EOL] [EOL] def addSuccess ( self , test ) : [EOL] self . _events . append ( ( [string] , test ) ) [EOL] [EOL] def startTest ( self , test ) : [EOL] self . _events . append ( ( [string] , test ) ) [EOL] self . testsRun += [number] [EOL] [EOL] def stop ( self ) : [EOL] self . shouldStop = True [EOL] [EOL] def stopTest ( self , test ) : [EOL] self . _events . append ( ( [string] , test ) ) [EOL] [EOL] def wasSuccessful ( self ) : [EOL] return self . _was_successful [EOL] [EOL] [EOL] class Python27TestResult ( Python26TestResult ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( Python27TestResult , self ) . __init__ ( ) [EOL] self . failfast = False [EOL] [EOL] def addError ( self , test , err ) : [EOL] super ( Python27TestResult , self ) . addError ( test , err ) [EOL] if self . failfast : [EOL] self . stop ( ) [EOL] [EOL] def addFailure ( self , test , err ) : [EOL] super ( Python27TestResult , self ) . addFailure ( test , err ) [EOL] if self . failfast : [EOL] self . stop ( ) [EOL] [EOL] def addExpectedFailure ( self , test , err ) : [EOL] self . _events . append ( ( [string] , test , err ) ) [EOL] [EOL] def addSkip ( self , test , reason ) : [EOL] self . _events . append ( ( [string] , test , reason ) ) [EOL] [EOL] def addUnexpectedSuccess ( self , test ) : [EOL] self . _events . append ( ( [string] , test ) ) [EOL] if self . failfast : [EOL] self . stop ( ) [EOL] [EOL] def startTestRun ( self ) : [EOL] self . _events . append ( ( [string] , ) ) [EOL] [EOL] def stopTestRun ( self ) : [EOL] self . _events . append ( ( [string] , ) ) [EOL] [EOL] [EOL] class ExtendedTestResult ( Python27TestResult ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ExtendedTestResult , self ) . __init__ ( ) [EOL] self . _tags = TagContext ( ) [EOL] [EOL] def addError ( self , test , err = None , details = None ) : [EOL] self . _was_successful = False [EOL] self . _events . append ( ( [string] , test , err or details ) ) [EOL] [EOL] def addFailure ( self , test , err = None , details = None ) : [EOL] self . _was_successful = False [EOL] self . _events . append ( ( [string] , test , err or details ) ) [EOL] [EOL] def addExpectedFailure ( self , test , err = None , details = None ) : [EOL] self . _events . append ( ( [string] , test , err or details ) ) [EOL] [EOL] def addSkip ( self , test , reason = None , details = None ) : [EOL] self . _events . append ( ( [string] , test , reason or details ) ) [EOL] [EOL] def addSuccess ( self , test , details = None ) : [EOL] if details : [EOL] self . _events . append ( ( [string] , test , details ) ) [EOL] else : [EOL] self . _events . append ( ( [string] , test ) ) [EOL] [EOL] def addUnexpectedSuccess ( self , test , details = None ) : [EOL] self . _was_successful = False [EOL] if details is not None : [EOL] self . _events . append ( ( [string] , test , details ) ) [EOL] else : [EOL] self . _events . append ( ( [string] , test ) ) [EOL] [EOL] def progress ( self , offset , whence ) : [EOL] self . _events . append ( ( [string] , offset , whence ) ) [EOL] [EOL] def startTestRun ( self ) : [EOL] super ( ExtendedTestResult , self ) . startTestRun ( ) [EOL] self . _was_successful = True [EOL] self . _tags = TagContext ( ) [EOL] [EOL] def startTest ( self , test ) : [EOL] super ( ExtendedTestResult , self ) . startTest ( test ) [EOL] self . _tags = TagContext ( self . _tags ) [EOL] [EOL] def stopTest ( self , test ) : [EOL] self . _tags = self . _tags . parent [EOL] super ( ExtendedTestResult , self ) . stopTest ( test ) [EOL] [EOL] @ property def current_tags ( self ) : [EOL] return self . _tags . get_current_tags ( ) [EOL] [EOL] def tags ( self , new_tags , gone_tags ) : [EOL] self . _tags . change_tags ( new_tags , gone_tags ) [EOL] self . _events . append ( ( [string] , new_tags , gone_tags ) ) [EOL] [EOL] def time ( self , time ) : [EOL] self . _events . append ( ( [string] , time ) ) [EOL] [EOL] def wasSuccessful ( self ) : [EOL] return self . _was_successful [EOL] [EOL] [EOL] class StreamResult ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _events = [ ] [EOL] [EOL] def startTestRun ( self ) : [EOL] self . _events . append ( ( [string] , ) ) [EOL] [EOL] def stopTestRun ( self ) : [EOL] self . _events . append ( ( [string] , ) ) [EOL] [EOL] def status ( self , test_id = None , test_status = None , test_tags = None , runnable = True , file_name = None , file_bytes = None , eof = False , mime_type = None , route_code = None , timestamp = None ) : [EOL] self . _events . append ( ( [string] , test_id , test_status , test_tags , runnable , file_name , file_bytes , eof , mime_type , route_code , timestamp ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] from testtools . testresult . real import ( CopyStreamResult , ExtendedToOriginalDecorator , ExtendedToStreamDecorator , MultiTestResult , StreamFailFast , StreamResult , StreamResultRouter , StreamSummary , StreamTagger , StreamToDict , StreamToExtendedDecorator , StreamToQueue , Tagger , TestByTestResult , TestControl , TestResult , TestResultDecorator , TextTestResult , ThreadsafeForwardingResult , TimestampingStreamResult , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Literal , Dict , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] import sys [EOL] from distutils . core import setup [EOL] from discover import __version__ as VERSION [EOL] [EOL] [EOL] NAME = [string] [EOL] MODULES = ( [string] , ) [EOL] DESCRIPTION = [string] [EOL] URL = [string] [EOL] CLASSIFIERS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] AUTHOR = [string] [EOL] AUTHOR_EMAIL = [string] [EOL] KEYWORDS = [string] . split ( [string] ) [EOL] LONG_DESCRIPTION = open ( [string] ) . read ( ) [EOL] [EOL] [EOL] params = dict ( name = NAME , version = VERSION , description = DESCRIPTION , long_description = LONG_DESCRIPTION , author = AUTHOR , author_email = AUTHOR_EMAIL , url = URL , py_modules = MODULES , classifiers = CLASSIFIERS , keywords = KEYWORDS ) [EOL] [EOL] [EOL] try : [EOL] from setuptools import setup [EOL] except ImportError : [EOL] from distutils . core import setup [EOL] else : [EOL] params . update ( dict ( entry_points = { [string] : [ [string] , ] , } , ) ) [EOL] params [ [string] ] = [string] [EOL] [EOL] setup ( ** params ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import unittest [EOL] [EOL] class TestSample ( unittest . TestCase ) : [EOL] [EOL] def test_so_easy ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] __all__ = [ [string] , [string] , ] [EOL] [EOL] import unittest [EOL] [EOL] from testtools . testcase import clone_test_with_new_id [EOL] [EOL] from testscenarios . scenarios import generate_scenarios [EOL] [EOL] _doc = [string] [EOL] [EOL] class WithScenarios ( object ) : [EOL] __doc__ = [string] + _doc [EOL] [EOL] def _get_scenarios ( self ) : [EOL] return getattr ( self , [string] , None ) [EOL] [EOL] def countTestCases ( self ) : [EOL] scenarios = self . _get_scenarios ( ) [EOL] if not scenarios : [EOL] return [number] [EOL] else : [EOL] return len ( scenarios ) [EOL] [EOL] def debug ( self ) : [EOL] scenarios = self . _get_scenarios ( ) [EOL] if scenarios : [EOL] for test in generate_scenarios ( self ) : [EOL] test . debug ( ) [EOL] else : [EOL] return super ( WithScenarios , self ) . debug ( ) [EOL] [EOL] def run ( self , result = None ) : [EOL] scenarios = self . _get_scenarios ( ) [EOL] if scenarios : [EOL] for test in generate_scenarios ( self ) : [EOL] test . run ( result ) [EOL] return [EOL] else : [EOL] return super ( WithScenarios , self ) . run ( result ) [EOL] [EOL] [EOL] class TestWithScenarios ( WithScenarios , unittest . TestCase ) : [EOL] __doc__ = [string] + _doc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Tuple , Dict [EOL] import typing [EOL] import unittest [EOL] import unittest [EOL] [EOL] import testscenarios [EOL] from testscenarios . scenarios import ( apply_scenario , apply_scenarios , generate_scenarios , load_tests_apply_scenarios , multiply_scenarios , ) [EOL] import testtools [EOL] from testtools . tests . helpers import LoggingResult [EOL] [EOL] [EOL] class TestGenerateScenarios ( testtools . TestCase ) : [EOL] [EOL] def hook_apply_scenarios ( self ) : [EOL] self . addCleanup ( setattr , testscenarios . scenarios , [string] , apply_scenarios ) [EOL] log = [ ] [EOL] def capture ( scenarios , test ) : [EOL] log . append ( ( scenarios , test ) ) [EOL] return apply_scenarios ( scenarios , test ) [EOL] testscenarios . scenarios . apply_scenarios = capture [EOL] return log [EOL] [EOL] def test_generate_scenarios_preserves_normal_test ( self ) : [EOL] class ReferenceTest ( unittest . TestCase ) : [EOL] def test_pass ( self ) : [EOL] pass [EOL] test = ReferenceTest ( [string] ) [EOL] log = self . hook_apply_scenarios ( ) [EOL] self . assertEqual ( [ test ] , list ( generate_scenarios ( test ) ) ) [EOL] self . assertEqual ( [ ] , log ) [EOL] [EOL] def test_tests_with_scenarios_calls_apply_scenarios ( self ) : [EOL] class ReferenceTest ( unittest . TestCase ) : [EOL] scenarios = [ ( [string] , { } ) ] [EOL] def test_pass ( self ) : [EOL] pass [EOL] test = ReferenceTest ( [string] ) [EOL] log = self . hook_apply_scenarios ( ) [EOL] tests = list ( generate_scenarios ( test ) ) [EOL] self . assertEqual ( [string] , tests [ [number] ] . id ( ) ) [EOL] self . assertEqual ( [ ( [ ( [string] , { } ) ] , test ) ] , log ) [EOL] [EOL] def test_all_scenarios_yielded ( self ) : [EOL] class ReferenceTest ( unittest . TestCase ) : [EOL] scenarios = [ ( [string] , { } ) , ( [string] , { } ) ] [EOL] def test_pass ( self ) : [EOL] pass [EOL] test = ReferenceTest ( [string] ) [EOL] tests = list ( generate_scenarios ( test ) ) [EOL] self . assertEqual ( [string] , tests [ [number] ] . id ( ) ) [EOL] self . assertEqual ( [string] , tests [ [number] ] . id ( ) ) [EOL] [EOL] def test_scenarios_attribute_cleared ( self ) : [EOL] class ReferenceTest ( unittest . TestCase ) : [EOL] scenarios = [ ( [string] , { [string] : [number] , [string] : [number] } ) , ( [string] , { [string] : [number] , [string] : [number] } ) ] [EOL] def test_check_foo ( self ) : [EOL] pass [EOL] test = ReferenceTest ( [string] ) [EOL] tests = list ( generate_scenarios ( test ) ) [EOL] for adapted in tests : [EOL] self . assertEqual ( None , adapted . scenarios ) [EOL] [EOL] def test_multiple_tests ( self ) : [EOL] class Reference1 ( unittest . TestCase ) : [EOL] scenarios = [ ( [string] , { } ) , ( [string] , { } ) ] [EOL] def test_something ( self ) : [EOL] pass [EOL] class Reference2 ( unittest . TestCase ) : [EOL] scenarios = [ ( [string] , { } ) , ( [string] , { } ) ] [EOL] def test_something ( self ) : [EOL] pass [EOL] suite = unittest . TestSuite ( ) [EOL] suite . addTest ( Reference1 ( [string] ) ) [EOL] suite . addTest ( Reference2 ( [string] ) ) [EOL] tests = list ( generate_scenarios ( suite ) ) [EOL] self . assertEqual ( [number] , len ( tests ) ) [EOL] [EOL] [EOL] class TestApplyScenario ( testtools . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] super ( TestApplyScenario , self ) . setUp ( ) [EOL] [EOL] self . scenario_name = [string] [EOL] self . scenario_attrs = { [string] : [string] } [EOL] self . scenario = ( self . scenario_name , self . scenario_attrs ) [EOL] [EOL] class ReferenceTest ( unittest . TestCase ) : [EOL] def test_pass ( self ) : [EOL] pass [EOL] def test_pass_with_docstring ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] self . ReferenceTest = ReferenceTest [EOL] [EOL] def test_sets_specified_id ( self ) : [EOL] raw_test = self . ReferenceTest ( [string] ) [EOL] raw_id = [string] [EOL] scenario_name = self . scenario_name [EOL] expect_id = [string] % vars ( ) [EOL] modified_test = apply_scenario ( self . scenario , raw_test ) [EOL] self . assertEqual ( expect_id , modified_test . id ( ) ) [EOL] [EOL] def test_sets_specified_attributes ( self ) : [EOL] raw_test = self . ReferenceTest ( [string] ) [EOL] modified_test = apply_scenario ( self . scenario , raw_test ) [EOL] self . assertEqual ( [string] , modified_test . foo ) [EOL] [EOL] def test_appends_scenario_name_to_short_description ( self ) : [EOL] raw_test = self . ReferenceTest ( [string] ) [EOL] modified_test = apply_scenario ( self . scenario , raw_test ) [EOL] raw_doc = self . ReferenceTest . test_pass_with_docstring . __doc__ [EOL] raw_desc = raw_doc . split ( [string] ) [ [number] ] . strip ( ) [EOL] scenario_name = self . scenario_name [EOL] expect_desc = [string] % vars ( ) [EOL] self . assertEqual ( expect_desc , modified_test . shortDescription ( ) ) [EOL] [EOL] class TestApplyScenarios ( testtools . TestCase ) : [EOL] [EOL] def test_calls_apply_scenario ( self ) : [EOL] self . addCleanup ( setattr , testscenarios . scenarios , [string] , apply_scenario ) [EOL] log = [ ] [EOL] def capture ( scenario , test ) : [EOL] log . append ( ( scenario , test ) ) [EOL] testscenarios . scenarios . apply_scenario = capture [EOL] scenarios = [ [string] , [string] ] [EOL] result = list ( apply_scenarios ( scenarios , [string] ) ) [EOL] self . assertEqual ( [ ( [string] , [string] ) , ( [string] , [string] ) ] , log ) [EOL] [EOL] def test_preserves_scenarios_attribute ( self ) : [EOL] class ReferenceTest ( unittest . TestCase ) : [EOL] scenarios = [ ( [string] , { } ) ] [EOL] def test_pass ( self ) : [EOL] pass [EOL] test = ReferenceTest ( [string] ) [EOL] tests = list ( apply_scenarios ( ReferenceTest . scenarios , test ) ) [EOL] self . assertEqual ( [ ( [string] , { } ) ] , ReferenceTest . scenarios ) [EOL] self . assertEqual ( ReferenceTest . scenarios , tests [ [number] ] . scenarios ) [EOL] [EOL] [EOL] class TestLoadTests ( testtools . TestCase ) : [EOL] [EOL] class SampleTest ( unittest . TestCase ) : [EOL] def test_nothing ( self ) : [EOL] pass [EOL] scenarios = [ ( [string] , { } ) , ( [string] , { } ) , ] [EOL] [EOL] def test_load_tests_apply_scenarios ( self ) : [EOL] suite = load_tests_apply_scenarios ( unittest . TestLoader ( ) , [ self . SampleTest ( [string] ) ] , None ) [EOL] result_tests = list ( testtools . iterate_tests ( suite ) ) [EOL] self . assertEquals ( [number] , len ( result_tests ) , result_tests ) [EOL] [EOL] def test_load_tests_apply_scenarios_old_style ( self ) : [EOL] [docstring] [EOL] suite = load_tests_apply_scenarios ( [ self . SampleTest ( [string] ) ] , self . __class__ . __module__ , unittest . TestLoader ( ) , ) [EOL] result_tests = list ( testtools . iterate_tests ( suite ) ) [EOL] self . assertEquals ( [number] , len ( result_tests ) , result_tests ) [EOL] [EOL] [EOL] class TestMultiplyScenarios ( testtools . TestCase ) : [EOL] [EOL] def test_multiply_scenarios ( self ) : [EOL] def factory ( name ) : [EOL] for i in [string] : [EOL] yield i , { name : i } [EOL] scenarios = multiply_scenarios ( factory ( [string] ) , factory ( [string] ) ) [EOL] self . assertEqual ( [ ( [string] , dict ( p = [string] , q = [string] ) ) , ( [string] , dict ( p = [string] , q = [string] ) ) , ( [string] , dict ( p = [string] , q = [string] ) ) , ( [string] , dict ( p = [string] , q = [string] ) ) , ] , scenarios ) [EOL] [EOL] def test_multiply_many_scenarios ( self ) : [EOL] def factory ( name ) : [EOL] for i in [string] : [EOL] yield i , { name : i } [EOL] scenarios = multiply_scenarios ( factory ( [string] ) , factory ( [string] ) , factory ( [string] ) , factory ( [string] ) ) [EOL] self . assertEqual ( [number] ** [number] , len ( scenarios ) , scenarios ) [EOL] self . assertEqual ( [string] , scenarios [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] class TestPerModuleScenarios ( testtools . TestCase ) : [EOL] [EOL] def test_per_module_scenarios ( self ) : [EOL] [docstring] [EOL] s = testscenarios . scenarios . per_module_scenarios ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) [EOL] self . assertEqual ( [string] , s [ - [number] ] [ [number] ] ) [EOL] self . assertIsInstance ( s [ - [number] ] [ [number] ] [ [string] ] , tuple ) [EOL] s [ - [number] ] [ [number] ] [ [string] ] = None [EOL] self . assertEqual ( s , [ ( [string] , { [string] : testscenarios } ) , ( [string] , { [string] : unittest } ) , ( [string] , { [string] : None } ) , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Dict[builtins.str,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List , Dict [EOL] import typing [EOL] try : [EOL] [comment] [EOL] from setuptools import setup [EOL] except ImportError : [EOL] [comment] [EOL] from distutils . core import setup [EOL] extra = { } [EOL] else : [EOL] extra = { [string] : [ [string] , [string] , ] } [EOL] [EOL] [EOL] def _get_version_from_file ( filename , start_of_line , split_marker ) : [EOL] [docstring] [EOL] try : [EOL] return [ x for x in open ( filename ) if x . startswith ( start_of_line ) ] [ - [number] ] . split ( split_marker ) [ [number] ] . strip ( ) [EOL] except ( IOError , IndexError ) : [EOL] return None [EOL] [EOL] [EOL] VERSION = ( _get_version_from_file ( [string] , [string] , [string] ) or _get_version_from_file ( [string] , [string] , [string] ) or [string] ) [EOL] [EOL] [EOL] setup ( name = [string] , version = VERSION , description = ( [string] ) , long_description = open ( [string] ) . read ( ) , classifiers = [ [string] , [string] , [string] , [string] , ] , keywords = [string] , author = [string] , author_email = [string] , url = [string] , packages = [ [string] , [string] ] , package_dir = { [string] : [string] } , scripts = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ** extra ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Pattern , Any [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] [EOL] from datetime import datetime , timedelta , tzinfo [EOL] import re [EOL] import sys [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] ISO8601_REGEX_PATTERN = ( [string] [string] [string] ) [EOL] TIMEZONE_REGEX_PATTERN = [string] [EOL] ISO8601_REGEX = re . compile ( ISO8601_REGEX_PATTERN . encode ( [string] ) ) [EOL] TIMEZONE_REGEX = re . compile ( TIMEZONE_REGEX_PATTERN . encode ( [string] ) ) [EOL] [EOL] zulu = [string] . encode ( [string] ) [EOL] minus = [string] . encode ( [string] ) [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] bytes = str [EOL] [EOL] [EOL] class ParseError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] ZERO = timedelta ( [number] ) [EOL] class Utc ( tzinfo ) : [EOL] [docstring] [EOL] def utcoffset ( self , dt ) : [EOL] return ZERO [EOL] [EOL] def tzname ( self , dt ) : [EOL] return [string] [EOL] [EOL] def dst ( self , dt ) : [EOL] return ZERO [EOL] UTC = Utc ( ) [EOL] [EOL] class FixedOffset ( tzinfo ) : [EOL] [docstring] [EOL] def __init__ ( self , offset_hours , offset_minutes , name ) : [EOL] self . __offset = timedelta ( hours = offset_hours , minutes = offset_minutes ) [EOL] self . __name = name [EOL] [EOL] def utcoffset ( self , dt ) : [EOL] return self . __offset [EOL] [EOL] def tzname ( self , dt ) : [EOL] return self . __name [EOL] [EOL] def dst ( self , dt ) : [EOL] return ZERO [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % self . __name [EOL] [EOL] def parse_timezone ( tzstring , default_timezone = UTC ) : [EOL] [docstring] [EOL] if tzstring == zulu : [EOL] return default_timezone [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if tzstring is None : [EOL] return default_timezone [EOL] m = TIMEZONE_REGEX . match ( tzstring ) [EOL] prefix , hours , minutes = m . groups ( ) [EOL] hours , minutes = int ( hours ) , int ( minutes ) [EOL] if prefix == minus : [EOL] hours = - hours [EOL] minutes = - minutes [EOL] return FixedOffset ( hours , minutes , tzstring ) [EOL] [EOL] def parse_date ( datestring , default_timezone = UTC ) : [EOL] [docstring] [EOL] if not isinstance ( datestring , bytes ) : [EOL] raise ParseError ( [string] % datestring ) [EOL] m = ISO8601_REGEX . match ( datestring ) [EOL] if not m : [EOL] raise ParseError ( [string] % datestring ) [EOL] groups = m . groupdict ( ) [EOL] tz = parse_timezone ( groups [ [string] ] , default_timezone = default_timezone ) [EOL] if groups [ [string] ] is None : [EOL] groups [ [string] ] = [number] [EOL] else : [EOL] groups [ [string] ] = int ( float ( [string] % groups [ [string] ] . decode ( ) ) * [number] ) [EOL] return datetime ( int ( groups [ [string] ] ) , int ( groups [ [string] ] ) , int ( groups [ [string] ] ) , int ( groups [ [string] ] ) , int ( groups [ [string] ] ) , int ( groups [ [string] ] ) , int ( groups [ [string] ] ) , tz ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Pattern[bytes]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Pattern[bytes]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $bytes$ 0 0 0 0 0 0 0 0 $bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] class ProgressModel ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _tasks = [ ] [EOL] self . push ( ) [EOL] [EOL] def adjust_width ( self , offset ) : [EOL] [docstring] [EOL] self . _tasks [ - [number] ] [ [number] ] += offset [EOL] [EOL] def advance ( self ) : [EOL] [docstring] [EOL] self . _tasks [ - [number] ] [ [number] ] += [number] [EOL] [EOL] def pop ( self ) : [EOL] [docstring] [EOL] self . _tasks . pop ( ) [EOL] [EOL] def pos ( self ) : [EOL] [docstring] [EOL] if not self . _tasks : [EOL] return [number] [EOL] task = self . _tasks [ - [number] ] [EOL] if len ( self . _tasks ) > [number] : [EOL] [comment] [EOL] [comment] [EOL] offset = task [ [number] ] * ( task [ [number] ] or [number] ) [EOL] else : [EOL] offset = [number] [EOL] return offset + task [ [number] ] [EOL] [EOL] def push ( self ) : [EOL] [docstring] [EOL] self . _tasks . append ( [ [number] , [number] , self . pos ( ) , self . width ( ) ] ) [EOL] [EOL] def set_width ( self , width ) : [EOL] [docstring] [EOL] self . _tasks [ - [number] ] [ [number] ] = width [EOL] [EOL] def width ( self ) : [EOL] [docstring] [EOL] if not self . _tasks : [EOL] return [number] [EOL] task = self . _tasks [ - [number] ] [EOL] if len ( self . _tasks ) > [number] : [EOL] [comment] [EOL] [comment] [EOL] return task [ [number] ] * ( task [ [number] ] or [number] ) [EOL] else : [EOL] return task [ [number] ] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] from testtools import content , content_type [EOL] from testtools . compat import _b , BytesIO [EOL] [EOL] from subunit import chunked [EOL] [EOL] end_marker = _b ( [string] ) [EOL] quoted_marker = _b ( [string] ) [EOL] empty = _b ( [string] ) [EOL] [EOL] [EOL] class DetailsParser ( object ) : [EOL] [docstring] [EOL] [EOL] [EOL] class SimpleDetailsParser ( DetailsParser ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , state ) : [EOL] self . _message = _b ( [string] ) [EOL] self . _state = state [EOL] [EOL] def lineReceived ( self , line ) : [EOL] if line == end_marker : [EOL] self . _state . endDetails ( ) [EOL] return [EOL] if line [ [number] : [number] ] == quoted_marker : [EOL] [comment] [EOL] self . _message += line [ [number] : ] [EOL] else : [EOL] self . _message += line [EOL] [EOL] def get_details ( self , style = None ) : [EOL] result = { } [EOL] if not style : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] result [ [string] ] = content . Content ( content_type . ContentType ( [string] , [string] , { [string] : [string] } ) , lambda : [ self . _message ] ) [EOL] else : [EOL] if style == [string] : [EOL] name = [string] [EOL] else : [EOL] name = [string] [EOL] result [ name ] = content . Content ( content_type . ContentType ( [string] , [string] ) , lambda : [ self . _message ] ) [EOL] return result [EOL] [EOL] def get_message ( self ) : [EOL] return self . _message [EOL] [EOL] [EOL] class MultipartDetailsParser ( DetailsParser ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , state ) : [EOL] self . _state = state [EOL] self . _details = { } [EOL] self . _parse_state = self . _look_for_content [EOL] [EOL] def _look_for_content ( self , line ) : [EOL] if line == end_marker : [EOL] self . _state . endDetails ( ) [EOL] return [EOL] [comment] [EOL] field , value = line [ : - [number] ] . decode ( [string] ) . split ( [string] , [number] ) [EOL] try : [EOL] main , sub = value . split ( [string] ) [EOL] except ValueError : [EOL] raise ValueError ( [string] % value ) [EOL] self . _content_type = content_type . ContentType ( main , sub ) [EOL] self . _parse_state = self . _get_name [EOL] [EOL] def _get_name ( self , line ) : [EOL] self . _name = line [ : - [number] ] . decode ( [string] ) [EOL] self . _body = BytesIO ( ) [EOL] self . _chunk_parser = chunked . Decoder ( self . _body ) [EOL] self . _parse_state = self . _feed_chunks [EOL] [EOL] def _feed_chunks ( self , line ) : [EOL] residue = self . _chunk_parser . write ( line ) [EOL] if residue is not None : [EOL] [comment] [EOL] assert residue == empty , [string] % ( residue , ) [EOL] body = self . _body [EOL] self . _details [ self . _name ] = content . Content ( self . _content_type , lambda : [ body . getvalue ( ) ] ) [EOL] self . _chunk_parser . close ( ) [EOL] self . _parse_state = self . _look_for_content [EOL] [EOL] def get_details ( self , for_skip = False ) : [EOL] return self . _details [EOL] [EOL] def get_message ( self ) : [EOL] return None [EOL] [EOL] def lineReceived ( self , line ) : [EOL] self . _parse_state ( line ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] [EOL] import csv [EOL] import datetime [EOL] [EOL] import testtools [EOL] from testtools . compat import all [EOL] from testtools . content import ( text_content , TracebackContent , ) [EOL] from testtools import StreamResult [EOL] [EOL] from subunit import iso8601 [EOL] import subunit [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class TestResultDecorator ( object ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __init__ ( self , decorated ) : [EOL] [docstring] [EOL] [comment] [EOL] self . decorated = testtools . ExtendedToOriginalDecorator ( decorated ) [EOL] [EOL] def startTest ( self , test ) : [EOL] return self . decorated . startTest ( test ) [EOL] [EOL] def startTestRun ( self ) : [EOL] return self . decorated . startTestRun ( ) [EOL] [EOL] def stopTest ( self , test ) : [EOL] return self . decorated . stopTest ( test ) [EOL] [EOL] def stopTestRun ( self ) : [EOL] return self . decorated . stopTestRun ( ) [EOL] [EOL] def addError ( self , test , err = None , details = None ) : [EOL] return self . decorated . addError ( test , err , details = details ) [EOL] [EOL] def addFailure ( self , test , err = None , details = None ) : [EOL] return self . decorated . addFailure ( test , err , details = details ) [EOL] [EOL] def addSuccess ( self , test , details = None ) : [EOL] return self . decorated . addSuccess ( test , details = details ) [EOL] [EOL] def addSkip ( self , test , reason = None , details = None ) : [EOL] return self . decorated . addSkip ( test , reason , details = details ) [EOL] [EOL] def addExpectedFailure ( self , test , err = None , details = None ) : [EOL] return self . decorated . addExpectedFailure ( test , err , details = details ) [EOL] [EOL] def addUnexpectedSuccess ( self , test , details = None ) : [EOL] return self . decorated . addUnexpectedSuccess ( test , details = details ) [EOL] [EOL] def _get_failfast ( self ) : [EOL] return getattr ( self . decorated , [string] , False ) [EOL] [EOL] def _set_failfast ( self , value ) : [EOL] self . decorated . failfast = value [EOL] failfast = property ( _get_failfast , _set_failfast ) [EOL] [EOL] def progress ( self , offset , whence ) : [EOL] return self . decorated . progress ( offset , whence ) [EOL] [EOL] def wasSuccessful ( self ) : [EOL] return self . decorated . wasSuccessful ( ) [EOL] [EOL] @ property def shouldStop ( self ) : [EOL] return self . decorated . shouldStop [EOL] [EOL] def stop ( self ) : [EOL] return self . decorated . stop ( ) [EOL] [EOL] @ property def testsRun ( self ) : [EOL] return self . decorated . testsRun [EOL] [EOL] def tags ( self , new_tags , gone_tags ) : [EOL] return self . decorated . tags ( new_tags , gone_tags ) [EOL] [EOL] def time ( self , a_datetime ) : [EOL] return self . decorated . time ( a_datetime ) [EOL] [EOL] [EOL] class HookedTestResultDecorator ( TestResultDecorator ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , decorated ) : [EOL] self . super = super ( HookedTestResultDecorator , self ) [EOL] self . super . __init__ ( decorated ) [EOL] [EOL] def startTest ( self , test ) : [EOL] self . _before_event ( ) [EOL] return self . super . startTest ( test ) [EOL] [EOL] def startTestRun ( self ) : [EOL] self . _before_event ( ) [EOL] return self . super . startTestRun ( ) [EOL] [EOL] def stopTest ( self , test ) : [EOL] self . _before_event ( ) [EOL] return self . super . stopTest ( test ) [EOL] [EOL] def stopTestRun ( self ) : [EOL] self . _before_event ( ) [EOL] return self . super . stopTestRun ( ) [EOL] [EOL] def addError ( self , test , err = None , details = None ) : [EOL] self . _before_event ( ) [EOL] return self . super . addError ( test , err , details = details ) [EOL] [EOL] def addFailure ( self , test , err = None , details = None ) : [EOL] self . _before_event ( ) [EOL] return self . super . addFailure ( test , err , details = details ) [EOL] [EOL] def addSuccess ( self , test , details = None ) : [EOL] self . _before_event ( ) [EOL] return self . super . addSuccess ( test , details = details ) [EOL] [EOL] def addSkip ( self , test , reason = None , details = None ) : [EOL] self . _before_event ( ) [EOL] return self . super . addSkip ( test , reason , details = details ) [EOL] [EOL] def addExpectedFailure ( self , test , err = None , details = None ) : [EOL] self . _before_event ( ) [EOL] return self . super . addExpectedFailure ( test , err , details = details ) [EOL] [EOL] def addUnexpectedSuccess ( self , test , details = None ) : [EOL] self . _before_event ( ) [EOL] return self . super . addUnexpectedSuccess ( test , details = details ) [EOL] [EOL] def progress ( self , offset , whence ) : [EOL] self . _before_event ( ) [EOL] return self . super . progress ( offset , whence ) [EOL] [EOL] def wasSuccessful ( self ) : [EOL] self . _before_event ( ) [EOL] return self . super . wasSuccessful ( ) [EOL] [EOL] @ property def shouldStop ( self ) : [EOL] self . _before_event ( ) [EOL] return self . super . shouldStop [EOL] [EOL] def stop ( self ) : [EOL] self . _before_event ( ) [EOL] return self . super . stop ( ) [EOL] [EOL] def time ( self , a_datetime ) : [EOL] self . _before_event ( ) [EOL] return self . super . time ( a_datetime ) [EOL] [EOL] [EOL] class AutoTimingTestResultDecorator ( HookedTestResultDecorator ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , decorated ) : [EOL] self . _time = None [EOL] super ( AutoTimingTestResultDecorator , self ) . __init__ ( decorated ) [EOL] [EOL] def _before_event ( self ) : [EOL] time = self . _time [EOL] if time is not None : [EOL] return [EOL] time = datetime . datetime . utcnow ( ) . replace ( tzinfo = iso8601 . Utc ( ) ) [EOL] self . decorated . time ( time ) [EOL] [EOL] def progress ( self , offset , whence ) : [EOL] return self . decorated . progress ( offset , whence ) [EOL] [EOL] @ property def shouldStop ( self ) : [EOL] return self . decorated . shouldStop [EOL] [EOL] def time ( self , a_datetime ) : [EOL] [docstring] [EOL] self . _time = a_datetime [EOL] return self . decorated . time ( a_datetime ) [EOL] [EOL] [EOL] class TagsMixin ( object ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . _clear_tags ( ) [EOL] [EOL] def _clear_tags ( self ) : [EOL] self . _global_tags = set ( ) , set ( ) [EOL] self . _test_tags = None [EOL] [EOL] def _get_active_tags ( self ) : [EOL] global_new , global_gone = self . _global_tags [EOL] if self . _test_tags is None : [EOL] return set ( global_new ) [EOL] test_new , test_gone = self . _test_tags [EOL] return global_new . difference ( test_gone ) . union ( test_new ) [EOL] [EOL] def _get_current_scope ( self ) : [EOL] if self . _test_tags : [EOL] return self . _test_tags [EOL] return self . _global_tags [EOL] [EOL] def _flush_current_scope ( self , tag_receiver ) : [EOL] new_tags , gone_tags = self . _get_current_scope ( ) [EOL] if new_tags or gone_tags : [EOL] tag_receiver . tags ( new_tags , gone_tags ) [EOL] if self . _test_tags : [EOL] self . _test_tags = set ( ) , set ( ) [EOL] else : [EOL] self . _global_tags = set ( ) , set ( ) [EOL] [EOL] def startTestRun ( self ) : [EOL] self . _clear_tags ( ) [EOL] [EOL] def startTest ( self , test ) : [EOL] self . _test_tags = set ( ) , set ( ) [EOL] [EOL] def stopTest ( self , test ) : [EOL] self . _test_tags = None [EOL] [EOL] def tags ( self , new_tags , gone_tags ) : [EOL] [docstring] [EOL] current_new_tags , current_gone_tags = self . _get_current_scope ( ) [EOL] current_new_tags . update ( new_tags ) [EOL] current_new_tags . difference_update ( gone_tags ) [EOL] current_gone_tags . update ( gone_tags ) [EOL] current_gone_tags . difference_update ( new_tags ) [EOL] [EOL] [EOL] class TagCollapsingDecorator ( HookedTestResultDecorator , TagsMixin ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , result ) : [EOL] super ( TagCollapsingDecorator , self ) . __init__ ( result ) [EOL] self . _clear_tags ( ) [EOL] [EOL] def _before_event ( self ) : [EOL] self . _flush_current_scope ( self . decorated ) [EOL] [EOL] def tags ( self , new_tags , gone_tags ) : [EOL] TagsMixin . tags ( self , new_tags , gone_tags ) [EOL] [EOL] [EOL] class TimeCollapsingDecorator ( HookedTestResultDecorator ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , decorated ) : [EOL] super ( TimeCollapsingDecorator , self ) . __init__ ( decorated ) [EOL] self . _last_received_time = None [EOL] self . _last_sent_time = None [EOL] [EOL] def _before_event ( self ) : [EOL] if self . _last_received_time is None : [EOL] return [EOL] if self . _last_received_time != self . _last_sent_time : [EOL] self . decorated . time ( self . _last_received_time ) [EOL] self . _last_sent_time = self . _last_received_time [EOL] self . _last_received_time = None [EOL] [EOL] def time ( self , a_time ) : [EOL] [comment] [EOL] [comment] [EOL] if self . _last_received_time is None : [EOL] self . decorated . time ( a_time ) [EOL] self . _last_sent_time = a_time [EOL] self . _last_received_time = a_time [EOL] [EOL] [EOL] def and_predicates ( predicates ) : [EOL] [docstring] [EOL] [comment] [EOL] return lambda * args , ** kwargs : all ( p ( * args , ** kwargs ) for p in predicates ) [EOL] [EOL] [EOL] def make_tag_filter ( with_tags , without_tags ) : [EOL] [docstring] [EOL] [EOL] with_tags = with_tags and set ( with_tags ) or None [EOL] without_tags = without_tags and set ( without_tags ) or None [EOL] [EOL] def check_tags ( test , outcome , err , details , tags ) : [EOL] if with_tags and not with_tags <= tags : [EOL] return False [EOL] if without_tags and bool ( without_tags & tags ) : [EOL] return False [EOL] return True [EOL] [EOL] return check_tags [EOL] [EOL] [EOL] class _PredicateFilter ( TestResultDecorator , TagsMixin ) : [EOL] [EOL] def __init__ ( self , result , predicate ) : [EOL] super ( _PredicateFilter , self ) . __init__ ( result ) [EOL] self . _clear_tags ( ) [EOL] self . decorated = TimeCollapsingDecorator ( TagCollapsingDecorator ( self . decorated ) ) [EOL] self . _predicate = predicate [EOL] [comment] [EOL] self . _current_test = None [EOL] [comment] [EOL] self . _current_test_filtered = None [EOL] [comment] [EOL] self . _buffered_calls = [ ] [EOL] [EOL] def filter_predicate ( self , test , outcome , error , details ) : [EOL] return self . _predicate ( test , outcome , error , details , self . _get_active_tags ( ) ) [EOL] [EOL] def addError ( self , test , err = None , details = None ) : [EOL] if ( self . filter_predicate ( test , [string] , err , details ) ) : [EOL] self . _buffered_calls . append ( ( [string] , [ test , err ] , { [string] : details } ) ) [EOL] else : [EOL] self . _filtered ( ) [EOL] [EOL] def addFailure ( self , test , err = None , details = None ) : [EOL] if ( self . filter_predicate ( test , [string] , err , details ) ) : [EOL] self . _buffered_calls . append ( ( [string] , [ test , err ] , { [string] : details } ) ) [EOL] else : [EOL] self . _filtered ( ) [EOL] [EOL] def addSkip ( self , test , reason = None , details = None ) : [EOL] if ( self . filter_predicate ( test , [string] , reason , details ) ) : [EOL] self . _buffered_calls . append ( ( [string] , [ test , reason ] , { [string] : details } ) ) [EOL] else : [EOL] self . _filtered ( ) [EOL] [EOL] def addExpectedFailure ( self , test , err = None , details = None ) : [EOL] if self . filter_predicate ( test , [string] , err , details ) : [EOL] self . _buffered_calls . append ( ( [string] , [ test , err ] , { [string] : details } ) ) [EOL] else : [EOL] self . _filtered ( ) [EOL] [EOL] def addUnexpectedSuccess ( self , test , details = None ) : [EOL] self . _buffered_calls . append ( ( [string] , [ test ] , { [string] : details } ) ) [EOL] [EOL] def addSuccess ( self , test , details = None ) : [EOL] if ( self . filter_predicate ( test , [string] , None , details ) ) : [EOL] self . _buffered_calls . append ( ( [string] , [ test ] , { [string] : details } ) ) [EOL] else : [EOL] self . _filtered ( ) [EOL] [EOL] def _filtered ( self ) : [EOL] self . _current_test_filtered = True [EOL] [EOL] def startTest ( self , test ) : [EOL] [docstring] [EOL] TagsMixin . startTest ( self , test ) [EOL] self . _current_test = test [EOL] self . _current_test_filtered = False [EOL] self . _buffered_calls . append ( ( [string] , [ test ] , { } ) ) [EOL] [EOL] def stopTest ( self , test ) : [EOL] [docstring] [EOL] if not self . _current_test_filtered : [EOL] for method , args , kwargs in self . _buffered_calls : [EOL] getattr ( self . decorated , method ) ( * args , ** kwargs ) [EOL] self . decorated . stopTest ( test ) [EOL] self . _current_test = None [EOL] self . _current_test_filtered = None [EOL] self . _buffered_calls = [ ] [EOL] TagsMixin . stopTest ( self , test ) [EOL] [EOL] def tags ( self , new_tags , gone_tags ) : [EOL] TagsMixin . tags ( self , new_tags , gone_tags ) [EOL] if self . _current_test is not None : [EOL] self . _buffered_calls . append ( ( [string] , [ new_tags , gone_tags ] , { } ) ) [EOL] else : [EOL] return super ( _PredicateFilter , self ) . tags ( new_tags , gone_tags ) [EOL] [EOL] def time ( self , a_time ) : [EOL] return self . decorated . time ( a_time ) [EOL] [EOL] def id_to_orig_id ( self , id ) : [EOL] if id . startswith ( [string] ) : [EOL] return id [ len ( [string] ) : ] [EOL] return id [EOL] [EOL] [EOL] class TestResultFilter ( TestResultDecorator ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , result , filter_error = False , filter_failure = False , filter_success = True , filter_skip = False , filter_xfail = False , filter_predicate = None , fixup_expected_failures = None ) : [EOL] [docstring] [EOL] predicates = [ ] [EOL] if filter_error : [EOL] predicates . append ( lambda t , outcome , e , d , tags : outcome != [string] ) [EOL] if filter_failure : [EOL] predicates . append ( lambda t , outcome , e , d , tags : outcome != [string] ) [EOL] if filter_success : [EOL] predicates . append ( lambda t , outcome , e , d , tags : outcome != [string] ) [EOL] if filter_skip : [EOL] predicates . append ( lambda t , outcome , e , d , tags : outcome != [string] ) [EOL] if filter_xfail : [EOL] predicates . append ( lambda t , outcome , e , d , tags : outcome != [string] ) [EOL] if filter_predicate is not None : [EOL] def compat ( test , outcome , error , details , tags ) : [EOL] [comment] [EOL] try : [EOL] return filter_predicate ( test , outcome , error , details , tags ) [EOL] except TypeError : [EOL] return filter_predicate ( test , outcome , error , details ) [EOL] predicates . append ( compat ) [EOL] predicate = and_predicates ( predicates ) [EOL] super ( TestResultFilter , self ) . __init__ ( _PredicateFilter ( result , predicate ) ) [EOL] if fixup_expected_failures is None : [EOL] self . _fixup_expected_failures = frozenset ( ) [EOL] else : [EOL] self . _fixup_expected_failures = fixup_expected_failures [EOL] [EOL] def addError ( self , test , err = None , details = None ) : [EOL] if self . _failure_expected ( test ) : [EOL] self . addExpectedFailure ( test , err = err , details = details ) [EOL] else : [EOL] super ( TestResultFilter , self ) . addError ( test , err = err , details = details ) [EOL] [EOL] def addFailure ( self , test , err = None , details = None ) : [EOL] if self . _failure_expected ( test ) : [EOL] self . addExpectedFailure ( test , err = err , details = details ) [EOL] else : [EOL] super ( TestResultFilter , self ) . addFailure ( test , err = err , details = details ) [EOL] [EOL] def addSuccess ( self , test , details = None ) : [EOL] if self . _failure_expected ( test ) : [EOL] self . addUnexpectedSuccess ( test , details = details ) [EOL] else : [EOL] super ( TestResultFilter , self ) . addSuccess ( test , details = details ) [EOL] [EOL] def _failure_expected ( self , test ) : [EOL] return ( test . id ( ) in self . _fixup_expected_failures ) [EOL] [EOL] [EOL] class TestIdPrintingResult ( testtools . TestResult ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , stream , show_times = False , show_exists = False ) : [EOL] [docstring] [EOL] super ( TestIdPrintingResult , self ) . __init__ ( ) [EOL] self . _stream = stream [EOL] self . show_exists = show_exists [EOL] self . show_times = show_times [EOL] [EOL] def startTestRun ( self ) : [EOL] self . failed_tests = [number] [EOL] self . __time = None [EOL] self . _test = None [EOL] self . _test_duration = [number] [EOL] self . _active_tests = { } [EOL] [EOL] def addError ( self , test , err ) : [EOL] self . failed_tests += [number] [EOL] self . _test = test [EOL] [EOL] def addFailure ( self , test , err ) : [EOL] self . failed_tests += [number] [EOL] self . _test = test [EOL] [EOL] def addSuccess ( self , test ) : [EOL] self . _test = test [EOL] [EOL] def addSkip ( self , test , reason = None , details = None ) : [EOL] self . _test = test [EOL] [EOL] def addUnexpectedSuccess ( self , test , details = None ) : [EOL] self . failed_tests += [number] [EOL] self . _test = test [EOL] [EOL] def addExpectedFailure ( self , test , err = None , details = None ) : [EOL] self . _test = test [EOL] [EOL] def reportTest ( self , test_id , duration ) : [EOL] if self . show_times : [EOL] seconds = duration . seconds [EOL] seconds += duration . days * [number] * [number] [EOL] seconds += duration . microseconds / [number] [EOL] self . _stream . write ( test_id + [string] % seconds ) [EOL] else : [EOL] self . _stream . write ( test_id + [string] ) [EOL] [EOL] def startTest ( self , test ) : [EOL] self . _start_time = self . _time ( ) [EOL] [EOL] def status ( self , test_id = None , test_status = None , test_tags = None , runnable = True , file_name = None , file_bytes = None , eof = False , mime_type = None , route_code = None , timestamp = None ) : [EOL] if not test_id : [EOL] return [EOL] if timestamp is not None : [EOL] self . time ( timestamp ) [EOL] if test_status == [string] : [EOL] if self . show_exists : [EOL] self . reportTest ( test_id , [number] ) [EOL] elif test_status in ( [string] , None ) : [EOL] self . _active_tests [ test_id ] = self . _time ( ) [EOL] else : [EOL] self . _end_test ( test_id ) [EOL] [EOL] def _end_test ( self , test_id ) : [EOL] test_start = self . _active_tests . pop ( test_id , None ) [EOL] if not test_start : [EOL] test_duration = [number] [EOL] else : [EOL] test_duration = self . _time ( ) - test_start [EOL] self . reportTest ( test_id , test_duration ) [EOL] [EOL] def stopTest ( self , test ) : [EOL] test_duration = self . _time ( ) - self . _start_time [EOL] self . reportTest ( self . _test . id ( ) , test_duration ) [EOL] [EOL] def time ( self , time ) : [EOL] self . __time = time [EOL] [EOL] def _time ( self ) : [EOL] return self . __time [EOL] [EOL] def wasSuccessful ( self ) : [EOL] [docstring] [EOL] return self . failed_tests == [number] [EOL] [EOL] def stopTestRun ( self ) : [EOL] for test_id in list ( self . _active_tests . keys ( ) ) : [EOL] self . _end_test ( test_id ) [EOL] [EOL] [EOL] class TestByTestResult ( testtools . TestResult ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __init__ ( self , on_test ) : [EOL] [docstring] [EOL] super ( TestByTestResult , self ) . __init__ ( ) [EOL] self . _on_test = on_test [EOL] [EOL] def startTest ( self , test ) : [EOL] super ( TestByTestResult , self ) . startTest ( test ) [EOL] self . _start_time = self . _now ( ) [EOL] [comment] [EOL] [comment] [EOL] self . _status = None [EOL] self . _details = None [EOL] self . _stop_time = None [EOL] [EOL] def stopTest ( self , test ) : [EOL] self . _stop_time = self . _now ( ) [EOL] super ( TestByTestResult , self ) . stopTest ( test ) [EOL] self . _on_test ( test = test , status = self . _status , start_time = self . _start_time , stop_time = self . _stop_time , tags = getattr ( self , [string] , None ) , details = self . _details ) [EOL] [EOL] def _err_to_details ( self , test , err , details ) : [EOL] if details : [EOL] return details [EOL] return { [string] : TracebackContent ( err , test ) } [EOL] [EOL] def addSuccess ( self , test , details = None ) : [EOL] super ( TestByTestResult , self ) . addSuccess ( test ) [EOL] self . _status = [string] [EOL] self . _details = details [EOL] [EOL] def addFailure ( self , test , err = None , details = None ) : [EOL] super ( TestByTestResult , self ) . addFailure ( test , err , details ) [EOL] self . _status = [string] [EOL] self . _details = self . _err_to_details ( test , err , details ) [EOL] [EOL] def addError ( self , test , err = None , details = None ) : [EOL] super ( TestByTestResult , self ) . addError ( test , err , details ) [EOL] self . _status = [string] [EOL] self . _details = self . _err_to_details ( test , err , details ) [EOL] [EOL] def addSkip ( self , test , reason = None , details = None ) : [EOL] super ( TestByTestResult , self ) . addSkip ( test , reason , details ) [EOL] self . _status = [string] [EOL] if details is None : [EOL] details = { [string] : text_content ( reason ) } [EOL] elif reason : [EOL] [comment] [EOL] details [ [string] ] = text_content ( reason ) [EOL] self . _details = details [EOL] [EOL] def addExpectedFailure ( self , test , err = None , details = None ) : [EOL] super ( TestByTestResult , self ) . addExpectedFailure ( test , err , details ) [EOL] self . _status = [string] [EOL] self . _details = self . _err_to_details ( test , err , details ) [EOL] [EOL] def addUnexpectedSuccess ( self , test , details = None ) : [EOL] super ( TestByTestResult , self ) . addUnexpectedSuccess ( test , details ) [EOL] self . _status = [string] [EOL] self . _details = details [EOL] [EOL] [EOL] class CsvResult ( TestByTestResult ) : [EOL] [EOL] def __init__ ( self , stream ) : [EOL] super ( CsvResult , self ) . __init__ ( self . _on_test ) [EOL] self . _write_row = csv . writer ( stream ) . writerow [EOL] [EOL] def _on_test ( self , test , status , start_time , stop_time , tags , details ) : [EOL] self . _write_row ( [ test . id ( ) , status , start_time , stop_time ] ) [EOL] [EOL] def startTestRun ( self ) : [EOL] super ( CsvResult , self ) . startTestRun ( ) [EOL] self . _write_row ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] class CatFiles ( StreamResult ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , byte_stream ) : [EOL] self . stream = subunit . make_stream_binary ( byte_stream ) [EOL] [EOL] def status ( self , test_id = None , test_status = None , test_tags = None , runnable = True , file_name = None , file_bytes = None , eof = False , mime_type = None , route_code = None , timestamp = None ) : [EOL] if file_name is not None : [EOL] self . stream . write ( file_bytes ) [EOL] self . stream . flush ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.property$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.super$ 0 $builtins.super$ 0 0 0 0 0 0 0 0 $builtins.super$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from io import BytesIO [EOL] import datetime [EOL] [EOL] from testtools import TestCase [EOL] from testtools . matchers import Contains , HasLength [EOL] from testtools . tests . test_testresult import TestStreamResultContract [EOL] from testtools . testresult . doubles import StreamResult [EOL] [EOL] import subunit [EOL] import subunit . iso8601 as iso8601 [EOL] [EOL] CONSTANT_ENUM = [string] [EOL] CONSTANT_INPROGRESS = [string] [EOL] CONSTANT_SUCCESS = [string] [EOL] CONSTANT_UXSUCCESS = [string] [EOL] CONSTANT_SKIP = [string] [EOL] CONSTANT_FAIL = [string] [EOL] CONSTANT_XFAIL = [string] [EOL] CONSTANT_EOF = [string] [EOL] CONSTANT_FILE_CONTENT = [string] [EOL] CONSTANT_MIME = [string] [EOL] CONSTANT_TIMESTAMP = [string] [EOL] CONSTANT_ROUTE_CODE = [string] [EOL] CONSTANT_RUNNABLE = [string] [EOL] CONSTANT_TAGS = [ [string] , [string] , ] [EOL] [EOL] [EOL] class TestStreamResultToBytesContract ( TestCase , TestStreamResultContract ) : [EOL] [docstring] [EOL] [EOL] def _make_result ( self ) : [EOL] return subunit . StreamResultToBytes ( BytesIO ( ) ) [EOL] [EOL] [EOL] class TestStreamResultToBytes ( TestCase ) : [EOL] [EOL] def _make_result ( self ) : [EOL] output = BytesIO ( ) [EOL] return subunit . StreamResultToBytes ( output ) , output [EOL] [EOL] def test_numbers ( self ) : [EOL] result = subunit . StreamResultToBytes ( BytesIO ( ) ) [EOL] packet = [ ] [EOL] self . assertRaises ( Exception , result . _write_number , - [number] , packet ) [EOL] self . assertEqual ( [ ] , packet ) [EOL] result . _write_number ( [number] , packet ) [EOL] self . assertEqual ( [ [string] ] , packet ) [EOL] del packet [ : ] [EOL] result . _write_number ( [number] , packet ) [EOL] self . assertEqual ( [ [string] ] , packet ) [EOL] del packet [ : ] [EOL] result . _write_number ( [number] , packet ) [EOL] self . assertEqual ( [ [string] ] , packet ) [EOL] del packet [ : ] [EOL] result . _write_number ( [number] , packet ) [EOL] self . assertEqual ( [ [string] ] , packet ) [EOL] del packet [ : ] [EOL] result . _write_number ( [number] , packet ) [EOL] self . assertEqual ( [ [string] , [string] ] , packet ) [EOL] del packet [ : ] [EOL] result . _write_number ( [number] , packet ) [EOL] self . assertEqual ( [ [string] , [string] ] , packet ) [EOL] del packet [ : ] [EOL] result . _write_number ( [number] , packet ) [EOL] self . assertEqual ( [ [string] ] , packet ) [EOL] del packet [ : ] [EOL] result . _write_number ( [number] , packet ) [EOL] self . assertEqual ( [ [string] ] , packet ) [EOL] del packet [ : ] [EOL] self . assertRaises ( Exception , result . _write_number , [number] , packet ) [EOL] self . assertEqual ( [ ] , packet ) [EOL] [EOL] def test_volatile_length ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] result , output = self . _make_result ( ) [EOL] [comment] [EOL] result . status ( file_name = [string] , file_bytes = [string] * [number] ) [EOL] self . assertThat ( output . getvalue ( ) , HasLength ( [number] ) ) [EOL] self . assertEqual ( [string] , output . getvalue ( ) [ [number] : [number] ] ) [EOL] output . seek ( [number] ) [EOL] output . truncate ( ) [EOL] [comment] [EOL] result . status ( file_name = [string] , file_bytes = [string] * [number] ) [EOL] self . assertThat ( output . getvalue ( ) , HasLength ( [number] ) ) [EOL] self . assertEqual ( [string] , output . getvalue ( ) [ [number] : [number] ] ) [EOL] output . seek ( [number] ) [EOL] output . truncate ( ) [EOL] [comment] [EOL] result . status ( file_name = [string] , file_bytes = [string] * [number] ) [EOL] self . assertThat ( output . getvalue ( ) , HasLength ( [number] ) ) [EOL] self . assertEqual ( [string] , output . getvalue ( ) [ [number] : [number] ] ) [EOL] output . seek ( [number] ) [EOL] output . truncate ( ) [EOL] [comment] [EOL] result . status ( file_name = [string] , file_bytes = [string] * [number] ) [EOL] self . assertThat ( output . getvalue ( ) , HasLength ( [number] ) ) [EOL] self . assertEqual ( [string] , output . getvalue ( ) [ [number] : [number] ] ) [EOL] output . seek ( [number] ) [EOL] output . truncate ( ) [EOL] [comment] [EOL] result . status ( file_name = [string] , file_bytes = [string] * [number] ) [EOL] self . assertThat ( output . getvalue ( ) , HasLength ( [number] ) ) [EOL] self . assertEqual ( [string] , output . getvalue ( ) [ [number] : [number] ] ) [EOL] output . seek ( [number] ) [EOL] output . truncate ( ) [EOL] [comment] [EOL] result . status ( file_name = [string] , file_bytes = [string] * [number] ) [EOL] self . assertThat ( output . getvalue ( ) , HasLength ( [number] ) ) [EOL] self . assertEqual ( [string] , output . getvalue ( ) [ [number] : [number] ] ) [EOL] output . seek ( [number] ) [EOL] output . truncate ( ) [EOL] self . assertRaises ( Exception , result . status , file_name = [string] , file_bytes = [string] * [number] ) [EOL] [EOL] def test_trivial_enumeration ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( [string] , [string] ) [EOL] self . assertEqual ( CONSTANT_ENUM , output . getvalue ( ) ) [EOL] [EOL] def test_inprogress ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( [string] , [string] ) [EOL] self . assertEqual ( CONSTANT_INPROGRESS , output . getvalue ( ) ) [EOL] [EOL] def test_success ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( [string] , [string] ) [EOL] self . assertEqual ( CONSTANT_SUCCESS , output . getvalue ( ) ) [EOL] [EOL] def test_uxsuccess ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( [string] , [string] ) [EOL] self . assertEqual ( CONSTANT_UXSUCCESS , output . getvalue ( ) ) [EOL] [EOL] def test_skip ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( [string] , [string] ) [EOL] self . assertEqual ( CONSTANT_SKIP , output . getvalue ( ) ) [EOL] [EOL] def test_fail ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( [string] , [string] ) [EOL] self . assertEqual ( CONSTANT_FAIL , output . getvalue ( ) ) [EOL] [EOL] def test_xfail ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( [string] , [string] ) [EOL] self . assertEqual ( CONSTANT_XFAIL , output . getvalue ( ) ) [EOL] [EOL] def test_unknown_status ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] self . assertRaises ( Exception , result . status , [string] , [string] ) [EOL] self . assertEqual ( [string] , output . getvalue ( ) ) [EOL] [EOL] def test_eof ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( eof = True ) [EOL] self . assertEqual ( CONSTANT_EOF , output . getvalue ( ) ) [EOL] [EOL] def test_file_content ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( file_name = [string] , file_bytes = [string] ) [EOL] self . assertEqual ( CONSTANT_FILE_CONTENT , output . getvalue ( ) ) [EOL] [EOL] def test_mime ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( mime_type = [string] ) [EOL] self . assertEqual ( CONSTANT_MIME , output . getvalue ( ) ) [EOL] [EOL] def test_route_code ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( test_id = [string] , test_status = [string] , route_code = [string] ) [EOL] self . assertEqual ( CONSTANT_ROUTE_CODE , output . getvalue ( ) ) [EOL] [EOL] def test_runnable ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( [string] , [string] , runnable = False ) [EOL] self . assertEqual ( CONSTANT_RUNNABLE , output . getvalue ( ) ) [EOL] [EOL] def test_tags ( self ) : [EOL] result , output = self . _make_result ( ) [EOL] result . status ( test_id = [string] , test_tags = set ( [ [string] , [string] ] ) ) [EOL] self . assertThat ( CONSTANT_TAGS , Contains ( output . getvalue ( ) ) ) [EOL] [EOL] def test_timestamp ( self ) : [EOL] timestamp = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , iso8601 . Utc ( ) ) [EOL] result , output = self . _make_result ( ) [EOL] result . status ( test_id = [string] , test_status = [string] , timestamp = timestamp ) [EOL] self . assertEqual ( CONSTANT_TIMESTAMP , output . getvalue ( ) ) [EOL] [EOL] [EOL] class TestByteStreamToStreamResult ( TestCase ) : [EOL] [EOL] def test_non_subunit_encapsulated ( self ) : [EOL] source = BytesIO ( [string] ) [EOL] result = StreamResult ( ) [EOL] subunit . ByteStreamToStreamResult ( source , non_subunit_name = [string] ) . run ( result ) [EOL] self . assertEqual ( [ ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ] , result . _events ) [EOL] self . assertEqual ( [string] , source . read ( ) ) [EOL] [EOL] def test_signature_middle_utf8_char ( self ) : [EOL] utf8_bytes = [string] [EOL] source = BytesIO ( utf8_bytes ) [EOL] [comment] [EOL] result = StreamResult ( ) [EOL] subunit . ByteStreamToStreamResult ( source , non_subunit_name = [string] ) . run ( result ) [EOL] self . assertEqual ( [ ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ( [string] , None , None , None , True , [string] , [string] , False , None , None , None ) , ] , result . _events ) [EOL] [EOL] def test_non_subunit_disabled_raises ( self ) : [EOL] source = BytesIO ( [string] ) [EOL] result = StreamResult ( ) [EOL] case = subunit . ByteStreamToStreamResult ( source ) [EOL] e = self . assertRaises ( Exception , case . run , result ) [EOL] self . assertEqual ( [string] , e . args [ [number] ] ) [EOL] self . assertEqual ( [string] , source . read ( ) ) [EOL] self . assertEqual ( [ ] , result . _events ) [EOL] [EOL] def test_trivial_enumeration ( self ) : [EOL] source = BytesIO ( CONSTANT_ENUM ) [EOL] result = StreamResult ( ) [EOL] subunit . ByteStreamToStreamResult ( source , non_subunit_name = [string] ) . run ( result ) [EOL] self . assertEqual ( [string] , source . read ( ) ) [EOL] self . assertEqual ( [ ( [string] , [string] , [string] , None , True , None , None , False , None , None , None ) , ] , result . _events ) [EOL] [EOL] def test_multiple_events ( self ) : [EOL] source = BytesIO ( CONSTANT_ENUM + CONSTANT_ENUM ) [EOL] result = StreamResult ( ) [EOL] subunit . ByteStreamToStreamResult ( source , non_subunit_name = [string] ) . run ( result ) [EOL] self . assertEqual ( [string] , source . read ( ) ) [EOL] self . assertEqual ( [ ( [string] , [string] , [string] , None , True , None , None , False , None , None , None ) , ( [string] , [string] , [string] , None , True , None , None , False , None , None , None ) , ] , result . _events ) [EOL] [EOL] def test_inprogress ( self ) : [EOL] self . check_event ( CONSTANT_INPROGRESS , [string] ) [EOL] [EOL] def test_success ( self ) : [EOL] self . check_event ( CONSTANT_SUCCESS , [string] ) [EOL] [EOL] def test_uxsuccess ( self ) : [EOL] self . check_event ( CONSTANT_UXSUCCESS , [string] ) [EOL] [EOL] def test_skip ( self ) : [EOL] self . check_event ( CONSTANT_SKIP , [string] ) [EOL] [EOL] def test_fail ( self ) : [EOL] self . check_event ( CONSTANT_FAIL , [string] ) [EOL] [EOL] def test_xfail ( self ) : [EOL] self . check_event ( CONSTANT_XFAIL , [string] ) [EOL] [EOL] def check_events ( self , source_bytes , events ) : [EOL] source = BytesIO ( source_bytes ) [EOL] result = StreamResult ( ) [EOL] subunit . ByteStreamToStreamResult ( source , non_subunit_name = [string] ) . run ( result ) [EOL] self . assertEqual ( [string] , source . read ( ) ) [EOL] self . assertEqual ( events , result . _events ) [EOL] [comment] [EOL] for event in result . _events : [EOL] if event [ [number] ] is not None : [EOL] self . assertIsInstance ( event [ [number] ] , bytes ) [EOL] [EOL] def check_event ( self , source_bytes , test_status = None , test_id = [string] , route_code = None , timestamp = None , tags = None , mime_type = None , file_name = None , file_bytes = None , eof = False , runnable = True ) : [EOL] event = self . _event ( test_id = test_id , test_status = test_status , tags = tags , runnable = runnable , file_name = file_name , file_bytes = file_bytes , eof = eof , mime_type = mime_type , route_code = route_code , timestamp = timestamp ) [EOL] self . check_events ( source_bytes , [ event ] ) [EOL] [EOL] def _event ( self , test_status = None , test_id = None , route_code = None , timestamp = None , tags = None , mime_type = None , file_name = None , file_bytes = None , eof = False , runnable = True ) : [EOL] return ( [string] , test_id , test_status , tags , runnable , file_name , file_bytes , eof , mime_type , route_code , timestamp ) [EOL] [EOL] def test_eof ( self ) : [EOL] self . check_event ( CONSTANT_EOF , test_id = None , eof = True ) [EOL] [EOL] def test_file_content ( self ) : [EOL] self . check_event ( CONSTANT_FILE_CONTENT , test_id = None , file_name = [string] , file_bytes = [string] ) [EOL] [EOL] def test_file_content_length_into_checksum ( self ) : [EOL] [comment] [EOL] bad_file_length_content = [string] [EOL] self . check_events ( bad_file_length_content , [ self . _event ( test_id = [string] , eof = True , file_name = [string] , file_bytes = bad_file_length_content , mime_type = [string] ) , self . _event ( test_id = [string] , test_status = [string] , eof = True , file_name = [string] , file_bytes = [string] , mime_type = [string] ) , ] ) [EOL] [EOL] def test_packet_length_4_word_varint ( self ) : [EOL] packet_data = [string] [EOL] self . check_events ( packet_data , [ self . _event ( test_id = [string] , eof = True , file_name = [string] , file_bytes = packet_data , mime_type = [string] ) , self . _event ( test_id = [string] , test_status = [string] , eof = True , file_name = [string] , file_bytes = [string] , mime_type = [string] ) , ] ) [EOL] [EOL] def test_mime ( self ) : [EOL] self . check_event ( CONSTANT_MIME , test_id = None , mime_type = [string] ) [EOL] [EOL] def test_route_code ( self ) : [EOL] self . check_event ( CONSTANT_ROUTE_CODE , [string] , route_code = [string] , test_id = [string] ) [EOL] [EOL] def test_runnable ( self ) : [EOL] self . check_event ( CONSTANT_RUNNABLE , test_status = [string] , runnable = False ) [EOL] [EOL] def test_tags ( self ) : [EOL] self . check_event ( CONSTANT_TAGS [ [number] ] , None , tags = set ( [ [string] , [string] ] ) , test_id = [string] ) [EOL] [EOL] def test_timestamp ( self ) : [EOL] timestamp = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , iso8601 . Utc ( ) ) [EOL] self . check_event ( CONSTANT_TIMESTAMP , [string] , test_id = [string] , timestamp = timestamp ) [EOL] [EOL] def test_bad_crc_errors_via_status ( self ) : [EOL] file_bytes = CONSTANT_MIME [ : - [number] ] + [string] [EOL] self . check_events ( file_bytes , [ self . _event ( test_id = [string] , eof = True , file_name = [string] , file_bytes = file_bytes , mime_type = [string] ) , self . _event ( test_id = [string] , test_status = [string] , eof = True , file_name = [string] , file_bytes = [string] [string] , mime_type = [string] ) , ] ) [EOL] [EOL] def test_not_utf8_in_string ( self ) : [EOL] file_bytes = CONSTANT_ROUTE_CODE [ : [number] ] + [string] + CONSTANT_ROUTE_CODE [ [number] : - [number] ] + [string] [EOL] self . check_events ( file_bytes , [ self . _event ( test_id = [string] , eof = True , file_name = [string] , file_bytes = file_bytes , mime_type = [string] ) , self . _event ( test_id = [string] , test_status = [string] , eof = True , file_name = [string] , file_bytes = [string] , mime_type = [string] ) , ] ) [EOL] [EOL] def test_NULL_in_string ( self ) : [EOL] file_bytes = CONSTANT_ROUTE_CODE [ : [number] ] + [string] + CONSTANT_ROUTE_CODE [ [number] : - [number] ] + [string] [EOL] self . check_events ( file_bytes , [ self . _event ( test_id = [string] , eof = True , file_name = [string] , file_bytes = file_bytes , mime_type = [string] ) , self . _event ( test_id = [string] , test_status = [string] , eof = True , file_name = [string] , file_bytes = [string] , mime_type = [string] ) , ] ) [EOL] [EOL] def test_bad_utf8_stringlength ( self ) : [EOL] file_bytes = CONSTANT_ROUTE_CODE [ : [number] ] + [string] + CONSTANT_ROUTE_CODE [ [number] : - [number] ] + [string] [EOL] self . check_events ( file_bytes , [ self . _event ( test_id = [string] , eof = True , file_name = [string] , file_bytes = file_bytes , mime_type = [string] ) , self . _event ( test_id = [string] , test_status = [string] , eof = True , file_name = [string] , file_bytes = [string] [string] , mime_type = [string] ) , ] ) [EOL] [EOL] def test_route_code_and_file_content ( self ) : [EOL] content = BytesIO ( ) [EOL] subunit . StreamResultToBytes ( content ) . status ( route_code = [string] , mime_type = [string] , file_name = [string] , file_bytes = [string] ) [EOL] self . check_event ( content . getvalue ( ) , test_id = None , file_name = [string] , route_code = [string] , mime_type = [string] , file_bytes = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import sys [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] import subunit [EOL] from subunit . progress_model import ProgressModel [EOL] [EOL] [EOL] class TestProgressModel ( unittest . TestCase ) : [EOL] [EOL] def assertProgressSummary ( self , pos , total , progress ) : [EOL] [docstring] [EOL] self . assertEqual ( pos , progress . pos ( ) ) [EOL] self . assertEqual ( total , progress . width ( ) ) [EOL] [EOL] def test_new_progress_0_0 ( self ) : [EOL] progress = ProgressModel ( ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_advance_0_0 ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . advance ( ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_advance_1_0 ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . advance ( ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_set_width_absolute ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . set_width ( [number] ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_set_width_absolute_preserves_pos ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . advance ( ) [EOL] progress . set_width ( [number] ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_adjust_width ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . adjust_width ( [number] ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] progress . adjust_width ( - [number] ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_adjust_width_preserves_pos ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . advance ( ) [EOL] progress . adjust_width ( [number] ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] progress . adjust_width ( - [number] ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_push_preserves_progress ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . adjust_width ( [number] ) [EOL] progress . advance ( ) [EOL] progress . push ( ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_advance_advances_substack ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . adjust_width ( [number] ) [EOL] progress . advance ( ) [EOL] progress . push ( ) [EOL] progress . adjust_width ( [number] ) [EOL] progress . advance ( ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_adjust_width_adjusts_substack ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . adjust_width ( [number] ) [EOL] progress . advance ( ) [EOL] progress . push ( ) [EOL] progress . adjust_width ( [number] ) [EOL] progress . advance ( ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_set_width_adjusts_substack ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . adjust_width ( [number] ) [EOL] progress . advance ( ) [EOL] progress . push ( ) [EOL] progress . set_width ( [number] ) [EOL] progress . advance ( ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL] [EOL] def test_pop_restores_progress ( self ) : [EOL] progress = ProgressModel ( ) [EOL] progress . adjust_width ( [number] ) [EOL] progress . advance ( ) [EOL] progress . push ( ) [EOL] progress . adjust_width ( [number] ) [EOL] progress . advance ( ) [EOL] progress . pop ( ) [EOL] self . assertProgressSummary ( [number] , [number] , progress ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import unittest [EOL] [EOL] from testtools . compat import _b , StringIO [EOL] [EOL] import subunit . tests [EOL] from subunit import content , content_type , details [EOL] [EOL] [EOL] class TestSimpleDetails ( unittest . TestCase ) : [EOL] [EOL] def test_lineReceived ( self ) : [EOL] parser = details . SimpleDetailsParser ( None ) [EOL] parser . lineReceived ( _b ( [string] ) ) [EOL] parser . lineReceived ( _b ( [string] ) ) [EOL] self . assertEqual ( _b ( [string] ) , parser . _message ) [EOL] [EOL] def test_lineReceived_escaped_bracket ( self ) : [EOL] parser = details . SimpleDetailsParser ( None ) [EOL] parser . lineReceived ( _b ( [string] ) ) [EOL] parser . lineReceived ( _b ( [string] ) ) [EOL] parser . lineReceived ( _b ( [string] ) ) [EOL] self . assertEqual ( _b ( [string] ) , parser . _message ) [EOL] [EOL] def test_get_message ( self ) : [EOL] parser = details . SimpleDetailsParser ( None ) [EOL] self . assertEqual ( _b ( [string] ) , parser . get_message ( ) ) [EOL] [EOL] def test_get_details ( self ) : [EOL] parser = details . SimpleDetailsParser ( None ) [EOL] traceback = [string] [EOL] expected = { } [EOL] expected [ [string] ] = content . Content ( content_type . ContentType ( [string] , [string] , { [string] : [string] } ) , lambda : [ _b ( [string] ) ] ) [EOL] found = parser . get_details ( ) [EOL] self . assertEqual ( expected . keys ( ) , found . keys ( ) ) [EOL] self . assertEqual ( expected [ [string] ] . content_type , found [ [string] ] . content_type ) [EOL] self . assertEqual ( _b ( [string] ) . join ( expected [ [string] ] . iter_bytes ( ) ) , _b ( [string] ) . join ( found [ [string] ] . iter_bytes ( ) ) ) [EOL] [EOL] def test_get_details_skip ( self ) : [EOL] parser = details . SimpleDetailsParser ( None ) [EOL] traceback = [string] [EOL] expected = { } [EOL] expected [ [string] ] = content . Content ( content_type . ContentType ( [string] , [string] ) , lambda : [ _b ( [string] ) ] ) [EOL] found = parser . get_details ( [string] ) [EOL] self . assertEqual ( expected , found ) [EOL] [EOL] def test_get_details_success ( self ) : [EOL] parser = details . SimpleDetailsParser ( None ) [EOL] traceback = [string] [EOL] expected = { } [EOL] expected [ [string] ] = content . Content ( content_type . ContentType ( [string] , [string] ) , lambda : [ _b ( [string] ) ] ) [EOL] found = parser . get_details ( [string] ) [EOL] self . assertEqual ( expected , found ) [EOL] [EOL] [EOL] class TestMultipartDetails ( unittest . TestCase ) : [EOL] [EOL] def test_get_message_is_None ( self ) : [EOL] parser = details . MultipartDetailsParser ( None ) [EOL] self . assertEqual ( None , parser . get_message ( ) ) [EOL] [EOL] def test_get_details ( self ) : [EOL] parser = details . MultipartDetailsParser ( None ) [EOL] self . assertEqual ( { } , parser . get_details ( ) ) [EOL] [EOL] def test_parts ( self ) : [EOL] parser = details . MultipartDetailsParser ( None ) [EOL] parser . lineReceived ( _b ( [string] ) ) [EOL] parser . lineReceived ( _b ( [string] ) ) [EOL] parser . lineReceived ( _b ( [string] ) ) [EOL] parser . lineReceived ( _b ( [string] ) ) [EOL] parser . lineReceived ( _b ( [string] ) ) [EOL] expected = { } [EOL] expected [ [string] ] = content . Content ( content_type . ContentType ( [string] , [string] ) , lambda : [ _b ( [string] ) ] ) [EOL] found = parser . get_details ( ) [EOL] self . assertEqual ( expected . keys ( ) , found . keys ( ) ) [EOL] self . assertEqual ( expected [ [string] ] . content_type , found [ [string] ] . content_type ) [EOL] self . assertEqual ( _b ( [string] ) . join ( expected [ [string] ] . iter_bytes ( ) ) , _b ( [string] ) . join ( found [ [string] ] . iter_bytes ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import sys [EOL] if sys . platform == [string] : [EOL] import msvcrt , os [EOL] msvcrt . setmode ( sys . stdout . fileno ( ) , os . O_BINARY ) [EOL] if len ( sys . argv ) == [number] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from io import BytesIO , StringIO [EOL] import unittest [EOL] [EOL] from testtools import TestCase [EOL] from testtools . compat import _u [EOL] from testtools . testresult . doubles import StreamResult [EOL] [EOL] import subunit [EOL] [EOL] UTF8_TEXT = [string] [EOL] [EOL] [EOL] class TestTAP2SubUnit ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] super ( TestTAP2SubUnit , self ) . setUp ( ) [EOL] self . tap = StringIO ( ) [EOL] self . subunit = BytesIO ( ) [EOL] [EOL] def test_skip_entire_file ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , True , [string] , [string] , True , None , None , None ) ] ) [EOL] [EOL] def test_ok_test_pass ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_ok_test_number_pass ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_ok_test_number_description_pass ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_ok_test_description_pass ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_ok_SKIP_skip ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_ok_skip_number_comment_lowercase ( self ) : [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) ] ) [EOL] [EOL] def test_ok_number_description_SKIP_skip_comment ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) ] ) [EOL] [EOL] def test_ok_SKIP_skip_comment ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) ] ) [EOL] [EOL] def test_ok_TODO_xfail ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_ok_TODO_xfail_comment ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) ] ) [EOL] [EOL] def test_bail_out_errors ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_missing_test_at_end_with_plan_adds_error ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) ] ) [EOL] [EOL] def test_missing_test_with_plan_adds_error ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_missing_test_no_plan_adds_error ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_four_tests_in_a_row_trailing_plan ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_four_tests_in_a_row_with_plan ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_four_tests_in_a_row_no_plan ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_todo_and_skip ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . subunit . seek ( [number] ) [EOL] events = StreamResult ( ) [EOL] subunit . ByteStreamToStreamResult ( self . subunit ) . run ( events ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) , ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) ] ) [EOL] [EOL] def test_leading_comments_add_to_next_test_log ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) , ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) ] ) [EOL] [EOL] def test_trailing_comments_are_included_in_last_test_log ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . write ( _u ( [string] ) ) [EOL] self . tap . seek ( [number] ) [EOL] result = subunit . TAP2SubUnit ( self . tap , self . subunit ) [EOL] self . assertEqual ( [number] , result ) [EOL] self . check_events ( [ ( [string] , [string] , [string] , None , False , None , None , True , None , None , None ) , ( [string] , [string] , [string] , None , False , [string] , [string] , True , [string] , None , None ) ] ) [EOL] [EOL] def check_events ( self , events ) : [EOL] self . subunit . seek ( [number] ) [EOL] eventstream = StreamResult ( ) [EOL] subunit . ByteStreamToStreamResult ( self . subunit ) . run ( eventstream ) [EOL] self . assertEqual ( events , eventstream . _events ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
[comment] [EOL] [EOL] from typing import Iterator [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] [EOL] from unittest import TestSuite , TestLoader [EOL] [EOL] [EOL] def test_suite ( ) : [EOL] from extras . tests import ( test_extras , ) [EOL] modules = [ test_extras , ] [EOL] loader = TestLoader ( ) [EOL] suites = map ( loader . loadTestsFromModule , modules ) [EOL] return TestSuite ( suites ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [docstring] [EOL] [EOL] [EOL] import os [EOL] from setuptools import setup [EOL] [EOL] [EOL] setup ( name = [string] , version = [string] , py_modules = [ [string] ] , install_requires = [ [string] , [string] ] , author = [string] , author_email = [string] , description = [string] , url = [string] , download_url = [string] , keywords = [string] . split ( ) , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __revision__ = [string] [EOL] [EOL] __version__ = [string] [EOL] [EOL] __build__ = [string] [EOL] [EOL] __buildsys__ = [string] [EOL] [EOL] __date__ = [string] [EOL] [EOL] __developer__ = [string] [EOL] [EOL] [comment] [EOL] import SCons . compat [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __revision__ = [string] [EOL] [EOL] import posix [EOL] [EOL] def generate ( env ) : [EOL] posix . generate ( env ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __revision__ = [string] [EOL] [EOL] import posix [EOL] [EOL] def generate ( env ) : [EOL] posix . generate ( env ) [EOL] [comment] [EOL] env [ [string] ] = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __revision__ = [string] [EOL] [EOL] import SCons . Scanner [EOL] [EOL] SWIGSuffixes = [ [string] ] [EOL] [EOL] def SWIGScanner ( ) : [EOL] expr = [string] [EOL] scanner = SCons . Scanner . ClassicCPP ( [string] , [string] , [string] , expr ) [EOL] return scanner [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __revision__ = [string] [EOL] [EOL] import re [EOL] [EOL] import SCons . Node [EOL] import SCons . Node . FS [EOL] import SCons . Scanner [EOL] import SCons . Util [EOL] import SCons . Warnings [EOL] [EOL] class F90Scanner ( SCons . Scanner . Classic ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , suffixes , path_variable , use_regex , incl_regex , def_regex , * args , ** kw ) : [EOL] [EOL] self . cre_use = re . compile ( use_regex , re . M ) [EOL] self . cre_incl = re . compile ( incl_regex , re . M ) [EOL] self . cre_def = re . compile ( def_regex , re . M ) [EOL] [EOL] def _scan ( node , env , path , self = self ) : [EOL] node = node . rfile ( ) [EOL] [EOL] if not node . exists ( ) : [EOL] return [ ] [EOL] [EOL] return self . scan ( node , env , path ) [EOL] [EOL] kw [ [string] ] = _scan [EOL] kw [ [string] ] = SCons . Scanner . FindPathDirs ( path_variable ) [EOL] kw [ [string] ] = [number] [EOL] kw [ [string] ] = suffixes [EOL] kw [ [string] ] = name [EOL] [EOL] SCons . Scanner . Current . __init__ ( self , * args , ** kw ) [EOL] [EOL] def scan ( self , node , env , path = ( ) ) : [EOL] [EOL] [comment] [EOL] if node . includes != None : [EOL] mods_and_includes = node . includes [EOL] else : [EOL] [comment] [EOL] includes = self . cre_incl . findall ( node . get_text_contents ( ) ) [EOL] [comment] [EOL] modules = self . cre_use . findall ( node . get_text_contents ( ) ) [EOL] [comment] [EOL] defmodules = self . cre_def . findall ( node . get_text_contents ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] d = { } [EOL] for m in defmodules : [EOL] d [ m . lower ( ) ] = [number] [EOL] modules = [ m for m in modules if m . lower ( ) not in d ] [EOL] [EOL] [comment] [EOL] suffix = env . subst ( [string] ) [EOL] modules = [ x . lower ( ) + suffix for x in modules ] [EOL] [comment] [EOL] mods_and_includes = SCons . Util . unique ( includes + modules ) [EOL] node . includes = mods_and_includes [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] nodes = [ ] [EOL] source_dir = node . get_dir ( ) [EOL] if callable ( path ) : [EOL] path = path ( ) [EOL] for dep in mods_and_includes : [EOL] n , i = self . find_include ( dep , source_dir , path ) [EOL] [EOL] if n is None : [EOL] SCons . Warnings . warn ( SCons . Warnings . DependencyWarning , [string] % ( i , node ) ) [EOL] else : [EOL] sortkey = self . sort_key ( dep ) [EOL] nodes . append ( ( sortkey , n ) ) [EOL] [EOL] return [ pair [ [number] ] for pair in sorted ( nodes ) ] [EOL] [EOL] def FortranScan ( path_variable = [string] ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] use_regex = [string] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] include_regex = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def_regex = [string] [EOL] [EOL] scanner = F90Scanner ( [string] , [string] , path_variable , use_regex , include_regex , def_regex ) [EOL] return scanner [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __revision__ = [string] [EOL] [EOL] import SCons . Node . FS [EOL] import SCons . Scanner [EOL] [EOL] def IDLScan ( ) : [EOL] [docstring] [EOL] cs = SCons . Scanner . ClassicCPP ( [string] , [string] , [string] , [string] ) [EOL] return cs [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __revision__ = [string] [EOL] [EOL] import re [EOL] [EOL] import SCons . Scanner [EOL] [EOL] def DScanner ( ) : [EOL] [docstring] [EOL] ds = D ( ) [EOL] return ds [EOL] [EOL] class D ( SCons . Scanner . Classic ) : [EOL] def __init__ ( self ) : [EOL] SCons . Scanner . Classic . __init__ ( self , name = [string] , suffixes = [string] , path_variable = [string] , regex = [string] ) [EOL] [EOL] self . cre2 = re . compile ( [string] , re . M ) [EOL] [EOL] def find_include ( self , include , source_dir , path ) : [EOL] [comment] [EOL] inc = include . replace ( [string] , [string] ) [EOL] [EOL] i = SCons . Node . FS . find_file ( inc + [string] , ( source_dir , ) + path ) [EOL] if i is None : [EOL] i = SCons . Node . FS . find_file ( inc + [string] , ( source_dir , ) + path ) [EOL] return i , include [EOL] [EOL] def find_include_names ( self , node ) : [EOL] includes = [ ] [EOL] for i in self . cre . findall ( node . get_text_contents ( ) ) : [EOL] includes = includes + self . cre2 . findall ( i ) [EOL] return includes [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __revision__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __all__ = [ [string] , ] [EOL] [EOL] import collections [EOL] [EOL] import SCons . Util [EOL] [EOL] [EOL] class _ListVariable ( collections . UserList ) : [EOL] def __init__ ( self , initlist = [ ] , allowedElems = [ ] ) : [EOL] collections . UserList . __init__ ( self , [ _f for _f in initlist if _f ] ) [EOL] self . allowedElems = sorted ( allowedElems ) [EOL] [EOL] def __cmp__ ( self , other ) : [EOL] raise NotImplementedError [EOL] def __eq__ ( self , other ) : [EOL] raise NotImplementedError [EOL] def __ge__ ( self , other ) : [EOL] raise NotImplementedError [EOL] def __gt__ ( self , other ) : [EOL] raise NotImplementedError [EOL] def __le__ ( self , other ) : [EOL] raise NotImplementedError [EOL] def __lt__ ( self , other ) : [EOL] raise NotImplementedError [EOL] def __str__ ( self ) : [EOL] if len ( self ) == [number] : [EOL] return [string] [EOL] self . data . sort ( ) [EOL] if self . data == self . allowedElems : [EOL] return [string] [EOL] else : [EOL] return [string] . join ( self ) [EOL] def prepare_to_store ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] def _converter ( val , allowedElems , mapdict ) : [EOL] [docstring] [EOL] if val == [string] : [EOL] val = [ ] [EOL] elif val == [string] : [EOL] val = allowedElems [EOL] else : [EOL] val = [ _f for _f in val . split ( [string] ) if _f ] [EOL] val = [ mapdict . get ( v , v ) for v in val ] [EOL] notAllowed = [ v for v in val if not v in allowedElems ] [EOL] if notAllowed : [EOL] raise ValueError ( [string] % [string] . join ( notAllowed ) ) [EOL] return _ListVariable ( val , allowedElems ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def ListVariable ( key , help , default , names , map = { } ) : [EOL] [docstring] [EOL] names_str = [string] % [string] . join ( names ) [EOL] if SCons . Util . is_List ( default ) : [EOL] default = [string] . join ( default ) [EOL] help = [string] . join ( ( help , [string] , names_str ) ) [EOL] return ( key , help , default , None , lambda val : _converter ( val , names , map ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __doc__ = [string] [EOL] [EOL] __revision__ = [string] [EOL] [EOL] class error ( Exception ) : [EOL] pass [EOL] [EOL] def open ( * args , ** kw ) : [EOL] raise error ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __doc__ = [string] [EOL] [EOL] __revision__ = [string] [EOL] [EOL] import md5 [EOL] from string import hexdigits [EOL] [EOL] class md5obj ( object ) : [EOL] [EOL] md5_module = md5 [EOL] [EOL] def __init__ ( self , name , string = [string] ) : [EOL] if not name in ( [string] , [string] ) : [EOL] raise ValueError ( [string] ) [EOL] self . name = [string] [EOL] self . m = self . md5_module . md5 ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . name , id ( self ) ) [EOL] [EOL] def copy ( self ) : [EOL] import copy [EOL] result = copy . copy ( self ) [EOL] result . m = self . m . copy ( ) [EOL] return result [EOL] [EOL] def digest ( self ) : [EOL] return self . m . digest ( ) [EOL] [EOL] def update ( self , arg ) : [EOL] return self . m . update ( arg ) [EOL] [EOL] def hexdigest ( self ) : [EOL] return self . m . hexdigest ( ) [EOL] [EOL] new = md5obj [EOL] [EOL] def md5 ( string = [string] ) : [EOL] return md5obj ( [string] , string ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from google3 . pyglib import app [EOL] from google3 . testing . pybase import googletest [EOL] from google3 . util . geometry . pywraps2 import * [EOL] [EOL] class PyWrapS2TestCase ( googletest . TestCase ) : [EOL] [EOL] def testContainsIsWrappedCorrectly ( self ) : [EOL] london = S2LatLngRect ( S2LatLng . FromDegrees ( [number] , [number] ) , S2LatLng . FromDegrees ( [number] , [number] ) ) [EOL] e14lj = S2LatLngRect ( S2LatLng . FromDegrees ( [number] , - [number] ) , S2LatLng . FromDegrees ( [number] , - [number] ) ) [EOL] self . failUnless ( london . Contains ( e14lj ) ) [EOL] [EOL] def testS2CellIdEqualsIsWrappedCorrectly ( self ) : [EOL] london = S2LatLng . FromDegrees ( [number] , - [number] ) [EOL] cell = S2CellId . FromLatLng ( london ) [EOL] same_cell = S2CellId . FromLatLng ( london ) [EOL] self . assertEquals ( cell , same_cell ) [EOL] [EOL] def testS2CellIdComparsionIsWrappedCorrectly ( self ) : [EOL] london = S2LatLng . FromDegrees ( [number] , - [number] ) [EOL] cell = S2CellId . FromLatLng ( london ) [EOL] self . failUnless ( cell < cell . next ( ) ) [EOL] self . failUnless ( cell . next ( ) > cell ) [EOL] [EOL] def testS2HashingIsWrappedCorrectly ( self ) : [EOL] london = S2LatLng . FromDegrees ( [number] , - [number] ) [EOL] cell = S2CellId . FromLatLng ( london ) [EOL] same_cell = S2CellId . FromLatLng ( london ) [EOL] self . assertEquals ( hash ( cell ) , hash ( same_cell ) ) [EOL] [EOL] def testCovererIsWrapperCorrectly ( self ) : [EOL] london = S2LatLngRect ( S2LatLng . FromDegrees ( [number] , [number] ) , S2LatLng . FromDegrees ( [number] , [number] ) ) [EOL] e14lj = S2LatLngRect ( S2LatLng . FromDegrees ( [number] , - [number] ) , S2LatLng . FromDegrees ( [number] , - [number] ) ) [EOL] coverer = S2RegionCoverer ( ) [EOL] covering = coverer . GetCovering ( e14lj ) [EOL] for cellid in covering : [EOL] self . failUnless ( london . Contains ( S2Cell ( cellid ) ) ) [EOL] [EOL] def main ( argv ) : [EOL] googletest . main ( ) [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , List , Optional , Literal , Any , Generator [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] [EOL] [EOL] def PreCommitGo ( input_api , output_api , pcg_mode ) : [EOL] [docstring] [EOL] if input_api . is_committing : [EOL] error_type = output_api . PresubmitError [EOL] else : [EOL] error_type = output_api . PresubmitPromptWarning [EOL] [EOL] exe = [string] if sys . platform == [string] else [string] [EOL] pcg = None [EOL] for p in os . environ [ [string] ] . split ( os . pathsep ) : [EOL] pcg = os . path . join ( p , exe ) [EOL] if os . access ( pcg , os . X_OK ) : [EOL] break [EOL] else : [EOL] return [ error_type ( [string] [string] ) ] [EOL] [EOL] cmd = [ pcg , [string] , [string] , [string] . join ( pcg_mode ) ] [EOL] if input_api . verbose : [EOL] cmd . append ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] if os . getenv ( [string] , [string] ) : [EOL] cmd . extend ( [ [string] , [string] ] ) [EOL] return input_api . RunTests ( [ input_api . Command ( name = [string] % [string] . join ( pcg_mode ) , cmd = cmd , kwargs = { } , message = error_type ) , ] ) [EOL] [EOL] [EOL] def header ( input_api ) : [EOL] [docstring] [EOL] current_year = int ( input_api . time . strftime ( [string] ) ) [EOL] allowed_years = ( str ( s ) for s in reversed ( xrange ( [number] , current_year + [number] ) ) ) [EOL] years_re = [string] + [string] . join ( allowed_years ) + [string] [EOL] license_header = ( [string] [string] [string] [string] [string] ) % { [string] : years_re , } [EOL] return license_header [EOL] [EOL] [EOL] def source_file_filter ( input_api ) : [EOL] [docstring] [EOL] bl = list ( input_api . DEFAULT_BLACK_LIST ) + [ [string] , [string] , ] [EOL] wl = list ( input_api . DEFAULT_WHITE_LIST ) + [ [string] , ] [EOL] return lambda x : input_api . FilterSourceFile ( x , white_list = wl , black_list = bl ) [EOL] [EOL] [EOL] def CommonChecks ( input_api , output_api ) : [EOL] results = [ ] [EOL] results . extend ( input_api . canned_checks . CheckChangeHasNoStrayWhitespace ( input_api , output_api , source_file_filter = source_file_filter ( input_api ) ) ) [EOL] results . extend ( input_api . canned_checks . CheckLicense ( input_api , output_api , header ( input_api ) , source_file_filter = source_file_filter ( input_api ) ) ) [EOL] return results [EOL] [EOL] [EOL] def CheckChangeOnUpload ( input_api , output_api ) : [EOL] results = CommonChecks ( input_api , output_api ) [EOL] results . extend ( PreCommitGo ( input_api , output_api , [ [string] , [string] ] ) ) [EOL] return results [EOL] [EOL] [EOL] def CheckChangeOnCommit ( input_api , output_api ) : [EOL] results = CommonChecks ( input_api , output_api ) [EOL] results . extend ( input_api . canned_checks . CheckChangeHasDescription ( input_api , output_api ) ) [EOL] results . extend ( input_api . canned_checks . CheckDoNotSubmitInDescription ( input_api , output_api ) ) [EOL] results . extend ( input_api . canned_checks . CheckDoNotSubmitInFiles ( input_api , output_api ) ) [EOL] results . extend ( PreCommitGo ( input_api , output_api , [ [string] ] ) ) [EOL] return results [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Dict [EOL] import typing [EOL] import io [EOL] [docstring] [EOL] [EOL] usage_msg = [string] [EOL] [EOL] from collections import namedtuple [EOL] from Cheetah . Template import Template [EOL] import sys [EOL] [EOL] def render_template ( template_path , ** kw ) : [EOL] [docstring] [EOL] [EOL] template = Template . compile ( file = template_path , compilerSettings = dict ( directiveStartToken = [string] , directiveEndToken = [string] , commentStartToken = [string] ) , baseclass = dict , useCache = False ) [EOL] return str ( template ( ** kw ) ) [EOL] [EOL] class ErrorCode : [EOL] def __init__ ( self , name , code , extra = None ) : [EOL] self . name = name [EOL] self . code = code [EOL] self . extra = extra [EOL] self . categories = [ ] [EOL] [EOL] class ErrorClass : [EOL] def __init__ ( self , name , codes ) : [EOL] self . name = name [EOL] self . codes = codes [EOL] [EOL] def main ( argv ) : [EOL] [comment] [EOL] if len ( sys . argv ) < [number] : [EOL] usage ( [string] ) [EOL] if len ( sys . argv ) < [number] : [EOL] usage ( [string] ) [EOL] [EOL] template_outputs = [ ] [EOL] for arg in sys . argv [ [number] : ] : [EOL] try : [EOL] template , output = arg . split ( [string] , [number] ) [EOL] template_outputs . append ( ( template , output ) ) [EOL] except Exception : [EOL] usage ( [string] + arg ) [EOL] [EOL] [comment] [EOL] error_codes , error_classes = parse_error_definitions_from_file ( argv [ [number] ] ) [EOL] check_for_conflicts ( error_codes , error_classes ) [EOL] [EOL] [comment] [EOL] for template , output in template_outputs : [EOL] text = render_template ( template , codes = error_codes , categories = error_classes , ) [EOL] [EOL] with open ( output , [string] ) as outfile : [EOL] outfile . write ( text ) [EOL] [EOL] def die ( message = None ) : [EOL] sys . stderr . write ( message or [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] def usage ( message = None ) : [EOL] sys . stderr . write ( __doc__ ) [EOL] die ( message ) [EOL] [EOL] def parse_error_definitions_from_file ( errors_filename ) : [EOL] errors_file = open ( errors_filename , [string] ) [EOL] errors_code = compile ( errors_file . read ( ) , errors_filename , [string] ) [EOL] error_codes = [ ] [EOL] error_classes = [ ] [EOL] eval ( errors_code , dict ( error_code = lambda * args , ** kw : error_codes . append ( ErrorCode ( * args , ** kw ) ) , error_class = lambda * args : error_classes . append ( ErrorClass ( * args ) ) ) ) [EOL] error_codes . sort ( key = lambda x : x . code ) [EOL] [EOL] return error_codes , error_classes [EOL] [EOL] def check_for_conflicts ( error_codes , error_classes ) : [EOL] failed = has_duplicate_error_codes ( error_codes ) [EOL] if has_duplicate_error_classes ( error_classes ) : [EOL] failed = True [EOL] if has_missing_error_codes ( error_codes , error_classes ) : [EOL] failed = True [EOL] if failed : [EOL] die ( ) [EOL] [EOL] def has_duplicate_error_codes ( error_codes ) : [EOL] sorted_by_name = sorted ( error_codes , key = lambda x : x . name ) [EOL] sorted_by_code = sorted ( error_codes , key = lambda x : x . code ) [EOL] [EOL] failed = False [EOL] prev = sorted_by_name [ [number] ] [EOL] for curr in sorted_by_name [ [number] : ] : [EOL] if curr . name == prev . name : [EOL] sys . stdout . write ( [string] % ( curr . name , curr . code , prev . code ) ) [EOL] failed = True [EOL] prev = curr [EOL] [EOL] prev = sorted_by_code [ [number] ] [EOL] for curr in sorted_by_code [ [number] : ] : [EOL] if curr . code == prev . code : [EOL] sys . stdout . write ( [string] % ( curr . code , curr . name , prev . name ) ) [EOL] failed = True [EOL] prev = curr [EOL] [EOL] return failed [EOL] [EOL] def has_duplicate_error_classes ( error_classes ) : [EOL] names = sorted ( ec . name for ec in error_classes ) [EOL] [EOL] failed = False [EOL] prev_name = names [ [number] ] [EOL] for name in names [ [number] : ] : [EOL] if prev_name == name : [EOL] sys . stdout . write ( [string] % name ) [EOL] failed = True [EOL] prev_name = name [EOL] return failed [EOL] [EOL] def has_missing_error_codes ( error_codes , error_classes ) : [EOL] code_names = dict ( ( ec . name , ec ) for ec in error_codes ) [EOL] failed = False [EOL] for category in error_classes : [EOL] for name in category . codes : [EOL] try : [EOL] code_names [ name ] . categories . append ( category . name ) [EOL] except KeyError : [EOL] sys . stdout . write ( [string] % ( name , category . name ) ) [EOL] failed = True [EOL] [EOL] return failed [EOL] [EOL] if __name__ == [string] : [EOL] main ( sys . argv ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any , List , Dict [EOL] import typing [EOL] import io [EOL] import os [EOL] import sys [EOL] [EOL] from gen_helper import getCopyrightNotice , openNamespaces , closeNamespaces , include [EOL] [EOL] def generate ( unicode_casefold_file , target ) : [EOL] [docstring] [EOL] out = open ( target , [string] ) [EOL] [EOL] out . write ( getCopyrightNotice ( ) ) [EOL] out . write ( include ( [string] ) ) [EOL] out . write ( [string] ) [EOL] out . write ( openNamespaces ( ) ) [EOL] [EOL] case_mappings = { } [EOL] [EOL] cf_file = open ( unicode_casefold_file , [string] ) [EOL] [EOL] for line in cf_file : [EOL] [comment] [EOL] data = line [ : line . find ( [string] ) ] [EOL] if ( data == [string] ) : [EOL] continue [EOL] [EOL] [comment] [EOL] values = data . split ( [string] ) [EOL] assert ( len ( values ) == [number] ) [EOL] [EOL] status = values [ [number] ] [EOL] if status == [string] or status == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] original_codepoint = int ( values [ [number] ] , [number] ) [EOL] codepoint_mapping = int ( values [ [number] ] , [number] ) [EOL] case_mappings [ original_codepoint ] = codepoint_mapping [EOL] [EOL] turkishMapping = { [number] : [number] , [number] : [number] , } [EOL] [EOL] out . write ( [string] ) [EOL] [EOL] mappings_list = [ ] [EOL] [EOL] for mapping in case_mappings : [EOL] mappings_list . append ( ( mapping , case_mappings [ mapping ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for mapping in turkishMapping : [EOL] if mapping not in case_mappings : [EOL] mappings_list . append ( ( mapping , mapping ) ) [EOL] [EOL] sorted_mappings = sorted ( mappings_list , key = lambda mapping : mapping [ [number] ] ) [EOL] [EOL] for mapping in sorted_mappings : [EOL] if mapping [ [number] ] <= [number] : [EOL] continue [comment] [EOL] [EOL] if mapping [ [number] ] in turkishMapping : [EOL] out . write ( [string] % ( mapping [ [number] ] , turkishMapping [ mapping [ [number] ] ] , mapping [ [number] ] ) ) [EOL] else : [EOL] out . write ( [string] % mapping ) [EOL] [EOL] out . write ( [string] ) [EOL] [EOL] out . write ( closeNamespaces ( ) ) [EOL] [EOL] if __name__ == [string] : [EOL] generate ( sys . argv [ [number] ] , sys . argv [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any , List , Dict , Set [EOL] import typing [EOL] import io [EOL] import sys [EOL] from unicodedata import normalize , category , unidata_version [EOL] [EOL] from gen_helper import getCopyrightNotice , openNamespaces , closeNamespaces , include [EOL] [EOL] diacritics = set ( ) [EOL] [EOL] def load_diacritics ( unicode_proplist_file ) : [EOL] proplist_file = open ( unicode_proplist_file , [string] ) [EOL] [EOL] for line in proplist_file : [EOL] [comment] [EOL] data = line [ : line . find ( [string] ) ] [EOL] if ( data == [string] ) : [EOL] continue [EOL] [EOL] [comment] [EOL] values = data . split ( [string] ) [EOL] assert ( len ( values ) == [number] ) [EOL] [EOL] uproperty = values [ [number] ] . strip ( ) [EOL] if uproperty == [string] : [EOL] if len ( values [ [number] ] . split ( [string] ) ) == [number] : [EOL] codepoint_range = values [ [number] ] . split ( [string] ) [EOL] [EOL] start = int ( codepoint_range [ [number] ] , [number] ) [EOL] end = int ( codepoint_range [ [number] ] , [number] ) + [number] [EOL] [EOL] for i in range ( start , end ) : [EOL] if i not in diacritics : [EOL] diacritics . add ( i ) [EOL] else : [EOL] if int ( values [ [number] ] , [number] ) not in diacritics : [EOL] diacritics . add ( int ( values [ [number] ] , [number] ) ) [EOL] [EOL] diacritic_mappings = { } [EOL] [EOL] def add_diacritic_mapping ( codepoint ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] a = chr ( codepoint ) [EOL] d = normalize ( [string] , a ) [EOL] r = [string] [EOL] [EOL] for i in range ( len ( d ) ) : [EOL] if ord ( d [ i ] ) not in diacritics : [EOL] r += d [ i ] [EOL] [EOL] c = normalize ( [string] , r ) [EOL] [EOL] [comment] [EOL] if ( a != c and len ( c ) == [number] ) : [EOL] assert c != [string] [comment] [EOL] assert ord ( c ) not in diacritics [EOL] diacritic_mappings [ codepoint ] = ord ( c [ [number] ] ) [EOL] [EOL] def add_diacritic_range ( start , end ) : [EOL] for x in range ( start , end + [number] ) : [EOL] add_diacritic_mapping ( x ) [EOL] [EOL] def generate ( target ) : [EOL] [docstring] [EOL] out = open ( target , [string] ) [EOL] [EOL] out . write ( getCopyrightNotice ( ) ) [EOL] out . write ( include ( [string] ) ) [EOL] out . write ( [string] ) [EOL] out . write ( openNamespaces ( ) ) [EOL] [EOL] [comment] [EOL] add_diacritic_range ( [number] , [number] ) [EOL] [EOL] for diacritic in diacritics : [EOL] diacritic_mappings [ diacritic ] = [number] [EOL] [EOL] out . write ( [string] ) [EOL] [EOL] mappings_list = [ ] [EOL] [EOL] for mapping in diacritic_mappings : [EOL] mappings_list . append ( ( mapping , diacritic_mappings [ mapping ] ) ) [EOL] [EOL] sorted_mappings = sorted ( mappings_list , key = lambda mapping : mapping [ [number] ] ) [EOL] [EOL] for mapping in sorted_mappings : [EOL] out . write ( [string] + str ( hex ( mapping [ [number] ] ) ) + [string] + str ( hex ( mapping [ [number] ] ) ) + [string] ) [EOL] [EOL] out . write ( [string] ) [EOL] [EOL] out . write ( closeNamespaces ( ) ) [EOL] [EOL] if __name__ == [string] : [EOL] if ( unidata_version != [string] ) : [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL] load_diacritics ( sys . argv [ [number] ] ) [EOL] generate ( sys . argv [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def getCopyrightNotice ( ) : [EOL] return [string] [EOL] [EOL] def openNamespaces ( ) : [EOL] return [string] [EOL] [EOL] def closeNamespaces ( ) : [EOL] return [string] [EOL] [EOL] def include ( header ) : [EOL] return [string] + header + [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import SCons [EOL] import subprocess [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def _detect ( env ) : [EOL] try : [EOL] abidw = env [ [string] ] [EOL] if not abidw : [EOL] return None [EOL] return abidw [EOL] except KeyError : [EOL] pass [EOL] [EOL] return env . WhereIs ( [string] ) [EOL] [EOL] def _add_emitter ( builder ) : [EOL] base_emitter = builder . emitter [EOL] [EOL] def new_emitter ( target , source , env ) : [EOL] new_targets = [ ] [EOL] for t in target : [EOL] abidw = str ( t ) + [string] [EOL] abidw = ( t . builder . target_factory or env . File ) ( abidw ) [EOL] new_targets . append ( abidw ) [EOL] setattr ( t . attributes , [string] , abidw ) [EOL] targets = target + new_targets [EOL] return ( targets , source ) [EOL] [EOL] new_emitter = SCons . Builder . ListEmitter ( [ base_emitter , new_emitter ] ) [EOL] builder . emitter = new_emitter [EOL] [EOL] def _add_scanner ( builder ) : [EOL] old_scanner = builder . target_scanner [EOL] path_function = old_scanner . path_function [EOL] [EOL] def new_scanner ( node , env , path ) : [EOL] old_results = old_scanner ( node , env , path ) [EOL] new_results = [ ] [EOL] for base in old_results : [EOL] abidw = getattr ( env . Entry ( base ) . attributes , [string] , None ) [EOL] new_results . append ( abidw if abidw else base ) [EOL] return new_results [EOL] [EOL] builder . target_scanner = SCons . Scanner . Scanner ( function = new_scanner , path_function = path_function ) [EOL] [EOL] def _add_action ( builder ) : [EOL] actions = builder . action [EOL] builder . action = actions + SCons . Action . Action ( [string] ) [EOL] [EOL] def exists ( env ) : [EOL] result = _detect ( env ) != None [EOL] return result [EOL] [EOL] def generate ( env ) : [EOL] [EOL] if not exists ( env ) : [EOL] return [EOL] [EOL] builder = env [ [string] ] [ [string] ] [EOL] _add_emitter ( builder ) [EOL] _add_action ( builder ) [EOL] _add_scanner ( builder ) [EOL] _add_scanner ( env [ [string] ] [ [string] ] ) [EOL] _add_scanner ( env [ [string] ] [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import SCons [EOL] [EOL] def _tag_as_precious ( target , source , env ) : [EOL] env . Precious ( target ) [EOL] return target , source [EOL] [EOL] def generate ( env ) : [EOL] builders = env [ [string] ] [EOL] for builder in ( [string] , [string] , [string] ) : [EOL] emitter = builders [ builder ] . emitter [EOL] builders [ builder ] . emitter = SCons . Builder . ListEmitter ( [ emitter , _tag_as_precious , ] ) [EOL] [EOL] def exists ( env ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if env . TargetOSIs ( [string] ) and not [string] in env [ [string] ] : [EOL] return True [EOL] [EOL] [comment] [EOL] [comment] [EOL] if env . TargetOSIs ( [string] ) and not env . TargetOSIs ( [string] ) and [string] in env [ [string] ] and [string] in env [ [string] ] : [EOL] return True [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import SCons [EOL] [EOL] def _update_builder ( env , builder , bitcode ) : [EOL] [EOL] old_scanner = builder . target_scanner [EOL] old_path_function = old_scanner . path_function [EOL] [EOL] def new_scanner ( node , env , path = ( ) ) : [EOL] results = old_scanner . function ( node , env , path ) [EOL] origin = getattr ( node . attributes , [string] , None ) [EOL] if origin : [EOL] origin_results = old_scanner ( origin , env , path ) [EOL] for origin_result in origin_results : [EOL] origin_result_debug_file = getattr ( origin_result . attributes , [string] , None ) [EOL] if origin_result_debug_file : [EOL] results . append ( origin_result_debug_file ) [EOL] [comment] [EOL] return results [EOL] [EOL] builder . target_scanner = SCons . Scanner . Scanner ( function = new_scanner , path_function = old_path_function , ) [EOL] [EOL] base_action = builder . action [EOL] if not isinstance ( base_action , SCons . Action . ListAction ) : [EOL] base_action = SCons . Action . ListAction ( [ base_action ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if env . TargetOSIs ( [string] ) : [EOL] if bitcode : [EOL] base_action . list . append ( SCons . Action . Action ( [string] , [string] ) ) [EOL] [EOL] else : [EOL] base_action . list . append ( SCons . Action . Action ( [string] , [string] ) ) [EOL] base_action . list . append ( SCons . Action . Action ( [string] , [string] ) ) [EOL] elif env . TargetOSIs ( [string] ) : [EOL] base_action . list . extend ( [ SCons . Action . Action ( [string] , [string] ) , SCons . Action . Action ( [string] , [string] ) , ] ) [EOL] else : [EOL] pass [EOL] [EOL] base_emitter = builder . emitter [EOL] def new_emitter ( target , source , env ) : [EOL] [EOL] bitcode_file = None [EOL] if env . TargetOSIs ( [string] ) : [EOL] debug_file = env . Dir ( str ( target [ [number] ] ) + [string] ) [EOL] if bitcode : [EOL] bitcode_file = env . File ( str ( target [ [number] ] ) + [string] ) [EOL] elif env . TargetOSIs ( [string] ) : [EOL] debug_file = env . File ( str ( target [ [number] ] ) + [string] ) [EOL] else : [EOL] pass [EOL] [EOL] setattr ( debug_file . attributes , [string] , target [ [number] ] ) [EOL] setattr ( target [ [number] ] . attributes , [string] , debug_file ) [EOL] [EOL] target . append ( debug_file ) [EOL] [EOL] if bitcode_file : [EOL] setattr ( bitcode_file . attributes , [string] , target [ [number] ] ) [EOL] setattr ( target [ [number] ] . attributes , [string] , bitcode_file ) [EOL] target . append ( bitcode_file ) [EOL] [EOL] return ( target , source ) [EOL] [EOL] new_emitter = SCons . Builder . ListEmitter ( [ base_emitter , new_emitter ] ) [EOL] builder . emitter = new_emitter [EOL] [EOL] def generate ( env ) : [EOL] if not exists ( env ) : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] bitcode = False [EOL] if env . TargetOSIs ( [string] ) and any ( flag == [string] for flag in env [ [string] ] ) : [EOL] bitcode = True [EOL] env . AppendUnique ( LINKFLAGS = [ [string] , [string] , ] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for builder in [ [string] , [string] ] : [EOL] _update_builder ( env , env [ [string] ] [ builder ] , bitcode ) [EOL] [EOL] def exists ( env ) : [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import SCons [EOL] [EOL] _splitDwarfFlag = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] _CSuffixes = [ [string] ] [EOL] if not SCons . Util . case_sensitive_suffixes ( [string] , [string] ) : [EOL] _CSuffixes . append ( [string] ) [EOL] [EOL] _CXXSuffixes = [ [string] , [string] , [string] , [string] , [string] ] [EOL] if SCons . Util . case_sensitive_suffixes ( [string] , [string] ) : [EOL] _CXXSuffixes . append ( [string] ) [EOL] [EOL] def _dwo_emitter ( target , source , env ) : [EOL] new_targets = [ ] [EOL] for t in target : [EOL] base , ext = SCons . Util . splitext ( str ( t ) ) [EOL] if not any ( ext == env [ osuffix ] for osuffix in [ [string] , [string] ] ) : [EOL] continue [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] dwotarget = ( t . builder . target_factory or env . File ) ( base + [string] ) [EOL] new_targets . append ( dwotarget ) [EOL] targets = target + new_targets [EOL] return ( targets , source ) [EOL] [EOL] def generate ( env ) : [EOL] suffixes = [ ] [EOL] if _splitDwarfFlag in env [ [string] ] : [EOL] suffixes = _CSuffixes + _CXXSuffixes [EOL] else : [EOL] if _splitDwarfFlag in env [ [string] ] : [EOL] suffixes . extend ( _CSuffixes ) [EOL] if _splitDwarfFlag in env [ [string] ] : [EOL] suffixes . extend ( _CXXSuffixes ) [EOL] [EOL] for object_builder in SCons . Tool . createObjBuilders ( env ) : [EOL] emitterdict = object_builder . builder . emitter [EOL] for suffix in emitterdict . iterkeys ( ) : [EOL] if not suffix in suffixes : [EOL] continue [EOL] base = emitterdict [ suffix ] [EOL] emitterdict [ suffix ] = SCons . Builder . ListEmitter ( [ base , _dwo_emitter , ] ) [EOL] [EOL] def exists ( env ) : [EOL] return any ( _splitDwarfFlag in env [ f ] for f in [ [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import logging [EOL] import optparse [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] from __future__ import print_function [EOL] [EOL] import logging [EOL] import optparse [EOL] import os [EOL] import posixpath [EOL] import sys [EOL] import textwrap [EOL] [EOL] import yaml [EOL] [EOL] [comment] [EOL] if __name__ == [string] and __package__ is None : [EOL] sys . path . append ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) [EOL] [EOL] from buildscripts import git [comment] [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class MetadataRepository ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , repository , references_file , lifecycle_file ) : [comment] [EOL] [docstring] [EOL] self . _repository = repository [EOL] self . _references_file = references_file [EOL] self . _lifecycle_file = lifecycle_file [EOL] [comment] [EOL] self . lifecycle_path = os . path . join ( repository . directory , lifecycle_file ) [EOL] [EOL] def list_revisions ( self ) : [comment] [EOL] [docstring] [EOL] return self . _repository . git_rev_list ( [ [string] , [string] , self . _lifecycle_file ] ) . splitlines ( ) [EOL] [EOL] def _get_references_content ( self , revision ) : [EOL] references_content = self . _repository . git_cat_file ( [ [string] , [string] % ( revision , self . _references_file ) ] ) [EOL] return references_content [EOL] [EOL] def get_reference ( self , metadata_revision , project ) : [EOL] [docstring] [EOL] references_content = self . _get_references_content ( metadata_revision ) [EOL] references = yaml . safe_load ( references_content ) [EOL] return references . get ( [string] , { } ) . get ( project ) [EOL] [EOL] def get_lifecycle_file_content ( self , metadata_revision ) : [EOL] [docstring] [EOL] return self . _repository . git_cat_file ( [ [string] , [string] % ( metadata_revision , self . _lifecycle_file ) ] ) [EOL] [EOL] [EOL] def _clone_repository ( url , branch ) : [EOL] [docstring] [EOL] target_directory = posixpath . splitext ( posixpath . basename ( url ) ) [ [number] ] [EOL] LOGGER . info ( [string] , url , target_directory ) [EOL] return git . Repository . clone ( url , target_directory , branch ) [EOL] [EOL] [EOL] def _get_metadata_revision ( metadata_repo , mongo_repo , project , revision ) : [EOL] [docstring] [EOL] for metadata_revision in metadata_repo . list_revisions ( ) : [EOL] reference = metadata_repo . get_reference ( metadata_revision , project ) [EOL] if not reference : [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] if mongo_repo . is_ancestor ( reference , revision ) : [EOL] [comment] [EOL] return metadata_revision [EOL] return None [EOL] [EOL] [EOL] def fetch_test_lifecycle ( metadata_repo_url , references_file , lifecycle_file , project , revision ) : [comment] [EOL] [docstring] [EOL] metadata_repo = MetadataRepository ( _clone_repository ( metadata_repo_url , project ) , references_file , lifecycle_file ) [EOL] mongo_repo = git . Repository ( os . getcwd ( ) ) [EOL] metadata_revision = _get_metadata_revision ( metadata_repo , mongo_repo , project , revision ) [EOL] if metadata_revision : [EOL] LOGGER . info ( [string] , metadata_revision ) [EOL] result = metadata_repo . get_lifecycle_file_content ( metadata_revision ) [EOL] else : [EOL] result = None [EOL] return result [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] parser = optparse . OptionParser ( description = textwrap . dedent ( main . __doc__ ) , usage = [string] ) [EOL] [EOL] parser . add_option ( [string] , dest = [string] , metavar = [string] , default = [string] , help = ( [string] [string] ) ) [EOL] [EOL] parser . add_option ( [string] , dest = [string] , metavar = [string] , default = [string] , help = ( [string] [string] ) ) [EOL] [EOL] parser . add_option ( [string] , dest = [string] , metavar = [string] , default = [string] , help = ( [string] [string] ) ) [EOL] [EOL] parser . add_option ( [string] , dest = [string] , metavar = [string] , default = [string] , help = ( [string] [string] ) ) [EOL] [EOL] parser . add_option ( [string] , dest = [string] , metavar = [string] , default = [string] , help = ( [string] [string] [string] ) ) [EOL] [EOL] parser . add_option ( [string] , dest = [string] , metavar = [string] , choices = [ [string] , [string] , [string] , [string] ] , default = [string] , help = [string] ) [EOL] [EOL] parser . add_option ( [string] , dest = [string] , metavar = [string] , default = None , help = ( [string] [string] ) ) [EOL] [EOL] options , args = parser . parse_args ( ) [EOL] [EOL] if len ( args ) != [number] : [EOL] parser . print_help ( file = sys . stderr ) [EOL] print ( file = sys . stderr ) [EOL] parser . error ( [string] ) [EOL] evergreen_project = args [ [number] ] [EOL] [EOL] logging . basicConfig ( format = [string] , level = options . log_level , filename = options . log_file ) [EOL] [EOL] lifecycle_file_content = fetch_test_lifecycle ( options . metadata_repo_url , options . references_file , options . lifecycle_file , evergreen_project , options . revision ) [EOL] if not lifecycle_file_content : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( [number] ) [EOL] else : [EOL] LOGGER . info ( [string] , options . destination_file ) [EOL] with open ( options . destination_file , [string] ) as destf : [EOL] destf . write ( lifecycle_file_content ) [EOL] LOGGER . info ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import jira [EOL] [EOL] [EOL] class JiraClient ( object ) : [EOL] [docstring] [EOL] [EOL] CLOSE_TRANSITION_NAME = [string] [EOL] RESOLVE_TRANSITION_NAME = [string] [EOL] FIXED_RESOLUTION_NAME = [string] [EOL] WONT_FIX_RESOLUTION_NAME = [string] [EOL] [EOL] def __init__ ( self , server , username = None , password = None , access_token = None , access_token_secret = None , consumer_key = None , key_cert = None ) : [EOL] [docstring] [EOL] opts = { [string] : server , [string] : True } [EOL] basic_auth = None [EOL] oauth_dict = None [EOL] if access_token and access_token_secret and consumer_key and key_cert : [EOL] oauth_dict = { [string] : access_token , [string] : access_token_secret , [string] : consumer_key , [string] : key_cert } [EOL] elif username and password : [EOL] basic_auth = ( username , password ) [EOL] else : [EOL] raise TypeError ( [string] [string] [string] ) [EOL] self . _jira = jira . JIRA ( options = opts , basic_auth = basic_auth , oauth = oauth_dict , validate = True ) [EOL] [EOL] self . _transitions = { } [EOL] self . _resolutions = { } [EOL] [EOL] def create_issue ( self , project , summary , description , labels = None ) : [EOL] [docstring] [EOL] fields = { [string] : project , [string] : { [string] : [string] } , [string] : summary , [string] : description } [EOL] new_issue = self . _jira . create_issue ( fields = fields ) [EOL] if labels : [EOL] new_issue . update ( fields = { [string] : labels } ) [EOL] return new_issue . key [EOL] [EOL] def close_issue ( self , issue_key , resolution , fix_version = None ) : [EOL] [docstring] [EOL] issue = self . _jira . issue ( issue_key ) [EOL] resolution_id = self . _get_resolution_id ( resolution ) [EOL] if resolution_id is None : [EOL] raise ValueError ( [string] . format ( resolution , issue_key ) ) [EOL] close_transition_id = self . _get_transition_id ( issue , JiraClient . CLOSE_TRANSITION_NAME ) [EOL] if close_transition_id is None : [EOL] raise ValueError ( [string] . format ( JiraClient . CLOSE_TRANSITION_NAME , issue_key ) ) [EOL] fields = { [string] : { [string] : resolution_id } } [EOL] if fix_version : [EOL] fields [ [string] ] = [ { [string] : fix_version } ] [EOL] self . _jira . transition_issue ( issue , close_transition_id , fields = fields ) [EOL] [EOL] def _get_transition_id ( self , issue , name ) : [EOL] project_key = issue . fields . project . key [EOL] project_transitions = self . _transitions . setdefault ( project_key , { } ) [EOL] [EOL] transition_id = project_transitions . get ( name ) [EOL] if transition_id : [EOL] return transition_id [EOL] transitions = self . _jira . transitions ( issue ) [EOL] for transition in transitions : [EOL] project_transitions [ transition [ [string] ] ] = transition [ [string] ] [EOL] if transition [ [string] ] == name : [EOL] transition_id = transition [ [string] ] [EOL] return transition_id [EOL] [EOL] def _get_resolution_id ( self , name ) : [EOL] resolution_id = self . _resolutions . get ( name ) [EOL] if resolution_id is not None : [EOL] return resolution_id [EOL] resolutions = self . _jira . resolutions ( ) [EOL] for resolution in resolutions : [EOL] self . _resolutions [ resolution . name ] = resolution . id [EOL] if resolution . name == name : [EOL] resolution_id = resolution . id [EOL] return resolution_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Tuple[typing.Any,typing.Any]$ 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import logging [EOL] import os [EOL] import sys [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if os . name == [string] and sys . version_info [ [number] ] == [number] : [EOL] try : [EOL] import subprocess32 as subprocess [EOL] except ImportError : [EOL] import warnings [EOL] warnings . warn ( ( [string] [string] [string] ) , RuntimeWarning ) [EOL] import subprocess [comment] [EOL] else : [EOL] import subprocess [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Repository ( object ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , directory ) : [EOL] [docstring] [EOL] self . directory = directory [EOL] [EOL] def git_add ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_cat_file ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_commit ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_diff ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_log ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_push ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_fetch ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_ls_files ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_rebase ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_reset ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_rev_list ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_rev_parse ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) . rstrip ( ) [EOL] [EOL] def git_rm ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def git_show ( self , args ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , args ) [EOL] [EOL] def get_origin_url ( self ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , [ [string] , [string] , [string] ] ) . rstrip ( ) [EOL] [EOL] def get_branch_name ( self ) : [EOL] [docstring] [EOL] branch = self . git_rev_parse ( [ [string] , [string] ] ) [EOL] if branch == [string] : [EOL] raise GitException ( [string] ) [EOL] return branch [EOL] [EOL] def get_current_revision ( self ) : [EOL] [docstring] [EOL] return self . git_rev_parse ( [ [string] ] ) . rstrip ( ) [EOL] [EOL] def configure ( self , parameter , value ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , [ [string] , parameter , value ] ) [EOL] [EOL] def is_detached ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return self . _callgit ( [string] , [ [string] , [string] ] ) == [number] [EOL] [EOL] def is_ancestor ( self , parent_revision , child_revision ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] merge_base = self . _callgito ( [string] , [ parent_revision , child_revision ] ) . rstrip ( ) [EOL] return parent_revision == merge_base [EOL] [EOL] def is_commit ( self , revision ) : [EOL] [docstring] [EOL] [comment] [EOL] return not self . _callgit ( [string] , [ [string] , [string] . format ( revision ) ] ) [EOL] [EOL] def is_working_tree_dirty ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return self . _callgit ( [string] , [ [string] ] ) == [number] [EOL] [EOL] def does_branch_exist ( self , branch ) : [EOL] [docstring] [EOL] [comment] [EOL] return not self . _callgit ( [string] , [ [string] , branch ] ) [EOL] [EOL] def get_merge_base ( self , commit ) : [EOL] [docstring] [EOL] return self . _callgito ( [string] , [ [string] , commit ] ) . rstrip ( ) [EOL] [EOL] def commit_with_message ( self , message ) : [EOL] [docstring] [EOL] return self . git_commit ( [ [string] , message ] ) [EOL] [EOL] def push_to_remote_branch ( self , remote , remote_branch ) : [EOL] [docstring] [EOL] refspec = [string] . format ( self . get_branch_name ( ) , remote_branch ) [EOL] return self . git_push ( [ remote , refspec ] ) [EOL] [EOL] def fetch_remote_branch ( self , repository , branch ) : [EOL] [docstring] [EOL] return self . git_fetch ( [ repository , branch ] ) [EOL] [EOL] def rebase_from_upstream ( self , upstream , ignore_date = False ) : [EOL] [docstring] [EOL] args = [ upstream ] [EOL] if ignore_date : [EOL] args . append ( [string] ) [EOL] return self . git_rebase ( args ) [EOL] [EOL] @ staticmethod def clone ( url , directory , branch = None , depth = None ) : [EOL] [docstring] [EOL] params = [ [string] , [string] ] [EOL] if branch : [EOL] params += [ [string] , branch ] [EOL] if depth : [EOL] params += [ [string] , depth ] [EOL] params += [ url , directory ] [EOL] result = Repository . _run_process ( [string] , params ) [EOL] result . check_returncode ( ) [EOL] return Repository ( directory ) [EOL] [EOL] @ staticmethod def get_base_directory ( directory = None ) : [EOL] [docstring] [EOL] if directory is not None : [EOL] params = [ [string] , [string] , directory ] [EOL] else : [EOL] params = [ [string] ] [EOL] params . extend ( [ [string] , [string] ] ) [EOL] result = Repository . _run_process ( [string] , params ) [EOL] result . check_returncode ( ) [EOL] return result . stdout . rstrip ( ) [EOL] [EOL] @ staticmethod def current_repository ( ) : [EOL] [docstring] [EOL] return Repository ( Repository . get_base_directory ( ) ) [EOL] [EOL] def _callgito ( self , cmd , args ) : [EOL] [docstring] [EOL] result = self . _run_cmd ( cmd , args ) [EOL] result . check_returncode ( ) [EOL] return result . stdout [EOL] [EOL] def _callgit ( self , cmd , args , raise_exception = False ) : [EOL] [docstring] [EOL] result = self . _run_cmd ( cmd , args ) [EOL] if raise_exception : [EOL] result . check_returncode ( ) [EOL] return result . returncode [EOL] [EOL] def _run_cmd ( self , cmd , args ) : [EOL] [docstring] [EOL] [EOL] params = [ [string] , cmd ] + args [EOL] return self . _run_process ( cmd , params , cwd = self . directory ) [EOL] [EOL] @ staticmethod def _run_process ( cmd , params , cwd = None ) : [EOL] process = subprocess . Popen ( params , stdout = subprocess . PIPE , stderr = subprocess . PIPE , cwd = cwd ) [EOL] ( stdout , stderr ) = process . communicate ( ) [EOL] if process . returncode : [EOL] if stdout : [EOL] LOGGER . error ( [string] , [string] . join ( params ) , stdout ) [EOL] if stderr : [EOL] LOGGER . error ( [string] , [string] . join ( params ) , stderr ) [EOL] return GitCommandResult ( cmd , params , process . returncode , stdout = stdout , stderr = stderr ) [EOL] [EOL] [EOL] class GitException ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , message , returncode = None , cmd = None , process_args = None , stdout = None , stderr = None ) : [EOL] [docstring] [EOL] Exception . __init__ ( self , message ) [EOL] self . returncode = returncode [EOL] self . cmd = cmd [EOL] self . process_args = process_args [EOL] self . stdout = stdout [EOL] self . stderr = stderr [EOL] [EOL] [EOL] class GitCommandResult ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cmd , process_args , returncode , stdout = None , stderr = None ) : [EOL] [docstring] [EOL] self . cmd = cmd [EOL] self . process_args = process_args [EOL] self . returncode = returncode [EOL] self . stdout = stdout [EOL] self . stderr = stderr [EOL] [EOL] def check_returncode ( self ) : [EOL] [docstring] [EOL] if self . returncode : [EOL] raise GitException ( [string] . format ( [string] . join ( self . process_args ) , self . returncode ) , self . returncode , self . cmd , self . process_args , self . stdout , self . stderr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[comment] [EOL] from typing import Any , Set , Dict [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import argparse [EOL] import sys [EOL] [EOL] import yaml [EOL] [EOL] DEFAULT_REQUIRED_BUILD_TIMEOUT_SECS = [number] * [number] [EOL] DEFAULT_NON_REQUIRED_BUILD_TIMEOUT_SECS = [number] * [number] * [number] [EOL] [EOL] SPECIFIC_TASK_OVERRIDES = { [string] : { [string] : [number] * [number] , } , } [EOL] [EOL] REQUIRED_BUILD_VARIANTS = { [string] , [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] [EOL] def determine_timeout ( task_name , variant , timeout = [number] ) : [EOL] [docstring] [EOL] [EOL] if timeout and timeout != [number] : [EOL] return timeout [EOL] [EOL] if variant in SPECIFIC_TASK_OVERRIDES and task_name in SPECIFIC_TASK_OVERRIDES [ variant ] : [EOL] return SPECIFIC_TASK_OVERRIDES [ variant ] [ task_name ] [EOL] [EOL] if variant in REQUIRED_BUILD_VARIANTS : [EOL] return DEFAULT_REQUIRED_BUILD_TIMEOUT_SECS [EOL] return DEFAULT_NON_REQUIRED_BUILD_TIMEOUT_SECS [EOL] [EOL] [EOL] def output_timeout ( timeout , options ) : [EOL] [docstring] [EOL] output = { [string] : timeout , } [EOL] [EOL] if options . outfile : [EOL] with open ( options . outfile , [string] ) as outfile : [EOL] yaml . dump ( output , stream = outfile , default_flow_style = False ) [EOL] [EOL] yaml . dump ( output , stream = sys . stdout , default_flow_style = False ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( description = main . __doc__ ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , type = int , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , help = [string] ) [EOL] [EOL] options = parser . parse_args ( ) [EOL] [EOL] timeout = determine_timeout ( options . task , options . variant , options . timeout ) [EOL] output_timeout ( timeout , options ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , List , Optional , Literal , Any , Tuple , Match [EOL] import typing [EOL] import subprocess [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] import codecs [EOL] import re [EOL] import os [EOL] import os . path [EOL] import subprocess [EOL] import sys [EOL] [EOL] [EOL] def get_all_source_files ( arr = None , prefix = [string] ) : [EOL] [docstring] [EOL] if arr is None : [EOL] arr = [ ] [EOL] [EOL] if not os . path . isdir ( prefix ) : [EOL] [comment] [EOL] arr . append ( prefix ) [EOL] return arr [EOL] [EOL] for fx in os . listdir ( prefix ) : [EOL] [comment] [EOL] if ( fx . startswith ( [string] ) or fx . startswith ( [string] ) or fx . startswith ( [string] ) or fx . startswith ( [string] ) or fx . startswith ( [string] ) or fx . startswith ( [string] ) or fx . startswith ( [string] ) or [string] in fx or fx . find ( [string] ) != - [number] ) : [EOL] continue [EOL] [comment] [EOL] [EOL] def is_followable_dir ( prefix , full ) : [EOL] [docstring] [EOL] if not os . path . isdir ( full ) : [EOL] return False [EOL] if not os . path . islink ( full ) : [EOL] return True [EOL] [comment] [EOL] if os . path . split ( prefix ) [ [number] ] == [string] : [EOL] return True [EOL] return False [EOL] [EOL] full = prefix + [string] + fx [EOL] if is_followable_dir ( prefix , full ) : [EOL] get_all_source_files ( arr , full ) [EOL] else : [EOL] if full . endswith ( [string] ) or full . endswith ( [string] ) or full . endswith ( [string] ) : [EOL] full = full . replace ( [string] , [string] ) [EOL] arr . append ( full ) [EOL] [EOL] return arr [EOL] [EOL] [EOL] def get_git_branch ( ) : [EOL] [docstring] [EOL] if not os . path . exists ( [string] ) or not os . path . isdir ( [string] ) : [EOL] return None [EOL] [EOL] version = open ( [string] , [string] ) . read ( ) . strip ( ) [EOL] if not version . startswith ( [string] ) : [EOL] return version [EOL] version = version . split ( [string] ) [EOL] version = version [ len ( version ) - [number] ] [EOL] return version [EOL] [EOL] [EOL] def get_git_branch_string ( prefix = [string] , postfix = [string] ) : [EOL] [docstring] [EOL] tt = re . compile ( [string] ) . split ( os . getcwd ( ) ) [EOL] if len ( tt ) > [number] and tt [ len ( tt ) - [number] ] == [string] : [EOL] par = tt [ len ( tt ) - [number] ] [EOL] mt = re . compile ( [string] ) . match ( par ) [EOL] if mt is not None : [EOL] return prefix + mt . group ( [number] ) . lower ( ) + postfix [EOL] if par . find ( [string] ) > [number] : [EOL] return [string] [EOL] [EOL] branch = get_git_branch ( ) [EOL] if branch is None or branch == [string] : [EOL] return [string] [EOL] return prefix + branch + postfix [EOL] [EOL] [EOL] def get_git_version ( ) : [EOL] [docstring] [EOL] if not os . path . exists ( [string] ) or not os . path . isdir ( [string] ) : [EOL] return [string] [EOL] [EOL] version = open ( [string] , [string] ) . read ( ) . strip ( ) [EOL] if not version . startswith ( [string] ) : [EOL] return version [EOL] version = version [ [number] : ] [EOL] git_ver = [string] + version [EOL] if not os . path . exists ( git_ver ) : [EOL] return version [EOL] return open ( git_ver , [string] ) . read ( ) . strip ( ) [EOL] [EOL] [EOL] def get_git_describe ( ) : [EOL] [docstring] [EOL] with open ( os . devnull , [string] ) as devnull : [EOL] proc = subprocess . Popen ( [string] , stdout = subprocess . PIPE , stderr = devnull , stdin = devnull , shell = True ) [EOL] return proc . communicate ( ) [ [number] ] . strip ( ) [EOL] [EOL] [EOL] def execsys ( args ) : [EOL] [docstring] [EOL] if isinstance ( args , str ) : [EOL] rc = re . compile ( [string] ) [EOL] args = rc . split ( args ) [EOL] proc = subprocess . Popen ( args , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] res = proc . communicate ( ) [EOL] return res [EOL] [EOL] [EOL] def which ( executable ) : [EOL] [docstring] [EOL] if sys . platform == [string] : [EOL] paths = os . environ . get ( [string] , [string] ) . split ( [string] ) [EOL] else : [EOL] paths = os . environ . get ( [string] , [string] ) . split ( [string] ) [EOL] [EOL] for path in paths : [EOL] path = os . path . expandvars ( path ) [EOL] path = os . path . expanduser ( path ) [EOL] path = os . path . abspath ( path ) [EOL] executable_path = os . path . join ( path , executable ) [EOL] if os . path . exists ( executable_path ) : [EOL] return executable_path [EOL] [EOL] return executable [EOL] [EOL] [EOL] def find_python ( min_version = ( [number] , [number] ) ) : [EOL] [docstring] [EOL] try : [EOL] if sys . version_info >= min_version : [EOL] return sys . executable [EOL] except AttributeError : [EOL] [comment] [EOL] pass [EOL] [EOL] version = re . compile ( [string] , re . MULTILINE ) [EOL] binaries = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] for binary in binaries : [EOL] try : [EOL] out , err = subprocess . Popen ( [ binary , [string] ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) . communicate ( ) [EOL] for stream in ( out , err ) : [EOL] match = version . search ( stream ) [EOL] if match : [EOL] versiontuple = tuple ( map ( int , match . group ( [number] ) . split ( [string] ) ) ) [EOL] if versiontuple >= min_version : [EOL] return which ( binary ) [EOL] except Exception : [comment] [EOL] pass [EOL] [EOL] raise Exception ( [string] % [string] . join ( str ( v ) for v in min_version ) ) [EOL] [EOL] [EOL] def replace_with_repr ( unicode_error ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] offender = unicode_error . object [ unicode_error . start : unicode_error . end ] [EOL] return ( unicode ( repr ( offender ) . strip ( [string] ) . strip ( [string] ) ) , unicode_error . end ) [EOL] [EOL] [EOL] codecs . register_error ( [string] , replace_with_repr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , List , Any , Type , DefaultDict [EOL] import logging [EOL] import argparse [EOL] import typing [EOL] import jinja2 [EOL] import datetime [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import argparse [EOL] import datetime [EOL] import itertools [EOL] import logging [EOL] import os [EOL] import sys [EOL] [EOL] from collections import defaultdict [EOL] from collections import namedtuple [EOL] from operator import itemgetter [EOL] [EOL] from jinja2 import Template [EOL] [EOL] from client . github import GithubApi [EOL] [EOL] import client . evergreen as evergreen [EOL] import util . testname as testname [EOL] import util . time as timeutil [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] TEMPLATES_DIR = [string] [EOL] TEST_SUITE_DIR = [string] [EOL] [EOL] MAX_RUNTIME_KEY = [string] [EOL] [EOL] CommitRange = namedtuple ( [string] , [ [string] , [string] ] ) [EOL] ProjectTarget = namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] Dependencies = namedtuple ( [string] , [ [string] , [string] ] ) [EOL] [EOL] [EOL] def enable_logging ( ) : [EOL] [docstring] [EOL] [EOL] logging . basicConfig ( format = [string] , level = logging . DEBUG , stream = sys . stdout , ) [EOL] [EOL] [EOL] def get_start_and_end_commit_since_date ( github_api , target , start_date ) : [EOL] [docstring] [EOL] [EOL] params = { [string] : [string] . format ( start_date ) , [string] : target . branch , } [EOL] [EOL] commits = github_api . get_commits ( target . owner , target . project , params ) [EOL] [EOL] return CommitRange ( commits [ - [number] ] [ [string] ] , commits [ [number] ] [ [string] ] ) [EOL] [EOL] [EOL] def get_history_by_revision ( evergreen_api , task , commit_range , evg_project , variants ) : [EOL] [docstring] [EOL] [EOL] params = { [string] : [string] , [string] : task , [string] : commit_range . start , [string] : commit_range . end , [string] : [string] , [string] : [string] , } [EOL] [EOL] if variants : [EOL] params [ [string] ] = variants [EOL] [EOL] LOGGER . debug ( [string] , params ) [EOL] [EOL] return evergreen_api . get_history ( evg_project , params ) [EOL] [EOL] [EOL] def get_test_history ( evergreen_api , target , task , commit_range , variants ) : [EOL] [docstring] [EOL] [EOL] evg_project = evergreen . generate_evergreen_project_name ( target . owner , target . project , target . branch ) [EOL] test_history = [ ] [EOL] iteration = [number] [EOL] while commit_range . start != commit_range . end : [EOL] history = get_history_by_revision ( evergreen_api , task , commit_range , evg_project , variants ) [EOL] LOGGER . debug ( [string] , iteration , len ( history ) , commit_range ) [EOL] [EOL] if not history : [EOL] break [EOL] [EOL] test_history += history [EOL] [EOL] [comment] [EOL] [comment] [EOL] commit_range = CommitRange ( history [ [number] ] [ [string] ] , commit_range . end ) [EOL] [EOL] LOGGER . debug ( [string] , commit_range ) [EOL] iteration += [number] [EOL] [EOL] return test_history [EOL] [EOL] [EOL] def split_hook_runs_out ( executions ) : [EOL] [docstring] [EOL] [EOL] def is_execution_a_hook ( execution ) : [EOL] [docstring] [EOL] [EOL] test_file = testname . normalize_test_file ( execution [ [string] ] ) [EOL] return testname . is_resmoke_hook ( test_file ) [EOL] [EOL] test_executions = [ e for e in executions if not is_execution_a_hook ( e ) ] [EOL] hook_executions = [ e for e in executions if is_execution_a_hook ( e ) ] [EOL] [EOL] return test_executions , hook_executions [EOL] [EOL] [EOL] def group_by_attribute ( list_to_group , attrib ) : [EOL] [docstring] [EOL] [EOL] return itertools . groupby ( sorted ( list_to_group , key = itemgetter ( attrib ) ) , key = itemgetter ( attrib ) ) [EOL] [EOL] [EOL] def organize_hooks ( executions ) : [EOL] [docstring] [EOL] hooks = defaultdict ( lambda : defaultdict ( lambda : defaultdict ( int ) ) ) [EOL] [EOL] for rev , rev_group in group_by_attribute ( executions , [string] ) : [EOL] for variant , var_group in group_by_attribute ( rev_group , [string] ) : [EOL] for hook in var_group : [EOL] name = testname . split_test_hook_name ( hook [ [string] ] ) [ [number] ] [EOL] hooks [ rev ] [ variant ] [ name ] += hook [ [string] ] [EOL] [EOL] return hooks [EOL] [EOL] [EOL] def execution_runtime ( test_file , execution , hooks ) : [EOL] [docstring] [EOL] [EOL] rev = execution [ [string] ] [EOL] variant = execution [ [string] ] [EOL] runtime = timeutil . ns2sec ( execution [ [string] ] ) [EOL] possible_hook_name = testname . get_short_name_from_test_file ( test_file ) [EOL] if rev in hooks and variant in hooks [ rev ] and possible_hook_name in hooks [ rev ] [ variant ] : [EOL] runtime += timeutil . ns2sec ( hooks [ rev ] [ variant ] [ possible_hook_name ] ) [EOL] [EOL] return runtime [EOL] [EOL] [EOL] def organize_executions_by_test ( executions ) : [EOL] [docstring] [EOL] [EOL] ( test_executions , hook_executions ) = split_hook_runs_out ( executions ) [EOL] [EOL] hooks = organize_hooks ( hook_executions ) [EOL] [EOL] def group_by_test_name ( test_list ) : [EOL] [docstring] [EOL] [EOL] def key_function ( execution ) : [EOL] [docstring] [EOL] [EOL] return testname . normalize_test_file ( execution [ [string] ] ) [EOL] [EOL] return itertools . groupby ( sorted ( test_list , key = key_function ) , key = key_function ) [EOL] [EOL] tests = defaultdict ( lambda : defaultdict ( int ) ) [EOL] [EOL] for test_file , tf_group in group_by_test_name ( test_executions ) : [EOL] [comment] [EOL] if os . path . isfile ( test_file ) : [EOL] for variant , variant_group in group_by_attribute ( tf_group , [string] ) : [EOL] runs = [ execution_runtime ( test_file , e , hooks ) for e in variant_group ] [EOL] ave_execution_time = average_of_array ( runs ) [EOL] tests [ test_file ] [ variant ] = ave_execution_time [EOL] [EOL] if ave_execution_time > tests [ test_file ] [ MAX_RUNTIME_KEY ] : [EOL] tests [ test_file ] [ MAX_RUNTIME_KEY ] = ave_execution_time [EOL] [EOL] return tests [EOL] [EOL] [EOL] def average_of_array ( array ) : [EOL] [docstring] [EOL] total = sum ( array ) [EOL] count = len ( array ) [EOL] [EOL] return total / count [EOL] [EOL] [EOL] def sort_list_of_test_by_max_runtime ( tests ) : [EOL] [docstring] [EOL] return sorted ( tests . keys ( ) , key = lambda test : tests [ test ] [ MAX_RUNTIME_KEY ] , reverse = True ) [EOL] [EOL] [EOL] def divide_tests_into_suites_by_maxtime ( tests , sorted_tests , max_time_seconds ) : [EOL] [docstring] [EOL] suites = [ ] [EOL] current_suite = Suite ( ) [EOL] LOGGER . debug ( [string] , max_time_seconds ) [EOL] for test_name in sorted_tests : [EOL] test = tests [ test_name ] [EOL] if current_suite . get_runtime ( ) + test [ MAX_RUNTIME_KEY ] > max_time_seconds : [EOL] LOGGER . debug ( [string] , current_suite . get_runtime ( ) , test [ MAX_RUNTIME_KEY ] , max_time_seconds ) [EOL] if current_suite . get_test_count ( ) > [number] : [EOL] suites . append ( current_suite ) [EOL] current_suite = Suite ( ) [EOL] [EOL] current_suite . add_test ( test_name , test ) [EOL] [EOL] if current_suite . get_test_count ( ) > [number] : [EOL] suites . append ( current_suite ) [EOL] [EOL] return suites [EOL] [EOL] [EOL] def get_misc_model ( test_list , extra_model_data = None ) : [EOL] [docstring] [EOL] model = { [string] : True , [string] : test_list , } [EOL] [EOL] if extra_model_data : [EOL] model . update ( extra_model_data ) [EOL] [EOL] return model [EOL] [EOL] [EOL] def render_template ( model , task , index ) : [EOL] [docstring] [EOL] template_file = [string] . format ( dir = TEMPLATES_DIR , task = task ) [EOL] target_file = [string] . format ( dir = TEST_SUITE_DIR , task = task , index = index ) [EOL] [EOL] render ( model , template_file , target_file ) [EOL] [EOL] [EOL] def render ( model , source , destination ) : [EOL] [docstring] [EOL] with open ( source , [string] ) as inp , open ( destination , [string] ) as out : [EOL] template = Template ( inp . read ( ) , trim_blocks = True ) [EOL] out . write ( template . render ( model ) ) [EOL] [EOL] [EOL] class Suite ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . tests = [ ] [EOL] self . total_runtime = [number] [EOL] self . variant_runtime = defaultdict ( int ) [EOL] [EOL] def add_test ( self , test_name , test_data ) : [EOL] [docstring] [EOL] [EOL] self . tests . append ( test_name ) [EOL] for variant in test_data : [EOL] if variant == MAX_RUNTIME_KEY : [EOL] self . total_runtime += test_data [ variant ] [EOL] else : [EOL] self . variant_runtime [ variant ] += test_data [ variant ] [EOL] [EOL] def get_runtime ( self ) : [EOL] [docstring] [EOL] [EOL] return self . total_runtime [EOL] [EOL] def get_test_count ( self ) : [EOL] [docstring] [EOL] [EOL] return len ( self . tests ) [EOL] [EOL] def get_model ( self , extra_model_data = None ) : [EOL] [docstring] [EOL] [EOL] model = { [string] : self . tests , [string] : [ ] } [EOL] for variant in self . variant_runtime : [EOL] model [ [string] ] . append ( { [string] : variant , [string] : self . variant_runtime [ variant ] / [number] } ) [EOL] [EOL] if extra_model_data : [EOL] model . update ( extra_model_data ) [EOL] [EOL] return model [EOL] [EOL] [EOL] class Main ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , deps ) : [EOL] [docstring] [EOL] self . deps = deps [EOL] self . options = { } [EOL] self . commit_range = None [EOL] self . test_list = [ ] [EOL] [EOL] def parse_commandline ( self ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( description = self . main . __doc__ ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , default = [number] , type = int , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , metavar = [string] , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = False , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [number] , help = [string] ) [EOL] [EOL] options = parser . parse_args ( ) [EOL] [EOL] if options . start_commit or options . end_commit : [EOL] if not options . start_commit or not options . end_commit : [EOL] parser . error ( [string] ) [EOL] [EOL] return options [EOL] [EOL] def get_data ( self , target , start_date , task , variants ) : [EOL] [docstring] [EOL] if not self . commit_range : [EOL] self . commit_range = get_start_and_end_commit_since_date ( self . deps . github , target , start_date ) [EOL] return get_test_history ( self . deps . evergreen , target , task , self . commit_range , variants ) [EOL] [EOL] def calculate_suites ( self , data , execution_time_secs ) : [EOL] [docstring] [EOL] tests = organize_executions_by_test ( data ) [EOL] self . test_list = sort_list_of_test_by_max_runtime ( tests ) [EOL] return divide_tests_into_suites_by_maxtime ( tests , self . test_list , execution_time_secs ) [EOL] [EOL] def render_suites ( self , suites , task ) : [EOL] [docstring] [EOL] for idx , suite in enumerate ( suites ) : [EOL] render_template ( suite . get_model ( self . extra_model_data ( ) ) , task , idx ) [EOL] [EOL] def render_misc_suite ( self , task ) : [EOL] [docstring] [EOL] model = get_misc_model ( self . test_list , self . extra_model_data ( ) ) [EOL] source = [string] . format ( dir = TEMPLATES_DIR , task = task ) [EOL] target = [string] . format ( dir = TEST_SUITE_DIR , task = task ) [EOL] [EOL] render ( model , source , target ) [EOL] [EOL] def extra_model_data ( self ) : [EOL] [docstring] [EOL] return { [string] : self . options , [string] : self . commit_range . start , [string] : self . commit_range . end , } [EOL] [EOL] def main ( self ) : [EOL] [docstring] [EOL] [EOL] options = self . parse_commandline ( ) [EOL] [EOL] self . options = options [EOL] [EOL] if options . verbose : [EOL] enable_logging ( ) [EOL] [EOL] if options . start_commit or options . end_commit : [EOL] self . commit_range = CommitRange ( options . start_commit , options . end_commit ) [EOL] [EOL] LOGGER . debug ( [string] , options ) [EOL] task = options . task [ [number] ] [EOL] [EOL] today = datetime . datetime . utcnow ( ) . replace ( microsecond = [number] ) [EOL] start_date = today - datetime . timedelta ( days = options . duration_days ) [EOL] [EOL] target = ProjectTarget ( options . owner , options . project , options . branch ) [EOL] [EOL] data = self . get_data ( target , start_date , task , options . variants ) [EOL] suites = self . calculate_suites ( data , options . execution_time_minutes * [number] ) [EOL] [EOL] LOGGER . debug ( [string] , len ( suites ) ) [EOL] [EOL] self . render_suites ( suites , task ) [EOL] self . render_misc_suite ( task ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] Main ( Dependencies ( evergreen . get_evergreen_api ( ) , GithubApi ( ) ) ) . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Type[CommitRange]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[ProjectTarget]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Dependencies]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CommitRange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CommitRange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CommitRange]$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $ProjectTarget$ 0 $typing.Type[ProjectTarget]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $ProjectTarget$ 0 $datetime.datetime$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Dependencies]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import argparse [EOL] import datetime [EOL] [docstring] [EOL] [EOL] import argparse [EOL] from datetime import datetime [EOL] import os [EOL] import sys [EOL] import time [EOL] [EOL] DATE_TIME_STR = [string] [EOL] [EOL] [EOL] def get_prune_file_path ( mount_point ) : [EOL] [docstring] [EOL] with open ( [string] , [string] ) as fh : [EOL] uuid = fh . read ( ) . strip ( ) [EOL] return os . path . join ( mount_point , uuid , [string] , [string] ) [EOL] [EOL] [EOL] def write_last_prune_time ( last_prune_time , prune_file_path ) : [EOL] [docstring] [EOL] with open ( prune_file_path , [string] ) as fh : [EOL] fh . write ( last_prune_time . strftime ( DATE_TIME_STR ) + [string] ) [EOL] [EOL] [EOL] def retrieve_last_prune_time ( prune_file_path ) : [EOL] [docstring] [EOL] if os . path . isfile ( prune_file_path ) : [EOL] with open ( prune_file_path , [string] ) as fh : [EOL] last_prune_time_str = fh . read ( ) . strip ( ) [EOL] last_prune_time = datetime . strptime ( last_prune_time_str , DATE_TIME_STR ) [EOL] else : [EOL] last_prune_time = datetime . utcnow ( ) [EOL] write_last_prune_time ( last_prune_time , prune_file_path ) [EOL] [EOL] return last_prune_time [EOL] [EOL] [EOL] def check_last_prune_time ( args ) : [EOL] [docstring] [EOL] [EOL] seconds_since_last_prune = args . prune_seconds [EOL] prune_file_path = get_prune_file_path ( args . mount_point ) [EOL] [EOL] now = datetime . utcnow ( ) [EOL] last_prune_time = retrieve_last_prune_time ( prune_file_path ) [EOL] [EOL] diff = now - last_prune_time [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if diff . total_seconds ( ) > seconds_since_last_prune : [EOL] print ( [string] . format ( diff . total_seconds ( ) , diff . total_seconds ( ) / [number] / [number] ) ) [EOL] sys . exit ( [number] ) [EOL] else : [EOL] print ( [string] . format ( diff . total_seconds ( ) , diff . total_seconds ( ) / [number] / [number] ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def get_command_line_args ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , type = str , required = False , help = [string] , default = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = int , required = False , help = [string] , default = [number] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , required = False , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] return args [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] args = get_command_line_args ( ) [EOL] mount_point = args . mount_point [EOL] [EOL] if args . write_prune_time : [EOL] write_last_prune_time ( datetime . utcnow ( ) , get_prune_file_path ( mount_point ) ) [EOL] else : [EOL] check_last_prune_time ( args ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] import sys [EOL] from hashlib import sha256 [EOL] [EOL] with open ( sys . argv [ [number] ] , [string] ) as fh : [EOL] print ( sha256 ( fh . read ( ) ) . hexdigest ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Literal , Any , Union [EOL] import typing [EOL] import optparse [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] import optparse [EOL] import os [EOL] import posixpath [EOL] import re [EOL] import shlex [EOL] import sys [EOL] import time [EOL] [EOL] [comment] [EOL] [comment] [EOL] if os . name == [string] and sys . version_info [ [number] ] == [number] : [EOL] try : [EOL] import subprocess32 as subprocess [EOL] except ImportError : [EOL] import warnings [EOL] warnings . warn ( ( [string] [string] [string] ) , RuntimeWarning ) [EOL] import subprocess [comment] [EOL] else : [EOL] import subprocess [EOL] [EOL] [comment] [EOL] if __name__ == [string] and __package__ is None : [EOL] sys . path . append ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) [EOL] [EOL] _IS_WINDOWS = sys . platform == [string] or sys . platform == [string] [EOL] [EOL] _OPERATIONS = [ [string] , [string] , [string] ] [EOL] [EOL] _SSH_CONNECTION_ERRORS = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def posix_path ( path ) : [EOL] [docstring] [EOL] [comment] [EOL] path_quote = [string] if path . startswith ( [string] ) else [string] [EOL] path_quote = [string] if path . startswith ( [string] ) else path_quote [EOL] if path_quote : [EOL] path = path [ [number] : - [number] ] [EOL] drive , new_path = os . path . splitdrive ( path ) [EOL] if drive : [EOL] new_path = posixpath . join ( [string] , drive . split ( [string] ) [ [number] ] , * re . split ( [string] , new_path ) ) [EOL] return [string] . format ( quote = path_quote , path = new_path ) [EOL] [EOL] [EOL] class RemoteOperations ( object ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , user_host , ssh_connection_options = None , ssh_options = None , scp_options = None , retries = [number] , retry_sleep = [number] , debug = False , shell_binary = [string] , use_shell = False ) : [EOL] [docstring] [EOL] [EOL] self . user_host = user_host [EOL] self . ssh_connection_options = ssh_connection_options if ssh_connection_options else [string] [EOL] self . ssh_options = ssh_options if ssh_options else [string] [EOL] self . scp_options = scp_options if scp_options else [string] [EOL] self . retries = retries [EOL] self . retry_sleep = retry_sleep [EOL] self . debug = debug [EOL] self . shell_binary = shell_binary [EOL] self . use_shell = use_shell [EOL] [comment] [EOL] self . _access_code , self . _access_buff = self . _remote_access ( ) [EOL] [EOL] def _call ( self , cmd ) : [EOL] if self . debug : [EOL] print ( cmd ) [EOL] [comment] [EOL] if not self . use_shell : [EOL] cmd = shlex . split ( cmd ) [EOL] [comment] [EOL] process = subprocess . Popen ( cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , shell = self . use_shell ) [EOL] buff_stdout , _ = process . communicate ( ) [EOL] return process . poll ( ) , buff_stdout [EOL] [EOL] def _remote_access ( self ) : [EOL] [docstring] [EOL] cmd = [string] . format ( self . ssh_connection_options , self . ssh_options , self . user_host ) [EOL] attempt_num = [number] [EOL] buff = [string] [EOL] while True : [EOL] ret , buff = self . _call ( cmd ) [EOL] [comment] [EOL] if not ret and not any ( ssh_error in buff for ssh_error in _SSH_CONNECTION_ERRORS ) : [EOL] return ret , buff [EOL] attempt_num += [number] [EOL] if attempt_num > self . retries : [EOL] break [EOL] if self . debug : [EOL] print ( [string] . format ( attempt_num , self . retry_sleep ) ) [EOL] time . sleep ( self . retry_sleep ) [EOL] return ret , buff [EOL] [EOL] def _perform_operation ( self , cmd ) : [EOL] return self . _call ( cmd ) [EOL] [EOL] def access_established ( self ) : [EOL] [docstring] [EOL] return not self . _access_code [EOL] [EOL] def access_info ( self ) : [EOL] [docstring] [EOL] return self . _access_code , self . _access_buff [EOL] [EOL] @ staticmethod def ssh_error ( message ) : [EOL] [docstring] [EOL] return message . startswith ( [string] ) [EOL] [EOL] def operation ( self , operation_type , operation_param , operation_dir = None ) : [EOL] [docstring] [EOL] [EOL] if not self . access_established ( ) : [EOL] return self . access_info ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if operation_type . startswith ( [string] ) and isinstance ( operation_param , str ) : [EOL] operation_param = shlex . split ( operation_param , posix = not _IS_WINDOWS ) [EOL] [EOL] cmds = [ ] [EOL] if operation_type == [string] : [EOL] if operation_dir is not None : [EOL] operation_param = [string] . format ( operation_dir , operation_param ) [EOL] dollar = [string] [EOL] if re . search ( [string] , operation_param ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] operation_param = [string] . format ( operation_param . replace ( [string] , [string] ) ) [EOL] operation_param = [string] . format ( operation_param . replace ( [string] , [string] ) ) [EOL] dollar = [string] [EOL] cmd = [string] . format ( self . ssh_connection_options , self . ssh_options , self . user_host , self . shell_binary , dollar , operation_param ) [EOL] cmds . append ( cmd ) [EOL] [EOL] elif operation_type == [string] : [EOL] cmd = [string] . format ( self . ssh_connection_options , self . scp_options ) [EOL] [comment] [EOL] for copy_file in operation_param : [EOL] [comment] [EOL] quote = [string] if not _IS_WINDOWS else [string] [EOL] cmd += [string] . format ( quote = quote , file = posix_path ( copy_file ) ) [EOL] operation_dir = operation_dir if operation_dir else [string] [EOL] cmd += [string] . format ( self . user_host , posix_path ( operation_dir ) ) [EOL] cmds . append ( cmd ) [EOL] [EOL] elif operation_type == [string] : [EOL] operation_dir = operation_dir if operation_dir else [string] [EOL] if not os . path . isdir ( operation_dir ) : [EOL] raise ValueError ( [string] . format ( operation_dir ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for copy_file in operation_param : [EOL] copy_file = posix_path ( copy_file ) [EOL] cmd = [string] . format ( self . ssh_connection_options , self . scp_options , self . user_host ) [EOL] [comment] [EOL] [comment] [EOL] quote = [string] if not _IS_WINDOWS else [string] [EOL] if [string] in copy_file : [EOL] copy_file = re . escape ( [string] . format ( quote = quote , file = copy_file ) ) [EOL] cmd += [string] . format ( copy_file , posix_path ( operation_dir ) ) [EOL] cmds . append ( cmd ) [EOL] [EOL] else : [EOL] raise ValueError ( [string] . format ( operation_type , _OPERATIONS ) ) [EOL] [EOL] final_ret = [number] [EOL] buff = [string] [EOL] for cmd in cmds : [EOL] ret , new_buff = self . _perform_operation ( cmd ) [EOL] buff += new_buff [EOL] final_ret = final_ret or ret [EOL] [EOL] return final_ret , buff [EOL] [EOL] def shell ( self , operation_param , operation_dir = None ) : [EOL] [docstring] [EOL] return self . operation ( operation_type = [string] , operation_param = operation_param , operation_dir = operation_dir ) [EOL] [EOL] def copy_to ( self , operation_param , operation_dir = None ) : [EOL] [docstring] [EOL] return self . operation ( operation_type = [string] , operation_param = operation_param , operation_dir = operation_dir ) [EOL] [EOL] def copy_from ( self , operation_param , operation_dir = None ) : [EOL] [docstring] [EOL] return self . operation ( operation_type = [string] , operation_param = operation_param , operation_dir = operation_dir ) [EOL] [EOL] [EOL] def main ( ) : [comment] [EOL] [docstring] [EOL] [EOL] parser = optparse . OptionParser ( description = __doc__ ) [EOL] control_options = optparse . OptionGroup ( parser , [string] ) [EOL] shell_options = optparse . OptionGroup ( parser , [string] ) [EOL] copy_options = optparse . OptionGroup ( parser , [string] ) [EOL] [EOL] parser . add_option ( [string] , dest = [string] , default = None , help = ( [string] [string] ) ) [EOL] [EOL] parser . add_option ( [string] , dest = [string] , default = [string] , choices = _OPERATIONS , help = ( [string] [string] . format ( [string] . join ( _OPERATIONS ) ) ) ) [EOL] [EOL] control_options . add_option ( [string] , dest = [string] , default = None , action = [string] , help = ( [string] [string] [string] [string] [string] [string] ) ) [EOL] [EOL] control_options . add_option ( [string] , dest = [string] , default = None , action = [string] , help = ( [string] [string] [string] [string] [string] ) ) [EOL] [EOL] control_options . add_option ( [string] , dest = [string] , default = None , action = [string] , help = ( [string] [string] [string] [string] [string] ) ) [EOL] [EOL] control_options . add_option ( [string] , dest = [string] , type = int , default = [number] , help = ( [string] [string] ) ) [EOL] [EOL] control_options . add_option ( [string] , dest = [string] , type = int , default = [number] , help = ( [string] [string] ) ) [EOL] [EOL] control_options . add_option ( [string] , dest = [string] , action = [string] , default = False , help = [string] ) [EOL] [EOL] control_options . add_option ( [string] , dest = [string] , action = [string] , default = False , help = [string] ) [EOL] [EOL] shell_options . add_option ( [string] , dest = [string] , default = None , action = [string] , help = ( [string] [string] [string] [string] [string] [string] ) ) [EOL] [EOL] shell_options . add_option ( [string] , dest = [string] , default = None , help = ( [string] [string] ) ) [EOL] [EOL] copy_options . add_option ( [string] , dest = [string] , default = None , action = [string] , help = ( [string] [string] [string] ) ) [EOL] [EOL] copy_options . add_option ( [string] , dest = [string] , default = None , help = ( [string] [string] [string] ) ) [EOL] [EOL] copy_options . add_option ( [string] , dest = [string] , default = [string] , help = ( [string] [string] [string] ) ) [EOL] [EOL] parser . add_option_group ( control_options ) [EOL] parser . add_option_group ( shell_options ) [EOL] parser . add_option_group ( copy_options ) [EOL] [EOL] ( options , _ ) = parser . parse_args ( ) [EOL] [EOL] if not getattr ( options , [string] , None ) : [EOL] parser . print_help ( ) [EOL] parser . error ( [string] ) [EOL] [EOL] if options . operation == [string] : [EOL] if not getattr ( options , [string] , None ) : [EOL] parser . print_help ( ) [EOL] parser . error ( [string] . format ( options . operation , [string] ) ) [EOL] operation_param = [string] . join ( options . remote_commands ) [EOL] operation_dir = options . command_dir [EOL] else : [EOL] if not getattr ( options , [string] , None ) : [EOL] parser . print_help ( ) [EOL] parser . error ( [string] . format ( options . operation , [string] ) ) [EOL] operation_param = options . files [EOL] if options . operation == [string] : [EOL] operation_dir = options . remote_dir [EOL] else : [EOL] operation_dir = options . local_dir [EOL] [EOL] if not options . ssh_connection_options : [EOL] ssh_connection_options = None [EOL] else : [EOL] ssh_connection_options = [string] . join ( options . ssh_connection_options ) [EOL] [EOL] if not options . ssh_options : [EOL] ssh_options = None [EOL] else : [EOL] ssh_options = [string] . join ( options . ssh_options ) [EOL] [EOL] if not options . scp_options : [EOL] scp_options = None [EOL] else : [EOL] scp_options = [string] . join ( options . scp_options ) [EOL] [EOL] remote_op = RemoteOperations ( user_host = options . user_host , ssh_connection_options = ssh_connection_options , ssh_options = ssh_options , scp_options = scp_options , retries = options . retries , retry_sleep = options . retry_sleep , debug = options . debug ) [EOL] ret_code , buff = remote_op . operation ( options . operation , operation_param , operation_dir ) [EOL] if options . verbose : [EOL] print ( [string] . format ( ret_code , sys . argv ) ) [EOL] print ( buff ) [EOL] [EOL] sys . exit ( ret_code ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] HOOK_DELIMITER = [string] [EOL] [EOL] [EOL] def is_resmoke_hook ( test_name ) : [EOL] [docstring] [EOL] return test_name . find ( HOOK_DELIMITER ) != - [number] [EOL] [EOL] [EOL] def split_test_hook_name ( hook_name ) : [EOL] [docstring] [EOL] assert is_resmoke_hook ( hook_name ) is True [EOL] [EOL] hook_name_parts = hook_name . split ( HOOK_DELIMITER ) [EOL] [EOL] return hook_name_parts [ [number] ] , hook_name_parts [ [number] ] [EOL] [EOL] [EOL] def get_short_name_from_test_file ( test_file ) : [EOL] [docstring] [EOL] [EOL] return os . path . splitext ( os . path . basename ( test_file ) ) [ [number] ] [EOL] [EOL] [EOL] def normalize_test_file ( test_file ) : [EOL] [docstring] [EOL] [EOL] if [string] in test_file : [EOL] posix_test_file = test_file . replace ( [string] , [string] ) [EOL] ( test_file_root , test_file_ext ) = os . path . splitext ( posix_test_file ) [EOL] if test_file_ext == [string] : [EOL] return test_file_root [EOL] return posix_test_file [EOL] [EOL] return test_file [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] [EOL] def ns2sec ( ns ) : [EOL] [docstring] [EOL] return ns / ( [number] ** [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from __future__ import absolute_import [EOL] [EOL] from . suites import NAMED_SUITES [EOL] from . loggers import NAMED_LOGGERS [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , List , Dict , Set [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] import re [EOL] import sys [EOL] [EOL] import gdb [EOL] import gdb . printing [EOL] [EOL] if sys . version_info [ [number] ] >= [number] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] long = int [comment] [EOL] [EOL] [EOL] class NonExecutingThread ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , locker_id ) : [EOL] [docstring] [EOL] self . locker_id = locker_id [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , NonExecutingThread ) : [EOL] return self . locker_id == other . locker_id [EOL] return NotImplemented [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self == other [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . locker_id ) [EOL] [EOL] def key ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . locker_id ) [EOL] [EOL] [EOL] class Thread ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , thread_id , lwpid , thread_name ) : [EOL] [docstring] [EOL] self . thread_id = thread_id [EOL] self . lwpid = lwpid [EOL] self . name = thread_name [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , Thread ) : [EOL] return self . thread_id == other . thread_id [EOL] return NotImplemented [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self == other [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . name , self . thread_id , self . lwpid ) [EOL] [EOL] def key ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . thread_id ) [EOL] [EOL] [EOL] class Lock ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , addr , resource ) : [EOL] [docstring] [EOL] self . addr = addr [EOL] self . resource = resource [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , Lock ) : [EOL] return self . addr == other . addr [EOL] return NotImplemented [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self == other [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . addr , self . resource ) [EOL] [EOL] def key ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . addr ) [EOL] [EOL] [EOL] class Graph ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . nodes = { } [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] return not bool ( self . nodes ) [EOL] [EOL] def add_node ( self , node ) : [EOL] [docstring] [EOL] if not self . find_node ( node ) : [EOL] self . nodes [ node . key ( ) ] = { [string] : node , [string] : [ ] } [EOL] [EOL] def find_node ( self , node ) : [EOL] [docstring] [EOL] if node . key ( ) in self . nodes : [EOL] return self . nodes [ node . key ( ) ] [EOL] return None [EOL] [EOL] def find_from_node ( self , from_node ) : [EOL] [docstring] [EOL] for node_key in self . nodes : [EOL] node = self . nodes [ node_key ] [EOL] for next_node in node [ [string] ] : [EOL] if next_node == from_node [ [string] ] . key ( ) : [EOL] return node [EOL] return None [EOL] [EOL] def remove_nodes_without_edge ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] temp_nodes = { } [EOL] for node_key in self . nodes : [EOL] node = self . nodes [ node_key ] [EOL] if node [ [string] ] or self . find_from_node ( node ) is not None : [EOL] temp_nodes [ node_key ] = self . nodes [ node_key ] [EOL] self . nodes = temp_nodes [EOL] [EOL] def add_edge ( self , from_node , to_node ) : [EOL] [docstring] [EOL] f_node = self . find_node ( from_node ) [EOL] if f_node is None : [EOL] self . add_node ( from_node ) [EOL] f_node = self . nodes [ from_node . key ( ) ] [EOL] [EOL] t_node = self . find_node ( to_node ) [EOL] if t_node is None : [EOL] self . add_node ( to_node ) [EOL] t_node = self . nodes [ to_node . key ( ) ] [EOL] [EOL] for n_node in f_node [ [string] ] : [EOL] if n_node == to_node . key ( ) : [EOL] return [EOL] self . nodes [ from_node . key ( ) ] [ [string] ] . append ( to_node . key ( ) ) [EOL] [EOL] def print ( self ) : [EOL] [docstring] [EOL] for node_key in self . nodes : [EOL] print ( [string] , self . nodes [ node_key ] [ [string] ] ) [EOL] for to_node in self . nodes [ node_key ] [ [string] ] : [EOL] print ( [string] , to_node ) [EOL] [EOL] def _get_node_escaped ( self , node_key ) : [EOL] [docstring] [EOL] return str ( self . nodes [ node_key ] [ [string] ] ) . replace ( [string] , [string] ) [EOL] [EOL] def to_graph ( self , nodes = None , message = None ) : [EOL] [docstring] [EOL] sb = [ ] [EOL] sb . append ( [string] ) [EOL] sb . append ( [string] ) [EOL] sb . append ( [string] ) [EOL] if message is not None : [EOL] sb . append ( message ) [EOL] sb . append ( [string] ) [EOL] for node_key in self . nodes : [EOL] for next_node_key in self . nodes [ node_key ] [ [string] ] : [EOL] sb . append ( [string] . format ( self . _get_node_escaped ( node_key ) , self . _get_node_escaped ( next_node_key ) ) ) [EOL] for node_key in self . nodes : [EOL] color = [string] [EOL] if nodes and node_key in nodes : [EOL] color = [string] [EOL] [EOL] sb . append ( [string] . format ( self . _get_node_escaped ( node_key ) , color ) ) [EOL] sb . append ( [string] ) [EOL] return [string] . join ( sb ) [EOL] [EOL] def depth_first_search ( self , node_key , nodes_visited , nodes_in_cycle = None ) : [EOL] [docstring] [EOL] if nodes_in_cycle is None : [EOL] nodes_in_cycle = [ ] [EOL] nodes_visited . add ( node_key ) [EOL] nodes_in_cycle . append ( node_key ) [EOL] for node in self . nodes [ node_key ] [ [string] ] : [EOL] if node in nodes_in_cycle : [EOL] [comment] [EOL] return nodes_in_cycle [ nodes_in_cycle . index ( node ) : ] [EOL] if node not in nodes_visited : [EOL] dfs_nodes = self . depth_first_search ( node , nodes_visited , nodes_in_cycle ) [EOL] if dfs_nodes : [EOL] return dfs_nodes [EOL] [EOL] [comment] [EOL] nodes_in_cycle . pop ( ) [EOL] return None [EOL] [EOL] def detect_cycle ( self ) : [EOL] [docstring] [EOL] nodes_visited = set ( ) [EOL] for node in self . nodes : [EOL] if node not in nodes_visited : [EOL] cycle_path = self . depth_first_search ( node , nodes_visited ) [EOL] if cycle_path : [EOL] return [ str ( self . nodes [ node_key ] [ [string] ] ) for node_key in cycle_path ] [EOL] return None [EOL] [EOL] [EOL] def find_thread ( thread_dict , search_thread_id ) : [EOL] [docstring] [EOL] for ( _ , thread ) in thread_dict . items ( ) : [EOL] if thread . thread_id == search_thread_id : [EOL] return thread [EOL] return None [EOL] [EOL] [EOL] def find_func_block ( block ) : [EOL] [docstring] [EOL] while block : [EOL] if block . function : [EOL] return block [EOL] block = block . superblock [EOL] return None [EOL] [EOL] [EOL] def find_frame ( function_name_pattern ) : [EOL] [docstring] [EOL] frame = gdb . newest_frame ( ) [EOL] while frame : [EOL] block = None [EOL] try : [EOL] block = frame . block ( ) [EOL] except RuntimeError as err : [EOL] if err . args [ [number] ] != [string] : [EOL] raise [EOL] [EOL] block = find_func_block ( block ) [EOL] if block and re . match ( function_name_pattern , block . function . name ) : [EOL] return frame [EOL] try : [EOL] frame = frame . older ( ) [EOL] except gdb . error as err : [EOL] print ( [string] % str ( err ) ) [EOL] break [EOL] return None [EOL] [EOL] [EOL] def find_mutex_holder ( graph , thread_dict , show ) : [EOL] [docstring] [EOL] frame = find_frame ( [string] ) [EOL] if frame is None : [EOL] return [EOL] [EOL] frame . select ( ) [EOL] [EOL] [comment] [EOL] mutex_this , _ = gdb . lookup_symbol ( [string] , frame . block ( ) ) [EOL] mutex_value = mutex_this . value ( frame ) [EOL] [comment] [EOL] mutex_holder_lwpid = int ( mutex_value [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if mutex_holder_lwpid not in thread_dict : [EOL] print ( [string] [string] . format ( mutex_value , mutex_holder_lwpid ) ) [EOL] mutex_holder = Thread ( mutex_holder_lwpid , mutex_holder_lwpid , [string] ) [EOL] else : [EOL] mutex_holder = thread_dict [ mutex_holder_lwpid ] [EOL] [EOL] ( _ , mutex_waiter_lwpid , _ ) = gdb . selected_thread ( ) . ptid [EOL] mutex_waiter = thread_dict [ mutex_waiter_lwpid ] [EOL] if show : [EOL] print ( [string] . format ( mutex_value , mutex_holder , mutex_waiter ) ) [EOL] if graph : [EOL] graph . add_edge ( mutex_waiter , Lock ( long ( mutex_value ) , [string] ) ) [EOL] graph . add_edge ( Lock ( long ( mutex_value ) , [string] ) , mutex_holder ) [EOL] [EOL] [EOL] def find_lock_manager_holders ( graph , thread_dict , show ) : [comment] [EOL] [docstring] [EOL] frame = find_frame ( [string] ) [EOL] if not frame : [EOL] return [EOL] [EOL] frame . select ( ) [EOL] [EOL] ( _ , lock_waiter_lwpid , _ ) = gdb . selected_thread ( ) . ptid [EOL] lock_waiter = thread_dict [ lock_waiter_lwpid ] [EOL] [EOL] locker_ptr_type = gdb . lookup_type ( [string] ) . pointer ( ) [EOL] lock_head = gdb . parse_and_eval ( [string] ) [EOL] [EOL] granted_list = lock_head . dereference ( ) [ [string] ] [EOL] lock_request_ptr = granted_list [ [string] ] [EOL] while lock_request_ptr : [EOL] lock_request = lock_request_ptr . dereference ( ) [EOL] locker_ptr = lock_request [ [string] ] [EOL] locker_ptr = locker_ptr . cast ( locker_ptr_type ) [EOL] locker = locker_ptr . dereference ( ) [EOL] lock_holder_id = int ( locker [ [string] ] [ [string] ] ) [EOL] if lock_holder_id == [number] : [EOL] locker_id = int ( locker [ [string] ] ) [EOL] lock_holder = NonExecutingThread ( locker_id ) [EOL] else : [EOL] lock_holder = find_thread ( thread_dict , lock_holder_id ) [EOL] if show : [EOL] print ( [string] . format ( lock_head , lock_request [ [string] ] , lock_holder , lock_waiter ) ) [EOL] if graph : [EOL] graph . add_edge ( lock_waiter , Lock ( long ( lock_head ) , [string] ) ) [EOL] graph . add_edge ( Lock ( long ( lock_head ) , [string] ) , lock_holder ) [EOL] lock_request_ptr = lock_request [ [string] ] [EOL] [EOL] [EOL] def get_locks ( graph , thread_dict , show = False ) : [EOL] [docstring] [EOL] for thread in gdb . selected_inferior ( ) . threads ( ) : [EOL] try : [EOL] if not thread . is_valid ( ) : [EOL] continue [EOL] thread . switch ( ) [EOL] find_mutex_holder ( graph , thread_dict , show ) [EOL] find_lock_manager_holders ( graph , thread_dict , show ) [EOL] except gdb . error as err : [EOL] print ( [string] % str ( err ) ) [EOL] [EOL] [EOL] def get_threads_info ( ) : [EOL] [docstring] [EOL] thread_dict = { } [EOL] for thread in gdb . selected_inferior ( ) . threads ( ) : [EOL] try : [EOL] if not thread . is_valid ( ) : [EOL] continue [EOL] thread . switch ( ) [EOL] [comment] [EOL] ( _ , lwpid , _ ) = thread . ptid [EOL] thread_num = thread . num [EOL] thread_name = get_current_thread_name ( ) [comment] [EOL] thread_id = get_thread_id ( ) [comment] [EOL] if not thread_id : [EOL] print ( [string] % thread_num ) [EOL] continue [EOL] thread_dict [ lwpid ] = Thread ( thread_id , lwpid , thread_name ) [EOL] except gdb . error as err : [EOL] print ( [string] % str ( err ) ) [EOL] [EOL] return thread_dict [EOL] [EOL] [EOL] class MongoDBShowLocks ( gdb . Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] RegisterMongoCommand . register ( self , [string] , gdb . COMMAND_DATA ) [EOL] [EOL] def invoke ( self , * _ ) : [EOL] [docstring] [EOL] self . mongodb_show_locks ( ) [EOL] [EOL] @ staticmethod def mongodb_show_locks ( ) : [EOL] [docstring] [EOL] try : [EOL] thread_dict = get_threads_info ( ) [EOL] get_locks ( graph = None , thread_dict = thread_dict , show = True ) [EOL] except gdb . error as err : [EOL] print ( [string] % str ( err ) ) [EOL] [EOL] [EOL] MongoDBShowLocks ( ) [EOL] [EOL] [EOL] class MongoDBWaitsForGraph ( gdb . Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] RegisterMongoCommand . register ( self , [string] , gdb . COMMAND_DATA ) [EOL] [EOL] def invoke ( self , arg , * _ ) : [EOL] [docstring] [EOL] self . mongodb_waitsfor_graph ( arg ) [EOL] [EOL] @ staticmethod def mongodb_waitsfor_graph ( graph_file = None ) : [EOL] [docstring] [EOL] [EOL] graph = Graph ( ) [EOL] try : [EOL] thread_dict = get_threads_info ( ) [EOL] get_locks ( graph = graph , thread_dict = thread_dict , show = False ) [EOL] graph . remove_nodes_without_edge ( ) [EOL] if graph . is_empty ( ) : [EOL] print ( [string] ) [EOL] return [EOL] cycle_message = [string] [EOL] cycle_nodes = graph . detect_cycle ( ) [EOL] if cycle_nodes : [EOL] cycle_message = [string] % cycle_nodes [EOL] if graph_file : [EOL] print ( [string] % graph_file ) [EOL] with open ( graph_file , [string] ) as fh : [EOL] fh . write ( graph . to_graph ( nodes = cycle_nodes , message = cycle_message ) ) [EOL] print ( cycle_message . split ( [string] ) [ [number] ] ) [EOL] else : [EOL] print ( graph . to_graph ( nodes = cycle_nodes , message = cycle_message ) ) [EOL] [EOL] except gdb . error as err : [EOL] print ( [string] % str ( err ) ) [EOL] [EOL] [EOL] MongoDBWaitsForGraph ( ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , DefaultDict , Set [EOL] import typing [EOL] import subprocess [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import collections [EOL] import errno [EOL] import fnmatch [EOL] import math [EOL] import os . path [EOL] import random [EOL] import subprocess [EOL] import sys [EOL] [EOL] import buildscripts . ciconfig . tags as _tags [EOL] from . import config [EOL] from . import errors [EOL] from . import utils [EOL] from . utils import globstar [EOL] from . utils import jscomment [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class TestFileExplorer ( object ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def is_glob_pattern ( path ) : [EOL] [docstring] [EOL] return globstar . is_glob_pattern ( path ) [EOL] [EOL] @ staticmethod def iglob ( pattern ) : [comment] [EOL] [docstring] [EOL] return globstar . iglob ( pattern ) [EOL] [EOL] @ staticmethod def jstest_tags ( file_path ) : [comment] [EOL] [docstring] [EOL] return jscomment . get_tags ( file_path ) [EOL] [EOL] @ staticmethod def read_root_file ( root_file_path ) : [comment] [EOL] [docstring] [EOL] tests = [ ] [EOL] with open ( root_file_path , [string] ) as filep : [EOL] for test_path in filep : [EOL] test_path = test_path . strip ( ) [EOL] tests . append ( test_path ) [EOL] return tests [EOL] [EOL] @ staticmethod def fnmatchcase ( name , pattern ) : [EOL] [docstring] [EOL] return fnmatch . fnmatchcase ( name , pattern ) [EOL] [EOL] @ staticmethod def isfile ( path ) : [EOL] [docstring] [EOL] return os . path . isfile ( path ) [EOL] [EOL] def list_dbtests ( self , dbtest_binary ) : [EOL] [docstring] [EOL] returncode , stdout = self . _run_program ( dbtest_binary , [ [string] ] ) [EOL] [EOL] if returncode != [number] : [EOL] raise errors . ResmokeError ( [string] ) [EOL] [EOL] return stdout . splitlines ( ) [EOL] [EOL] @ staticmethod def _run_program ( binary , args ) : [comment] [EOL] [docstring] [EOL] command = [ binary ] [EOL] command . extend ( args ) [EOL] program = subprocess . Popen ( command , stdout = subprocess . PIPE ) [EOL] stdout = program . communicate ( ) [ [number] ] [EOL] [EOL] return program . returncode , stdout [EOL] [EOL] @ staticmethod def parse_tag_file ( test_kind ) : [EOL] [docstring] [EOL] tagged_tests = collections . defaultdict ( list ) [EOL] if config . TAG_FILE : [EOL] tags_conf = _tags . TagsConfig . from_file ( config . TAG_FILE ) [EOL] tagged_roots = tags_conf . get_test_patterns ( test_kind ) [EOL] for tagged_root in tagged_roots : [EOL] [comment] [EOL] tests = globstar . iglob ( tagged_root ) [EOL] test_tags = tags_conf . get_tags ( test_kind , tagged_root ) [EOL] for test in tests : [EOL] [comment] [EOL] [comment] [EOL] tagged_tests [ test ] . extend ( test_tags ) [EOL] return tagged_tests [EOL] [EOL] [EOL] class _TestList ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , test_file_explorer , roots , tests_are_files = True ) : [EOL] [docstring] [EOL] self . _test_file_explorer = test_file_explorer [EOL] self . _tests_are_files = tests_are_files [EOL] self . _roots = self . _expand_files ( roots ) if tests_are_files else roots [EOL] self . _filtered = set ( self . _roots ) [EOL] [EOL] def _expand_files ( self , tests ) : [EOL] expanded_tests = [ ] [EOL] for test in tests : [EOL] if self . _test_file_explorer . is_glob_pattern ( test ) : [EOL] expanded_tests . extend ( self . _test_file_explorer . iglob ( test ) ) [EOL] else : [EOL] if not self . _test_file_explorer . isfile ( test ) : [EOL] raise ValueError ( [string] . format ( test ) ) [EOL] expanded_tests . append ( test ) [EOL] return expanded_tests [EOL] [EOL] def include_files ( self , include_files , force = False ) : [EOL] [docstring] [EOL] if not self . _tests_are_files : [EOL] raise TypeError ( [string] ) [EOL] expanded_include_files = set ( ) [EOL] for path in include_files : [EOL] if self . _test_file_explorer . is_glob_pattern ( path ) : [EOL] expanded_include_files . update ( set ( self . _test_file_explorer . iglob ( path ) ) ) [EOL] else : [EOL] expanded_include_files . add ( os . path . normpath ( path ) ) [EOL] self . _filtered = self . _filtered & expanded_include_files [EOL] if force : [EOL] self . _filtered |= set ( self . _roots ) & expanded_include_files [EOL] [EOL] def exclude_files ( self , exclude_files ) : [comment] [EOL] [docstring] [EOL] if not self . _tests_are_files : [EOL] raise TypeError ( [string] ) [EOL] for path in exclude_files : [EOL] if self . _test_file_explorer . is_glob_pattern ( path ) : [EOL] paths = self . _test_file_explorer . iglob ( path ) [EOL] for expanded_path in paths : [EOL] self . _filtered . discard ( expanded_path ) [EOL] else : [EOL] path = os . path . normpath ( path ) [EOL] if path not in self . _roots : [EOL] raise ValueError ( [string] . format ( path ) ) [EOL] self . _filtered . discard ( path ) [EOL] [EOL] def match_tag_expression ( self , tag_expression , get_tags ) : [EOL] [docstring] [EOL] self . _filtered = { test for test in self . _filtered if tag_expression ( get_tags ( test ) ) } [EOL] [EOL] def include_any_pattern ( self , patterns ) : [EOL] [docstring] [EOL] [EOL] def match ( test ) : [EOL] [docstring] [EOL] for pattern in patterns : [EOL] if test == pattern or fnmatch . fnmatchcase ( test , pattern ) : [EOL] return True [EOL] return False [EOL] [EOL] self . _filtered = { test for test in self . _filtered if match ( test ) } [EOL] [EOL] def get_tests ( self ) : [EOL] [docstring] [EOL] tests = [ ] [EOL] excluded = [ ] [EOL] for test in self . _roots : [EOL] if test in self . _filtered : [EOL] if test not in tests : [EOL] tests . append ( test ) [EOL] elif test not in excluded : [EOL] excluded . append ( test ) [EOL] return tests , excluded [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class _AllOfExpression ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , children ) : [EOL] self . __children = children [EOL] [EOL] def __call__ ( self , file_tags ) : [EOL] return all ( child ( file_tags ) for child in self . __children ) [EOL] [EOL] [EOL] class _AnyOfExpression ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , children ) : [EOL] self . __children = children [EOL] [EOL] def __call__ ( self , file_tags ) : [EOL] return any ( child ( file_tags ) for child in self . __children ) [EOL] [EOL] [EOL] class _NotExpression ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , child ) : [EOL] self . __child = child [EOL] [EOL] def __call__ ( self , file_tags ) : [EOL] return not self . __child ( file_tags ) [EOL] [EOL] [EOL] class _MatchExpression ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tag ) : [EOL] self . __tag = tag [EOL] [EOL] def __call__ ( self , file_tags ) : [EOL] return self . __tag in file_tags [EOL] [EOL] [EOL] def make_expression ( conf ) : [EOL] [docstring] [EOL] if isinstance ( conf , str ) : [EOL] return _MatchExpression ( conf ) [EOL] elif isinstance ( conf , dict ) : [EOL] if len ( conf ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] key = conf . keys ( ) [ [number] ] [EOL] value = conf [ key ] [EOL] if key == [string] : [EOL] return _AllOfExpression ( _make_expression_list ( value ) ) [EOL] elif key == [string] : [EOL] return _AnyOfExpression ( _make_expression_list ( value ) ) [EOL] elif key == [string] : [EOL] return _NotExpression ( make_expression ( value ) ) [EOL] raise ValueError ( [string] . format ( conf ) ) [EOL] [EOL] [EOL] def _make_expression_list ( configs ) : [EOL] return [ make_expression ( conf ) for conf in configs ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class _SelectorConfig ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , root = None , roots = None , include_files = None , exclude_files = None , include_tags = None , exclude_tags = None , include_with_any_tags = None , exclude_with_any_tags = None ) : [EOL] [docstring] [EOL] [comment] [EOL] if root and roots : [EOL] raise ValueError ( [string] ) [EOL] if include_tags and exclude_tags : [EOL] raise ValueError ( [string] ) [EOL] self . root = root [EOL] self . roots = roots [EOL] self . include_files = utils . default_if_none ( include_files , [ ] ) [EOL] self . exclude_files = utils . default_if_none ( exclude_files , [ ] ) [EOL] include_with_any_tags = self . __merge_lists ( include_with_any_tags , config . INCLUDE_WITH_ANY_TAGS ) [EOL] exclude_with_any_tags = self . __merge_lists ( exclude_with_any_tags , config . EXCLUDE_WITH_ANY_TAGS ) [EOL] [EOL] self . tags_expression = self . __make_tags_expression ( include_tags , exclude_tags , include_with_any_tags , exclude_with_any_tags ) [EOL] [EOL] @ staticmethod def __merge_lists ( list_a , list_b ) : [EOL] if list_a or list_b : [EOL] if list_a is None : [EOL] return set ( list_b ) [EOL] elif list_b is None : [EOL] return set ( list_a ) [EOL] return set ( list_a ) | set ( list_b ) [EOL] return None [EOL] [EOL] @ staticmethod def __make_tags_expression ( include_tags , exclude_tags , include_with_any_tags , exclude_with_any_tags ) : [EOL] expressions = [ ] [EOL] if include_tags : [EOL] expressions . append ( make_expression ( include_tags ) ) [EOL] elif exclude_tags : [EOL] expressions . append ( _NotExpression ( make_expression ( exclude_tags ) ) ) [EOL] if include_with_any_tags : [EOL] include_with_any_expr = make_expression ( { [string] : include_with_any_tags } ) [EOL] expressions . append ( include_with_any_expr ) [EOL] if exclude_with_any_tags : [EOL] exclude_with_any_expr = make_expression ( { [string] : { [string] : exclude_with_any_tags } } ) [EOL] expressions . append ( exclude_with_any_expr ) [EOL] [EOL] if expressions : [EOL] return _AllOfExpression ( expressions ) [EOL] return None [EOL] [EOL] [EOL] class _Selector ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , test_file_explorer , tests_are_files = True ) : [EOL] [docstring] [EOL] self . _test_file_explorer = test_file_explorer [EOL] self . _tests_are_files = tests_are_files [EOL] [EOL] def select ( self , selector_config ) : [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if selector_config . roots is not None : [EOL] roots = selector_config . roots [EOL] else : [EOL] roots = self . _test_file_explorer . read_root_file ( selector_config . root ) [EOL] [EOL] [comment] [EOL] test_list = _TestList ( self . _test_file_explorer , roots , self . _tests_are_files ) [EOL] [comment] [EOL] if self . _tests_are_files and selector_config . exclude_files : [EOL] test_list . exclude_files ( selector_config . exclude_files ) [EOL] [comment] [EOL] if selector_config . tags_expression : [EOL] test_list . match_tag_expression ( selector_config . tags_expression , self . get_tags ) [EOL] [comment] [EOL] if self . _tests_are_files and selector_config . include_files : [EOL] test_list . include_files ( selector_config . include_files , force = True ) [EOL] [EOL] return self . sort_tests ( * test_list . get_tests ( ) ) [EOL] [EOL] @ staticmethod def sort_tests ( tests , excluded ) : [EOL] [docstring] [EOL] if config . ORDER_TESTS_BY_NAME : [EOL] return sorted ( tests , key = str . lower ) , sorted ( excluded , key = str . lower ) [EOL] return tests , excluded [EOL] [EOL] @ staticmethod def get_tags ( test_file ) : [comment] [EOL] [docstring] [EOL] return [ ] [EOL] [EOL] [EOL] class _JSTestSelectorConfig ( _SelectorConfig ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , roots = None , include_files = None , exclude_files = None , include_with_any_tags = None , exclude_with_any_tags = None , include_tags = None , exclude_tags = None ) : [EOL] _SelectorConfig . __init__ ( self , roots = roots , include_files = include_files , exclude_files = exclude_files , include_with_any_tags = include_with_any_tags , exclude_with_any_tags = exclude_with_any_tags , include_tags = include_tags , exclude_tags = exclude_tags ) [EOL] [EOL] [EOL] class _JSTestSelector ( _Selector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , test_file_explorer ) : [EOL] _Selector . __init__ ( self , test_file_explorer ) [EOL] self . _tags = self . _test_file_explorer . parse_tag_file ( [string] ) [EOL] [EOL] def get_tags ( self , test_file ) : [EOL] [docstring] [EOL] file_tags = self . _test_file_explorer . jstest_tags ( test_file ) [EOL] if test_file in self . _tags : [EOL] return list ( set ( file_tags ) | set ( self . _tags [ test_file ] ) ) [EOL] return file_tags [EOL] [EOL] [EOL] class _MultiJSTestSelectorConfig ( _JSTestSelectorConfig ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , group_size = None , group_count_multiplier = [number] , ** kwargs ) : [EOL] [docstring] [EOL] _JSTestSelectorConfig . __init__ ( self , ** kwargs ) [EOL] self . group_size = group_size [EOL] self . group_count_multiplier = group_count_multiplier [EOL] [EOL] [EOL] class _MultiJSTestSelector ( _JSTestSelector ) : [EOL] [docstring] [EOL] [EOL] def select ( self , selector_config ) : [EOL] [docstring] [EOL] tests , excluded = _JSTestSelector . select ( self , selector_config ) [EOL] [EOL] group_size = selector_config . group_size [EOL] multi = selector_config . group_count_multiplier [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if group_size is None : [EOL] multi = [number] [EOL] group_size = len ( tests ) [EOL] [EOL] grouped_tests = [ ] [EOL] [EOL] start = [number] [EOL] corpus = tests [ : ] [EOL] random . shuffle ( corpus ) [EOL] [EOL] num_groups = len ( tests ) * multi / group_size [EOL] while len ( grouped_tests ) < num_groups : [EOL] if start + group_size > len ( corpus ) : [EOL] recycled_tests = corpus [ : start ] [EOL] random . shuffle ( recycled_tests ) [EOL] corpus = corpus [ start : ] + recycled_tests [EOL] start = [number] [EOL] grouped_tests . append ( corpus [ start : start + group_size ] ) [EOL] start += group_size [EOL] return grouped_tests , excluded [EOL] [EOL] @ staticmethod def sort_tests ( tests , excluded ) : [EOL] [docstring] [EOL] return tests , excluded [EOL] [EOL] [EOL] class _CppTestSelectorConfig ( _SelectorConfig ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , root = config . DEFAULT_INTEGRATION_TEST_LIST , roots = None , include_files = None , exclude_files = None ) : [EOL] [docstring] [EOL] if roots : [EOL] [comment] [EOL] [comment] [EOL] _SelectorConfig . __init__ ( self , roots = roots , include_files = include_files , exclude_files = exclude_files ) [EOL] else : [EOL] _SelectorConfig . __init__ ( self , root = root , include_files = include_files , exclude_files = exclude_files ) [EOL] [EOL] [EOL] class _CppTestSelector ( _Selector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , test_file_explorer ) : [EOL] [docstring] [EOL] _Selector . __init__ ( self , test_file_explorer ) [EOL] [EOL] def select ( self , selector_config ) : [EOL] [docstring] [EOL] if selector_config . roots : [EOL] [comment] [EOL] [comment] [EOL] test_list = _TestList ( self . _test_file_explorer , selector_config . roots ) [EOL] return test_list . get_tests ( ) [EOL] return _Selector . select ( self , selector_config ) [EOL] [EOL] [EOL] class _DbTestSelectorConfig ( _SelectorConfig ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , binary = None , roots = None , include_suites = None ) : [EOL] [docstring] [EOL] _SelectorConfig . __init__ ( self , roots = roots ) [EOL] self . include_suites = utils . default_if_none ( include_suites , [ ] ) [EOL] [EOL] [comment] [EOL] binary = utils . default_if_none ( config . DBTEST_EXECUTABLE , binary ) [EOL] [comment] [EOL] binary = utils . default_if_none ( binary , config . DEFAULT_DBTEST_EXECUTABLE ) [EOL] [comment] [EOL] if sys . platform == [string] and os . path . splitext ( binary ) [ [number] ] != [string] : [EOL] binary += [string] [EOL] self . binary = binary [EOL] [EOL] [EOL] class _DbTestSelector ( _Selector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , test_file_explorer ) : [EOL] [docstring] [EOL] _Selector . __init__ ( self , test_file_explorer , tests_are_files = False ) [EOL] [EOL] def select ( self , selector_config ) : [EOL] [docstring] [EOL] if selector_config . roots : [EOL] roots = selector_config . roots [EOL] else : [EOL] if not self . _test_file_explorer . isfile ( selector_config . binary ) : [EOL] raise IOError ( errno . ENOENT , [string] , selector_config . binary ) [EOL] roots = self . _test_file_explorer . list_dbtests ( selector_config . binary ) [EOL] [EOL] if config . INCLUDE_WITH_ANY_TAGS : [EOL] [comment] [EOL] [comment] [EOL] return [ ] , roots [EOL] [EOL] if selector_config . roots : [EOL] [comment] [EOL] [comment] [EOL] return selector_config . roots , [ ] [EOL] [EOL] if not selector_config . include_suites : [EOL] return roots , [ ] [EOL] [EOL] test_files = _TestList ( self . _test_file_explorer , roots , tests_are_files = False ) [EOL] test_files . include_any_pattern ( selector_config . include_suites ) [EOL] [EOL] return test_files . get_tests ( ) [EOL] [EOL] [EOL] class _JsonTestSelectorConfig ( _SelectorConfig ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , roots , include_files = None , exclude_files = None ) : [EOL] [docstring] [EOL] _SelectorConfig . __init__ ( self , roots = roots , include_files = include_files , exclude_files = exclude_files ) [EOL] [EOL] [EOL] class _SleepTestCaseSelectorConfig ( _SelectorConfig ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , roots ) : [EOL] [docstring] [EOL] _SelectorConfig . __init__ ( self , roots = roots ) [EOL] [EOL] [EOL] class _SleepTestCaseSelector ( _Selector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , test_file_explorer ) : [EOL] [docstring] [EOL] _Selector . __init__ ( self , test_file_explorer , tests_are_files = False ) [EOL] [EOL] [EOL] class _PyTestCaseSelectorConfig ( _SelectorConfig ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , roots , include_files = None , exclude_files = None ) : [EOL] _SelectorConfig . __init__ ( self , roots = roots , include_files = include_files , exclude_files = exclude_files ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] _DEFAULT_TEST_FILE_EXPLORER = TestFileExplorer ( ) [EOL] [EOL] _SELECTOR_REGISTRY = { [string] : ( _CppTestSelectorConfig , _CppTestSelector ) , [string] : ( _CppTestSelectorConfig , _CppTestSelector ) , [string] : ( _CppTestSelectorConfig , _CppTestSelector ) , [string] : ( _JsonTestSelectorConfig , _Selector ) , [string] : ( _DbTestSelectorConfig , _DbTestSelector ) , [string] : ( _JSTestSelectorConfig , _JSTestSelector ) , [string] : ( _MultiJSTestSelectorConfig , _MultiJSTestSelector ) , [string] : ( _JsonTestSelectorConfig , _Selector ) , [string] : ( _JSTestSelectorConfig , _JSTestSelector ) , [string] : ( _JSTestSelectorConfig , _JSTestSelector ) , [string] : ( _PyTestCaseSelectorConfig , _Selector ) , [string] : ( _SleepTestCaseSelectorConfig , _SleepTestCaseSelector ) , } [EOL] [EOL] [EOL] def filter_tests ( test_kind , selector_config , test_file_explorer = _DEFAULT_TEST_FILE_EXPLORER ) : [EOL] [docstring] [EOL] if test_kind not in _SELECTOR_REGISTRY : [EOL] raise ValueError ( [string] . format ( test_kind ) ) [EOL] selector_config_class , selector_class = _SELECTOR_REGISTRY [ test_kind ] [EOL] selector = selector_class ( test_file_explorer ) [EOL] selector_config = selector_config_class ( ** selector_config ) [EOL] return selector . select ( selector_config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bytes$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , DefaultDict , Set [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import collections [EOL] import optparse [EOL] import os [EOL] [EOL] from . import config as _config [EOL] from . import errors [EOL] from . import utils [EOL] from . testing import suite as _suite [EOL] from . . import resmokeconfig [EOL] [EOL] [EOL] def get_named_suites ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] executor_only = { [string] , [string] , [string] } [EOL] suite_names = [ suite for suite in resmokeconfig . NAMED_SUITES if suite not in executor_only ] [EOL] suite_names . sort ( ) [EOL] return suite_names [EOL] [EOL] [EOL] def create_test_membership_map ( fail_on_missing_selector = False , test_kind = None ) : [EOL] [docstring] [EOL] [EOL] test_membership = collections . defaultdict ( list ) [EOL] suite_names = get_named_suites ( ) [EOL] for suite_name in suite_names : [EOL] try : [EOL] suite_config = _get_suite_config ( suite_name ) [EOL] if test_kind and suite_config . get ( [string] ) != test_kind : [EOL] continue [EOL] suite = _suite . Suite ( suite_name , suite_config ) [EOL] except IOError as err : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if err . filename in _config . EXTERNAL_SUITE_SELECTORS : [EOL] if not fail_on_missing_selector : [EOL] continue [EOL] raise [EOL] [EOL] for testfile in suite . tests : [EOL] if isinstance ( testfile , ( dict , list ) ) : [EOL] continue [EOL] test_membership [ testfile ] . append ( suite_name ) [EOL] return test_membership [EOL] [EOL] [EOL] def get_suites ( suite_files , test_files ) : [EOL] [docstring] [EOL] suite_roots = None [EOL] if test_files : [EOL] [comment] [EOL] [comment] [EOL] _config . ORDER_TESTS_BY_NAME = any ( tag_filter is not None for tag_filter in ( _config . EXCLUDE_WITH_ANY_TAGS , _config . INCLUDE_WITH_ANY_TAGS ) ) [EOL] [comment] [EOL] suite_roots = _make_suite_roots ( test_files ) [EOL] [EOL] suites = [ ] [EOL] for suite_filename in suite_files : [EOL] suite_config = _get_suite_config ( suite_filename ) [EOL] if suite_roots : [EOL] [comment] [EOL] suite_config . update ( suite_roots ) [EOL] suite = _suite . Suite ( suite_filename , suite_config ) [EOL] suites . append ( suite ) [EOL] return suites [EOL] [EOL] [EOL] def _make_suite_roots ( files ) : [EOL] return { [string] : { [string] : files } } [EOL] [EOL] [EOL] def _get_suite_config ( pathname ) : [EOL] [docstring] [EOL] return _get_yaml_config ( [string] , pathname ) [EOL] [EOL] [EOL] def _get_yaml_config ( kind , pathname ) : [EOL] [comment] [EOL] [comment] [EOL] if not utils . is_yaml_file ( pathname ) and not os . path . dirname ( pathname ) : [EOL] if pathname not in resmokeconfig . NAMED_SUITES : [EOL] raise errors . SuiteNotFound ( [string] % ( kind , pathname ) ) [EOL] pathname = resmokeconfig . NAMED_SUITES [ pathname ] [comment] [EOL] [EOL] if not utils . is_yaml_file ( pathname ) or not os . path . isfile ( pathname ) : [EOL] raise optparse . OptionValueError ( [string] % ( kind , pathname ) ) [EOL] return utils . load_yaml_file ( pathname ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import signal [EOL] [EOL] from . import interface [EOL] from . . . core import programs [EOL] [EOL] [EOL] class YesFixture ( interface . Fixture ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , logger , job_num , num_instances = [number] , message_length = [number] ) : [EOL] [docstring] [EOL] interface . Fixture . __init__ ( self , logger , job_num ) [EOL] [EOL] self . __processes = [ None ] * num_instances [EOL] self . __message = [string] * message_length [EOL] [EOL] def setup ( self ) : [EOL] [docstring] [EOL] for ( i , process ) in enumerate ( self . __processes ) : [EOL] process = self . _make_process ( i ) [EOL] [EOL] self . logger . info ( [string] , process . as_command ( ) ) [EOL] process . start ( ) [EOL] self . logger . info ( [string] , process . pid ) [EOL] [EOL] self . __processes [ i ] = process [EOL] [EOL] def _make_process ( self , index ) : [EOL] logger = self . logger . new_fixture_node_logger ( [string] . format ( index ) ) [EOL] return programs . generic_program ( logger , [ [string] , self . __message ] ) [EOL] [EOL] def _do_teardown ( self ) : [EOL] running_at_start = self . is_running ( ) [EOL] success = True [comment] [EOL] [EOL] if not running_at_start : [EOL] self . logger . info ( [string] ) [EOL] else : [EOL] self . logger . info ( [string] ) [EOL] [EOL] for process in reversed ( self . __processes ) : [EOL] if process is not None : [EOL] if running_at_start : [EOL] self . logger . info ( [string] , process . pid ) [EOL] process . stop ( ) [EOL] [EOL] exit_code = process . wait ( ) [EOL] success = ( exit_code == - signal . SIGTERM ) and success [EOL] [EOL] if running_at_start : [EOL] self . logger . info ( [string] [string] , process . pid , exit_code ) [EOL] [EOL] if running_at_start : [EOL] self . logger . info ( [string] ) [EOL] [EOL] return success [EOL] [EOL] def is_running ( self ) : [EOL] [docstring] [EOL] return all ( process is not None and process . poll ( ) is None for process in self . __processes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] from . interface import NoOpFixture as _NoOpFixture [EOL] from . interface import make_fixture [EOL] from . . . utils import autoloader as _autoloader [EOL] [EOL] NOOP_FIXTURE_CLASS = _NoOpFixture . REGISTERED_NAME [EOL] [EOL] [comment] [EOL] [comment] [EOL] _autoloader . load_all_modules ( name = __name__ , path = __path__ ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import bson [EOL] [EOL] from buildscripts . resmokelib import errors [EOL] [EOL] [EOL] def get_last_optime ( client ) : [EOL] [docstring] [EOL] repl_set_status = client . admin . command ( { [string] : [number] } ) [EOL] conn_status = [ m for m in repl_set_status [ [string] ] if [string] in m ] [ [number] ] [EOL] optime = conn_status [ [string] ] [EOL] [EOL] optime_is_empty = False [EOL] [EOL] if isinstance ( optime , bson . Timestamp ) : [comment] [EOL] optime_is_empty = ( optime == bson . Timestamp ( [number] , [number] ) ) [EOL] else : [comment] [EOL] optime_is_empty = ( optime [ [string] ] == bson . Timestamp ( [number] , [number] ) and optime [ [string] ] == - [number] ) [EOL] [EOL] if optime_is_empty : [EOL] raise errors . ServerFailure ( [string] . format ( addr = client . address , repl_set_status = repl_set_status ) ) [EOL] [EOL] return optime [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] from . import interface [EOL] from . . . import core [EOL] from . . . import utils [EOL] [EOL] [EOL] class CPPUnitTestCase ( interface . ProcessTestCase ) : [EOL] [docstring] [EOL] [EOL] REGISTERED_NAME = [string] [EOL] [EOL] def __init__ ( self , logger , program_executable , program_options = None ) : [EOL] [docstring] [EOL] [EOL] interface . ProcessTestCase . __init__ ( self , logger , [string] , program_executable ) [EOL] [EOL] self . program_executable = program_executable [EOL] self . program_options = utils . default_if_none ( program_options , { } ) . copy ( ) [EOL] [EOL] def _make_process ( self ) : [EOL] return core . process . Process ( self . logger , [ self . program_executable ] , ** self . program_options ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] from . interface import make_test_case [EOL] from . . . utils import autoloader as _autoloader [EOL] [EOL] [comment] [EOL] [comment] [EOL] _autoloader . load_all_modules ( name = __name__ , path = __path__ ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import time [EOL] [EOL] from . import interface [EOL] [EOL] [EOL] class SleepTestCase ( interface . TestCase ) : [EOL] [docstring] [EOL] [EOL] REGISTERED_NAME = [string] [EOL] [EOL] def __init__ ( self , logger , sleep_duration_secs ) : [EOL] [docstring] [EOL] [EOL] sleep_duration_secs = int ( sleep_duration_secs ) [EOL] [EOL] interface . TestCase . __init__ ( self , logger , [string] , [string] . format ( sleep_duration_secs ) ) [EOL] [EOL] self . __sleep_duration_secs = sleep_duration_secs [EOL] [EOL] def run_test ( self ) : [EOL] [docstring] [EOL] time . sleep ( self . __sleep_duration_secs ) [EOL] self . return_code = [number] [EOL] [EOL] def as_command ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . __sleep_duration_secs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] from . interface import make_hook [EOL] from . . . utils import autoloader as _autoloader [EOL] [EOL] [comment] [EOL] [comment] [EOL] _autoloader . load_all_modules ( name = __name__ , path = __path__ ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import copy [EOL] [EOL] from buildscripts . resmokelib import utils [EOL] from buildscripts . resmokelib . testing . hooks import interface [EOL] from buildscripts . resmokelib . testing . fixtures import shardedcluster [EOL] [EOL] [EOL] class CleanupConcurrencyWorkloads ( interface . Hook ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hook_logger , fixture , exclude_dbs = None , same_collection = False , same_db = False ) : [EOL] [docstring] [EOL] description = [string] [EOL] interface . Hook . __init__ ( self , hook_logger , fixture , description ) [EOL] [EOL] protected_dbs = [ [string] , [string] , [string] , [string] ] [EOL] self . exclude_dbs = list ( set ( ) . union ( protected_dbs , utils . default_if_none ( exclude_dbs , [ ] ) ) ) [EOL] self . same_collection_name = None [EOL] self . same_db_name = None [EOL] if same_db or same_collection : [EOL] [comment] [EOL] self . same_db_name = [string] [EOL] if same_collection : [EOL] [comment] [EOL] self . same_collection_name = [string] [EOL] [EOL] def after_test ( self , test , test_report ) : [EOL] [docstring] [EOL] hook_test_case = CleanupConcurrencyWorkloadsTestCase . create_after_test ( self . logger . test_case_logger , test , self ) [EOL] hook_test_case . configure ( self . fixture ) [EOL] hook_test_case . run_dynamic_test ( test_report ) [EOL] [EOL] [EOL] class CleanupConcurrencyWorkloadsTestCase ( interface . DynamicTestCase ) : [EOL] [docstring] [EOL] [EOL] def _find_same_db_name ( self , dbs ) : [EOL] [docstring] [EOL] for db in dbs : [EOL] if db . endswith ( self . _hook . same_db_name ) : [EOL] return db [EOL] return None [EOL] [EOL] def run_test ( self ) : [EOL] [docstring] [EOL] same_db_name = None [EOL] client = self . _hook . fixture . mongo_client ( ) [EOL] db_names = client . database_names ( ) [EOL] [EOL] exclude_dbs = copy . copy ( self . _hook . exclude_dbs ) [EOL] if self . _hook . same_db_name : [EOL] same_db_name = self . _find_same_db_name ( db_names ) [EOL] if same_db_name : [EOL] exclude_dbs . append ( same_db_name ) [EOL] self . logger . info ( [string] , exclude_dbs ) [EOL] [EOL] is_sharded_fixture = isinstance ( self . _hook . fixture , shardedcluster . ShardedClusterFixture ) [EOL] [comment] [EOL] if is_sharded_fixture and self . _hook . fixture . enable_balancer : [EOL] self . _hook . fixture . stop_balancer ( ) [EOL] [EOL] for db_name in [ db for db in db_names if db not in exclude_dbs ] : [EOL] self . logger . info ( [string] , db_name ) [EOL] try : [EOL] client . drop_database ( db_name ) [EOL] except : [EOL] self . logger . exception ( [string] , db_name ) [EOL] raise [EOL] [EOL] if self . _hook . same_collection_name and same_db_name : [EOL] self . logger . info ( [string] , same_db_name , self . _hook . same_collection_name ) [EOL] colls = client [ same_db_name ] . collection_names ( ) [EOL] for coll in [ coll for coll in colls if coll != self . _hook . same_collection_name ] : [EOL] self . logger . info ( [string] , same_db_name , coll ) [EOL] try : [EOL] client [ same_db_name ] . drop_collection ( coll ) [EOL] except : [EOL] self . logger . exception ( [string] , same_db_name , coll ) [EOL] raise [EOL] [EOL] [comment] [EOL] if is_sharded_fixture and self . _hook . fixture . enable_balancer : [EOL] self . _hook . fixture . start_balancer ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import sys [EOL] [EOL] from . . testcases import interface as testcase [EOL] from . . . import errors [EOL] from . . . logging import loggers [EOL] from . . . utils import registry [EOL] [EOL] _HOOKS = { } [comment] [EOL] [EOL] [EOL] def make_hook ( class_name , * args , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] if class_name not in _HOOKS : [EOL] raise ValueError ( [string] % class_name ) [EOL] [EOL] return _HOOKS [ class_name ] ( * args , ** kwargs ) [EOL] [EOL] [EOL] class Hook ( object ) : [EOL] [docstring] [EOL] [EOL] __metaclass__ = registry . make_registry_metaclass ( _HOOKS ) [comment] [EOL] [EOL] REGISTERED_NAME = registry . LEAVE_UNREGISTERED [EOL] [EOL] def __init__ ( self , hook_logger , fixture , description ) : [EOL] [docstring] [EOL] [EOL] if not isinstance ( hook_logger , loggers . HookLogger ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] self . logger = hook_logger [EOL] self . fixture = fixture [EOL] self . description = description [EOL] [EOL] def before_suite ( self , test_report ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def after_suite ( self , test_report ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def before_test ( self , test , test_report ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def after_test ( self , test , test_report ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class DynamicTestCase ( testcase . TestCase ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , logger , test_name , description , base_test_name , hook ) : [EOL] [docstring] [EOL] testcase . TestCase . __init__ ( self , logger , [string] , test_name ) [EOL] self . description = description [EOL] self . _hook = hook [EOL] self . _base_test_name = base_test_name [EOL] [EOL] def run_dynamic_test ( self , test_report ) : [EOL] [docstring] [EOL] test_report . startTest ( self , dynamic = True ) [EOL] try : [EOL] self . run_test ( ) [EOL] except ( errors . TestFailure , self . failureException ) as err : [EOL] self . return_code = [number] [EOL] self . logger . error ( [string] . format ( self . description ) ) [EOL] test_report . addFailure ( self , sys . exc_info ( ) ) [EOL] raise errors . TestFailure ( err . args [ [number] ] ) [EOL] except : [EOL] self . return_code = [number] [EOL] test_report . addFailure ( self , sys . exc_info ( ) ) [EOL] raise [EOL] else : [EOL] self . return_code = [number] [EOL] test_report . addSuccess ( self ) [EOL] finally : [EOL] test_report . stopTest ( self ) [EOL] [EOL] def as_command ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ classmethod def create_before_test ( cls , logger , base_test , hook , * args , ** kwargs ) : [EOL] [docstring] [EOL] base_test_name = base_test . short_name ( ) [EOL] test_name = cls . _make_test_name ( base_test_name , hook ) [EOL] description = [string] . format ( hook . description , base_test_name ) [EOL] return cls ( logger , test_name , description , base_test_name , hook , * args , ** kwargs ) [EOL] [EOL] @ classmethod def create_after_test ( cls , logger , base_test , hook , * args , ** kwargs ) : [EOL] [docstring] [EOL] base_test_name = base_test . short_name ( ) [EOL] test_name = cls . _make_test_name ( base_test_name , hook ) [EOL] description = [string] . format ( hook . description , base_test_name ) [EOL] return cls ( logger , test_name , description , base_test_name , hook , * args , ** kwargs ) [EOL] [EOL] @ staticmethod def _make_test_name ( base_test_name , hook ) : [EOL] return [string] . format ( base_test_name , hook . __class__ . __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import threading [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import heapq [EOL] import sched [EOL] import threading [EOL] [EOL] [EOL] class Scheduler ( sched . scheduler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , timefunc , delayfunc ) : [EOL] [docstring] [EOL] sched . scheduler . __init__ ( self , timefunc , delayfunc ) [EOL] [EOL] [comment] [EOL] self . _queue_lock = threading . RLock ( ) [EOL] [EOL] def enterabs ( self , time , priority , action , argument ) : [EOL] [docstring] [EOL] with self . _queue_lock : [EOL] return sched . scheduler . enterabs ( self , time , priority , action , argument ) [EOL] [EOL] def enter ( self , delay , priority , action , argument ) : [EOL] [docstring] [EOL] with self . _queue_lock : [EOL] return sched . scheduler . enter ( self , delay , priority , action , argument ) [EOL] [EOL] def cancel ( self , event ) : [EOL] [docstring] [EOL] with self . _queue_lock : [EOL] return sched . scheduler . cancel ( self , event ) [EOL] [EOL] def empty ( self ) : [EOL] [docstring] [EOL] with self . _queue_lock : [EOL] return sched . scheduler . empty ( self ) [EOL] [EOL] [comment] [EOL] def run ( self ) : [EOL] [docstring] [EOL] while True : [EOL] with self . _queue_lock : [EOL] if not self . _queue : [EOL] break [EOL] [EOL] now = self . timefunc ( ) [EOL] event = self . _queue [ [number] ] [EOL] [EOL] should_execute = event . time <= now [EOL] if should_execute : [EOL] heapq . heappop ( self . _queue ) [EOL] [EOL] if should_execute : [EOL] event . action ( * event . argument ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . delayfunc ( [number] ) [EOL] else : [EOL] self . delayfunc ( event . time - now ) [EOL] [EOL] @ property def queue ( self ) : [EOL] [docstring] [EOL] with self . _queue_lock : [EOL] return sched . scheduler . queue . fget ( self ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading._RLock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Type , Dict [EOL] import typing [EOL] import ctypes [EOL] import os [EOL] import threading [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import Queue [EOL] import collections [EOL] import json [EOL] import math [EOL] import os [EOL] import sys [EOL] import tarfile [EOL] import tempfile [EOL] import threading [EOL] import time [EOL] [EOL] _IS_WINDOWS = sys . platform == [string] or sys . platform == [string] [EOL] [EOL] if _IS_WINDOWS : [EOL] import ctypes [EOL] [EOL] UploadArgs = collections . namedtuple ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] ArchiveArgs = collections . namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def file_list_size ( files ) : [EOL] [docstring] [EOL] if isinstance ( files , str ) : [EOL] files = [ files ] [EOL] file_bytes = [number] [EOL] for ifile in files : [EOL] if not os . path . exists ( ifile ) : [EOL] pass [EOL] elif os . path . isdir ( ifile ) : [EOL] file_bytes += directory_size ( ifile ) [EOL] else : [EOL] file_bytes += os . path . getsize ( ifile ) [EOL] return file_bytes [EOL] [EOL] [EOL] def directory_size ( directory ) : [EOL] [docstring] [EOL] dir_bytes = [number] [EOL] for root_dir , _ , files in os . walk ( unicode ( directory ) ) : [EOL] for name in files : [EOL] full_name = os . path . join ( root_dir , name ) [EOL] try : [EOL] dir_bytes += os . path . getsize ( full_name ) [EOL] except OSError : [EOL] [comment] [EOL] pass [EOL] return dir_bytes [EOL] [EOL] [EOL] def free_space ( path ) : [EOL] [docstring] [EOL] if _IS_WINDOWS : [EOL] dirname = os . path . dirname ( path ) [EOL] free_bytes = ctypes . c_ulonglong ( [number] ) [EOL] ctypes . windll . kernel32 . GetDiskFreeSpaceExW ( ctypes . c_wchar_p ( dirname ) , None , None , ctypes . pointer ( free_bytes ) ) [EOL] return free_bytes . value [EOL] stat = os . statvfs ( path ) [EOL] return stat . f_bavail * stat . f_bsize [EOL] [EOL] [EOL] def remove_file ( file_name ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] os . remove ( file_name ) [EOL] status = [number] [EOL] message = [string] . format ( file_name ) [EOL] except Exception as err : [comment] [EOL] status = [number] [EOL] message = [string] . format ( file_name , err ) [EOL] return status , message [EOL] [EOL] [EOL] class Archival ( object ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , logger , archival_json_file = [string] , limit_size_mb = [number] , limit_files = [number] , s3_client = None ) : [EOL] [docstring] [EOL] [EOL] self . archival_json_file = archival_json_file [EOL] self . limit_size_mb = limit_size_mb [EOL] self . limit_files = limit_files [EOL] self . size_mb = [number] [EOL] self . num_files = [number] [EOL] self . archive_time = [number] [EOL] self . logger = logger [EOL] [EOL] [comment] [EOL] self . _lock = threading . Lock ( ) [EOL] [EOL] [comment] [EOL] self . _archive_file_queue = Queue . Queue ( ) [EOL] self . _archive_file_worker = threading . Thread ( target = self . _update_archive_file_wkr , args = ( self . _archive_file_queue , logger ) , name = [string] ) [EOL] self . _archive_file_worker . setDaemon ( True ) [EOL] self . _archive_file_worker . start ( ) [EOL] if not s3_client : [EOL] self . s3_client = self . _get_s3_client ( ) [EOL] else : [EOL] self . s3_client = s3_client [EOL] [EOL] [comment] [EOL] self . _upload_queue = Queue . Queue ( ) [EOL] self . _upload_worker = threading . Thread ( target = self . _upload_to_s3_wkr , args = ( self . _upload_queue , self . _archive_file_queue , logger , self . s3_client ) , name = [string] ) [EOL] self . _upload_worker . setDaemon ( True ) [EOL] self . _upload_worker . start ( ) [EOL] [EOL] @ staticmethod def _get_s3_client ( ) : [EOL] [comment] [EOL] import boto3 [EOL] return boto3 . client ( [string] ) [EOL] [EOL] def archive_files_to_s3 ( self , display_name , input_files , s3_bucket , s3_path ) : [EOL] [docstring] [EOL] [EOL] start_time = time . time ( ) [EOL] with self . _lock : [EOL] if not input_files : [EOL] status = [number] [EOL] message = [string] [EOL] elif self . limit_size_mb and self . size_mb >= self . limit_size_mb : [EOL] status = [number] [EOL] message = [string] . format ( self . limit_size_mb ) [EOL] elif self . limit_files and self . num_files >= self . limit_files : [EOL] status = [number] [EOL] message = [string] . format ( self . limit_files ) [EOL] else : [EOL] status , message , file_size_mb = self . _archive_files ( display_name , input_files , s3_bucket , s3_path ) [EOL] [EOL] if status == [number] : [EOL] self . num_files += [number] [EOL] self . size_mb += file_size_mb [EOL] self . archive_time += time . time ( ) - start_time [EOL] [EOL] return status , message [EOL] [EOL] @ staticmethod def _update_archive_file_wkr ( queue , logger ) : [EOL] [docstring] [EOL] archival_json = [ ] [EOL] while True : [EOL] archive_args = queue . get ( ) [EOL] [comment] [EOL] if archive_args is None : [EOL] queue . task_done ( ) [EOL] break [EOL] archival_record = { [string] : archive_args . display_name , [string] : archive_args . remote_file , [string] : [string] } [EOL] logger . debug ( [string] , archive_args . archival_file , archival_record ) [EOL] archival_json . append ( archival_record ) [EOL] with open ( archive_args . archival_file , [string] ) as archival_fh : [EOL] json . dump ( archival_json , archival_fh ) [EOL] queue . task_done ( ) [EOL] [EOL] @ staticmethod def _upload_to_s3_wkr ( queue , archive_file_queue , logger , s3_client ) : [EOL] [docstring] [EOL] while True : [EOL] upload_args = queue . get ( ) [EOL] [comment] [EOL] if upload_args is None : [EOL] queue . task_done ( ) [EOL] archive_file_queue . put ( None ) [EOL] break [EOL] extra_args = { [string] : upload_args . content_type , [string] : [string] } [EOL] logger . debug ( [string] , upload_args . local_file , upload_args . s3_bucket , upload_args . s3_path ) [EOL] upload_completed = False [EOL] try : [EOL] s3_client . upload_file ( upload_args . local_file , upload_args . s3_bucket , upload_args . s3_path , ExtraArgs = extra_args ) [EOL] upload_completed = True [EOL] logger . debug ( [string] , upload_args . local_file , upload_args . s3_bucket , upload_args . s3_path ) [EOL] except Exception as err : [comment] [EOL] logger . exception ( [string] , err ) [EOL] [EOL] if upload_args . delete_file : [EOL] status , message = remove_file ( upload_args . local_file ) [EOL] if status : [EOL] logger . error ( [string] , message ) [EOL] [EOL] remote_file = [string] . format ( upload_args . s3_bucket , upload_args . s3_path ) [EOL] if upload_completed : [EOL] archive_file_queue . put ( ArchiveArgs ( upload_args . archival_file , upload_args . display_name , remote_file ) ) [EOL] [EOL] queue . task_done ( ) [EOL] [EOL] def _archive_files ( self , display_name , input_files , s3_bucket , s3_path ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if isinstance ( input_files , str ) : [EOL] input_files = [ input_files ] [EOL] [EOL] message = [string] . format ( display_name , input_files ) [EOL] status = [number] [EOL] size_mb = [number] [EOL] [EOL] [comment] [EOL] _ , temp_file = tempfile . mkstemp ( suffix = [string] ) [EOL] [EOL] [comment] [EOL] if file_list_size ( input_files ) > free_space ( temp_file ) : [EOL] status , message = remove_file ( temp_file ) [EOL] if status : [EOL] self . logger . warning ( [string] , message ) [EOL] return [number] , [string] . format ( message ) , [number] [EOL] [EOL] try : [EOL] with tarfile . open ( temp_file , [string] ) as tar_handle : [EOL] for input_file in input_files : [EOL] try : [EOL] tar_handle . add ( input_file ) [EOL] except ( IOError , OSError , tarfile . TarError ) as err : [EOL] message = [string] . format ( message , input_file , err ) [EOL] except ( IOError , OSError , tarfile . TarError ) as err : [EOL] status , message = remove_file ( temp_file ) [EOL] if status : [EOL] self . logger . warning ( [string] , message ) [EOL] return [number] , str ( err ) , [number] [EOL] [EOL] [comment] [EOL] size_mb = int ( math . ceil ( float ( file_list_size ( temp_file ) ) / ( [number] * [number] ) ) ) [EOL] self . _upload_queue . put ( UploadArgs ( self . archival_json_file , display_name , temp_file , [string] , s3_bucket , s3_path , True ) ) [EOL] [EOL] return status , message , size_mb [EOL] [EOL] def check_thread ( self , thread , expected_alive ) : [EOL] [docstring] [EOL] if thread . isAlive ( ) and not expected_alive : [EOL] self . logger . warning ( [string] [string] , thread . name , self . archival_json_file ) [EOL] elif not thread . isAlive ( ) and expected_alive : [EOL] self . logger . warning ( [string] [string] , thread . name , self . archival_json_file ) [EOL] [EOL] def exit ( self , timeout = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _upload_queue . put ( None ) [EOL] self . check_thread ( self . _upload_worker , True ) [EOL] self . check_thread ( self . _archive_file_worker , True ) [EOL] self . _upload_worker . join ( timeout = timeout ) [EOL] self . check_thread ( self . _upload_worker , False ) [EOL] [EOL] [comment] [EOL] self . _archive_file_worker . join ( timeout = timeout ) [EOL] self . check_thread ( self . _archive_file_worker , False ) [EOL] [EOL] self . logger . info ( [string] , self . archive_time , self . num_files , self . size_mb ) [EOL] [EOL] def files_archived_num ( self ) : [EOL] [docstring] [EOL] return self . num_files [EOL] [EOL] def files_archived_size_mb ( self ) : [EOL] [docstring] [EOL] return self . size_mb [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Type[UploadArgs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[ArchiveArgs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Type[ArchiveArgs]$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[UploadArgs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict , Union [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import datetime [EOL] import unittest [EOL] [EOL] from mock import patch , Mock [EOL] [EOL] from buildscripts import generate_resmoke_suites as grs [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class GetStartAndEndCommitSinceDateTest ( unittest . TestCase ) : [EOL] @ patch ( [string] ) def test_that_first_and_last_commits_returned ( self , GithubApi ) : [EOL] GithubApi . get_commits . return_value = [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , ] [EOL] [EOL] target = grs . ProjectTarget ( [string] , [string] , [string] ) [EOL] [EOL] today = datetime . datetime . utcnow ( ) . replace ( microsecond = [number] , tzinfo = None ) [EOL] [EOL] commitRange = grs . get_start_and_end_commit_since_date ( GithubApi , target , today ) [EOL] [EOL] self . assertEqual ( commitRange . start , [string] ) [EOL] self . assertEqual ( commitRange . end , [string] ) [EOL] [EOL] [EOL] class GetHistoryByRevisionTest ( unittest . TestCase ) : [EOL] @ patch ( [string] ) def test_get_history_by_revision_call_evergreen ( self , EvergreenApi ) : [EOL] grs . get_history_by_revision ( EvergreenApi , [string] , grs . CommitRange ( [string] , [string] ) , [string] , None ) [EOL] [EOL] self . assertTrue ( EvergreenApi . get_history . called ) [EOL] [EOL] [EOL] class GetTestHistoryTest ( unittest . TestCase ) : [EOL] @ patch ( [string] ) def test_get_test_history_returns_when_the_end_revision_is_given ( self , EvergreenApi ) : [EOL] def get_history_mock ( project , params ) : [EOL] return [ { [string] : [string] } ] [EOL] [EOL] EvergreenApi . get_history = get_history_mock [EOL] grs . get_test_history ( EvergreenApi , grs . ProjectTarget ( [string] , [string] , [string] ) , [string] , grs . CommitRange ( [string] , [string] ) , None ) [EOL] [EOL] @ patch ( [string] ) def test_get_test_history_can_be_called_multiple_times ( self , EvergreenApi ) : [EOL] call_data = { [string] : [number] } [EOL] [EOL] def get_history_mock ( project , params ) : [EOL] returnValue = [ [string] , [string] , ] [EOL] [EOL] call_data [ [string] ] += [number] [EOL] return [ { [string] : returnValue [ call_data [ [string] ] - [number] ] } ] [EOL] [EOL] EvergreenApi . get_history = get_history_mock [EOL] [EOL] grs . get_test_history ( EvergreenApi , grs . ProjectTarget ( [string] , [string] , [string] ) , [string] , grs . CommitRange ( [string] , [string] ) , None ) [EOL] [EOL] self . assertEqual ( call_data [ [string] ] , [number] ) [EOL] [EOL] [EOL] class SplitHookRunsOutTest ( unittest . TestCase ) : [EOL] def test_a_list_with_no_hooks_returns_no_hooks ( self ) : [EOL] test_list = [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , ] [EOL] [EOL] ( tests , hooks ) = grs . split_hook_runs_out ( test_list ) [EOL] [EOL] self . assertEqual ( len ( tests ) , [number] ) [EOL] self . assertEqual ( len ( hooks ) , [number] ) [EOL] [EOL] def test_a_list_with_only_hooks_returns_all_hooks ( self ) : [EOL] test_list = [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , ] [EOL] [EOL] ( tests , hooks ) = grs . split_hook_runs_out ( test_list ) [EOL] [EOL] self . assertEqual ( len ( tests ) , [number] ) [EOL] self . assertEqual ( len ( hooks ) , [number] ) [EOL] [EOL] def test_a_list_with_a_mix_of_test_and_hooks_returns_both ( self ) : [EOL] test_list = [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , ] [EOL] [EOL] ( tests , hooks ) = grs . split_hook_runs_out ( test_list ) [EOL] [EOL] self . assertEqual ( len ( tests ) , [number] ) [EOL] self . assertEqual ( len ( hooks ) , [number] ) [EOL] [EOL] [EOL] class OrganizeHooksTest ( unittest . TestCase ) : [EOL] def test_calling_with_no_executions ( self ) : [EOL] hooks = grs . organize_hooks ( [ ] ) [EOL] [EOL] self . assertEqual ( len ( hooks ) , [number] ) [EOL] [EOL] def test_one_hooks ( self ) : [EOL] executions = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } ] [EOL] [EOL] hooks = grs . organize_hooks ( executions ) [EOL] [EOL] self . assertEqual ( len ( hooks ) , [number] ) [EOL] self . assertEqual ( hooks [ [string] ] [ [string] ] [ [string] ] , [number] ) [EOL] [EOL] def test_multiple_hooks_on_the_same_test ( self ) : [EOL] executions = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } ] [EOL] [EOL] hooks = grs . organize_hooks ( executions ) [EOL] [EOL] self . assertEqual ( len ( hooks ) , [number] ) [EOL] self . assertEqual ( hooks [ [string] ] [ [string] ] [ [string] ] , [number] ) [EOL] [EOL] def test_multiple_hooks_on_different_variants ( self ) : [EOL] executions = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } ] [EOL] [EOL] hooks = grs . organize_hooks ( executions ) [EOL] [EOL] self . assertEqual ( len ( hooks ) , [number] ) [EOL] self . assertEqual ( hooks [ [string] ] [ [string] ] [ [string] ] , [number] ) [EOL] self . assertEqual ( hooks [ [string] ] [ [string] ] [ [string] ] , [number] ) [EOL] self . assertEqual ( hooks [ [string] ] [ [string] ] [ [string] ] , [number] ) [EOL] [EOL] def test_multiple_hooks_on_different_revisions ( self ) : [EOL] executions = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } ] [EOL] [EOL] hooks = grs . organize_hooks ( executions ) [EOL] [EOL] self . assertEqual ( len ( hooks ) , [number] ) [EOL] self . assertEqual ( hooks [ [string] ] [ [string] ] [ [string] ] , [number] ) [EOL] self . assertEqual ( hooks [ [string] ] [ [string] ] [ [string] ] , [number] ) [EOL] self . assertEqual ( hooks [ [string] ] [ [string] ] [ [string] ] , [number] ) [EOL] [EOL] [EOL] class ExecutionRuntimeTest ( unittest . TestCase ) : [EOL] def test_execution_runtime_is_calculated_with_no_hooks ( self ) : [EOL] execution = { [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] [EOL] runtime = grs . execution_runtime ( [string] , execution , { } ) [EOL] [EOL] self . assertEquals ( runtime , [number] ) [EOL] [EOL] def test_execution_runtime_is_calculated_with_no_applicable_hooks ( self ) : [EOL] execution = { [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] hooks = { [string] : { [string] : { [string] : [number] , } } } [EOL] [EOL] runtime = grs . execution_runtime ( [string] , execution , hooks ) [EOL] [EOL] self . assertEquals ( runtime , [number] ) [EOL] [EOL] def test_execution_runtime_is_calculated_with_hooks ( self ) : [EOL] execution = { [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] hooks = { [string] : { [string] : { [string] : [number] , } } } [EOL] [EOL] runtime = grs . execution_runtime ( [string] , execution , hooks ) [EOL] [EOL] self . assertEquals ( runtime , [number] ) [EOL] [EOL] [EOL] class OrganizeExecutionsByTestTest ( unittest . TestCase ) : [EOL] def test_no_executions ( self ) : [EOL] tests = grs . organize_executions_by_test ( [ ] ) [EOL] [EOL] self . assertEquals ( len ( tests ) , [number] ) [EOL] [EOL] @ patch ( [string] ) def test_only_test_executions ( self , os ) : [EOL] os . path . isfile . return_value = True [EOL] [EOL] executions = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } ] [EOL] [EOL] tests = grs . organize_executions_by_test ( executions ) [EOL] [EOL] self . assertEquals ( len ( tests ) , [number] ) [EOL] self . assertEquals ( tests [ [string] ] [ [string] ] , [number] ) [EOL] self . assertEquals ( tests [ [string] ] [ [string] ] , [number] ) [EOL] self . assertEquals ( tests [ [string] ] [ [string] ] , [number] ) [EOL] [EOL] @ patch ( [string] ) def test_mix_of_test_and_hook_executions ( self , os ) : [EOL] os . path . isfile . return_value = True [EOL] [EOL] executions = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , ] [EOL] [EOL] tests = grs . organize_executions_by_test ( executions ) [EOL] [EOL] self . assertEquals ( len ( tests ) , [number] ) [EOL] self . assertEquals ( tests [ [string] ] [ [string] ] , [number] ) [EOL] self . assertEquals ( tests [ [string] ] [ [string] ] , [number] ) [EOL] self . assertEquals ( tests [ [string] ] [ [string] ] , [number] ) [EOL] [EOL] @ patch ( [string] ) def test_multiple_revisions_for_same_test ( self , os ) : [EOL] os . path . isfile . return_value = True [EOL] [EOL] executions = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , ] [EOL] [EOL] tests = grs . organize_executions_by_test ( executions ) [EOL] [EOL] self . assertEquals ( len ( tests ) , [number] ) [EOL] self . assertEquals ( tests [ [string] ] [ [string] ] , [number] ) [EOL] self . assertEquals ( tests [ [string] ] [ [string] ] , [number] ) [EOL] self . assertEquals ( tests [ [string] ] [ [string] ] , [number] ) [EOL] [EOL] @ patch ( [string] ) def test_non_files_are_not_included ( self , os ) : [EOL] os . path . isfile . return_value = False [EOL] [EOL] executions = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } ] [EOL] [EOL] tests = grs . organize_executions_by_test ( executions ) [EOL] [EOL] self . assertEquals ( len ( tests ) , [number] ) [EOL] [EOL] [EOL] class DivideTestsIntoSuitesByMaxtimeTest ( unittest . TestCase ) : [EOL] def test_if_less_total_than_max_only_one_suite_created ( self ) : [EOL] max_time = [number] [EOL] test_names = [ [string] , [string] , [string] ] [EOL] tests = { test_names [ [number] ] : { [string] : [number] } , test_names [ [number] ] : { [string] : [number] } , test_names [ [number] ] : { [string] : [number] } , } [EOL] [EOL] suites = grs . divide_tests_into_suites_by_maxtime ( tests , test_names , max_time ) [EOL] self . assertEqual ( len ( suites ) , [number] ) [EOL] self . assertEqual ( suites [ [number] ] . get_test_count ( ) , [number] ) [EOL] self . assertEqual ( suites [ [number] ] . get_runtime ( ) , [number] ) [EOL] [EOL] def test_if_each_test_should_be_own_suite ( self ) : [EOL] max_time = [number] [EOL] test_names = [ [string] , [string] , [string] ] [EOL] tests = { test_names [ [number] ] : { [string] : [number] } , test_names [ [number] ] : { [string] : [number] } , test_names [ [number] ] : { [string] : [number] } , } [EOL] [EOL] suites = grs . divide_tests_into_suites_by_maxtime ( tests , test_names , max_time ) [EOL] self . assertEqual ( len ( suites ) , [number] ) [EOL] [EOL] def test_if_test_is_greater_than_max_it_goes_alone ( self ) : [EOL] max_time = [number] [EOL] test_names = [ [string] , [string] , [string] ] [EOL] tests = { test_names [ [number] ] : { [string] : [number] } , test_names [ [number] ] : { [string] : [number] } , test_names [ [number] ] : { [string] : [number] } , } [EOL] [EOL] suites = grs . divide_tests_into_suites_by_maxtime ( tests , test_names , max_time ) [EOL] self . assertEqual ( len ( suites ) , [number] ) [EOL] self . assertEqual ( suites [ [number] ] . get_test_count ( ) , [number] ) [EOL] self . assertEqual ( suites [ [number] ] . get_runtime ( ) , [number] ) [EOL] [EOL] [EOL] class SuiteTest ( unittest . TestCase ) : [EOL] def test_adding_tests_increases_count_and_runtime ( self ) : [EOL] suite = grs . Suite ( ) [EOL] suite . add_test ( [string] , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } ) [EOL] suite . add_test ( [string] , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } ) [EOL] suite . add_test ( [string] , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } ) [EOL] [EOL] self . assertEqual ( suite . get_test_count ( ) , [number] ) [EOL] self . assertEqual ( suite . get_runtime ( ) , [number] ) [EOL] [EOL] def test_model_generation ( self ) : [EOL] suite = grs . Suite ( ) [EOL] suite . add_test ( [string] , { [string] : [number] * [number] , [string] : [number] * [number] , [string] : [number] * [number] , [string] : [number] * [number] , } ) [EOL] suite . add_test ( [string] , { [string] : [number] * [number] , [string] : [number] * [number] , [string] : [number] * [number] , [string] : [number] * [number] , } ) [EOL] suite . add_test ( [string] , { [string] : [number] * [number] , [string] : [number] * [number] , [string] : [number] * [number] , [string] : [number] * [number] , } ) [EOL] [EOL] model = suite . get_model ( ) [EOL] [EOL] self . assertEqual ( model [ [string] ] , [ [string] , [string] , [string] ] ) [EOL] self . assertIn ( { [string] : [number] , [string] : [string] } , model [ [string] ] ) [EOL] self . assertIn ( { [string] : [number] , [string] : [string] } , model [ [string] ] ) [EOL] self . assertIn ( { [string] : [number] , [string] : [string] } , model [ [string] ] ) [EOL] [EOL] [EOL] class GetMiscModelTest ( unittest . TestCase ) : [EOL] def test_model_with_test_in_same_dir ( self ) : [EOL] test_list = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] model = grs . get_misc_model ( test_list ) [EOL] [EOL] self . assertIn ( [string] , model ) [EOL] [EOL] self . assertIn ( [string] , model ) [EOL] self . assertEqual ( len ( model [ [string] ] ) , [number] ) [EOL] self . assertIn ( [string] , model [ [string] ] ) [EOL] self . assertIn ( [string] , model [ [string] ] ) [EOL] self . assertIn ( [string] , model [ [string] ] ) [EOL] self . assertIn ( [string] , model [ [string] ] ) [EOL] [EOL] def test_model_includes_extra_data ( self ) : [EOL] test_list = [ [string] ] [EOL] extra_data = { [string] : [string] , } [EOL] [EOL] model = grs . get_misc_model ( test_list , extra_data ) [EOL] [EOL] self . assertIn ( [string] , model ) [EOL] self . assertEqual ( model [ [string] ] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import unittest [EOL] [EOL] from buildscripts import evergreen_task_timeout as ett [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class DetermineTimeoutTest ( unittest . TestCase ) : [EOL] def test_timeout_used_if_specified ( self ) : [EOL] self . assertEqual ( ett . determine_timeout ( [string] , [string] , [number] ) , [number] ) [EOL] [EOL] def test_default_is_returned_with_no_timeout ( self ) : [EOL] self . assertEqual ( ett . determine_timeout ( [string] , [string] ) , ett . DEFAULT_NON_REQUIRED_BUILD_TIMEOUT_SECS ) [EOL] [EOL] def test_default_is_returned_with_timeout_at_zero ( self ) : [EOL] self . assertEqual ( ett . determine_timeout ( [string] , [string] , [number] ) , ett . DEFAULT_NON_REQUIRED_BUILD_TIMEOUT_SECS ) [EOL] [EOL] def test_default_required_returned_on_required_variants ( self ) : [EOL] self . assertEqual ( ett . determine_timeout ( [string] , next ( iter ( ett . REQUIRED_BUILD_VARIANTS ) ) ) , ett . DEFAULT_REQUIRED_BUILD_TIMEOUT_SECS ) [EOL] [EOL] def test_task_specific_timeout ( self ) : [EOL] self . assertEqual ( ett . determine_timeout ( [string] , [string] ) , [number] * [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] from __future__ import print_function [EOL] [EOL] import os [EOL] import shutil [EOL] import sys [EOL] import tempfile [EOL] import unittest [EOL] [EOL] from buildscripts . resmokelib import utils [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def rmtree ( dir_root ) : [EOL] [docstring] [EOL] utils . rmtree ( dir_root ) [EOL] return not os . path . exists ( dir_root ) [EOL] [EOL] [EOL] def create_file ( path ) : [EOL] [docstring] [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] [EOL] [EOL] def ascii_filesystemencoding ( ) : [EOL] [docstring] [EOL] encoding = sys . getfilesystemencoding ( ) [EOL] return encoding . startswith ( [string] ) or encoding == [string] [EOL] [EOL] [EOL] def string_for_ascii_filesystem_encoding ( path ) : [EOL] [docstring] [EOL] if ascii_filesystemencoding ( ) and isinstance ( path , unicode ) : [EOL] return path . encode ( [string] ) [EOL] return path [EOL] [EOL] [EOL] class RmtreeTestCase ( unittest . TestCase ) : [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . temp_dir_root = tempfile . mkdtemp ( ) [EOL] cls . cwd = os . getcwd ( ) [EOL] [EOL] @ classmethod def tearDownClass ( cls ) : [EOL] os . chdir ( cls . cwd ) [EOL] shutil . rmtree ( cls . temp_dir_root , ignore_errors = True ) [EOL] [EOL] def do_test ( self , name ) : [EOL] pass [EOL] [EOL] def test_ascii ( self ) : [EOL] [comment] [EOL] self . do_test ( [string] ) [EOL] [EOL] def test_unicode ( self ) : [EOL] [comment] [EOL] self . do_test ( [string] ) [EOL] [EOL] def test_greek ( self ) : [EOL] [comment] [EOL] self . do_test ( string_for_ascii_filesystem_encoding ( [string] ) ) [EOL] [EOL] def test_japanese ( self ) : [EOL] [comment] [EOL] self . do_test ( string_for_ascii_filesystem_encoding ( [string] ) ) [EOL] [EOL] [EOL] class RmtreeFileTests ( RmtreeTestCase ) : [EOL] def do_test ( self , file_name ) : [comment] [EOL] [docstring] [EOL] temp_dir = tempfile . mkdtemp ( dir = self . temp_dir_root ) [EOL] os . chdir ( temp_dir ) [EOL] create_file ( file_name ) [EOL] os . chdir ( self . temp_dir_root ) [EOL] self . assertTrue ( rmtree ( temp_dir ) ) [EOL] [EOL] [EOL] class RmtreeDirectoryTests ( RmtreeTestCase ) : [EOL] def do_test ( self , dir_name ) : [comment] [EOL] [docstring] [EOL] os . chdir ( self . temp_dir_root ) [EOL] os . mkdir ( dir_name ) [EOL] self . assertTrue ( rmtree ( dir_name ) ) [EOL] [EOL] [EOL] class RmtreeDirectoryWithNonAsciiTests ( RmtreeTestCase ) : [EOL] def do_test ( self , name ) : [EOL] [docstring] [EOL] os . chdir ( self . temp_dir_root ) [EOL] os . mkdir ( name ) [EOL] os . chdir ( name ) [EOL] create_file ( name ) [EOL] os . chdir ( self . temp_dir_root ) [EOL] self . assertTrue ( rmtree ( name ) ) [EOL] [EOL] [EOL] class ShutilWindowsRmtreeFileTests ( RmtreeFileTests ) : [EOL] def do_test ( self , file_name ) : [EOL] [docstring] [EOL] if not utils . is_windows ( ) : [EOL] print ( [string] ) [EOL] return [EOL] temp_dir = tempfile . mkdtemp ( dir = self . temp_dir_root ) [EOL] os . chdir ( temp_dir ) [EOL] create_file ( file_name ) [EOL] os . chdir ( self . temp_dir_root ) [EOL] with self . assertRaises ( WindowsError ) : [comment] [EOL] shutil . rmtree ( temp_dir ) [EOL] [EOL] def test_ascii ( self ) : [EOL] pass [EOL] [EOL] def test_unicode ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[comment] [EOL] from typing import Any , List , Dict , Union [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import datetime [EOL] import os [EOL] import unittest [EOL] [EOL] import mock [EOL] [EOL] import buildscripts . resmokelib . testing . hooks . combine_benchrun_embedded_results as cber [EOL] [EOL] [comment] [EOL] [EOL] _BM_REPORT_INSERT_1 = { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , [string] : [number] , [string] : { [string] : [string] } , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } [EOL] [EOL] _BM_REPORT_INSERT_2 = { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , [string] : [number] , [string] : { [string] : [string] } , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } [EOL] [EOL] _BM_REPORT_DELETE = { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , [string] : [string] , [string] : { [string] : [string] } , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } [EOL] [EOL] _BM_REPORT_UPDATE = { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , [string] : [number] , [string] : { [string] : [string] } , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } [EOL] [EOL] _BM_REPORT_MULTI = { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , [string] : [number] , [string] : { [string] : [string] } , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } [EOL] [EOL] _BM_ALL_REPORTS = [ _BM_REPORT_INSERT_1 , _BM_REPORT_INSERT_2 , _BM_REPORT_DELETE , _BM_REPORT_UPDATE , _BM_REPORT_MULTI ] [EOL] [EOL] [comment] [EOL] _START_TIME = [number] [EOL] [EOL] [comment] [EOL] _END_TIME = [number] [EOL] [EOL] [EOL] class CombineBenchrunEmbeddedResultsFixture ( unittest . TestCase ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ mock . patch ( [string] , autospec = True ) def setUp ( self , MockHook ) : [comment] [EOL] self . cber_hook = cber . CombineBenchrunEmbeddedResults ( None , None ) [EOL] self . cber_hook . create_time = datetime . datetime . utcfromtimestamp ( _START_TIME ) [EOL] self . cber_hook . end_time = datetime . datetime . utcfromtimestamp ( _END_TIME ) [EOL] [EOL] [EOL] class TestCombineBenchmarkResults ( CombineBenchrunEmbeddedResultsFixture ) : [EOL] def _setup_reports ( self , reports , test_name , num_threads ) : [EOL] self . total_ops_per_sec = [number] [EOL] self . num_tests = len ( reports ) [EOL] self . cber_hook . benchmark_reports [ test_name ] = cber . _BenchrunEmbeddedThreadsReport ( ) [EOL] for rep in reports : [EOL] self . cber_hook . benchmark_reports [ test_name ] . add_report ( num_threads , rep ) [EOL] self . total_ops_per_sec += rep [ [string] ] [EOL] self . ops_per_sec = self . total_ops_per_sec / self . num_tests [EOL] self . report = self . cber_hook . _generate_perf_plugin_report ( ) [EOL] [EOL] def test_generate_one_report ( self ) : [EOL] test_name = [string] [EOL] num_threads = [string] [EOL] self . _setup_reports ( [ _BM_REPORT_MULTI ] , test_name , num_threads ) [EOL] report_0 = self . report [ [string] ] [ [number] ] [EOL] self . assertEqual ( report_0 [ [string] ] , test_name ) [EOL] self . assertEqual ( report_0 [ [string] ] [ str ( num_threads ) ] [ [string] ] , self . ops_per_sec ) [EOL] [EOL] def test_generate_all_reports ( self ) : [EOL] test_name = [string] [EOL] thread_num = [string] [EOL] self . _setup_reports ( _BM_ALL_REPORTS , test_name , thread_num ) [EOL] self . assertEqual ( len ( self . report . keys ( ) ) , [number] ) [EOL] report_0 = self . report [ [string] ] [ [number] ] [EOL] self . assertEqual ( report_0 [ [string] ] , test_name ) [EOL] self . assertEqual ( report_0 [ [string] ] [ thread_num ] [ [string] ] , self . ops_per_sec ) [EOL] self . assertEqual ( self . report [ [string] ] , [string] ) [EOL] self . assertEqual ( self . report [ [string] ] , [string] ) [EOL] [EOL] def test_parse_report_name ( self ) : [EOL] self . cber_hook . report_root = os . path . join ( [string] , [string] ) [EOL] test_name = [string] [EOL] thread_num = [number] [EOL] file_name = os . path . join ( self . cber_hook . report_root , test_name , [string] . format ( thread_num ) , [string] ) [EOL] report_threads = self . cber_hook . _parse_report_name ( file_name ) [EOL] self . assertEqual ( thread_num , int ( report_threads ) ) [EOL] [EOL] [EOL] class TestBenchrunEmbeddedThreadsReport ( CombineBenchrunEmbeddedResultsFixture ) : [EOL] def test_generate_single_thread_perf_plugin_dict ( self ) : [EOL] thread_report = cber . _BenchrunEmbeddedThreadsReport ( ) [EOL] thread_num = [string] [EOL] thread_report . add_report ( thread_num , _BM_REPORT_INSERT_1 ) [EOL] perf_report = thread_report . generate_perf_plugin_dict ( ) [EOL] self . assertEqual ( len ( perf_report . keys ( ) ) , [number] ) [EOL] self . assertEqual ( perf_report [ thread_num ] [ [string] ] , _BM_REPORT_INSERT_1 [ [string] ] ) [EOL] self . assertEqual ( len ( perf_report [ thread_num ] [ [string] ] ) , [number] ) [EOL] [EOL] thread_report . add_report ( thread_num , _BM_REPORT_INSERT_2 ) [EOL] perf_report = thread_report . generate_perf_plugin_dict ( ) [EOL] self . assertEqual ( len ( perf_report . keys ( ) ) , [number] ) [EOL] ops_per_sec = ( _BM_REPORT_INSERT_1 [ [string] ] + _BM_REPORT_INSERT_2 [ [string] ] ) / [number] [EOL] self . assertEqual ( perf_report [ thread_num ] [ [string] ] , ops_per_sec ) [EOL] self . assertEqual ( len ( perf_report [ thread_num ] [ [string] ] ) , [number] ) [EOL] [EOL] def test_generate_multi_thread_perf_plugin_dict ( self ) : [EOL] thread_report = cber . _BenchrunEmbeddedThreadsReport ( ) [EOL] thread_num = [string] [EOL] thread_report . add_report ( thread_num , _BM_REPORT_INSERT_1 ) [EOL] perf_report = thread_report . generate_perf_plugin_dict ( ) [EOL] self . assertEqual ( len ( perf_report . keys ( ) ) , [number] ) [EOL] self . assertEqual ( perf_report [ thread_num ] [ [string] ] , _BM_REPORT_INSERT_1 [ [string] ] ) [EOL] self . assertEqual ( len ( perf_report [ thread_num ] [ [string] ] ) , [number] ) [EOL] [EOL] thread_num = [string] [EOL] thread_report . add_report ( thread_num , _BM_REPORT_INSERT_2 ) [EOL] perf_report = thread_report . generate_perf_plugin_dict ( ) [EOL] self . assertEqual ( len ( perf_report . keys ( ) ) , [number] ) [EOL] self . assertEqual ( perf_report [ [string] ] [ [string] ] , _BM_REPORT_INSERT_1 [ [string] ] ) [EOL] self . assertEqual ( len ( perf_report [ [string] ] [ [string] ] ) , [number] ) [EOL] self . assertEqual ( perf_report [ thread_num ] [ [string] ] , _BM_REPORT_INSERT_2 [ [string] ] ) [EOL] self . assertEqual ( len ( perf_report [ thread_num ] [ [string] ] ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]]$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List , Optional , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import distutils . spawn [comment] [EOL] import os [EOL] import shutil [EOL] import sys [EOL] import tempfile [EOL] import unittest [EOL] [EOL] import buildscripts . mobile . adb_monitor as adb_monitor [EOL] [EOL] _IS_WINDOWS = sys . platform == [string] or sys . platform == [string] [EOL] [EOL] if _IS_WINDOWS : [EOL] import win32file [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def mock_adb_and_systrace ( directory ) : [EOL] [docstring] [EOL] [comment] [EOL] adb_binary = os . path . join ( directory , [string] ) [EOL] echo_binary = distutils . spawn . find_executable ( [string] ) [EOL] if _IS_WINDOWS : [EOL] adb_binary = [string] . format ( adb_binary ) [EOL] shutil . copyfile ( echo_binary , adb_binary ) [EOL] else : [EOL] os . symlink ( echo_binary , adb_binary ) [EOL] os . environ [ [string] ] = [string] . format ( directory , os . path . pathsep , os . environ [ [string] ] ) [EOL] [EOL] [comment] [EOL] systrace_dir = os . path . join ( directory , [string] ) [EOL] os . mkdir ( systrace_dir ) [EOL] systrace = os . path . join ( systrace_dir , [string] ) [EOL] with open ( systrace , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] fh . write ( [string] ) [EOL] fh . write ( [string] ) [EOL] fh . write ( [string] ) [EOL] fh . write ( [string] ) [EOL] fh . write ( [string] ) [EOL] fh . write ( [string] ) [EOL] fh . write ( [string] ) [EOL] fh . write ( [string] ) [EOL] [EOL] [EOL] def file_contents ( path ) : [EOL] with open ( path , [string] ) as fh : [EOL] return fh . read ( ) [EOL] [EOL] [EOL] class AdbTestCase ( unittest . TestCase ) : [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . temp_dir = tempfile . mkdtemp ( ) [EOL] mock_adb_and_systrace ( cls . temp_dir ) [EOL] cls . adb = adb_monitor . Adb ( ) [EOL] [EOL] @ classmethod def tearDownClass ( cls ) : [EOL] shutil . rmtree ( cls . temp_dir ) [EOL] [EOL] [EOL] class AdbTest ( AdbTestCase ) : [EOL] def test_bad_adb ( self ) : [EOL] self . assertRaises ( EnvironmentError , lambda : adb_monitor . Adb ( [string] ) ) [EOL] [EOL] def test_devices ( self ) : [EOL] self . adb . devices ( ) [EOL] [EOL] def test_battery ( self ) : [EOL] temp_file = os . path . join ( self . temp_dir , [string] ) [EOL] self . adb . battery ( output_file = temp_file ) [EOL] self . assertTrue ( os . path . isfile ( temp_file ) ) [EOL] [EOL] def test_memory ( self ) : [EOL] temp_file = os . path . join ( self . temp_dir , [string] ) [EOL] self . adb . memory ( output_file = temp_file ) [EOL] self . assertTrue ( os . path . isfile ( temp_file ) ) [EOL] [EOL] def test_systrace ( self ) : [EOL] temp_file = os . path . join ( self . temp_dir , [string] ) [EOL] self . adb . systrace_start ( output_file = temp_file ) [EOL] self . adb . systrace_stop ( ) [EOL] self . assertTrue ( os . path . isfile ( temp_file ) ) [EOL] [EOL] [EOL] class AdbControlTestCase ( unittest . TestCase ) : [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . temp_dir = tempfile . mkdtemp ( ) [EOL] mock_adb_and_systrace ( cls . temp_dir ) [EOL] cls . adb = adb_monitor . Adb ( ) [EOL] [EOL] @ classmethod def tearDownClass ( cls ) : [EOL] shutil . rmtree ( cls . temp_dir ) [EOL] [EOL] [EOL] class AdbControlTest ( AdbControlTestCase ) : [EOL] def _test_files ( self , num_samples = [number] , collection_time_secs = [number] , sample_interval_ms = [number] , arg_list = None ) : [EOL] args = { } [EOL] arg_file_list = [ ] [EOL] for arg_name in arg_list : [EOL] arg_test_file = tempfile . NamedTemporaryFile ( delete = False ) . name [EOL] args [ arg_name ] = arg_test_file [EOL] arg_file_list . append ( arg_test_file ) [EOL] adb_control = adb_monitor . AdbControl ( self . adb , collection_time_secs = collection_time_secs , num_samples = num_samples , sample_interval_ms = sample_interval_ms , ** args ) [EOL] adb_control . start ( ) [EOL] adb_control . wait ( ) [EOL] for arg_file in arg_file_list : [EOL] self . assertGreater ( os . stat ( arg_file ) . st_size , [number] ) [EOL] os . remove ( arg_file ) [EOL] [EOL] def test_all_files_num_samples ( self ) : [EOL] self . _test_files ( num_samples = [number] , arg_list = [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_all_files_collection_time_secs ( self ) : [EOL] self . _test_files ( collection_time_secs = [number] , arg_list = [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_all_files_collection_and_samples ( self ) : [EOL] self . _test_files ( collection_time_secs = [number] , num_samples = [number] , arg_list = [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_no_file_arg ( self ) : [EOL] self . assertRaises ( ValueError , lambda : adb_monitor . AdbControl ( self . adb ) ) [EOL] [EOL] def test_bad_file_arg ( self ) : [EOL] self . assertRaises ( TypeError , lambda : self . _test_files ( arg_list = [ [string] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import unittest [EOL] [EOL] import client . evergreen as evergreen [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class GenerateEvergreenProjectNameTest ( unittest . TestCase ) : [EOL] def test_generate_evergreen_project_name ( self ) : [EOL] owner = [string] [EOL] project = [string] [EOL] branch = [string] [EOL] [EOL] project_name = evergreen . generate_evergreen_project_name ( owner , project , branch ) [EOL] [EOL] self . assertIn ( owner , project_name ) [EOL] self . assertIn ( project , project_name ) [EOL] self . assertIn ( branch , project_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0
[docstring] [EOL]	0 0
from typing import Any , List , Dict , Union [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import datetime [EOL] import os [EOL] import unittest [EOL] [EOL] import buildscripts . ciconfig . evergreen as _evergreen [EOL] [EOL] [comment] [EOL] [EOL] TEST_FILE_PATH = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] [EOL] [EOL] class TestEvergreenProjectConfig ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . conf = _evergreen . parse_evergreen_file ( TEST_FILE_PATH , evergreen_binary = None ) [EOL] [EOL] def test_invalid_path ( self ) : [EOL] invalid_path = [string] [EOL] with self . assertRaises ( IOError ) : [EOL] _evergreen . parse_evergreen_file ( invalid_path , evergreen_binary = None ) [EOL] [EOL] def test_list_tasks ( self ) : [EOL] self . assertEqual ( [number] , len ( self . conf . tasks ) ) [EOL] self . assertEqual ( [number] , len ( self . conf . task_names ) ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] [EOL] def test_list_task_groups ( self ) : [EOL] self . assertEqual ( [number] , len ( self . conf . task_groups ) ) [EOL] self . assertEqual ( [number] , len ( self . conf . task_group_names ) ) [EOL] self . assertIn ( [string] , self . conf . task_group_names ) [EOL] [EOL] def test_list_lifecycle_task_names ( self ) : [EOL] self . assertEqual ( [number] , len ( self . conf . lifecycle_task_names ) ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] self . assertIn ( [string] , self . conf . task_names ) [EOL] [EOL] def test_list_variants ( self ) : [EOL] self . assertEqual ( [number] , len ( self . conf . variants ) ) [EOL] self . assertEqual ( [number] , len ( self . conf . variant_names ) ) [EOL] self . assertIn ( [string] , self . conf . variant_names ) [EOL] self . assertIn ( [string] , self . conf . variant_names ) [EOL] self . assertIn ( [string] , self . conf . variant_names ) [EOL] self . assertIn ( [string] , self . conf . variant_names ) [EOL] [EOL] def test_get_variant ( self ) : [EOL] variant = self . conf . get_variant ( [string] ) [EOL] [EOL] self . assertIsNotNone ( variant ) [EOL] self . assertEqual ( [string] , variant . name ) [EOL] [EOL] def test_list_distro_names ( self ) : [EOL] self . assertEqual ( [number] , len ( self . conf . distro_names ) ) [EOL] self . assertIn ( [string] , self . conf . distro_names ) [EOL] self . assertIn ( [string] , self . conf . distro_names ) [EOL] self . assertIn ( [string] , self . conf . distro_names ) [EOL] self . assertIn ( [string] , self . conf . distro_names ) [EOL] self . assertIn ( [string] , self . conf . distro_names ) [EOL] [EOL] [EOL] class TestTask ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_from_dict ( self ) : [EOL] task_dict = { [string] : [string] , [string] : [ ] , [string] : [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] , [string] : { [string] : [string] } } , { [string] : [string] , [string] : { [string] : [string] } } ] } [EOL] task = _evergreen . Task ( task_dict ) [EOL] [EOL] self . assertEqual ( [string] , task . name ) [EOL] self . assertEqual ( [ ] , task . depends_on ) [EOL] self . assertEqual ( task_dict , task . raw ) [EOL] [EOL] def test_resmoke_args ( self ) : [EOL] task_dict = { [string] : [string] , [string] : [ { [string] : [string] , [string] : { [string] : [string] } } ] } [EOL] task = _evergreen . Task ( task_dict ) [EOL] [EOL] self . assertEqual ( [string] , task . resmoke_args ) [EOL] self . assertEqual ( [string] , task . resmoke_suite ) [EOL] [EOL] [EOL] class TestTaskGroup ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_from_list ( self ) : [EOL] task_group_dict = { [string] : [string] , [string] : [number] , [string] : [ [string] , [string] ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] } [EOL] task_group = _evergreen . TaskGroup ( task_group_dict ) [EOL] [EOL] self . assertEqual ( [string] , task_group . name ) [EOL] self . assertEqual ( [number] , len ( task_group . tasks ) ) [EOL] self . assertEqual ( task_group_dict , task_group . raw ) [EOL] [EOL] def test_resmoke_args ( self ) : [EOL] task_dict = { [string] : [string] , [string] : [ { [string] : [string] , [string] : { [string] : [string] } } ] } [EOL] task = _evergreen . Task ( task_dict ) [EOL] [EOL] self . assertEqual ( [string] , task . resmoke_args ) [EOL] self . assertEqual ( [string] , task . resmoke_suite ) [EOL] [EOL] [EOL] class TestVariant ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . conf = _evergreen . parse_evergreen_file ( TEST_FILE_PATH , evergreen_binary = None ) [EOL] [EOL] def test_from_dict ( self ) : [EOL] task = _evergreen . Task ( { [string] : [string] } ) [EOL] tasks_map = { task . name : task } [EOL] task_groups_map = { } [EOL] variant_dict = { [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : [ { [string] : [string] } ] , } [EOL] variant = _evergreen . Variant ( variant_dict , tasks_map , task_groups_map ) [EOL] [EOL] self . assertEqual ( [string] , variant . name ) [EOL] self . assertEqual ( [string] , variant . display_name ) [EOL] self . assertEqual ( [ [string] ] , variant . run_on ) [EOL] self . assertEqual ( [number] , len ( variant . tasks ) ) [EOL] self . assertEqual ( [string] , variant . tasks [ [number] ] . name ) [EOL] [EOL] def test_display_name ( self ) : [EOL] variant_ubuntu = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( [string] , variant_ubuntu . display_name ) [EOL] [EOL] variant_osx = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( [string] , variant_osx . display_name ) [EOL] [EOL] def test_batchtime ( self ) : [EOL] variant_ubuntu = self . conf . get_variant ( [string] ) [EOL] batchtime = datetime . timedelta ( minutes = [number] ) [EOL] self . assertEqual ( batchtime , variant_ubuntu . batchtime ) [EOL] [EOL] variant_osx = self . conf . get_variant ( [string] ) [EOL] self . assertIsNone ( variant_osx . batchtime ) [EOL] [EOL] def test_modules ( self ) : [EOL] variant_ubuntu = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( [ [string] ] , variant_ubuntu . modules ) [EOL] [EOL] variant_osx = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( [ ] , variant_osx . modules ) [EOL] [EOL] def test_run_on ( self ) : [EOL] variant_ubuntu = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( [ [string] ] , variant_ubuntu . run_on ) [EOL] [EOL] variant_osx = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( [ [string] ] , variant_osx . run_on ) [EOL] [EOL] def test_distro_names ( self ) : [EOL] variant_ubuntu = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( set ( [ [string] , [string] ] ) , variant_ubuntu . distro_names ) [EOL] [EOL] variant_osx = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( set ( [ [string] ] ) , variant_osx . distro_names ) [EOL] [EOL] def test_test_flags ( self ) : [EOL] variant_ubuntu = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( [string] , variant_ubuntu . test_flags ) [EOL] [EOL] variant_osx = self . conf . get_variant ( [string] ) [EOL] self . assertIsNone ( variant_osx . test_flags ) [EOL] [EOL] def test_num_jobs_available ( self ) : [EOL] variant_ubuntu = self . conf . get_variant ( [string] ) [EOL] self . assertIsNone ( variant_ubuntu . num_jobs_available ) [EOL] [EOL] variant_osx = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( [number] , variant_osx . num_jobs_available ) [EOL] [EOL] def test_variant_tasks ( self ) : [EOL] variant_ubuntu = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( [number] , len ( variant_ubuntu . tasks ) ) [EOL] for task_name in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] task = variant_ubuntu . get_task ( task_name ) [EOL] self . assertIsNotNone ( task ) [EOL] self . assertEqual ( variant_ubuntu , task . variant ) [EOL] self . assertIn ( task_name , variant_ubuntu . task_names ) [EOL] [EOL] [comment] [EOL] resmoke_task = variant_ubuntu . get_task ( [string] ) [EOL] self . assertEqual ( [string] , resmoke_task . combined_resmoke_args ) [EOL] [EOL] [comment] [EOL] passing_task = variant_ubuntu . get_task ( [string] ) [EOL] self . assertIsNone ( passing_task . combined_resmoke_args ) [EOL] [EOL] [comment] [EOL] variant_debian = self . conf . get_variant ( [string] ) [EOL] resmoke_task = variant_debian . get_task ( [string] ) [EOL] self . assertEqual ( [string] , resmoke_task . combined_resmoke_args ) [EOL] [EOL] [comment] [EOL] variant_amazon = self . conf . get_variant ( [string] ) [EOL] self . assertEqual ( [number] , len ( variant_amazon . tasks ) ) [EOL] self . assertIn ( [string] , variant_amazon . task_names ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]],builtins.str]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 $typing.Dict[unknown,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $typing.Any$ 0 $datetime.timedelta$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import unittest [EOL] [EOL] import util . time as time_utils [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Ns2SecTest ( unittest . TestCase ) : [EOL] def test_ns_converted_to_seconds ( self ) : [EOL] self . assertEqual ( time_utils . ns2sec ( [number] ** [number] ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] [EOL] import unittest [EOL] [EOL] import util . testname as testname_utils [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class IsResmokeHookTest ( unittest . TestCase ) : [EOL] def test_is_a_test_hook_true ( self ) : [EOL] self . assertTrue ( testname_utils . is_resmoke_hook ( [string] ) ) [EOL] [EOL] def test_is_a_test_hook_false ( self ) : [EOL] self . assertFalse ( testname_utils . is_resmoke_hook ( [string] ) ) [EOL] [EOL] [EOL] class SplitTestHookNameTest ( unittest . TestCase ) : [EOL] def test_split_test_hook_returns_test_name_and_hook ( self ) : [EOL] ( test_name , hook_name ) = testname_utils . split_test_hook_name ( [string] ) [EOL] [EOL] self . assertEqual ( test_name , [string] ) [EOL] self . assertEqual ( hook_name , [string] ) [EOL] [EOL] def test_split_test_hook_name_should_throw_exception ( self ) : [EOL] with self . assertRaises ( AssertionError ) : [EOL] testname_utils . split_test_hook_name ( [string] ) [EOL] [EOL] [EOL] class GetShortNameFromTestFileTest ( unittest . TestCase ) : [EOL] def test_only_base_name_is_returned ( self ) : [EOL] hook_name = testname_utils . get_short_name_from_test_file ( [string] ) [EOL] [EOL] self . assertEqual ( hook_name , [string] ) [EOL] [EOL] def test_extension_is_not_returned ( self ) : [EOL] hook_name = testname_utils . get_short_name_from_test_file ( [string] ) [EOL] [EOL] self . assertEqual ( hook_name , [string] ) [EOL] [EOL] def test_full_path_and_extension_are_stripped ( self ) : [EOL] hook_name = testname_utils . get_short_name_from_test_file ( [string] ) [EOL] [EOL] self . assertEqual ( hook_name , [string] ) [EOL] [EOL] [EOL] class NormalizeTestFileTest ( unittest . TestCase ) : [EOL] def test_windows_file_is_normalized ( self ) : [EOL] windows_file = [string] [EOL] self . assertEqual ( testname_utils . normalize_test_file ( windows_file ) , [string] ) [EOL] [EOL] def test_windows_file_with_non_exe_ext ( self ) : [EOL] windows_file = [string] [EOL] self . assertEqual ( testname_utils . normalize_test_file ( windows_file ) , [string] ) [EOL] [EOL] def test_unix_files_are_not_changed ( self ) : [EOL] unix_file = [string] [EOL] self . assertEqual ( testname_utils . normalize_test_file ( unix_file ) , unix_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0
[docstring] [EOL]	0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] import time [EOL] [EOL] try : [EOL] from urlparse import urlparse [EOL] except ImportError : [EOL] from urllib . parse import urlparse [comment] [EOL] [EOL] import requests [EOL] import yaml [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_API_SERVER = [string] [EOL] [EOL] [EOL] def generate_evergreen_project_name ( owner , project , branch ) : [EOL] [docstring] [EOL] return [string] . format ( owner = owner , project = project , branch = branch ) [EOL] [EOL] [EOL] def read_evg_config ( ) : [EOL] [docstring] [EOL] known_locations = [ [string] , os . path . expanduser ( [string] ) , os . path . expanduser ( [string] ) , ] [EOL] [EOL] for filename in known_locations : [EOL] if os . path . isfile ( filename ) : [EOL] with open ( filename , [string] ) as fstream : [EOL] return yaml . safe_load ( fstream ) [EOL] [EOL] return None [EOL] [EOL] [EOL] def get_evergreen_server ( ) : [EOL] [docstring] [EOL] evg_config = read_evg_config ( ) [EOL] evg_config = evg_config if evg_config is not None else { } [EOL] api_server = [string] . format ( url = urlparse ( evg_config . get ( [string] , DEFAULT_API_SERVER ) ) ) [EOL] [EOL] return api_server [EOL] [EOL] [EOL] def get_evergreen_api ( ) : [EOL] [docstring] [EOL] return EvergreenApi ( get_evergreen_server ( ) ) [EOL] [EOL] [EOL] class EvergreenApi ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_server ) : [EOL] [docstring] [EOL] self . api_server = api_server [EOL] [EOL] def get_history ( self , project , params ) : [EOL] [docstring] [EOL] url = [string] . format ( api_server = self . api_server , project = project ) [EOL] [EOL] start = time . time ( ) [EOL] response = requests . get ( url = url , params = params ) [EOL] LOGGER . debug ( [string] , round ( time . time ( ) - start , [number] ) ) [EOL] response . raise_for_status ( ) [EOL] [EOL] return response . json ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] import json [EOL] [EOL] URL_PATH_STATS = [string] [EOL] URL_PATH_LAST_REGISTER = [string] [EOL] URL_PATH_LAST_METRICS = [string] [EOL] URL_DISABLE_FAULTS = [string] [EOL] URL_ENABLE_FAULTS = [string] [EOL] [EOL] class Stats : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . register_calls = [number] [EOL] self . metrics_calls = [number] [EOL] self . fault_calls = [number] [EOL] [EOL] def __repr__ ( self ) : [EOL] return json . dumps ( { [string] : self . metrics_calls , [string] : self . register_calls , [string] : self . fault_calls , } ) [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import List , Literal , Any , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] import argparse [EOL] import urllib [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import collections [EOL] import http . server [EOL] import json [EOL] import logging [EOL] import socketserver [EOL] import sys [EOL] import urllib . parse [EOL] [EOL] import bson [EOL] from bson . codec_options import CodecOptions [EOL] from bson . json_util import dumps [EOL] import mock_http_common [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] stats = mock_http_common . Stats ( ) [EOL] last_metrics = None [EOL] last_register = None [EOL] disable_faults = False [EOL] fault_type = None [EOL] [EOL] [docstring] [EOL] FAULT_FAIL_REGISTER = [string] [EOL] [EOL] [docstring] [EOL] FAULT_INVALID_REGISTER = [string] [EOL] [EOL] [docstring] [EOL] FAULT_HALT_METRICS_5 = [string] [EOL] [EOL] [docstring] [EOL] FAULT_PERMANENTLY_DELETE_AFTER_3 = [string] [EOL] [EOL] [docstring] [EOL] FAULT_RESEND_REGISTRATION_AT_3 = [string] [EOL] [EOL] [docstring] [EOL] FAULT_RESEND_REGISTRATION_ONCE = [string] [EOL] [EOL] [comment] [EOL] SUPPORTED_FAULT_TYPES = [ FAULT_FAIL_REGISTER , FAULT_INVALID_REGISTER , FAULT_HALT_METRICS_5 , FAULT_PERMANENTLY_DELETE_AFTER_3 , FAULT_RESEND_REGISTRATION_AT_3 , FAULT_RESEND_REGISTRATION_ONCE , ] [EOL] [EOL] [comment] [EOL] URL_POST_REGISTER = [string] [EOL] URL_POST_METRICS = [string] [EOL] [EOL] [EOL] class FreeMonHandler ( http . server . BaseHTTPRequestHandler ) : [EOL] [docstring] [EOL] [EOL] def do_GET ( self ) : [EOL] [docstring] [EOL] parts = urllib . parse . urlsplit ( self . path ) [EOL] path = parts [ [number] ] [EOL] [EOL] if path == mock_http_common . URL_PATH_STATS : [EOL] self . _do_stats ( ) [EOL] elif path == mock_http_common . URL_PATH_LAST_REGISTER : [EOL] self . _do_last_register ( ) [EOL] elif path == mock_http_common . URL_PATH_LAST_METRICS : [EOL] self . _do_last_metrics ( ) [EOL] elif path == mock_http_common . URL_DISABLE_FAULTS : [EOL] self . _do_disable_faults ( ) [EOL] elif path == mock_http_common . URL_ENABLE_FAULTS : [EOL] self . _do_enable_faults ( ) [EOL] else : [EOL] self . send_response ( http . HTTPStatus . NOT_FOUND ) [EOL] self . end_headers ( ) [EOL] self . wfile . write ( [string] . encode ( ) ) [EOL] [EOL] def do_POST ( self ) : [EOL] [docstring] [EOL] parts = urllib . parse . urlsplit ( self . path ) [EOL] path = parts [ [number] ] [EOL] [EOL] if path == URL_POST_REGISTER : [EOL] self . _do_registration ( ) [EOL] elif path == URL_POST_METRICS : [EOL] self . _do_metrics ( ) [EOL] else : [EOL] self . send_response ( http . HTTPStatus . NOT_FOUND ) [EOL] self . end_headers ( ) [EOL] self . wfile . write ( [string] . encode ( ) ) [EOL] [EOL] def _send_header ( self ) : [EOL] self . send_response ( http . HTTPStatus . OK ) [EOL] self . send_header ( [string] , [string] ) [EOL] self . end_headers ( ) [EOL] [EOL] def _do_registration ( self ) : [EOL] global stats [EOL] global last_register [EOL] clen = int ( self . headers . get ( [string] ) ) [EOL] [EOL] stats . register_calls += [number] [EOL] [EOL] raw_input = self . rfile . read ( clen ) [EOL] decoded_doc = bson . BSON . decode ( raw_input ) [EOL] last_register = dumps ( decoded_doc ) [EOL] [EOL] if not disable_faults and fault_type == FAULT_FAIL_REGISTER : [EOL] stats . fault_calls += [number] [EOL] self . send_response ( http . HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] self . send_header ( [string] , [string] ) [EOL] self . end_headers ( ) [EOL] self . wfile . write ( [string] . encode ( ) ) [EOL] return [EOL] [EOL] if not disable_faults and fault_type == FAULT_INVALID_REGISTER : [EOL] stats . fault_calls += [number] [EOL] data = bson . BSON . encode ( { [string] : bson . int64 . Int64 ( [number] ) , [string] : False , [string] : [string] , [string] : [string] , [string] : [string] , [string] : bson . int64 . Int64 ( [number] ) , } ) [EOL] else : [EOL] data = bson . BSON . encode ( { [string] : bson . int64 . Int64 ( [number] ) , [string] : False , [string] : [string] , [string] : [string] , [string] : [string] , [string] : bson . int64 . Int64 ( [number] ) , [string] : [string] , } ) [EOL] [EOL] self . _send_header ( ) [EOL] [EOL] self . wfile . write ( data ) [EOL] [EOL] def _do_metrics ( self ) : [EOL] global stats [EOL] global last_metrics [EOL] clen = int ( self . headers . get ( [string] ) ) [EOL] [EOL] stats . metrics_calls += [number] [EOL] [EOL] raw_input = self . rfile . read ( clen ) [EOL] decoded_doc = bson . BSON . decode ( raw_input ) [EOL] last_metrics = dumps ( decoded_doc ) [EOL] [EOL] if not disable_faults and stats . metrics_calls > [number] and fault_type == FAULT_HALT_METRICS_5 : [EOL] stats . fault_calls += [number] [EOL] data = bson . BSON . encode ( { [string] : bson . int64 . Int64 ( [number] ) , [string] : True , [string] : False , [string] : [string] , [string] : bson . int64 . Int64 ( [number] ) , [string] : [string] , } ) [EOL] elif not disable_faults and stats . metrics_calls > [number] and fault_type == FAULT_PERMANENTLY_DELETE_AFTER_3 : [EOL] stats . fault_calls += [number] [EOL] data = bson . BSON . encode ( { [string] : bson . int64 . Int64 ( [number] ) , [string] : False , [string] : True , [string] : [string] , [string] : bson . int64 . Int64 ( [number] ) , [string] : [string] , } ) [EOL] elif not disable_faults and stats . metrics_calls > [number] and stats . fault_calls < [number] and fault_type == FAULT_RESEND_REGISTRATION_ONCE : [EOL] stats . fault_calls += [number] [EOL] data = bson . BSON . encode ( { [string] : bson . int64 . Int64 ( [number] ) , [string] : False , [string] : False , [string] : [string] , [string] : bson . int64 . Int64 ( [number] ) , [string] : [string] , [string] : True , } ) [EOL] elif not disable_faults and stats . metrics_calls == [number] and fault_type == FAULT_RESEND_REGISTRATION_AT_3 : [EOL] stats . fault_calls += [number] [EOL] data = bson . BSON . encode ( { [string] : bson . int64 . Int64 ( [number] ) , [string] : False , [string] : False , [string] : [string] , [string] : bson . int64 . Int64 ( [number] ) , [string] : [string] , [string] : True , } ) [EOL] else : [EOL] data = bson . BSON . encode ( { [string] : bson . int64 . Int64 ( [number] ) , [string] : False , [string] : False , [string] : [string] , [string] : bson . int64 . Int64 ( [number] ) , [string] : [string] , } ) [EOL] [EOL] [comment] [EOL] self . _send_header ( ) [EOL] [EOL] self . wfile . write ( data ) [EOL] [EOL] def _do_stats ( self ) : [EOL] self . _send_header ( ) [EOL] [EOL] self . wfile . write ( str ( stats ) . encode ( [string] ) ) [EOL] [EOL] def _do_last_register ( self ) : [EOL] self . _send_header ( ) [EOL] [EOL] self . wfile . write ( str ( last_register ) . encode ( [string] ) ) [EOL] [EOL] def _do_last_metrics ( self ) : [EOL] self . _send_header ( ) [EOL] [EOL] self . wfile . write ( str ( last_metrics ) . encode ( [string] ) ) [EOL] [EOL] def _do_disable_faults ( self ) : [EOL] global disable_faults [EOL] disable_faults = True [EOL] self . _send_header ( ) [EOL] [EOL] def _do_enable_faults ( self ) : [EOL] global disable_faults [EOL] disable_faults = False [EOL] self . _send_header ( ) [EOL] [EOL] def run ( port , server_class = http . server . HTTPServer , handler_class = FreeMonHandler ) : [EOL] [docstring] [EOL] server_address = ( [string] , port ) [EOL] [EOL] http . server . HTTPServer . protocol_version = [string] [EOL] [EOL] httpd = server_class ( server_address , handler_class ) [EOL] [EOL] print ( [string] % ( str ( server_address ) ) ) [EOL] [EOL] httpd . serve_forever ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] global fault_type [EOL] global disable_faults [EOL] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = int , default = [number] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] if args . verbose : [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] if args . fault : [EOL] if args . fault not in SUPPORTED_FAULT_TYPES : [EOL] print ( [string] % ( args . fault , SUPPORTED_FAULT_TYPES ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] fault_type = args . fault [EOL] [EOL] if args . disable_faults : [EOL] disable_faults = True [EOL] [EOL] run ( args . port ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.SplitResult$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $urllib.parse.SplitResult$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.SplitResult$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $urllib.parse.SplitResult$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from docutils import nodes [EOL] [EOL] class refcounting ( nodes . emphasis ) : pass [EOL] [EOL] def visit ( self , node ) : [EOL] self . visit_emphasis ( node ) [EOL] [EOL] def depart ( self , node ) : [EOL] self . depart_emphasis ( node ) [EOL] [EOL] def html_visit ( self , node ) : [EOL] self . body . append ( self . starttag ( node , [string] , [string] , CLASS = [string] ) ) [EOL] [EOL] def html_depart ( self , node ) : [EOL] self . body . append ( [string] ) [EOL] [EOL] [EOL] def refcounting_directive ( name , arguments , options , content , lineno , content_offset , block_text , state , state_machine ) : [EOL] if arguments [ [number] ] == [string] : [EOL] text = [string] [EOL] elif arguments [ [number] ] == [string] : [EOL] text = [string] [EOL] else : [EOL] raise Error ( [string] ) [EOL] [EOL] return [ refcounting ( text , text ) ] [EOL] [EOL] def setup ( app ) : [EOL] app . add_node ( refcounting , html = ( html_visit , html_depart ) , latex = ( visit , depart ) , text = ( visit , depart ) , man = ( visit , depart ) ) [EOL] app . add_directive ( [string] , refcounting_directive , [number] , ( [number] , [number] , [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Pattern , Any [EOL] import typing [EOL] import test [EOL] import os [EOL] import shutil [EOL] from shutil import rmtree [EOL] from os import mkdir [EOL] from glob import glob [EOL] from os . path import join , dirname , exists [EOL] import re [EOL] [EOL] [EOL] FLAGS_PATTERN = re . compile ( [string] ) [EOL] FILES_PATTERN = re . compile ( [string] ) [EOL] [EOL] [EOL] class SimpleTestCase ( test . TestCase ) : [EOL] [EOL] def __init__ ( self , path , file , mode , context , config , additional = [ ] ) : [EOL] super ( SimpleTestCase , self ) . __init__ ( context , path , mode ) [EOL] self . file = file [EOL] self . config = config [EOL] self . mode = mode [EOL] self . tmpdir = join ( dirname ( self . config . root ) , [string] ) [EOL] self . additional_flags = additional [EOL] [EOL] def AfterRun ( self , result ) : [EOL] [comment] [EOL] try : [EOL] rmtree ( self . tmpdir ) [EOL] except : [EOL] pass [EOL] [comment] [EOL] try : [EOL] mkdir ( self . tmpdir ) [EOL] except : [EOL] pass [EOL] [EOL] def BeforeRun ( self ) : [EOL] [comment] [EOL] try : [EOL] rmtree ( self . tmpdir ) [EOL] except : [EOL] pass [EOL] [comment] [EOL] [comment] [EOL] while not os . path . exists ( self . tmpdir ) : [EOL] try : [EOL] mkdir ( self . tmpdir ) [EOL] except : [EOL] pass [EOL] [EOL] def GetLabel ( self ) : [EOL] return [string] % ( self . mode , self . GetName ( ) ) [EOL] [EOL] def GetName ( self ) : [EOL] return self . path [ - [number] ] [EOL] [EOL] def GetCommand ( self ) : [EOL] result = [ self . config . context . GetVm ( self . mode ) ] [EOL] source = open ( self . file ) . read ( ) [EOL] flags_match = FLAGS_PATTERN . search ( source ) [EOL] if flags_match : [EOL] result += flags_match . group ( [number] ) . strip ( ) . split ( ) [EOL] files_match = FILES_PATTERN . search ( source ) [EOL] additional_files = [ ] [EOL] if files_match : [EOL] additional_files += files_match . group ( [number] ) . strip ( ) . split ( ) [EOL] for a_file in additional_files : [EOL] result . append ( join ( dirname ( self . config . root ) , [string] , a_file ) ) [EOL] [EOL] if self . additional_flags : [EOL] result += self . additional_flags [EOL] [EOL] result += [ self . file ] [EOL] [EOL] return result [EOL] [EOL] def GetSource ( self ) : [EOL] return open ( self . file ) . read ( ) [EOL] [EOL] [EOL] class SimpleTestConfiguration ( test . TestConfiguration ) : [EOL] [EOL] def __init__ ( self , context , root , section , additional = [ ] ) : [EOL] super ( SimpleTestConfiguration , self ) . __init__ ( context , root ) [EOL] self . section = section [EOL] self . additional_flags = additional [EOL] [EOL] def Ls ( self , path ) : [EOL] def SelectTest ( name ) : [EOL] return name . startswith ( [string] ) and name . endswith ( [string] ) [EOL] return [ f [ : - [number] ] for f in os . listdir ( path ) if SelectTest ( f ) ] [EOL] [EOL] def ListTests ( self , current_path , path , mode ) : [EOL] all_tests = [ current_path + [ t ] for t in self . Ls ( join ( self . root ) ) ] [EOL] result = [ ] [EOL] for test in all_tests : [EOL] if self . Contains ( path , test ) : [EOL] file_path = join ( self . root , reduce ( join , test [ [number] : ] , [string] ) + [string] ) [EOL] result . append ( SimpleTestCase ( test , file_path , mode , self . context , self , self . additional_flags ) ) [EOL] return result [EOL] [EOL] def GetBuildRequirements ( self ) : [EOL] return [ [string] , [string] ] [EOL] [EOL] def GetTestStatus ( self , sections , defs ) : [EOL] status_file = join ( self . root , [string] % ( self . section ) ) [EOL] if exists ( status_file ) : [EOL] test . ReadConfigurationInto ( status_file , sections , defs ) [EOL] [EOL] class AddonTestConfiguration ( SimpleTestConfiguration ) : [EOL] def __init__ ( self , context , root , section , additional = [ ] ) : [EOL] super ( AddonTestConfiguration , self ) . __init__ ( context , root , section ) [EOL] [EOL] def Ls ( self , path ) : [EOL] def SelectTest ( name ) : [EOL] return name . endswith ( [string] ) [EOL] [EOL] result = [ ] [EOL] for subpath in os . listdir ( path ) : [EOL] if os . path . isdir ( join ( path , subpath ) ) : [EOL] for f in os . listdir ( join ( path , subpath ) ) : [EOL] if SelectTest ( f ) : [EOL] result . append ( [ subpath , f [ : - [number] ] ] ) [EOL] return result [EOL] [EOL] def ListTests ( self , current_path , path , mode ) : [EOL] all_tests = [ current_path + t for t in self . Ls ( join ( self . root ) ) ] [EOL] result = [ ] [EOL] for test in all_tests : [EOL] if self . Contains ( path , test ) : [EOL] file_path = join ( self . root , reduce ( join , test [ [number] : ] , [string] ) + [string] ) [EOL] result . append ( SimpleTestCase ( test , file_path , mode , self . context , self ) ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Pattern , Any [EOL] import typing [EOL] import test [EOL] import os [EOL] import shutil [EOL] from shutil import rmtree [EOL] from os import mkdir [EOL] from glob import glob [EOL] from os . path import join , dirname , exists [EOL] import re [EOL] import shlex [EOL] [EOL] FAKETIME_FLAGS_PATTERN = re . compile ( [string] ) [EOL] FAKETIME_BIN_PATH = os . path . join ( [string] , [string] , [string] , [string] ) [EOL] [EOL] class TimersTestCase ( test . TestCase ) : [EOL] [EOL] def __init__ ( self , path , file , mode , context , config ) : [EOL] super ( TimersTestCase , self ) . __init__ ( context , path , mode ) [EOL] self . file = file [EOL] self . config = config [EOL] self . mode = mode [EOL] [EOL] def GetLabel ( self ) : [EOL] return [string] % ( self . mode , self . GetName ( ) ) [EOL] [EOL] def GetName ( self ) : [EOL] return self . path [ - [number] ] [EOL] [EOL] def GetCommand ( self ) : [EOL] result = [ FAKETIME_BIN_PATH ] [EOL] [EOL] source = open ( self . file ) . read ( ) [EOL] faketime_flags_match = FAKETIME_FLAGS_PATTERN . search ( source ) [EOL] if faketime_flags_match : [EOL] result += shlex . split ( faketime_flags_match . group ( [number] ) . strip ( ) ) [EOL] [EOL] result += [ self . config . context . GetVm ( self . mode ) ] [EOL] result += [ self . file ] [EOL] [EOL] return result [EOL] [EOL] def GetSource ( self ) : [EOL] return open ( self . file ) . read ( ) [EOL] [EOL] [EOL] class TimersTestConfiguration ( test . TestConfiguration ) : [EOL] [EOL] def __init__ ( self , context , root ) : [EOL] super ( TimersTestConfiguration , self ) . __init__ ( context , root ) [EOL] [EOL] def Ls ( self , path ) : [EOL] def SelectTest ( name ) : [EOL] return name . startswith ( [string] ) and name . endswith ( [string] ) [EOL] return [ f [ : - [number] ] for f in os . listdir ( path ) if SelectTest ( f ) ] [EOL] [EOL] def ListTests ( self , current_path , path , mode ) : [EOL] all_tests = [ current_path + [ t ] for t in self . Ls ( join ( self . root ) ) ] [EOL] result = [ ] [EOL] for test in all_tests : [EOL] if self . Contains ( path , test ) : [EOL] file_path = join ( self . root , reduce ( join , test [ [number] : ] , [string] ) + [string] ) [EOL] result . append ( TimersTestCase ( test , file_path , mode , self . context , self ) ) [EOL] return result [EOL] [EOL] def GetBuildRequirements ( self ) : [EOL] return [ [string] , [string] ] [EOL] [EOL] def GetTestStatus ( self , sections , defs ) : [EOL] status_file = join ( self . root , [string] ) [EOL] if exists ( status_file ) : [EOL] test . ReadConfigurationInto ( status_file , sections , defs ) [EOL] [EOL] [EOL] [EOL] def GetConfiguration ( context , root ) : [EOL] return TimersTestConfiguration ( context , root ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 $typing.list$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import sys , os [EOL] sys . path . append ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] import testpy [EOL] [EOL] def GetConfiguration ( context , root ) : [EOL] return testpy . SimpleTestConfiguration ( context , root , [string] , [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Callable , Type [EOL] import typing [EOL] import platform [EOL] import re [EOL] [EOL] [EOL] [comment] [EOL] def ReadLinesFrom ( name ) : [EOL] list = [ ] [EOL] for line in open ( name ) : [EOL] if [string] in line : [EOL] line = line [ : line . find ( [string] ) ] [EOL] line = line . strip ( ) [EOL] if len ( line ) == [number] : [EOL] continue [EOL] list . append ( line ) [EOL] return list [EOL] [EOL] [EOL] def GuessOS ( ) : [EOL] id = platform . system ( ) [EOL] if id == [string] : [EOL] return [string] [EOL] elif id == [string] : [EOL] return [string] [EOL] elif id . find ( [string] ) >= [number] : [EOL] return [string] [EOL] elif id == [string] or id == [string] : [EOL] [comment] [EOL] [comment] [EOL] return [string] [EOL] elif id == [string] : [EOL] return [string] [EOL] elif id == [string] : [EOL] return [string] [EOL] elif id == [string] : [EOL] return [string] [EOL] elif id == [string] : [EOL] return [string] [EOL] else : [EOL] return None [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def GuessArchitecture ( ) : [EOL] id = platform . machine ( ) [EOL] id = id . lower ( ) [comment] [EOL] if id . startswith ( [string] ) : [EOL] return [string] [EOL] elif ( not id ) or ( not re . match ( [string] , id ) is None ) : [EOL] return [string] [EOL] elif id == [string] : [EOL] return [string] [EOL] elif id == [string] : [EOL] return [string] [EOL] elif id == [string] : [EOL] return [string] [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def GuessWordsize ( ) : [EOL] if [string] in platform . machine ( ) : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] def IsWindows ( ) : [EOL] return GuessOS ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] try : [EOL] from setuptools import setup [EOL] except ImportError : [EOL] from distutils . core import setup [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , license = [string] , author = [string] , author_email = [string] , url = [string] , install_requires = [ [string] ] , package_dir = { [string] : [string] } , packages = [ [string] , [string] ] , entry_points = { [string] : [ [string] , [string] ] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Literal [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] __author__ = ( [string] , [string] ) [EOL] [EOL] def ByName ( name ) : [EOL] [docstring] [EOL] return globals ( ) [ name ] [EOL] [EOL] [EOL] [comment] [EOL] FILE_NOT_FOUND = - [number] [EOL] FILE_DOES_NOT_PARSE = - [number] [EOL] [EOL] [comment] [EOL] EXTRA_SPACE = [number] [EOL] MISSING_SPACE = [number] [EOL] EXTRA_LINE = [number] [EOL] MISSING_LINE = [number] [EOL] ILLEGAL_TAB = [number] [EOL] WRONG_INDENTATION = [number] [EOL] WRONG_BLANK_LINE_COUNT = [number] [EOL] [EOL] [comment] [EOL] MISSING_SEMICOLON = [number] [EOL] MISSING_SEMICOLON_AFTER_FUNCTION = [number] [EOL] ILLEGAL_SEMICOLON_AFTER_FUNCTION = [number] [EOL] REDUNDANT_SEMICOLON = [number] [EOL] [EOL] [comment] [EOL] ILLEGAL_PROTOTYPE_MEMBER_VALUE = [number] [EOL] LINE_TOO_LONG = [number] [EOL] LINE_STARTS_WITH_OPERATOR = [number] [EOL] COMMA_AT_END_OF_LITERAL = [number] [EOL] MULTI_LINE_STRING = [number] [EOL] UNNECESSARY_DOUBLE_QUOTED_STRING = [number] [EOL] [EOL] [comment] [EOL] GOOG_REQUIRES_NOT_ALPHABETIZED = [number] [EOL] GOOG_PROVIDES_NOT_ALPHABETIZED = [number] [EOL] MISSING_GOOG_REQUIRE = [number] [EOL] MISSING_GOOG_PROVIDE = [number] [EOL] EXTRA_GOOG_REQUIRE = [number] [EOL] [EOL] [comment] [EOL] INVALID_JSDOC_TAG = [number] [EOL] INVALID_USE_OF_DESC_TAG = [number] [EOL] NO_BUG_NUMBER_AFTER_BUG_TAG = [number] [EOL] MISSING_PARAMETER_DOCUMENTATION = [number] [EOL] EXTRA_PARAMETER_DOCUMENTATION = [number] [EOL] WRONG_PARAMETER_DOCUMENTATION = [number] [EOL] MISSING_JSDOC_TAG_TYPE = [number] [EOL] MISSING_JSDOC_TAG_DESCRIPTION = [number] [EOL] MISSING_JSDOC_PARAM_NAME = [number] [EOL] OUT_OF_ORDER_JSDOC_TAG_TYPE = [number] [EOL] MISSING_RETURN_DOCUMENTATION = [number] [EOL] UNNECESSARY_RETURN_DOCUMENTATION = [number] [EOL] MISSING_BRACES_AROUND_TYPE = [number] [EOL] MISSING_MEMBER_DOCUMENTATION = [number] [EOL] MISSING_PRIVATE = [number] [EOL] EXTRA_PRIVATE = [number] [EOL] INVALID_OVERRIDE_PRIVATE = [number] [EOL] INVALID_INHERIT_DOC_PRIVATE = [number] [EOL] MISSING_JSDOC_TAG_THIS = [number] [EOL] UNNECESSARY_BRACES_AROUND_INHERIT_DOC = [number] [EOL] INVALID_AUTHOR_TAG_DESCRIPTION = [number] [EOL] JSDOC_PREFER_QUESTION_TO_PIPE_NULL = [number] [EOL] JSDOC_ILLEGAL_QUESTION_WITH_PIPE = [number] [EOL] JSDOC_TAG_DESCRIPTION_ENDS_WITH_INVALID_CHARACTER = [number] [EOL] [comment] [EOL] INCORRECT_SUPPRESS_SYNTAX = [number] [EOL] INVALID_SUPPRESS_TYPE = [number] [EOL] UNNECESSARY_SUPPRESS = [number] [EOL] [EOL] [comment] [EOL] FILE_MISSING_NEWLINE = [number] [EOL] FILE_IN_BLOCK = [number] [EOL] [EOL] [comment] [EOL] INTERFACE_CONSTRUCTOR_CANNOT_HAVE_PARAMS = [number] [EOL] INTERFACE_METHOD_CANNOT_HAVE_CODE = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] FUNCTION_MISSING_RETURN_TYPE = [number] [EOL] PARAMETER_MISSING_TYPE = [number] [EOL] VAR_MISSING_TYPE = [number] [EOL] PARAMETER_MISSING_DEFAULT_VALUE = [number] [EOL] IMPORTS_NOT_ALPHABETIZED = [number] [EOL] IMPORT_CONTAINS_WILDCARD = [number] [EOL] UNUSED_IMPORT = [number] [EOL] INVALID_TRACE_SEVERITY_LEVEL = [number] [EOL] MISSING_TRACE_SEVERITY_LEVEL = [number] [EOL] MISSING_TRACE_MESSAGE = [number] [EOL] REMOVE_TRACE_BEFORE_SUBMIT = [number] [EOL] REMOVE_COMMENT_BEFORE_SUBMIT = [number] [EOL] [comment] [EOL] [EOL] NEW_ERRORS = frozenset ( [ WRONG_INDENTATION , MISSING_SEMICOLON , WRONG_BLANK_LINE_COUNT , EXTRA_GOOG_REQUIRE , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Literal , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] __author__ = ( [string] , [string] ) [EOL] [EOL] import copy [EOL] import re [EOL] [EOL] from closure_linter import javascripttokens [EOL] from closure_linter . common import matcher [EOL] from closure_linter . common import tokenizer [EOL] [EOL] [comment] [EOL] Type = javascripttokens . JavaScriptTokenType [EOL] Matcher = matcher . Matcher [EOL] [EOL] [EOL] class JavaScriptModes ( object ) : [EOL] [docstring] [EOL] TEXT_MODE = [string] [EOL] SINGLE_QUOTE_STRING_MODE = [string] [EOL] DOUBLE_QUOTE_STRING_MODE = [string] [EOL] BLOCK_COMMENT_MODE = [string] [EOL] DOC_COMMENT_MODE = [string] [EOL] DOC_COMMENT_LEX_SPACES_MODE = [string] [EOL] LINE_COMMENT_MODE = [string] [EOL] PARAMETER_MODE = [string] [EOL] FUNCTION_MODE = [string] [EOL] [EOL] [EOL] class JavaScriptTokenizer ( tokenizer . Tokenizer ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] IDENTIFIER_CHAR = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] MANTISSA = [string] [EOL] DECIMAL_LITERAL = [string] % MANTISSA [EOL] HEX_LITERAL = [string] [EOL] NUMBER = re . compile ( [string] % ( HEX_LITERAL , DECIMAL_LITERAL ) , re . VERBOSE ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] SINGLE_QUOTE = re . compile ( [string] ) [EOL] SINGLE_QUOTE_TEXT = re . compile ( [string] ) [EOL] DOUBLE_QUOTE = re . compile ( [string] ) [EOL] DOUBLE_QUOTE_TEXT = re . compile ( [string] ) [EOL] [EOL] START_SINGLE_LINE_COMMENT = re . compile ( [string] ) [EOL] END_OF_LINE_SINGLE_LINE_COMMENT = re . compile ( [string] ) [EOL] [EOL] START_DOC_COMMENT = re . compile ( [string] ) [EOL] START_BLOCK_COMMENT = re . compile ( [string] ) [EOL] END_BLOCK_COMMENT = re . compile ( [string] ) [EOL] BLOCK_COMMENT_TEXT = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] DOC_COMMENT_TEXT = re . compile ( [string] ) [EOL] DOC_COMMENT_NO_SPACES_TEXT = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] DOC_PREFIX = re . compile ( [string] ) [EOL] [EOL] START_BLOCK = re . compile ( [string] ) [EOL] END_BLOCK = re . compile ( [string] ) [EOL] [EOL] REGEX_CHARACTER_CLASS = [string] [EOL] [comment] [EOL] [comment] [EOL] POST_REGEX_LIST = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] REGEX = re . compile ( [string] % ( REGEX_CHARACTER_CLASS , [string] . join ( POST_REGEX_LIST ) ) , re . VERBOSE ) [EOL] [EOL] ANYTHING = re . compile ( [string] ) [EOL] PARAMETERS = re . compile ( [string] ) [EOL] CLOSING_PAREN_WITH_SPACE = re . compile ( [string] ) [EOL] [EOL] FUNCTION_DECLARATION = re . compile ( [string] ) [EOL] [EOL] OPENING_PAREN = re . compile ( [string] ) [EOL] CLOSING_PAREN = re . compile ( [string] ) [EOL] [EOL] OPENING_BRACKET = re . compile ( [string] ) [EOL] CLOSING_BRACKET = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] KEYWORD_LIST = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [comment] [EOL] [comment] [EOL] KEYWORD = re . compile ( [string] % ( [string] . join ( KEYWORD_LIST ) , IDENTIFIER_CHAR ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] OPERATOR_LIST = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] OPERATOR = re . compile ( [string] . join ( OPERATOR_LIST ) ) [EOL] [EOL] WHITESPACE = re . compile ( [string] ) [EOL] SEMICOLON = re . compile ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] NESTED_IDENTIFIER = [string] % IDENTIFIER_CHAR [EOL] IDENTIFIER = re . compile ( NESTED_IDENTIFIER ) [EOL] [EOL] SIMPLE_LVALUE = re . compile ( [string] % NESTED_IDENTIFIER , re . VERBOSE ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] DOC_FLAG = re . compile ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] DOC_FLAG_LEX_SPACES = re . compile ( [string] % [string] . join ( [ [string] ] ) ) [EOL] [EOL] DOC_INLINE_FLAG = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] SAFE_STAR = [string] [EOL] [EOL] COMMON_DOC_MATCHERS = [ Matcher ( END_BLOCK_COMMENT , Type . END_DOC_COMMENT , JavaScriptModes . TEXT_MODE ) , Matcher ( DOC_INLINE_FLAG , Type . DOC_INLINE_FLAG ) , Matcher ( DOC_FLAG_LEX_SPACES , Type . DOC_FLAG , JavaScriptModes . DOC_COMMENT_LEX_SPACES_MODE ) , Matcher ( DOC_FLAG , Type . DOC_FLAG ) , Matcher ( START_BLOCK , Type . DOC_START_BRACE ) , Matcher ( END_BLOCK , Type . DOC_END_BRACE ) , Matcher ( DOC_PREFIX , Type . DOC_PREFIX , None , True ) ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] JAVASCRIPT_MATCHERS = { JavaScriptModes . TEXT_MODE : [ Matcher ( START_DOC_COMMENT , Type . START_DOC_COMMENT , JavaScriptModes . DOC_COMMENT_MODE ) , Matcher ( START_BLOCK_COMMENT , Type . START_BLOCK_COMMENT , JavaScriptModes . BLOCK_COMMENT_MODE ) , Matcher ( END_OF_LINE_SINGLE_LINE_COMMENT , Type . START_SINGLE_LINE_COMMENT ) , Matcher ( START_SINGLE_LINE_COMMENT , Type . START_SINGLE_LINE_COMMENT , JavaScriptModes . LINE_COMMENT_MODE ) , Matcher ( SINGLE_QUOTE , Type . SINGLE_QUOTE_STRING_START , JavaScriptModes . SINGLE_QUOTE_STRING_MODE ) , Matcher ( DOUBLE_QUOTE , Type . DOUBLE_QUOTE_STRING_START , JavaScriptModes . DOUBLE_QUOTE_STRING_MODE ) , Matcher ( REGEX , Type . REGEX ) , Matcher ( START_BLOCK , Type . START_BLOCK ) , Matcher ( END_BLOCK , Type . END_BLOCK ) , Matcher ( FUNCTION_DECLARATION , Type . FUNCTION_DECLARATION , JavaScriptModes . FUNCTION_MODE ) , Matcher ( OPENING_PAREN , Type . START_PAREN ) , Matcher ( CLOSING_PAREN , Type . END_PAREN ) , Matcher ( OPENING_BRACKET , Type . START_BRACKET ) , Matcher ( CLOSING_BRACKET , Type . END_BRACKET ) , Matcher ( NUMBER , Type . NUMBER ) , Matcher ( SIMPLE_LVALUE , Type . SIMPLE_LVALUE ) , Matcher ( OPERATOR , Type . OPERATOR ) , Matcher ( KEYWORD , Type . KEYWORD ) , Matcher ( WHITESPACE , Type . WHITESPACE ) , Matcher ( IDENTIFIER , Type . IDENTIFIER ) , Matcher ( SEMICOLON , Type . SEMICOLON ) ] , JavaScriptModes . SINGLE_QUOTE_STRING_MODE : [ Matcher ( SINGLE_QUOTE_TEXT , Type . STRING_TEXT ) , Matcher ( SINGLE_QUOTE , Type . SINGLE_QUOTE_STRING_END , JavaScriptModes . TEXT_MODE ) ] , JavaScriptModes . DOUBLE_QUOTE_STRING_MODE : [ Matcher ( DOUBLE_QUOTE_TEXT , Type . STRING_TEXT ) , Matcher ( DOUBLE_QUOTE , Type . DOUBLE_QUOTE_STRING_END , JavaScriptModes . TEXT_MODE ) ] , JavaScriptModes . BLOCK_COMMENT_MODE : [ Matcher ( END_BLOCK_COMMENT , Type . END_BLOCK_COMMENT , JavaScriptModes . TEXT_MODE ) , Matcher ( BLOCK_COMMENT_TEXT , Type . COMMENT ) ] , JavaScriptModes . DOC_COMMENT_MODE : COMMON_DOC_MATCHERS + [ Matcher ( DOC_COMMENT_TEXT , Type . COMMENT ) ] , JavaScriptModes . DOC_COMMENT_LEX_SPACES_MODE : COMMON_DOC_MATCHERS + [ Matcher ( WHITESPACE , Type . COMMENT ) , Matcher ( DOC_COMMENT_NO_SPACES_TEXT , Type . COMMENT ) ] , JavaScriptModes . LINE_COMMENT_MODE : [ Matcher ( ANYTHING , Type . COMMENT , JavaScriptModes . TEXT_MODE ) ] , JavaScriptModes . FUNCTION_MODE : [ Matcher ( OPENING_PAREN , Type . START_PARAMETERS , JavaScriptModes . PARAMETER_MODE ) , Matcher ( WHITESPACE , Type . WHITESPACE ) , Matcher ( IDENTIFIER , Type . FUNCTION_NAME ) ] , JavaScriptModes . PARAMETER_MODE : [ Matcher ( CLOSING_PAREN_WITH_SPACE , Type . END_PARAMETERS , JavaScriptModes . TEXT_MODE ) , Matcher ( PARAMETERS , Type . PARAMETERS , JavaScriptModes . PARAMETER_MODE ) ] } [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] JAVASCRIPT_DEFAULT_TYPES = { JavaScriptModes . DOC_COMMENT_MODE : Type . COMMENT , JavaScriptModes . DOC_COMMENT_LEX_SPACES_MODE : Type . COMMENT } [EOL] [EOL] def __init__ ( self , parse_js_doc = True ) : [EOL] [docstring] [EOL] matchers = self . JAVASCRIPT_MATCHERS [EOL] if not parse_js_doc : [EOL] [comment] [EOL] matchers = copy . deepcopy ( matchers ) [EOL] matchers [ JavaScriptModes . DOC_COMMENT_MODE ] = matchers [ JavaScriptModes . BLOCK_COMMENT_MODE ] [EOL] [EOL] tokenizer . Tokenizer . __init__ ( self , JavaScriptModes . TEXT_MODE , matchers , self . JAVASCRIPT_DEFAULT_TYPES ) [EOL] [EOL] def _CreateToken ( self , string , token_type , line , line_number , values = None ) : [EOL] [docstring] [EOL] return javascripttokens . JavaScriptToken ( string , token_type , line , line_number , values ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Literal , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] __author__ = ( [string] , [string] ) [EOL] [EOL] from closure_linter . common import tokens [EOL] [EOL] class JavaScriptTokenType ( tokens . TokenType ) : [EOL] [docstring] [EOL] NUMBER = [string] [EOL] START_SINGLE_LINE_COMMENT = [string] [EOL] START_BLOCK_COMMENT = [string] [EOL] START_DOC_COMMENT = [string] [EOL] END_BLOCK_COMMENT = [string] [EOL] END_DOC_COMMENT = [string] [EOL] COMMENT = [string] [EOL] SINGLE_QUOTE_STRING_START = [string] [EOL] SINGLE_QUOTE_STRING_END = [string] [EOL] DOUBLE_QUOTE_STRING_START = [string] [EOL] DOUBLE_QUOTE_STRING_END = [string] [EOL] STRING_TEXT = [string] [EOL] START_BLOCK = [string] [EOL] END_BLOCK = [string] [EOL] START_PAREN = [string] [EOL] END_PAREN = [string] [EOL] START_BRACKET = [string] [EOL] END_BRACKET = [string] [EOL] REGEX = [string] [EOL] FUNCTION_DECLARATION = [string] [EOL] FUNCTION_NAME = [string] [EOL] START_PARAMETERS = [string] [EOL] PARAMETERS = [string] [EOL] END_PARAMETERS = [string] [EOL] SEMICOLON = [string] [EOL] DOC_FLAG = [string] [EOL] DOC_INLINE_FLAG = [string] [EOL] DOC_START_BRACE = [string] [EOL] DOC_END_BRACE = [string] [EOL] DOC_PREFIX = [string] [EOL] SIMPLE_LVALUE = [string] [EOL] KEYWORD = [string] [EOL] OPERATOR = [string] [EOL] IDENTIFIER = [string] [EOL] [EOL] STRING_TYPES = frozenset ( [ SINGLE_QUOTE_STRING_START , SINGLE_QUOTE_STRING_END , DOUBLE_QUOTE_STRING_START , DOUBLE_QUOTE_STRING_END , STRING_TEXT ] ) [EOL] [EOL] COMMENT_TYPES = frozenset ( [ START_SINGLE_LINE_COMMENT , COMMENT , START_BLOCK_COMMENT , START_DOC_COMMENT , END_BLOCK_COMMENT , END_DOC_COMMENT , DOC_START_BRACE , DOC_END_BRACE , DOC_FLAG , DOC_INLINE_FLAG , DOC_PREFIX ] ) [EOL] [EOL] FLAG_DESCRIPTION_TYPES = frozenset ( [ DOC_INLINE_FLAG , COMMENT , DOC_START_BRACE , DOC_END_BRACE ] ) [EOL] [EOL] FLAG_ENDING_TYPES = frozenset ( [ DOC_FLAG , END_DOC_COMMENT ] ) [EOL] [EOL] NON_CODE_TYPES = COMMENT_TYPES | frozenset ( [ tokens . TokenType . WHITESPACE , tokens . TokenType . BLANK_LINE ] ) [EOL] [EOL] UNARY_OPERATORS = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] UNARY_OK_OPERATORS = [ [string] , [string] , [string] , [string] ] + UNARY_OPERATORS [EOL] [EOL] UNARY_POST_OPERATORS = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] EXPRESSION_ENDER_TYPES = [ tokens . TokenType . NORMAL , IDENTIFIER , NUMBER , SIMPLE_LVALUE , END_BRACKET , END_PAREN , END_BLOCK , SINGLE_QUOTE_STRING_END , DOUBLE_QUOTE_STRING_END ] [EOL] [EOL] [EOL] class JavaScriptToken ( tokens . Token ) : [EOL] [docstring] [EOL] [EOL] def IsKeyword ( self , keyword ) : [EOL] [docstring] [EOL] return self . type == JavaScriptTokenType . KEYWORD and self . string == keyword [EOL] [EOL] def IsOperator ( self , operator ) : [EOL] [docstring] [EOL] return self . type == JavaScriptTokenType . OPERATOR and self . string == operator [EOL] [EOL] def IsAssignment ( self ) : [EOL] [docstring] [EOL] return ( self . type == JavaScriptTokenType . OPERATOR and self . string . endswith ( [string] ) and self . string not in ( [string] , [string] , [string] , [string] , [string] , [string] ) ) [EOL] [EOL] def IsComment ( self ) : [EOL] [docstring] [EOL] return self . type in JavaScriptTokenType . COMMENT_TYPES [EOL] [EOL] def IsCode ( self ) : [EOL] [docstring] [EOL] return self . type not in JavaScriptTokenType . NON_CODE_TYPES [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . line_number , self . type , self . string , self . values , self . metadata ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Tuple , Literal [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] __author__ = ( [string] , [string] ) [EOL] [EOL] [EOL] class TokenType ( object ) : [EOL] [docstring] [EOL] NORMAL = [string] [EOL] WHITESPACE = [string] [EOL] BLANK_LINE = [string] [EOL] [EOL] [EOL] class Token ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , string , token_type , line , line_number , values = None ) : [EOL] [docstring] [EOL] self . type = token_type [EOL] self . string = string [EOL] self . length = len ( string ) [EOL] self . line = line [EOL] self . line_number = line_number [EOL] self . values = values [EOL] [EOL] [comment] [EOL] self . previous = None [EOL] self . next = None [EOL] self . start_index = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . attached_object = None [EOL] [EOL] [comment] [EOL] self . metadata = None [EOL] [EOL] def IsFirstInLine ( self ) : [EOL] [docstring] [EOL] return not self . previous or self . previous . line_number != self . line_number [EOL] [EOL] def IsLastInLine ( self ) : [EOL] [docstring] [EOL] return not self . next or self . next . line_number != self . line_number [EOL] [EOL] def IsType ( self , token_type ) : [EOL] [docstring] [EOL] return self . type == token_type [EOL] [EOL] def IsAnyType ( self , * token_types ) : [EOL] [docstring] [EOL] if not isinstance ( token_types [ [number] ] , basestring ) : [EOL] return self . type in token_types [ [number] ] [EOL] else : [EOL] return self . type in token_types [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . type , self . string , self . values , self . line_number , self . metadata ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Tuple , Literal , Any [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] __author__ = ( [string] , [string] ) [EOL] [EOL] [EOL] class Error ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , code , message , token , position , fix_data ) : [EOL] [docstring] [EOL] self . code = code [EOL] self . message = message [EOL] self . token = token [EOL] self . position = position [EOL] if token : [EOL] self . start_index = token . start_index [EOL] else : [EOL] self . start_index = [number] [EOL] self . fix_data = fix_data [EOL] if self . position : [EOL] self . start_index += self . position . start [EOL] [EOL] def Compare ( a , b ) : [EOL] [docstring] [EOL] line_diff = a . token . line_number - b . token . line_number [EOL] if line_diff : [EOL] return line_diff [EOL] [EOL] return a . start_index - b . start_index [EOL] Compare = staticmethod ( Compare ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.staticmethod$ 0 0 0 $builtins.staticmethod$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Literal [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] __author__ = ( [string] , [string] ) [EOL] [EOL] [EOL] class LintRunner ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] if self . __class__ == LintRunner : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def Run ( self , filenames , error_handler ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Literal [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] __author__ = ( [string] , [string] ) [EOL] [EOL] [EOL] from closure_linter . common import errorhandler [EOL] [EOL] [EOL] class ErrorAccumulator ( errorhandler . ErrorHandler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _errors = [ ] [EOL] [EOL] def HandleError ( self , error ) : [EOL] [docstring] [EOL] self . _errors . append ( ( error . token . line_number , error . code ) ) [EOL] [EOL] def GetErrors ( self ) : [EOL] [docstring] [EOL] return self . _errors [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Literal [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] __author__ = ( [string] , [string] ) [EOL] [EOL] from closure_linter . common import position [EOL] from closure_linter . common import tokens [EOL] [EOL] [comment] [EOL] Token = tokens . Token [EOL] Position = position . Position [EOL] [EOL] [EOL] class Matcher ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , regex , token_type , result_mode = None , line_start = False ) : [EOL] [docstring] [EOL] self . regex = regex [EOL] self . type = token_type [EOL] self . result_mode = result_mode [EOL] self . line_start = line_start [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Literal [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] __author__ = ( [string] , [string] ) [EOL] [EOL] [EOL] class ErrorHandler ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] if self . __class__ == ErrorHandler : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def HandleFile ( self , filename , first_token ) : [EOL] [docstring] [EOL] [EOL] def HandleError ( self , error ) : [EOL] [docstring] [EOL] [EOL] def FinishFile ( self ) : [EOL] [docstring] [EOL] [EOL] def GetErrors ( self ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import gyp . generator . ninja as ninja [EOL] import unittest [EOL] import StringIO [EOL] import sys [EOL] import TestCommon [EOL] [EOL] [EOL] class TestPrefixesAndSuffixes ( unittest . TestCase ) : [EOL] def test_BinaryNamesWindows ( self ) : [EOL] writer = ninja . NinjaWriter ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] spec = { [string] : [string] } [EOL] self . assertTrue ( writer . ComputeOutputFileName ( spec , [string] ) . endswith ( [string] ) ) [EOL] self . assertTrue ( writer . ComputeOutputFileName ( spec , [string] ) . endswith ( [string] ) ) [EOL] self . assertTrue ( writer . ComputeOutputFileName ( spec , [string] ) . endswith ( [string] ) ) [EOL] [EOL] def test_BinaryNamesLinux ( self ) : [EOL] writer = ninja . NinjaWriter ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] spec = { [string] : [string] } [EOL] self . assertTrue ( [string] not in writer . ComputeOutputFileName ( spec , [string] ) ) [EOL] self . assertTrue ( writer . ComputeOutputFileName ( spec , [string] ) . startswith ( [string] ) ) [EOL] self . assertTrue ( writer . ComputeOutputFileName ( spec , [string] ) . startswith ( [string] ) ) [EOL] self . assertTrue ( writer . ComputeOutputFileName ( spec , [string] ) . endswith ( [string] ) ) [EOL] self . assertTrue ( writer . ComputeOutputFileName ( spec , [string] ) . endswith ( [string] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Callable , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] import code [EOL] import sys [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] _generator_identity_variables = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] generator_default_variables = { } [EOL] [EOL] for v in _generator_identity_variables : [EOL] generator_default_variables [ v ] = [string] % v [EOL] [EOL] [EOL] def GenerateOutput ( target_list , target_dicts , data , params ) : [EOL] locals = { [string] : target_list , [string] : target_dicts , [string] : data , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] banner = [string] % ( sys . version , sys . platform , repr ( sorted ( locals . keys ( ) ) ) ) [EOL] [EOL] code . interact ( banner , local = locals ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] import subprocess [EOL] import sys [EOL] [EOL] sys . exit ( subprocess . call ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Literal , Any , Union [EOL] import typing [EOL] import subprocess [EOL] import typing_extensions [EOL] import io [EOL] import os [EOL] from os . path import join , dirname , abspath [EOL] import subprocess [EOL] import sys [EOL] import tempfile [EOL] [EOL] def Check ( output , errors ) : [EOL] failed = any ( [ s . startswith ( [string] ) or s . startswith ( [string] ) for s in output . split ( [string] ) ] ) [EOL] return [number] if failed else [number] [EOL] [EOL] def Execute ( cmdline ) : [EOL] ( fd_out , outname ) = tempfile . mkstemp ( ) [EOL] ( fd_err , errname ) = tempfile . mkstemp ( ) [EOL] process = subprocess . Popen ( args = cmdline , shell = True , stdout = fd_out , stderr = fd_err , ) [EOL] exit_code = process . wait ( ) [EOL] os . close ( fd_out ) [EOL] os . close ( fd_err ) [EOL] output = file ( outname ) . read ( ) [EOL] errors = file ( errname ) . read ( ) [EOL] os . unlink ( outname ) [EOL] os . unlink ( errname ) [EOL] sys . stdout . write ( output ) [EOL] sys . stderr . write ( errors ) [EOL] return exit_code or Check ( output , errors ) [EOL] [EOL] def Escape ( arg ) : [EOL] def ShouldEscape ( ) : [EOL] for x in arg : [EOL] if not x . isalnum ( ) and x != [string] and x != [string] : [EOL] return True [EOL] return False [EOL] [EOL] return arg if not ShouldEscape ( ) else [string] % ( arg . replace ( [string] , [string] ) ) [EOL] [EOL] def WriteToTemporaryFile ( data ) : [EOL] ( fd , fname ) = tempfile . mkstemp ( ) [EOL] os . close ( fd ) [EOL] tmp_file = open ( fname , [string] ) [EOL] tmp_file . write ( data ) [EOL] tmp_file . close ( ) [EOL] return fname [EOL] [EOL] def Main ( ) : [EOL] if ( len ( sys . argv ) == [number] ) : [EOL] print ( [string] % sys . argv [ [number] ] ) [EOL] return [number] [EOL] workspace = abspath ( join ( dirname ( sys . argv [ [number] ] ) , [string] ) ) [EOL] android_workspace = os . getenv ( [string] , [string] ) [EOL] args = [ Escape ( arg ) for arg in sys . argv [ [number] : ] ] [EOL] script = ( [string] . join ( args ) + [string] [string] [string] [string] [string] ) [EOL] script = script . replace ( workspace , android_workspace ) [EOL] script_file = WriteToTemporaryFile ( script ) [EOL] android_script_file = android_workspace + [string] + script_file [EOL] command = ( [string] % ( script_file , android_script_file ) + [string] % android_script_file + [string] % android_script_file ) [EOL] error_code = Execute ( command ) [EOL] os . unlink ( script_file ) [EOL] return error_code [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( Main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Pattern , Dict [EOL] import typing [EOL] import subprocess [EOL] import os [EOL] import re [EOL] import subprocess [EOL] import tempfile [EOL] [EOL] [EOL] [comment] [EOL] OBJDUMP_BIN = [string] [EOL] if not os . path . exists ( OBJDUMP_BIN ) : [EOL] OBJDUMP_BIN = [string] [EOL] [EOL] [EOL] _COMMON_DISASM_OPTIONS = [ [string] , [string] , [string] ] [EOL] [EOL] _DISASM_HEADER_RE = re . compile ( [string] ) [EOL] _DISASM_LINE_RE = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] _ARCH_MAP = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def GetDisasmLines ( filename , offset , size , arch , inplace , arch_flags = [string] ) : [EOL] tmp_name = None [EOL] if not inplace : [EOL] [comment] [EOL] assert arch in _ARCH_MAP , [string] % arch [EOL] arch_flags = arch_flags + [string] + _ARCH_MAP [ arch ] [EOL] tmp_name = tempfile . mktemp ( [string] ) [EOL] command = [string] [string] % ( filename , tmp_name , size , offset , OBJDUMP_BIN , [string] . join ( _COMMON_DISASM_OPTIONS ) , arch_flags , tmp_name ) [EOL] else : [EOL] command = [string] % ( OBJDUMP_BIN , [string] . join ( _COMMON_DISASM_OPTIONS ) , arch_flags , offset , offset + size , filename ) [EOL] process = subprocess . Popen ( command , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) [EOL] out , err = process . communicate ( ) [EOL] lines = out . split ( [string] ) [EOL] header_line = [number] [EOL] for i , line in enumerate ( lines ) : [EOL] if _DISASM_HEADER_RE . match ( line ) : [EOL] header_line = i [EOL] break [EOL] if tmp_name : [EOL] os . unlink ( tmp_name ) [EOL] split_lines = [ ] [EOL] for line in lines [ header_line + [number] : ] : [EOL] match = _DISASM_LINE_RE . match ( line ) [EOL] if match : [EOL] line_address = int ( match . group ( [number] ) , [number] ) [EOL] split_lines . append ( ( line_address , match . group ( [number] ) ) ) [EOL] return split_lines [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from typing import Tuple , Dict [EOL] import typing [EOL] INSTANCE_TYPES = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , } [EOL] [EOL] [comment] [EOL] KNOWN_MAPS = { [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , [number] : ( [number] , [string] ) , } [EOL] [EOL] [comment] [EOL] KNOWN_OBJECTS = { ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , ( [string] , [number] ) : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Tuple[builtins.str,builtins.int],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Optional , Any , Match [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] [EOL] [EOL] class JavaScriptMinifier ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . seen_identifiers = { [string] : True , [string] : True } [EOL] self . identifier_counter = [number] [EOL] self . in_comment = False [EOL] self . map = { } [EOL] self . nesting = [number] [EOL] [EOL] def LookAtIdentifier ( self , m ) : [EOL] [docstring] [EOL] identifier = m . group ( [number] ) [EOL] self . seen_identifiers [ identifier ] = True [EOL] [EOL] def Push ( self ) : [EOL] [docstring] [EOL] self . nesting += [number] [EOL] [EOL] def Pop ( self ) : [EOL] [docstring] [EOL] self . nesting -= [number] [EOL] [comment] [EOL] [comment] [EOL] if self . nesting == [number] : [EOL] self . map = { } [EOL] self . identifier_counter = [number] [EOL] [EOL] def Declaration ( self , m ) : [EOL] [docstring] [EOL] matched_text = m . group ( [number] ) [EOL] if matched_text == [string] : [EOL] self . Push ( ) [EOL] return matched_text [EOL] if matched_text == [string] : [EOL] self . Pop ( ) [EOL] return matched_text [EOL] if re . match ( [string] , matched_text ) : [EOL] return matched_text [EOL] m = re . match ( [string] , matched_text ) [EOL] if m : [EOL] var_names = matched_text [ m . end ( ) : ] [EOL] var_names = re . split ( [string] , var_names ) [EOL] return [string] + [string] . join ( map ( self . FindNewName , var_names ) ) [EOL] m = re . match ( [string] , matched_text ) [EOL] if m : [EOL] up_to_args = m . group ( [number] ) [EOL] args = m . group ( [number] ) [EOL] args = re . split ( [string] , args ) [EOL] self . Push ( ) [EOL] return up_to_args + [string] + [string] . join ( map ( self . FindNewName , args ) ) + [string] [EOL] [EOL] if matched_text in self . map : [EOL] return self . map [ matched_text ] [EOL] [EOL] return matched_text [EOL] [EOL] def CharFromNumber ( self , number ) : [EOL] [docstring] [EOL] if number < [number] : [EOL] return chr ( number + [number] ) [EOL] number -= [number] [EOL] return chr ( number + [number] ) [EOL] [EOL] def FindNewName ( self , var_name ) : [EOL] [docstring] [EOL] new_identifier = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if var_name in self . map : [EOL] return self . map [ var_name ] [EOL] if self . nesting == [number] : [EOL] return var_name [EOL] while True : [EOL] identifier_first_char = self . identifier_counter % [number] [EOL] identifier_second_char = self . identifier_counter // [number] [EOL] new_identifier = self . CharFromNumber ( identifier_first_char ) [EOL] if identifier_second_char != [number] : [EOL] new_identifier = ( self . CharFromNumber ( identifier_second_char - [number] ) + new_identifier ) [EOL] self . identifier_counter += [number] [EOL] if not new_identifier in self . seen_identifiers : [EOL] break [EOL] [EOL] self . map [ var_name ] = new_identifier [EOL] return new_identifier [EOL] [EOL] def RemoveSpaces ( self , m ) : [EOL] [docstring] [EOL] entire_match = m . group ( [number] ) [EOL] replacement = m . group ( [number] ) [EOL] if re . match ( [string] , entire_match ) : [EOL] return entire_match [EOL] if re . match ( [string] , entire_match ) : [EOL] return entire_match [EOL] if re . match ( [string] , entire_match ) : [EOL] return entire_match [EOL] return replacement [EOL] [EOL] def JSMinify ( self , text ) : [EOL] [docstring] [EOL] new_lines = [ ] [EOL] for line in re . split ( [string] , text ) : [EOL] line = line . replace ( [string] , [string] ) [EOL] if self . in_comment : [EOL] m = re . search ( [string] , line ) [EOL] if m : [EOL] line = line [ m . end ( ) : ] [EOL] self . in_comment = False [EOL] else : [EOL] new_lines . append ( [string] ) [EOL] continue [EOL] [EOL] if not self . in_comment : [EOL] line = re . sub ( [string] , [string] , line ) [EOL] line = re . sub ( [string] , [string] , line ) [EOL] m = re . search ( [string] , line ) [EOL] if m : [EOL] line = line [ : m . start ( ) ] [EOL] self . in_comment = True [EOL] [EOL] [comment] [EOL] line = re . sub ( [string] , [string] , line ) [EOL] line = re . sub ( [string] , [string] , line ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] double_quoted_string = [string] [EOL] [comment] [EOL] single_quoted_string = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] slash_quoted_regexp = [string] [EOL] [comment] [EOL] line = re . sub ( [string] . join ( [ double_quoted_string , single_quoted_string , slash_quoted_regexp , [string] ] ) , self . RemoveSpaces , line ) [EOL] [comment] [EOL] [comment] [EOL] line = re . sub ( [string] . join ( [ double_quoted_string , single_quoted_string , slash_quoted_regexp , [string] ] ) , self . RemoveSpaces , line ) [EOL] [comment] [EOL] if self . nesting == [number] : [EOL] re . sub ( [string] , self . LookAtIdentifier , line ) [EOL] function_declaration_regexp = ( [string] [string] [string] ) [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if re . search ( [string] , line ) : [EOL] block_trailing_colon = [string] [EOL] else : [EOL] block_trailing_colon = [string] [EOL] [comment] [EOL] variable_use_regexp = [string] + block_trailing_colon [EOL] line = re . sub ( [string] . join ( [ double_quoted_string , single_quoted_string , slash_quoted_regexp , [string] , [string] , [string] , function_declaration_regexp , variable_use_regexp ] ) , self . Declaration , line ) [EOL] new_lines . append ( line ) [EOL] [EOL] return [string] . join ( new_lines ) + [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Dict , List , Any , Iterator , Callable [EOL] import typing [EOL] import optparse [EOL] import io [EOL] import os , re , sys , string [EOL] import optparse [EOL] import jsmin [EOL] import bz2 [EOL] import textwrap [EOL] [EOL] [EOL] class Error ( Exception ) : [EOL] def __init__ ( self , msg ) : [EOL] Exception . __init__ ( self , msg ) [EOL] [EOL] [EOL] def ToCArray ( byte_sequence ) : [EOL] result = [ ] [EOL] for chr in byte_sequence : [EOL] result . append ( str ( ord ( chr ) ) ) [EOL] joined = [string] . join ( result ) [EOL] return textwrap . fill ( joined , [number] ) [EOL] [EOL] [EOL] def RemoveCommentsAndTrailingWhitespace ( lines ) : [EOL] lines = re . sub ( [string] , [string] , lines ) [comment] [EOL] lines = re . sub ( re . compile ( [string] , re . DOTALL ) , [string] , lines ) [comment] [EOL] lines = re . sub ( [string] , [string] , lines ) [comment] [EOL] return lines [EOL] [EOL] [EOL] def ReadFile ( filename ) : [EOL] file = open ( filename , [string] ) [EOL] try : [EOL] lines = file . read ( ) [EOL] finally : [EOL] file . close ( ) [EOL] return lines [EOL] [EOL] [EOL] EVAL_PATTERN = re . compile ( [string] ) [EOL] WITH_PATTERN = re . compile ( [string] ) [EOL] [EOL] def Validate ( lines ) : [EOL] [comment] [EOL] [comment] [EOL] if EVAL_PATTERN . search ( lines ) : [EOL] raise Error ( [string] ) [EOL] if WITH_PATTERN . search ( lines ) : [EOL] raise Error ( [string] ) [EOL] [EOL] [comment] [EOL] return lines [EOL] [EOL] [EOL] def ExpandConstants ( lines , constants ) : [EOL] for key , value in constants : [EOL] lines = key . sub ( str ( value ) , lines ) [EOL] return lines [EOL] [EOL] [EOL] def ExpandMacroDefinition ( lines , pos , name_pattern , macro , expander ) : [EOL] pattern_match = name_pattern . search ( lines , pos ) [EOL] while pattern_match is not None : [EOL] [comment] [EOL] height = [number] [EOL] start = pattern_match . start ( ) [EOL] end = pattern_match . end ( ) [EOL] assert lines [ end - [number] ] == [string] [EOL] last_match = end [EOL] arg_index = [ [number] ] [comment] [EOL] mapping = { } [EOL] def add_arg ( str ) : [EOL] [comment] [EOL] replacement = expander ( str . strip ( ) ) [EOL] mapping [ macro . args [ arg_index [ [number] ] ] ] = replacement [EOL] arg_index [ [number] ] += [number] [EOL] while end < len ( lines ) and height > [number] : [EOL] [comment] [EOL] if lines [ end ] == [string] and height == [number] : [EOL] add_arg ( lines [ last_match : end ] ) [EOL] last_match = end + [number] [EOL] elif lines [ end ] in [ [string] , [string] , [string] ] : [EOL] height = height + [number] [EOL] elif lines [ end ] in [ [string] , [string] , [string] ] : [EOL] height = height - [number] [EOL] end = end + [number] [EOL] [comment] [EOL] add_arg ( lines [ last_match : end - [number] ] ) [EOL] result = macro . expand ( mapping ) [EOL] [comment] [EOL] lines = lines [ : start ] + result + lines [ end : ] [EOL] pattern_match = name_pattern . search ( lines , start + len ( result ) ) [EOL] return lines [EOL] [EOL] def ExpandMacros ( lines , macros ) : [EOL] [comment] [EOL] [comment] [EOL] for name_pattern , macro in reversed ( macros ) : [EOL] def expander ( s ) : [EOL] return ExpandMacros ( s , macros ) [EOL] lines = ExpandMacroDefinition ( lines , [number] , name_pattern , macro , expander ) [EOL] return lines [EOL] [EOL] class TextMacro : [EOL] def __init__ ( self , args , body ) : [EOL] self . args = args [EOL] self . body = body [EOL] def expand ( self , mapping ) : [EOL] result = self . body [EOL] for key , value in mapping . items ( ) : [EOL] result = result . replace ( key , value ) [EOL] return result [EOL] [EOL] class PythonMacro : [EOL] def __init__ ( self , args , fun ) : [EOL] self . args = args [EOL] self . fun = fun [EOL] def expand ( self , mapping ) : [EOL] args = [ ] [EOL] for arg in self . args : [EOL] args . append ( mapping [ arg ] ) [EOL] return str ( self . fun ( * args ) ) [EOL] [EOL] CONST_PATTERN = re . compile ( [string] ) [EOL] MACRO_PATTERN = re . compile ( [string] ) [EOL] PYTHON_MACRO_PATTERN = re . compile ( [string] ) [EOL] [EOL] [EOL] def ReadMacros ( lines ) : [EOL] constants = [ ] [EOL] macros = [ ] [EOL] for line in lines . split ( [string] ) : [EOL] hash = line . find ( [string] ) [EOL] if hash != - [number] : line = line [ : hash ] [EOL] line = line . strip ( ) [EOL] if len ( line ) is [number] : continue [EOL] const_match = CONST_PATTERN . match ( line ) [EOL] if const_match : [EOL] name = const_match . group ( [number] ) [EOL] value = const_match . group ( [number] ) . strip ( ) [EOL] constants . append ( ( re . compile ( [string] % name ) , value ) ) [EOL] else : [EOL] macro_match = MACRO_PATTERN . match ( line ) [EOL] if macro_match : [EOL] name = macro_match . group ( [number] ) [EOL] args = [ match . strip ( ) for match in macro_match . group ( [number] ) . split ( [string] ) ] [EOL] body = macro_match . group ( [number] ) . strip ( ) [EOL] macros . append ( ( re . compile ( [string] % name ) , TextMacro ( args , body ) ) ) [EOL] else : [EOL] python_match = PYTHON_MACRO_PATTERN . match ( line ) [EOL] if python_match : [EOL] name = python_match . group ( [number] ) [EOL] args = [ match . strip ( ) for match in python_match . group ( [number] ) . split ( [string] ) ] [EOL] body = python_match . group ( [number] ) . strip ( ) [EOL] fun = eval ( [string] + [string] . join ( args ) + [string] + body ) [EOL] macros . append ( ( re . compile ( [string] % name ) , PythonMacro ( args , fun ) ) ) [EOL] else : [EOL] raise Error ( [string] + line ) [EOL] return ( constants , macros ) [EOL] [EOL] INLINE_MACRO_PATTERN = re . compile ( [string] ) [EOL] INLINE_MACRO_END_PATTERN = re . compile ( [string] ) [EOL] [EOL] def ExpandInlineMacros ( lines ) : [EOL] pos = [number] [EOL] while True : [EOL] macro_match = INLINE_MACRO_PATTERN . search ( lines , pos ) [EOL] if macro_match is None : [EOL] [comment] [EOL] return lines [EOL] name = macro_match . group ( [number] ) [EOL] args = [ match . strip ( ) for match in macro_match . group ( [number] ) . split ( [string] ) ] [EOL] end_macro_match = INLINE_MACRO_END_PATTERN . search ( lines , macro_match . end ( ) ) [EOL] if end_macro_match is None : [EOL] raise Error ( [string] % name ) [EOL] body = lines [ macro_match . end ( ) : end_macro_match . start ( ) ] [EOL] [EOL] [comment] [EOL] lines = lines [ : macro_match . start ( ) ] + lines [ end_macro_match . end ( ) : ] [EOL] name_pattern = re . compile ( [string] % name ) [EOL] macro = TextMacro ( args , body ) [EOL] [EOL] [comment] [EOL] pos = macro_match . start ( ) [EOL] [EOL] def non_expander ( s ) : [EOL] return s [EOL] lines = ExpandMacroDefinition ( lines , pos , name_pattern , macro , non_expander ) [EOL] [EOL] [EOL] INLINE_CONSTANT_PATTERN = re . compile ( [string] ) [EOL] [EOL] def ExpandInlineConstants ( lines ) : [EOL] pos = [number] [EOL] while True : [EOL] const_match = INLINE_CONSTANT_PATTERN . search ( lines , pos ) [EOL] if const_match is None : [EOL] [comment] [EOL] return lines [EOL] name = const_match . group ( [number] ) [EOL] replacement = const_match . group ( [number] ) [EOL] name_pattern = re . compile ( [string] % name ) [EOL] [EOL] [comment] [EOL] lines = ( lines [ : const_match . start ( ) ] + re . sub ( name_pattern , replacement , lines [ const_match . end ( ) : ] ) ) [EOL] [EOL] [comment] [EOL] pos = const_match . start ( ) [EOL] [EOL] [EOL] HEADER_TEMPLATE = [string] [EOL] [EOL] SOURCES_DECLARATION = [string] [EOL] [EOL] [EOL] RAW_SOURCES_COMPRESSION_DECLARATION = [string] [EOL] [EOL] [EOL] RAW_SOURCES_DECLARATION = [string] [EOL] [EOL] [EOL] GET_INDEX_CASE = [string] [EOL] [EOL] [EOL] GET_RAW_SCRIPT_SOURCE_CASE = [string] [EOL] [EOL] [EOL] GET_SCRIPT_NAME_CASE = [string] [EOL] [EOL] [EOL] def BuildFilterChain ( macro_filename ) : [EOL] [docstring] [EOL] filter_chain = [ ReadFile ] [EOL] [EOL] if macro_filename : [EOL] ( consts , macros ) = ReadMacros ( ReadFile ( macro_filename ) ) [EOL] filter_chain . append ( lambda l : ExpandConstants ( l , consts ) ) [EOL] filter_chain . append ( lambda l : ExpandMacros ( l , macros ) ) [EOL] [EOL] filter_chain . extend ( [ RemoveCommentsAndTrailingWhitespace , ExpandInlineMacros , ExpandInlineConstants , Validate , jsmin . JavaScriptMinifier ( ) . JSMinify ] ) [EOL] [EOL] def chain ( f1 , f2 ) : [EOL] return lambda x : f2 ( f1 ( x ) ) [EOL] [EOL] return reduce ( chain , filter_chain ) [EOL] [EOL] [EOL] class Sources : [EOL] def __init__ ( self ) : [EOL] self . names = [ ] [EOL] self . modules = [ ] [EOL] self . is_debugger_id = [ ] [EOL] [EOL] [EOL] def IsDebuggerFile ( filename ) : [EOL] return filename . endswith ( [string] ) [EOL] [EOL] def IsMacroFile ( filename ) : [EOL] return filename . endswith ( [string] ) [EOL] [EOL] [EOL] def PrepareSources ( source_files ) : [EOL] [docstring] [EOL] macro_file = None [EOL] macro_files = filter ( IsMacroFile , source_files ) [EOL] assert len ( macro_files ) in [ [number] , [number] ] [EOL] if macro_files : [EOL] source_files . remove ( macro_files [ [number] ] ) [EOL] macro_file = macro_files [ [number] ] [EOL] [EOL] filters = BuildFilterChain ( macro_file ) [EOL] [EOL] [comment] [EOL] source_files = sorted ( source_files , lambda l , r : IsDebuggerFile ( r ) - IsDebuggerFile ( l ) ) [EOL] [EOL] result = Sources ( ) [EOL] for source in source_files : [EOL] try : [EOL] lines = filters ( source ) [EOL] except Error as e : [EOL] raise Error ( [string] % ( source , str ( e ) ) ) [EOL] [EOL] result . modules . append ( lines ) ; [EOL] [EOL] is_debugger = IsDebuggerFile ( source ) [EOL] result . is_debugger_id . append ( is_debugger ) ; [EOL] [EOL] name = os . path . basename ( source ) [ : - [number] ] [EOL] result . names . append ( name if not is_debugger else name [ : - [number] ] ) ; [EOL] return result [EOL] [EOL] [EOL] def BuildMetadata ( sources , source_bytes , native_type ) : [EOL] [docstring] [EOL] total_length = len ( source_bytes ) [EOL] raw_sources = [string] . join ( sources . modules ) [EOL] [EOL] [comment] [EOL] assert not filter ( lambda value : ord ( value ) >= [number] , raw_sources ) [EOL] [EOL] [comment] [EOL] get_index_cases = [ ] [EOL] get_script_name_cases = [ ] [EOL] get_raw_script_source_cases = [ ] [EOL] offset = [number] [EOL] for i in xrange ( len ( sources . modules ) ) : [EOL] native_name = [string] % sources . names [ i ] [EOL] d = { [string] : i , [string] : sources . names [ i ] , [string] : native_name , [string] : len ( native_name ) , [string] : offset , [string] : len ( sources . modules [ i ] ) , } [EOL] get_index_cases . append ( GET_INDEX_CASE % d ) [EOL] get_script_name_cases . append ( GET_SCRIPT_NAME_CASE % d ) [EOL] get_raw_script_source_cases . append ( GET_RAW_SCRIPT_SOURCE_CASE % d ) [EOL] offset += len ( sources . modules [ i ] ) [EOL] assert offset == len ( raw_sources ) [EOL] [EOL] [comment] [EOL] have_raw_sources = source_bytes == raw_sources [EOL] raw_sources_declaration = ( RAW_SOURCES_DECLARATION [EOL] if have_raw_sources else RAW_SOURCES_COMPRESSION_DECLARATION ) [EOL] [EOL] metadata = { [string] : len ( sources . modules ) , [string] : sum ( sources . is_debugger_id ) , [string] : SOURCES_DECLARATION % ToCArray ( source_bytes ) , [string] : raw_sources_declaration , [string] : sum ( map ( len , sources . modules ) ) , [string] : total_length , [string] : [string] . join ( get_index_cases ) , [string] : [string] . join ( get_raw_script_source_cases ) , [string] : [string] . join ( get_script_name_cases ) , [string] : native_type , } [EOL] return metadata [EOL] [EOL] [EOL] def CompressMaybe ( sources , compression_type ) : [EOL] [docstring] [EOL] sources_bytes = [string] . join ( sources . modules ) [EOL] if compression_type == [string] : [EOL] return sources_bytes [EOL] elif compression_type == [string] : [EOL] return bz2 . compress ( sources_bytes ) [EOL] else : [EOL] raise Error ( [string] % compression_type ) [EOL] [EOL] [EOL] def PutInt ( blob_file , value ) : [EOL] assert ( value >= [number] and value < ( [number] << [number] ) ) [EOL] size = [number] if ( value < [number] << [number] ) else ( [number] if ( value < [number] << [number] ) else [number] ) [EOL] value_with_length = ( value << [number] ) | size [EOL] [EOL] byte_sequence = bytearray ( ) [EOL] for i in xrange ( size ) : [EOL] byte_sequence . append ( value_with_length & [number] ) [EOL] value_with_length >>= [number] ; [EOL] blob_file . write ( byte_sequence ) [EOL] [EOL] [EOL] def PutStr ( blob_file , value ) : [EOL] PutInt ( blob_file , len ( value ) ) ; [EOL] blob_file . write ( value ) ; [EOL] [EOL] [EOL] def WriteStartupBlob ( sources , startup_blob ) : [EOL] [docstring] [EOL] output = open ( startup_blob , [string] ) [EOL] [EOL] debug_sources = sum ( sources . is_debugger_id ) [EOL] PutInt ( output , debug_sources ) [EOL] for i in xrange ( debug_sources ) : [EOL] PutStr ( output , sources . names [ i ] ) ; [EOL] PutStr ( output , sources . modules [ i ] ) ; [EOL] [EOL] PutInt ( output , len ( sources . names ) - debug_sources ) [EOL] for i in xrange ( debug_sources , len ( sources . names ) ) : [EOL] PutStr ( output , sources . names [ i ] ) ; [EOL] PutStr ( output , sources . modules [ i ] ) ; [EOL] [EOL] output . close ( ) [EOL] [EOL] [EOL] def JS2C ( source , target , native_type , compression_type , raw_file , startup_blob ) : [EOL] sources = PrepareSources ( source ) [EOL] sources_bytes = CompressMaybe ( sources , compression_type ) [EOL] metadata = BuildMetadata ( sources , sources_bytes , native_type ) [EOL] [EOL] [comment] [EOL] if raw_file : [EOL] output = open ( raw_file , [string] ) [EOL] output . write ( sources_bytes ) [EOL] output . close ( ) [EOL] [EOL] if startup_blob : [EOL] WriteStartupBlob ( sources , startup_blob ) ; [EOL] [EOL] [comment] [EOL] output = open ( target , [string] ) [EOL] output . write ( HEADER_TEMPLATE % metadata ) [EOL] output . close ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = optparse . OptionParser ( ) [EOL] parser . add_option ( [string] , action = [string] , help = [string] ) [EOL] parser . add_option ( [string] , action = [string] , help = [string] ) [EOL] parser . set_usage ( [string] ) [EOL] ( options , args ) = parser . parse_args ( ) [EOL] [EOL] JS2C ( args [ [number] : ] , args [ [number] ] , args [ [number] ] , args [ [number] ] , options . raw , options . startup_blob ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Pattern , Any [EOL] import typing [EOL] import re [EOL] import os [EOL] import sys [EOL] [EOL] DECLARE_FILE = [string] [EOL] REGISTER_FILE = [string] [EOL] DECLARE_RE = re . compile ( [string] ) [EOL] REGISTER_RE = re . compile ( [string] ) [EOL] [EOL] WORKSPACE = os . path . abspath ( os . path . join ( os . path . dirname ( sys . argv [ [number] ] ) , [string] ) ) [EOL] [EOL] [comment] [EOL] BLACKLISTED = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] def Find ( filename , re ) : [EOL] references = [ ] [EOL] with open ( filename , [string] ) as f : [EOL] for line in f : [EOL] match = re . match ( line ) [EOL] if match : [EOL] references . append ( match . group ( [number] ) ) [EOL] return references [EOL] [EOL] def Main ( ) : [EOL] declarations = Find ( DECLARE_FILE , DECLARE_RE ) [EOL] registrations = Find ( REGISTER_FILE , REGISTER_RE ) [EOL] difference = list ( set ( declarations ) - set ( registrations ) - set ( BLACKLISTED ) ) [EOL] for reference in difference : [EOL] print ( [string] % reference ) [EOL] return len ( difference ) > [number] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( Main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Dict , List , Optional , Any , Match [EOL] import typing [EOL] import io [EOL] import re [EOL] import sys [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] consts_misc = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extras_accessors = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] expected_classes = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] types = { } [comment] [EOL] typeclasses = { } [comment] [EOL] klasses = { } [comment] [EOL] fields = [ ] [comment] [EOL] [EOL] header = [string] % sys . argv [ [number] ] [EOL] [EOL] footer = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def load_objects ( ) : [EOL] objfilename = sys . argv [ [number] ] [EOL] objfile = open ( objfilename , [string] ) [EOL] in_insttype = False ; [EOL] [EOL] typestr = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] checktypes = { } [EOL] for klass in expected_classes : [EOL] checktypes [ klass ] = True ; [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for line in objfile : [EOL] if ( line . startswith ( [string] ) ) : [EOL] in_insttype = True ; [EOL] continue ; [EOL] [EOL] if ( in_insttype and line . startswith ( [string] ) ) : [EOL] in_insttype = False [EOL] continue ; [EOL] [EOL] line = re . sub ( [string] , [string] , line . rstrip ( ) . lstrip ( ) ) [EOL] [EOL] if (in_insttype) : [EOL] typestr += line ; [EOL] continue ; [EOL] [EOL] match = re . match ( [string] , line ) [EOL] [EOL] if (match) : [EOL] klass = match . group ( [number] ) [EOL] pklass = match . group ( [number] ) [EOL] klasses [ klass ] = { [string] : pklass } ; [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] entries = typestr . split ( [string] ) [EOL] for entry in entries : [EOL] types [ re . sub ( [string] , [string] , entry ) . lstrip ( ) ] = True ; [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for type in types : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] usetype = re . sub ( [string] , [string] , type ) ; [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] usetype = re . sub ( [string] , [string] , usetype ) ; [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( not usetype . endswith ( [string] ) ) : [EOL] continue ; [EOL] [EOL] usetype = usetype [ [number] : len ( usetype ) - len ( [string] ) ] [EOL] parts = usetype . split ( [string] ) [EOL] cctype = [string] ; [EOL] [EOL] if ( parts [ [number] ] == [string] ) : [EOL] cctype = [string] ; [EOL] start = [number] ; [EOL] else : [EOL] cctype = [string] ; [EOL] start = [number] [EOL] [EOL] for ii in range ( start , len ( parts ) ) : [EOL] part = parts [ ii ] [EOL] cctype += part [ [number] ] . upper ( ) + part [ [number] : ] . lower ( ) ; [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( cctype . endswith ( [string] ) ) : [EOL] if ( cctype . find ( [string] ) == - [number] and cctype . find ( [string] ) == - [number] and cctype . find ( [string] ) == - [number] ) : [EOL] if ( cctype . find ( [string] ) != - [number] ) : [EOL] cctype = re . sub ( [string] , [string] , cctype ) ; [EOL] else : [EOL] cctype = re . sub ( [string] , [string] , cctype ) ; [EOL] [EOL] if ( cctype . find ( [string] ) == - [number] ) : [EOL] cctype = re . sub ( [string] , [string] , cctype ) ; [EOL] [EOL] if ( not ( cctype in klasses ) ) : [EOL] cctype = re . sub ( [string] , [string] , cctype ) ; [EOL] cctype = re . sub ( [string] , [string] , cctype ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( cctype in klasses ) : [EOL] typeclasses [ type ] = cctype ; [EOL] if ( cctype in checktypes ) : [EOL] del checktypes [ cctype ] ; [EOL] [EOL] if ( len ( checktypes ) > [number] ) : [EOL] for klass in checktypes : [EOL] print ( [string] % klass ) ; [EOL] [EOL] sys . exit ( [number] ) ; [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def parse_field ( call ) : [EOL] [comment] [EOL] for ii in range ( [number] , len ( call ) ) : [EOL] if ( call [ ii ] == [string] ) : [EOL] call [ ii ] == [string] ; [EOL] [EOL] idx = call . find ( [string] ) [EOL] kind = call [ [number] : idx ] [EOL] rest = call [ idx + [number] : len ( call ) - [number] ] [EOL] args = re . split ( [string] , rest ) [EOL] [EOL] consts = [ ] [EOL] [EOL] if ( kind == [string] or kind == [string] ) : [EOL] klass = args [ [number] ] ; [EOL] field = args [ [number] ] ; [EOL] dtype = args [ [number] ] [EOL] offset = args [ [number] ] ; [EOL] [EOL] return ( { [string] : [string] % ( klass , field , dtype ) , [string] : [string] % ( klass , offset ) } ) ; [EOL] [EOL] assert ( kind == [string] or kind == [string] ) ; [EOL] klass = args [ [number] ] [EOL] field = args [ [number] ] [EOL] offset = args [ [number] ] [EOL] [EOL] return ( { [string] : [string] % ( klass , field , [string] ) , [string] : [string] % ( klass , offset ) } ) ; [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def load_fields ( ) : [EOL] inlfilename = sys . argv [ [number] ] [EOL] inlfile = open ( inlfilename , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] prefixes = [ [string] , [string] , [string] , [string] ] [EOL] current = [string] ; [EOL] opens = [number] [EOL] [EOL] for line in inlfile : [EOL] if ( opens > [number] ) : [EOL] [comment] [EOL] for ii in range ( [number] , len ( line ) ) : [EOL] if ( line [ ii ] == [string] ) : [EOL] opens += [number] ; [EOL] elif ( line [ ii ] == [string] ) : [EOL] opens -= [number] ; [EOL] [EOL] if ( opens == [number] ) : [EOL] break ; [EOL] [EOL] current += line [ [number] : ii + [number] ] ; [EOL] continue ; [EOL] [EOL] for prefix in prefixes : [EOL] if ( not line . startswith ( prefix + [string] ) ) : [EOL] continue ; [EOL] [EOL] if ( len ( current ) > [number] ) : [EOL] fields . append ( parse_field ( current ) ) ; [EOL] current = [string] ; [EOL] [EOL] for ii in range ( len ( prefix ) , len ( line ) ) : [EOL] if ( line [ ii ] == [string] ) : [EOL] opens += [number] ; [EOL] elif ( line [ ii ] == [string] ) : [EOL] opens -= [number] ; [EOL] [EOL] if ( opens == [number] ) : [EOL] break ; [EOL] [EOL] current += line [ [number] : ii + [number] ] ; [EOL] [EOL] if ( len ( current ) > [number] ) : [EOL] fields . append ( parse_field ( current ) ) ; [EOL] current = [string] [EOL] [EOL] for body in extras_accessors : [EOL] fields . append ( parse_field ( [string] % body ) ) ; [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def emit_set ( out , consts ) : [EOL] [comment] [EOL] [comment] [EOL] ws = re . compile ( [string] ) [EOL] for const in consts : [EOL] name = ws . sub ( [string] , const [ [string] ] ) [EOL] value = ws . sub ( [string] , str ( const [ [string] ] ) ) [comment] [EOL] out . write ( [string] % ( name , value ) ) [EOL] out . write ( [string] ) ; [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def emit_config ( ) : [EOL] out = file ( sys . argv [ [number] ] , [string] ) [EOL] [EOL] out . write ( header ) ; [EOL] [EOL] out . write ( [string] ) ; [EOL] emit_set ( out , consts_misc ) ; [EOL] [EOL] out . write ( [string] ) ; [EOL] consts = [ ] ; [EOL] keys = typeclasses . keys ( ) ; [EOL] keys . sort ( ) ; [EOL] for typename in keys : [EOL] klass = typeclasses [ typename ] [EOL] consts . append ( { [string] : [string] % ( klass , typename ) , [string] : typename } ) ; [EOL] [EOL] emit_set ( out , consts ) ; [EOL] [EOL] out . write ( [string] ) ; [EOL] consts = [ ] [EOL] keys = klasses . keys ( ) [EOL] keys . sort ( ) ; [EOL] for klassname in keys : [EOL] pklass = klasses [ klassname ] [ [string] ] [EOL] if ( pklass == None ) : [EOL] continue ; [EOL] [EOL] consts . append ( { [string] : [string] % ( klassname , pklass ) , [string] : [number] } ) ; [EOL] [EOL] emit_set ( out , consts ) ; [EOL] [EOL] out . write ( [string] ) ; [EOL] emit_set ( out , fields ) ; [EOL] [EOL] out . write ( footer ) ; [EOL] [EOL] if ( len ( sys . argv ) < [number] ) : [EOL] print ( [string] % sys . argv [ [number] ] ) ; [EOL] sys . exit ( [number] ) ; [EOL] [EOL] load_objects ( ) ; [EOL] load_fields ( ) ; [EOL] emit_config ( ) ; [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Optional , Any , Match [EOL] import typing [EOL] import re [EOL] [EOL] [EOL] class GitFailedException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def Strip ( f ) : [EOL] def new_f ( * args , ** kwargs ) : [EOL] return f ( * args , ** kwargs ) . strip ( ) [EOL] return new_f [EOL] [EOL] [EOL] def MakeArgs ( l ) : [EOL] [docstring] [EOL] return [string] . join ( filter ( None , l ) ) [EOL] [EOL] [EOL] def Quoted ( s ) : [EOL] return [string] % s [EOL] [EOL] [EOL] class GitRecipesMixin ( object ) : [EOL] def GitIsWorkdirClean ( self ) : [EOL] return self . Git ( [string] ) . strip ( ) == [string] [EOL] [EOL] @ Strip def GitBranch ( self ) : [EOL] return self . Git ( [string] ) [EOL] [EOL] def GitCreateBranch ( self , name , branch = [string] ) : [EOL] assert name [EOL] self . Git ( MakeArgs ( [ [string] , name , branch ] ) ) [EOL] [EOL] def GitDeleteBranch ( self , name ) : [EOL] assert name [EOL] self . Git ( MakeArgs ( [ [string] , name ] ) ) [EOL] [EOL] def GitReset ( self , name ) : [EOL] assert name [EOL] self . Git ( MakeArgs ( [ [string] , name ] ) ) [EOL] [EOL] def GitStash ( self ) : [EOL] self . Git ( MakeArgs ( [ [string] ] ) ) [EOL] [EOL] def GitRemotes ( self ) : [EOL] return map ( str . strip , self . Git ( MakeArgs ( [ [string] ] ) ) . splitlines ( ) ) [EOL] [EOL] def GitCheckout ( self , name ) : [EOL] assert name [EOL] self . Git ( MakeArgs ( [ [string] , name ] ) ) [EOL] [EOL] def GitCheckoutFile ( self , name , branch_or_hash ) : [EOL] assert name [EOL] assert branch_or_hash [EOL] self . Git ( MakeArgs ( [ [string] , branch_or_hash , [string] , name ] ) ) [EOL] [EOL] def GitCheckoutFileSafe ( self , name , branch_or_hash ) : [EOL] try : [EOL] self . GitCheckoutFile ( name , branch_or_hash ) [EOL] except GitFailedException : [comment] [EOL] [comment] [EOL] return False [EOL] return True [EOL] [EOL] def GitChangedFiles ( self , git_hash ) : [EOL] assert git_hash [EOL] try : [EOL] files = self . Git ( MakeArgs ( [ [string] , git_hash , [string] % git_hash ] ) ) [EOL] return map ( str . strip , files . splitlines ( ) ) [EOL] except GitFailedException : [comment] [EOL] [comment] [EOL] return [ ] [EOL] [EOL] [EOL] @ Strip def GitCurrentBranch ( self ) : [EOL] for line in self . Git ( [string] ) . strip ( ) . splitlines ( ) : [EOL] match = re . match ( [string] , line ) [EOL] if match : return match . group ( [number] ) [EOL] raise Exception ( [string] ) [comment] [EOL] [EOL] @ Strip def GitLog ( self , n = [number] , format = [string] , grep = [string] , git_hash = [string] , parent_hash = [string] , branch = [string] , reverse = False ) : [EOL] assert not ( git_hash and parent_hash ) [EOL] args = [ [string] ] [EOL] if n > [number] : [EOL] args . append ( [string] % n ) [EOL] if format : [EOL] args . append ( [string] % format ) [EOL] if grep : [EOL] args . append ( [string] % grep . replace ( [string] , [string] ) ) [EOL] if reverse : [EOL] args . append ( [string] ) [EOL] if git_hash : [EOL] args . append ( git_hash ) [EOL] if parent_hash : [EOL] args . append ( [string] % parent_hash ) [EOL] args . append ( branch ) [EOL] return self . Git ( MakeArgs ( args ) ) [EOL] [EOL] def GitGetPatch ( self , git_hash ) : [EOL] assert git_hash [EOL] return self . Git ( MakeArgs ( [ [string] , [string] , [string] , git_hash ] ) ) [EOL] [EOL] [comment] [EOL] def GitAdd ( self , name ) : [EOL] assert name [EOL] self . Git ( MakeArgs ( [ [string] , Quoted ( name ) ] ) ) [EOL] [EOL] def GitApplyPatch ( self , patch_file , reverse = False ) : [EOL] assert patch_file [EOL] args = [ [string] ] [EOL] if reverse : [EOL] args . append ( [string] ) [EOL] args . append ( Quoted ( patch_file ) ) [EOL] self . Git ( MakeArgs ( args ) ) [EOL] [EOL] def GitUpload ( self , reviewer = [string] , author = [string] , force = False , cq = False , bypass_hooks = False ) : [EOL] args = [ [string] ] [EOL] if author : [EOL] args += [ [string] , Quoted ( author ) ] [EOL] if reviewer : [EOL] args += [ [string] , Quoted ( reviewer ) ] [EOL] if force : [EOL] args . append ( [string] ) [EOL] if cq : [EOL] args . append ( [string] ) [EOL] if bypass_hooks : [EOL] args . append ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] self . Git ( MakeArgs ( args ) , pipe = False ) [EOL] [EOL] def GitCommit ( self , message = [string] , file_name = [string] ) : [EOL] assert message or file_name [EOL] args = [ [string] ] [EOL] if file_name : [EOL] args += [ [string] , Quoted ( file_name ) ] [EOL] if message : [EOL] args += [ [string] , Quoted ( message ) ] [EOL] self . Git ( MakeArgs ( args ) ) [EOL] [EOL] def GitPresubmit ( self ) : [EOL] self . Git ( [string] , [string] ) [EOL] [EOL] def GitDCommit ( self ) : [EOL] self . Git ( [string] , retry_on = lambda x : x is None ) [EOL] [EOL] def GitDiff ( self , loc1 , loc2 ) : [EOL] return self . Git ( MakeArgs ( [ [string] , loc1 , loc2 ] ) ) [EOL] [EOL] def GitPull ( self ) : [EOL] self . Git ( [string] ) [EOL] [EOL] def GitSVNFetch ( self ) : [EOL] self . Git ( [string] ) [EOL] [EOL] def GitSVNRebase ( self ) : [EOL] self . Git ( [string] ) [EOL] [EOL] [comment] [EOL] @ Strip def GitSVNLog ( self ) : [EOL] return self . Git ( [string] ) [EOL] [EOL] @ Strip def GitSVNFindGitHash ( self , revision , branch = [string] ) : [EOL] assert revision [EOL] return self . Git ( MakeArgs ( [ [string] , [string] % revision , branch ] ) ) [EOL] [EOL] @ Strip def GitSVNFindSVNRev ( self , git_hash , branch = [string] ) : [EOL] return self . Git ( MakeArgs ( [ [string] , git_hash , branch ] ) ) [EOL] [EOL] def GitSVNDCommit ( self ) : [EOL] return self . Git ( [string] , retry_on = lambda x : x is None ) [EOL] [EOL] def GitSVNTag ( self , version ) : [EOL] self . Git ( ( [string] % ( version , version ) ) , retry_on = lambda x : x is None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any , Set [EOL] import typing [EOL] import _importlib_modulespec [EOL] import imp [EOL] import os [EOL] [EOL] from . import statusfile [EOL] from . import utils [EOL] [EOL] class TestSuite ( object ) : [EOL] [EOL] @ staticmethod def LoadTestSuite ( root ) : [EOL] name = root . split ( os . path . sep ) [ - [number] ] [EOL] f = None [EOL] try : [EOL] ( f , pathname , description ) = imp . find_module ( [string] , [ root ] ) [EOL] module = imp . load_module ( [string] , f , pathname , description ) [EOL] suite = module . GetSuite ( name , root ) [EOL] finally : [EOL] if f : [EOL] f . close ( ) [EOL] return suite [EOL] [EOL] def __init__ ( self , name , root ) : [EOL] self . name = name [comment] [EOL] self . root = root [comment] [EOL] self . tests = None [comment] [EOL] self . rules = None [comment] [EOL] self . wildcards = None [comment] [EOL] self . total_duration = None [comment] [EOL] [EOL] def shell ( self ) : [EOL] return [string] [EOL] [EOL] def suffix ( self ) : [EOL] return [string] [EOL] [EOL] def status_file ( self ) : [EOL] return [string] % ( self . root , self . name ) [EOL] [EOL] [comment] [EOL] def CommonTestName ( self , testcase ) : [EOL] if utils . IsWindows ( ) : [EOL] return testcase . path . replace ( [string] , [string] ) [EOL] else : [EOL] return testcase . path [EOL] [EOL] def ListTests ( self , context ) : [EOL] raise NotImplementedError [EOL] [EOL] def VariantFlags ( self , testcase , default_flags ) : [EOL] if testcase . outcomes and statusfile . OnlyStandardVariant ( testcase . outcomes ) : [EOL] return [ [ ] ] [EOL] return default_flags [EOL] [EOL] def DownloadData ( self ) : [EOL] pass [EOL] [EOL] def ReadStatusFile ( self , variables ) : [EOL] ( self . rules , self . wildcards ) = statusfile . ReadStatusFile ( self . status_file ( ) , variables ) [EOL] [EOL] def ReadTestCases ( self , context ) : [EOL] self . tests = self . ListTests ( context ) [EOL] [EOL] @ staticmethod def _FilterFlaky ( flaky , mode ) : [EOL] return ( mode == [string] and not flaky ) or ( mode == [string] and flaky ) [EOL] [EOL] @ staticmethod def _FilterSlow ( slow , mode ) : [EOL] return ( mode == [string] and not slow ) or ( mode == [string] and slow ) [EOL] [EOL] @ staticmethod def _FilterPassFail ( pass_fail , mode ) : [EOL] return ( mode == [string] and not pass_fail ) or ( mode == [string] and pass_fail ) [EOL] [EOL] def FilterTestCasesByStatus ( self , warn_unused_rules , flaky_tests = [string] , slow_tests = [string] , pass_fail_tests = [string] ) : [EOL] filtered = [ ] [EOL] used_rules = set ( ) [EOL] for t in self . tests : [EOL] flaky = False [EOL] slow = False [EOL] pass_fail = False [EOL] testname = self . CommonTestName ( t ) [EOL] if testname in self . rules : [EOL] used_rules . add ( testname ) [EOL] [comment] [EOL] [comment] [EOL] t . outcomes = self . rules [ testname ] [EOL] if statusfile . DoSkip ( t . outcomes ) : [EOL] continue [comment] [EOL] flaky = statusfile . IsFlaky ( t . outcomes ) [EOL] slow = statusfile . IsSlow ( t . outcomes ) [EOL] pass_fail = statusfile . IsPassOrFail ( t . outcomes ) [EOL] skip = False [EOL] for rule in self . wildcards : [EOL] assert rule [ - [number] ] == [string] [EOL] if testname . startswith ( rule [ : - [number] ] ) : [EOL] used_rules . add ( rule ) [EOL] t . outcomes = self . wildcards [ rule ] [EOL] if statusfile . DoSkip ( t . outcomes ) : [EOL] skip = True [EOL] break [comment] [EOL] flaky = flaky or statusfile . IsFlaky ( t . outcomes ) [EOL] slow = slow or statusfile . IsSlow ( t . outcomes ) [EOL] pass_fail = pass_fail or statusfile . IsPassOrFail ( t . outcomes ) [EOL] if ( skip or self . _FilterFlaky ( flaky , flaky_tests ) or self . _FilterSlow ( slow , slow_tests ) or self . _FilterPassFail ( pass_fail , pass_fail_tests ) ) : [EOL] continue [comment] [EOL] filtered . append ( t ) [EOL] self . tests = filtered [EOL] [EOL] if not warn_unused_rules : [EOL] return [EOL] [EOL] for rule in self . rules : [EOL] if rule not in used_rules : [EOL] print ( [string] % ( rule , self . rules [ rule ] ) ) [EOL] for rule in self . wildcards : [EOL] if rule not in used_rules : [EOL] print ( [string] % ( rule , self . wildcards [ rule ] ) ) [EOL] [EOL] def FilterTestCasesByArgs ( self , args ) : [EOL] filtered = [ ] [EOL] filtered_args = [ ] [EOL] for a in args : [EOL] argpath = a . split ( os . path . sep ) [EOL] if argpath [ [number] ] != self . name : [EOL] continue [EOL] if len ( argpath ) == [number] or ( len ( argpath ) == [number] and argpath [ [number] ] == [string] ) : [EOL] return [comment] [EOL] path = os . path . sep . join ( argpath [ [number] : ] ) [EOL] if path [ - [number] ] == [string] : [EOL] path = path [ : - [number] ] [EOL] filtered_args . append ( path ) [EOL] for t in self . tests : [EOL] for a in filtered_args : [EOL] if t . path . startswith ( a ) : [EOL] filtered . append ( t ) [EOL] break [EOL] self . tests = filtered [EOL] [EOL] def GetFlagsForTestCase ( self , testcase , context ) : [EOL] raise NotImplementedError [EOL] [EOL] def GetSourceForTest ( self , testcase ) : [EOL] return [string] [EOL] [EOL] def IsFailureOutput ( self , output , testpath ) : [EOL] return output . exit_code != [number] [EOL] [EOL] def IsNegativeTest ( self , testcase ) : [EOL] return False [EOL] [EOL] def HasFailed ( self , testcase ) : [EOL] execution_failed = self . IsFailureOutput ( testcase . output , testcase . path ) [EOL] if self . IsNegativeTest ( testcase ) : [EOL] return not execution_failed [EOL] else : [EOL] return execution_failed [EOL] [EOL] def GetOutcome ( self , testcase ) : [EOL] if testcase . output . HasCrashed ( ) : [EOL] return statusfile . CRASH [EOL] elif testcase . output . HasTimedOut ( ) : [EOL] return statusfile . TIMEOUT [EOL] elif self . HasFailed ( testcase ) : [EOL] return statusfile . FAIL [EOL] else : [EOL] return statusfile . PASS [EOL] [EOL] def HasUnexpectedOutput ( self , testcase ) : [EOL] outcome = self . GetOutcome ( testcase ) [EOL] return not outcome in ( testcase . outcomes or [ statusfile . PASS ] ) [EOL] [EOL] def StripOutputForTransmit ( self , testcase ) : [EOL] if not self . HasUnexpectedOutput ( testcase ) : [EOL] testcase . output . stdout = [string] [EOL] testcase . output . stderr = [string] [EOL] [EOL] def CalculateTotalDuration ( self ) : [EOL] self . total_duration = [number] [EOL] for t in self . tests : [EOL] self . total_duration += t . duration [EOL] return self . total_duration [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $_importlib_modulespec.ModuleType$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import threading [EOL] import os [EOL] import shelve [EOL] import threading [EOL] [EOL] [EOL] class PerfDataEntry ( object ) : [EOL] def __init__ ( self ) : [EOL] self . avg = [number] [EOL] self . count = [number] [EOL] [EOL] def AddResult ( self , result ) : [EOL] kLearnRateLimiter = [number] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] effective_count = min ( self . count , kLearnRateLimiter ) [EOL] self . avg = self . avg * effective_count + result [EOL] self . count = effective_count + [number] [EOL] self . avg /= self . count [EOL] [EOL] [EOL] class PerfDataStore ( object ) : [EOL] def __init__ ( self , datadir , arch , mode ) : [EOL] filename = os . path . join ( datadir , [string] % ( arch , mode ) ) [EOL] self . database = shelve . open ( filename , protocol = [number] ) [EOL] self . closed = False [EOL] self . lock = threading . Lock ( ) [EOL] [EOL] def __del__ ( self ) : [EOL] self . close ( ) [EOL] [EOL] def close ( self ) : [EOL] if self . closed : return [EOL] self . database . close ( ) [EOL] self . closed = True [EOL] [EOL] def GetKey ( self , test ) : [EOL] [docstring] [EOL] flags = [string] . join ( test . flags ) [EOL] return str ( [string] % ( test . suitename ( ) , test . path , flags ) ) [EOL] [EOL] def FetchPerfData ( self , test ) : [EOL] [docstring] [EOL] key = self . GetKey ( test ) [EOL] if key in self . database : [EOL] return self . database [ key ] . avg [EOL] return None [EOL] [EOL] def UpdatePerfData ( self , test ) : [EOL] [docstring] [EOL] testkey = self . GetKey ( test ) [EOL] self . RawUpdatePerfData ( testkey , test . duration ) [EOL] [EOL] def RawUpdatePerfData ( self , testkey , duration ) : [EOL] with self . lock : [EOL] if testkey in self . database : [EOL] entry = self . database [ testkey ] [EOL] else : [EOL] entry = PerfDataEntry ( ) [EOL] entry . AddResult ( duration ) [EOL] self . database [ testkey ] = entry [EOL] [EOL] [EOL] class PerfDataManager ( object ) : [EOL] def __init__ ( self , datadir ) : [EOL] self . datadir = os . path . abspath ( datadir ) [EOL] if not os . path . exists ( self . datadir ) : [EOL] os . makedirs ( self . datadir ) [EOL] self . stores = { } [comment] [EOL] self . closed = False [EOL] self . lock = threading . Lock ( ) [EOL] [EOL] def __del__ ( self ) : [EOL] self . close ( ) [EOL] [EOL] def close ( self ) : [EOL] if self . closed : return [EOL] for arch in self . stores : [EOL] modes = self . stores [ arch ] [EOL] for mode in modes : [EOL] store = modes [ mode ] [EOL] store . close ( ) [EOL] self . closed = True [EOL] [EOL] def GetStore ( self , arch , mode ) : [EOL] with self . lock : [EOL] if not arch in self . stores : [EOL] self . stores [ arch ] = { } [EOL] modes = self . stores [ arch ] [EOL] if not mode in modes : [EOL] modes [ mode ] = PerfDataStore ( self . datadir , arch , mode ) [EOL] return modes [ mode ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Optional [EOL] import typing [EOL] import xml [EOL] import xml . etree . ElementTree as xml [EOL] [EOL] [EOL] class JUnitTestOutput : [EOL] def __init__ ( self , test_suite_name ) : [EOL] self . root = xml . Element ( [string] ) [EOL] self . root . attrib [ [string] ] = test_suite_name [EOL] [EOL] def HasRunTest ( self , test_name , test_duration , test_failure ) : [EOL] testCaseElement = xml . Element ( [string] ) [EOL] testCaseElement . attrib [ [string] ] = [string] . join ( test_name ) [EOL] testCaseElement . attrib [ [string] ] = str ( round ( test_duration , [number] ) ) [EOL] if len ( test_failure ) : [EOL] failureElement = xml . Element ( [string] ) [EOL] failureElement . text = test_failure [EOL] testCaseElement . append ( failureElement ) [EOL] self . root . append ( testCaseElement ) [EOL] [EOL] def FinishAndWrite ( self , file ) : [EOL] xml . ElementTree ( self . root ) . write ( file , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $xml.etree.ElementTree.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 0 0 $xml.etree.ElementTree.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $xml.etree.ElementTree.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 $xml.etree.ElementTree.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $xml.etree.ElementTree.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $xml.etree.ElementTree.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 $xml.etree.ElementTree.etree.ElementTree.Element$ 0 $typing.Optional[builtins.str]$ 0 0 0 $xml.etree.ElementTree.etree.ElementTree.Element$ 0 0 0 $xml.etree.ElementTree.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 $xml.etree.ElementTree.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import os [EOL] from os . path import exists [EOL] from os . path import isdir [EOL] from os . path import join [EOL] import platform [EOL] import re [EOL] import urllib2 [EOL] [EOL] [EOL] def GetSuitePaths ( test_root ) : [EOL] def IsSuite ( path ) : [EOL] return isdir ( path ) and exists ( join ( path , [string] ) ) [EOL] return [ f for f in os . listdir ( test_root ) if IsSuite ( join ( test_root , f ) ) ] [EOL] [EOL] [EOL] [comment] [EOL] def ReadLinesFrom ( name ) : [EOL] lines = [ ] [EOL] with open ( name ) as f : [EOL] for line in f : [EOL] if line . startswith ( [string] ) : continue [EOL] if [string] in line : [EOL] line = line [ : line . find ( [string] ) ] [EOL] line = line . strip ( ) [EOL] if not line : continue [EOL] lines . append ( line ) [EOL] return lines [EOL] [EOL] [EOL] def GuessOS ( ) : [EOL] system = platform . system ( ) [EOL] if system == [string] : [EOL] return [string] [EOL] elif system == [string] : [EOL] return [string] [EOL] elif system . find ( [string] ) >= [number] : [EOL] return [string] [EOL] elif system == [string] or system == [string] : [EOL] [comment] [EOL] [comment] [EOL] return [string] [EOL] elif system == [string] : [EOL] return [string] [EOL] elif system == [string] : [EOL] return [string] [EOL] elif system == [string] : [EOL] return [string] [EOL] elif system == [string] : [EOL] return [string] [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def UseSimulator ( arch ) : [EOL] machine = platform . machine ( ) [EOL] return ( machine and ( arch == [string] or arch == [string] or arch == [string] ) and not arch . startswith ( machine ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def DefaultArch ( ) : [EOL] machine = platform . machine ( ) [EOL] machine = machine . lower ( ) [comment] [EOL] if machine . startswith ( [string] ) : [EOL] return [string] [EOL] elif ( not machine ) or ( not re . match ( [string] , machine ) is None ) : [EOL] return [string] [EOL] elif machine == [string] : [EOL] return [string] [EOL] elif machine == [string] : [EOL] return [string] [EOL] elif machine == [string] : [EOL] return [string] [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def GuessWordsize ( ) : [EOL] if [string] in platform . machine ( ) : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] def IsWindows ( ) : [EOL] return GuessOS ( ) == [string] [EOL] [EOL] [EOL] def URLRetrieve ( source , destination ) : [EOL] [docstring] [EOL] with open ( destination , [string] ) as f : [EOL] f . write ( urllib2 . urlopen ( source ) . read ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from pool import Pool [EOL] [EOL] def Run ( x ) : [EOL] if x == [number] : [EOL] raise Exception ( [string] ) [EOL] return x [EOL] [EOL] class PoolTest ( unittest . TestCase ) : [EOL] def testNormal ( self ) : [EOL] results = set ( ) [EOL] pool = Pool ( [number] ) [EOL] for result in pool . imap_unordered ( Run , [ [ x ] for x in range ( [number] , [number] ) ] ) : [EOL] results . add ( result ) [EOL] self . assertEquals ( set ( range ( [number] , [number] ) ) , results ) [EOL] [EOL] def testException ( self ) : [EOL] results = set ( ) [EOL] pool = Pool ( [number] ) [EOL] for result in pool . imap_unordered ( Run , [ [ x ] for x in range ( [number] , [number] ) ] ) : [EOL] [comment] [EOL] results . add ( result ) [EOL] expect = set ( range ( [number] , [number] ) ) [EOL] expect . remove ( [number] ) [EOL] self . assertEquals ( expect , results ) [EOL] [EOL] def testAdd ( self ) : [EOL] results = set ( ) [EOL] pool = Pool ( [number] ) [EOL] for result in pool . imap_unordered ( Run , [ [ x ] for x in range ( [number] , [number] ) ] ) : [EOL] results . add ( result ) [EOL] if result < [number] : [EOL] pool . add ( [ result + [number] ] ) [EOL] self . assertEquals ( set ( range ( [number] , [number] ) + range ( [number] , [number] ) + range ( [number] , [number] ) ) , results ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from . import output [EOL] [EOL] class TestCase ( object ) : [EOL] def __init__ ( self , suite , path , flags = [ ] , dependency = None ) : [EOL] self . suite = suite [comment] [EOL] self . path = path [comment] [EOL] self . flags = flags [comment] [EOL] self . dependency = dependency [comment] [EOL] self . outcomes = None [EOL] self . output = None [EOL] self . id = None [comment] [EOL] self . duration = None [comment] [EOL] self . run = [number] [comment] [EOL] [EOL] def CopyAddingFlags ( self , flags ) : [EOL] copy = TestCase ( self . suite , self . path , self . flags + flags , self . dependency ) [EOL] copy . outcomes = self . outcomes [EOL] return copy [EOL] [EOL] def PackTask ( self ) : [EOL] [docstring] [EOL] assert self . id is not None [EOL] return [ self . suitename ( ) , self . path , self . flags , self . dependency , list ( self . outcomes or [ ] ) , self . id ] [EOL] [EOL] @ staticmethod def UnpackTask ( task ) : [EOL] [docstring] [EOL] [comment] [EOL] test = TestCase ( str ( task [ [number] ] ) , task [ [number] ] , task [ [number] ] , task [ [number] ] ) [EOL] test . outcomes = set ( task [ [number] ] ) [EOL] test . id = task [ [number] ] [EOL] test . run = [number] [EOL] return test [EOL] [EOL] def SetSuiteObject ( self , suites ) : [EOL] self . suite = suites [ self . suite ] [EOL] [EOL] def PackResult ( self ) : [EOL] [docstring] [EOL] self . suite . StripOutputForTransmit ( self ) [EOL] return [ self . id , self . output . Pack ( ) , self . duration ] [EOL] [EOL] def MergeResult ( self , result ) : [EOL] [docstring] [EOL] assert result [ [number] ] == self . id [EOL] self . output = output . Output . Unpack ( result [ [number] ] ) [EOL] self . duration = result [ [number] ] [EOL] [EOL] def suitename ( self ) : [EOL] return self . suite . name [EOL] [EOL] def GetLabel ( self ) : [EOL] return self . suitename ( ) + [string] + self . suite . CommonTestName ( self ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Context ( ) : [EOL] def __init__ ( self , arch , mode , shell_dir , mode_flags , verbose , timeout , isolates , command_prefix , extra_flags , noi18n , random_seed , no_sorting , rerun_failures_count , rerun_failures_max , predictable ) : [EOL] self . arch = arch [EOL] self . mode = mode [EOL] self . shell_dir = shell_dir [EOL] self . mode_flags = mode_flags [EOL] self . verbose = verbose [EOL] self . timeout = timeout [EOL] self . isolates = isolates [EOL] self . command_prefix = command_prefix [EOL] self . extra_flags = extra_flags [EOL] self . noi18n = noi18n [EOL] self . random_seed = random_seed [EOL] self . no_sorting = no_sorting [EOL] self . rerun_failures_count = rerun_failures_count [EOL] self . rerun_failures_max = rerun_failures_max [EOL] self . predictable = predictable [EOL] [EOL] def Pack ( self ) : [EOL] return [ self . arch , self . mode , self . mode_flags , self . timeout , self . isolates , self . command_prefix , self . extra_flags , self . noi18n , self . random_seed , self . no_sorting , self . rerun_failures_count , self . rerun_failures_max , self . predictable ] [EOL] [EOL] @ staticmethod def Unpack ( packed ) : [EOL] [comment] [EOL] return Context ( packed [ [number] ] , packed [ [number] ] , None , packed [ [number] ] , False , packed [ [number] ] , packed [ [number] ] , packed [ [number] ] , packed [ [number] ] , packed [ [number] ] , packed [ [number] ] , packed [ [number] ] , packed [ [number] ] , packed [ [number] ] , packed [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] class Peer ( object ) : [EOL] def __init__ ( self , address , jobs , rel_perf , pubkey ) : [EOL] self . address = address [comment] [EOL] self . jobs = jobs [comment] [EOL] self . relative_performance = rel_perf [EOL] self . pubkey = pubkey [comment] [EOL] self . shells = set ( ) [comment] [EOL] self . needed_work = [number] [EOL] self . assigned_work = [number] [EOL] self . tests = [ ] [comment] [EOL] self . trusting_me = False [comment] [EOL] self . trusted = False [comment] [EOL] [EOL] def __str__ ( self ) : [EOL] return ( [string] % ( self . address , self . jobs , self . relative_performance , self . trusting_me , self . trusted ) ) [EOL] [EOL] def AddTests ( self , shell ) : [EOL] [docstring] [EOL] assert self . needed_work > [number] [EOL] if shell . shell not in self . shells : [EOL] self . shells . add ( shell . shell ) [EOL] while len ( shell . tests ) > [number] and self . needed_work > [number] : [EOL] t = shell . tests . pop ( ) [EOL] self . needed_work -= t . duration [EOL] self . assigned_work += t . duration [EOL] shell . total_duration -= t . duration [EOL] self . tests . append ( t ) [EOL] [EOL] def ForceAddOneTest ( self , test , shell ) : [EOL] [docstring] [EOL] if shell . shell not in self . shells : [EOL] self . shells . add ( shell . shell ) [EOL] self . needed_work -= test . duration [EOL] self . assigned_work += test . duration [EOL] shell . total_duration -= test . duration [EOL] self . tests . append ( test ) [EOL] [EOL] [EOL] def Pack ( self ) : [EOL] [docstring] [EOL] return [ self . address , self . jobs , self . relative_performance ] [EOL] [EOL] @ staticmethod def Unpack ( packed ) : [EOL] [docstring] [EOL] pubkey_dummy = [string] [comment] [EOL] return Peer ( packed [ [number] ] , packed [ [number] ] , packed [ [number] ] , pubkey_dummy ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , List , Dict [EOL] import typing [EOL] from . import context [EOL] from . import testcase [EOL] [EOL] class WorkPacket ( object ) : [EOL] def __init__ ( self , peer = None , context = None , tests = None , binaries = None , base_revision = None , patch = None , pubkey = None ) : [EOL] self . peer = peer [EOL] self . context = context [EOL] self . tests = tests [EOL] self . binaries = binaries [EOL] self . base_revision = base_revision [EOL] self . patch = patch [EOL] self . pubkey_fingerprint = pubkey [EOL] [EOL] def Pack ( self , binaries_dict ) : [EOL] [docstring] [EOL] need_libv8 = False [EOL] binaries = [ ] [EOL] for shell in self . peer . shells : [EOL] prefetched_binary = binaries_dict [ shell ] [EOL] binaries . append ( { [string] : shell , [string] : prefetched_binary [ [number] ] , [string] : prefetched_binary [ [number] ] } ) [EOL] if prefetched_binary [ [number] ] : [EOL] need_libv8 = True [EOL] if need_libv8 : [EOL] libv8 = binaries_dict [ [string] ] [EOL] binaries . append ( { [string] : [string] , [string] : libv8 [ [number] ] , [string] : libv8 [ [number] ] } ) [EOL] tests = [ ] [EOL] test_map = { } [EOL] for t in self . peer . tests : [EOL] test_map [ t . id ] = t [EOL] tests . append ( t . PackTask ( ) ) [EOL] result = { [string] : binaries , [string] : self . pubkey_fingerprint , [string] : self . context . Pack ( ) , [string] : self . base_revision , [string] : self . patch , [string] : tests } [EOL] return result , test_map [EOL] [EOL] @ staticmethod def Unpack ( packed ) : [EOL] [docstring] [EOL] binaries = packed [ [string] ] [EOL] pubkey_fingerprint = packed [ [string] ] [EOL] ctx = context . Context . Unpack ( packed [ [string] ] ) [EOL] base_revision = packed [ [string] ] [EOL] patch = packed [ [string] ] [EOL] tests = [ testcase . TestCase . UnpackTask ( t ) for t in packed [ [string] ] ] [EOL] return WorkPacket ( context = ctx , tests = tests , binaries = binaries , base_revision = base_revision , patch = patch , pubkey = pubkey_fingerprint ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import signal [EOL] [EOL] from . . local import utils [EOL] [EOL] class Output ( object ) : [EOL] [EOL] def __init__ ( self , exit_code , timed_out , stdout , stderr ) : [EOL] self . exit_code = exit_code [EOL] self . timed_out = timed_out [EOL] self . stdout = stdout [EOL] self . stderr = stderr [EOL] [EOL] def HasCrashed ( self ) : [EOL] if utils . IsWindows ( ) : [EOL] return [number] & self . exit_code and not ( [number] & self . exit_code ) [EOL] else : [EOL] [comment] [EOL] if self . timed_out : [EOL] return False [EOL] return ( self . exit_code < [number] and self . exit_code != - signal . SIGABRT ) [EOL] [EOL] def HasTimedOut ( self ) : [EOL] return self . timed_out [EOL] [EOL] def Pack ( self ) : [EOL] return [ self . exit_code , self . timed_out , self . stdout , self . stderr ] [EOL] [EOL] @ staticmethod def Unpack ( packed ) : [EOL] [comment] [EOL] return Output ( packed [ [number] ] , packed [ [number] ] , packed [ [number] ] , packed [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Tuple , Any [EOL] import typing [EOL] import socket [EOL] import threading [EOL] import socket [EOL] import SocketServer [EOL] import threading [EOL] try : [EOL] import ujson as json [EOL] except : [EOL] import json [EOL] [EOL] from . import constants [EOL] from . . objects import peer [EOL] [EOL] [EOL] STARTUP_REQUEST = [string] [EOL] STARTUP_RESPONSE = [string] [EOL] EXIT_REQUEST = [string] [EOL] [EOL] [EOL] def GetOwnIP ( ) : [EOL] s = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) [EOL] s . connect ( ( [string] , [number] ) ) [EOL] ip = s . getsockname ( ) [ [number] ] [EOL] s . close ( ) [EOL] return ip [EOL] [EOL] [EOL] class PresenceHandler ( SocketServer . BaseRequestHandler ) : [EOL] [EOL] def handle ( self ) : [EOL] data = json . loads ( self . request [ [number] ] . strip ( ) ) [EOL] [EOL] if data [ [number] ] == STARTUP_REQUEST : [EOL] jobs = data [ [number] ] [EOL] relative_perf = data [ [number] ] [EOL] pubkey_fingerprint = data [ [number] ] [EOL] trusted = self . server . daemon . IsTrusted ( pubkey_fingerprint ) [EOL] response = [ STARTUP_RESPONSE , self . server . daemon . jobs , self . server . daemon . relative_perf , self . server . daemon . pubkey_fingerprint , trusted ] [EOL] response = json . dumps ( response ) [EOL] self . server . SendTo ( self . client_address [ [number] ] , response ) [EOL] p = peer . Peer ( self . client_address [ [number] ] , jobs , relative_perf , pubkey_fingerprint ) [EOL] p . trusted = trusted [EOL] self . server . daemon . AddPeer ( p ) [EOL] [EOL] elif data [ [number] ] == STARTUP_RESPONSE : [EOL] jobs = data [ [number] ] [EOL] perf = data [ [number] ] [EOL] pubkey_fingerprint = data [ [number] ] [EOL] p = peer . Peer ( self . client_address [ [number] ] , jobs , perf , pubkey_fingerprint ) [EOL] p . trusted = self . server . daemon . IsTrusted ( pubkey_fingerprint ) [EOL] p . trusting_me = data [ [number] ] [EOL] self . server . daemon . AddPeer ( p ) [EOL] [EOL] elif data [ [number] ] == EXIT_REQUEST : [EOL] self . server . daemon . DeletePeer ( self . client_address [ [number] ] ) [EOL] if self . client_address [ [number] ] == self . server . daemon . ip : [EOL] self . server . shutdown_lock . release ( ) [EOL] [EOL] [EOL] class PresenceDaemon ( SocketServer . ThreadingMixIn , SocketServer . UDPServer ) : [EOL] def __init__ ( self , daemon ) : [EOL] self . daemon = daemon [EOL] address = ( daemon . ip , constants . PRESENCE_PORT ) [EOL] SocketServer . UDPServer . __init__ ( self , address , PresenceHandler ) [EOL] self . shutdown_lock = threading . Lock ( ) [EOL] [EOL] def shutdown ( self ) : [EOL] self . shutdown_lock . acquire ( ) [EOL] self . SendToAll ( json . dumps ( [ EXIT_REQUEST ] ) ) [EOL] self . shutdown_lock . acquire ( ) [EOL] self . shutdown_lock . release ( ) [EOL] SocketServer . UDPServer . shutdown ( self ) [EOL] [EOL] def SendTo ( self , target , message ) : [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) [EOL] sock . sendto ( message , ( target , constants . PRESENCE_PORT ) ) [EOL] sock . close ( ) [EOL] [EOL] def SendToAll ( self , message ) : [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) [EOL] ip = self . daemon . ip . split ( [string] ) [EOL] for i in range ( [number] , [number] ) : [EOL] ip [ - [number] ] = str ( i ) [EOL] sock . sendto ( message , ( [string] . join ( ip ) , constants . PRESENCE_PORT ) ) [EOL] sock . close ( ) [EOL] [EOL] def FindPeers ( self ) : [EOL] request = [ STARTUP_REQUEST , self . daemon . jobs , self . daemon . relative_perf , self . daemon . pubkey_fingerprint ] [EOL] request = json . dumps ( request ) [EOL] self . SendToAll ( request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,builtins.int]$ 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] CLIENT_PORT = [number] [comment] [EOL] PEER_PORT = [number] [comment] [EOL] PRESENCE_PORT = [number] [comment] [EOL] STATUS_PORT = [number] [comment] [EOL] [EOL] END_OF_STREAM = [string] [comment] [EOL] SIZE_T = [number] [comment] [EOL] [EOL] [comment] [EOL] ADD_TRUSTED = [string] [EOL] INFORM_DURATION = [string] [EOL] REQUEST_PEERS = [string] [EOL] UNRESPONSIVE_PEER = [string] [EOL] REQUEST_PUBKEY_FINGERPRINT = [string] [EOL] REQUEST_STATUS = [string] [EOL] UPDATE_PERF = [string] [EOL] [EOL] [comment] [EOL] LIST_TRUSTED_PUBKEYS = [string] [EOL] GET_SIGNED_PUBKEY = [string] [EOL] NOTIFY_NEW_TRUSTED = [string] [EOL] TRUST_YOU_NOW = [string] [EOL] DO_YOU_TRUST = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import socket [EOL] import socket [EOL] import SocketServer [EOL] import StringIO [EOL] [EOL] from . import compression [EOL] from . import constants [EOL] [EOL] [EOL] def LocalQuery ( query ) : [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] code = sock . connect_ex ( ( [string] , constants . CLIENT_PORT ) ) [EOL] if code != [number] : return None [EOL] compression . Send ( query , sock ) [EOL] compression . Send ( constants . END_OF_STREAM , sock ) [EOL] rec = compression . Receiver ( sock ) [EOL] data = None [EOL] while not rec . IsDone ( ) : [EOL] data = rec . Current ( ) [EOL] assert data [ [number] ] == query [ [number] ] [EOL] data = data [ [number] ] [EOL] rec . Advance ( ) [EOL] sock . close ( ) [EOL] return data [EOL] [EOL] [EOL] class LocalHandler ( SocketServer . BaseRequestHandler ) : [EOL] def handle ( self ) : [EOL] rec = compression . Receiver ( self . request ) [EOL] while not rec . IsDone ( ) : [EOL] data = rec . Current ( ) [EOL] action = data [ [number] ] [EOL] [EOL] if action == constants . REQUEST_PEERS : [EOL] with self . server . daemon . peer_list_lock : [EOL] response = [ p . Pack ( ) for p in self . server . daemon . peers if p . trusting_me ] [EOL] compression . Send ( [ action , response ] , self . request ) [EOL] [EOL] elif action == constants . UNRESPONSIVE_PEER : [EOL] self . server . daemon . DeletePeer ( data [ [number] ] ) [EOL] [EOL] elif action == constants . REQUEST_PUBKEY_FINGERPRINT : [EOL] compression . Send ( [ action , self . server . daemon . pubkey_fingerprint ] , self . request ) [EOL] [EOL] elif action == constants . REQUEST_STATUS : [EOL] compression . Send ( [ action , self . _GetStatusMessage ( ) ] , self . request ) [EOL] [EOL] elif action == constants . ADD_TRUSTED : [EOL] fingerprint = self . server . daemon . CopyToTrusted ( data [ [number] ] ) [EOL] compression . Send ( [ action , fingerprint ] , self . request ) [EOL] [EOL] elif action == constants . INFORM_DURATION : [EOL] test_key = data [ [number] ] [EOL] test_duration = data [ [number] ] [EOL] arch = data [ [number] ] [EOL] mode = data [ [number] ] [EOL] self . server . daemon . AddPerfData ( test_key , test_duration , arch , mode ) [EOL] [EOL] elif action == constants . UPDATE_PERF : [EOL] address = data [ [number] ] [EOL] perf = data [ [number] ] [EOL] self . server . daemon . UpdatePeerPerformance ( data [ [number] ] , data [ [number] ] ) [EOL] [EOL] rec . Advance ( ) [EOL] compression . Send ( constants . END_OF_STREAM , self . request ) [EOL] [EOL] def _GetStatusMessage ( self ) : [EOL] sio = StringIO . StringIO ( ) [EOL] sio . write ( [string] ) [EOL] with self . server . daemon . peer_list_lock : [EOL] for p in self . server . daemon . peers : [EOL] sio . write ( [string] % p ) [EOL] sio . write ( [string] % ( self . server . daemon . jobs , self . server . daemon . relative_perf ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] result = sio . getvalue ( ) [EOL] sio . close ( ) [EOL] return result [EOL] [EOL] [EOL] class LocalSocketServer ( SocketServer . ThreadingMixIn , SocketServer . TCPServer ) : [EOL] def __init__ ( self , daemon ) : [EOL] SocketServer . TCPServer . __init__ ( self , ( [string] , constants . CLIENT_PORT ) , LocalHandler ) [EOL] self . daemon = daemon [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import base64 [EOL] import os [EOL] import subprocess [EOL] [EOL] [EOL] def ReadFileAndSignature ( filename ) : [EOL] with open ( filename , [string] ) as f : [EOL] file_contents = base64 . b64encode ( f . read ( ) ) [EOL] signature_file = filename + [string] [EOL] if ( not os . path . exists ( signature_file ) or os . path . getmtime ( signature_file ) < os . path . getmtime ( filename ) ) : [EOL] private_key = [string] [EOL] code = subprocess . call ( [string] % ( signature_file , private_key , filename ) , shell = True ) [EOL] if code != [number] : return [ None , code ] [EOL] with open ( signature_file ) as f : [EOL] signature = base64 . b64encode ( f . read ( ) ) [EOL] return [ file_contents , signature ] [EOL] [EOL] [EOL] def VerifySignature ( filename , file_contents , signature , pubkeyfile ) : [EOL] with open ( filename , [string] ) as f : [EOL] f . write ( base64 . b64decode ( file_contents ) ) [EOL] signature_file = filename + [string] [EOL] with open ( signature_file , [string] ) as f : [EOL] f . write ( base64 . b64decode ( signature ) ) [EOL] code = subprocess . call ( [string] % ( pubkeyfile , signature_file , filename ) , shell = True ) [EOL] matched = ( code == [number] ) [EOL] if not matched : [EOL] os . remove ( signature_file ) [EOL] os . remove ( filename ) [EOL] return matched [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import cStringIO as StringIO [EOL] try : [EOL] import ujson as json [EOL] except ImportError : [EOL] import json [EOL] import os [EOL] import struct [EOL] import zlib [EOL] [EOL] from . import constants [EOL] [EOL] def Send ( obj , sock ) : [EOL] [docstring] [EOL] obj = json . dumps ( obj ) [EOL] compression_level = [number] [comment] [EOL] compressed = zlib . compress ( obj , compression_level ) [EOL] payload = struct . pack ( [string] , len ( compressed ) ) + compressed [EOL] sock . sendall ( payload ) [EOL] [EOL] [EOL] class Receiver ( object ) : [EOL] def __init__ ( self , sock ) : [EOL] self . sock = sock [EOL] self . data = StringIO . StringIO ( ) [EOL] self . datalength = [number] [EOL] self . _next = self . _GetNext ( ) [EOL] [EOL] def IsDone ( self ) : [EOL] return self . _next == None [EOL] [EOL] def Current ( self ) : [EOL] return self . _next [EOL] [EOL] def Advance ( self ) : [EOL] try : [EOL] self . _next = self . _GetNext ( ) [EOL] except : [EOL] raise [EOL] [EOL] def _GetNext ( self ) : [EOL] try : [EOL] while self . datalength < constants . SIZE_T : [EOL] try : [EOL] chunk = self . sock . recv ( [number] ) [EOL] except : [EOL] raise [EOL] if not chunk : return None [EOL] self . _AppendData ( chunk ) [EOL] size = self . _PopData ( constants . SIZE_T ) [EOL] size = struct . unpack ( [string] , size ) [ [number] ] [EOL] while self . datalength < size : [EOL] try : [EOL] chunk = self . sock . recv ( [number] ) [EOL] except : [EOL] raise [EOL] if not chunk : return None [EOL] self . _AppendData ( chunk ) [EOL] result = self . _PopData ( size ) [EOL] result = zlib . decompress ( result ) [EOL] result = json . loads ( result ) [EOL] if result == constants . END_OF_STREAM : [EOL] return None [EOL] return result [EOL] except : [EOL] raise [EOL] [EOL] def _AppendData ( self , new ) : [EOL] self . data . seek ( [number] , os . SEEK_END ) [EOL] self . data . write ( new ) [EOL] self . datalength += len ( new ) [EOL] [EOL] def _PopData ( self , length ) : [EOL] self . data . seek ( [number] ) [EOL] chunk = self . data . read ( length ) [EOL] remaining = self . data . read ( ) [EOL] self . data . close ( ) [EOL] self . data = StringIO . StringIO ( ) [EOL] self . data . write ( remaining ) [EOL] assert self . datalength - length == len ( remaining ) [EOL] self . datalength = len ( remaining ) [EOL] return chunk [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Tuple , Any [EOL] import typing [EOL] import socket [EOL] import socket [EOL] import SocketServer [EOL] [EOL] from . import compression [EOL] from . import constants [EOL] [EOL] [EOL] def _StatusQuery ( peer , query ) : [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] code = sock . connect_ex ( ( peer . address , constants . STATUS_PORT ) ) [EOL] if code != [number] : [EOL] [comment] [EOL] return [EOL] compression . Send ( query , sock ) [EOL] compression . Send ( constants . END_OF_STREAM , sock ) [EOL] rec = compression . Receiver ( sock ) [EOL] data = None [EOL] while not rec . IsDone ( ) : [EOL] data = rec . Current ( ) [EOL] assert data [ [number] ] == query [ [number] ] [EOL] data = data [ [number] ] [EOL] rec . Advance ( ) [EOL] sock . close ( ) [EOL] return data [EOL] [EOL] [EOL] def RequestTrustedPubkeys ( peer , server ) : [EOL] pubkey_list = _StatusQuery ( peer , [ constants . LIST_TRUSTED_PUBKEYS ] ) [EOL] for pubkey in pubkey_list : [EOL] if server . IsTrusted ( pubkey ) : continue [EOL] result = _StatusQuery ( peer , [ constants . GET_SIGNED_PUBKEY , pubkey ] ) [EOL] server . AcceptNewTrusted ( result ) [EOL] [EOL] [EOL] def NotifyNewTrusted ( peer , data ) : [EOL] _StatusQuery ( peer , [ constants . NOTIFY_NEW_TRUSTED ] + data ) [EOL] [EOL] [EOL] def ITrustYouNow ( peer ) : [EOL] _StatusQuery ( peer , [ constants . TRUST_YOU_NOW ] ) [EOL] [EOL] [EOL] def TryTransitiveTrust ( peer , pubkey , server ) : [EOL] if _StatusQuery ( peer , [ constants . DO_YOU_TRUST , pubkey ] ) : [EOL] result = _StatusQuery ( peer , [ constants . GET_SIGNED_PUBKEY , pubkey ] ) [EOL] server . AcceptNewTrusted ( result ) [EOL] [EOL] [EOL] class StatusHandler ( SocketServer . BaseRequestHandler ) : [EOL] def handle ( self ) : [EOL] rec = compression . Receiver ( self . request ) [EOL] while not rec . IsDone ( ) : [EOL] data = rec . Current ( ) [EOL] action = data [ [number] ] [EOL] [EOL] if action == constants . LIST_TRUSTED_PUBKEYS : [EOL] response = self . server . daemon . ListTrusted ( ) [EOL] compression . Send ( [ action , response ] , self . request ) [EOL] [EOL] elif action == constants . GET_SIGNED_PUBKEY : [EOL] response = self . server . daemon . SignTrusted ( data [ [number] ] ) [EOL] compression . Send ( [ action , response ] , self . request ) [EOL] [EOL] elif action == constants . NOTIFY_NEW_TRUSTED : [EOL] self . server . daemon . AcceptNewTrusted ( data [ [number] : ] ) [EOL] pass [comment] [EOL] [EOL] elif action == constants . TRUST_YOU_NOW : [EOL] self . server . daemon . MarkPeerAsTrusting ( self . client_address [ [number] ] ) [EOL] pass [comment] [EOL] [EOL] elif action == constants . DO_YOU_TRUST : [EOL] response = self . server . daemon . IsTrusted ( data [ [number] ] ) [EOL] compression . Send ( [ action , response ] , self . request ) [EOL] [EOL] rec . Advance ( ) [EOL] compression . Send ( constants . END_OF_STREAM , self . request ) [EOL] [EOL] [EOL] class StatusSocketServer ( SocketServer . ThreadingMixIn , SocketServer . TCPServer ) : [EOL] def __init__ ( self , daemon ) : [EOL] address = ( daemon . ip , constants . STATUS_PORT ) [EOL] SocketServer . TCPServer . __init__ ( self , address , StatusHandler ) [EOL] self . daemon = daemon [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,builtins.int]$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import optparse [EOL] [docstring] [EOL] [EOL] [EOL] import optparse [EOL] import os . path [EOL] import sys [EOL] [EOL] [EOL] def GeneratorMain ( argv ) : [EOL] parser = optparse . OptionParser ( ) [EOL] parser . add_option ( [string] , action = [string] ) [EOL] parser . add_option ( [string] , action = [string] ) [EOL] parser . add_option ( [string] ) [EOL] parser . add_option ( [string] , default = [string] ) [EOL] parser . add_option ( [string] , action = [string] ) [EOL] parser . add_option ( [string] , action = [string] ) [EOL] parser . add_option ( [string] , action = [string] ) [EOL] [EOL] options , args = parser . parse_args ( argv ) [EOL] [EOL] if not options . headers_root : [EOL] parser . error ( [string] ) [EOL] if not options . output_directory : [EOL] parser . error ( [string] ) [EOL] if not args : [EOL] parser . error ( [string] ) [EOL] [EOL] source_tree_root = os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) ) [EOL] [EOL] for root in options . headers_root : [EOL] target_directory = os . path . join ( options . output_directory , os . path . relpath ( root , source_tree_root ) ) [EOL] if options . generate and not os . path . exists ( target_directory ) : [EOL] os . makedirs ( target_directory ) [EOL] [EOL] for header_spec in args : [EOL] if [string] in header_spec : [EOL] ( header_filename , include_before , include_after ) = header_spec . split ( [string] , [number] ) [EOL] else : [EOL] header_filename = header_spec [EOL] include_before = [string] [EOL] include_after = [string] [EOL] if options . outputs : [EOL] yield os . path . join ( target_directory , header_filename ) [EOL] if options . generate : [EOL] with open ( os . path . join ( target_directory , header_filename ) , [string] ) as f : [EOL] if options . define : [EOL] for define in options . define : [EOL] key , value = define . split ( [string] , [number] ) [EOL] [comment] [EOL] [comment] [EOL] f . write ( [string] % key ) [EOL] f . write ( [string] % key ) [EOL] f . write ( [string] % ( key , value ) ) [EOL] [EOL] if include_before : [EOL] for header in include_before . split ( [string] ) : [EOL] f . write ( [string] % header ) [EOL] [EOL] include_target = options . prefix + header_filename [EOL] if options . use_include_next : [EOL] f . write ( [string] % include_target ) [EOL] else : [EOL] f . write ( [string] % include_target ) [EOL] [EOL] if include_after : [EOL] for header in include_after . split ( [string] ) : [EOL] f . write ( [string] % header ) [EOL] [EOL] if options . define : [EOL] for define in options . define : [EOL] key , value = define . split ( [string] , [number] ) [EOL] [comment] [EOL] [comment] [EOL] f . write ( [string] % key ) [EOL] [EOL] [EOL] def DoMain ( argv ) : [EOL] return [string] . join ( GeneratorMain ( argv ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] DoMain ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Match [EOL] import typing [EOL] import os [EOL] import re [EOL] import subprocess [EOL] import sys [EOL] [EOL] [EOL] def DoMain ( * args ) : [EOL] cc = os . environ . get ( [string] , [string] ) [EOL] stdin , stderr = os . pipe ( ) [EOL] subprocess . call ( [ cc , [string] ] , stderr = stderr ) [EOL] output = os . read ( stdin , [number] ) [EOL] match = re . search ( [string] , output ) [EOL] if match : [EOL] print ( match . group ( [number] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] DoMain ( * sys . argv ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , List , Optional , Any , Tuple , Match , Callable [EOL] import typing [EOL] import os [EOL] import re [EOL] import sys [EOL] [EOL] [EOL] def get_libuv_version ( ) : [EOL] with open ( [string] ) as f : [EOL] data = f . read ( ) [EOL] try : [EOL] m = re . search ( [string] , data , re . MULTILINE ) [EOL] major = int ( m . group ( [number] ) ) [EOL] m = re . search ( [string] , data , re . MULTILINE ) [EOL] minor = int ( m . group ( [number] ) ) [EOL] m = re . search ( [string] , data , re . MULTILINE ) [EOL] patch = int ( m . group ( [number] ) ) [EOL] m = re . search ( [string] , data , re . MULTILINE ) [EOL] is_release = int ( m . group ( [number] ) ) [EOL] m = re . search ( [string] , data , re . MULTILINE ) [EOL] suffix = m . group ( [number] ) [EOL] return [string] % ( major , minor , patch , [string] % suffix if not is_release else [string] ) [EOL] except Exception : [EOL] return [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = [string] [EOL] copyright = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = get_libuv_version ( ) [EOL] [comment] [EOL] release = version [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] html_title = [string] [EOL] [EOL] [comment] [EOL] html_short_title = [string] % version [EOL] [EOL] [comment] [EOL] [comment] [EOL] html_logo = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_favicon = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( [string] , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( [string] , [string] , [string] , [ [string] ] , [number] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_title = [string] [EOL] epub_author = [string] [EOL] epub_publisher = [string] [EOL] epub_copyright = [string] [EOL] [EOL] [comment] [EOL] epub_basename = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_exclude_files = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Callable , Generator , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] PYLINT_BLACKLIST = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] PYLINT_DISABLED_WARNINGS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def CheckChangeOnUpload ( input_api , output_api ) : [EOL] report = [ ] [EOL] report . extend ( input_api . canned_checks . PanProjectChecks ( input_api , output_api ) ) [EOL] return report [EOL] [EOL] [EOL] def CheckChangeOnCommit ( input_api , output_api ) : [EOL] report = [ ] [EOL] [EOL] [comment] [EOL] current_year = int ( input_api . time . strftime ( [string] ) ) [EOL] allowed_years = ( str ( s ) for s in reversed ( xrange ( [number] , current_year + [number] ) ) ) [EOL] years_re = [string] + [string] . join ( allowed_years ) + [string] [EOL] [EOL] [comment] [EOL] license = ( [string] [string] [string] [string] ) % { [string] : years_re , } [EOL] [EOL] report . extend ( input_api . canned_checks . PanProjectChecks ( input_api , output_api , license_header = license ) ) [EOL] report . extend ( input_api . canned_checks . CheckTreeIsOpen ( input_api , output_api , [string] , [string] ) ) [EOL] [EOL] import os [EOL] import sys [EOL] old_sys_path = sys . path [EOL] try : [EOL] sys . path = [ [string] , [string] ] + sys . path [EOL] blacklist = PYLINT_BLACKLIST [EOL] if sys . platform == [string] : [EOL] blacklist = [ os . path . normpath ( x ) . replace ( [string] , [string] ) for x in PYLINT_BLACKLIST ] [EOL] report . extend ( input_api . canned_checks . RunPylint ( input_api , output_api , black_list = blacklist , disabled_warnings = PYLINT_DISABLED_WARNINGS ) ) [EOL] finally : [EOL] sys . path = old_sys_path [EOL] return report [EOL] [EOL] [EOL] def GetPreferredTrySlaves ( ) : [EOL] return [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import random [EOL] [EOL] import gyp . common [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] import hashlib [EOL] _new_md5 = hashlib . md5 [EOL] except ImportError : [EOL] import md5 [EOL] _new_md5 = md5 . new [EOL] [EOL] [EOL] [comment] [EOL] random . seed ( ) [EOL] [EOL] [comment] [EOL] ENTRY_TYPE_GUIDS = { [string] : [string] , [string] : [string] , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def MakeGuid ( name , seed = [string] ) : [EOL] [docstring] [EOL] [comment] [EOL] d = _new_md5 ( str ( seed ) + str ( name ) ) . hexdigest ( ) . upper ( ) [EOL] [comment] [EOL] guid = ( [string] + d [ : [number] ] + [string] + d [ [number] : [number] ] + [string] + d [ [number] : [number] ] + [string] + d [ [number] : [number] ] + [string] + d [ [number] : [number] ] + [string] ) [EOL] return guid [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class MSVSSolutionEntry ( object ) : [EOL] def __cmp__ ( self , other ) : [EOL] [comment] [EOL] return cmp ( ( self . name , self . get_guid ( ) ) , ( other . name , other . get_guid ( ) ) ) [EOL] [EOL] [EOL] class MSVSFolder ( MSVSSolutionEntry ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , name = None , entries = None , guid = None , items = None ) : [EOL] [docstring] [EOL] if name : [EOL] self . name = name [EOL] else : [EOL] [comment] [EOL] self . name = os . path . basename ( path ) [EOL] [EOL] self . path = path [EOL] self . guid = guid [EOL] [EOL] [comment] [EOL] self . entries = sorted ( list ( entries or [ ] ) ) [EOL] self . items = list ( items or [ ] ) [EOL] [EOL] self . entry_type_guid = ENTRY_TYPE_GUIDS [ [string] ] [EOL] [EOL] def get_guid ( self ) : [EOL] if self . guid is None : [EOL] [comment] [EOL] self . guid = MakeGuid ( self . path , seed = [string] ) [EOL] return self . guid [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class MSVSProject ( MSVSSolutionEntry ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , name = None , dependencies = None , guid = None , spec = None , build_file = None , config_platform_overrides = None , fixpath_prefix = None ) : [EOL] [docstring] [EOL] self . path = path [EOL] self . guid = guid [EOL] self . spec = spec [EOL] self . build_file = build_file [EOL] [comment] [EOL] self . name = name or os . path . splitext ( os . path . basename ( path ) ) [ [number] ] [EOL] [EOL] [comment] [EOL] self . dependencies = list ( dependencies or [ ] ) [EOL] [EOL] self . entry_type_guid = ENTRY_TYPE_GUIDS [ [string] ] [EOL] [EOL] if config_platform_overrides : [EOL] self . config_platform_overrides = config_platform_overrides [EOL] else : [EOL] self . config_platform_overrides = { } [EOL] self . fixpath_prefix = fixpath_prefix [EOL] self . msbuild_toolset = None [EOL] [EOL] def set_dependencies ( self , dependencies ) : [EOL] self . dependencies = list ( dependencies or [ ] ) [EOL] [EOL] def get_guid ( self ) : [EOL] if self . guid is None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . guid = MakeGuid ( self . name ) [EOL] return self . guid [EOL] [EOL] def set_msbuild_toolset ( self , msbuild_toolset ) : [EOL] self . msbuild_toolset = msbuild_toolset [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class MSVSSolution : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , version , entries = None , variants = None , websiteProperties = True ) : [EOL] [docstring] [EOL] self . path = path [EOL] self . websiteProperties = websiteProperties [EOL] self . version = version [EOL] [EOL] [comment] [EOL] self . entries = list ( entries or [ ] ) [EOL] [EOL] if variants : [EOL] [comment] [EOL] self . variants = variants [ : ] [EOL] else : [EOL] [comment] [EOL] self . variants = [ [string] , [string] ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . Write ( ) [EOL] [EOL] [EOL] def Write ( self , writer = gyp . common . WriteOnDiff ) : [EOL] [docstring] [EOL] [comment] [EOL] all_entries = set ( ) [EOL] entries_to_check = self . entries [ : ] [EOL] while entries_to_check : [EOL] e = entries_to_check . pop ( [number] ) [EOL] [EOL] [comment] [EOL] if e in all_entries : [EOL] continue [EOL] [EOL] all_entries . add ( e ) [EOL] [EOL] [comment] [EOL] if isinstance ( e , MSVSFolder ) : [EOL] entries_to_check += e . entries [EOL] [EOL] all_entries = sorted ( all_entries ) [EOL] [EOL] [comment] [EOL] f = writer ( self . path ) [EOL] f . write ( [string] [string] % self . version . SolutionVersion ( ) ) [EOL] f . write ( [string] % self . version . Description ( ) ) [EOL] [EOL] [comment] [EOL] sln_root = os . path . split ( self . path ) [ [number] ] [EOL] for e in all_entries : [EOL] relative_path = gyp . common . RelativePath ( e . path , sln_root ) [EOL] [comment] [EOL] [comment] [EOL] folder_name = relative_path . replace ( [string] , [string] ) or [string] [EOL] f . write ( [string] % ( e . entry_type_guid , e . name , folder_name , e . get_guid ( ) , ) ) [EOL] [EOL] [comment] [EOL] if self . websiteProperties : [EOL] f . write ( [string] [string] [string] [string] ) [EOL] [EOL] if isinstance ( e , MSVSFolder ) : [EOL] if e . items : [EOL] f . write ( [string] ) [EOL] for i in e . items : [EOL] f . write ( [string] % ( i , i ) ) [EOL] f . write ( [string] ) [EOL] [EOL] if isinstance ( e , MSVSProject ) : [EOL] if e . dependencies : [EOL] f . write ( [string] ) [EOL] for d in e . dependencies : [EOL] f . write ( [string] % ( d . get_guid ( ) , d . get_guid ( ) ) ) [EOL] f . write ( [string] ) [EOL] [EOL] f . write ( [string] ) [EOL] [EOL] [comment] [EOL] f . write ( [string] ) [EOL] [EOL] [comment] [EOL] f . write ( [string] ) [EOL] for v in self . variants : [EOL] f . write ( [string] % ( v , v ) ) [EOL] f . write ( [string] ) [EOL] [EOL] [comment] [EOL] config_guids = [ ] [EOL] config_guids_overrides = { } [EOL] for e in all_entries : [EOL] if isinstance ( e , MSVSProject ) : [EOL] config_guids . append ( e . get_guid ( ) ) [EOL] config_guids_overrides [ e . get_guid ( ) ] = e . config_platform_overrides [EOL] config_guids . sort ( ) [EOL] [EOL] f . write ( [string] ) [EOL] for g in config_guids : [EOL] for v in self . variants : [EOL] nv = config_guids_overrides [ g ] . get ( v , v ) [EOL] [comment] [EOL] [comment] [EOL] f . write ( [string] % ( g , v , nv , ) ) [EOL] [EOL] [comment] [EOL] f . write ( [string] % ( g , v , nv , ) ) [EOL] f . write ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] f . write ( [string] ) [EOL] f . write ( [string] ) [EOL] f . write ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if any ( [ e . entries for e in all_entries if isinstance ( e , MSVSFolder ) ] ) : [EOL] f . write ( [string] ) [EOL] for e in all_entries : [EOL] if not isinstance ( e , MSVSFolder ) : [EOL] continue [comment] [EOL] for subentry in e . entries : [EOL] f . write ( [string] % ( subentry . get_guid ( ) , e . get_guid ( ) ) ) [EOL] f . write ( [string] ) [EOL] [EOL] f . write ( [string] ) [EOL] [EOL] f . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Dict , Union , List , Literal , Any , Type , Tuple , Iterator [EOL] import typing [EOL] import subprocess [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] import os [EOL] import re [EOL] import subprocess [EOL] import sys [EOL] [EOL] import gyp . MSVSVersion [EOL] [EOL] windows_quoter_regex = re . compile ( [string] ) [EOL] [EOL] def QuoteForRspFile ( arg ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] arg = windows_quoter_regex . sub ( lambda mo : [number] * mo . group ( [number] ) + [string] , arg ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] arg = arg . replace ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] return [string] + arg + [string] [EOL] [EOL] [EOL] def EncodeRspFileList ( args ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not args : return [string] [EOL] if args [ [number] ] . startswith ( [string] ) : [EOL] call , program = args [ [number] ] . split ( [string] , [number] ) [EOL] program = call + [string] + os . path . normpath ( program ) [EOL] else : [EOL] program = os . path . normpath ( args [ [number] ] ) [EOL] return program + [string] + [string] . join ( QuoteForRspFile ( arg ) for arg in args [ [number] : ] ) [EOL] [EOL] [EOL] def _GenericRetrieve ( root , default , path ) : [EOL] [docstring] [EOL] if not root : [EOL] return default [EOL] if not path : [EOL] return root [EOL] return _GenericRetrieve ( root . get ( path [ [number] ] ) , default , path [ [number] : ] ) [EOL] [EOL] [EOL] def _AddPrefix ( element , prefix ) : [EOL] [docstring] [EOL] if element is None : [EOL] return element [EOL] [comment] [EOL] if isinstance ( element , list ) or isinstance ( element , tuple ) : [EOL] return [ prefix + e for e in element ] [EOL] else : [EOL] return prefix + element [EOL] [EOL] [EOL] def _DoRemapping ( element , map ) : [EOL] [docstring] [EOL] if map is not None and element is not None : [EOL] if not callable ( map ) : [EOL] map = map . get [comment] [EOL] if isinstance ( element , list ) or isinstance ( element , tuple ) : [EOL] element = filter ( None , [ map ( elem ) for elem in element ] ) [EOL] else : [EOL] element = map ( element ) [EOL] return element [EOL] [EOL] [EOL] def _AppendOrReturn ( append , element ) : [EOL] [docstring] [EOL] if append is not None and element is not None : [EOL] if isinstance ( element , list ) or isinstance ( element , tuple ) : [EOL] append . extend ( element ) [EOL] else : [EOL] append . append ( element ) [EOL] else : [EOL] return element [EOL] [EOL] [EOL] def _FindDirectXInstallation ( ) : [EOL] [docstring] [EOL] [comment] [EOL] if hasattr ( _FindDirectXInstallation , [string] ) : [EOL] return _FindDirectXInstallation . dxsdk_dir [EOL] [EOL] dxsdk_dir = os . environ . get ( [string] ) [EOL] if not dxsdk_dir : [EOL] [comment] [EOL] cmd = [ [string] , [string] , [string] , [string] ] [EOL] p = subprocess . Popen ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] for line in p . communicate ( ) [ [number] ] . splitlines ( ) : [EOL] if [string] in line : [EOL] dxsdk_dir = line . split ( [string] ) [ [number] ] + [string] [EOL] [EOL] [comment] [EOL] _FindDirectXInstallation . dxsdk_dir = dxsdk_dir [EOL] return dxsdk_dir [EOL] [EOL] [EOL] class MsvsSettings ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , spec , generator_flags ) : [EOL] self . spec = spec [EOL] self . vs_version = GetVSVersion ( generator_flags ) [EOL] self . dxsdk_dir = _FindDirectXInstallation ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . wdk_dir = os . environ . get ( [string] ) [EOL] [EOL] supported_fields = [ ( [string] , dict ) , ( [string] , dict ) , ( [string] , list ) , ( [string] , list ) , ( [string] , str ) , ( [string] , str ) , ( [string] , str ) , ( [string] , str ) , ] [EOL] configs = spec [ [string] ] [EOL] for field , default in supported_fields : [EOL] setattr ( self , field , { } ) [EOL] for configname , config in configs . iteritems ( ) : [EOL] getattr ( self , field ) [ configname ] = config . get ( field , default ( ) ) [EOL] [EOL] self . msvs_cygwin_dirs = spec . get ( [string] , [ [string] ] ) [EOL] [EOL] def GetVSMacroEnv ( self , base_to_build = None , config = None ) : [EOL] [docstring] [EOL] target_platform = [string] if self . GetArch ( config ) == [string] else [string] [EOL] target_name = self . spec . get ( [string] , [string] ) + self . spec . get ( [string] , self . spec [ [string] ] ) [EOL] target_dir = base_to_build + [string] if base_to_build else [string] [EOL] replacements = { [string] : target_dir , [string] : target_dir , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . spec [ [string] ] , [string] : target_name , [string] : target_platform , [string] : [string] , } [EOL] [comment] [EOL] [comment] [EOL] if self . vs_version . Path ( ) : [EOL] replacements [ [string] ] = self . vs_version . Path ( ) [EOL] replacements [ [string] ] = os . path . join ( self . vs_version . Path ( ) , [string] ) + [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] replacements [ [string] ] = self . dxsdk_dir if self . dxsdk_dir else [string] [EOL] replacements [ [string] ] = self . wdk_dir if self . wdk_dir else [string] [EOL] return replacements [EOL] [EOL] def ConvertVSMacros ( self , s , base_to_build = None , config = None ) : [EOL] [docstring] [EOL] env = self . GetVSMacroEnv ( base_to_build , config = config ) [EOL] return ExpandMacros ( s , env ) [EOL] [EOL] def AdjustLibraries ( self , libraries ) : [EOL] [docstring] [EOL] libs = [ lib [ [number] : ] if lib . startswith ( [string] ) else lib for lib in libraries ] [EOL] return [ lib + [string] if not lib . endswith ( [string] ) else lib for lib in libs ] [EOL] [EOL] def _GetAndMunge ( self , field , path , default , prefix , append , map ) : [EOL] [docstring] [EOL] result = _GenericRetrieve ( field , default , path ) [EOL] result = _DoRemapping ( result , map ) [EOL] result = _AddPrefix ( result , prefix ) [EOL] return _AppendOrReturn ( append , result ) [EOL] [EOL] class _GetWrapper ( object ) : [EOL] def __init__ ( self , parent , field , base_path , append = None ) : [EOL] self . parent = parent [EOL] self . field = field [EOL] self . base_path = [ base_path ] [EOL] self . append = append [EOL] def __call__ ( self , name , map = None , prefix = [string] , default = None ) : [EOL] return self . parent . _GetAndMunge ( self . field , self . base_path + [ name ] , default = default , prefix = prefix , append = self . append , map = map ) [EOL] [EOL] def GetArch ( self , config ) : [EOL] [docstring] [EOL] configuration_platform = self . msvs_configuration_platform . get ( config , [string] ) [EOL] platform = self . msvs_target_platform . get ( config , [string] ) [EOL] if not platform : [comment] [EOL] platform = configuration_platform [EOL] [comment] [EOL] return { [string] : [string] , [string] : [string] } . get ( platform , [string] ) [EOL] [EOL] def _TargetConfig ( self , config ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] arch = self . GetArch ( config ) [EOL] if arch == [string] and not config . endswith ( [string] ) : [EOL] config += [string] [EOL] if arch == [string] and config . endswith ( [string] ) : [EOL] config = config . rsplit ( [string] , [number] ) [ [number] ] [EOL] return config [EOL] [EOL] def _Setting ( self , path , config , default = None , prefix = [string] , append = None , map = None ) : [EOL] [docstring] [EOL] return self . _GetAndMunge ( self . msvs_settings [ config ] , path , default , prefix , append , map ) [EOL] [EOL] def _ConfigAttrib ( self , path , config , default = None , prefix = [string] , append = None , map = None ) : [EOL] [docstring] [EOL] return self . _GetAndMunge ( self . msvs_configuration_attributes [ config ] , path , default , prefix , append , map ) [EOL] [EOL] def AdjustIncludeDirs ( self , include_dirs , config ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] includes = include_dirs + self . msvs_system_include_dirs [ config ] [EOL] includes . extend ( self . _Setting ( ( [string] , [string] ) , config , default = [ ] ) ) [EOL] return [ self . ConvertVSMacros ( p , config = config ) for p in includes ] [EOL] [EOL] def GetComputedDefines ( self , config ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] defines = [ ] [EOL] if self . _ConfigAttrib ( [ [string] ] , config ) == [string] : [EOL] defines . extend ( ( [string] , [string] ) ) [EOL] if self . _ConfigAttrib ( [ [string] ] , config ) == [string] : [EOL] defines . append ( [string] ) [EOL] defines . extend ( self . _Setting ( ( [string] , [string] ) , config , default = [ ] ) ) [EOL] return defines [EOL] [EOL] def GetCompilerPdbName ( self , config , expand_special ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] pdbname = self . _Setting ( ( [string] , [string] ) , config ) [EOL] if pdbname : [EOL] pdbname = expand_special ( self . ConvertVSMacros ( pdbname ) ) [EOL] return pdbname [EOL] [EOL] def GetMapFileName ( self , config , expand_special ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] map_file = self . _Setting ( ( [string] , [string] ) , config ) [EOL] if map_file : [EOL] map_file = expand_special ( self . ConvertVSMacros ( map_file , config = config ) ) [EOL] return map_file [EOL] [EOL] def GetOutputName ( self , config , expand_special ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] type = self . spec [ [string] ] [EOL] root = [string] if type == [string] else [string] [EOL] [comment] [EOL] output_file = self . _Setting ( ( root , [string] ) , config ) [EOL] if output_file : [EOL] output_file = expand_special ( self . ConvertVSMacros ( output_file , config = config ) ) [EOL] return output_file [EOL] [EOL] def GetPDBName ( self , config , expand_special , default ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] output_file = self . _Setting ( ( [string] , [string] ) , config ) [EOL] generate_debug_info = self . _Setting ( ( [string] , [string] ) , config ) [EOL] if generate_debug_info : [EOL] if output_file : [EOL] return expand_special ( self . ConvertVSMacros ( output_file , config = config ) ) [EOL] else : [EOL] return default [EOL] else : [EOL] return None [EOL] [EOL] def GetCflags ( self , config ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] cflags = [ ] [EOL] cflags . extend ( [ [string] + w for w in self . msvs_disabled_warnings [ config ] ] ) [EOL] cl = self . _GetWrapper ( self , self . msvs_settings [ config ] , [string] , append = cflags ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , prefix = [string] , default = [string] ) [EOL] cl ( [string] , prefix = [string] ) [EOL] cl ( [string] , prefix = [string] ) [EOL] cl ( [string] , map = { [string] : [string] } ) [EOL] cl ( [string] , map = { [string] : [string] } ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] cl ( [string] , map = { [string] : [string] } ) [EOL] cl ( [string] , prefix = [string] ) [EOL] cl ( [string] , map = { [string] : [string] } ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] } ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] } ) [EOL] cl ( [string] , map = { [string] : [string] } ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] } ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] cl ( [string] , map = { [string] : [string] } ) [EOL] cl ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] cl ( [string] , map = { [string] : [string] } ) [EOL] cl ( [string] , prefix = [string] ) [EOL] cflags . extend ( [ [string] + f for f in self . _Setting ( ( [string] , [string] ) , config , default = [ ] ) ] ) [EOL] if self . vs_version . short_name in ( [string] , [string] ) : [EOL] [comment] [EOL] cflags . append ( [string] ) [EOL] [comment] [EOL] cflags = filter ( lambda x : not x . startswith ( [string] ) , cflags ) [EOL] return cflags [EOL] [EOL] def GetPrecompiledHeader ( self , config , gyp_to_build_path ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] return _PchHelper ( self , config , gyp_to_build_path ) [EOL] [EOL] def _GetPchFlags ( self , config , extension ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . msvs_precompiled_header [ config ] : [EOL] source_ext = os . path . splitext ( self . msvs_precompiled_source [ config ] ) [ [number] ] [EOL] if _LanguageMatchesForPch ( source_ext , extension ) : [EOL] pch = os . path . split ( self . msvs_precompiled_header [ config ] ) [ [number] ] [EOL] return [ [string] + pch , [string] + pch , [string] + pch + [string] ] [EOL] return [ ] [EOL] [EOL] def GetCflagsC ( self , config ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] return self . _GetPchFlags ( config , [string] ) [EOL] [EOL] def GetCflagsCC ( self , config ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] return [ [string] ] + self . _GetPchFlags ( config , [string] ) [EOL] [EOL] def _GetAdditionalLibraryDirectories ( self , root , config , gyp_to_build_path ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] libpaths = self . _Setting ( ( root , [string] ) , config , default = [ ] ) [EOL] libpaths = [ os . path . normpath ( gyp_to_build_path ( self . ConvertVSMacros ( p , config = config ) ) ) for p in libpaths ] [EOL] return [ [string] + p + [string] for p in libpaths ] [EOL] [EOL] def GetLibFlags ( self , config , gyp_to_build_path ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] libflags = [ ] [EOL] lib = self . _GetWrapper ( self , self . msvs_settings [ config ] , [string] , append = libflags ) [EOL] libflags . extend ( self . _GetAdditionalLibraryDirectories ( [string] , config , gyp_to_build_path ) ) [EOL] lib ( [string] , map = { [string] : [string] } ) [EOL] lib ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] lib ( [string] ) [EOL] return libflags [EOL] [EOL] def GetDefFile ( self , gyp_to_build_path ) : [EOL] [docstring] [EOL] spec = self . spec [EOL] if spec [ [string] ] in ( [string] , [string] , [string] ) : [EOL] def_files = [ s for s in spec . get ( [string] , [ ] ) if s . endswith ( [string] ) ] [EOL] if len ( def_files ) == [number] : [EOL] return gyp_to_build_path ( def_files [ [number] ] ) [EOL] elif len ( def_files ) > [number] : [EOL] raise Exception ( [string] ) [EOL] return None [EOL] [EOL] def _GetDefFileAsLdflags ( self , ldflags , gyp_to_build_path ) : [EOL] [docstring] [EOL] def_file = self . GetDefFile ( gyp_to_build_path ) [EOL] if def_file : [EOL] ldflags . append ( [string] % def_file ) [EOL] [EOL] def GetPGDName ( self , config , expand_special ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] output_file = self . _Setting ( ( [string] , [string] ) , config ) [EOL] if output_file : [EOL] output_file = expand_special ( self . ConvertVSMacros ( output_file , config = config ) ) [EOL] return output_file [EOL] [EOL] def GetLdflags ( self , config , gyp_to_build_path , expand_special , manifest_base_name , output_name , is_executable , build_dir ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] ldflags = [ ] [EOL] ld = self . _GetWrapper ( self , self . msvs_settings [ config ] , [string] , append = ldflags ) [EOL] self . _GetDefFileAsLdflags ( ldflags , gyp_to_build_path ) [EOL] ld ( [string] , map = { [string] : [string] } ) [EOL] ld ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] ldflags . extend ( self . _GetAdditionalLibraryDirectories ( [string] , config , gyp_to_build_path ) ) [EOL] ld ( [string] , prefix = [string] ) [EOL] ld ( [string] , prefix = [string] , map = { [string] : [string] , [string] : [string] } ) [EOL] out = self . GetOutputName ( config , expand_special ) [EOL] if out : [EOL] ldflags . append ( [string] + out ) [EOL] pdb = self . GetPDBName ( config , expand_special , output_name + [string] ) [EOL] if pdb : [EOL] ldflags . append ( [string] + pdb ) [EOL] pgd = self . GetPGDName ( config , expand_special ) [EOL] if pgd : [EOL] ldflags . append ( [string] + pgd ) [EOL] map_file = self . GetMapFileName ( config , expand_special ) [EOL] ld ( [string] , map = { [string] : [string] + map_file if map_file [EOL] else [string] } ) [EOL] ld ( [string] , map = { [string] : [string] } ) [EOL] ld ( [string] , prefix = [string] ) [EOL] [EOL] minimum_required_version = self . _Setting ( ( [string] , [string] ) , config , default = [string] ) [EOL] if minimum_required_version : [EOL] minimum_required_version = [string] + minimum_required_version [EOL] ld ( [string] , map = { [string] : [string] % minimum_required_version , [string] : [string] % minimum_required_version } , prefix = [string] ) [EOL] [EOL] ld ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] ld ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] ld ( [string] , prefix = [string] ) [EOL] ld ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] ld ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] ld ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] ld ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] ld ( [string] , prefix = [string] ) [EOL] ld ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] ld ( [string] , map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] ld ( [string] , prefix = [string] ) [EOL] ld ( [string] , map = { [string] : [string] } ) [EOL] ld ( [string] , prefix = [string] ) [EOL] ld ( [string] , map = { [string] : [string] } ) [EOL] ld ( [string] , map = { [string] : [string] , [string] : [string] } , prefix = [string] ) [EOL] [comment] [EOL] ld ( [string] , prefix = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] base_flags = filter ( lambda x : [string] in x or x == [string] , ldflags ) [EOL] if not base_flags : [EOL] ldflags . append ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not filter ( lambda x : [string] in x , ldflags ) : [EOL] ldflags . append ( [string] ) [EOL] [EOL] have_def_file = filter ( lambda x : x . startswith ( [string] ) , ldflags ) [EOL] manifest_flags , intermediate_manifest , manifest_files = self . _GetLdManifestFlags ( config , manifest_base_name , gyp_to_build_path , is_executable and not have_def_file , build_dir ) [EOL] ldflags . extend ( manifest_flags ) [EOL] return ldflags , intermediate_manifest , manifest_files [EOL] [EOL] def _GetLdManifestFlags ( self , config , name , gyp_to_build_path , allow_isolation , build_dir ) : [EOL] [docstring] [EOL] generate_manifest = self . _Setting ( ( [string] , [string] ) , config , default = [string] ) [EOL] if generate_manifest != [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [ [string] ] , [ ] , [ ] [EOL] [EOL] output_name = name + [string] [EOL] flags = [ [string] , [string] + output_name , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] flags . append ( [string] ) [EOL] [EOL] config = self . _TargetConfig ( config ) [EOL] enable_uac = self . _Setting ( ( [string] , [string] ) , config , default = [string] ) [EOL] manifest_files = [ ] [EOL] generated_manifest_outer = [string] [string] [string] [EOL] if enable_uac == [string] : [EOL] execution_level = self . _Setting ( ( [string] , [string] ) , config , default = [string] ) [EOL] execution_level_map = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] ui_access = self . _Setting ( ( [string] , [string] ) , config , default = [string] ) [EOL] [EOL] inner = [string] % ( execution_level_map [ execution_level ] , ui_access ) [EOL] else : [EOL] inner = [string] [EOL] [EOL] generated_manifest_contents = generated_manifest_outer % inner [EOL] generated_name = name + [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] build_dir_generated_name = os . path . join ( build_dir , generated_name ) [EOL] gyp . common . EnsureDirExists ( build_dir_generated_name ) [EOL] f = gyp . common . WriteOnDiff ( build_dir_generated_name ) [EOL] f . write ( generated_manifest_contents ) [EOL] f . close ( ) [EOL] manifest_files = [ generated_name ] [EOL] [EOL] if allow_isolation : [EOL] flags . append ( [string] ) [EOL] [EOL] manifest_files += self . _GetAdditionalManifestFiles ( config , gyp_to_build_path ) [EOL] return flags , output_name , manifest_files [EOL] [EOL] def _GetAdditionalManifestFiles ( self , config , gyp_to_build_path ) : [EOL] [docstring] [EOL] files = self . _Setting ( ( [string] , [string] ) , config , default = [ ] ) [EOL] if isinstance ( files , str ) : [EOL] files = files . split ( [string] ) [EOL] return [ os . path . normpath ( gyp_to_build_path ( self . ConvertVSMacros ( f , config = config ) ) ) for f in files ] [EOL] [EOL] def IsUseLibraryDependencyInputs ( self , config ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] uldi = self . _Setting ( ( [string] , [string] ) , config ) [EOL] return uldi == [string] [EOL] [EOL] def IsEmbedManifest ( self , config ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] embed = self . _Setting ( ( [string] , [string] ) , config , default = [string] ) [EOL] return embed == [string] [EOL] [EOL] def IsLinkIncremental ( self , config ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] link_inc = self . _Setting ( ( [string] , [string] ) , config ) [EOL] return link_inc != [string] [EOL] [EOL] def GetRcflags ( self , config , gyp_to_ninja_path ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] rcflags = [ ] [EOL] rc = self . _GetWrapper ( self , self . msvs_settings [ config ] , [string] , append = rcflags ) [EOL] rc ( [string] , map = gyp_to_ninja_path , prefix = [string] ) [EOL] rcflags . append ( [string] + gyp_to_ninja_path ( [string] ) ) [EOL] rc ( [string] , prefix = [string] ) [EOL] [comment] [EOL] rc ( [string] , prefix = [string] , map = lambda x : hex ( int ( x ) ) [ [number] : ] ) [EOL] return rcflags [EOL] [EOL] def BuildCygwinBashCommandLine ( self , args , path_to_base ) : [EOL] [docstring] [EOL] cygwin_dir = os . path . normpath ( os . path . join ( path_to_base , self . msvs_cygwin_dirs [ [number] ] ) ) [EOL] cd = ( [string] % path_to_base ) . replace ( [string] , [string] ) [EOL] args = [ a . replace ( [string] , [string] ) . replace ( [string] , [string] ) for a in args ] [EOL] args = [ [string] % a . replace ( [string] , [string] ) for a in args ] [EOL] bash_cmd = [string] . join ( args ) [EOL] cmd = ( [string] % cygwin_dir + [string] % ( cd , bash_cmd ) ) [EOL] return cmd [EOL] [EOL] def IsRuleRunUnderCygwin ( self , rule ) : [EOL] [docstring] [EOL] return int ( rule . get ( [string] , self . spec . get ( [string] , [number] ) ) ) != [number] [EOL] [EOL] def _HasExplicitRuleForExtension ( self , spec , extension ) : [EOL] [docstring] [EOL] for rule in spec . get ( [string] , [ ] ) : [EOL] if rule [ [string] ] == extension : [EOL] return True [EOL] return False [EOL] [EOL] def HasExplicitIdlRules ( self , spec ) : [EOL] [docstring] [EOL] return self . _HasExplicitRuleForExtension ( spec , [string] ) [EOL] [EOL] def HasExplicitAsmRules ( self , spec ) : [EOL] [docstring] [EOL] return self . _HasExplicitRuleForExtension ( spec , [string] ) [EOL] [EOL] def GetIdlBuildData ( self , source , config ) : [EOL] [docstring] [EOL] config = self . _TargetConfig ( config ) [EOL] midl_get = self . _GetWrapper ( self , self . msvs_settings [ config ] , [string] ) [EOL] def midl ( name , default = None ) : [EOL] return self . ConvertVSMacros ( midl_get ( name , default = default ) , config = config ) [EOL] tlb = midl ( [string] , default = [string] ) [EOL] header = midl ( [string] , default = [string] ) [EOL] dlldata = midl ( [string] , default = [string] ) [EOL] iid = midl ( [string] , default = [string] ) [EOL] proxy = midl ( [string] , default = [string] ) [EOL] [comment] [EOL] [comment] [EOL] outdir = midl ( [string] , default = [string] ) [EOL] output = [ header , dlldata , iid , proxy ] [EOL] variables = [ ( [string] , tlb ) , ( [string] , header ) , ( [string] , dlldata ) , ( [string] , iid ) , ( [string] , proxy ) ] [EOL] [comment] [EOL] target_platform = [string] if self . GetArch ( config ) == [string] else [string] [EOL] flags = [ [string] , [string] , [string] , target_platform , [string] ] [EOL] return outdir , output , variables , flags [EOL] [EOL] [EOL] def _LanguageMatchesForPch ( source_ext , pch_source_ext ) : [EOL] c_exts = ( [string] , ) [EOL] cc_exts = ( [string] , [string] , [string] ) [EOL] return ( ( source_ext in c_exts and pch_source_ext in c_exts ) or ( source_ext in cc_exts and pch_source_ext in cc_exts ) ) [EOL] [EOL] [EOL] class PrecompiledHeader ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , settings , config , gyp_to_build_path , gyp_to_unique_output , obj_ext ) : [EOL] self . settings = settings [EOL] self . config = config [EOL] pch_source = self . settings . msvs_precompiled_source [ self . config ] [EOL] self . pch_source = gyp_to_build_path ( pch_source ) [EOL] filename , _ = os . path . splitext ( pch_source ) [EOL] self . output_obj = gyp_to_unique_output ( filename + obj_ext ) . lower ( ) [EOL] [EOL] def _PchHeader ( self ) : [EOL] [docstring] [EOL] return os . path . split ( self . settings . msvs_precompiled_header [ self . config ] ) [ [number] ] [EOL] [EOL] def GetObjDependencies ( self , sources , objs , arch ) : [EOL] [docstring] [EOL] assert arch is None [EOL] if not self . _PchHeader ( ) : [EOL] return [ ] [EOL] pch_ext = os . path . splitext ( self . pch_source ) [ [number] ] [EOL] for source in sources : [EOL] if _LanguageMatchesForPch ( os . path . splitext ( source ) [ [number] ] , pch_ext ) : [EOL] return [ ( None , None , self . output_obj ) ] [EOL] return [ ] [EOL] [EOL] def GetPchBuildCommands ( self , arch ) : [EOL] [docstring] [EOL] return [ ] [EOL] [EOL] def GetFlagsModifications ( self , input , output , implicit , command , cflags_c , cflags_cc , expand_special ) : [EOL] [docstring] [EOL] if input == self . pch_source : [EOL] pch_output = [ [string] + self . _PchHeader ( ) ] [EOL] if command == [string] : [EOL] return ( [ ( [string] , map ( expand_special , cflags_cc + pch_output ) ) ] , self . output_obj , [ ] ) [EOL] elif command == [string] : [EOL] return ( [ ( [string] , map ( expand_special , cflags_c + pch_output ) ) ] , self . output_obj , [ ] ) [EOL] return [ ] , output , implicit [EOL] [EOL] [EOL] vs_version = None [EOL] def GetVSVersion ( generator_flags ) : [EOL] global vs_version [EOL] if not vs_version : [EOL] vs_version = gyp . MSVSVersion . SelectVisualStudioVersion ( generator_flags . get ( [string] , [string] ) ) [EOL] return vs_version [EOL] [EOL] def _GetVsvarsSetupArgs ( generator_flags , arch ) : [EOL] vs = GetVSVersion ( generator_flags ) [EOL] return vs . SetupScript ( ) [EOL] [EOL] def ExpandMacros ( string , expansions ) : [EOL] [docstring] [EOL] if [string] in string : [EOL] for old , new in expansions . iteritems ( ) : [EOL] assert [string] not in new , new [EOL] string = string . replace ( old , new ) [EOL] return string [EOL] [EOL] def _ExtractImportantEnvironment ( output_of_set ) : [EOL] [docstring] [EOL] envvars_to_save = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] env = { } [EOL] for line in output_of_set . splitlines ( ) : [EOL] for envvar in envvars_to_save : [EOL] if re . match ( envvar + [string] , line . lower ( ) ) : [EOL] var , setting = line . split ( [string] , [number] ) [EOL] if envvar == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] setting = os . path . dirname ( sys . executable ) + os . pathsep + setting [EOL] env [ var . upper ( ) ] = setting [EOL] break [EOL] for required in ( [string] , [string] , [string] ) : [EOL] if required not in env : [EOL] raise Exception ( [string] [string] % required ) [EOL] return env [EOL] [EOL] def _FormatAsEnvironmentBlock ( envvar_dict ) : [EOL] [docstring] [EOL] block = [string] [EOL] nul = [string] [EOL] for key , value in envvar_dict . iteritems ( ) : [EOL] block += key + [string] + value + nul [EOL] block += nul [EOL] return block [EOL] [EOL] def _ExtractCLPath ( output_of_where ) : [EOL] [docstring] [EOL] [comment] [EOL] for line in output_of_where . strip ( ) . splitlines ( ) : [EOL] if line . startswith ( [string] ) : [EOL] return line [ len ( [string] ) : ] . strip ( ) [EOL] [EOL] def GenerateEnvironmentFiles ( toplevel_build_dir , generator_flags , open_out ) : [EOL] [docstring] [EOL] archs = ( [string] , [string] ) [EOL] if generator_flags . get ( [string] , [number] ) : [EOL] cl_paths = { } [EOL] for arch in archs : [EOL] cl_paths [ arch ] = [string] [EOL] return cl_paths [EOL] vs = GetVSVersion ( generator_flags ) [EOL] cl_paths = { } [EOL] for arch in archs : [EOL] [comment] [EOL] args = vs . SetupScript ( arch ) [EOL] args . extend ( ( [string] , [string] ) ) [EOL] popen = subprocess . Popen ( args , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) [EOL] variables , _ = popen . communicate ( ) [EOL] env = _ExtractImportantEnvironment ( variables ) [EOL] env_block = _FormatAsEnvironmentBlock ( env ) [EOL] f = open_out ( os . path . join ( toplevel_build_dir , [string] + arch ) , [string] ) [EOL] f . write ( env_block ) [EOL] f . close ( ) [EOL] [EOL] [comment] [EOL] args = vs . SetupScript ( arch ) [EOL] args . extend ( ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) ) [EOL] popen = subprocess . Popen ( args , shell = True , stdout = subprocess . PIPE ) [EOL] output , _ = popen . communicate ( ) [EOL] cl_paths [ arch ] = _ExtractCLPath ( output ) [EOL] return cl_paths [EOL] [EOL] def VerifyMissingSources ( sources , build_dir , generator_flags , gyp_to_ninja ) : [EOL] [docstring] [EOL] if int ( generator_flags . get ( [string] , [number] ) ) : [EOL] no_specials = filter ( lambda x : [string] not in x , sources ) [EOL] relative = [ os . path . join ( build_dir , gyp_to_ninja ( s ) ) for s in no_specials ] [EOL] missing = filter ( lambda x : not os . path . exists ( x ) , relative ) [EOL] if missing : [EOL] [comment] [EOL] [comment] [EOL] cleaned_up = [ os . path . normpath ( x ) for x in missing ] [EOL] raise Exception ( [string] % [string] . join ( cleaned_up ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def CalculateCommonVariables ( default_variables , params ) : [EOL] generator_flags = params . get ( [string] , { } ) [EOL] [EOL] [comment] [EOL] msvs_version = gyp . msvs_emulation . GetVSVersion ( generator_flags ) [EOL] default_variables [ [string] ] = msvs_version . ShortName ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( [string] in os . environ . get ( [string] , [string] ) or [string] in os . environ . get ( [string] , [string] ) ) : [EOL] default_variables [ [string] ] = [number] [EOL] else : [EOL] default_variables [ [string] ] = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[typing.Union[builtins.dict,builtins.list,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[typing.Union[builtins.dict,builtins.list,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Type[type]$ 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Type[type]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.List[typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Tuple[builtins.str,typing.Any]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] import socket [EOL] [docstring] [EOL] import socket [EOL] import xml . sax [EOL] import errno [EOL] import stat [EOL] import platform [EOL] import logging [EOL] import contextlib [EOL] [EOL] _logger = logging . getLogger ( __name__ ) [EOL] [EOL] @ contextlib . contextmanager def socket_shutter ( sock ) : [EOL] [docstring] [EOL] try : [EOL] yield sock [EOL] finally : [EOL] sock . shutdown ( socket . SHUT_RDWR ) [EOL] sock . close ( ) [EOL] [EOL] [EOL] def is_set ( val , mask ) : [EOL] [docstring] [EOL] [EOL] return val & mask == mask [EOL] [EOL] def is_dir ( attrs ) : [EOL] [docstring] [EOL] [EOL] return stat . S_ISDIR ( attrs . st_mode ) [EOL] [EOL] [EOL] def mock_msg ( cmd , body ) : [EOL] [docstring] [EOL] [EOL] return { [string] : { [string] : [number] , [string] : cmd } , [string] : body , [string] : None } [EOL] [EOL] def try_connect ( url_host , port , success = True , retdict = { } ) : [EOL] [docstring] [EOL] [EOL] s = None [EOL] try : [EOL] s = socket . create_connection ( ( url_host , port ) ) [EOL] except socket . error as err : [EOL] if retdict . has_key ( err . errno ) : [EOL] return retdict [ err . errno ] [EOL] _logger . debug ( [string] + str ( err . errno ) + [string] + str ( retdict ) ) [EOL] raise [EOL] else : [EOL] return success [EOL] finally : [EOL] if s : [EOL] s . shutdown ( socket . SHUT_RDWR ) [EOL] s . close ( ) [EOL] [EOL] def _retdict ( name , val ) : [EOL] rd = { getattr ( errno , name ) : val } [EOL] wsa = [string] + name [EOL] if hasattr ( errno , wsa ) : [EOL] rd [ getattr ( errno , wsa ) ] = val [EOL] return rd [EOL] [EOL] def is_port_available ( url_host , port ) : [EOL] [docstring] [EOL] [EOL] return try_connect ( url_host , port , False , _retdict ( [string] , True ) ) [EOL] [EOL] class NoPortAvailableException ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , url_host , bp , ep ) : [EOL] self . host = url_host [EOL] self . bp = bp [EOL] self . ep = ep [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( _ = self ) [EOL] [EOL] def first_available_port ( url_host , bport , eport ) : [EOL] [docstring] [EOL] [EOL] for p in range ( bport , eport + [number] ) : [EOL] if is_port_available ( url_host , p ) : [EOL] return p ; [EOL] raise NoPortAvailableException ( url_host , bport , eport ) [EOL] [EOL] def html_rep ( obj ) : [EOL] [docstring] [EOL] [EOL] s = str ( obj ) [EOL] if s == [string] : [EOL] s = repr ( obj ) [EOL] return s . strip ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] def get_val ( d , k , default = None ) : [EOL] [docstring] [EOL] if not d . has_key ( k ) : [EOL] return default [EOL] return d [ k ] [EOL] [EOL] def get_fmask ( perm , role ) : [EOL] [docstring] [EOL] return getattr ( stat , [string] + perm + role ) [EOL] [EOL] class Param ( dict ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , val = None , sep = [string] ) : [EOL] if type ( name ) == dict or type ( name ) == Param : [EOL] for k in name . keys ( ) : [EOL] self [ k ] = name [ k ] [EOL] return [EOL] self [ [string] ] = name [EOL] if val : [EOL] self [ [string] ] = val [EOL] self [ [string] ] = sep [EOL] assert self [ [string] ] == name [EOL] [EOL] def __str__ ( self ) : [EOL] if self . has_key ( [string] ) : [EOL] return self [ [string] ] + get_val ( self , [string] , [string] ) + str ( self [ [string] ] ) [EOL] return self [ [string] ] [EOL] [EOL] [EOL] def params_to_cmdv ( executable , params ) : [EOL] return [ executable ] + [ str ( Param ( p ) ) for p in params [ [string] ] ] [EOL] [EOL] class ConvertToPython ( xml . sax . handler . ContentHandler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _estack = [ ] [EOL] [EOL] def startElement ( self , name , attrs ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] a = { } [EOL] for an in attrs . getNames ( ) : [EOL] a [ an ] = attrs . getValue ( an ) [EOL] try : [EOL] a [ an ] = float ( a [ an ] ) [EOL] a [ an ] = int ( a [ an ] ) [EOL] except : [EOL] pass [EOL] self . _estack . append ( [ name , a ] ) [EOL] [EOL] def endElement ( self , name ) : [EOL] [docstring] [EOL] [comment] [EOL] if len ( self . _estack ) > [number] : [EOL] e = self . _estack . pop ( ) [EOL] self . _estack [ - [number] ] . append ( e ) [EOL] [EOL] def get_obj ( self ) : [EOL] [docstring] [EOL] [EOL] assert len ( self . _estack ) == [number] [EOL] return self . _estack [ [number] ] [EOL] [EOL] def xml_to_python ( xml_str ) : [EOL] [docstring] [EOL] [EOL] assert xml_str != None [EOL] cp = ConvertToPython ( ) [EOL] xml . sax . parseString ( xml_str , cp , xml . sax . handler . ErrorHandler ( ) ) [EOL] return cp . get_obj ( ) [EOL] [EOL] [EOL] def _parse_until_delim ( ctx , fld , delim ) : [EOL] [docstring] [EOL] i = ctx [ [string] ] . find ( delim ) [EOL] if ( i == - [number] ) : [EOL] return False [EOL] [EOL] ctx [ fld ] = ctx [ [string] ] [ [number] : i ] [EOL] ctx [ [string] ] = ctx [ [string] ] [ i + len ( delim ) : ] [EOL] return True [EOL] [EOL] def parse_empty_line ( ctx ) : [EOL] [docstring] [EOL] if ctx [ [string] ] . startswith ( [string] ) : [EOL] ctx [ [string] ] = ctx [ [string] ] [ [number] : ] [EOL] return True [EOL] return False [EOL] [EOL] def parse_property ( ctx , delim ) : [EOL] [docstring] [EOL] if _parse_until_delim ( ctx , [string] , delim ) and _parse_until_delim ( ctx , [string] , [string] ) : [EOL] ctx [ [string] ] [ ctx [ [string] ] ] = ctx [ [string] ] [EOL] return True [EOL] return False [EOL] [EOL] def parse_properties ( ctx , delim = [string] ) : [EOL] [docstring] [EOL] return parse_property ( ctx , delim ) and parse_properties ( ctx , delim ) or parse_empty_line ( ctx ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Union , List , Any , Tuple , Iterator [EOL] import typing [EOL] import io [EOL] [docstring] [EOL] import StringIO [EOL] import ConfigParser [EOL] [EOL] def parse_cluster_config_ini ( path ) : [EOL] with open ( path ) as ini : [EOL] return parse_cluster_conifg_ini_ ( ini ) [EOL] [EOL] def parse_cluster_conifg_ini_ ( ini ) : [EOL] c = [ ] [EOL] s = None [EOL] for l in map ( str . rstrip , ini ) : [EOL] if l == [string] or l . startswith ( [string] ) : [EOL] continue [EOL] if l . startswith ( [string] ) : [EOL] s = { [string] : l [ [number] : - [number] ] , [string] : { } } [EOL] c . append ( s ) [EOL] continue [EOL] ( k , v ) = l . split ( [string] , [number] ) [EOL] s [ [string] ] [ k ] = v [EOL] return c [EOL] [EOL] def write_cluster_config_ini ( c ) : [EOL] return [string] . join ( [ [string] . format ( s [ [string] ] , [string] . join ( [ [string] . format ( k , s [ [string] ] [ k ] ) for k in s [ [string] ] . keys ( ) ] ) ) for s in c ] ) [EOL] [EOL] def parse_cluster_config_ini_x ( path ) : [EOL] c = { } [EOL] with open ( path ) as ini : [EOL] key = None [EOL] opts = { } [EOL] for l in map ( str . rstrip , ini ) : [EOL] if l == [string] or l . startswith ( [string] ) : [EOL] continue [EOL] if l . startswith ( [string] ) : [EOL] if key is not None : [EOL] c [ key ] = opts [EOL] key = l [EOL] continue [EOL] ( k , v ) = l . split ( [string] , [number] ) [EOL] opts [ k ] = v [EOL] if k == [string] : [EOL] key = ( key , v ) [EOL] return c [EOL] [EOL] [comment] [EOL] def parse_config_ini ( path ) : [EOL] ini = open ( path ) [EOL] buf = StringIO . StringIO ( ) [EOL] sections = { } [EOL] [EOL] for l in map ( str . rstrip , ini ) : [EOL] if not [string] in l and len ( l ) > [number] and l [ [number] ] == [string] and l [ - [number] ] == [string] : [EOL] section = l [ [number] : - [number] ] [EOL] n = [number] [EOL] if sections . has_key ( section ) : [EOL] n = sections [ section ] + [number] [EOL] sections [ section ] = n [EOL] buf . write ( [string] + section + [string] + repr ( n ) + [string] ) [EOL] else : [EOL] buf . write ( l + [string] ) [EOL] ini . close ( ) [EOL] buf . seek ( [number] ) [EOL] [EOL] cp = ConfigParser . ConfigParser ( ) [EOL] cp . optionxform = str [EOL] cp . readfp ( buf ) [EOL] buf . close ( ) [EOL] return cp [EOL] [EOL] [EOL] def get_option_value_set ( cp , option ) : [EOL] return set ( [ cp . get ( s , option ) for s in filter ( lambda s : cp . has_option ( s , option ) , cp . sections ( ) ) ] ) [EOL] [EOL] def get_node_dicts ( cp , portbase ) : [EOL] node_sections = filter ( lambda s : cp . has_option ( s , [string] ) and not [string] in s , cp . sections ( ) ) [EOL] ndicts = [ ] [EOL] for ns in node_sections : [EOL] t = [string] . join ( ns . split ( [string] ) [ : - [number] ] ) [EOL] nalist = [ ( [string] , t . lower ( ) ) ] [EOL] if t == [string] : [EOL] nalist += [ ( [string] , portbase ) ] [EOL] portbase += [number] [EOL] if cp . has_section ( t + [string] ) : [EOL] nalist += cp . items ( t + [string] ) [EOL] [EOL] nalist += cp . items ( ns ) [EOL] ndicts . append ( dict ( nalist ) ) [EOL] return ndicts [EOL] [EOL] def get_actual_section ( s ) : [EOL] if [string] in s : [EOL] return s [EOL] return [string] . join ( s . split ( [string] ) [ : - [number] ] ) [EOL] [EOL] def get_proct1 ( s ) : [EOL] if [string] in s : [EOL] s = s . rstrip ( [string] ) [EOL] else : [EOL] s = [string] . join ( s . split ( [string] ) [ : - [number] ] ) [EOL] return s . lower ( ) [EOL] [EOL] def get_pid1 ( cp , s ) : [EOL] if cp . has_option ( s , [string] ) : [EOL] return cp . get ( s , [string] ) [EOL] return None [EOL] [EOL] def get_ndbconnecturl ( cp ) : [EOL] return [string] . join ( [ [string] . format ( cp . get ( s , [string] ) , cp . get ( s , [string] ) ) for s in filter ( lambda se : [string] in se , cp . sections ( ) ) ] ) [EOL] [EOL] def get_configvalues ( cp ) : [EOL] return [ { [string] : get_actual_section ( s ) , [string] : k , [string] : get_proct1 ( s ) , [string] : get_pid1 ( cp , s ) , [string] : None , [string] : None , [string] : v } for s in cp . sections ( ) for ( k , v ) in cp . items ( s ) ] [EOL] [EOL] def get_processes ( cp ) : [EOL] return [ { [string] : [number] , [string] : [number] , [string] : [number] , [string] : get_proct1 ( s ) , [string] : get_pid1 ( cp , s ) , [string] : { } , [string] : cp . get ( s , [string] ) , [string] : None , [string] : get_ndbconnecturl ( cp ) } for s in filter ( lambda s : cp . has_option ( s , [string] ) and not [string] in s , cp . sections ( ) ) ] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Tuple , Any , Set [EOL] import typing [EOL] import itertools [EOL] import itertools [EOL] [EOL] class Condition ( object ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , k , state ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] class Effect ( object ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , k , state ) : [EOL] [docstring] [EOL] [EOL] class Action ( object ) : [EOL] [docstring] [EOL] [EOL] preconditions = [ ] [EOL] effect = None [EOL] postconditions = [ ] [EOL] enabled = True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] n = self . __class__ . __name__ [EOL] return n [ [number] ] . lower ( ) + n [ [number] : ] [EOL] [EOL] class Driver ( object ) : [EOL] [docstring] [EOL] [EOL] def newState ( self ) : [EOL] [docstring] [EOL] return { } [EOL] [EOL] def preSuite ( self , seq ) : [EOL] [docstring] [EOL] [EOL] def startSequence ( self , seq ) : [EOL] [docstring] [EOL] [EOL] def startAction ( self , action ) : [EOL] [docstring] [EOL] [EOL] def endAction ( self , action , state , errored ) : [EOL] [docstring] [EOL] [EOL] def endSequence ( self , seq , state ) : [EOL] [docstring] [EOL] [EOL] def postSuite ( self , seq ) : [EOL] [docstring] [EOL] [EOL] def runTest ( actions , driver , duplicates = [number] , length = [number] ) : [EOL] [docstring] [EOL] [EOL] instances = itertools . chain ( * itertools . repeat ( [ a ( ) for a in actions ] , duplicates ) ) [EOL] tests = set ( itertools . permutations ( instances , length ) ) [EOL] driver . preSuite ( tests ) [EOL] for seq in sorted ( tests ) : [EOL] state = driver . newState ( ) [EOL] driver . startSequence ( seq ) [EOL] for a in seq : [EOL] driver . startAction ( a ) [EOL] haserror = not all ( p ( state ) for p in a . preconditions ) [EOL] if not haserror : [EOL] try : [EOL] a . effect ( state ) [EOL] haserror = not all ( p ( state ) for p in a . postconditions ) [EOL] except : [EOL] haserror = True [EOL] driver . endAction ( a , state , haserror ) [EOL] driver . endSequence ( seq , state ) [EOL] driver . postSuite ( tests ) [EOL] [EOL] def findActions ( classes ) : [EOL] [docstring] [EOL] [EOL] actions = [ ] [EOL] for __t in ( t for t in classes if isinstance ( type , type ( t ) ) ) : [EOL] if Action in __t . __mro__ and __t != Action and __t . enabled : [EOL] actions . append ( __t ) [EOL] return actions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import StringIO [EOL] from google3 . pyglib import flags [EOL] from google3 . testing . pybase import googletest [EOL] from google3 . util . regexp . re2 import unicode [EOL] [EOL] _UNICODE_DIR = os . path . join ( flags . FLAGS . test_srcdir , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] class ConvertTest ( googletest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def testUInt ( self ) : [EOL] self . assertEquals ( [number] , unicode . _UInt ( [string] ) ) [EOL] self . assertEquals ( [number] , unicode . _UInt ( [string] ) ) [EOL] self . assertEquals ( [number] , unicode . _UInt ( [string] ) ) [EOL] self . assertRaises ( unicode . InputError , unicode . _UInt , [string] ) [EOL] self . assertRaises ( unicode . InputError , unicode . _UInt , [string] ) [EOL] self . assertRaises ( unicode . InputError , unicode . _UInt , [string] ) [EOL] [EOL] def testURange ( self ) : [EOL] self . assertEquals ( [ [number] , [number] , [number] ] , unicode . _URange ( [string] ) ) [EOL] self . assertEquals ( [ [number] ] , unicode . _URange ( [string] ) ) [EOL] self . assertRaises ( unicode . InputError , unicode . _URange , [string] ) [EOL] self . assertRaises ( unicode . InputError , unicode . _URange , [string] ) [EOL] self . assertRaises ( unicode . InputError , unicode . _URange , [string] ) [EOL] [EOL] def testUStr ( self ) : [EOL] self . assertEquals ( [string] , unicode . _UStr ( [number] ) ) [EOL] self . assertEquals ( [string] , unicode . _UStr ( [number] ) ) [EOL] self . assertRaises ( unicode . InputError , unicode . _UStr , [number] ) [EOL] self . assertRaises ( unicode . InputError , unicode . _UStr , - [number] ) [EOL] [EOL] [EOL] _UNICODE_TABLE = [string] [EOL] [EOL] _BAD_TABLE1 = [string] [EOL] [EOL] _BAD_TABLE2 = [string] [EOL] [EOL] _BAD_TABLE3 = [string] [EOL] [EOL] [EOL] class AbortError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] def Abort ( ) : [EOL] raise AbortError ( [string] ) [EOL] [EOL] [EOL] def StringTable ( s , n , f ) : [EOL] unicode . ReadUnicodeTable ( StringIO . StringIO ( s ) , n , f ) [EOL] [EOL] [EOL] class ReadUnicodeTableTest ( googletest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def testSimpleTable ( self ) : [EOL] [EOL] ncall = [ [number] ] [comment] [EOL] [EOL] def DoLine ( codes , fields ) : [EOL] self . assertEquals ( [number] , len ( fields ) ) [EOL] ncall [ [number] ] += [number] [EOL] self . assertEquals ( [string] % ( ncall [ [number] ] , ) , fields [ [number] ] ) [EOL] if ncall [ [number] ] == [number] : [EOL] self . assertEquals ( [ [number] ] , codes ) [EOL] self . assertEquals ( [string] , fields [ [number] ] ) [EOL] self . assertEquals ( [string] , fields [ [number] ] ) [EOL] elif ncall [ [number] ] == [number] : [EOL] self . assertEquals ( range ( [number] , [number] + [number] ) , codes ) [EOL] self . assertEquals ( [string] , fields [ [number] ] ) [EOL] self . assertEquals ( [string] , fields [ [number] ] ) [EOL] elif ncall [ [number] ] == [number] : [EOL] self . assertEquals ( range ( [number] , [number] + [number] ) , codes ) [EOL] self . assertEquals ( [string] , fields [ [number] ] ) [EOL] self . assertEquals ( [string] , fields [ [number] ] ) [EOL] elif ncall [ [number] ] == [number] : [EOL] self . assertEquals ( [ [number] ] , codes ) [EOL] self . assertEquals ( [string] , fields [ [number] ] ) [EOL] self . assertEquals ( [string] , fields [ [number] ] ) [EOL] elif ncall [ [number] ] == [number] : [EOL] self . assertEquals ( [ [number] ] , codes ) [EOL] self . assertEquals ( [string] , fields [ [number] ] ) [EOL] self . assertEquals ( [string] , fields [ [number] ] ) [EOL] [EOL] StringTable ( _UNICODE_TABLE , [number] , DoLine ) [EOL] self . assertEquals ( [number] , ncall [ [number] ] ) [EOL] [EOL] def testErrorTables ( self ) : [EOL] self . assertRaises ( unicode . InputError , StringTable , _UNICODE_TABLE , [number] , Abort ) [EOL] self . assertRaises ( unicode . InputError , StringTable , _UNICODE_TABLE , [number] , Abort ) [EOL] self . assertRaises ( unicode . InputError , StringTable , _BAD_TABLE1 , [number] , Abort ) [EOL] self . assertRaises ( unicode . InputError , StringTable , _BAD_TABLE2 , [number] , Abort ) [EOL] self . assertRaises ( unicode . InputError , StringTable , _BAD_TABLE3 , [number] , Abort ) [EOL] [EOL] [EOL] class ParseContinueTest ( googletest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def testParseContinue ( self ) : [EOL] self . assertEquals ( ( [string] , [string] ) , unicode . _ParseContinue ( [string] ) ) [EOL] self . assertEquals ( ( [string] , [string] ) , unicode . _ParseContinue ( [string] ) ) [EOL] self . assertEquals ( ( [string] , None ) , unicode . _ParseContinue ( [string] ) ) [EOL] [EOL] [EOL] class CaseGroupsTest ( googletest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def FindGroup ( self , c ) : [EOL] if type ( c ) == str : [EOL] c = ord ( c ) [EOL] for g in self . groups : [EOL] if c in g : [EOL] return g [EOL] return None [EOL] [EOL] def testCaseGroups ( self ) : [EOL] self . groups = unicode . CaseGroups ( unicode_dir = _UNICODE_DIR ) [EOL] self . assertEquals ( [ ord ( [string] ) , ord ( [string] ) ] , self . FindGroup ( [string] ) ) [EOL] self . assertEquals ( None , self . FindGroup ( [string] ) ) [EOL] [EOL] [EOL] class ScriptsTest ( googletest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def FindScript ( self , c ) : [EOL] if type ( c ) == str : [EOL] c = ord ( c ) [EOL] for script , codes in self . scripts . items ( ) : [EOL] for code in codes : [EOL] if c == code : [EOL] return script [EOL] return None [EOL] [EOL] def testScripts ( self ) : [EOL] self . scripts = unicode . Scripts ( unicode_dir = _UNICODE_DIR ) [EOL] self . assertEquals ( [string] , self . FindScript ( [string] ) ) [EOL] self . assertEquals ( [string] , self . FindScript ( [string] ) ) [EOL] self . assertEquals ( None , self . FindScript ( [number] ) ) [EOL] [EOL] [EOL] class CategoriesTest ( googletest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def FindCategory ( self , c ) : [EOL] if type ( c ) == str : [EOL] c = ord ( c ) [EOL] short = None [EOL] for category , codes in self . categories . items ( ) : [EOL] for code in codes : [EOL] if code == c : [EOL] [comment] [EOL] if len ( category ) > [number] : [EOL] return category [EOL] if short == None : [EOL] short = category [EOL] return short [EOL] [EOL] def testCategories ( self ) : [EOL] self . categories = unicode . Categories ( unicode_dir = _UNICODE_DIR ) [EOL] self . assertEquals ( [string] , self . FindCategory ( [string] ) ) [EOL] self . assertEquals ( [string] , self . FindCategory ( [string] ) ) [EOL] self . assertEquals ( [string] , self . FindCategory ( [number] ) ) [comment] [EOL] self . assertEquals ( None , self . FindCategory ( [number] ) ) [EOL] self . assertEquals ( [string] , self . FindCategory ( [number] ) ) [EOL] self . assertEquals ( [string] , self . FindCategory ( [number] ) ) [EOL] self . assertEquals ( [string] , self . FindCategory ( [number] ) ) [EOL] self . assertTrue ( ord ( [string] ) in self . categories [ [string] ] ) [EOL] self . assertTrue ( ord ( [string] ) in self . categories [ [string] ] ) [EOL] self . assertTrue ( [number] in self . categories [ [string] ] ) [EOL] self . assertTrue ( [number] in self . categories [ [string] ] ) [EOL] self . assertTrue ( [number] in self . categories [ [string] ] ) [EOL] [EOL] def main ( ) : [EOL] googletest . main ( ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] from numpy . testing import assert_array_equal [EOL] [EOL] def test_meandiscrete ( ) : [EOL] X_test = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] mean_discrete = MeanDiscrete ( ) [EOL] mean_discrete . fit ( X_test ) [EOL] assert_array_equal ( mean_discrete . mean , np . array ( [ [number] , [number] ] ) ) [EOL] X_transformed = mean_discrete . transform ( X_test ) [EOL] X_expected = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] assert_array_equal ( X_transformed , X_expected )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Dict , List , Any , Tuple [EOL] import typing [EOL] import os [EOL] import re [EOL] import numpy as np [EOL] from mrjob . job import MRJob [EOL] from mrjob . step import MRStep [EOL] from operator import itemgetter [EOL] [EOL] word_search_re = re . compile ( [string] ) [EOL] [EOL] [EOL] class NaiveBayesTrainer ( MRJob ) : [EOL] [EOL] def steps ( self ) : [EOL] return [ MRStep ( mapper = self . extract_words_mapping , reducer = self . reducer_count_words ) , MRStep ( reducer = self . compare_words_reducer ) , ] [EOL] [EOL] def extract_words_mapping ( self , key , value ) : [EOL] tokens = value . split ( ) [EOL] gender = eval ( tokens [ [number] ] ) [EOL] blog_post = eval ( [string] . join ( tokens [ [number] : ] ) ) [EOL] all_words = word_search_re . findall ( blog_post ) [EOL] all_words = [ word . lower ( ) for word in all_words ] [EOL] [comment] [EOL] for word in all_words : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] yield ( gender , word ) , [number] / len ( all_words ) [EOL] [EOL] def reducer_count_words ( self , key , counts ) : [EOL] s = sum ( counts ) [EOL] gender , word = key [comment] [EOL] yield word , ( gender , s ) [EOL] [EOL] def compare_words_reducer ( self , word , values ) : [EOL] per_gender = { } [EOL] for value in values : [EOL] gender , s = value [EOL] per_gender [ gender ] = s [EOL] yield word , per_gender [EOL] [EOL] def ratio_mapper ( self , word , value ) : [EOL] counts = dict ( value ) [EOL] sum_of_counts = float ( np . mean ( counts . values ( ) ) ) [EOL] maximum_score = max ( counts . items ( ) , key = itemgetter ( [number] ) ) [EOL] current_ratio = maximum_score [ [number] ] / sum_of_counts [EOL] yield None , ( word , sum_of_counts , value ) [EOL] [EOL] def sorter_reducer ( self , key , values ) : [EOL] ranked_list = sorted ( values , key = itemgetter ( [number] ) , reverse = True ) [EOL] n_printed = [number] [EOL] for word , sum_of_counts , scores in ranked_list : [EOL] if n_printed < [number] : [EOL] print ( ( n_printed + [number] ) , word , scores ) [EOL] n_printed += [number] [EOL] yield word , dict ( scores ) [EOL] [EOL] if __name__ == [string] : [EOL] NaiveBayesTrainer . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Any [EOL] import typing [EOL] import os [EOL] import re [EOL] from mrjob . job import MRJob [EOL] from mrjob . step import MRStep [EOL] [EOL] word_search_re = re . compile ( [string] ) [EOL] [EOL] [EOL] class ExtractPosts ( MRJob ) : [EOL] [EOL] post_start = False [EOL] post = [ ] [EOL] [EOL] def mapper ( self , key , line ) : [EOL] filename = os . environ [ [string] ] [EOL] gender = filename . split ( [string] ) [ [number] ] [EOL] try : [EOL] docnum = int ( filename [ [number] ] ) [EOL] except : [EOL] docnum = [number] [EOL] if filename . startswith ( [string] ) : [EOL] [comment] [EOL] line = line . strip ( ) [EOL] if line == [string] : [EOL] self . post_start = True [EOL] elif line == [string] : [EOL] self . post_start = False [EOL] yield gender , repr ( [string] . join ( self . post ) ) [EOL] self . post = [ ] [EOL] elif self . post_start : [EOL] self . post . append ( line ) [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] ExtractPosts . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0