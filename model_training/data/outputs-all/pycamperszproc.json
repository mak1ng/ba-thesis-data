from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] import zproc [EOL] [EOL] [EOL] @ pytest . fixture def ctx ( ) : [EOL] return zproc . Context ( ) [EOL] [EOL] [EOL] @ pytest . fixture def state ( ctx ) : [EOL] return ctx . create_state ( { [string] : [number] } ) [EOL] [EOL] [EOL] def test_retry ( ctx , state ) : [EOL] @ ctx . spawn ( retry_for = [ ValueError ] , max_retries = [number] , retry_delay = [number] ) def p ( ctx ) : [EOL] state = ctx . create_state ( ) [EOL] try : [EOL] raise ValueError [EOL] finally : [EOL] state [ [string] ] += [number] [EOL] [EOL] with pytest . raises ( zproc . ProcessWaitError ) : [EOL] p . wait ( ) [EOL] assert state [ [string] ] == [number] [EOL] [EOL] [EOL] def test_infinite_retry ( ctx , state ) : [EOL] @ ctx . spawn ( retry_for = [ ValueError ] , max_retries = None , retry_delay = [number] ) def p ( ctx ) : [EOL] state = ctx . create_state ( ) [EOL] try : [EOL] raise ValueError [EOL] finally : [EOL] [comment] [EOL] state [ [string] ] += [number] [EOL] [EOL] with pytest . raises ( TimeoutError ) : [EOL] p . wait ( timeout = [number] ) [EOL] p . stop ( ) [EOL] assert [number] <= state [ [string] ] <= [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] import signal [EOL] import time [EOL] [EOL] import pytest [EOL] [EOL] import zproc [EOL] [EOL] [EOL] @ pytest . fixture def ctx ( ) : [EOL] return zproc . Context ( ) [EOL] [EOL] [EOL] @ pytest . fixture def state ( ctx ) : [EOL] return ctx . create_state ( ) [EOL] [EOL] [EOL] def test_exception_contract ( ctx , state ) : [EOL] @ zproc . atomic def mutator ( snap ) : [EOL] snap [ [string] ] = [number] [EOL] raise ValueError [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] mutator ( state ) [EOL] [EOL] assert state == { } [EOL] [EOL] [EOL] def test_signal_contract ( ctx , state ) : [EOL] @ zproc . atomic def atomic_fn ( snap ) : [EOL] snap [ [string] ] = [number] [EOL] time . sleep ( [number] ) [EOL] [EOL] curpid = os . getpid ( ) [EOL] [EOL] @ ctx . spawn ( pass_context = False ) def p ( ) : [EOL] time . sleep ( [number] ) [EOL] zproc . send_signal ( signal . SIGINT , curpid ) [EOL] [EOL] zproc . signal_to_exception ( signal . SIGINT ) [EOL] [EOL] with pytest . raises ( zproc . SignalException ) : [EOL] atomic_fn ( state ) [EOL] [EOL] print ( state . copy ( ) ) [EOL] assert state == { [string] : [number] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import pytest [EOL] [EOL] import zproc [EOL] [EOL] [EOL] @ pytest . fixture def ctx ( ) : [EOL] return zproc . Context ( ) [EOL] [EOL] [EOL] @ pytest . fixture def state ( ctx ) : [EOL] return ctx . create_state ( ) [EOL] [EOL] [EOL] def test_ping ( ctx , state ) : [EOL] pid = ctx . server_process . pid [EOL] assert zproc . ping ( ctx . server_address ) == pid [EOL] assert state . ping ( ) == pid [EOL] assert ctx . ping ( ) == pid [EOL] [EOL] [EOL] def test_timeout ( ctx , state ) : [EOL] pid = ctx . server_process . pid [EOL] assert zproc . ping ( ctx . server_address , timeout = [number] ) == pid [EOL] assert state . ping ( timeout = [number] ) == pid [EOL] assert ctx . ping ( timeout = [number] ) == pid [EOL] [EOL] [EOL] def test_timeout_error ( ctx , state ) : [EOL] with pytest . raises ( TimeoutError ) : [EOL] zproc . ping ( ctx . server_address , timeout = [number] ) [EOL] [EOL] with pytest . raises ( TimeoutError ) : [EOL] ctx . ping ( timeout = [number] ) [EOL] [EOL] with pytest . raises ( TimeoutError ) : [EOL] state . ping ( timeout = [number] ) [EOL] [EOL] [EOL] def test_ping_after_close ( ctx , state ) : [EOL] ctx . server_process . terminate ( ) [EOL] [EOL] with pytest . raises ( TimeoutError ) : [EOL] zproc . ping ( ctx . server_address , timeout = [number] ) [EOL] [EOL] with pytest . raises ( TimeoutError ) : [EOL] ctx . ping ( timeout = [number] ) [EOL] [EOL] with pytest . raises ( TimeoutError ) : [EOL] state . ping ( timeout = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterator [EOL] import typing [EOL] import zproc [EOL] import pytest [EOL] [EOL] import zproc [EOL] [EOL] [EOL] @ pytest . fixture def ctx ( ) : [EOL] return zproc . Context ( ) [EOL] [EOL] [EOL] @ pytest . fixture def swarm ( ctx ) : [EOL] return ctx . create_swarm ( ) [EOL] [EOL] [EOL] def test_regular ( swarm ) : [EOL] r1 = swarm . map ( pow , range ( [number] ** [number] ) , args = [ [number] ] ) [EOL] r2 = map ( lambda x : pow ( x , [number] ) , range ( [number] ** [number] ) ) [EOL] [EOL] assert r1 == list ( r2 ) [EOL] [EOL] [EOL] def test_lazy ( swarm ) : [EOL] r1 = swarm . map_lazy ( pow , range ( [number] ** [number] ) , args = [ [number] ] ) [EOL] r2 = swarm . map_lazy ( pow , range ( [number] ** [number] ) , args = [ [number] ] ) [EOL] r3 = map ( lambda x : pow ( x , [number] ) , range ( [number] ** [number] ) ) [EOL] [EOL] assert list ( r1 ) == r2 . as_list == list ( r3 ) [EOL] [EOL] [EOL] def test_nested_map ( ctx ) : [EOL] @ ctx . spawn def p1 ( ctx ) : [EOL] swarm = ctx . create_swarm ( ) [EOL] return swarm . map ( pow , range ( [number] ) , args = [ [number] ] ) [EOL] [EOL] assert p1 . wait ( ) == list ( map ( lambda x : pow ( x , [number] ) , range ( [number] ) ) ) [EOL] [EOL] [EOL] def test_remote_result ( ctx ) : [EOL] @ ctx . spawn def p2 ( ctx ) : [EOL] swarm = ctx . create_swarm ( ) [EOL] result = swarm . map_lazy ( pow , range ( [number] ) , args = [ [number] ] ) [EOL] return result . task_id [EOL] [EOL] result = zproc . SequenceTaskResult ( ctx . server_address , p2 . wait ( ) ) . as_list [EOL] assert result == list ( map ( lambda x : pow ( x , [number] ) , range ( [number] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] [EOL] [EOL] def test_namespaces ( ) : [EOL] state = zproc . Context ( ) . create_state ( ) [EOL] [EOL] state . namespace = [string] [EOL] state [ [string] ] = [number] [EOL] [EOL] assert state == { [string] : [number] } [EOL] [EOL] state . namespace = [string] [EOL] state [ [string] ] = [number] [EOL] [EOL] assert state == { [string] : [number] } [EOL] [EOL] state . namespace = [string] [EOL] assert state == { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import zproc [EOL] [docstring] [EOL] import random [EOL] [EOL] import pytest [EOL] [EOL] import zproc [EOL] [EOL] TEST_VALUE = { [string] : [number] } [EOL] [EOL] [EOL] def test_random_addr ( ) : [EOL] ctx = zproc . Context ( ) [EOL] state = ctx . create_state ( TEST_VALUE ) [EOL] [EOL] ctx = zproc . Context ( ctx . server_address , start_server = False ) [EOL] assert state == TEST_VALUE [EOL] [EOL] state = zproc . State ( ctx . server_address ) [EOL] assert state == TEST_VALUE [EOL] [EOL] [EOL] def test_static_addr ( ) : [EOL] addr = [string] % random . randint ( [number] , [number] ) [EOL] [EOL] ctx = zproc . Context ( addr ) [EOL] state = ctx . create_state ( TEST_VALUE ) [EOL] [EOL] assert state == TEST_VALUE [EOL] [EOL] state = zproc . State ( addr ) [EOL] assert state == TEST_VALUE [EOL] [EOL] [EOL] def test_start_server ( ) : [EOL] _ , addr = zproc . start_server ( ) [EOL] [EOL] ctx = zproc . Context ( addr , start_server = False ) [EOL] state = ctx . create_state ( TEST_VALUE ) [EOL] [EOL] ctx = zproc . Context ( addr , start_server = False ) [EOL] assert state == TEST_VALUE [EOL] [EOL] state = zproc . State ( ctx . server_address ) [EOL] assert state == TEST_VALUE [EOL] [EOL] [EOL] def test_not_start_server ( ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] zproc . Context ( start_server = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import zproc [EOL] [docstring] [EOL] import pytest [EOL] [EOL] import zproc [EOL] [EOL] [EOL] @ pytest . fixture def ctx ( ) : [EOL] return zproc . Context ( ) [EOL] [EOL] [EOL] @ pytest . fixture def pydict ( ) : [EOL] return { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] @ pytest . fixture def state ( pydict , ctx ) : [EOL] return ctx . create_state ( pydict ) [EOL] [EOL] [EOL] def test_update ( state , pydict ) : [EOL] state . update ( { [string] : [number] , [string] : [number] } ) [EOL] pydict . update ( { [string] : [number] , [string] : [number] } ) [EOL] [EOL] assert state == pydict [EOL] [EOL] [EOL] def test__contains__ ( state , pydict ) : [EOL] assert ( [string] in state ) == ( [string] in pydict ) [EOL] assert ( [string] not in state ) == ( [string] not in pydict ) [EOL] [EOL] [EOL] def test__delitem__ ( state , pydict ) : [EOL] del state [ [string] ] [EOL] del pydict [ [string] ] [EOL] [EOL] assert state == pydict [EOL] [EOL] [EOL] def test__eq__ ( state , pydict ) : [EOL] assert ( state == { [string] : [string] } ) == ( pydict == { [string] : [string] } ) [EOL] [EOL] [EOL] def test__getitem__ ( state , pydict ) : [EOL] assert state [ [string] ] == pydict [ [string] ] [EOL] [EOL] [EOL] def test__iter__ ( state , pydict ) : [EOL] for k1 , k2 in zip ( state , pydict ) : [EOL] assert k1 == k2 [EOL] [EOL] [EOL] def test__len__ ( state , pydict ) : [EOL] assert len ( state ) == len ( pydict ) [EOL] [EOL] [EOL] def test__ne__ ( state , pydict ) : [EOL] assert ( state != { [string] : [string] } ) == ( pydict != { [string] : [string] } ) [EOL] [EOL] [EOL] def test__setitem__ ( state , pydict ) : [EOL] state [ [string] ] = [number] [EOL] pydict [ [string] ] = [number] [EOL] assert state == pydict [EOL] [EOL] [EOL] def test_clear ( state , pydict ) : [EOL] state . clear ( ) [EOL] pydict . clear ( ) [EOL] assert state == pydict [EOL] [EOL] [EOL] def test_dict_inbuilt ( state , pydict ) : [EOL] assert dict ( state ) == dict ( pydict ) [EOL] [EOL] [EOL] def test_copy ( state , pydict ) : [EOL] assert state . copy ( ) == pydict . copy ( ) [EOL] [EOL] [EOL] def test_get ( state , pydict ) : [EOL] assert state . get ( [string] , [ ] ) == pydict . get ( [string] , [ ] ) [EOL] assert state . get ( [string] ) == pydict . get ( [string] ) [EOL] [EOL] [EOL] def test_items ( state , pydict ) : [EOL] for i , j in zip ( state . items ( ) , pydict . items ( ) ) : [EOL] assert i [ [number] ] == j [ [number] ] and i [ [number] ] == j [ [number] ] [EOL] [EOL] [EOL] def test_values ( state , pydict ) : [EOL] for i , j in zip ( state . values ( ) , pydict . values ( ) ) : [EOL] assert i == j [EOL] [EOL] [EOL] def test_keys ( state , pydict ) : [EOL] for i , j in zip ( state . keys ( ) , pydict . keys ( ) ) : [EOL] assert i == j [EOL] [EOL] [EOL] def test_setdefault ( state , pydict ) : [EOL] state . setdefault ( [string] , None ) [EOL] pydict . setdefault ( [string] , None ) [EOL] [EOL] assert state == pydict [EOL] [EOL] [EOL] def test_pop ( state , pydict ) : [EOL] assert state . pop ( [string] ) == pydict . pop ( [string] ) [EOL] assert state == pydict [EOL] [EOL] [EOL] def test_popitem ( state , pydict ) : [EOL] assert state . popitem ( ) == pydict . popitem ( ) [EOL] assert state == pydict [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] import time [EOL] [EOL] import pytest [EOL] [EOL] import zproc [EOL] [EOL] [EOL] @ pytest . fixture def state ( ) : [EOL] ctx = zproc . Context ( ) [EOL] [EOL] @ ctx . spawn ( ) def updater ( ctx ) : [EOL] state = ctx . create_state ( ) [EOL] [EOL] state [ [string] ] = None [EOL] state [ [string] ] = False [EOL] time . sleep ( [number] ) [EOL] state [ [string] ] = True [EOL] state [ [string] ] = True [EOL] state [ [string] ] = True [EOL] [EOL] return ctx . create_state ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def test_when_change ( state ) : [EOL] it = state . when_change ( ) [EOL] assert isinstance ( next ( it ) , dict ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def test_when ( state ) : [EOL] it = state . when ( lambda s : s . get ( [string] ) is True ) [EOL] assert next ( it ) [ [string] ] is True [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def test_when_equal ( state ) : [EOL] it = state . when_equal ( [string] , True ) [EOL] assert next ( it ) [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def test_when_not_equal ( state ) : [EOL] it = state . when_not_equal ( [string] , False ) [EOL] assert next ( it ) . get ( [string] ) is not False [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def test_when_none ( state ) : [EOL] it = state . when_none ( [string] ) [EOL] assert next ( it ) . get ( [string] ) is None [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def test_when_not_none ( state ) : [EOL] it = state . when_not_none ( [string] ) [EOL] assert next ( it ) [ [string] ] is not None [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def test_when_avail ( state ) : [EOL] it = state . when_available ( [string] ) [EOL] assert [string] in next ( it ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] from time import sleep [EOL] [EOL] import pytest [EOL] [EOL] import zproc [EOL] [EOL] [EOL] @ pytest . fixture def state ( ) : [EOL] ctx = zproc . Context ( ) [EOL] [EOL] @ ctx . spawn def mutator ( ctx ) : [EOL] state = ctx . create_state ( ) [EOL] [EOL] for n in range ( [number] ) : [EOL] sleep ( [number] ) [EOL] state [ [string] ] = n [EOL] [EOL] return ctx . create_state ( ) [EOL] [EOL] [EOL] def test_not_live ( state ) : [EOL] it = state . when_change ( [string] ) [EOL] sleep ( [number] ) [EOL] assert next ( it ) [ [string] ] == [number] [EOL] [EOL] [EOL] def test_live ( state ) : [EOL] it = state . when_change ( [string] , live = True ) [EOL] sleep ( [number] ) [EOL] assert next ( it ) [ [string] ] > [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] [EOL] import pytest [EOL] [EOL] import zproc [EOL] [EOL] TOLERANCE = [number] [EOL] [EOL] [EOL] @ pytest . fixture def ctx ( ) : [EOL] return zproc . Context ( pass_context = False ) [EOL] [EOL] [EOL] def test_timeout_accuracy ( ctx ) : [EOL] @ ctx . spawn def test ( ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] start = time . time ( ) [EOL] try : [EOL] ctx . wait ( [number] ) [EOL] except TimeoutError : [EOL] end = time . time ( ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] diff = end - start [EOL] [EOL] assert diff == pytest . approx ( [number] , TOLERANCE ) [EOL] [EOL] [EOL] def test_timeout_accuracy_parallel ( ctx ) : [EOL] @ ctx . spawn def test1 ( ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] @ ctx . spawn def test2 ( ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] start = time . time ( ) [EOL] try : [EOL] ctx . wait ( [number] ) [EOL] except TimeoutError : [EOL] end = time . time ( ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] diff = end - start [EOL] [EOL] assert diff == pytest . approx ( [number] , TOLERANCE ) [EOL] [EOL] [EOL] def test_timeout1 ( ctx ) : [EOL] @ ctx . spawn def test ( ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] with pytest . raises ( TimeoutError ) : [EOL] ctx . wait ( [number] ) [EOL] [EOL] [EOL] def test_timeout2 ( ctx ) : [EOL] @ ctx . spawn def test ( ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] with pytest . raises ( TimeoutError ) : [EOL] test . wait ( [number] ) [EOL] [EOL] [EOL] def test_wait_timeout ( ctx ) : [EOL] @ ctx . spawn def test1 ( ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] @ ctx . spawn def test2 ( ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TimeoutError ) : [EOL] ctx . wait ( [number] ) [EOL] [EOL] [EOL] def test_wait_timeout_dumb ( ctx ) : [EOL] @ ctx . spawn def test1 ( ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] @ ctx . spawn def test2 ( ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] for i in ctx . process_list : [EOL] i . wait ( [number] ) [EOL] [EOL] [EOL] def test_wait_error ( ctx ) : [EOL] @ ctx . spawn def test ( ) : [EOL] raise ValueError [EOL] [EOL] with pytest . raises ( zproc . ProcessWaitError ) : [EOL] test . wait ( ) [EOL] [EOL] with pytest . raises ( zproc . ProcessWaitError ) : [EOL] ctx . wait ( ) [EOL] [EOL] [EOL] def test_exit ( ctx ) : [EOL] @ ctx . spawn def test ( ) : [EOL] raise zproc . ProcessExit ( [number] ) [EOL] [EOL] with pytest . raises ( zproc . ProcessWaitError ) : [EOL] test . wait ( ) [EOL] [EOL] assert test . exitcode == [number] [EOL] [EOL] with pytest . raises ( zproc . ProcessWaitError ) : [EOL] ctx . wait ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] import zproc [EOL] [EOL] [EOL] @ pytest . fixture def ctx ( ) : [EOL] return zproc . Context ( ) [EOL] [EOL] [EOL] def test_not_pass_ctx ( ctx ) : [EOL] @ ctx . spawn ( pass_context = False ) def my_process ( ) : [EOL] return [number] [EOL] [EOL] assert my_process . wait ( ) == [number] [EOL] [EOL] [EOL] def test_pass_ctx ( ctx ) : [EOL] @ ctx . spawn ( pass_context = True ) def my_process ( ctx ) : [EOL] assert isinstance ( ctx , zproc . Context ) [EOL] return [number] [EOL] [EOL] assert my_process . wait ( ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] import random [EOL] import time [EOL] [EOL] import zproc [EOL] [EOL] MAX_ITER = [number] [EOL] SLOW = False [EOL] [EOL] ctx = zproc . Context ( ) [EOL] state = ctx . create_state ( { [string] : [number] } ) [EOL] [EOL] [EOL] @ zproc . atomic def inc ( snap ) : [EOL] snap [ [string] ] += [number] [EOL] [EOL] [EOL] @ ctx . spawn def generator ( ctx ) : [EOL] state = ctx . create_state ( ) [EOL] while True : [EOL] inc ( state ) [EOL] if SLOW : [EOL] time . sleep ( random . random ( ) ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] @ ctx . spawn def test_process ( ctx ) : [EOL] state = ctx . create_state ( ) [EOL] [EOL] for snap in state . when_change ( [string] , live = True , count = MAX_ITER ) : [EOL] print ( snap , end = [string] , flush = True ) [EOL] [EOL] if SLOW : [EOL] time . sleep ( random . random ( ) ) [EOL] print ( ) [EOL] [EOL] [EOL] test_process . wait ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] @ ctx . spawn def test_process ( ctx ) : [EOL] state = ctx . create_state ( ) [EOL] [EOL] for snap in state . when_change ( [string] , live = False , count = MAX_ITER ) : [EOL] print ( snap , end = [string] , flush = True ) [EOL] [EOL] if SLOW : [EOL] time . sleep ( random . random ( ) ) [EOL] [EOL] print ( ) [EOL] [EOL] [EOL] test_process . wait ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import zproc [EOL] [EOL] for i in range ( [number] ) : [EOL] print ( zproc . start_server ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] import zproc [EOL] [EOL] ctx = zproc . Context ( ) [EOL] [EOL] for i in range ( [number] ) : [EOL] [EOL] @ ctx . spawn def my_process ( ctx ) : [EOL] assert isinstance ( ctx , zproc . Context ) [EOL] state = ctx . create_state ( ) [EOL] assert isinstance ( state , zproc . State ) [EOL] print ( i ) [EOL] return i [EOL] [EOL] assert my_process . wait ( ) == i [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import zproc [EOL] import time [EOL] [EOL] import zproc [EOL] [EOL] ctx = zproc . Context ( ) [EOL] [EOL] for i in range ( [number] ) : [EOL] [EOL] @ ctx . spawn def p1 ( ctx ) : [EOL] @ ctx . spawn def p2 ( ctx ) : [EOL] @ ctx . spawn def p3 ( ctx ) : [EOL] @ ctx . spawn def p4 ( ctx ) : [EOL] @ ctx . spawn ( pass_context = False ) def pn ( ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] print ( i ) [EOL] return i [EOL] [EOL] assert p1 . wait ( ) == i [EOL]	0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import zproc [EOL] import multiprocessing [EOL] from time import perf_counter [EOL] [EOL] import zproc [EOL] [EOL] ctx = zproc . Context ( ) [EOL] ctx . workers . start ( [number] ) [EOL] [EOL] [EOL] def sq ( x ) : [EOL] return x ** [number] [EOL] [EOL] [EOL] SAMPLES = [number] [EOL] [EOL] s = perf_counter ( ) [EOL] list ( ctx . workers . map ( sq , range ( SAMPLES ) ) ) [EOL] print ( perf_counter ( ) - s ) [EOL] [EOL] with multiprocessing . Pool ( [number] ) as p : [EOL] s = perf_counter ( ) [EOL] p . map ( sq , range ( SAMPLES ) ) [EOL] print ( perf_counter ( ) - s ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0
import zproc [EOL] import multiprocessing [EOL] import time [EOL] [EOL] import zproc [EOL] [EOL] ctx = zproc . Context ( ) [EOL] ctx . workers . start ( ) [EOL] [EOL] [EOL] def test123 ( x ) : [EOL] return x * x [EOL] [EOL] [EOL] with multiprocessing . Pool ( ) as p : [EOL] s = time . perf_counter ( ) [EOL] print ( len ( p . map ( test123 , range ( [number] ** [number] ) ) ) ) [EOL] e = time . perf_counter ( ) [EOL] print ( [string] , e - s ) [EOL] [EOL] [EOL] s = time . perf_counter ( ) [EOL] print ( len ( ctx . workers . map ( test123 , range ( [number] ** [number] ) ) ) ) [EOL] e = time . perf_counter ( ) [EOL] print ( [string] , e - s ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0
from typing import Any , List [EOL] import asyncio [EOL] import typing [EOL] import zproc [EOL] [docstring] [EOL] import asyncio [EOL] from time import time [EOL] [EOL] import zproc [EOL] [EOL] SAMPLES = [number] [EOL] [EOL] sites = list ( { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } ) [EOL] [EOL] [EOL] def print_result ( results ) : [EOL] winner = max ( results , key = lambda x : x [ [number] ] ) [EOL] print ( ) [EOL] print ( [string] , winner [ [number] ] , winner [ [number] ] / [number] , [string] ) [EOL] print ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] ctx = zproc . Context ( ) [EOL] ctx . state . setdefault ( [string] , [ ] ) [EOL] [EOL] [EOL] @ zproc . atomic def save ( snap , size , url ) : [EOL] print ( url , int ( size / [number] ) , [string] ) [EOL] [EOL] snap [ [string] ] . append ( ( size , url ) ) [EOL] [EOL] [EOL] def downloader ( state , url ) : [EOL] size = [number] [EOL] for _ in range ( SAMPLES ) : [EOL] size += len ( requests . get ( url , headers = { [string] : [string] } ) . text ) [EOL] size /= SAMPLES [EOL] [EOL] save ( state , size , url ) [EOL] [EOL] [EOL] s = time ( ) [EOL] [EOL] for url in sites : [EOL] ctx . spawn ( downloader , args = [ url ] ) [EOL] ctx . wait ( ) [EOL] [EOL] print_result ( ctx . state [ [string] ] ) [EOL] [EOL] t = time ( ) - s [EOL] [EOL] print ( [string] . format ( t ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def map_downloader ( url ) : [EOL] size = [number] [EOL] for _ in range ( SAMPLES ) : [EOL] size += len ( requests . get ( url , headers = { [string] : [string] } ) . text ) [EOL] size /= SAMPLES [EOL] print ( url , int ( size / [number] ) , [string] ) [EOL] [EOL] return size , url [EOL] [EOL] [EOL] s = time ( ) [EOL] [EOL] print_result ( ctx . worker_map ( map_downloader , sites , count = len ( sites ) ) ) [EOL] [EOL] t = time ( ) - s [EOL] [EOL] print ( [string] . format ( t ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import grequests [EOL] [EOL] [EOL] async def main ( ) : [EOL] results = [ ] [EOL] for site in sites : [EOL] size = [number] [EOL] for _ in range ( SAMPLES ) : [EOL] req = await grequests . get ( site , headers = { [string] : [string] } ) [EOL] size += len ( req . text ) [EOL] size /= SAMPLES [EOL] [EOL] results . append ( ( size , site ) ) [EOL] [EOL] print_result ( results ) [EOL] [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] [EOL] s = time ( ) [EOL] [EOL] loop . run_until_complete ( main ( ) ) [EOL] [EOL] t = time ( ) - s [EOL] [EOL] print ( [string] . format ( t ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Dict , Any , Union , Tuple [EOL] import typing [EOL] import os [EOL] import sys [EOL] [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] import datetime [EOL] [EOL] import zproc [EOL] [EOL] project = [string] [EOL] copyright = [string] . format ( datetime . datetime . now ( ) . year ) [EOL] author = [string] [EOL] [EOL] [comment] [EOL] version = zproc . __version__ [EOL] [comment] [EOL] release = zproc . __version__ [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] html_sidebars = { [string] : [ [string] , [string] , [string] , [string] , [string] , ] } [EOL] html_theme_options = { [string] : [number] , [string] : False , [string] : [string] , } [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( master_doc , [string] , [string] , [string] , [string] ) ] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] , ) ] [EOL] [EOL] [comment] [EOL] [EOL] autoclass_content = [string] [EOL] autodoc_member_order = [string] [EOL] [EOL] rst_prolog = [string] [EOL] [EOL] intersphinx_mapping = { [string] : ( [string] , None ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] import zproc [EOL] [EOL] ctx = zproc . Context ( ) [EOL] [EOL] [EOL] def my_proc ( ctx ) : [EOL] state = ctx . create_state ( ) [EOL] [EOL] for snap in state . when_available ( ) : [EOL] pass [EOL] [EOL] [EOL] ctx . start ( ) [EOL] ctx . spawn ( my_proc ) [EOL] [EOL] [EOL] swarm = ctx . create_swarm ( ) [EOL] [EOL] state = ctx . create_state ( ) [EOL] [EOL] [EOL] state [ [string] ] = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] [docstring] [EOL] from time import sleep [EOL] [EOL] import zproc [EOL] [EOL] ctx = zproc . Context ( ) [EOL] state = ctx . state [EOL] [EOL] state [ [string] ] = [number] [EOL] [EOL] [EOL] @ zproc . atomic def inc_peanuts ( snap ) : [EOL] snap [ [string] ] += [number] [EOL] print ( [string] , snap [ [string] ] ) [EOL] [EOL] [EOL] @ ctx . _process def peanut_gen ( state ) : [EOL] while True : [EOL] inc_peanuts ( state ) [EOL] sleep ( [number] ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] [EOL] for _ in range ( [number] ) : [EOL] num = state . when_change ( [string] , live = True ) [EOL] print ( [string] , num ) [EOL] [EOL] sleep ( [number] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] for _ in range ( [number] ) : [EOL] num = state . when_change ( [string] , live = False ) [EOL] print ( [string] , num ) [EOL] [EOL] sleep ( [number] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] for _ in range ( [number] ) : [EOL] num = state . when_change ( [string] , live = False ) [EOL] print ( [string] , num ) [EOL] [EOL] state . go_live ( ) [EOL] [EOL] sleep ( [number] ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import zproc [EOL] [docstring] [EOL] import random [EOL] [EOL] import zproc [EOL] [EOL] [EOL] def num_listener ( state , low , high ) : [EOL] [comment] [EOL] state . when ( lambda state : low < state . get ( [string] ) < high ) [EOL] [EOL] print ( [string] . format ( low , high ) ) [EOL] [EOL] state [ [string] ] = True [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] ctx = zproc . Context ( ) [comment] [EOL] state = ctx . state [EOL] [EOL] state . setdefault ( [string] , [number] ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] ctx . spawn ( num_listener , args = [ [number] , [number] ] ) [EOL] [EOL] while True : [EOL] if state . get ( [string] ) : [EOL] print ( [string] ) [EOL] break [EOL] else : [EOL] num = random . random ( ) [EOL] state [ [string] ] = num [EOL] [EOL] print ( [string] , num ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0
import zproc [EOL] [docstring] [EOL] import zproc [EOL] [EOL] ctx = zproc . Context ( wait = True ) [EOL] print ( [string] , ctx . state ) [EOL] [EOL] ctx . state [ [string] ] = [string] [EOL] [EOL] [EOL] @ ctx . _process def child1 ( state ) : [EOL] print ( [string] , state ) [EOL] state [ [string] ] = [string] [EOL] [EOL] ctx = zproc . Context ( state . address , wait = True ) [EOL] [EOL] @ ctx . _process def child2 ( state ) : [EOL] print ( [string] , state ) [EOL] state [ [string] ] = [string] [EOL] [EOL] ctx = zproc . Context ( state . address , wait = True ) [EOL] [EOL] @ ctx . _process def child3 ( state ) : [EOL] print ( [string] , state ) [EOL]	0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] [docstring] [EOL] from random import random [EOL] from time import sleep [EOL] [EOL] import zproc [EOL] [EOL] ctx = zproc . Context ( wait = True ) [EOL] ctx . state [ [string] ] = [number] [EOL] [EOL] [EOL] @ zproc . atomic def increment ( snap ) : [EOL] count = snap [ [string] ] [EOL] [EOL] sleep ( random ( ) ) [EOL] [EOL] snap [ [string] ] = count + [number] [EOL] print ( snap [ [string] ] ) [EOL] [EOL] [EOL] def child1 ( state ) : [EOL] increment ( state ) [EOL] [EOL] [EOL] ctx . spawn ( child1 , count = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] [docstring] [EOL] import zproc [EOL] [EOL] [EOL] @ zproc . atomic def eat_cookie ( snap ) : [EOL] [docstring] [EOL] snap [ [string] ] -= [number] [EOL] print ( [string] ) [EOL] [EOL] [EOL] @ zproc . atomic def bake_cookie ( snap ) : [EOL] [docstring] [EOL] snap [ [string] ] += [number] [EOL] print ( [string] ) [EOL] [EOL] [EOL] ctx = zproc . Context ( wait = True ) [EOL] state = ctx . create_state ( ) [EOL] state [ [string] ] = [number] [EOL] [EOL] [EOL] @ ctx . spawn def cookie_eater ( ctx ) : [EOL] [docstring] [EOL] state = ctx . create_state ( ) [EOL] state [ [string] ] = True [EOL] [EOL] for _ in state . when_change ( [string] ) : [EOL] eat_cookie ( state ) [EOL] [EOL] [EOL] [comment] [EOL] next ( state . when_available ( [string] ) ) [EOL] [EOL] [comment] [EOL] print ( cookie_eater ) [EOL] for _ in range ( [number] ) : [EOL] bake_cookie ( state ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] import zproc [EOL] import random [EOL] import time [EOL] [EOL] import zproc [EOL] [EOL] NUM_PROCS = [number] [EOL] NUM_COOKIES = [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ zproc . atomic def decrement ( state , key ) : [EOL] state [ key ] -= [number] [EOL] [EOL] [EOL] @ zproc . atomic def increment ( state , key ) : [EOL] state [ key ] += [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def cookie_eater ( ctx ) : [EOL] state = ctx . create_state ( ) [EOL] increment ( state , [string] ) [EOL] [EOL] [comment] [EOL] time . sleep ( random . random ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for _ in state . when_change ( [string] , count = NUM_COOKIES , start_time = [number] ) : [EOL] decrement ( state , [string] ) [EOL] [EOL] increment ( state , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] ctx = zproc . Context ( wait = True ) [EOL] state = ctx . create_state ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] [comment] [EOL] ready = state . when_change ( [string] , count = NUM_PROCS ) [EOL] [EOL] [comment] [EOL] eaters = ctx . spawn ( cookie_eater , count = NUM_PROCS ) [EOL] print ( eaters ) [EOL] [EOL] [comment] [EOL] ready = list ( ready ) [EOL] print ( [string] , ready ) [EOL] assert len ( ready ) == NUM_PROCS [EOL] [EOL] [comment] [EOL] done = state . when_change ( [string] , count = NUM_PROCS ) [EOL] [EOL] [comment] [EOL] for _ in range ( NUM_COOKIES ) : [EOL] increment ( state , [string] ) [EOL] [EOL] [comment] [EOL] done = list ( done ) [EOL] print ( [string] , done ) [EOL] assert len ( done ) == NUM_PROCS [EOL] [EOL] [comment] [EOL] assert state [ [string] ] == NUM_COOKIES - NUM_PROCS * NUM_COOKIES [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $zproc.context.Context$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] [docstring] [EOL] from time import sleep [EOL] [EOL] import zproc [EOL] [EOL] [EOL] [comment] [EOL] def child1 ( state ) : [EOL] val = state . when_change ( [string] ) [comment] [EOL] print ( [string] , val ) [EOL] [EOL] state [ [string] ] = [string] [comment] [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] def child2 ( state ) : [EOL] state . when ( lambda s : s . get ( [string] ) == [string] ) [comment] [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] ctx = zproc . Context ( wait = True ) [comment] [EOL] ctx . spawn ( child1 , child2 ) [comment] [EOL] [EOL] sleep ( [number] ) [comment] [EOL] [EOL] ctx . state [ [string] ] = [string] [comment] [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import zproc [EOL] from time import sleep [EOL] [EOL] import zproc [EOL] [EOL] ctx = zproc . Context ( ) [EOL] [EOL] [EOL] @ ctx . spawn ( pass_state = False ) def my_process ( ) : [EOL] sleep ( [number] ) [EOL] [EOL] try : [EOL] raise ValueError ( [string] ) [EOL] except Exception as e : [EOL] print ( [string] , repr ( e ) ) [EOL] [EOL] [comment] [EOL] return zproc . RemoteException ( ) [EOL] [EOL] [EOL] sleep ( [number] ) [EOL] [EOL] try : [EOL] my_process . wait ( ) [comment] [EOL] except Exception as e : [EOL] print ( [string] , repr ( e ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zproc [EOL] [docstring] [EOL] from time import sleep [EOL] [EOL] import zproc [EOL] [EOL] [EOL] def child1 ( state ) : [EOL] val = state . when ( lambda s : s . get ( [string] ) is True ) [EOL] print ( [string] , val ) [EOL] [EOL] [EOL] def child2 ( state ) : [EOL] val = state . when_equal ( [string] , True ) [EOL] print ( [string] , val ) [EOL] [EOL] [EOL] def child3 ( state ) : [EOL] val = state . when_not_equal ( [string] , False ) [EOL] print ( [string] , val ) [EOL] [EOL] [EOL] def child4 ( state ) : [EOL] val = state . when_change ( ) [EOL] print ( [string] , val ) [EOL] [EOL] [EOL] def child5 ( state ) : [EOL] val = state . when_change ( [string] ) [EOL] print ( [string] , val ) [EOL] [EOL] [EOL] def child6 ( state ) : [EOL] val = state . when_change ( [string] , exclude = True ) [EOL] print ( [string] , val ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] ctx = zproc . Context ( wait = True ) [EOL] [EOL] ctx . spawn ( child1 , child2 , child3 , child4 , child5 , child6 ) [EOL] [EOL] sleep ( [number] ) [EOL] [EOL] print ( [string] ) [EOL] ctx . state [ [string] ] = True [EOL] [EOL] sleep ( [number] ) [EOL] [EOL] print ( [string] ) [EOL] ctx . state [ [string] ] = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zproc.context.Context$ 0 0 0 0 0 0 0 0