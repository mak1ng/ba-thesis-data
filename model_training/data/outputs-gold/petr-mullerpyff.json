from typing import Dict , FrozenSet , Mapping , Any , Iterable , List , Set , Optional [EOL] import logging [EOL] import _ast [EOL] import pyff [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import pathlib [EOL] import ast [EOL] [EOL] from typing import Optional , Iterable , FrozenSet , Set , Dict , Mapping [EOL] from types import MappingProxyType [EOL] from astroid . modutils import get_module_files [EOL] [EOL] import pyff . modules as pm [EOL] from pyff . kitchensink import hl , hlistify , pluralize [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PackageSummary : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , package ) : [EOL] self . path = package [EOL] [EOL] [EOL] class PackagePyfference : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , modules ) : [EOL] self . modules = modules [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . modules ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { repr ( self . modules ) } [string] " [EOL] [EOL] [EOL] class PackagesPyfference : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , removed , changed , new , ) : [EOL] self . _removed = removed [EOL] self . _changed = changed [EOL] self . _new = new [EOL] [EOL] @ property def removed ( self ) : [EOL] [docstring] [EOL] return MappingProxyType ( self . _removed ) [EOL] [EOL] @ property def new ( self ) : [EOL] [docstring] [EOL] return MappingProxyType ( self . _new ) [EOL] [EOL] @ property def changed ( self ) : [EOL] [docstring] [EOL] return MappingProxyType ( self . _changed ) [EOL] [EOL] def __str__ ( self ) : [EOL] lines = [ ] [EOL] if self . _removed : [EOL] lines . append ( f" [string] { pluralize ( [string] , self . _removed ) } [string] { hlistify ( self . _removed ) }" ) [EOL] [EOL] if self . _changed : [EOL] lines . append ( [string] . join ( [ f" [string] { hl ( package ) } [string] " + str ( change ) . replace ( [string] , [string] ) for package , change in self . _changed . items ( ) ] ) ) [EOL] [EOL] if self . _new : [EOL] lines . append ( f" [string] { pluralize ( [string] , self . _new ) } [string] { hlistify ( self . _new ) }" ) [EOL] [EOL] return [string] . join ( lines ) [EOL] [EOL] def __bool__ ( self ) : [EOL] return bool ( self . _removed or self . _changed or self . _new ) [EOL] [EOL] [EOL] def extract_modules ( files , package ) : [EOL] [docstring] [EOL] return frozenset ( { module . name for module in files if module . parents [ [number] ] == package . path } ) [EOL] [EOL] [EOL] def _compare_module_in_packages ( module , old_package , new_package ) : [EOL] [docstring] [EOL] old_module = old_package . path / module [EOL] new_module = new_package . path / module [EOL] [EOL] old_summary = pm . summarize_module ( old_module ) [EOL] new_summary = pm . summarize_module ( new_module ) [EOL] [EOL] return pm . pyff_module ( old_summary , new_summary ) [EOL] [EOL] [EOL] def summarize_package ( package ) : [EOL] [docstring] [EOL] return PackageSummary ( package ) [EOL] [EOL] [EOL] def _summarize_module_in_package ( module , package ) : [EOL] full_path = package . path / module [EOL] module_ast = ast . parse ( full_path . read_text ( ) ) [EOL] return pm . ModuleSummary ( str ( module ) , module_ast ) [EOL] [EOL] [EOL] def pyff_package ( old_package , new_package ) : [EOL] [docstring] [EOL] old_files = { pathlib . Path ( module ) for module in get_module_files ( old_package . path , ( ) ) } [EOL] new_files = { pathlib . Path ( module ) for module in get_module_files ( new_package . path , ( ) ) } [EOL] [EOL] LOGGER . debug ( [string] , str ( old_package . path ) , old_files ) [EOL] LOGGER . debug ( [string] , str ( new_package . path ) , new_files ) [EOL] [EOL] old_modules = { pathlib . Path ( module ) for module in extract_modules ( old_files , old_package ) } [EOL] new_modules = { pathlib . Path ( module ) for module in extract_modules ( new_files , new_package ) } [EOL] [EOL] LOGGER . debug ( [string] , str ( old_modules ) ) [EOL] LOGGER . debug ( [string] , str ( new_modules ) ) [EOL] [EOL] removed = old_modules - new_modules [EOL] new = new_modules - old_modules [EOL] both = old_modules . intersection ( new_modules ) [EOL] [EOL] LOGGER . debug ( [string] , str ( removed ) ) [EOL] LOGGER . debug ( [string] , str ( both ) ) [EOL] LOGGER . debug ( [string] , str ( new ) ) [EOL] [EOL] removed_summaries = { module : _summarize_module_in_package ( module , old_package ) for module in removed } [EOL] new_summaries = { module : _summarize_module_in_package ( module , new_package ) for module in new } [EOL] changed = { module : change for module , change in [ ( module , _compare_module_in_packages ( module , old_package , new_package ) ) for module in both ] if change is not None } [EOL] modules = pm . ModulesPyfference ( removed_summaries , changed , new_summaries ) [EOL] [EOL] if modules : [EOL] return PackagePyfference ( modules ) [EOL] [EOL] return None [EOL] [EOL] [EOL] def pyff_package_path ( old , new ) : [EOL] [docstring] [EOL] old_summary = summarize_package ( old ) [EOL] new_summary = summarize_package ( new ) [EOL] return pyff_package ( old_summary , new_summary ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[pyff.modules.ModulesPyfference]$ 0 0 0 0 0 $typing.Optional[pyff.modules.ModulesPyfference]$ 0 $typing.Optional[pyff.modules.ModulesPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[pathlib.Path,PackageSummary]$ 0 $typing.Dict[pathlib.Path,PackagePyfference]$ 0 $typing.Dict[pathlib.Path,PackageSummary]$ 0 0 0 0 0 0 $typing.Dict[pathlib.Path,PackageSummary]$ 0 $typing.Dict[pathlib.Path,PackageSummary]$ 0 0 0 $typing.Dict[pathlib.Path,PackagePyfference]$ 0 $typing.Dict[pathlib.Path,PackagePyfference]$ 0 0 0 $typing.Dict[pathlib.Path,PackageSummary]$ 0 $typing.Dict[pathlib.Path,PackageSummary]$ 0 0 0 0 0 $typing.Mapping[pathlib.Path,PackageSummary]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[pathlib.Path,PackageSummary]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[pathlib.Path,PackagePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.modules.ModulePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PackageSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.modules.ModuleSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[PackagePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[PackagePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import argparse [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] import logging [EOL] import pathlib [EOL] from argparse import ArgumentParser [EOL] from typing import Callable [EOL] [EOL] from pyff . modules import pyff_module_path [EOL] from pyff . packages import pyff_package_path [EOL] from pyff . directories import pyff_directory [EOL] from pyff . repositories import pyff_git_revision [EOL] from pyff . kitchensink import highlight , HIGHLIGHTS [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def _pyff_that ( function , what , parser = ArgumentParser ( ) ) : [EOL] parser . add_argument ( [string] ) [EOL] parser . add_argument ( [string] ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , choices = HIGHLIGHTS , default = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , default = False ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] if args . debug : [EOL] logging . basicConfig ( format = [string] , level = logging . DEBUG ) [EOL] [EOL] LOGGER . debug ( f" [string] { what } [string] { args . old } [string] { what } [string] { args . new }" ) [EOL] changes = function ( pathlib . Path ( args . old ) , pathlib . Path ( args . new ) , args ) [EOL] [EOL] if changes is None : [EOL] print ( f" [string] " f"{ what } [string] { args . old } [string] { args . new } [string] " ) [EOL] sys . exit ( [number] ) [EOL] [EOL] print ( highlight ( str ( changes ) , args . highlight ) ) [EOL] [EOL] [EOL] def pyffmod ( ) : [EOL] [docstring] [EOL] [EOL] def compare ( old , new , _ ) : [EOL] [docstring] [EOL] return pyff_module_path ( old , new ) [EOL] [EOL] _pyff_that ( compare , [string] ) [EOL] [EOL] [EOL] def pyffpkg ( ) : [EOL] [docstring] [EOL] [EOL] def compare ( old , new , _ ) : [EOL] [docstring] [EOL] return pyff_package_path ( old , new ) [EOL] [EOL] _pyff_that ( compare , [string] ) [EOL] [EOL] [EOL] def pyffdir ( ) : [EOL] [docstring] [EOL] [EOL] def compare ( old , new , _ ) : [EOL] [docstring] [EOL] return pyff_directory ( old , new ) [EOL] [EOL] _pyff_that ( compare , [string] ) [EOL] [EOL] [EOL] def pyffgit ( ) : [EOL] [docstring] [EOL] parser = ArgumentParser ( ) [EOL] parser . add_argument ( [string] ) [EOL] [EOL] def compare ( old , new , args ) : [EOL] [docstring] [EOL] return pyff_git_revision ( args . repository , old , new ) [EOL] [EOL] _pyff_that ( compare , [string] , parser ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] pyffmod ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Sized , Iterable [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Iterable , Sized [EOL] from colorama import Fore , Style [EOL] [EOL] HL_OPEN = [string] [EOL] HL_CLOSE = [string] [EOL] [EOL] HIGHLIGHTS = ( [string] , [string] ) [EOL] [EOL] [EOL] def highlight ( message , highlights ) : [EOL] [docstring] [EOL] if highlights == [string] : [EOL] return message . replace ( HL_OPEN , Fore . RED ) . replace ( HL_CLOSE , Style . RESET_ALL ) [EOL] elif highlights == [string] : [EOL] return message . replace ( HL_OPEN , [string] ) . replace ( HL_CLOSE , [string] ) [EOL] [EOL] raise ValueError ( [string] + str ( HIGHLIGHTS ) ) [EOL] [EOL] [EOL] def hl ( what ) : [comment] [EOL] [docstring] [EOL] return f"{ HL_OPEN }{ what }{ HL_CLOSE }" [EOL] [EOL] [EOL] def pluralize ( name , items ) : [EOL] [docstring] [EOL] return f"{ name }" if len ( items ) == [number] else f"{ name } [string] " [EOL] [EOL] [EOL] def hlistify ( container ) : [EOL] [docstring] [EOL] return [string] . join ( [ hl ( name ) for name in container ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , FrozenSet , Mapping , Union , Any , Literal , List , Set , Optional [EOL] import _ast [EOL] import typing_extensions [EOL] import logging [EOL] import pyff [EOL] import builtins [EOL] import typing [EOL] import ast [EOL] [docstring] [EOL] [EOL] import collections . abc [EOL] import types [EOL] from typing import Set , Dict , Union , Optional , FrozenSet , Mapping , cast [EOL] import ast [EOL] import logging [EOL] from pyff . kitchensink import hl , hlistify , pluralize [EOL] [EOL] ImportNode = Union [ ast . Import , ast . ImportFrom ] [comment] [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ImportedName : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , node , alias ) : [EOL] self . name = name [EOL] self . node = node [EOL] self . alias = alias [EOL] [EOL] def __repr__ ( self ) : [comment] [EOL] return f" [string] { self . name } [string] { self . node } [string] { self . alias }" [EOL] [EOL] def is_import ( self ) : [EOL] [docstring] [EOL] return isinstance ( self . node , ast . Import ) [EOL] [EOL] def is_import_from ( self ) : [EOL] [docstring] [EOL] return isinstance ( self . node , ast . ImportFrom ) [EOL] [EOL] @ property def canonical_name ( self ) : [EOL] [docstring] [EOL] if isinstance ( self . node , ast . Import ) : [EOL] return self . alias . name [EOL] elif isinstance ( self . node , ast . ImportFrom ) : [EOL] return f"{ self . node . module } [string] { self . alias . name }" [EOL] [EOL] raise Exception ( [string] ) [comment] [EOL] [EOL] @ property def canonical_ast ( self ) : [EOL] [docstring] [EOL] node = ... [EOL] [EOL] if isinstance ( self . node , ast . Import ) : [EOL] items = self . alias . name . split ( [string] ) [EOL] node = ast . Name ( id = items . pop ( [number] ) , ctx = ast . Load ( ) ) [EOL] while items : [EOL] node = ast . Attribute ( value = node , attr = items . pop ( [number] ) , ctx = ast . Load ( ) ) [EOL] return node [EOL] elif isinstance ( self . node , ast . ImportFrom ) : [EOL] if self . node . module is None : [EOL] raise Exception ( [string] ) [comment] [EOL] items = self . node . module . split ( [string] ) + [ self . alias . name ] [EOL] node = ast . Name ( id = items . pop ( [number] ) , ctx = ast . Load ( ) ) [EOL] while items : [EOL] node = ast . Attribute ( value = node , attr = items . pop ( [number] ) , ctx = ast . Load ( ) ) [EOL] return node [EOL] [EOL] raise Exception ( [string] ) [comment] [EOL] [EOL] def __str__ ( self ) : [EOL] return self . name [EOL] [EOL] [EOL] class FromImportPyfference : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _new = { } [EOL] self . _removed = { } [EOL] self . _new_modules = set ( ) [EOL] self . _removed_modules = set ( ) [EOL] [EOL] @ property def new ( self ) : [EOL] [docstring] [EOL] return types . MappingProxyType ( self . _new ) [EOL] [EOL] @ property def removed ( self ) : [EOL] [docstring] [EOL] return types . MappingProxyType ( self . _removed ) [EOL] [EOL] @ property def new_modules ( self ) : [EOL] [docstring] [EOL] return frozenset ( self . _new_modules ) [EOL] [EOL] @ property def removed_modules ( self ) : [EOL] [docstring] [EOL] return frozenset ( self . _removed_modules ) [EOL] [EOL] def add_new ( self , node ) : [EOL] [docstring] [EOL] if not node . is_import_from ( ) : [EOL] raise ValueError ( [string] ) [comment] [EOL] [EOL] module = cast ( ast . ImportFrom , node . node ) . module [EOL] [EOL] if module is None : [EOL] raise Exception ( [string] ) [comment] [EOL] [EOL] if module not in self . _new : [EOL] self . _new [ module ] = set ( ) [EOL] self . _new [ module ] . add ( node ) [EOL] [EOL] def add_removed ( self , node ) : [EOL] [docstring] [EOL] if not node . is_import_from ( ) : [EOL] raise ValueError ( [string] ) [comment] [EOL] [EOL] module = cast ( ast . ImportFrom , node . node ) . module [EOL] if module is None : [EOL] raise Exception ( [string] ) [comment] [EOL] [EOL] if module not in self . _removed : [EOL] self . _removed [ module ] = set ( ) [EOL] self . _removed [ module ] . add ( node ) [EOL] [EOL] def add_new_modules ( self , modules ) : [EOL] [docstring] [EOL] self . _new_modules . update ( modules ) [EOL] [EOL] def add_removed_modules ( self , modules ) : [EOL] [docstring] [EOL] self . _removed_modules . update ( modules ) [EOL] [EOL] def delete_new_module ( self , module ) : [EOL] [docstring] [EOL] self . _new_modules . discard ( module ) [EOL] if module in self . _new : [EOL] del self . _new [ module ] [EOL] [EOL] def delete_removed_module ( self , module ) : [EOL] [docstring] [EOL] self . _removed_modules . discard ( module ) [EOL] if module in self . _removed : [EOL] del self . _removed [ module ] [EOL] [EOL] def __bool__ ( self ) : [EOL] return bool ( self . _new or self . removed or self . new_modules or self . removed_modules ) [EOL] [EOL] [EOL] class ImportsPyfference : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _new_imports = set ( ) [EOL] self . _removed_imports = set ( ) [EOL] self . fromimports = FromImportPyfference ( ) [EOL] self . _changed_to_fromimport = { } [EOL] self . _changed_to_import = { } [EOL] [EOL] def __bool__ ( self ) : [EOL] return bool ( ( self . _new_imports or self . _removed_imports or self . fromimports or self . _changed_to_fromimport or self . _changed_to_import ) ) [EOL] [EOL] @ property def new_imports ( self ) : [EOL] [docstring] [EOL] return frozenset ( self . _new_imports ) [EOL] [EOL] @ property def removed_imports ( self ) : [EOL] [docstring] [EOL] return frozenset ( self . _removed_imports ) [EOL] [EOL] def simplify ( self ) : [EOL] [docstring] [EOL] return self if self else None [EOL] [EOL] def new_import ( self , node ) : [EOL] [docstring] [EOL] self . _new_imports . add ( node ) [EOL] [EOL] def removed_import ( self , node ) : [EOL] [docstring] [EOL] self . _removed_imports . add ( node ) [EOL] [EOL] def new_from_import ( self , node ) : [EOL] [docstring] [EOL] if not node . is_import_from ( ) : [EOL] raise ValueError ( [string] ) [comment] [EOL] [EOL] if cast ( ast . ImportFrom , node . node ) . module : [EOL] self . fromimports . add_new ( node ) [EOL] [EOL] def removed_from_import ( self , node ) : [EOL] [docstring] [EOL] if not node . is_import_from ( ) : [EOL] raise ValueError ( [string] ) [comment] [EOL] [EOL] if cast ( ast . ImportFrom , node . node ) . module : [EOL] self . fromimports . add_removed ( node ) [EOL] [EOL] def new_fromimport_modules ( self , modules ) : [EOL] [docstring] [EOL] self . fromimports . add_new_modules ( modules ) [EOL] [EOL] def removed_fromimport_modules ( self , modules ) : [EOL] [docstring] [EOL] self . fromimports . add_removed_modules ( modules ) [EOL] [EOL] def reduce ( self ) : [EOL] [docstring] [EOL] for name in set ( self . _new_imports ) : [EOL] if name . name in self . fromimports . removed_modules : [EOL] LOGGER . debug ( f" [string] { name } [string] " f" [string] { name } [string] " f" [string] " ) [EOL] self . _new_imports . discard ( name ) [EOL] self . _changed_to_import [ name . name ] = self . fromimports . removed [ name . name ] [EOL] self . fromimports . delete_removed_module ( name . name ) [EOL] [EOL] for name in set ( self . _removed_imports ) : [EOL] if name . name in self . fromimports . new_modules : [EOL] self . _removed_imports . discard ( name ) [EOL] self . _changed_to_fromimport [ name . name ] = self . fromimports . new [ name . name ] [EOL] self . fromimports . delete_new_module ( name . name ) [EOL] LOGGER . debug ( f" [string] { name } [string] " f" [string] { name } [string] " f" [string] " ) [EOL] [EOL] def __str__ ( self ) : [EOL] lines = [ ] [EOL] removed_imports = sorted ( [ name . name for name in self . removed_imports ] ) [EOL] if removed_imports : [EOL] packages = pluralize ( [string] , removed_imports ) [EOL] names = hlistify ( removed_imports ) [EOL] lines . append ( f" [string] { packages } [string] { names }" ) [EOL] [EOL] new_imports = sorted ( [ name . name for name in self . new_imports ] ) [EOL] if new_imports : [EOL] packages = pluralize ( [string] , new_imports ) [EOL] names = hlistify ( new_imports ) [EOL] lines . append ( f" [string] { packages } [string] { names }" ) [EOL] [EOL] for module , names in self . fromimports . removed . items ( ) : [EOL] removed_names = sorted ( [ str ( name ) for name in names ] ) [EOL] hl_removed_names = hlistify ( removed_names ) [EOL] if module in self . fromimports . removed_modules : [EOL] lines . append ( f" [string] { hl_removed_names } [string] { hl ( module ) }" ) [EOL] else : [EOL] lines . append ( f" [string] { hl_removed_names } [string] { hl ( module ) }" ) [EOL] [EOL] for module , names in self . fromimports . new . items ( ) : [EOL] new_names = sorted ( [ str ( name ) for name in names ] ) [EOL] if module in self . fromimports . new_modules : [EOL] lines . append ( f" [string] { hlistify ( new_names ) } [string] { hl ( module ) }" ) [EOL] else : [EOL] lines . append ( f" [string] { hlistify ( new_names ) } [string] { hl ( module ) }" ) [EOL] [EOL] for module , names in self . _changed_to_fromimport . items ( ) : [EOL] new_names = sorted ( [ str ( name ) for name in names ] ) [EOL] lines . append ( f" [string] { hlistify ( new_names ) } [string] { hl ( module ) } [string] " f" [string] { hl ( module ) } [string] " ) [EOL] [EOL] for module , names in self . _changed_to_import . items ( ) : [EOL] new_names = sorted ( [ str ( name ) for name in names ] ) [EOL] was = [string] if len ( new_names ) == [number] else [string] [EOL] lines . append ( f" [string] { hl ( module ) } [string] " f" [string] { hlistify ( new_names ) } [string] " f"{ was } [string] { hl ( module ) } [string] " ) [EOL] [EOL] return [string] . join ( lines ) [EOL] [EOL] [EOL] class ImportedNames ( collections . abc . Mapping ) : [comment] [EOL] [docstring] [EOL] [EOL] @ staticmethod def extract ( code ) : [EOL] [docstring] [EOL] import_walker = ImportExtractor ( ) [EOL] import_walker . visit ( code ) [EOL] return import_walker . names [EOL] [EOL] @ staticmethod def compare ( old , new ) : [EOL] [docstring] [EOL] LOGGER . debug ( [string] ) [EOL] change = ImportsPyfference ( ) [EOL] for name , node in new . names . items ( ) : [EOL] if name not in old . names : [EOL] LOGGER . debug ( f" [string] { name } [string] " ) [EOL] if node . is_import ( ) : [EOL] change . new_import ( node ) [EOL] elif node . is_import_from ( ) : [EOL] change . new_from_import ( node ) [EOL] [EOL] for name , node in old . names . items ( ) : [EOL] if name not in new . names : [EOL] LOGGER . debug ( f" [string] { name } [string] " ) [EOL] if node . is_import ( ) : [EOL] change . removed_import ( node ) [EOL] elif node . is_import_from ( ) : [EOL] change . removed_from_import ( node ) [EOL] [EOL] change . new_fromimport_modules ( new . from_modules - old . from_modules ) [EOL] LOGGER . debug ( f" [string] " f"{ change . fromimports . new }" ) [EOL] change . removed_fromimport_modules ( old . from_modules - new . from_modules ) [EOL] LOGGER . debug ( f" [string] " f"{ change . fromimports . removed }" ) [EOL] [EOL] change . reduce ( ) [EOL] [EOL] return change if change else None [EOL] [EOL] def __init__ ( self ) : [EOL] self . names = { } [EOL] self . from_modules = set ( ) [EOL] [EOL] def __getitem__ ( self , item ) : [EOL] return self . names [ item ] [EOL] [EOL] def __iter__ ( self ) : [EOL] yield from self . names [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . names ) [EOL] [EOL] def __repr__ ( self ) : [comment] [EOL] return f" [string] { self . names } [string] { self . from_modules }" [EOL] [EOL] def _add ( self , name , node ) : [EOL] if name . asname is not None : [EOL] self . names [ name . asname ] = ImportedName ( name . asname , node , alias = name ) [EOL] else : [EOL] self . names [ name . name ] = ImportedName ( name . name , node , alias = name ) [EOL] [EOL] def add_import ( self , node ) : [EOL] [docstring] [EOL] for name in node . names : [EOL] self . _add ( name , node ) [EOL] [EOL] def add_importfrom ( self , node ) : [EOL] [docstring] [EOL] for name in node . names : [EOL] self . _add ( name , node ) [EOL] if node . module : [EOL] self . from_modules . add ( node . module ) [EOL] [EOL] [EOL] class ImportExtractor ( ast . NodeVisitor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . names = ImportedNames ( ) [EOL] super ( ImportExtractor , self ) . __init__ ( ) [EOL] [EOL] def visit_Import ( self , node ) : [comment] [EOL] [docstring] [EOL] self . names . add_import ( node ) [EOL] [EOL] def visit_ImportFrom ( self , node ) : [comment] [EOL] [docstring] [EOL] self . names . add_importfrom ( node ) [EOL] [EOL] [EOL] def pyff_imports ( old , new ) : [EOL] [docstring] [EOL] old_walker = ImportExtractor ( ) [EOL] new_walker = ImportExtractor ( ) [EOL] [EOL] old_walker . visit ( old ) [EOL] new_walker . visit ( new ) [EOL] [EOL] difference = ImportedNames . compare ( old_walker . names , new_walker . names ) [EOL] [EOL] return difference if difference else None [EOL] [EOL] [EOL] def pyff_imports_code ( old_code , new_code ) : [EOL] [docstring] [EOL] old_ast = ast . parse ( old_code ) [EOL] new_ast = ast . parse ( new_code ) [EOL] [EOL] return pyff_imports ( old_ast , new_ast ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $ImportNode$ 0 $ast.alias$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $ImportNode$ 0 $ImportNode$ 0 0 0 $ast.alias$ 0 $ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[ast.Name,ast.Attribute]$ 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[ImportedName]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[ImportedName]]$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Set[ImportedName]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Set[ImportedName]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $ImportedName$ 0 0 0 0 0 0 0 $ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $ImportedName$ 0 $ImportedName$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $ImportedName$ 0 0 0 0 $None$ 0 0 0 $ImportedName$ 0 0 0 0 0 0 0 $ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $ImportedName$ 0 $ImportedName$ 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $ImportedName$ 0 0 0 0 $None$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $None$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[ImportedName]$ 0 0 0 0 0 0 0 $typing.Set[ImportedName]$ 0 0 0 0 0 0 0 $FromImportPyfference$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[ImportedName]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[ImportedName]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[ImportedName]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[ImportedName]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional["ImportsPyfference"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 $ImportedName$ 0 0 0 0 $None$ 0 0 0 $ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 $ImportedName$ 0 0 0 0 $None$ 0 0 0 $ImportedName$ 0 0 0 0 0 0 0 $ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ImportedName$ 0 $ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 $ImportedName$ 0 0 0 0 $None$ 0 0 0 $ImportedName$ 0 0 0 0 0 0 0 $ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ImportedName$ 0 $ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 $ImportedName$ 0 0 0 0 $None$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $None$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ImportedNames"$ 0 $ast.Module$ 0 0 0 0 0 $pyff.imports.ImportExtractor$ 0 0 0 0 0 $pyff.imports.ImportExtractor$ 0 0 0 $ast.Module$ 0 0 0 $pyff.imports.ImportExtractor$ 0 0 0 0 0 0 0 $typing.Optional[ImportsPyfference]$ 0 $"ImportedNames"$ 0 $"ImportedNames"$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 0 0 0 0 0 $"ImportedNames"$ 0 0 0 0 0 0 0 0 0 0 0 0 $"ImportedNames"$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $"ImportedNames"$ 0 0 0 0 0 0 0 0 0 0 0 0 $"ImportedNames"$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 $"ImportedNames"$ 0 0 0 $"ImportedNames"$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 $"ImportedNames"$ 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 $"ImportedNames"$ 0 0 0 $"ImportedNames"$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,ImportedName]$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $ast.alias$ 0 $ImportNode$ 0 0 0 0 $ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 $ast.alias$ 0 0 0 0 0 0 $ast.alias$ 0 0 0 $ImportNode$ 0 0 0 $ast.alias$ 0 0 0 0 0 0 0 0 0 $ast.alias$ 0 $ast.alias$ 0 0 0 0 $ast.alias$ 0 $ast.alias$ 0 $ImportNode$ 0 0 0 $ast.alias$ 0 0 0 0 $None$ 0 0 0 $ast.Import$ 0 0 0 0 0 0 0 0 $ast.Import$ 0 0 0 0 0 0 0 0 0 0 $ast.Import$ 0 0 0 0 $None$ 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 0 0 0 0 0 $ast.ImportFrom$ 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 0 0 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import pyff [EOL] [docstring] [EOL] [EOL] import tempfile [EOL] import shutil [EOL] import pathlib [EOL] from typing import Optional [EOL] import git [EOL] [EOL] [EOL] import pyff . directories as pd [EOL] import pyff . packages as pp [EOL] [EOL] [EOL] class RevisionsPyfference : [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def __init__ ( self , change ) : [EOL] self . _change = change [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . _change ) [EOL] [EOL] @ property def packages ( self ) : [EOL] [docstring] [EOL] return self . _change . packages [EOL] [EOL] [EOL] def pyff_git_revision ( repository , old , new ) : [EOL] [docstring] [EOL] with tempfile . TemporaryDirectory ( ) as temporary_wd : [EOL] working_directory = pathlib . Path ( temporary_wd ) [EOL] source_dir = working_directory / [string] [EOL] old_dir = working_directory / [string] [EOL] new_dir = working_directory / [string] [EOL] [EOL] repo = git . Repo . clone_from ( repository , source_dir ) [EOL] [EOL] repo . git . checkout ( old ) [EOL] shutil . copytree ( source_dir , old_dir ) [EOL] [EOL] repo . git . checkout ( new ) [EOL] shutil . copytree ( source_dir , new_dir ) [EOL] [EOL] change = pd . pyff_directory ( old_dir , new_dir ) [EOL] if change : [EOL] return RevisionsPyfference ( change ) [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 0 $pyff.directories.DirectoryPyfference$ 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.packages.PackagesPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[RevisionsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List , Optional [EOL] import logging [EOL] import pyff [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] import ast [EOL] [docstring] [EOL] [EOL] import ast [EOL] import logging [EOL] import pathlib [EOL] from typing import List , Optional , Dict [EOL] [EOL] import pyff . classes as pc [EOL] import pyff . functions as pf [EOL] import pyff . imports as pi [EOL] from pyff . kitchensink import hl , pluralize , hlistify [EOL] [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ModuleSummary : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , node ) : [EOL] self . name = name [EOL] self . node = node [EOL] [EOL] [EOL] class ModulePyfference : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , imports = None , classes = None , functions = None , ) : [EOL] [EOL] self . other = [ ] [EOL] self . imports = imports [EOL] self . classes = classes [EOL] self . functions = functions [EOL] [EOL] def __str__ ( self ) : [EOL] changes = [ self . imports , self . classes , self . functions ] + self . other [EOL] return [string] . join ( [ str ( change ) for change in changes if change is not None ] ) [EOL] [EOL] def simplify ( self ) : [EOL] [docstring] [EOL] if self . imports is not None : [EOL] self . imports = self . imports . simplify ( ) [EOL] [EOL] if self . classes is not None : [EOL] self . classes = self . classes . simplify ( ) [EOL] [EOL] if self . functions is not None : [EOL] self . functions = self . functions . simplify ( ) [EOL] [EOL] return self if ( self . functions or self . classes or self . imports or self . other ) else None [EOL] [EOL] [EOL] class ModulesPyfference : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , removed , changed , new , ) : [EOL] self . removed = removed [EOL] self . changed = changed [EOL] self . new = new [EOL] [EOL] def __str__ ( self ) : [EOL] lines = [ ] [EOL] [EOL] if self . removed : [EOL] lines . append ( f" [string] { pluralize ( [string] , self . removed ) } [string] { hlistify ( sorted ( self . removed ) ) }" ) [EOL] [EOL] if self . changed : [EOL] lines . append ( [string] . join ( [ f" [string] { hl ( module ) } [string] " + str ( change ) . replace ( [string] , [string] ) for module , change in sorted ( self . changed . items ( ) ) ] ) ) [EOL] [EOL] if self . new : [EOL] lines . append ( f" [string] { pluralize ( [string] , self . new ) } [string] { hlistify ( sorted ( self . new ) ) }" ) [EOL] [EOL] return [string] . join ( lines ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( f" [string] { repr ( self . removed ) } [string] " f" [string] { repr ( self . changed ) } [string] { repr ( self . new ) } [string] " ) [EOL] [EOL] def __bool__ ( self ) : [EOL] return bool ( self . removed or self . changed or self . new ) [EOL] [EOL] [EOL] def summarize_module ( module ) : [EOL] [docstring] [EOL] return ModuleSummary ( name = module . name , node = ast . parse ( module . read_text ( ) ) ) [EOL] [EOL] [EOL] def pyff_module ( old , new ) : [EOL] [docstring] [EOL] old_imports = pi . ImportedNames . extract ( old . node ) [EOL] new_imports = pi . ImportedNames . extract ( new . node ) [EOL] imports = pi . pyff_imports ( old . node , new . node ) [EOL] classes = pc . pyff_classes ( old . node , new . node , old_imports , new_imports ) [EOL] functions = pf . pyff_functions ( old . node , new . node , old_imports , new_imports ) [EOL] [EOL] if imports or classes or functions : [EOL] LOGGER . debug ( [string] ) [EOL] pyfference = ModulePyfference ( imports , classes , functions ) [EOL] return pyfference [EOL] [EOL] LOGGER . debug ( [string] ) [EOL] return None [EOL] [EOL] [EOL] def pyff_module_path ( old , new ) : [EOL] [docstring] [EOL] return pyff_module ( summarize_module ( old ) , summarize_module ( new ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $ast.Module$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $ast.Module$ 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,pyff.classes.ClassesPyfference,pyff.functions.FunctionsPyfference,pyff.imports.ImportsPyfference]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,pyff.classes.ClassesPyfference,pyff.functions.FunctionsPyfference,pyff.imports.ImportsPyfference]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional["ModulePyfference"]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[pathlib.Path,ModuleSummary]$ 0 $typing.Dict[pathlib.Path,ModulePyfference]$ 0 $typing.Dict[pathlib.Path,ModuleSummary]$ 0 0 0 0 0 0 $typing.Dict[pathlib.Path,ModuleSummary]$ 0 $typing.Dict[pathlib.Path,ModuleSummary]$ 0 0 0 $typing.Dict[pathlib.Path,ModulePyfference]$ 0 $typing.Dict[pathlib.Path,ModulePyfference]$ 0 0 0 $typing.Dict[pathlib.Path,ModuleSummary]$ 0 $typing.Dict[pathlib.Path,ModuleSummary]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ModuleSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ModulePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ModulePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Set , Optional [EOL] import logging [EOL] import pyff [EOL] import builtins [EOL] import typing [EOL] import ast [EOL] [docstring] [EOL] [EOL] import ast [EOL] import logging [EOL] import copy [EOL] from typing import Set , Optional , Dict [EOL] import pyff . imports as pi [EOL] from pyff . kitchensink import hl [EOL] [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class SingleExternalNameUsageChange : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def __init__ ( self , old , new ) : [EOL] self . old = old [EOL] self . new = new [EOL] [EOL] self . _key = ( old , new ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , SingleExternalNameUsageChange ) [EOL] and self . old == other . old [EOL] and self . new == other . new ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . _key ) [EOL] [EOL] def __repr__ ( self ) : [comment] [EOL] return f" [string] { self . old } [string] { self . new } [string] " [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { hl ( self . old ) } [string] { hl ( self . new ) }" [EOL] [EOL] [EOL] class ExternalNameUsageChange : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def __init__ ( self , changes ) : [EOL] self . changes = changes [EOL] [EOL] def __repr__ ( self ) : [comment] [EOL] return f" [string] { self . changes } [string] " [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . join ( sorted ( [ str ( line ) for line in self . changes ] ) ) [EOL] [EOL] [EOL] class FullyQualifyNames ( ast . NodeTransformer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , imports ) : [EOL] super ( FullyQualifyNames , self ) . __init__ ( ) [EOL] self . external_names = imports [EOL] self . substitutions = { } [EOL] self . references = { } [EOL] self . _current = None [EOL] [EOL] def visit_Name ( self , node ) : [comment] [EOL] self . _current = None [EOL] if node . id in self . external_names : [EOL] self . _current = self . external_names [ node . id ] . canonical_name [EOL] self . references [ self . _current ] = node . id [EOL] if node . id == self . _current : [EOL] return node [EOL] [EOL] self . substitutions [ node . id ] = self . _current [EOL] return self . external_names [ node . id ] . canonical_ast [EOL] [EOL] return node [EOL] [EOL] def visit_Attribute ( self , node ) : [comment] [EOL] self . generic_visit ( node ) [EOL] if self . _current : [EOL] prefix = self . _current [EOL] self . _current = [string] . join ( [ prefix , node . attr ] ) [EOL] key = self . references [ prefix ] [EOL] self . references [ self . _current ] = [string] . join ( [ key , node . attr ] ) [EOL] [EOL] return node [EOL] [EOL] [EOL] def find_external_name_matches ( old , new , old_imports , new_imports ) : [EOL] [docstring] [EOL] [EOL] if ast . dump ( old ) == ast . dump ( new ) : [EOL] return None [EOL] [EOL] fq_old_transformer = FullyQualifyNames ( old_imports ) [EOL] fq_new_transformer = FullyQualifyNames ( new_imports ) [EOL] [EOL] LOGGER . debug ( [string] ) [EOL] fq_old = fq_old_transformer . visit ( copy . deepcopy ( old ) ) [EOL] LOGGER . debug ( [string] ) [EOL] fq_new = fq_new_transformer . visit ( copy . deepcopy ( new ) ) [EOL] [EOL] changes = set ( ) [EOL] [EOL] if ast . dump ( fq_old ) == ast . dump ( fq_new ) : [EOL] LOGGER . debug ( [string] ) [EOL] LOGGER . debug ( f" [string] { fq_old_transformer . references }" ) [EOL] LOGGER . debug ( f" [string] { fq_new_transformer . references }" ) [EOL] for original , fqdn in fq_old_transformer . substitutions . items ( ) : [EOL] LOGGER . debug ( f" [string] { original } [string] { fqdn } [string] " ) [EOL] if fqdn in fq_new_transformer . references : [EOL] changes . add ( SingleExternalNameUsageChange ( original , fq_new_transformer . references [ fqdn ] ) ) [EOL] [EOL] for original , fqdn in fq_new_transformer . substitutions . items ( ) : [EOL] LOGGER . debug ( f" [string] { original } [string] { fqdn } [string] " ) [EOL] if fqdn in fq_old_transformer . references : [EOL] changes . add ( SingleExternalNameUsageChange ( fq_old_transformer . references [ fqdn ] , original ) ) [EOL] [EOL] return ExternalNameUsageChange ( changes ) if changes else None [EOL] [EOL] [EOL] class StatementPyfference : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . semantically_relevant = set ( ) [EOL] self . semantically_irrelevant = set ( ) [EOL] [EOL] def add_semantically_irrelevant_change ( self , change ) : [comment] [EOL] [docstring] [EOL] self . semantically_irrelevant . add ( change ) [EOL] [EOL] def add_semantically_relevant_change ( self , change ) : [comment] [EOL] [docstring] [EOL] self . semantically_relevant . add ( change ) [EOL] [EOL] def semantically_different ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return bool ( self . semantically_relevant or not self . semantically_irrelevant ) [EOL] [EOL] def __str__ ( self ) : [EOL] lines = [ ] [EOL] for change in self . semantically_relevant : [EOL] lines . append ( str ( change ) ) [EOL] [EOL] for change in self . semantically_irrelevant : [EOL] lines . append ( str ( change ) ) [EOL] [EOL] return [string] . join ( lines ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( f" [string] { repr ( self . semantically_relevant ) } [string] " f" [string] { repr ( self . semantically_irrelevant ) } [string] " ) [EOL] [EOL] def is_specific ( self ) : [EOL] [docstring] [EOL] return bool ( self . semantically_relevant or self . semantically_irrelevant ) [EOL] [EOL] [EOL] def pyff_statement ( old_statement , new_statement , old_imports , new_imports , ) : [EOL] [docstring] [EOL] [EOL] if ast . dump ( old_statement ) == ast . dump ( new_statement ) : [EOL] return None [EOL] [EOL] pyfference = StatementPyfference ( ) [EOL] [EOL] change = find_external_name_matches ( old_statement , new_statement , old_imports , new_imports ) [EOL] if change : [EOL] LOGGER . debug ( [string] ) [EOL] pyfference . add_semantically_irrelevant_change ( change ) [EOL] [EOL] return pyfference [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Set[SingleExternalNameUsageChange]$ 0 0 0 0 0 $typing.Set[SingleExternalNameUsageChange]$ 0 $typing.Set[SingleExternalNameUsageChange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 $pyff.imports.ImportedNames$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ExternalNameUsageChange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Set$ 0 0 0 0 0 0 0 $typing.Set$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[StatementPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] __version__ = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
	0
	0
def main ( ) : [EOL] print ( [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import argparse [EOL] from argparse import Action , ArgumentParser [EOL] [EOL] class ParsePlayerAction ( Action ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] Action . __init__ ( self , * args , ** kwargs ) [EOL] [EOL] def __call__ ( self , parser , namespace , values , option_string = None ) : [EOL] if [number] < len ( values ) < [number] : [EOL] setattr ( namespace , self . dest , values ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def main ( ) : [EOL] parser = ArgumentParser ( ) [EOL] subcommands = parser . add_subparsers ( ) [EOL] [EOL] add = subcommands . add_parser ( [string] ) [EOL] add . add_argument ( [string] , action = ParsePlayerAction , nargs = [string] ) [EOL] [EOL] parser . parse_args ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import pyff [EOL] [docstring] [EOL] [EOL] import ast [EOL] import pyff . imports as pi [EOL] import pyff . functions as pf [EOL] [EOL] [EOL] def parse_imports ( code ) : [EOL] [docstring] [EOL] extractor = pi . ImportExtractor ( ) [EOL] extractor . visit ( ast . parse ( code ) ) [EOL] return extractor . names [EOL] [EOL] [EOL] def extract_names_from_function ( code , imported_names ) : [EOL] [docstring] [EOL] extractor = pf . ExternalNamesExtractor ( imported_names ) [EOL] extractor . visit ( ast . parse ( code ) ) [EOL] return extractor . names [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Set , Optional , Any [EOL] import _ast [EOL] import pyff [EOL] import builtins [EOL] import typing [EOL] import unittest [EOL] import ast [EOL] from unittest . mock import Mock [EOL] import pytest [EOL] import pyff . functions as pf [EOL] import pyff . imports as pi [EOL] import pyff . statements as ps [EOL] [EOL] from helpers import parse_imports , extract_names_from_function [EOL] [EOL] [EOL] class TestFunctionImplementationChange : [EOL] def test_sanity ( self ) : [EOL] fic = pf . FunctionImplementationChange ( ) [EOL] assert fic is not None [EOL] [EOL] def test_make_message ( self ) : [EOL] fic = pf . FunctionImplementationChange ( ) [EOL] assert fic . make_message ( ) == [string] [EOL] [EOL] def test_equality ( self ) : [EOL] assert pf . FunctionImplementationChange ( ) == pf . FunctionImplementationChange ( ) [EOL] a_set = { pf . FunctionImplementationChange ( ) } [EOL] a_set . add ( pf . FunctionImplementationChange ( ) ) [EOL] assert len ( a_set ) == [number] [EOL] [EOL] [EOL] class TestExternalUsageChange : [EOL] def test_sanity ( self ) : [EOL] euc = pf . ExternalUsageChange ( gone = { [string] , [string] } , appeared = { [string] } ) [EOL] assert euc . gone == { [string] , [string] } [EOL] assert euc . appeared == { [string] } [EOL] [EOL] def test_make_message ( self ) : [EOL] euc = pf . ExternalUsageChange ( gone = { [string] , [string] } , appeared = { [string] } ) [EOL] assert ( euc . make_message ( ) == [string] [string] ) [EOL] [EOL] def test_equality ( self ) : [EOL] euc = pf . ExternalUsageChange ( gone = { [string] , [string] } , appeared = { [string] } ) [EOL] euc_same = pf . ExternalUsageChange ( gone = { [string] , [string] } , appeared = { [string] } ) [EOL] euc_diff = pf . ExternalUsageChange ( gone = { [string] } , appeared = { [string] } ) [EOL] [EOL] assert euc == euc_same [EOL] assert euc != euc_diff [EOL] [EOL] [EOL] class TestStatementChange : [EOL] def test_sanity ( self ) : [EOL] spyff = ps . StatementPyfference ( ) [EOL] change = pf . StatementChange ( spyff ) [EOL] [EOL] assert change . make_message ( ) == str ( spyff ) [EOL] [EOL] [EOL] class TestFunctionPyfferenceRecorder : [EOL] def test_nochange ( self ) : [EOL] recorder = pf . FunctionPyfferenceRecorder ( [string] ) [EOL] assert recorder . build ( ) is None [EOL] [EOL] def test_namechange ( self ) : [EOL] recorder = pf . FunctionPyfferenceRecorder ( [string] ) [EOL] recorder . name_changed ( [string] ) [EOL] pyfference = recorder . build ( ) [EOL] assert pyfference . name == [string] [EOL] assert pyfference . old_name == [string] [EOL] assert not pyfference . implementation [EOL] [EOL] def test_implementation ( self ) : [EOL] recorder = pf . FunctionPyfferenceRecorder ( [string] ) [EOL] recorder . implementation_changed ( pf . FunctionImplementationChange ( ) ) [EOL] pyfference = recorder . build ( ) [EOL] assert pyfference . old_name is None [EOL] assert len ( pyfference . implementation ) == [number] [EOL] [EOL] [EOL] class TestFunctionPyfference : [EOL] def test_sanity ( self ) : [comment] [EOL] fic = pf . FunctionImplementationChange ( ) [EOL] fp1 = pf . FunctionPyfference ( name = [string] , implementation = { fic } , old_name = [string] ) [EOL] assert fp1 . name == [string] [EOL] assert fp1 . implementation == { fic } [EOL] assert fp1 . old_name == [string] [EOL] [EOL] fp2 = pf . FunctionPyfference ( name = [string] , implementation = { fic } ) [EOL] assert fp2 . name == [string] [EOL] assert fp2 . implementation == { fic } [EOL] assert fp2 . old_name is None [EOL] [EOL] def test_name_change ( self ) : [EOL] change = pf . FunctionPyfference ( name = [string] , implementation = set ( ) , old_name = [string] ) [EOL] assert str ( change ) == [string] [EOL] [EOL] def test_method_name_change ( self ) : [EOL] change = pf . FunctionPyfference ( name = [string] , implementation = set ( ) , old_name = [string] ) [EOL] change . set_method ( ) [EOL] assert str ( change ) == [string] [EOL] [EOL] def test_implementation_change ( self ) : [EOL] fic = pf . FunctionImplementationChange ( ) [EOL] change = pf . FunctionPyfference ( name = [string] , implementation = { fic } ) [EOL] assert ( str ( change ) == [string] [string] ) [EOL] [EOL] def test_simplify ( self ) : [EOL] fic = pf . FunctionImplementationChange ( ) [EOL] change = pf . FunctionPyfference ( name = [string] , implementation = { fic } ) [EOL] assert change . simplify ( ) is change [EOL] [EOL] empty_change = pf . FunctionPyfference ( name = [string] , implementation = set ( ) ) [EOL] assert empty_change . simplify ( ) is None [EOL] [EOL] name_change = pf . FunctionPyfference ( name = [string] , implementation = set ( ) , old_name = [string] ) [EOL] assert name_change . simplify ( ) is name_change [EOL] [EOL] [EOL] class TestExternalNamesExtractor : [EOL] def test_import ( self ) : [EOL] imported_names = parse_imports ( [string] ) [EOL] package_names = extract_names_from_function ( [string] , imported_names ) [EOL] assert package_names == { [string] } [EOL] [EOL] module_names = extract_names_from_function ( [string] , imported_names ) [EOL] assert module_names == { [string] } [EOL] [EOL] alias_names = extract_names_from_function ( [string] , imported_names ) [EOL] assert alias_names == { [string] , [string] } [EOL] [EOL] def test_importfrom ( self ) : [EOL] imported_names = parse_imports ( [string] [string] ) [EOL] package_names = extract_names_from_function ( [string] , imported_names ) [EOL] assert package_names == { [string] } [EOL] [EOL] alias_names = extract_names_from_function ( [string] , imported_names ) [EOL] assert alias_names == { [string] } [EOL] [EOL] module_names = extract_names_from_function ( [string] , imported_names ) [EOL] assert module_names == { [string] } [EOL] [EOL] [EOL] class TestCompareImportUsage : [EOL] def test_no_external ( self ) : [EOL] old_imports = parse_imports ( [string] ) [EOL] new_imports = parse_imports ( [string] ) [EOL] [EOL] old_function = ast . parse ( [string] ) [EOL] new_function = ast . parse ( [string] ) [EOL] [EOL] assert pf . compare_import_usage ( old_function , new_function , old_imports , new_imports ) is None [EOL] [EOL] def test_appeared ( self ) : [EOL] old_imports = parse_imports ( [string] ) [EOL] new_imports = parse_imports ( [string] ) [EOL] [EOL] old_function = ast . parse ( [string] ) [EOL] new_function = ast . parse ( [string] ) [EOL] [EOL] change = pf . compare_import_usage ( old_function , new_function , old_imports , new_imports ) [EOL] assert change . appeared == { [string] } [EOL] [EOL] def test_gone ( self ) : [EOL] old_imports = parse_imports ( [string] ) [EOL] new_imports = parse_imports ( [string] ) [EOL] [EOL] old_function = ast . parse ( [string] ) [EOL] new_function = ast . parse ( [string] ) [EOL] [EOL] change = pf . compare_import_usage ( old_function , new_function , old_imports , new_imports ) [EOL] assert change . appeared == { [string] } [EOL] assert change . gone == { [string] } [EOL] [EOL] [EOL] class TestPyffFunction : [EOL] @ staticmethod def _make_summary ( code ) : [EOL] extractor = pf . FunctionsExtractor ( ) [EOL] extractor . visit ( ast . parse ( code ) ) [EOL] return extractor . functions . popitem ( ) [ [number] ] [EOL] [EOL] def test_identical ( self ) : [EOL] [comment] [EOL] old = self . _make_summary ( [string] ) [EOL] new = self . _make_summary ( [string] ) [EOL] [EOL] assert pf . pyff_function ( old , new , pi . ImportedNames ( ) , pi . ImportedNames ( ) ) is None [EOL] [EOL] def test_namechange ( self ) : [EOL] [comment] [EOL] old = self . _make_summary ( [string] ) [EOL] new = self . _make_summary ( [string] ) [EOL] [EOL] pyfference = pf . pyff_function ( old , new , pi . ImportedNames ( ) , pi . ImportedNames ( ) ) [EOL] assert pyfference . name == [string] [EOL] assert pyfference . old_name == [string] [EOL] [EOL] def test_imports_fixes ( self ) : [EOL] old = self . _make_summary ( [string] ) [EOL] new = self . _make_summary ( [string] ) [EOL] old_imports = parse_imports ( [string] ) [EOL] new_imports = parse_imports ( [string] ) [EOL] [EOL] pyfference = pf . pyff_function ( old , new , old_imports , new_imports ) [EOL] assert len ( pyfference . implementation ) == [number] [EOL] [EOL] def test_external_name_usage ( self ) : [EOL] old = self . _make_summary ( [string] ) [EOL] new = self . _make_summary ( [string] ) [EOL] old_imports = parse_imports ( [string] ) [EOL] new_imports = parse_imports ( [string] ) [EOL] [EOL] pyfference = pf . pyff_function ( old , new , old_imports , new_imports ) [EOL] assert len ( pyfference . implementation ) == [number] [EOL] [EOL] def test_different_statement_count ( self ) : [EOL] old = self . _make_summary ( [string] ) [EOL] new = self . _make_summary ( [string] ) [EOL] no_imports = parse_imports ( [string] ) [EOL] [EOL] pyfference = pf . pyff_function ( old , new , no_imports , no_imports ) [EOL] assert len ( pyfference . implementation ) == [number] [EOL] [EOL] [EOL] class TestPyffFunctionCode : [EOL] [EOL] FUNCTION = [string] [EOL] FUNKTION = [string] [EOL] KLASS = [string] [EOL] [EOL] def test_identical ( self ) : [EOL] assert ( pf . pyff_function_code ( self . FUNCTION , self . FUNCTION , pi . ImportedNames ( ) , pi . ImportedNames ( ) ) is None ) [EOL] [EOL] def test_namechange ( self ) : [EOL] pyfference = pf . pyff_function_code ( self . FUNCTION , self . FUNKTION , pi . ImportedNames ( ) , pi . ImportedNames ( ) ) [EOL] assert pyfference . name == [string] [EOL] assert pyfference . old_name == [string] [EOL] [EOL] def test_invalid ( self ) : [EOL] with pytest . raises ( ValueError ) : [EOL] pf . pyff_function_code ( self . FUNCTION , self . KLASS , pi . ImportedNames ( ) , pi . ImportedNames ( ) ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] pf . pyff_function_code ( self . KLASS , self . FUNKTION , pi . ImportedNames ( ) , pi . ImportedNames ( ) ) [EOL] [EOL] [EOL] class TestFunctionSummary : [EOL] @ pytest . fixture def mocked_node ( self ) : [EOL] return Mock ( spec = ast . FunctionDef ) [EOL] [EOL] def test_sanity ( self , mocked_node ) : [EOL] summary = pf . FunctionSummary ( [string] , node = mocked_node ) [EOL] assert summary . name == [string] [EOL] assert summary == pf . FunctionSummary ( [string] , node = mocked_node ) [EOL] assert summary != pf . FunctionSummary ( [string] , node = mocked_node ) [EOL] assert str ( summary ) == [string] [EOL] [EOL] def test_set_method ( self , mocked_node ) : [EOL] summary = pf . FunctionSummary ( [string] , node = mocked_node ) [EOL] summary . set_method ( ) [EOL] assert str ( summary ) == [string] [EOL] [EOL] def test_property ( self , mocked_node ) : [EOL] noprop = pf . FunctionSummary ( [string] , node = mocked_node ) [EOL] assert not noprop . property [EOL] prop = pf . FunctionSummary ( [string] , is_property = True , node = mocked_node ) [EOL] assert prop . property [EOL] assert str ( prop ) == [string] [EOL] [EOL] [EOL] class TestFunctionsExtractor : [EOL] @ pytest . fixture def extractor ( self ) : [EOL] return pf . FunctionsExtractor ( ) [EOL] [EOL] def test_functions ( self , extractor ) : [EOL] extractor . visit ( ast . parse ( [string] [string] [string] [string] ) ) [EOL] assert extractor . names == { [string] , [string] } [EOL] assert [string] in extractor . functions [EOL] assert [string] in extractor . functions [EOL] [EOL] def test_not_enter_classes ( self , extractor ) : [EOL] extractor . visit ( ast . parse ( [string] [string] [string] [string] [string] ) ) [EOL] assert extractor . names == { [string] } [EOL] assert [string] not in extractor . functions [EOL] [EOL] def test_property_functions ( self , extractor ) : [EOL] extractor . visit ( ast . parse ( [string] ) ) [EOL] assert str ( extractor . functions [ [string] ] ) == [string] [EOL] [EOL] [EOL] class TestFunctionsPyfference : [EOL] def test_sanity ( self ) : [EOL] mocked_node = Mock ( spec = ast . FunctionDef ) [EOL] new = { [string] : pf . FunctionSummary ( [string] , node = mocked_node ) , [string] : pf . FunctionSummary ( [string] , node = mocked_node ) , } [EOL] changed = { [string] : pf . FunctionPyfference ( [string] , old_name = [string] , implementation = set ( ) ) } [EOL] removed = { [string] : pf . FunctionSummary ( [string] , node = mocked_node ) , [string] : pf . FunctionSummary ( [string] , node = mocked_node ) , } [EOL] change = pf . FunctionsPyfference ( new = new , changed = changed , removed = removed ) [EOL] assert change . new [ [string] ] == pf . FunctionSummary ( [string] , node = mocked_node ) [EOL] assert change . new [ [string] ] == pf . FunctionSummary ( [string] , node = mocked_node ) [EOL] assert change . removed [ [string] ] == pf . FunctionSummary ( [string] , node = mocked_node ) [EOL] assert change . removed [ [string] ] == pf . FunctionSummary ( [string] , node = mocked_node ) [EOL] assert change . changed [ [string] ] . old_name == [string] [EOL] assert str ( change ) == ( [string] [string] [string] [string] [string] ) [EOL] change . set_method ( ) [EOL] assert str ( change ) == ( [string] [string] [string] [string] [string] ) [EOL] [EOL] [EOL] class TestPyffFunctions : [EOL] def test_sanity ( self ) : [EOL] old = ast . parse ( [string] [string] [string] [string] ) [EOL] new = ast . parse ( [string] [string] [string] [string] [string] [string] ) [EOL] old_imports = pi . ImportedNames . extract ( old ) [EOL] new_imports = pi . ImportedNames . extract ( new ) [EOL] change = pf . pyff_functions ( old , new , old_imports , new_imports ) [EOL] assert change is not None [EOL] assert len ( change . new ) == [number] [EOL] new_funktion = change . new [ [string] ] [EOL] assert new_funktion . name == [string] [EOL] [EOL] assert len ( change . changed ) == [number] [EOL] assert [string] in change . changed [EOL] [EOL] def test_property_functions ( self ) : [EOL] no_method = ast . parse ( [string] ) [EOL] property_method = ast . parse ( [string] ) [EOL] no_imports = pi . ImportedNames . extract ( no_method ) [EOL] [EOL] assert ( str ( pf . pyff_functions ( no_method , property_method , no_imports , no_imports ) ) == [string] ) [EOL] assert ( str ( pf . pyff_functions ( property_method , no_method , no_imports , no_imports ) ) == [string] ) [EOL] [EOL] def test_changed_arguments ( self ) : [EOL] old = ast . parse ( [string] [string] [string] ) [EOL] new = ast . parse ( [string] [string] [string] ) [EOL] old_imports = pi . ImportedNames . extract ( old ) [EOL] new_imports = pi . ImportedNames . extract ( new ) [EOL] change = pf . pyff_functions ( old , new , old_imports , new_imports ) [EOL] [comment] [EOL] assert change is None [EOL] [EOL] def test_same ( self ) : [EOL] module = ast . parse ( [string] [string] [string] [string] ) [EOL] imports = pi . ImportedNames . extract ( module ) [EOL] assert pf . pyff_functions ( module , module , imports , imports ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[pyff.functions.FunctionImplementationChange]$ 0 0 0 0 0 0 0 0 0 $typing.Set[pyff.functions.FunctionImplementationChange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[pyff.functions.FunctionImplementationChange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.ExternalUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.ExternalUsageChange$ 0 0 0 0 0 0 0 0 0 0 $pyff.functions.ExternalUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.ExternalUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.ExternalUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.ExternalUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.ExternalUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.ExternalUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.ExternalUsageChange$ 0 $pyff.functions.ExternalUsageChange$ 0 0 $pyff.functions.ExternalUsageChange$ 0 $pyff.functions.ExternalUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 0 $pyff.functions.StatementChange$ 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 $pyff.functions.StatementChange$ 0 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfferenceRecorder$ 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfferenceRecorder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfferenceRecorder$ 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfferenceRecorder$ 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 $pyff.functions.FunctionPyfferenceRecorder$ 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfferenceRecorder$ 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfferenceRecorder$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 $pyff.functions.FunctionPyfferenceRecorder$ 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionImplementationChange$ 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 $pyff.functions.FunctionPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.ExternalUsageChange]$ 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Optional[pyff.functions.ExternalUsageChange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.ExternalUsageChange]$ 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Optional[pyff.functions.ExternalUsageChange]$ 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.ExternalUsageChange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pyff.functions.FunctionsExtractor$ 0 0 0 0 0 0 0 $pyff.functions.FunctionsExtractor$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $pyff.functions.FunctionsExtractor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pyff.functions.FunctionSummary]$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 $pyff.functions.FunctionsPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pyff.functions.FunctionSummary]$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 $pyff.functions.FunctionsPyfference$ 0 0 0 0 0 $typing.Dict[builtins.str,pyff.functions.FunctionSummary]$ 0 $typing.Dict[builtins.str,pyff.functions.FunctionSummary]$ 0 $pyff.functions.FunctionsPyfference$ 0 $pyff.functions.FunctionsPyfference$ 0 $typing.Dict[builtins.str,pyff.functions.FunctionSummary]$ 0 $typing.Dict[builtins.str,pyff.functions.FunctionSummary]$ 0 0 0 $pyff.functions.FunctionsPyfference$ 0 $typing.Dict[builtins.str,pyff.functions.FunctionSummary]$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 $pyff.functions.FunctionsPyfference$ 0 $typing.Dict[builtins.str,pyff.functions.FunctionSummary]$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 $pyff.functions.FunctionsPyfference$ 0 $typing.Dict[builtins.str,pyff.functions.FunctionSummary]$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 $pyff.functions.FunctionsPyfference$ 0 $typing.Dict[builtins.str,pyff.functions.FunctionSummary]$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 $pyff.functions.FunctionsPyfference$ 0 $pyff.functions.FunctionsPyfference$ 0 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionsPyfference$ 0 0 0 0 0 0 0 0 0 0 $pyff.functions.FunctionsPyfference$ 0 0 0 0 0 0 0 0 $pyff.functions.FunctionsPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $pyff.imports.ImportedNames$ 0 $pyff.imports.ImportedNames$ 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 $_ast.Module$ 0 0 0 0 $pyff.functions.FunctionSummary$ 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 $_ast.Module$ 0 0 0 0 0 $pyff.functions.FunctionSummary$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $pyff.imports.ImportedNames$ 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $pyff.imports.ImportedNames$ 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $pyff.imports.ImportedNames$ 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $pyff.imports.ImportedNames$ 0 $pyff.imports.ImportedNames$ 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Any [EOL] import typing [EOL] import _ast [EOL] import pyff [EOL] import ast [EOL] import pytest [EOL] import pyff . imports as pi [EOL] from helpers import parse_imports [EOL] [EOL] [EOL] class TestImportedName : [EOL] def test_import ( self ) : [EOL] alias = ast . alias ( name = [string] , asname = None ) [EOL] name = pi . ImportedName ( [string] , ast . Import ( names = [ alias ] ) , alias ) [EOL] assert name . name == [string] [EOL] assert name . node . names [ [number] ] . name == [string] [EOL] assert name . node . names [ [number] ] . asname is None [EOL] assert name . alias is alias [EOL] assert name . is_import ( ) [EOL] assert not name . is_import_from ( ) [EOL] [EOL] def test_importfrom ( self ) : [EOL] alias = ast . alias ( name = [string] , asname = None ) [EOL] name = pi . ImportedName ( [string] , ast . ImportFrom ( module = [string] , level = [number] , names = [ alias ] ) , alias ) [EOL] assert name . name == [string] [EOL] assert name . node . module == [string] [EOL] assert name . node . names [ [number] ] . name == [string] [EOL] assert name . node . names [ [number] ] . asname is None [EOL] assert name . node . level == [number] [EOL] assert name . alias is alias [EOL] assert not name . is_import ( ) [EOL] assert name . is_import_from ( ) [EOL] [EOL] def test_fqdn_imports ( self ) : [EOL] simple = ast . alias ( name = [string] , asname = None ) [EOL] assert pi . ImportedName ( [string] , ast . Import ( names = [ simple ] ) , simple ) . canonical_name == [string] [EOL] [EOL] module = ast . alias ( name = [string] , asname = None ) [EOL] module_name = pi . ImportedName ( [string] , ast . Import ( names = [ module ] ) , module ) [EOL] assert module_name . canonical_name == [string] [EOL] [EOL] alias = ast . alias ( name = [string] , asname = [string] ) [EOL] assert pi . ImportedName ( [string] , ast . Import ( names = [ alias ] ) , alias ) . canonical_name == [string] [EOL] [EOL] def test_fqast_imports ( self ) : [EOL] simple = ast . alias ( name = [string] , asname = None ) [EOL] node_ast = ast . dump ( pi . ImportedName ( [string] , ast . Import ( names = [ simple ] ) , simple ) . canonical_ast ) [EOL] assert node_ast == [string] [EOL] [EOL] module = ast . alias ( name = [string] , asname = None ) [EOL] module_name = pi . ImportedName ( [string] , ast . Import ( names = [ module ] ) , module ) [EOL] module_ast = ast . dump ( module_name . canonical_ast ) [EOL] assert module_ast == [string] [EOL] [EOL] alias = ast . alias ( name = [string] , asname = [string] ) [EOL] alias_ast = ast . dump ( pi . ImportedName ( [string] , ast . Import ( names = [ alias ] ) , alias ) . canonical_ast ) [EOL] assert alias_ast == [string] [EOL] [EOL] def test_fqdn_importfrom ( self ) : [EOL] [comment] [EOL] simple = ast . alias ( name = [string] , asname = None ) [EOL] simple_name = ast . ImportFrom ( module = [string] , names = [ simple ] ) [EOL] assert pi . ImportedName ( [string] , simple_name , simple ) . canonical_name == [string] [EOL] [EOL] module = ast . alias ( name = [string] , asname = None ) [EOL] module_name = ast . ImportFrom ( module = [string] , names = [ module ] ) [EOL] assert pi . ImportedName ( [string] , module_name , module ) . canonical_name == [string] [EOL] [EOL] alias = ast . alias ( name = [string] , asname = [string] ) [EOL] alias_name = ast . ImportFrom ( module = [string] , names = [ alias ] ) [EOL] assert ( pi . ImportedName ( [string] , alias_name , alias ) . canonical_name == [string] ) [EOL] [EOL] def test_fqast_importfrom ( self ) : [EOL] simple = ast . alias ( name = [string] , asname = None ) [EOL] simple_name = pi . ImportedName ( [string] , ast . ImportFrom ( module = [string] , names = [ simple ] ) , simple ) [EOL] simple_ast = ast . dump ( simple_name . canonical_ast ) [EOL] assert simple_ast == [string] [EOL] [EOL] module = ast . alias ( name = [string] , asname = None ) [EOL] module_node = ast . ImportFrom ( module = [string] , names = [ module ] ) [EOL] module_name = pi . ImportedName ( [string] , module_node , module ) [EOL] module_ast = ast . dump ( module_name . canonical_ast ) [EOL] assert ( module_ast == [string] ) [EOL] [EOL] alias = ast . alias ( name = [string] , asname = [string] ) [EOL] alias_node = ast . ImportFrom ( module = [string] , names = [ alias ] ) [EOL] alias_name = pi . ImportedName ( [string] , alias_node , alias ) [EOL] alias_ast = ast . dump ( alias_name . canonical_ast ) [EOL] assert ( alias_ast == [string] ) [EOL] [EOL] [EOL] class TestImportedNames : [EOL] def test_dictionary ( self ) : [EOL] names = pi . ImportedNames ( ) [EOL] assert not names [EOL] [EOL] names . add_import ( ast . Import ( names = [ ast . alias ( name = [string] , asname = None ) ] ) ) [EOL] assert len ( names ) == [number] [EOL] assert [string] in names [EOL] assert names [ [string] ] . name == [string] [EOL] assert len ( names [ [string] ] . node . names ) == [number] [EOL] [EOL] assert list ( sorted ( names ) ) == [ [string] ] [EOL] [EOL] def test_import ( self ) : [EOL] names = pi . ImportedNames ( ) [EOL] names . add_import ( ast . Import ( names = [ ast . alias ( name = [string] , asname = None ) , ast . alias ( name = [string] , asname = None ) ] ) ) [EOL] names . add_import ( ast . Import ( names = [ ast . alias ( name = [string] , asname = None ) ] ) ) [EOL] assert len ( names ) == [number] [EOL] assert [string] in names [EOL] assert [string] in names [EOL] assert [string] in names [EOL] [EOL] assert names [ [string] ] . node is names [ [string] ] . node [EOL] assert names [ [string] ] . node is not names [ [string] ] . node [EOL] [EOL] def test_importfrom ( self ) : [EOL] names = pi . ImportedNames ( ) [EOL] names . add_importfrom ( ast . ImportFrom ( module = [string] , level = [number] , names = [ ast . alias ( name = [string] , asname = None ) , ast . alias ( name = [string] , asname = None ) ] , ) ) [EOL] names . add_importfrom ( ast . ImportFrom ( module = [string] , level = [number] , names = [ ast . alias ( name = [string] , asname = None ) ] ) ) [EOL] assert len ( names ) == [number] [EOL] assert [string] in names [EOL] assert [string] in names [EOL] assert [string] in names [EOL] assert names [ [string] ] . node is names [ [string] ] . node [EOL] assert names [ [string] ] . node is not names [ [string] ] . node [EOL] assert names . from_modules == { [string] , [string] } [EOL] [EOL] def test_asname ( self ) : [EOL] names = pi . ImportedNames ( ) [EOL] names . add_import ( ast . Import ( names = [ ast . alias ( name = [string] , asname = [string] ) ] ) ) [EOL] assert len ( names ) == [number] [EOL] assert [string] in names [EOL] [EOL] [EOL] class TestPyffImports : [EOL] def test_new_import ( self ) : [EOL] old = [string] [EOL] new = [string] [EOL] [EOL] assert len ( pi . pyff_imports_code ( old , new ) . new_imports ) == [number] [EOL] assert len ( pi . pyff_imports ( ast . parse ( old ) , ast . parse ( new ) ) . new_imports ) == [number] [EOL] assert pi . pyff_imports_code ( new , new ) is None [EOL] assert pi . pyff_imports ( ast . parse ( new ) , ast . parse ( new ) ) is None [EOL] [EOL] [EOL] class TestImportedNamesCompare : [EOL] def test_new_import ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new = parse_imports ( [string] ) [EOL] new_with_comma = parse_imports ( [string] ) [EOL] [EOL] change = pi . ImportedNames . compare ( old , new ) [EOL] assert len ( change . new_imports ) == [number] [EOL] assert max ( change . new_imports ) . canonical_name == [string] [EOL] [EOL] change_with_comma = pi . ImportedNames . compare ( old , new_with_comma ) [EOL] assert len ( change_with_comma . new_imports ) == [number] [EOL] assert max ( change_with_comma . new_imports ) . canonical_name == [string] [EOL] [EOL] def test_removed_import ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] old_with_comma = parse_imports ( [string] ) [EOL] new = parse_imports ( [string] ) [EOL] [EOL] change = pi . ImportedNames . compare ( old , new ) [EOL] assert len ( change . removed_imports ) == [number] [EOL] assert max ( change . removed_imports ) . canonical_name == [string] [EOL] [EOL] change = pi . ImportedNames . compare ( old_with_comma , new ) [EOL] assert len ( change . removed_imports ) == [number] [EOL] assert max ( change . removed_imports ) . canonical_name == [string] [EOL] [EOL] def test_new_importfrom ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new = parse_imports ( [string] ) [EOL] new_with_comma = parse_imports ( [string] ) [EOL] [EOL] change = pi . ImportedNames . compare ( old , new ) [EOL] assert len ( change . fromimports . new ) == [number] [EOL] assert not change . fromimports . new_modules [EOL] assert change . fromimports . new [ [string] ] . pop ( ) . canonical_name == [string] [EOL] [EOL] change_with_comma = pi . ImportedNames . compare ( old , new_with_comma ) [EOL] assert len ( change_with_comma . fromimports . new ) == [number] [EOL] assert not change . fromimports . new_modules [EOL] assert change_with_comma . fromimports . new [ [string] ] . pop ( ) . canonical_name == [string] [EOL] [EOL] def test_removed_importfrom ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] old_with_comma = parse_imports ( [string] ) [EOL] new = parse_imports ( [string] ) [EOL] [EOL] change = pi . ImportedNames . compare ( old , new ) [EOL] assert len ( change . fromimports . removed ) == [number] [EOL] assert not change . fromimports . removed_modules [EOL] assert change . fromimports . removed [ [string] ] . pop ( ) . canonical_name == [string] [EOL] [EOL] change_with_comma = pi . ImportedNames . compare ( old_with_comma , new ) [EOL] assert len ( change_with_comma . fromimports . removed ) == [number] [EOL] assert not change . fromimports . removed_modules [EOL] assert change_with_comma . fromimports . removed [ [string] ] . pop ( ) . canonical_name == [string] [EOL] [EOL] def test_new_importfrom_module ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new = parse_imports ( [string] ) [EOL] [EOL] change = pi . ImportedNames . compare ( old , new ) [EOL] assert len ( change . fromimports . new ) == [number] [EOL] assert len ( change . fromimports . new_modules ) == [number] [EOL] assert change . fromimports . new_modules == { [string] } [EOL] [EOL] def test_identical ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new = parse_imports ( [string] ) [EOL] [EOL] assert pi . ImportedNames . compare ( old , new ) is None [EOL] [EOL] [EOL] class TestFromImportPyfference : [EOL] @ staticmethod @ pytest . fixture def change ( ) : [EOL] return pi . FromImportPyfference ( ) [EOL] [EOL] def test_truthiness ( self , change ) : [EOL] assert not change [EOL] change . add_new_modules ( { [string] } ) [EOL] assert change [EOL] [EOL] def test_new ( self , change ) : [EOL] alias = ast . alias ( name = [string] , asname = None ) [EOL] change . add_new ( pi . ImportedName ( [string] , ast . ImportFrom ( module = [string] , level = [number] , names = [ alias ] ) , alias ) ) [EOL] assert change . new [ [string] ] is not None [EOL] [EOL] def test_removed ( self , change ) : [EOL] alias = ast . alias ( name = [string] , asname = None ) [EOL] change . add_removed ( pi . ImportedName ( [string] , ast . ImportFrom ( module = [string] , level = [number] , names = [ alias ] ) , alias ) ) [EOL] assert change . removed [ [string] ] is not None [EOL] [EOL] def test_new_modules ( self , change ) : [EOL] change . add_new_modules ( { [string] , [string] } ) [EOL] alias = ast . alias ( name = [string] , asname = None ) [EOL] change . add_new ( pi . ImportedName ( [string] , ast . ImportFrom ( module = [string] , level = [number] , names = [ alias ] ) , alias ) ) [EOL] assert change . new_modules == { [string] , [string] } [EOL] assert change . new [EOL] change . delete_new_module ( [string] ) [EOL] assert change . new_modules == { [string] } [EOL] assert not change . new [EOL] [EOL] def test_removed_modules ( self , change ) : [EOL] change . add_removed_modules ( { [string] , [string] } ) [EOL] assert change . removed_modules == { [string] , [string] } [EOL] change . delete_removed_module ( [string] ) [EOL] assert change . removed_modules == { [string] } [EOL] [EOL] [EOL] class TestImportsPyfference : [EOL] def test_truthiness ( self ) : [EOL] change = pi . ImportsPyfference ( ) [EOL] assert not change [EOL] change . new_fromimport_modules ( { [string] } ) [EOL] assert change [EOL] [EOL] def test_message_new_import ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new_one = parse_imports ( [string] ) [EOL] new_more = parse_imports ( [string] ) [EOL] assert str ( pi . ImportedNames . compare ( old , new_one ) ) == [string] [EOL] assert ( str ( pi . ImportedNames . compare ( old , new_more ) ) == [string] ) [EOL] [EOL] def test_message_remove_import ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new_one = parse_imports ( [string] ) [EOL] new_more = parse_imports ( [string] ) [EOL] [EOL] assert str ( pi . ImportedNames . compare ( old , new_one ) ) == [string] [EOL] assert ( str ( pi . ImportedNames . compare ( old , new_more ) ) == [string] ) [comment] [EOL] [EOL] def test_message_new_fromimport ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new_one = parse_imports ( [string] ) [EOL] new_more = parse_imports ( [string] ) [EOL] assert str ( pi . ImportedNames . compare ( old , new_one ) ) == [string] [EOL] assert ( str ( pi . ImportedNames . compare ( old , new_more ) ) == [string] ) [EOL] [EOL] def test_message_remove_fromimport ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new_one = parse_imports ( [string] ) [EOL] new_more = parse_imports ( [string] ) [EOL] assert ( str ( pi . ImportedNames . compare ( old , new_one ) ) == [string] ) [EOL] assert ( str ( pi . ImportedNames . compare ( old , new_more ) ) == [string] ) [EOL] [EOL] def test_message_new_fromimport_module ( self ) : [comment] [EOL] old = parse_imports ( [string] ) [EOL] new_one = parse_imports ( [string] ) [EOL] new_more = parse_imports ( [string] ) [EOL] assert ( str ( pi . ImportedNames . compare ( old , new_one ) ) == [string] ) [EOL] assert ( str ( pi . ImportedNames . compare ( old , new_more ) ) == [string] ) [EOL] [EOL] def test_message_removed_fromimport_module ( self ) : [comment] [EOL] old = parse_imports ( [string] ) [EOL] new = parse_imports ( [string] ) [EOL] assert ( str ( pi . ImportedNames . compare ( old , new ) ) == [string] ) [EOL] [EOL] def test_from_to_general ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new = parse_imports ( [string] ) [EOL] assert ( str ( pi . ImportedNames . compare ( old , new ) ) == [string] ) [EOL] [EOL] def test_general_to_from ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new = parse_imports ( [string] ) [EOL] assert ( str ( pi . ImportedNames . compare ( old , new ) ) == [string] ) [EOL] [EOL] [EOL] class TestImportExtractor : [EOL] def test_import_simple ( self ) : [EOL] names = parse_imports ( [string] ) [EOL] assert len ( names ) == [number] [EOL] assert [string] in names [EOL] [EOL] def test_import_multiple ( self ) : [EOL] names = parse_imports ( [string] ) [EOL] assert len ( names ) == [number] [EOL] assert [string] in names [EOL] assert [string] in names [EOL] [EOL] def test_import_alias ( self ) : [EOL] names = parse_imports ( [string] ) [EOL] assert len ( names ) == [number] [EOL] assert [string] in names [EOL] assert [string] in names [EOL] [EOL] def test_importfrom_simple ( self ) : [EOL] names = parse_imports ( [string] ) [EOL] assert len ( names ) == [number] [EOL] assert [string] in names [EOL] [EOL] def test_importfrom_multiple ( self ) : [EOL] names = parse_imports ( [string] ) [EOL] assert len ( names ) == [number] [EOL] assert [string] in names [EOL] assert [string] in names [EOL] [EOL] def test_importfrom_alias ( self ) : [EOL] names = parse_imports ( [string] ) [EOL] assert len ( names ) == [number] [EOL] assert [string] in names [EOL] assert [string] in names [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 $pyff.imports.ImportedName$ 0 $pyff.imports.ImportedName$ 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 $_ast.alias$ 0 $_ast.alias$ 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 $pyff.imports.ImportedName$ 0 $pyff.imports.ImportedName$ 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 $_ast.alias$ 0 $_ast.alias$ 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 $builtins.str$ 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $_ast.ImportFrom$ 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $_ast.ImportFrom$ 0 $_ast.alias$ 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $_ast.ImportFrom$ 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $_ast.ImportFrom$ 0 $_ast.alias$ 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $_ast.ImportFrom$ 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 $_ast.ImportFrom$ 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 $builtins.str$ 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $_ast.ImportFrom$ 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 $_ast.ImportFrom$ 0 $_ast.alias$ 0 0 $builtins.str$ 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 $_ast.ImportFrom$ 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 0 $_ast.ImportFrom$ 0 $_ast.alias$ 0 0 $builtins.str$ 0 0 0 0 0 $pyff.imports.ImportedName$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportsPyfference$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [EOL] from typing import Optional [EOL] import typing [EOL] import unittest [EOL] import pyff [EOL] import pathlib [EOL] from unittest . mock import MagicMock [EOL] import pytest [EOL] import pyff . packages as pp [EOL] import pyff . directories as pd [EOL] import pyff . modules as pm [EOL] [EOL] [EOL] class TestDirectoryPyfference : [EOL] def test_packages ( self ) : [EOL] mock_packages = MagicMock ( spec = pp . PackagesPyfference ) [EOL] mock_packages . __str__ . return_value = [string] [EOL] change = pd . DirectoryPyfference ( packages = mock_packages , modules = None ) [EOL] assert change [EOL] assert change . packages [EOL] assert str ( change ) == [string] [EOL] [EOL] def test_empty ( self ) : [EOL] change = pd . DirectoryPyfference ( packages = None , modules = None ) [EOL] assert not change [EOL] assert str ( change ) == [string] [EOL] [EOL] def test_modules ( self ) : [EOL] mock_modules = MagicMock ( spec = pm . ModulesPyfference ) [EOL] mock_modules . __str__ . return_value = [string] [EOL] change = pd . DirectoryPyfference ( modules = mock_modules , packages = None ) [EOL] assert change [EOL] assert change . modules [EOL] assert str ( change ) == [string] [EOL] [EOL] [EOL] class TestFindThosePythonz : [EOL] def test_package ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] [EOL] packages , _ = pd . find_those_pythonz ( pathlib . Path ( [string] ) ) [EOL] assert packages == { pathlib . Path ( [string] ) } [EOL] [EOL] def test_only_toplevel_package ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] [EOL] packages , _ = pd . find_those_pythonz ( pathlib . Path ( [string] ) ) [EOL] assert packages == { pathlib . Path ( [string] ) } [EOL] [EOL] def test_package_somewhere_deep ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] [EOL] packages , _ = pd . find_those_pythonz ( pathlib . Path ( [string] ) ) [EOL] assert packages == { pathlib . Path ( [string] ) } [EOL] [EOL] def test_ignore_nonpython_stuff ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] [EOL] packages , _ = pd . find_those_pythonz ( pathlib . Path ( [string] ) ) [EOL] assert packages == { pathlib . Path ( [string] ) } [EOL] [EOL] def test_module ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] _ , modules = pd . find_those_pythonz ( pathlib . Path ( [string] ) ) [EOL] assert modules == { pathlib . Path ( [string] ) } [EOL] [EOL] def test_module_deep ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] _ , modules = pd . find_those_pythonz ( pathlib . Path ( [string] ) ) [EOL] assert modules == { pathlib . Path ( [string] ) } [EOL] [EOL] def test_everything ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] [EOL] packages , modules = pd . find_those_pythonz ( pathlib . Path ( [string] ) ) [EOL] assert packages == { pathlib . Path ( [string] ) , pathlib . Path ( [string] ) , } [EOL] assert modules == { pathlib . Path ( [string] ) , pathlib . Path ( [string] ) } [EOL] [EOL] [EOL] class TestPyffDirectory : [EOL] def test_identical ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] [EOL] assert pd . pyff_directory ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) is None [EOL] [EOL] def test_invalid ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] pd . pyff_directory ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] pd . pyff_directory ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] pd . pyff_directory ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) [EOL] [EOL] def test_remove_package ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] fs . create_dir ( [string] ) [EOL] change = pd . pyff_directory ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) [EOL] assert change [EOL] assert pathlib . Path ( [string] ) in change . packages . removed [EOL] [EOL] def test_add_package ( self , fs ) : [comment] [EOL] fs . create_dir ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] change = pd . pyff_directory ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) [EOL] assert change [EOL] assert pathlib . Path ( [string] ) in change . packages . new [EOL] [EOL] def test_changed_package ( self , fs ) : [comment] [EOL] fs . create_dir ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] change = pd . pyff_directory ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) [EOL] assert change [EOL] assert pathlib . Path ( [string] ) in change . packages . changed [EOL] [EOL] def test_removed_module ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] fs . create_dir ( [string] ) [EOL] change = pd . pyff_directory ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) [EOL] assert change [EOL] assert pathlib . Path ( [string] ) in change . modules . removed [EOL] [EOL] def test_changed_module ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] pathlib . Path ( [string] ) . write_text ( [string] ) [EOL] change = pd . pyff_directory ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) [EOL] assert change [EOL] assert pathlib . Path ( [string] ) in change . modules . changed [EOL] [EOL] def test_new_module ( self , fs ) : [comment] [EOL] fs . create_dir ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] change = pd . pyff_directory ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) [EOL] assert change [EOL] assert pathlib . Path ( [string] ) in change . modules . new [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $pyff.directories.DirectoryPyfference$ 0 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 0 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $pyff.directories.DirectoryPyfference$ 0 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 0 0 $pyff.directories.DirectoryPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.directories.DirectoryPyfference]$ 0 0 0 0 0
[comment] [EOL] from typing import Optional [EOL] import typing [EOL] import unittest [EOL] import pathlib [EOL] import pyff [EOL] import pathlib [EOL] from unittest . mock import MagicMock [EOL] import pytest [EOL] import pyff . modules as pm [EOL] import pyff . packages as pp [EOL] [EOL] [EOL] class TestPackagesPyfference : [EOL] def test_empty ( self ) : [EOL] assert not pp . PackagesPyfference ( None , None , None ) [EOL] [EOL] def test_removed ( self ) : [EOL] path = pathlib . Path ( [string] ) [EOL] summary = pp . PackageSummary ( path ) [EOL] change = pp . PackagesPyfference ( removed = { path : summary } , changed = None , new = None ) [EOL] assert change [EOL] assert path in change . removed [EOL] assert str ( change ) == [string] [EOL] [EOL] def test_new ( self ) : [EOL] path = pathlib . Path ( [string] ) [EOL] summary = pp . PackageSummary ( path ) [EOL] change = pp . PackagesPyfference ( new = { path : summary } , changed = None , removed = None ) [EOL] assert change [EOL] assert path in change . new [EOL] assert str ( change ) == [string] [EOL] [EOL] def test_changed ( self ) : [EOL] path = pathlib . Path ( [string] ) [EOL] inner_change = MagicMock ( spec = pp . PackagePyfference ) [EOL] inner_change . __str__ . return_value = [string] [EOL] change = pp . PackagesPyfference ( changed = { path : inner_change } , removed = None , new = None ) [EOL] assert change [EOL] assert path in change . changed [EOL] assert str ( change ) == [string] [EOL] [EOL] [EOL] class TestPackagePyfference : [EOL] def test_sanity ( self ) : [EOL] mock_modules = MagicMock ( spec = pm . ModulesPyfference ) [EOL] mock_modules . __str__ . return_value = [string] [EOL] change = pp . PackagePyfference ( modules = mock_modules ) [EOL] assert change . modules is not None [EOL] assert str ( change ) == [string] [EOL] [EOL] [EOL] class TestExtractions : [EOL] def test_extract_module ( self ) : [EOL] assert pp . extract_modules ( [ pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ] , pp . summarize_package ( pathlib . Path ( [string] ) ) , ) == { [string] } [EOL] assert ( pp . extract_modules ( [ pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ] , pp . summarize_package ( pathlib . Path ( [string] ) ) , ) == frozenset ( ) ) [EOL] [EOL] [EOL] class TestPyffPackage : [EOL] @ pytest . fixture def sample_package_path ( self , fs ) : [comment] [EOL] fs . create_dir ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] [EOL] return pathlib . Path ( [string] ) [EOL] [EOL] @ pytest . fixture def sample_with_new_module_path ( self , fs ) : [comment] [EOL] fs . create_dir ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] [EOL] return pathlib . Path ( [string] ) [EOL] [EOL] @ pytest . fixture def sample_package ( self , sample_package_path ) : [comment] [EOL] return pp . summarize_package ( sample_package_path ) [EOL] [EOL] @ pytest . fixture def sample_with_new_module ( self , sample_with_new_module_path ) : [comment] [EOL] return pp . summarize_package ( sample_with_new_module_path ) [EOL] [EOL] def test_identical ( self , sample_package ) : [EOL] assert pp . pyff_package ( sample_package , sample_package ) is None [EOL] [EOL] def test_new_module ( self , sample_package , sample_with_new_module ) : [EOL] change = pp . pyff_package ( sample_package , sample_with_new_module ) [EOL] assert change is not None [EOL] assert change . modules is not None [EOL] assert pathlib . Path ( [string] ) in change . modules . new [EOL] [EOL] def test_pyff_package_path ( self , sample_package_path , sample_with_new_module_path ) : [EOL] change = pp . pyff_package_path ( sample_package_path , sample_with_new_module_path ) [EOL] assert change is not None [EOL] assert change . modules is not None [EOL] assert pathlib . Path ( [string] ) in change . modules . new [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pyff.packages.PackageSummary$ 0 0 0 0 0 $pathlib.Path$ 0 0 $pyff.packages.PackagesPyfference$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pyff.packages.PackageSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.packages.PackagesPyfference$ 0 0 $pathlib.Path$ 0 $pyff.packages.PackagesPyfference$ 0 0 0 0 0 0 $pyff.packages.PackagesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pyff.packages.PackageSummary$ 0 0 0 0 0 $pathlib.Path$ 0 0 $pyff.packages.PackagesPyfference$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pyff.packages.PackageSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.packages.PackagesPyfference$ 0 0 $pathlib.Path$ 0 $pyff.packages.PackagesPyfference$ 0 0 0 0 0 0 $pyff.packages.PackagesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $pyff.packages.PackagesPyfference$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.packages.PackagesPyfference$ 0 0 $pathlib.Path$ 0 $pyff.packages.PackagesPyfference$ 0 0 0 0 0 0 $pyff.packages.PackagesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $pyff.packages.PackagePyfference$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 $pyff.packages.PackagePyfference$ 0 0 0 0 0 0 0 0 0 $pyff.packages.PackagePyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.packages.PackagePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.packages.PackagePyfference]$ 0 0 0 0 0 $typing.Optional[pyff.packages.PackagePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.packages.PackagePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.packages.PackagePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.packages.PackagePyfference]$ 0 0 0 0 0 $typing.Optional[pyff.packages.PackagePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.packages.PackagePyfference]$ 0 0 0 0 0
[comment] [EOL] [EOL] from pytest import raises [EOL] from colorama import Fore , Style [EOL] from pyff . kitchensink import HL_OPEN , HL_CLOSE , highlight [EOL] [EOL] [EOL] def test_highlights ( ) : [EOL] output = f" [string] { HL_OPEN } [string] { HL_CLOSE } [string] { HL_OPEN } [string] { HL_CLOSE }" [EOL] colorized = f" [string] { Fore . RED } [string] { Style . RESET_ALL } [string] { Fore . RED } [string] { Style . RESET_ALL }" [EOL] quoted = [string] [EOL] assert highlight ( output , [string] ) == colorized [EOL] assert highlight ( output , [string] ) == quoted [EOL] [EOL] with raises ( ValueError ) : [EOL] highlight ( output , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Any [EOL] import typing [EOL] import unittest [EOL] import pyff [EOL] import os [EOL] import pathlib [EOL] from unittest . mock import MagicMock , patch [EOL] [EOL] import pyff . directories as pd [EOL] import pyff . repositories as pr [EOL] [EOL] [EOL] class TestRevisionsPyfference : [EOL] def test_sanity ( self ) : [EOL] directory_change = MagicMock ( spec = pd . DirectoryPyfference ) [EOL] directory_change . __str__ . return_value = [string] [EOL] change = pr . RevisionsPyfference ( change = directory_change ) [EOL] [EOL] assert str ( change ) == [string] [EOL] [EOL] [EOL] class TestPyffGitRevision : [EOL] @ staticmethod def _make_fake_clone ( fs , revisions ) : [comment] [EOL] def _fake_clone_method ( _ , directory ) : [EOL] fs . create_dir ( directory ) [EOL] fake_repo = MagicMock ( ) [EOL] [EOL] def _fake_checkout ( revision ) : [EOL] if revision in revisions : [EOL] oldcwd = os . getcwd ( ) [EOL] os . chdir ( directory ) [EOL] revisions [ revision ] ( ) [EOL] os . chdir ( oldcwd ) [EOL] [EOL] fake_repo . git . checkout = _fake_checkout [EOL] return fake_repo [EOL] [EOL] return _fake_clone_method [EOL] [EOL] def test_difference ( self , fs ) : [comment] [EOL] def checkout_old ( ) : [EOL] fs . create_file ( [string] ) [EOL] [EOL] def checkout_new ( ) : [EOL] fs . create_file ( [string] ) [EOL] [EOL] with patch ( [string] ) as fake_clone : [EOL] [EOL] fake_clone . side_effect = self . _make_fake_clone ( fs , { [string] : checkout_old , [string] : checkout_new } ) [EOL] change = pr . pyff_git_revision ( [string] , [string] , [string] ) [EOL] assert change is not None [EOL] assert pathlib . Path ( [string] ) in change . packages . new [EOL] [EOL] def test_identical ( self , fs ) : [comment] [EOL] def checkout_old ( ) : [EOL] fs . create_file ( [string] ) [EOL] [EOL] with patch ( [string] ) as fake_clone : [EOL] fake_clone . side_effect = self . _make_fake_clone ( fs , { [string] : checkout_old } ) [EOL] change = pr . pyff_git_revision ( [string] , [string] , [string] ) [EOL] assert change is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $pyff.repositories.RevisionsPyfference$ 0 0 0 0 0 $pyff.repositories.RevisionsPyfference$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $pyff.repositories.RevisionsPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.repositories.RevisionsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.repositories.RevisionsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.repositories.RevisionsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.repositories.RevisionsPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.repositories.RevisionsPyfference]$ 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Tuple , Any [EOL] import typing [EOL] import _ast [EOL] import builtins [EOL] import pyff [EOL] import ast [EOL] from typing import Tuple [EOL] from pytest import raises , fixture [EOL] import pyff . classes as pc [EOL] import pyff . imports as pi [EOL] import pyff . functions as pf [EOL] from helpers import parse_imports [EOL] [EOL] [EOL] class TestPyffClass : [EOL] @ staticmethod def _make_summary ( classname , code ) : [EOL] import_walker = pi . ImportExtractor ( ) [EOL] code_ast = ast . parse ( code ) [EOL] import_walker . visit ( code_ast ) [EOL] walker = pc . ClassesExtractor ( import_walker . names ) [EOL] walker . visit ( code_ast ) [EOL] return ( walker . classes [ classname ] , import_walker . names ) [EOL] [EOL] def test_new_method ( self ) : [EOL] old , old_imports = self . _make_summary ( [string] , [string] ) [EOL] new , new_imports = self . _make_summary ( [string] , [string] ) [EOL] [EOL] change = pc . pyff_class ( old , new , old_imports , new_imports ) [EOL] assert change is not None [EOL] assert change . methods [EOL] assert [string] in change . methods . new [EOL] [EOL] [EOL] class TestClassPyfference : [EOL] def test_methods ( self ) : [EOL] old = ast . parse ( [string] ) [EOL] new = ast . parse ( [string] ) [EOL] methods = pf . pyff_functions ( old , new , pi . ImportedNames . extract ( old ) , pi . ImportedNames . extract ( new ) ) [EOL] change = pc . ClassPyfference ( name = [string] , methods = methods , attributes = None ) [EOL] assert change . methods is not None [EOL] assert change . attributes is None [EOL] assert [string] in change . methods . new [EOL] assert str ( change ) == [string] [EOL] [EOL] def test_attributes ( self ) : [EOL] change = pc . ClassPyfference ( name = [string] , methods = None , attributes = pc . AttributesPyfference ( removed = None , new = { [string] } ) , ) [EOL] assert change . methods is None [EOL] assert change . attributes is not None [EOL] assert change . attributes . new == { [string] } [EOL] assert str ( change ) == [string] [EOL] [EOL] [EOL] class TestClassSummary : [EOL] @ fixture def classdef ( self ) : [EOL] return ast . ClassDef ( name = [string] , bases = [ ] , keywords = [ ] , body = [ ] , decorator_list = [ ] ) [EOL] [EOL] def test_class_summary ( self , classdef ) : [EOL] cls = pc . ClassSummary ( methods = { [string] , [string] , [string] , [string] , [string] } , definition = classdef , attributes = set ( ) ) [EOL] assert cls . name == [string] [EOL] assert cls . methods == { [string] , [string] , [string] , [string] , [string] } [EOL] assert cls . private_methods == { [string] , [string] } [EOL] assert cls . public_methods == { [string] , [string] , [string] } [EOL] assert str ( cls ) == [string] [EOL] [EOL] another_def = self . classdef ( ) [EOL] another_def . name = [string] [EOL] another = pc . ClassSummary ( methods = set ( ) , attributes = { } , definition = another_def ) [EOL] assert cls < another [EOL] another_def . name = [string] [EOL] assert cls > another [EOL] [EOL] def test_attributes ( self , classdef ) : [EOL] cls = pc . ClassSummary ( methods = { [string] } , definition = classdef , attributes = { [string] , [string] } ) [EOL] assert cls . attributes == { [string] , [string] } [EOL] [EOL] def test_singular ( self , classdef ) : [EOL] cls = pc . ClassSummary ( methods = { [string] , [string] } , definition = classdef , attributes = set ( ) ) [EOL] assert str ( cls ) == [string] [EOL] [EOL] def test_baseclasses ( self ) : [EOL] base = pc . LocalBaseClass ( [string] ) [EOL] imported = pc . ImportedBaseClass ( [string] ) [EOL] assert str ( base ) == [string] [EOL] assert str ( imported ) == [string] [EOL] [EOL] def test_inherited_class_summary ( self , classdef ) : [EOL] local = pc . ClassSummary ( methods = set ( ) , baseclasses = [ pc . LocalBaseClass ( [string] ) ] , definition = classdef , attributes = set ( ) , ) [EOL] imported = pc . ClassSummary ( methods = set ( ) , baseclasses = [ pc . ImportedBaseClass ( [string] ) ] , definition = classdef , attributes = set ( ) , ) [EOL] assert ( str ( local ) == [string] ) [comment] [EOL] assert ( str ( imported ) == [string] ) [comment] [EOL] [EOL] def test_multiple_inherited_summary ( self , classdef ) : [EOL] local = pc . ClassSummary ( methods = set ( ) , baseclasses = [ pc . LocalBaseClass ( [string] ) , pc . LocalBaseClass ( [string] ) ] , definition = classdef , attributes = set ( ) , ) [EOL] with raises ( Exception ) : [EOL] str ( local ) [EOL] [EOL] [EOL] class TestAttributesPyfference : [EOL] def test_sanity ( self ) : [EOL] change = pc . AttributesPyfference ( removed = { [string] } , new = { [string] , [string] } ) [EOL] assert change [EOL] assert change . new == { [string] , [string] } [EOL] assert change . removed == { [string] } [EOL] assert str ( change ) == [string] [EOL] [EOL] def test_empty ( self ) : [EOL] change = pc . AttributesPyfference ( removed = set ( ) , new = set ( ) ) [EOL] assert not change [EOL] [EOL] [EOL] class TestClassesExtractor : [EOL] @ fixture def extractor ( self ) : [EOL] return pc . ClassesExtractor ( ) [EOL] [EOL] def test_extract_single_class ( self , extractor ) : [EOL] cls = ast . parse ( [string] [string] ) [EOL] extractor . visit ( cls ) [EOL] assert extractor . classnames == { [string] } [EOL] assert len ( extractor . classes ) == [number] [EOL] assert [string] in extractor . classes [EOL] summary = extractor . classes [ [string] ] [EOL] assert str ( summary ) == [string] [EOL] [EOL] def test_extract_multiple_classes ( self , extractor ) : [EOL] cls = ast . parse ( [string] [string] [string] [string] ) [EOL] extractor . visit ( cls ) [EOL] assert extractor . classnames == { [string] , [string] } [EOL] assert len ( extractor . classes ) == [number] [EOL] [EOL] def test_extract_class_with_methods ( self , extractor ) : [EOL] cls = ast . parse ( [string] [string] [string] [string] [string] [string] [string] ) [EOL] extractor . visit ( cls ) [EOL] assert len ( extractor . classes ) == [number] [EOL] summary = extractor . classes [ [string] ] [EOL] assert summary . methods == { [string] , [string] , [string] } [EOL] assert summary . private_methods == { [string] , [string] } [EOL] assert summary . public_methods == { [string] } [EOL] assert str ( summary ) == [string] [EOL] [EOL] def test_extract_local_baseclass ( self ) : [EOL] code = ( [string] [string] [string] [string] [string] ) [EOL] names = parse_imports ( code ) [EOL] extractor = pc . ClassesExtractor ( names ) [EOL] extractor . visit ( ast . parse ( code ) ) [EOL] assert len ( extractor . classes ) == [number] [EOL] summary = extractor . classes [ [string] ] [EOL] assert ( str ( summary ) == [string] ) [EOL] [EOL] def test_extract_external_baseclass ( self ) : [EOL] code = [string] [string] [string] [EOL] names = parse_imports ( code ) [EOL] extractor = pc . ClassesExtractor ( names ) [EOL] extractor . visit ( ast . parse ( code ) ) [EOL] assert len ( extractor . classes ) == [number] [EOL] summary = extractor . classes [ [string] ] [EOL] assert ( str ( summary ) == [string] ) [EOL] [EOL] def test_extract_attribute ( self , extractor ) : [EOL] klass = ast . parse ( [string] ) [EOL] extractor . visit ( klass ) [EOL] summary = extractor . classes [ [string] ] [EOL] assert summary . attributes == { [string] } [EOL] [EOL] def test_extract_annotated_attribute ( self , extractor ) : [comment] [EOL] klass = ast . parse ( [string] ) [EOL] extractor . visit ( klass ) [EOL] summary = extractor . classes [ [string] ] [EOL] assert summary . attributes == { [string] } [EOL] [EOL] [EOL] class TestClassesPyfference : [EOL] def test_new_classes ( self ) : [EOL] cpyff = pc . ClassesPyfference ( new = { [string] , [string] } , changed = set ( ) ) [EOL] assert cpyff . new == { [string] , [string] } [EOL] assert str ( cpyff ) == ( [string] [string] ) [EOL] [EOL] def test_simplify ( self ) : [EOL] change = pc . ClassesPyfference ( new = set ( ) , changed = set ( ) ) [EOL] assert change . simplify ( ) is None [EOL] [EOL] [EOL] class TestPyffClasses : [EOL] def test_new_classes ( self ) : [EOL] old = ast . parse ( [string] [string] ) [EOL] new = ast . parse ( [string] [string] [string] [string] ) [EOL] old_imports = pi . ImportedNames . extract ( old ) [EOL] new_imports = pi . ImportedNames . extract ( new ) [EOL] change = pc . pyff_classes ( old , new , old_imports , new_imports ) [EOL] assert change is not None [EOL] assert len ( change . new ) == [number] [EOL] newcls , = change . new [EOL] assert newcls . name == [string] [EOL] [EOL] def test_same ( self ) : [EOL] cls = [string] [string] [EOL] imports = pi . ImportedNames . extract ( ast . parse ( cls ) ) [EOL] change = pc . pyff_classes ( ast . parse ( cls ) , ast . parse ( cls ) , imports , imports ) [EOL] assert change is None [EOL] [EOL] def test_changed_class ( self ) : [EOL] old = ast . parse ( [string] ) [EOL] new = ast . parse ( [string] ) [EOL] old_imports = pi . ImportedNames . extract ( old ) [EOL] new_imports = pi . ImportedNames . extract ( new ) [EOL] change = pc . pyff_classes ( old , new , old_imports , new_imports ) [EOL] assert change is not None [EOL] assert [string] in change . changed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[pyff.classes.ClassSummary,pyff.imports.ImportedNames]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pyff.imports.ImportExtractor$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 $builtins.str$ 0 0 $pyff.imports.ImportExtractor$ 0 0 0 $_ast.Module$ 0 0 $pyff.classes.ClassesExtractor$ 0 0 0 0 0 $pyff.imports.ImportExtractor$ 0 0 0 0 $pyff.classes.ClassesExtractor$ 0 0 0 $_ast.Module$ 0 0 0 0 $pyff.classes.ClassesExtractor$ 0 0 0 $builtins.str$ 0 0 $pyff.imports.ImportExtractor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.classes.ClassPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.classes.ClassPyfference]$ 0 0 0 0 0 $typing.Optional[pyff.classes.ClassPyfference]$ 0 0 0 0 0 0 $typing.Optional[pyff.classes.ClassPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 $pyff.classes.ClassPyfference$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 0 0 $pyff.classes.ClassPyfference$ 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 0 0 0 0 $pyff.classes.ClassPyfference$ 0 0 0 0 0 0 0 0 $pyff.classes.ClassPyfference$ 0 $typing.Optional[pyff.functions.FunctionsPyfference]$ 0 $_ast.Module$ 0 0 0 0 $pyff.classes.ClassPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassPyfference$ 0 0 0 0 0 0 $pyff.classes.ClassPyfference$ 0 0 0 0 0 0 0 $pyff.classes.ClassPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pyff.classes.ClassSummary$ 0 $pyff.classes.ClassSummary$ 0 $typing.Any$ 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.LocalBaseClass$ 0 0 0 0 0 0 0 0 $pyff.classes.ImportedBaseClass$ 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.LocalBaseClass$ 0 0 0 0 0 0 0 $pyff.classes.ImportedBaseClass$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.AttributesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.AttributesPyfference$ 0 0 $pyff.classes.AttributesPyfference$ 0 0 0 0 0 0 0 0 0 0 $pyff.classes.AttributesPyfference$ 0 0 0 0 0 0 0 0 0 0 $pyff.classes.AttributesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.AttributesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.AttributesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $pyff.classes.ClassesExtractor$ 0 0 0 0 0 $typing.Any$ 0 0 $pyff.classes.ClassesExtractor$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $pyff.classes.ClassesExtractor$ 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 $pyff.classes.ClassesExtractor$ 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $pyff.classes.ClassesExtractor$ 0 0 0 0 0 $typing.Any$ 0 0 $pyff.classes.ClassesExtractor$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $pyff.classes.ClassesExtractor$ 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 $pyff.classes.ClassesExtractor$ 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $pyff.imports.ImportedNames$ 0 $pyff.imports.ImportedNames$ 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 $_ast.Module$ 0 0 0 0 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $pyff.imports.ImportedNames$ 0 $pyff.imports.ImportedNames$ 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 $pyff.imports.ImportedNames$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $pyff.imports.ImportedNames$ 0 $pyff.imports.ImportedNames$ 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.classes.ClassesPyfference]$ 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Any [EOL] import typing [EOL] import _ast [EOL] import unittest [EOL] import pyff [EOL] import ast [EOL] import pathlib [EOL] [EOL] from unittest . mock import Mock , MagicMock [EOL] [EOL] import pyff . modules as pm [EOL] import pyff . imports as pi [EOL] import pyff . functions as pf [EOL] import pyff . classes as pc [EOL] [EOL] from helpers import parse_imports [EOL] [EOL] [EOL] class TestModuleSummary : [EOL] def test_sanity ( self ) : [EOL] summary = pm . ModuleSummary ( [string] , Mock ( spec = ast . Module ) ) [EOL] assert summary . name == [string] [EOL] assert summary . node is not None [EOL] [EOL] [EOL] class TestModulesPyfference : [EOL] def test_sanity ( self ) : [EOL] mocked_imports = MagicMock ( spec = pi . ImportsPyfference ) [EOL] mocked_imports . __str__ . return_value = [string] [EOL] change = pm . ModulesPyfference ( removed = { [string] : pm . ModuleSummary ( [string] , Mock ( spec = ast . Module ) ) } , changed = { [string] : pm . ModulePyfference ( imports = mocked_imports ) } , new = { [string] : pm . ModuleSummary ( [string] , Mock ( spec = ast . Module ) ) , [string] : pm . ModuleSummary ( [string] , Mock ( spec = ast . Module ) ) , } , ) [EOL] assert change . removed is not None [EOL] assert change . changed is not None [EOL] assert change . new is not None [EOL] assert len ( change . new ) == [number] [EOL] assert str ( change ) == ( [string] [string] [string] [string] ) [EOL] assert change [EOL] [EOL] def test_emptiness ( self ) : [EOL] change = pm . ModulesPyfference ( { } , { } , { } ) [EOL] assert not change [EOL] [EOL] [EOL] class TestModulePyfference : [EOL] def test_sanity ( self ) : [EOL] old = parse_imports ( [string] ) [EOL] new = parse_imports ( [string] [string] [string] [string] ) [EOL] imports = pi . ImportedNames . compare ( old , new ) [EOL] functions = pf . FunctionsPyfference ( new = { [string] : pf . FunctionSummary ( [string] , node = Mock ( spec = ast . FunctionDef ) ) , [string] : pf . FunctionSummary ( [string] , node = Mock ( spec = ast . FunctionDef ) ) , } , changed = { [string] : pf . FunctionPyfference ( [string] , old_name = [string] , implementation = set ( ) ) } , removed = { } , ) [EOL] classes = pc . ClassesPyfference ( new = { [string] , [string] } , changed = set ( ) ) [EOL] change = pm . ModulePyfference ( imports , classes , functions ) [EOL] assert change . classes is not None [EOL] assert change . functions is not None [EOL] assert change . imports is not None [EOL] assert str ( change ) == ( [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] assert change . simplify ( ) is change [EOL] [EOL] def test_empty ( self ) : [EOL] change = pm . ModulePyfference ( ) [EOL] assert change . simplify ( ) is None [EOL] [EOL] [EOL] class TestPyffModule : [EOL] def test_sanity ( self ) : [EOL] old = ast . parse ( [string] ) [EOL] new = ast . parse ( [string] [string] [string] [string] [string] ) [EOL] change = pm . pyff_module ( pm . ModuleSummary ( [string] , old ) , pm . ModuleSummary ( [string] , new ) ) [EOL] assert change . imports is not None [EOL] assert change . classes is not None [EOL] assert change . functions is not None [EOL] [EOL] def test_pyff_module_path ( self , fs ) : [comment] [EOL] fs . create_file ( [string] ) [EOL] fs . create_file ( [string] ) [EOL] pathlib . Path ( [string] ) . write_text ( [string] [string] [string] [string] [string] ) [EOL] change = pm . pyff_module_path ( pathlib . Path ( [string] ) , pathlib . Path ( [string] ) ) [EOL] assert change . imports is not None [EOL] assert change . classes is not None [EOL] assert change . functions is not None [EOL] [EOL] def test_same ( self ) : [EOL] module = pm . ModuleSummary ( [string] , ast . parse ( [string] [string] [string] [string] [string] ) , ) [EOL] assert pm . pyff_module ( module , module ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.modules.ModuleSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.modules.ModuleSummary$ 0 0 0 0 0 0 $pyff.modules.ModuleSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $pyff.modules.ModulesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.modules.ModulesPyfference$ 0 0 0 0 0 0 0 $pyff.modules.ModulesPyfference$ 0 0 0 0 0 0 0 $pyff.modules.ModulesPyfference$ 0 0 0 0 0 0 0 0 0 $pyff.modules.ModulesPyfference$ 0 0 0 0 0 0 0 0 0 $pyff.modules.ModulesPyfference$ 0 0 0 0 0 0 0 0 0 0 $pyff.modules.ModulesPyfference$ 0 0 0 0 0 0 0 0 0 $pyff.modules.ModulesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.modules.ModulesPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $pyff.functions.FunctionsPyfference$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.classes.ClassesPyfference$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.modules.ModulePyfference$ 0 0 0 0 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 $pyff.classes.ClassesPyfference$ 0 $pyff.functions.FunctionsPyfference$ 0 0 0 $pyff.modules.ModulePyfference$ 0 $pyff.classes.ClassesPyfference$ 0 0 0 0 0 $pyff.modules.ModulePyfference$ 0 $pyff.functions.FunctionsPyfference$ 0 0 0 0 0 $pyff.modules.ModulePyfference$ 0 $typing.Optional[pyff.imports.ImportsPyfference]$ 0 0 0 0 0 0 0 $pyff.modules.ModulePyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.modules.ModulePyfference$ 0 0 0 0 0 $pyff.modules.ModulePyfference$ 0 0 0 0 0 0 0 0 0 $pyff.modules.ModulePyfference$ 0 0 0 0 0 0 0 0 $pyff.modules.ModulePyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.modules.ModulePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 $typing.Optional[pyff.modules.ModulePyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.modules.ModulePyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.modules.ModulePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.modules.ModulePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.modules.ModulePyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.modules.ModulePyfference]$ 0 0 0 0 0 0 0 $typing.Optional[pyff.modules.ModulePyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.modules.ModuleSummary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.modules.ModuleSummary$ 0 $pyff.modules.ModuleSummary$ 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Callable , Any [EOL] import typing [EOL] import _ast [EOL] import pyff [EOL] import ast [EOL] [EOL] import pyff . statements as ps [EOL] import pyff . imports as pi [EOL] [EOL] from helpers import parse_imports [EOL] [EOL] [EOL] class TestFullyQualifyNames : [EOL] @ staticmethod def _check_fqn ( imports , code , expected_subs , expected_qualified_code ) : [EOL] imports = parse_imports ( imports ) [EOL] qualifier = ps . FullyQualifyNames ( imports ) [EOL] original_ast = ast . parse ( code ) [EOL] qualified_ast = qualifier . visit ( original_ast ) [EOL] assert qualifier . substitutions == expected_subs [EOL] assert ast . dump ( ast . parse ( expected_qualified_code ) ) == ast . dump ( qualified_ast ) [EOL] [EOL] @ staticmethod def _check_references ( imports , code , references ) : [EOL] imports = parse_imports ( imports ) [EOL] qualifier = ps . FullyQualifyNames ( imports ) [EOL] qualifier . visit ( ast . parse ( code ) ) [EOL] assert qualifier . references == references [EOL] [EOL] def test_import ( self ) : [EOL] self . _check_fqn ( [string] , [string] , { [string] : [string] } , [string] , ) [EOL] self . _check_fqn ( [string] , [string] , { [string] : [string] } , [string] ) [EOL] self . _check_fqn ( [string] , [string] , { } , [string] ) [EOL] [EOL] def test_importfrom ( self ) : [EOL] self . _check_fqn ( [string] , [string] , { [string] : [string] } , [string] , ) [EOL] self . _check_fqn ( [string] , [string] , { [string] : [string] } , [string] , ) [EOL] self . _check_fqn ( [string] , [string] , { [string] : [string] } , [string] , ) [EOL] self . _check_fqn ( [string] , [string] , { } , [string] ) [EOL] [EOL] def test_nosub ( self ) : [EOL] self . _check_fqn ( [string] , [string] , { } , [string] ) [EOL] [EOL] def test_references ( self ) : [EOL] self . _check_references ( [string] , [string] , { [string] : [string] , [string] : [string] , [string] : [string] } , ) [EOL] [EOL] def test_references_from ( self ) : [EOL] self . _check_references ( [string] , [string] , { [string] : [string] , [string] : [string] } , ) [EOL] [EOL] def test_references_alias ( self ) : [EOL] self . _check_references ( [string] , [string] , { [string] : [string] , [string] : [string] } , ) [EOL] [EOL] [EOL] class TestSingleExternalNameUsageChange : [EOL] def test_sanity ( self ) : [EOL] change = ps . SingleExternalNameUsageChange ( old = [string] , new = [string] ) [EOL] assert change . old == [string] [EOL] assert change . new == [string] [EOL] assert str ( change ) == [string] [EOL] [EOL] def test_equality ( self ) : [EOL] change = ps . SingleExternalNameUsageChange ( old = [string] , new = [string] ) [EOL] equal = ps . SingleExternalNameUsageChange ( old = [string] , new = [string] ) [EOL] different = ps . SingleExternalNameUsageChange ( old = [string] , new = [string] ) [EOL] [EOL] assert change == equal [EOL] assert { change } == { equal } [EOL] assert change != different [EOL] [EOL] [EOL] class TestExternalNameUsageChange : [EOL] def test_sanity ( self ) : [EOL] change_1 = ps . SingleExternalNameUsageChange ( [string] , [string] ) [EOL] change_2 = ps . SingleExternalNameUsageChange ( [string] , [string] ) [EOL] fip = ps . ExternalNameUsageChange ( { change_1 , change_2 } ) [EOL] assert len ( fip . changes ) == [number] [EOL] assert ps . SingleExternalNameUsageChange ( [string] , [string] ) in fip . changes [EOL] assert ps . SingleExternalNameUsageChange ( [string] , [string] ) in fip . changes [EOL] assert str ( fip ) == [string] . join ( sorted ( [ str ( change_1 ) , str ( change_2 ) ] ) ) [EOL] [EOL] [EOL] class TestFindExternalNameMatches : [EOL] @ staticmethod def _check_matches ( changeset , length , old , new ) : [EOL] assert changeset is not None [EOL] assert len ( changeset . changes ) == length [EOL] change = changeset . changes . pop ( ) [EOL] assert change . old == old [EOL] assert change . new == new [EOL] [EOL] def test_import ( self ) : [EOL] package_imports = parse_imports ( [string] ) [EOL] alias_imports = parse_imports ( [string] ) [EOL] [EOL] parse_pkg = lambda : ast . parse ( [string] ) [EOL] parse_alias = lambda : ast . parse ( [string] ) [EOL] [EOL] assert ( ps . find_external_name_matches ( parse_pkg ( ) , parse_pkg ( ) , package_imports , package_imports ) is None ) [EOL] [EOL] changes = ps . find_external_name_matches ( parse_pkg ( ) , parse_alias ( ) , package_imports , alias_imports ) [EOL] assert changes is not None [EOL] assert len ( changes . changes ) == [number] [EOL] change = changes . changes . pop ( ) [EOL] assert change . old == [string] [EOL] assert change . new == [string] [EOL] [EOL] def test_importfrom ( self ) : [EOL] [comment] [EOL] from_import = parse_imports ( [string] ) [EOL] alias_import = parse_imports ( [string] ) [EOL] [EOL] [comment] [EOL] parse_from = lambda : ast . parse ( [string] ) [EOL] parse_alias = lambda : ast . parse ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from_to_alias = ps . find_external_name_matches ( parse_from ( ) , parse_alias ( ) , from_import , alias_import ) [EOL] self . _check_matches ( from_to_alias , [number] , [string] , [string] ) [EOL] [EOL] def test_example_04 ( self ) : [EOL] old_import = parse_imports ( [string] ) [EOL] new_import = parse_imports ( [string] ) [EOL] [EOL] old = ast . parse ( [string] ) [EOL] new = ast . parse ( [string] ) [EOL] [EOL] change = ps . find_external_name_matches ( old , new , old_import , new_import ) [EOL] assert change is not None [EOL] [EOL] [EOL] class TestStatementPyfference : [EOL] def test_sem_relevant ( self ) : [EOL] pyfference = ps . StatementPyfference ( ) [EOL] assert pyfference . semantically_different ( ) [EOL] pyfference . add_semantically_relevant_change ( [string] ) [EOL] assert pyfference . semantically_different ( ) [EOL] assert pyfference . semantically_relevant == { [string] } [EOL] assert str ( pyfference ) == [string] [EOL] [EOL] def test_sem_irrelevant ( self ) : [EOL] pyfference = ps . StatementPyfference ( ) [EOL] assert pyfference . semantically_different ( ) [EOL] pyfference . add_semantically_irrelevant_change ( [string] ) [EOL] assert not pyfference . semantically_different ( ) [EOL] assert pyfference . semantically_irrelevant == { [string] } [EOL] assert str ( pyfference ) == [string] [EOL] [EOL] [EOL] class TestPyffStatement : [EOL] def test_identical ( self ) : [EOL] assert ( ps . pyff_statement ( ast . parse ( [string] ) , ast . parse ( [string] ) , pi . ImportedNames ( ) , pi . ImportedNames ( ) , ) is None ) [EOL] [EOL] def test_different ( self ) : [EOL] change = ps . pyff_statement ( ast . parse ( [string] ) , ast . parse ( [string] ) , pi . ImportedNames ( ) , pi . ImportedNames ( ) ) [EOL] assert change . semantically_different ( ) [EOL] [EOL] def test_external_names ( self ) : [EOL] change = ps . pyff_statement ( ast . parse ( [string] ) , ast . parse ( [string] ) , pi . ImportedNames ( ) , pi . ImportedNames ( ) , ) [EOL] [comment] [EOL] assert change . semantically_different ( ) [EOL] [EOL] another_change = ps . pyff_statement ( ast . parse ( [string] ) , ast . parse ( [string] ) , parse_imports ( [string] ) , parse_imports ( [string] ) , ) [EOL] [comment] [EOL] assert not another_change . semantically_different ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $pyff.statements.FullyQualifyNames$ 0 0 0 0 0 $typing.Any$ 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pyff.statements.FullyQualifyNames$ 0 0 0 $_ast.Module$ 0 0 0 $pyff.statements.FullyQualifyNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $pyff.statements.FullyQualifyNames$ 0 0 0 0 0 $typing.Any$ 0 0 $pyff.statements.FullyQualifyNames$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.FullyQualifyNames$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 $pyff.statements.ExternalNameUsageChange$ 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 $pyff.statements.ExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.ExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.ExternalNameUsageChange$ 0 0 0 0 0 0 $pyff.statements.ExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Callable[[],_ast.Module]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],_ast.Module]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],_ast.Module]$ 0 0 0 $typing.Callable[[],_ast.Module]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 $typing.Callable[[],_ast.Module]$ 0 0 0 $typing.Callable[[],_ast.Module]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 $pyff.statements.SingleExternalNameUsageChange$ 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 $pyff.statements.SingleExternalNameUsageChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Callable[[],_ast.Module]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],_ast.Module]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.statements.ExternalNameUsageChange]$ 0 0 0 0 0 $typing.Callable[[],_ast.Module]$ 0 0 0 $typing.Callable[[],_ast.Module]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[pyff.statements.ExternalNameUsageChange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.statements.ExternalNameUsageChange]$ 0 0 0 0 0 $_ast.Module$ 0 $_ast.Module$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Optional[pyff.statements.ExternalNameUsageChange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 0 0 0 0 $pyff.statements.StatementPyfference$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.statements.StatementPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.statements.StatementPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.statements.StatementPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.statements.StatementPyfference]$ 0 0 0 0 0 0 $typing.Optional[pyff.statements.StatementPyfference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyff.statements.StatementPyfference]$ 0 0 0 0 0