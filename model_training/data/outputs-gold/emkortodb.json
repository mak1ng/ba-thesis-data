from typing import List , Tuple [EOL] import typing [EOL] import builtins [EOL] import todb [EOL] from typing import List , Tuple [EOL] [EOL] from todb . data_model import ConfColumn , PrimaryKeyConf [EOL] [EOL] ERROR_MSG = [string] [EOL] [EOL] [EOL] class DbClient ( object ) : [EOL] def init_table ( self , name , columns , pkey ) : [EOL] raise NotImplementedError ( ERROR_MSG ) [EOL] [EOL] def insert_in_batch ( self , table_name , objects ) : [EOL] raise NotImplementedError ( ERROR_MSG ) [EOL] [EOL] def insert_one_by_one ( self , table_name , objects ) : [EOL] raise NotImplementedError ( ERROR_MSG ) [EOL] [EOL] def drop_table ( self , name ) : [EOL] raise NotImplementedError ( ERROR_MSG ) [EOL] [EOL] def count ( self , table_name ) : [EOL] raise NotImplementedError ( ERROR_MSG ) [EOL] [EOL] def close ( self ) : [EOL] raise NotImplementedError ( ERROR_MSG ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[todb.data_model.ConfColumn]$ 0 $todb.data_model.PrimaryKeyConf$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Tuple[builtins.bool,typing.List[typing.List[builtins.str]]]$ 0 0 0 $builtins.str$ 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $builtins.str$ 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Dict , Type , Union , Any , Literal , List , Tuple [EOL] import typing_extensions [EOL] import builtins [EOL] import datetime [EOL] import sqlalchemy [EOL] import typing [EOL] import todb [EOL] import json [EOL] import string [EOL] from datetime import date , time , datetime [EOL] from typing import Type , List , Tuple , Dict , Any , Union [EOL] [EOL] from sqlalchemy import BigInteger , Integer , Float , Date , Time , DateTime , Boolean , Unicode [EOL] from sqlalchemy . sql . type_api import TypeEngine [EOL] [EOL] from todb . abstract import Model [EOL] [EOL] DEFAULT_FILE_ENCODING = [string] [EOL] DEFAULT_HAS_HEADER_ROW = True [EOL] DEFAULT_ROW_DELIMITER = [string] [EOL] DEFAULT_CELL_DELIMITER = [string] [EOL] [EOL] [EOL] class InputFileConfig ( Model ) : [EOL] def __init__ ( self , conf_dict ) : [EOL] self . conf_dict = conf_dict [EOL] [EOL] def file_encoding ( self ) : [EOL] return str ( self . conf_dict . get ( [string] , DEFAULT_FILE_ENCODING ) ) [EOL] [EOL] def has_header_row ( self ) : [EOL] return bool ( self . conf_dict . get ( [string] , DEFAULT_HAS_HEADER_ROW ) ) [EOL] [EOL] def row_delimiter ( self ) : [EOL] return str ( self . conf_dict . get ( [string] , DEFAULT_ROW_DELIMITER ) ) [EOL] [EOL] def cell_delimiter ( self ) : [EOL] return str ( self . conf_dict . get ( [string] , DEFAULT_CELL_DELIMITER ) ) [EOL] [EOL] [EOL] _CONF_TYPE_TO_PYTHON_TYPE = { [string] : bool , [string] : str , [string] : date , [string] : time , [string] : datetime , [string] : int , [string] : int , [string] : float , [string] : float } [EOL] [EOL] _CONF_TYPE_TO_SQL_TYPE = { [string] : Boolean , [string] : Unicode , [string] : Date , [string] : Time , [string] : DateTime , [string] : Integer , [string] : BigInteger , [string] : Float , [string] : Float } [EOL] [EOL] _CONF_TYPE_TO_CASS_TYPE = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def handle_lat_lon ( lat_or_lon ) : [EOL] lat_or_lon = lat_or_lon . replace ( [string] , [string] ) [EOL] table = str . maketrans ( { key : [string] for key in string . punctuation } ) [EOL] lat_or_lon = lat_or_lon . translate ( table ) [EOL] multiplier = [number] if lat_or_lon [ - [number] ] in [ [string] , [string] ] else - [number] [EOL] lat_or_lon_numeric_parts = [ p for p in lat_or_lon [ : - [number] ] . split ( [string] ) if p . isdigit ( ) ] [EOL] lat_or_lon_value = sum ( float ( x ) / [number] ** n for n , x in enumerate ( lat_or_lon_numeric_parts ) ) [EOL] return multiplier * lat_or_lon_value [EOL] [EOL] [EOL] def handle_float ( value ) : [EOL] if [string] in value and [string] in value : [EOL] if value . find ( [string] ) < value . find ( [string] ) : [EOL] return float ( value . replace ( [string] , [string] ) ) [EOL] else : [EOL] return float ( value . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] elif [string] in value : [EOL] return float ( value . replace ( [string] , [string] ) ) [EOL] else : [EOL] return float ( value ) [EOL] [EOL] [EOL] def get_python_type ( conf_type ) : [EOL] return _CONF_TYPE_TO_PYTHON_TYPE [ conf_type ] [EOL] [EOL] [EOL] def get_sql_type ( conf_type ) : [EOL] return _CONF_TYPE_TO_SQL_TYPE [ conf_type ] [EOL] [EOL] [EOL] def get_cass_type ( conf_type ) : [EOL] return _CONF_TYPE_TO_CASS_TYPE [ conf_type ] [EOL] [EOL] [EOL] class ConfColumn ( Model ) : [EOL] def __init__ ( self , name , col_index , conf_type , nullable , indexed , unique ) : [EOL] self . name = name [EOL] self . col_index = col_index [EOL] self . nullable = nullable [EOL] self . indexed = indexed [EOL] self . unique = unique [EOL] self . conf_type = conf_type [EOL] self . python_type = get_python_type ( self . conf_type ) [EOL] self . sql_type = get_sql_type ( self . conf_type ) [EOL] self . cass_type = get_cass_type ( self . conf_type ) [EOL] [EOL] [EOL] PKEY_AUTOINC = [string] [EOL] PKEY_UUID = [string] [EOL] PKEY_COLS = [string] [EOL] [EOL] [EOL] class PrimaryKeyConf ( Model ) : [EOL] def __init__ ( self , mode , columns ) : [EOL] self . mode = mode [EOL] self . columns = columns [EOL] [EOL] def is_clustered ( self ) : [EOL] return len ( self . columns ) > [number] [EOL] [EOL] [EOL] def parse_model_file ( file_path ) : [EOL] columns = [ ] [EOL] with open ( file_path , [string] , encoding = [string] ) as model_file : [EOL] model_conf = json . load ( model_file ) [EOL] file_config = InputFileConfig ( model_conf . get ( [string] , { } ) ) [EOL] [EOL] col_names = model_conf . get ( [string] , { } ) [EOL] for col_name , col_conf in col_names . items ( ) : [EOL] column = ConfColumn ( name = col_name , col_index = col_conf [ [string] ] , conf_type = col_conf [ [string] ] , nullable = col_conf . get ( [string] , True ) , indexed = col_conf . get ( [string] , False ) , unique = col_conf . get ( [string] , False ) ) [EOL] columns . append ( column ) [EOL] [EOL] pkey_value = model_conf [ [string] ] [EOL] pkey_conf = _parse_primary_key_config ( col_names , pkey_value ) [EOL] [EOL] return columns , pkey_conf , file_config [EOL] [EOL] [EOL] def _parse_primary_key_config ( col_names , pkey_value ) : [EOL] pkey_conf = None [EOL] if pkey_value == PKEY_AUTOINC : [EOL] pkey_conf = PrimaryKeyConf ( PKEY_AUTOINC , [ ] ) [EOL] elif pkey_value == PKEY_UUID : [EOL] pkey_conf = PrimaryKeyConf ( PKEY_UUID , [ ] ) [EOL] elif isinstance ( pkey_value , str ) : [EOL] if pkey_value in col_names : [EOL] pkey_conf = PrimaryKeyConf ( PKEY_COLS , [ pkey_value ] ) [EOL] else : [EOL] raise ValueError ( [string] . format ( pkey_value , col_names ) ) [EOL] elif isinstance ( pkey_value , list ) : [EOL] if any ( [ c not in col_names for c in pkey_value ] ) : [EOL] raise ValueError ( [string] . format ( pkey_value , col_names ) ) [EOL] else : [EOL] pkey_conf = PrimaryKeyConf ( PKEY_COLS , pkey_value ) [EOL] else : [EOL] raise ValueError ( [string] . format ( type ( pkey_value ) , pkey_value ) ) [EOL] return pkey_conf [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PrimaryKeyConf$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import logging [EOL] import time [EOL] from os import path [EOL] from typing import Optional [EOL] [EOL] GLOBAL_LOGGER = None [EOL] DEFAULT_LOG_FILE = [string] [EOL] [EOL] [EOL] def setup_logger ( level = logging . INFO , log_file = None ) : [EOL] if log_file is not None : [EOL] log_directory = path . dirname ( path . abspath ( log_file ) ) [EOL] if path . exists ( log_directory ) : [EOL] logging . basicConfig ( format = [string] , level = level , filename = log_file ) [EOL] else : [EOL] print ( [string] . format ( log_directory ) ) [EOL] logging . basicConfig ( format = [string] , level = level , filename = DEFAULT_LOG_FILE ) [EOL] else : [EOL] logging . basicConfig ( format = [string] , level = level ) [EOL] logging . Formatter . converter = time . gmtime [EOL] sqlalchemy_logger = logging . getLogger ( [string] ) [EOL] if level == logging . DEBUG : [EOL] sqlalchemy_logger . setLevel ( logging . WARNING ) [EOL] else : [EOL] sqlalchemy_logger . setLevel ( logging . ERROR ) [EOL] [EOL] [EOL] def get_logger ( calling_module = [string] ) : [EOL] global GLOBAL_LOGGER [EOL] if GLOBAL_LOGGER is None : [EOL] GLOBAL_LOGGER = logging . getLogger ( calling_module ) [EOL] return GLOBAL_LOGGER [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] import todb [EOL] from datetime import datetime [EOL] from os import path [EOL] from typing import List [EOL] [EOL] from todb . data_model import InputFileConfig [EOL] from todb . logger import get_logger [EOL] from todb . util import seconds_between [EOL] [EOL] [EOL] class FailRowHandler ( object ) : [EOL] def __init__ ( self , input_file_config , output_file_path ) : [EOL] self . input_file_config = input_file_config [EOL] self . output_file_path = output_file_path [EOL] self . logger = get_logger ( ) [EOL] [EOL] def handle_failed_rows ( self , rows ) : [EOL] start_time = datetime . utcnow ( ) [EOL] self . logger . debug ( [string] . format ( len ( rows ) ) ) [EOL] try : [EOL] out_bytes = self . _convert_rows_to_bytes ( rows ) [EOL] with open ( self . output_file_path , [string] ) as out_file : [EOL] out_file . write ( out_bytes ) [EOL] took_seconds = seconds_between ( start_time ) [EOL] self . logger . info ( [string] . format ( len ( rows ) , took_seconds ) ) [EOL] except Exception as e : [EOL] self . logger . error ( [string] . format ( path . basename ( self . output_file_path ) , e , rows ) ) [EOL] [EOL] def _convert_rows_to_bytes ( self , rows ) : [EOL] out_string = self . input_file_config . row_delimiter ( ) . join ( [ self . input_file_config . cell_delimiter ( ) . join ( cells ) for cells in rows ] ) [EOL] out_bytes = ( [string] + out_string ) . encode ( self . input_file_config . file_encoding ( ) ) [EOL] return out_bytes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $builtins.float$ 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0
from typing import List , Iterator [EOL] import typing [EOL] import builtins [EOL] import todb [EOL] from typing import Iterator , List [EOL] [EOL] from todb . data_model import InputFileConfig [EOL] from todb . logger import get_logger [EOL] [EOL] [EOL] class CsvParser ( object ) : [EOL] def __init__ ( self , input_file_config , chunk_size_kB ) : [EOL] self . chunk_size_kB = chunk_size_kB [EOL] self . input_file_config = input_file_config [EOL] self . logger = get_logger ( ) [EOL] [EOL] def read_rows_in_chunks ( self , file_path ) : [EOL] buffer_size_bytes = round ( self . chunk_size_kB * [number] , ndigits = None ) [EOL] cached_last_line = [string] [EOL] has_header_row = self . input_file_config . has_header_row ( ) [EOL] with open ( file_path , [string] ) as input_file : [EOL] while True : [EOL] data = input_file . read ( buffer_size_bytes ) [EOL] if not data : [EOL] break [EOL] try : [EOL] one_line = cached_last_line + data . decode ( self . input_file_config . file_encoding ( ) ) [EOL] rows = one_line . split ( self . input_file_config . row_delimiter ( ) ) [EOL] cached_last_line = rows . pop ( - [number] ) [comment] [EOL] if has_header_row : [EOL] rows . pop ( [number] ) [comment] [EOL] has_header_row = False [EOL] cells_in_rows = [ r . split ( self . input_file_config . cell_delimiter ( ) ) for r in rows ] [EOL] yield cells_in_rows [EOL] except Exception as e : [EOL] self . logger . error ( [string] . format ( e ) ) [EOL] cached_last_line = [string] [EOL] yield [ ] [EOL] [comment] [EOL] yield [ cached_last_line . split ( self . input_file_config . cell_delimiter ( ) ) ] if cached_last_line else [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $todb.data_model.InputFileConfig$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $todb.data_model.InputFileConfig$ 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.List[typing.List[builtins.str]]]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import Dict , Optional , List , Any [EOL] import typing [EOL] import datetime [EOL] import todb [EOL] import builtins [EOL] from datetime import datetime , date , time [EOL] from typing import Dict , List , Any , Optional [EOL] [EOL] from dateutil . parser import parse [EOL] [EOL] from todb . data_model import ConfColumn , handle_lat_lon , handle_float [EOL] from todb . logger import get_logger [EOL] [EOL] BOOLEAN_MAPPINGS = { [string] : True , [string] : False , [string] : False , [string] : True , [string] : False , [string] : True , [string] : False , [string] : True , [string] : False } [EOL] [EOL] [EOL] class EntityBuilder ( object ) : [EOL] def __init__ ( self , columns ) : [EOL] self . columns = columns [EOL] self . logger = get_logger ( ) [EOL] [EOL] def to_entity ( self , cells_in_row ) : [EOL] try : [EOL] return { c . name : self . _cast_value_to_sql_compatible ( c , cells_in_row [ c . col_index ] if c . col_index is not None else None ) for c in self . columns } [EOL] except Exception as e : [EOL] self . logger . debug ( [string] . format ( cells_in_row , e ) ) [EOL] return None [EOL] [EOL] def _cast_value_to_sql_compatible ( self , column , value ) : [EOL] if not value or value . lower ( ) == [string] : [EOL] if column . nullable : [EOL] return None [EOL] else : [EOL] raise ValueError ( [string] . format ( column . name ) ) [EOL] try : [EOL] if column . conf_type == [string] : [EOL] return handle_lat_lon ( value ) [EOL] if column . conf_type == [string] : [EOL] return handle_float ( value ) [EOL] elif column . python_type in ( datetime , date , time ) : [EOL] parsed_time = parse ( value ) [EOL] if column . python_type == datetime : [EOL] return parsed_time . replace ( tzinfo = None ) [EOL] elif column . python_type == date : [EOL] return parsed_time . date ( ) [EOL] else : [EOL] return parsed_time . time ( ) [EOL] elif column . python_type == bool : [EOL] mapping = BOOLEAN_MAPPINGS . get ( value . lower ( ) , None ) [EOL] if mapping is not None : [EOL] return mapping [EOL] else : [EOL] return bool ( int ( value ) ) [EOL] else : [EOL] return column . python_type ( value ) [EOL] except Exception as e : [EOL] self . logger . warning ( [string] . format ( value , column , e ) ) [EOL] if column . nullable : [EOL] return None [EOL] else : [EOL] raise e [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[todb.data_model.ConfColumn]$ 0 0 0 0 0 $typing.List[todb.data_model.ConfColumn]$ 0 $typing.List[todb.data_model.ConfColumn]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 $todb.data_model.ConfColumn$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $todb.data_model.ConfColumn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.ConfColumn$ 0 0 0 0 0 0 0 0 0 $todb.data_model.ConfColumn$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $todb.data_model.ConfColumn$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $todb.data_model.ConfColumn$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $todb.data_model.ConfColumn$ 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 $todb.data_model.ConfColumn$ 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 $todb.data_model.ConfColumn$ 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $todb.data_model.ConfColumn$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $todb.data_model.ConfColumn$ 0 0 0 0 0 0 $todb.data_model.ConfColumn$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , Any , List , Optional [EOL] import typing [EOL] import builtins [EOL] import sqlalchemy [EOL] import todb [EOL] from typing import List , Dict , Any , Optional , Tuple [EOL] [EOL] from sqlalchemy import MetaData , Column , Table , select , func , Integer [EOL] from sqlalchemy . engine import Engine , create_engine , Connection [EOL] from sqlalchemy . pool import NullPool [EOL] [EOL] from todb . data_model import ConfColumn , PrimaryKeyConf , PKEY_AUTOINC [EOL] from todb . db_client import DbClient [EOL] from todb . entity_builder import EntityBuilder [EOL] from todb . logger import get_logger [EOL] [EOL] INSERT_ONE_BY_ONE_THRESHOLD = [number] [EOL] [EOL] [EOL] class SqlClient ( DbClient ) : [EOL] def __init__ ( self , db_url , entity_builder , db_engine = None , ca_file = None ) : [EOL] self . db_url = db_url [EOL] self . ca_file = ca_file [EOL] self . entity_builder = entity_builder [EOL] self . _db_engine = db_engine [EOL] self . logger = get_logger ( ) [EOL] self . _conn = None [comment] [EOL] [EOL] def init_table ( self , name , columns , pkey ) : [EOL] meta = MetaData ( ) [EOL] table = self . _get_table ( name ) [EOL] if table is None : [EOL] self . logger . info ( [string] . format ( name ) ) [EOL] table = self . _sql_table_from_columns ( meta , name , columns , pkey ) [EOL] meta . create_all ( self . _get_db_engine ( ) , tables = [ table ] ) [EOL] [EOL] def drop_table ( self , name ) : [EOL] the_table = self . _get_table ( name ) [EOL] if the_table is not None : [EOL] the_table . drop ( bind = self . _get_db_engine ( ) ) [EOL] [EOL] def count ( self , table_name ) : [EOL] try : [EOL] table = self . _get_table ( table_name ) [EOL] count = self . _get_connection ( ) . scalar ( select ( [ func . count ( ) ] ) . select_from ( table ) ) [EOL] except Exception as e : [EOL] self . logger . error ( [string] . format ( e ) ) [EOL] count = [number] [EOL] return count [EOL] [EOL] def insert_in_batch ( self , table_name , rows ) : [EOL] list_of_model_dicts , failed_rows = self . _build_entities_from_rows ( rows ) [EOL] if list_of_model_dicts : [EOL] try : [EOL] self . _insert_entities ( list_of_model_dicts , table_name ) [EOL] return True , failed_rows [EOL] except Exception as e : [EOL] self . logger . debug ( [string] . format ( len ( list_of_model_dicts ) , e ) ) [EOL] return False , failed_rows [EOL] else : [EOL] return True , failed_rows [EOL] [EOL] def insert_one_by_one ( self , table_name , rows ) : [EOL] all_failed_rows = [ ] [EOL] for row in rows : [EOL] list_of_entities , failed_rows = self . _build_entities_from_rows ( [ row ] ) [EOL] all_failed_rows . extend ( failed_rows ) [EOL] if list_of_entities : [EOL] try : [EOL] self . _insert_entities ( list_of_entities , table_name ) [EOL] except Exception : [EOL] all_failed_rows . append ( row ) [EOL] return all_failed_rows [EOL] [EOL] def close ( self ) : [EOL] if self . _conn is not None and not self . _conn . closed : [EOL] self . _conn . close ( ) [EOL] [EOL] def _build_entities_from_rows ( self , rows ) : [EOL] list_of_model_dicts = [ ] [EOL] failed_rows = [ ] [EOL] for row_cells in rows : [EOL] entity = self . entity_builder . to_entity ( row_cells ) [EOL] if entity is not None : [EOL] list_of_model_dicts . append ( entity ) [EOL] else : [EOL] failed_rows . append ( row_cells ) [EOL] return list_of_model_dicts , failed_rows [EOL] [EOL] def _insert_entities ( self , list_of_model_dicts , table_name ) : [EOL] db_connection = self . _get_connection ( ) [EOL] table = self . _get_table ( table_name ) [EOL] if table is None : [EOL] raise Exception ( [string] . format ( table_name , self . db_url ) ) [EOL] db_connection . execute ( table . insert ( ) , list_of_model_dicts ) [EOL] return db_connection [EOL] [EOL] def _get_table ( self , name ) : [EOL] meta = MetaData ( ) [EOL] meta . reflect ( bind = self . _get_db_engine ( ) ) [EOL] try : [EOL] return meta . tables [ name ] [EOL] except KeyError as e : [EOL] self . logger . debug ( [string] . format ( name , e ) ) [EOL] return None [EOL] [EOL] def _get_connection ( self ) : [EOL] if self . _conn is None or self . _conn . closed : [EOL] self . _conn = self . _get_db_engine ( ) . connect ( ) [EOL] return self . _conn [EOL] [EOL] def _get_db_engine ( self ) : [EOL] if self . _db_engine is None : [EOL] self . logger . debug ( [string] . format ( self . db_url ) ) [EOL] if self . ca_file is not None : [EOL] ssl_args = { [string] : { [string] : self . ca_file } } [EOL] self . _db_engine = create_engine ( self . db_url , echo = False , poolclass = NullPool , connect_args = ssl_args ) [EOL] else : [EOL] self . _db_engine = create_engine ( self . db_url , echo = False , poolclass = NullPool ) [EOL] return self . _db_engine [EOL] [EOL] def _sql_table_from_columns ( self , sql_metadata , table_name , columns , pkey ) : [EOL] sql_columns = { c . name : Column ( c . name , c . sql_type , primary_key = c . name in pkey . columns , nullable = c . nullable , index = c . indexed , unique = c . unique ) for c in columns } [EOL] if pkey . mode == PKEY_AUTOINC : [EOL] id_column = Column ( [string] , Integer , primary_key = True , autoincrement = True ) [EOL] sql_columns . update ( { [string] : id_column } ) [EOL] return Table ( table_name , sql_metadata , * sql_columns . values ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $todb.entity_builder.EntityBuilder$ 0 $typing.Optional[sqlalchemy.engine.Engine]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $todb.entity_builder.EntityBuilder$ 0 $todb.entity_builder.EntityBuilder$ 0 0 0 0 0 $typing.Optional[sqlalchemy.engine.Engine]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[todb.data_model.ConfColumn]$ 0 $todb.data_model.PrimaryKeyConf$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.List[todb.data_model.ConfColumn]$ 0 $todb.data_model.PrimaryKeyConf$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Tuple[builtins.bool,typing.List[typing.List[builtins.str]]]$ 0 0 0 $builtins.str$ 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $builtins.str$ 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Dict[builtins.str,typing.Any]],typing.List[typing.List[builtins.str]]]$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $sqlalchemy.engine.Connection$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Optional[sqlalchemy.Table]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.engine.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.engine.Engine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.Table$ 0 0 0 $sqlalchemy.MetaData$ 0 $builtins.str$ 0 $typing.List[todb.data_model.ConfColumn]$ 0 $todb.data_model.PrimaryKeyConf$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.PrimaryKeyConf$ 0 $typing.List[todb.data_model.ConfColumn]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[todb.data_model.ConfColumn]$ 0 0 0 $todb.data_model.PrimaryKeyConf$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $sqlalchemy.MetaData$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0
from typing import Dict , Tuple , Any , List , Optional [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] import uuid [EOL] from datetime import datetime [EOL] from os import path [EOL] from typing import Optional , Any , List , Dict , Tuple [EOL] from uuid import UUID , uuid5 [EOL] [EOL] SEED_TEXT = UUID ( int = [number] ) [EOL] [EOL] [EOL] def seconds_between ( start , end = None , precision = [number] ) : [EOL] return round ( ( ( end or datetime . utcnow ( ) ) - start ) . total_seconds ( ) , precision ) [EOL] [EOL] [EOL] def proj_path_to_abs ( rel_project_path ) : [EOL] this_file_dir = path . dirname ( path . realpath ( __file__ ) ) [EOL] project_directory , project_dir_name , _ = this_file_dir . partition ( [string] ) [EOL] return path . abspath ( path . join ( project_directory , project_dir_name , rel_project_path ) ) [EOL] [EOL] [EOL] def limit_or_default ( value , default , lower_bound = None , upper_bound = None ) : [EOL] if value is None : [EOL] return default [EOL] else : [EOL] if lower_bound is not None and upper_bound is not None : [EOL] return min ( max ( value , lower_bound ) , upper_bound ) [EOL] elif lower_bound is not None : [EOL] return max ( value , lower_bound ) [EOL] elif upper_bound is not None : [EOL] return min ( value , upper_bound ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def gen_uuid_from_obj ( o , sorted_keys ) : [EOL] cells_as_str = [string] . join ( [ str ( o [ c ] ) for c in sorted_keys ] ) [EOL] return gen_uuid ( str ( cells_as_str ) ) [EOL] [EOL] [EOL] def gen_uuid ( content ) : [EOL] return str ( uuid5 ( SEED_TEXT , str ( content ) ) ) [EOL] [EOL] [EOL] def split_in_half ( values ) : [EOL] half = len ( values ) // [number] [EOL] return values [ : half ] , values [ half : ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from copy import copy [EOL] [EOL] [EOL] class Model ( object ) : [EOL] def __repr__ ( self ) : [EOL] return str ( { self . __class__ . __name__ : copy ( self . __dict__ ) } ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . __repr__ ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . __dict__ == other . __dict__ [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . __dict__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import todb [EOL] import datetime [EOL] from datetime import datetime [EOL] from typing import List [EOL] [EOL] from todb . db_client import DbClient [EOL] from todb . logger import get_logger [EOL] from todb . util import split_in_half , seconds_between [EOL] [EOL] INSERT_ONE_BY_ONE_THRESHOLD = [number] [EOL] [EOL] [EOL] class Importer ( object ) : [EOL] def __init__ ( self , db_client ) : [EOL] self . db_client = db_client [EOL] self . logger = get_logger ( ) [EOL] [EOL] def parse_and_import ( self , table_name , rows ) : [EOL] [docstring] [EOL] start_time = datetime . utcnow ( ) [EOL] if len ( rows ) <= INSERT_ONE_BY_ONE_THRESHOLD : [EOL] failed_rows = self . db_client . insert_one_by_one ( table_name , rows ) [EOL] took_seconds = seconds_between ( start_time ) [EOL] self . logger . debug ( [string] . format ( len ( rows ) - len ( failed_rows ) , len ( rows ) , took_seconds ) ) [EOL] return failed_rows [EOL] else : [EOL] mass_insert_successful , failed_rows = self . db_client . insert_in_batch ( table_name , rows ) [EOL] if mass_insert_successful : [EOL] took_seconds = seconds_between ( start_time ) [EOL] self . logger . debug ( [string] . format ( len ( rows ) - len ( failed_rows ) , len ( rows ) , took_seconds ) ) [EOL] return failed_rows [EOL] else : [EOL] rows_a , rows_b = split_in_half ( rows ) [EOL] failed_rows_a = self . parse_and_import ( table_name , rows_a ) [EOL] failed_rows_b = self . parse_and_import ( table_name , rows_b ) [EOL] return failed_rows_a + failed_rows_b [EOL] [EOL] def close ( self ) : [EOL] self . db_client . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from todb . main import todb [EOL] from todb . params import InputParams [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import todb [EOL] import unittest [EOL] [EOL] from todb . data_model import InputFileConfig [EOL] from todb . parsing import CsvParser [EOL] from todb . util import proj_path_to_abs [EOL] [EOL] [EOL] class CsvParsingTest ( unittest . TestCase ) : [EOL] def test_should_parse_example_csv_file ( self ) : [EOL] abs_csv_path = proj_path_to_abs ( [string] ) [EOL] in_file_config = InputFileConfig ( { [string] : True } ) [EOL] parser = CsvParser ( in_file_config , chunk_size_kB = [number] ) [EOL] [EOL] all_lines = [ ] [EOL] for lines in parser . read_rows_in_chunks ( abs_csv_path ) : [EOL] all_lines . extend ( lines ) [EOL] self . assertIn ( [ [string] , [string] , [string] , [string] ] , all_lines ) [EOL] self . assertIn ( [ [string] , [string] , [string] , [string] ] , all_lines ) [EOL] self . assertIn ( [ [string] , [string] , [string] , [string] ] , all_lines ) [EOL] self . assertNotIn ( [ [string] , [string] , [string] , [string] ] , all_lines ) [EOL] self . assertEqual ( len ( all_lines ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 0 $todb.parsing.CsvParser$ 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $todb.parsing.CsvParser$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0
	0
import datetime [EOL] import unittest [EOL] from datetime import datetime , timedelta [EOL] [EOL] from todb . util import seconds_between [EOL] [EOL] [EOL] class UtilsTest ( unittest . TestCase ) : [EOL] def test_should_measure_seconds_since_event ( self ) : [EOL] start_point = datetime . utcnow ( ) - timedelta ( seconds = [number] ) [EOL] time_that_passed = seconds_between ( start_point ) [EOL] self . assertAlmostEqual ( time_that_passed , [number] , delta = [number] ) [EOL] [EOL] def test_should_measure_seconds_between_events ( self ) : [EOL] end_point = datetime . utcnow ( ) [EOL] start_point = end_point - timedelta ( seconds = [number] ) [EOL] time_that_passed = seconds_between ( start_point , end_point ) [EOL] self . assertAlmostEqual ( time_that_passed , [number] , delta = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0
import todb [EOL] import json [EOL] import unittest [EOL] [EOL] from todb . data_model import InputFileConfig [EOL] [EOL] INPUT_FILE_CONFIG = [string] [EOL] [EOL] [EOL] class InputFileConfigParsingTest ( unittest . TestCase ) : [EOL] def test_should_return_default_config_on_empty_input ( self ) : [EOL] default_config = InputFileConfig ( conf_dict = { } ) [EOL] self . assertEqual ( default_config . file_encoding ( ) , [string] ) [EOL] self . assertEqual ( default_config . has_header_row ( ) , True ) [EOL] self . assertEqual ( default_config . row_delimiter ( ) , [string] ) [EOL] self . assertEqual ( default_config . cell_delimiter ( ) , [string] ) [EOL] [EOL] def test_should_return_custom_config_on_custom_input ( self ) : [EOL] custom_config = InputFileConfig ( conf_dict = json . loads ( INPUT_FILE_CONFIG ) ) [EOL] self . assertEqual ( custom_config . file_encoding ( ) , [string] ) [EOL] self . assertEqual ( custom_config . has_header_row ( ) , False ) [EOL] self . assertEqual ( custom_config . row_delimiter ( ) , [string] ) [EOL] self . assertEqual ( custom_config . cell_delimiter ( ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.InputFileConfig$ 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import todb [EOL] import unittest [EOL] [EOL] from test . test_db_utils import setup_db_repository_test_class , get_test_db_engine , TEST_SQL_DB_URL [EOL] from todb . data_model import ConfColumn , PrimaryKeyConf , PKEY_AUTOINC [EOL] from todb . entity_builder import EntityBuilder [EOL] from todb . sql_client import SqlClient [EOL] [EOL] [EOL] class SqlClientTest ( unittest . TestCase ) : [EOL] @ classmethod def setUpClass ( cls ) : [EOL] setup_db_repository_test_class ( cls ) [EOL] [EOL] def setUp ( self ) : [EOL] self . columns = [ ConfColumn ( [string] , [number] , [string] , nullable = True , indexed = True , unique = True ) , ConfColumn ( [string] , [number] , [string] , nullable = False , indexed = False , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = True , indexed = False , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = True , indexed = False , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = False , indexed = True , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = True , indexed = False , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = True , indexed = False , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = False , indexed = True , unique = False ) ] [EOL] self . primary_key = PrimaryKeyConf ( mode = PKEY_AUTOINC , columns = [ ] ) [EOL] self . rows = [ [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ] [EOL] self . entity_builder = EntityBuilder ( self . columns ) [EOL] self . client = SqlClient ( TEST_SQL_DB_URL , self . entity_builder , get_test_db_engine ( debug = True ) ) [EOL] self . table_name = [string] [EOL] [EOL] def tearDown ( self ) : [EOL] self . client . drop_table ( self . table_name ) [EOL] [EOL] def test_should_create_and_drop_tables ( self ) : [EOL] self . client . init_table ( self . table_name , self . columns , self . primary_key ) [EOL] actual_table = self . client . _get_table ( self . table_name ) [EOL] self . assertIsNotNone ( actual_table ) [EOL] self . assertEqual ( len ( actual_table . columns ) , len ( self . columns ) + [number] ) [EOL] [EOL] def test_should_create_table_and_insert_data ( self ) : [EOL] self . client . init_table ( self . table_name , self . columns , self . primary_key ) [EOL] self . client . insert_in_batch ( self . table_name , self . rows ) [EOL] row_count = self . client . count ( self . table_name ) [EOL] self . assertEqual ( row_count , len ( self . rows ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[todb.data_model.ConfColumn]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.data_model.PrimaryKeyConf$ 0 0 0 0 0 0 0 $typing.List[todb.data_model.ConfColumn]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.entity_builder.EntityBuilder$ 0 0 0 0 0 $typing.List[todb.data_model.ConfColumn]$ 0 0 0 0 $todb.sql_client.SqlClient$ 0 0 0 0 0 0 0 $todb.entity_builder.EntityBuilder$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import unittest [EOL] import sqlalchemy [EOL] import builtins [EOL] from typing import Type [EOL] from unittest import TestCase [EOL] [EOL] from sqlalchemy . engine import Engine , create_engine [EOL] from sqlalchemy . pool import StaticPool [EOL] [EOL] TEST_SQL_DB_URL = [string] [EOL] [EOL] [EOL] def setup_db_repository_test_class ( cls ) : [EOL] cls . db_file_name = [string] . format ( cls . __name__ ) [comment] [EOL] cls . engine = get_test_db_engine ( debug = True ) [comment] [EOL] [EOL] [EOL] def get_test_db_engine ( debug = False ) : [EOL] [docstring] [EOL] return create_engine ( TEST_SQL_DB_URL , echo = debug , poolclass = StaticPool ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.engine.Engine$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from todb . data_model import parse_model_file , ConfColumn , PrimaryKeyConf , PKEY_COLS , handle_lat_lon , handle_float [EOL] from todb . util import proj_path_to_abs [EOL] [EOL] LAT_LON_DELTA = [number] [EOL] FLOAT_DELTA = [number] [EOL] [EOL] [EOL] class DataModelParsingTest ( unittest . TestCase ) : [EOL] def test_should_parse_model_file ( self ) : [EOL] abs_csv_path = proj_path_to_abs ( [string] ) [EOL] model_columns , pkey_config , file_config = parse_model_file ( abs_csv_path ) [EOL] self . assertEqual ( pkey_config , PrimaryKeyConf ( PKEY_COLS , [ [string] , [string] , [string] ] ) ) [EOL] self . assertEqual ( len ( model_columns ) , [number] ) [EOL] self . assertIn ( ConfColumn ( name = [string] , col_index = [number] , conf_type = [string] , nullable = False , indexed = True , unique = False ) , model_columns ) [EOL] [EOL] def test_should_parse_lat_lon_strings ( self ) : [EOL] coord_1 = [string] [EOL] coord_1_expected = [number] [EOL] coord_2 = [string] [EOL] coord_1_actual = handle_lat_lon ( coord_1 ) [EOL] coord_2_expected = - [number] [EOL] coord_2_actual = handle_lat_lon ( coord_2 ) [EOL] self . assertAlmostEqual ( coord_1_actual , coord_1_expected , delta = LAT_LON_DELTA ) [EOL] self . assertAlmostEqual ( coord_2_actual , coord_2_expected , delta = LAT_LON_DELTA ) [EOL] [EOL] def test_should_parse_lat_lon_canonical_strings ( self ) : [EOL] coord_1 = [string] [string] [EOL] coord_1_expected = [number] [EOL] coord_2 = [string] [string] [EOL] coord_1_actual = handle_lat_lon ( coord_1 ) [EOL] coord_2_expected = - [number] [EOL] coord_2_actual = handle_lat_lon ( coord_2 ) [EOL] self . assertAlmostEqual ( coord_1_actual , coord_1_expected , delta = LAT_LON_DELTA ) [EOL] self . assertAlmostEqual ( coord_2_actual , coord_2_expected , delta = LAT_LON_DELTA ) [EOL] [EOL] def test_should_parse_float_in_comma_notation ( self ) : [EOL] float_with_commas = [string] [EOL] float_with_commas_inverted = [string] [EOL] float_with_comma_as_separator = [string] [EOL] float_with_dot_as_separator = [string] [EOL] expected_float = [number] [EOL] self . assertAlmostEqual ( handle_float ( float_with_commas ) , expected_float , delta = FLOAT_DELTA ) [EOL] self . assertAlmostEqual ( handle_float ( float_with_commas_inverted ) , expected_float , delta = FLOAT_DELTA ) [EOL] self . assertAlmostEqual ( handle_float ( float_with_comma_as_separator ) , expected_float , delta = FLOAT_DELTA ) [EOL] self . assertAlmostEqual ( handle_float ( float_with_dot_as_separator ) , expected_float , delta = FLOAT_DELTA ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0
from typing import Dict , Union , Any , List , Optional [EOL] import typing [EOL] import datetime [EOL] import todb [EOL] import unittest [EOL] from datetime import datetime , date , time [EOL] [EOL] from todb . data_model import ConfColumn [EOL] from todb . entity_builder import EntityBuilder [EOL] [EOL] [EOL] class EntityBuilderTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . columns = [ ConfColumn ( [string] , [number] , [string] , nullable = True , indexed = True , unique = True ) , ConfColumn ( [string] , [number] , [string] , nullable = False , indexed = False , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = True , indexed = False , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = True , indexed = False , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = False , indexed = True , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = True , indexed = False , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = True , indexed = False , unique = False ) , ConfColumn ( [string] , [number] , [string] , nullable = False , indexed = True , unique = False ) ] [EOL] [EOL] def test_should_build_entity_with_each_type ( self ) : [EOL] row = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] builder = EntityBuilder ( self . columns ) [EOL] actual_entity = builder . to_entity ( row ) [EOL] expected_entity = { [string] : [string] , [string] : - [number] , [string] : [number] , [string] : - [number] , [string] : True , [string] : date ( [number] , [number] , [number] ) , [string] : time ( [number] , [number] , [number] , [number] ) , [string] : datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) } [EOL] self . assertEqual ( actual_entity , expected_entity ) [EOL] [EOL] def test_should_return_none_on_non_nullable_column ( self ) : [EOL] row = [ [string] , None , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] builder = EntityBuilder ( self . columns ) [EOL] actual_entity = builder . to_entity ( row ) [EOL] self . assertEqual ( actual_entity , None ) [EOL] [EOL] def test_should_return_none_on_too_many_columns ( self ) : [EOL] row = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] builder = EntityBuilder ( self . columns ) [EOL] actual_entity = builder . to_entity ( row ) [EOL] self . assertEqual ( actual_entity , None ) [EOL] [EOL] def test_should_replace_value_with_none_if_column_nullable_and_value_non_parsable ( self ) : [EOL] row = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] builder = EntityBuilder ( self . columns ) [EOL] actual_entity = builder . to_entity ( row ) [EOL] expected_entity = { [string] : [string] , [string] : - [number] , [string] : None , [string] : None , [string] : True , [string] : date ( [number] , [number] , [number] ) , [string] : time ( [number] , [number] , [number] , [number] ) , [string] : datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) } [EOL] self . assertEqual ( actual_entity , expected_entity ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[todb.data_model.ConfColumn]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.entity_builder.EntityBuilder$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $todb.entity_builder.EntityBuilder$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Union[datetime.date.time.date,datetime.date.time.time,builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Dict[builtins.str,typing.Union[datetime.date.time.date,datetime.date.time.time,builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.entity_builder.EntityBuilder$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $todb.entity_builder.EntityBuilder$ 0 0 0 $typing.List[typing.Optional[builtins.str]]$ 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.entity_builder.EntityBuilder$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $todb.entity_builder.EntityBuilder$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todb.entity_builder.EntityBuilder$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $todb.entity_builder.EntityBuilder$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Union[None,datetime.date.time.date,datetime.date.time.time,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Dict[builtins.str,typing.Union[None,datetime.date.time.date,datetime.date.time.time,builtins.int,builtins.str]]$ 0 0