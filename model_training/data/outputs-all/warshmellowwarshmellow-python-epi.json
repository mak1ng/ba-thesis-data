from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] def dutch ( pivot_index , nums ) : [EOL] pivot = nums [ pivot_index ] [EOL] [EOL] smaller = [number] [EOL] for i , _ in enumerate ( nums ) : [EOL] if nums [ i ] < pivot : [EOL] nums [ i ] , nums [ smaller ] = nums [ smaller ] , nums [ i ] [EOL] smaller += [number] [EOL] [EOL] larger = len ( nums ) - [number] [EOL] for i in reversed ( range ( len ( nums ) ) ) : [EOL] if nums [ i ] < pivot : [EOL] break [EOL] elif nums [ i ] > pivot : [EOL] nums [ i ] , nums [ larger ] = nums [ larger ] , nums [ i ] [EOL] larger -= [number] [EOL] [EOL] return nums [EOL] [EOL] [EOL] def mod_three_sort ( nums ) : [EOL] [comment] [EOL] lowest_eq1 = - [number] [EOL] lowest_eq2 = - [number] [EOL] [EOL] [comment] [EOL] for i in range ( len ( nums ) ) : [EOL] [comment] [EOL] n = nums [ i ] [EOL] [EOL] if n % [number] == [number] : [EOL] if lowest_eq1 == - [number] and lowest_eq2 > - [number] : [EOL] [comment] [EOL] nums [ lowest_eq2 ] , nums [ i ] = nums [ i ] , nums [ lowest_eq2 ] [EOL] lowest_eq2 += [number] [EOL] elif lowest_eq1 > - [number] and lowest_eq2 == - [number] : [EOL] [comment] [EOL] nums [ lowest_eq1 ] , nums [ i ] = nums [ i ] , nums [ lowest_eq1 ] [EOL] lowest_eq1 += [number] [EOL] elif lowest_eq1 > - [number] and lowest_eq2 > - [number] : [EOL] [comment] [EOL] nums [ lowest_eq1 ] , nums [ i ] = nums [ i ] , nums [ lowest_eq1 ] [EOL] lowest_eq1 += [number] [EOL] nums [ lowest_eq2 ] , nums [ i ] = nums [ i ] , nums [ lowest_eq2 ] [EOL] lowest_eq2 += [number] [EOL] [EOL] elif n % [number] == [number] : [EOL] [comment] [EOL] if lowest_eq1 == - [number] and lowest_eq2 == - [number] : [EOL] lowest_eq1 = i [EOL] elif lowest_eq1 > - [number] and lowest_eq2 == - [number] : [EOL] [comment] [EOL] pass [EOL] elif lowest_eq1 > - [number] and lowest_eq2 > - [number] : [EOL] [comment] [EOL] nums [ lowest_eq2 ] , nums [ i ] = nums [ i ] , nums [ lowest_eq2 ] [EOL] lowest_eq2 += [number] [EOL] elif lowest_eq1 == - [number] and lowest_eq2 > - [number] : [EOL] [comment] [EOL] nums [ lowest_eq2 ] , nums [ i ] = nums [ i ] , nums [ lowest_eq2 ] [EOL] lowest_eq1 = lowest_eq2 [EOL] lowest_eq2 += [number] [EOL] [EOL] else : [EOL] if lowest_eq2 == - [number] : [EOL] lowest_eq2 = i [EOL] [EOL] return nums [EOL] [EOL] [EOL] def mod_two_stable_sort ( nums ) : [EOL] lowest_eq1 = - [number] [EOL] [EOL] for i in range ( len ( nums ) ) : [EOL] n = nums [ i ] [EOL] [comment] [EOL] if n % [number] == [number] : [EOL] if lowest_eq1 > - [number] : [EOL] for j in range ( i , lowest_eq1 , - [number] ) : [EOL] nums [ j ] , nums [ j - [number] ] = nums [ j - [number] ] , nums [ j ] [EOL] lowest_eq1 += [number] [EOL] else : [EOL] if lowest_eq1 == - [number] : [EOL] lowest_eq1 = i [EOL] [EOL] return nums [EOL] [EOL] [EOL] def add_two_bin_str ( a , b ) : [EOL] if len ( a ) == [number] and len ( b ) == [number] : [EOL] return [string] [EOL] [EOL] if len ( a ) > len ( b ) : [EOL] a , b = b , a [EOL] [EOL] a_rev = list ( reversed ( a ) ) [EOL] b_rev = list ( reversed ( b ) ) [EOL] [EOL] result = [ ] [EOL] carry_over = [number] [EOL] for i in range ( len ( a ) ) : [EOL] ac , bc = int ( a_rev [ i ] ) , int ( b_rev [ i ] ) [EOL] [EOL] s = ac + bc + carry_over [EOL] if s > [number] : [EOL] carry_over = [number] [EOL] else : [EOL] carry_over = [number] [EOL] [EOL] modded_sum = s % [number] [EOL] [EOL] result . append ( modded_sum ) [EOL] [EOL] left_over_b_rev = b_rev [ len ( a ) : ] [EOL] [EOL] for j in range ( len ( left_over_b_rev ) ) : [EOL] bc = int ( left_over_b_rev [ j ] ) [EOL] [EOL] s = bc + carry_over [EOL] if s > [number] : [EOL] carry_over = [number] [EOL] else : [EOL] carry_over = [number] [EOL] [EOL] modded_sum = s % [number] [EOL] [EOL] result . append ( modded_sum ) [EOL] [EOL] return [string] . join ( reversed ( [ str ( x ) for x in result ] ) ) [EOL] [EOL] [EOL] def multiply_two_list ( num1 , num2 ) : [EOL] result = [ [number] ] * ( len ( num1 ) + len ( num2 ) ) [EOL] [EOL] for i in reversed ( range ( len ( num1 ) ) ) : [EOL] for j in reversed ( range ( len ( num2 ) ) ) : [EOL] result [ i + j + [number] ] += num1 [ i ] * num2 [ j ] [EOL] result [ i + j ] += result [ i + j + [number] ] // [number] [EOL] result [ i + j + [number] ] %= [number] [EOL] [EOL] strip_idx = [number] [EOL] for i , x in enumerate ( result ) : [EOL] if x == [number] : [EOL] strip_idx += [number] [EOL] else : [EOL] break [EOL] [EOL] result_stripped = result [ strip_idx : ] [EOL] if len ( result_stripped ) == [number] : [EOL] result_stripped = [ [number] ] [EOL] [EOL] return result_stripped [EOL] [EOL] [EOL] def dedup_sorted ( a ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] write_me = [number] [EOL] [EOL] [comment] [EOL] for i in range ( [number] , len ( a ) ) : [EOL] highest_unique_so_far = a [ write_me - [number] ] [EOL] if highest_unique_so_far < a [ i ] : [EOL] a [ write_me ] = a [ i ] [EOL] write_me += [number] [EOL] [EOL] return a [ : write_me ] [EOL] [EOL] [EOL] def remove_key_and_shift ( a , key ) : [EOL] val = a [ key ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] write_me = a . index ( val ) [EOL] [EOL] i = write_me [EOL] while write_me < len ( a ) and i < len ( a ) : [EOL] if a [ i ] != val : [EOL] a [ write_me ] , a [ i ] = a [ i ] , a [ write_me ] [EOL] write_me += [number] [EOL] if write_me >= len ( a ) : [EOL] break [EOL] while a [ write_me ] != val : [EOL] write_me += [number] [EOL] if i < write_me : [EOL] i = write_me [EOL] else : [EOL] i += [number] [EOL] [EOL] return a [ : write_me ] [EOL] [EOL] [EOL] def overwrite_limit_sorted ( a , limit ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return a [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] class BinTree : [EOL] def __init__ ( self , item = None , left = None , right = None , parent = None ) : [EOL] self . item = item [EOL] self . parent = parent [EOL] self . left = left [EOL] self . right = right [EOL] [EOL] @ staticmethod def inorder ( root ) : [EOL] if not root : [EOL] return [ ] [EOL] [EOL] result = [ ] [EOL] result . extend ( BinTree . inorder ( root . left ) ) [EOL] result . extend ( [ root . item ] ) [EOL] result . extend ( BinTree . inorder ( root . right ) ) [EOL] return result [EOL] [EOL] @ staticmethod def preorder ( root ) : [EOL] if not root : [EOL] return [ ] [EOL] [EOL] result = [ ] [EOL] result . extend ( [ root . item ] ) [EOL] result . extend ( BinTree . preorder ( root . left ) ) [EOL] result . extend ( BinTree . preorder ( root . right ) ) [EOL] return result [EOL] [EOL] @ staticmethod def postorder ( root ) : [EOL] if not root : [EOL] return [ ] [EOL] [EOL] result = [ ] [EOL] result . extend ( BinTree . preorder ( root . left ) ) [EOL] result . extend ( BinTree . preorder ( root . right ) ) [EOL] result . extend ( [ root . item ] ) [EOL] return result [EOL] [EOL] @ staticmethod def height ( root ) : [EOL] if not root : [EOL] return - [number] [EOL] [EOL] return max ( BinTree . height ( root . left ) , BinTree . height ( root . right ) ) + [number] [EOL] [EOL] @ staticmethod def is_height_balanced ( root ) : [EOL] [docstring] [EOL] [comment] [EOL] if not root : [EOL] return True [EOL] [EOL] [comment] [EOL] return BinTree . is_height_balanced ( root . left ) and BinTree . is_height_balanced ( root . right ) and abs ( BinTree . height ( root . left ) - BinTree . height ( root . right ) ) <= [number] [EOL] [EOL] @ classmethod def reconstruct ( cls , inorder , preorder ) : [EOL] if len ( inorder ) == [number] or len ( preorder ) == [number] : [EOL] return [EOL] [EOL] root_item = preorder [ [number] ] [EOL] [EOL] root_idx_in_inorder = inorder . index ( root_item ) [EOL] left_inorder = inorder [ : root_idx_in_inorder ] [EOL] right_inorder = inorder [ root_idx_in_inorder + [number] : ] [EOL] [EOL] left_preorder = preorder [ [number] : root_idx_in_inorder + [number] ] [EOL] right_preorder = preorder [ root_idx_in_inorder + [number] : ] [EOL] [EOL] left_subtree = cls . reconstruct ( left_inorder , left_preorder ) [EOL] right_subtree = cls . reconstruct ( right_inorder , right_preorder ) [EOL] [EOL] return cls ( item = root_item , left = left_subtree , right = right_subtree ) [EOL] [EOL] @ classmethod def reconstruct_with_marker ( cls , preorder_with_marker ) : [EOL] def helper ( preorder_iter ) : [EOL] try : [EOL] subtree_key = next ( preorder_iter ) [EOL] if subtree_key == [string] : [EOL] return [EOL] [EOL] left = helper ( preorder_iter ) [EOL] right = helper ( preorder_iter ) [EOL] [EOL] return cls ( subtree_key , left = left , right = right ) [EOL] except StopIteration : [EOL] return [EOL] [EOL] return helper ( iter ( preorder_with_marker ) ) [EOL] [EOL] @ classmethod def reconstruct_from_postorder ( cls , po ) : [EOL] def helper ( postorder_iter ) : [EOL] try : [EOL] subtree_key = next ( postorder_iter ) [EOL] if subtree_key == [string] : [EOL] return [EOL] [EOL] right = helper ( postorder_iter ) [EOL] left = helper ( postorder_iter ) [EOL] [EOL] return cls ( subtree_key , left = left , right = right ) [EOL] except StopIteration : [EOL] return [EOL] [EOL] return helper ( iter ( reversed ( po ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] import hypothesis . strategies as st [EOL] from hypothesis import given [EOL] [EOL] from honorsclass import * [EOL] [EOL] [EOL] class TestHonorsClass ( unittest . TestCase ) : [EOL] @ given ( st . integers ( min_value = [number] ) , st . integers ( min_value = [number] ) ) def test_bin_gcd ( self , a , b ) : [EOL] result = bin_gcd ( a , b ) [EOL] self . assertEqual ( a % result , [number] ) [EOL] self . assertEqual ( b % result , [number] ) [EOL] self . assertEqual ( result , bin_gcd ( a , b % a ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , DefaultDict , Tuple , Dict , Any , Counter , List [EOL] import typing [EOL] import builtins [EOL] import collections [EOL] from collections import Counter , defaultdict [EOL] import time [EOL] [EOL] [EOL] def can_form_palindrome ( a ) : [EOL] c = Counter ( a ) [EOL] return sum ( v % [number] for v in c . values ( ) ) <= [number] [EOL] [EOL] [EOL] def is_letter_constructible ( letter_text , magazine_text ) : [EOL] return not Counter ( letter_text ) - Counter ( magazine_text ) [EOL] [EOL] [EOL] class LRUCache : [EOL] def __init__ ( self , size ) : [EOL] self . _table = { } [EOL] self . _size = size [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _table ) [EOL] [EOL] def size ( self ) : [EOL] return self . _size [EOL] [EOL] def _remove_lru ( self ) : [EOL] def mins ( table ) : [EOL] min_key , min_value , min_time = None , None , None [EOL] for k , v in table . items ( ) : [EOL] value , t = v [EOL] if not min_key or min_value > t : [EOL] min_key = k [EOL] min_value = value [EOL] min_time = t [EOL] return min_key , ( min_value , min_time ) [EOL] [EOL] min_key , _ = mins ( self . _table ) [EOL] del self . _table [ min_key ] [EOL] [EOL] def insert ( self , key , value , time = time . gmtime ( ) ) : [EOL] [comment] [EOL] if key in self . _table : [EOL] v , _ = self . _table [ key ] [EOL] self . _table [ key ] = ( v , time ) [EOL] return [EOL] [EOL] [comment] [EOL] if len ( self . _table ) == self . _size : [EOL] self . _remove_lru ( ) [EOL] [EOL] self . _table [ key ] = ( value , time ) [EOL] [EOL] def get ( self , key , time = time . gmtime ( ) ) : [EOL] if key in self . _table : [EOL] v , _ = self . _table [ key ] [EOL] self . _table [ key ] = ( v , time ) [EOL] return v [EOL] [EOL] def remove ( self , key ) : [EOL] del self . _table [ key ] [EOL] [EOL] [EOL] def lca ( a , b ) : [EOL] def path_to_root ( x ) : [EOL] curr = x [EOL] while curr : [EOL] yield curr [EOL] curr = curr . parent [EOL] [EOL] a_path = path_to_root ( a ) [EOL] b_path = path_to_root ( b ) [EOL] [EOL] bset = set ( b_path ) [EOL] for x in a_path : [EOL] if x in bset : [EOL] return x [EOL] [EOL] [EOL] def nearest_repeated ( s ) : [EOL] indices_by_entry = defaultdict ( list ) [EOL] for i , entry in enumerate ( s ) : [EOL] indices_by_entry [ entry ] . append ( i ) [EOL] [EOL] h = { } [EOL] for entry , ind in indices_by_entry . items ( ) : [EOL] if len ( ind ) > [number] : [EOL] h [ entry ] = min ( [ ind [ i ] - ind [ i - [number] ] for i in range ( [number] , len ( ind ) ) ] ) [EOL] [EOL] return min ( h . values ( ) ) [EOL] [EOL] [EOL] def smallest_cover ( s , query ) : [EOL] def list_contains ( subarray , keywords ) : [EOL] sub_counts = Counter ( subarray ) [EOL] keywords_counts = Counter ( keywords ) [EOL] return sub_counts & keywords_counts == keywords_counts [EOL] [EOL] if not list_contains ( s , query ) : [EOL] return [EOL] [EOL] k , j = min ( [ ( i , j ) for i in range ( len ( s ) ) for j in range ( i + [number] , len ( s ) + [number] ) if list_contains ( s [ i : j ] , query ) ] , key = lambda x : len ( s [ x [ [number] ] : x [ [number] ] ] ) ) [EOL] return k , j - [number] [EOL] [EOL] [EOL] def smallest_cover_lin ( s , query ) : [EOL] def counter_contains ( bigger , smaller ) : [EOL] return bigger & smaller == smaller [EOL] [EOL] if not counter_contains ( Counter ( s ) , Counter ( query ) ) : [EOL] return [EOL] [EOL] query_counts = Counter ( query ) [EOL] current_counts = Counter ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] j = len ( [ current_counts . update ( [ s [ j ] ] ) for j in range ( len ( s ) ) if not counter_contains ( current_counts , query_counts ) ] ) [EOL] [EOL] [comment] [EOL] i = [number] [EOL] contains_indices = [ ( i , j ) ] [EOL] while i < len ( s ) and j < len ( s ) + [number] : [EOL] if counter_contains ( current_counts , query_counts ) : [EOL] contains_indices . append ( ( i , j ) ) [EOL] current_counts [ s [ i ] ] -= [number] [EOL] i += [number] [EOL] elif j < len ( s ) : [EOL] current_counts . update ( s [ j ] ) [EOL] j += [number] [EOL] else : [EOL] j += [number] [EOL] [EOL] min_i , min_j = min ( contains_indices , key = lambda x : x [ [number] ] - x [ [number] ] ) [EOL] return min_i , min_j - [number] [EOL] [EOL] [EOL] def len_longest_contained_interval ( s ) : [EOL] if len ( s ) <= [number] : [EOL] return [EOL] elif len ( s ) == [number] and s [ [number] ] == s [ [number] ] - [number] : [EOL] return [number] [EOL] elif len ( s ) == [number] and s [ [number] ] != s [ [number] ] - [number] : [EOL] return [EOL] [EOL] s . sort ( ) [EOL] [EOL] results = [ [number] ] [EOL] [comment] [EOL] if s [ [number] ] == s [ [number] ] + [number] : [EOL] results . append ( [number] ) [EOL] else : [EOL] results . append ( [number] ) [EOL] [EOL] [comment] [EOL] for i , x in enumerate ( s ) : [EOL] if i < [number] : [EOL] continue [EOL] [comment] [EOL] if x == s [ i - [number] ] + [number] : [EOL] results . append ( results [ i - [number] ] + [number] ) [EOL] else : [EOL] results . append ( [number] ) [EOL] [EOL] return max ( results ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def halve ( x ) : [EOL] return x >> [number] [EOL] [EOL] [EOL] def is_odd ( x ) : [EOL] return x & [number] == [number] [EOL] [EOL] [EOL] def is_even ( x ) : [EOL] return not is_odd ( x ) [EOL] [EOL] [EOL] def bin_gcd ( u , v ) : [EOL] if u == [number] : [EOL] return v [EOL] [EOL] if v == [number] : [EOL] return u [EOL] [EOL] if is_even ( u ) and is_even ( v ) : [EOL] return [number] * bin_gcd ( halve ( u ) , halve ( v ) ) [EOL] [EOL] if is_even ( u ) and is_odd ( v ) : [EOL] return bin_gcd ( halve ( u ) , v ) [EOL] [EOL] if is_odd ( u ) and is_even ( v ) : [EOL] return bin_gcd ( u , halve ( v ) ) [EOL] [EOL] [comment] [EOL] if u >= v : [EOL] return bin_gcd ( halve ( u - v ) , v ) [EOL] else : [EOL] return bin_gcd ( u , halve ( v - u ) ) [EOL]	0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] import hypothesis . strategies as st [EOL] from hypothesis import given [EOL] [EOL] from hashtablesepi import * [EOL] [EOL] from bintreesepi import BinTree [EOL] [EOL] [EOL] class TestBinTreesEpi ( unittest . TestCase ) : [EOL] [EOL] @ unittest . skip ( [string] ) def test_is_bst ( self ) : [EOL] [docstring] [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Tuple , Union [EOL] import typing [EOL] import time [EOL] import builtins [EOL] import hashtablesepi [EOL] import bintreesepi [EOL] import unittest [EOL] [EOL] import hypothesis . strategies as st [EOL] from hypothesis import given [EOL] [EOL] from hashtablesepi import * [EOL] [EOL] from bintreesepi import BinTree [EOL] [EOL] [EOL] class TestHashTablesEpi ( unittest . TestCase ) : [EOL] [EOL] [comment] [EOL] @ given ( st . text ( ) ) def test_can_form_palindrome ( self , a ) : [EOL] expected_cond = sum ( v % [number] for v in Counter ( a ) . values ( ) ) <= [number] [EOL] result = can_form_palindrome ( a ) [EOL] self . assertEqual ( result , expected_cond ) [EOL] [EOL] [comment] [EOL] @ given ( letter_text = st . text ( ) , magazine_text = st . text ( ) ) def test_is_letter_constructible ( self , letter_text , magazine_text ) : [EOL] expected_cond = not Counter ( letter_text ) - Counter ( magazine_text ) [EOL] result = is_letter_constructible ( letter_text , magazine_text ) [EOL] self . assertEqual ( result , expected_cond ) [EOL] [EOL] [comment] [EOL] def test_lru_cache ( self ) : [EOL] now = time . gmtime ( [number] ) [EOL] [EOL] c = LRUCache ( [number] ) [EOL] c . insert ( [string] , [number] , now ) [EOL] c . insert ( [string] , [number] , time . gmtime ( [number] + [number] ) ) [EOL] self . assertEqual ( len ( c ) , [number] ) [EOL] self . assertEqual ( c . get ( [string] ) , None ) [EOL] self . assertEqual ( c . get ( [string] ) , [number] ) [EOL] [EOL] c . insert ( [string] , [number] , time . gmtime ( [number] + [number] ) ) [EOL] self . assertEqual ( c . get ( [string] ) , [number] ) [EOL] [EOL] c . remove ( [string] ) [EOL] self . assertEqual ( c . get ( [string] ) , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_lca ( self ) : [EOL] [docstring] [EOL] atree = BinTree ( ) [EOL] btree = BinTree ( parent = atree ) [EOL] ctree = BinTree ( parent = atree ) [EOL] dtree = BinTree ( parent = ctree ) [EOL] etree = BinTree ( parent = ctree ) [EOL] ftree = BinTree ( parent = etree ) [EOL] [EOL] self . assertEqual ( lca ( dtree , etree ) , ctree ) [EOL] self . assertEqual ( lca ( dtree , ftree ) , ctree ) [EOL] self . assertEqual ( lca ( etree , ftree ) , etree ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_nearest_repeated ( self ) : [EOL] s = [string] . split ( ) [EOL] self . assertEqual ( nearest_repeated ( s ) , [number] ) [EOL] [EOL] [comment] [EOL] def test_smallest_cover ( self ) : [EOL] s = [string] . split ( ) [EOL] self . assertEqual ( smallest_cover ( s , set ( [string] . split ( ) ) ) , ( [number] , [number] ) , str ( s ) ) [EOL] self . assertEqual ( smallest_cover_lin ( s , set ( [string] . split ( ) ) ) , ( [number] , [number] ) , str ( s ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_len_longest_contained_interval ( self ) : [EOL] test_pairs = [ ( [ ] , None ) , ( [ [number] ] , None ) , ( [ [number] , [number] ] , None ) , ( [ [number] , [number] , [number] , [number] ] , [number] ) , ( [ [number] , - [number] , [number] , [number] , [number] , [number] , [number] , [number] , - [number] , [number] , [number] ] , [number] ) ] [EOL] [EOL] for s , expected in test_pairs : [EOL] self . assertEqual ( len_longest_contained_interval ( s ) , expected , str ( s ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $time.struct_time$ 0 0 0 0 0 0 0 0 0 $hashtablesepi.LRUCache$ 0 0 0 0 0 0 $hashtablesepi.LRUCache$ 0 0 0 0 0 0 0 $time.struct_time$ 0 0 $hashtablesepi.LRUCache$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashtablesepi.LRUCache$ 0 0 0 0 0 0 0 0 0 $hashtablesepi.LRUCache$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashtablesepi.LRUCache$ 0 0 0 0 0 0 0 0 0 0 $hashtablesepi.LRUCache$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashtablesepi.LRUCache$ 0 0 0 0 0 0 0 0 0 0 $hashtablesepi.LRUCache$ 0 0 0 0 0 0 0 0 0 0 $hashtablesepi.LRUCache$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Tuple[typing.List[typing.Any],None],typing.Tuple[typing.List[builtins.int],None],typing.Tuple[typing.List[builtins.int],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Tuple[typing.List[typing.Any],None],typing.Tuple[typing.List[builtins.int],None],typing.Tuple[typing.List[builtins.int],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import bintreesepi [EOL] import unittest [EOL] [EOL] import hypothesis . strategies as st [EOL] from hypothesis import given [EOL] [EOL] from hashtablesepi import * [EOL] [EOL] from bintreesepi import BinTree [EOL] [EOL] [EOL] class TestBinTreesEpi ( unittest . TestCase ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_is_height_balanced ( self ) : [EOL] [docstring] [EOL] ftree = BinTree ( ) [EOL] etree = BinTree ( left = ftree ) [EOL] dtree = BinTree ( ) [EOL] ctree = BinTree ( left = etree , right = dtree ) [EOL] btree = BinTree ( ) [EOL] atree = BinTree ( left = ctree , right = btree ) [EOL] [EOL] self . assertEqual ( BinTree . is_height_balanced ( atree ) , False , [string] ) [EOL] self . assertEqual ( BinTree . is_height_balanced ( ctree ) , True , [string] ) [EOL] [EOL] [comment] [EOL] def test_reconstruct ( self ) : [EOL] a = BinTree ( item = [string] ) [EOL] f = BinTree ( item = [string] ) [EOL] e = BinTree ( item = [string] , left = a ) [EOL] b = BinTree ( item = [string] , left = f , right = e ) [EOL] [EOL] i = BinTree ( item = [string] ) [EOL] g = BinTree ( item = [string] , left = i ) [EOL] d = BinTree ( item = [string] , right = g ) [EOL] c = BinTree ( item = [string] , right = d ) [EOL] [EOL] h = BinTree ( item = [string] , left = b , right = c ) [EOL] [EOL] expected_inorder , expected_preorder = [string] , [string] [EOL] [EOL] reconstructed = BinTree . reconstruct ( inorder = expected_inorder , preorder = expected_preorder ) [EOL] [EOL] self . assertEqual ( [string] . join ( BinTree . inorder ( reconstructed ) ) , expected_inorder ) [EOL] self . assertEqual ( [string] . join ( BinTree . preorder ( reconstructed ) ) , expected_preorder ) [EOL] [EOL] [comment] [EOL] def test_reconstruct_with_marker ( self ) : [EOL] [docstring] [EOL] [EOL] expected_inorder , expected_preorder = [string] , [string] [EOL] preorder_blueprint = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] reconstructed = BinTree . reconstruct_with_marker ( preorder_blueprint ) [EOL] [EOL] self . assertEqual ( [string] . join ( BinTree . inorder ( reconstructed ) ) , expected_inorder ) [EOL] self . assertEqual ( [string] . join ( BinTree . preorder ( reconstructed ) ) , expected_preorder ) [EOL] [EOL] [comment] [EOL] @ unittest . skip ( [string] ) def test_reconstruct_from_postorder ( self ) : [EOL] [docstring] [EOL] [EOL] expected_inorder , expected_preorder , expected_postorder = [string] , [string] , [string] [EOL] postorder_blueprint = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] reconstructed = BinTree . reconstruct_from_postorder ( postorder_blueprint ) [EOL] [EOL] self . assertEqual ( [string] . join ( BinTree . inorder ( reconstructed ) ) , expected_inorder ) [EOL] self . assertEqual ( [string] . join ( BinTree . preorder ( reconstructed ) ) , expected_preorder ) [EOL] self . assertEqual ( [string] . join ( BinTree . postorder ( reconstructed ) ) , expected_postorder ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 $bintreesepi.BinTree$ 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 $bintreesepi.BinTree$ 0 0 0 $bintreesepi.BinTree$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0