[comment] [EOL] from typing import Tuple , Set , List , Any , Dict , Union [EOL] import pathlib [EOL] import typing [EOL] import pyvideo_scrape [EOL] import datetime [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import copy [EOL] import datetime [EOL] import json [EOL] import os [EOL] import pathlib [EOL] import re [EOL] import sys [EOL] [EOL] import sh [EOL] import slugify [EOL] import yaml [EOL] import youtube_dl [EOL] [EOL] from loguru import logger [EOL] [EOL] JSON_FORMAT_KWARGS = { [string] : [number] , [string] : ( [string] , [string] ) , [string] : True , } [EOL] [EOL] [EOL] def load_events ( fich ) : [EOL] [docstring] [EOL] with fich . open ( ) as fd_conf : [EOL] yaml_text = fd_conf . read ( ) [EOL] conf = yaml . safe_load ( yaml_text ) [EOL] return yaml_text , conf [EOL] [EOL] [EOL] def save_file ( path , text ) : [EOL] [docstring] [EOL] with path . open ( mode = [string] ) as f_stream : [EOL] f_stream . write ( text ) [EOL] [EOL] [EOL] def youtube_dl_version ( ) : [EOL] [docstring] [EOL] import pkg_resources [EOL] [EOL] return pkg_resources . get_distribution ( [string] ) . version [EOL] [EOL] [EOL] class Event : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , event_data , repository_path ) : [EOL] self . videos = [ ] [EOL] self . youtube_videos = [ ] [EOL] self . file_videos = [ ] [EOL] self . repository_path = repository_path [EOL] [EOL] self . branch = event_data [ [string] ] [EOL] self . event_dir = self . repository_path / event_data [ [string] ] [EOL] self . video_dir = self . event_dir / [string] [EOL] [EOL] self . title = event_data [ [string] ] [EOL] [EOL] for mandatory_field in [ [string] , [string] , [string] , [string] ] : [EOL] if mandatory_field in event_data and event_data [ mandatory_field ] : [EOL] pass [EOL] else : [EOL] logger . error ( [string] , mandatory_field , self . title ) [EOL] raise ValueError ( [string] . format ( mandatory_field ) ) [EOL] self . issue = event_data [ [string] ] [EOL] [EOL] if isinstance ( event_data [ [string] ] , str ) : [EOL] self . youtube_lists = [ event_data [ [string] ] ] [EOL] elif isinstance ( event_data [ [string] ] , list ) : [EOL] self . youtube_lists = event_data [ [string] ] [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] self . related_urls = event_data . get ( [string] , [ ] ) [EOL] self . language = event_data . get ( [string] , None ) [EOL] self . tags = event_data . get ( [string] , [ ] ) [EOL] if not self . tags : [EOL] self . tags = [ ] [EOL] [EOL] if [string] in event_data and event_data [ [string] ] : [EOL] self . know_date = True [EOL] self . date_begin = event_data [ [string] ] [ [string] ] [EOL] self . date_end = event_data [ [string] ] . get ( [string] , self . date_begin ) [EOL] self . date_default = event_data [ [string] ] . get ( [string] , self . date_begin ) [EOL] else : [EOL] self . know_date = False [EOL] self . minimal_download = event_data . get ( [string] , False ) [EOL] if self . minimal_download : [EOL] self . branch = [string] . format ( self . branch ) [EOL] [EOL] self . overwrite , self . add_new_files , self . wipe = False , False , False [EOL] self . overwrite_fields = [ ] [EOL] if [string] in event_data and event_data [ [string] ] : [EOL] overwrite = event_data [ [string] ] [EOL] self . overwrite = True [EOL] if [string] in overwrite and overwrite [ [string] ] : [EOL] self . wipe = True [EOL] else : [EOL] if [string] in overwrite and overwrite [ [string] ] : [EOL] self . add_new_files = True [EOL] if ( [string] in overwrite [EOL] and overwrite [ [string] ] ) : [EOL] self . overwrite_fields = overwrite [ [string] ] [EOL] [EOL] def create_branch ( self ) : [EOL] [docstring] [EOL] os . chdir ( str ( self . repository_path ) ) [EOL] sh . git . checkout ( [string] ) [EOL] sh . git . checkout ( [string] , self . branch ) [EOL] logger . debug ( [string] , self . branch ) [EOL] [EOL] def create_dirs ( self ) : [EOL] [docstring] [EOL] for new_directory in [ self . event_dir , self . event_dir / [string] ] : [EOL] new_directory . mkdir ( exist_ok = self . overwrite ) [EOL] logger . debug ( [string] , new_directory ) [EOL] [EOL] def create_category ( self ) : [comment] [EOL] [docstring] [EOL] category_file_path = self . event_dir / [string] [EOL] category_data = { [string] : self . title , } [EOL] category_data_text = json . dumps ( category_data , ** JSON_FORMAT_KWARGS ) + [string] [EOL] save_file ( category_file_path , category_data_text ) [EOL] logger . debug ( [string] , category_file_path ) [EOL] [EOL] def download_video_data ( self ) : [EOL] [docstring] [EOL] [EOL] def scrape_url ( url ) : [EOL] [docstring] [EOL] ydl_opts = { [string] : True , } [EOL] [EOL] ydl = youtube_dl . YoutubeDL ( ydl_opts ) [EOL] [EOL] with ydl : [EOL] result_ydl = ydl . extract_info ( url , download = False ) [EOL] [EOL] logger . debug ( [string] , url ) [EOL] if [string] in result_ydl : [EOL] [comment] [EOL] return result_ydl [ [string] ] [EOL] [comment] [EOL] return [ result_ydl ] [EOL] [EOL] youtube_list = sum ( ( scrape_url ( url ) for url in self . youtube_lists ) , [ ] ) [EOL] for youtube_video_data in youtube_list : [EOL] if youtube_video_data : [comment] [EOL] self . youtube_videos . append ( Video . from_youtube ( video_data = youtube_video_data , event = self ) ) [EOL] else : [EOL] logger . warning ( [string] ) [EOL] [EOL] def load_video_data ( self ) : [EOL] [docstring] [EOL] self . file_videos = [ Video . from_file ( path , self ) for path in self . video_dir . glob ( [string] ) ] [EOL] [EOL] def merge_video_data ( self ) : [EOL] [docstring] [EOL] if self . overwrite : [EOL] if self . wipe : [EOL] self . videos = self . youtube_videos [EOL] elif self . add_new_files or self . overwrite_fields : [EOL] old_videos = { video . filename : video for video in self . file_videos } [EOL] old_videos_url = { video . metadata [ [string] ] [ [number] ] [ [string] ] : video for video in self . file_videos } [EOL] new_videos = { } [EOL] for video in self . youtube_videos : [EOL] new_video_url = video . metadata [ [string] ] [ [number] ] [ [string] ] [EOL] if new_video_url in old_videos_url : [EOL] new_video_filename = old_videos_url [ new_video_url ] . filename [EOL] else : [EOL] new_video_filename = video . filename [EOL] new_videos [ new_video_filename ] = video [EOL] [EOL] if self . overwrite_fields : [EOL] forgotten = set ( old_videos ) - set ( new_videos ) [EOL] for name in forgotten : [EOL] logger . warning ( [string] , old_videos [ name ] . filename , old_videos [ name ] . metadata [ [string] ] [ [number] ] [ [string] ] , ) [EOL] [EOL] changes = set ( new_videos ) . intersection ( set ( old_videos ) ) [EOL] for path in changes : [EOL] merged_video = old_videos [ path ] . merge ( new_videos [ path ] , self . overwrite_fields ) [EOL] self . videos . append ( merged_video ) [EOL] else : [EOL] self . videos = self . file_videos [EOL] if self . add_new_files : [EOL] adds = set ( new_videos ) - set ( old_videos ) [EOL] self . videos . extend ( [ new_videos [ path ] for path in adds ] ) [EOL] else : [comment] [EOL] self . videos = self . youtube_videos [EOL] [EOL] def save_video_data ( self ) : [EOL] [docstring] [EOL] if self . overwrite : [EOL] [comment] [EOL] for path in self . video_dir . glob ( [string] ) : [EOL] path . unlink ( ) [EOL] for video in self . videos : [EOL] video . save ( ) [EOL] [EOL] def create_commit ( self , event_data_yaml ) : [EOL] [docstring] [EOL] os . chdir ( str ( self . repository_path ) ) [EOL] sh . git . checkout ( self . branch ) [EOL] sh . git . add ( self . event_dir ) [EOL] message_body = ( [string] . format ( event_data_yaml ) + [string] + [string] ) [EOL] if self . minimal_download : [EOL] message = ( [string] + [string] . format ( self . title , self . issue ) + [string] + [string] + [string] + [string] + message_body ) [EOL] sh . git . commit ( [string] , message ) [EOL] sh . git . push ( [string] , [string] , self . branch ) [EOL] [comment] [EOL] sh . git . checkout ( [string] ) [EOL] else : [EOL] message = ( [string] . format ( self . branch , self . issue ) + message_body ) [EOL] sh . git . commit ( [string] , message ) [EOL] sh . git . checkout ( [string] ) [EOL] logger . debug ( [string] , self . branch ) [EOL] [EOL] [EOL] class Video : [EOL] [docstring] [EOL] [EOL] @ staticmethod def __calculate_title ( video_data ) : [EOL] [docstring] [EOL] title = [string] [EOL] if [string] in video_data . keys ( ) : [EOL] title = video_data [ [string] ] [EOL] elif [string] in video_data . keys ( ) : [EOL] title = video_data [ [string] ] [EOL] elif [string] in video_data . keys ( ) : [EOL] title = video_data [ [string] ] [EOL] return title [EOL] [EOL] def __calculate_slug ( self ) : [EOL] [docstring] [EOL] [EOL] return slugify . slugify ( self . metadata [ [string] ] ) [EOL] [EOL] def __calculate_date_recorded ( self , upload_date_str ) : [EOL] [docstring] [EOL] [EOL] upload_date = datetime . date ( int ( upload_date_str [ [number] : [number] ] ) , int ( upload_date_str [ [number] : [number] ] ) , int ( upload_date_str [ [number] : [number] ] ) ) [EOL] if self . event . know_date : [EOL] if not ( self . event . date_begin <= upload_date <= self . event . date_end ) : [EOL] return self . event . date_default . isoformat ( ) [EOL] [EOL] return upload_date . isoformat ( ) [EOL] [EOL] def __init__ ( self , event ) : [EOL] self . event = event [EOL] self . filename = None [EOL] self . metadata = { } [EOL] [EOL] @ classmethod def from_file ( cls , path , event ) : [EOL] [docstring] [EOL] self = cls ( event ) [EOL] [EOL] self . filename = path . stem [comment] [EOL] [EOL] try : [EOL] with path . open ( ) as f_path : [EOL] self . metadata = json . load ( f_path ) [EOL] except ValueError : [EOL] print ( [string] . format ( path ) ) [EOL] raise [EOL] [EOL] return self [EOL] [EOL] @ classmethod def from_youtube ( cls , video_data , event ) : [EOL] [docstring] [EOL] self = cls ( event ) [EOL] [EOL] metadata = self . metadata [EOL] [EOL] metadata [ [string] ] = self . __calculate_title ( video_data ) [EOL] self . filename = self . __calculate_slug ( ) [EOL] metadata [ [string] ] = [ [string] ] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] metadata [ [string] ] = video_data [ [string] ] [EOL] metadata [ [string] ] = [ { [string] : [string] , [string] : video_data [ [string] ] } ] [EOL] metadata [ [string] ] = self . __calculate_date_recorded ( video_data [ [string] ] ) [EOL] [EOL] [comment] [EOL] metadata [ [string] ] = video_data [ [string] ] [EOL] metadata [ [string] ] = video_data [ [string] ] [comment] [EOL] metadata [ [string] ] = video_data [ [string] ] [ [number] ] . get ( [string] , event . language ) [EOL] if not metadata [ [string] ] : [EOL] metadata [ [string] ] = event . language [EOL] metadata [ [string] ] = copy . deepcopy ( event . related_urls ) [EOL] [EOL] if event . minimal_download : [EOL] metadata [ [string] ] = [ ] [EOL] metadata [ [string] ] = event . tags [EOL] metadata [ [string] ] = [string] [EOL] else : [EOL] metadata [ [string] ] = sorted ( set ( video_data [ [string] ] ) . union ( set ( event . tags ) ) ) [EOL] metadata [ [string] ] = video_data [ [string] ] [EOL] description_urls = list ( set ( re . findall ( [string] , video_data [ [string] ] ) ) ) [EOL] for url in description_urls : [EOL] metadata [ [string] ] . append ( { [string] : url , [string] : url } ) [EOL] [EOL] return self [EOL] [EOL] def merge ( self , new_video , fields ) : [EOL] [docstring] [EOL] merged_video = Video ( self . event ) [EOL] merged_video . filename = self . filename [EOL] for field in self . metadata : [EOL] if field in set ( fields ) : [EOL] merged_video . metadata [ field ] = new_video . metadata . get ( field ) [EOL] else : [EOL] merged_video . metadata [ field ] = self . metadata . get ( field ) [EOL] return merged_video [EOL] [EOL] def save ( self ) : [EOL] [docstring] [EOL] path = self . event . video_dir / [string] . format ( self . filename ) [EOL] if path . exists ( ) : [EOL] duplicate_num = [number] [EOL] new_path = path [EOL] while new_path . exists ( ) : [EOL] duplicate_num += [number] [EOL] new_path = path . parent / ( path . stem + [string] . format ( duplicate_num , path . suffix ) ) [EOL] logger . debug ( [string] , path ) [EOL] path = new_path [EOL] [EOL] data_text = json . dumps ( self . metadata , ** JSON_FORMAT_KWARGS ) + [string] [EOL] save_file ( path , data_text ) [EOL] logger . debug ( [string] , path ) [EOL] [EOL] [EOL] @ logger . catch def main ( ) : [EOL] [docstring] [EOL] [EOL] logger . add ( sys . stderr , format = [string] , filter = [string] , level = [string] ) [EOL] [EOL] time_init = datetime . datetime . now ( ) [EOL] logger . debug ( [string] , time_init ) [EOL] logger . debug ( [string] , youtube_dl_version ( ) ) [EOL] [EOL] cwd = pathlib . Path . cwd ( ) [EOL] [EOL] events_file = cwd / [string] [EOL] event_data_yaml , events_data = load_events ( events_file ) [EOL] [EOL] pyvideo_repo = pathlib . PosixPath ( events_data [ [string] ] ) . expanduser ( ) . resolve ( ) [EOL] events = [ Event ( event_data , repository_path = pyvideo_repo ) for event_data in events_data [ [string] ] ] [EOL] for event in events : [EOL] try : [EOL] event . create_branch ( ) [EOL] event . create_dirs ( ) [EOL] event . create_category ( ) [EOL] except ( sh . ErrorReturnCode_128 , FileExistsError ) as exc : [EOL] logger . warning ( [string] , event . branch ) [EOL] logger . debug ( exc . args [ [number] ] ) [EOL] continue [EOL] event . download_video_data ( ) [EOL] event . load_video_data ( ) [EOL] event . merge_video_data ( ) [EOL] event . save_video_data ( ) [EOL] event . create_commit ( event_data_yaml ) [EOL] [EOL] time_end = datetime . datetime . now ( ) [EOL] time_delta = str ( time_end - time_init ) [EOL] logger . debug ( [string] , time_init ) [EOL] logger . debug ( [string] , time_end ) [EOL] logger . debug ( [string] , time_delta ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyvideo_scrape.Video$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0