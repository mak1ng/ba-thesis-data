from typing import Any , Type [EOL] import typing [EOL] import project [EOL] import os [EOL] [EOL] import sdl2 [EOL] import sdl2 . ext [EOL] [EOL] from gamepart import Game [EOL] [EOL] from context import MyContext [EOL] [EOL] [EOL] ROOT = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] RESOURCES = os . path . join ( ROOT , [string] ) [EOL] [EOL] [EOL] class MyGame ( Game ) : [EOL] context_class = MyContext [EOL] [EOL] def get_config ( self ) : [EOL] config = super ( ) . get_config ( ) [EOL] config [ [string] ] = [number] [EOL] [comment] [EOL] return config [EOL] [EOL] def init_font_manager ( self ) : [EOL] self . font_manager = sdl2 . ext . FontManager ( os . path . join ( RESOURCES , [string] ) ) [EOL] [EOL] def init_heavy ( self ) : [EOL] self . font_manager . add ( os . path . join ( RESOURCES , [string] ) , [string] ) [EOL] [EOL] def init_scenes ( self ) : [EOL] import scenes [EOL] [EOL] self . add_scene ( [string] , scenes . TestScene ) [EOL] self . add_scene ( [string] , scenes . BallScene ) [EOL] super ( ) . init_scenes ( ) [EOL] self . queue_scene_switch ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[project.game.MyGame]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import project [EOL] from gamepart . context import Context [EOL] [EOL] [EOL] class MyContext ( Context ) : [EOL] console = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import sys [EOL] import os [EOL] [EOL] [EOL] def setup ( ) : [EOL] [comment] [EOL] logging . basicConfig ( level = int ( os . environ . get ( [string] , [string] ) ) , format = [string] , ) [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] project = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) [EOL] os . environ . setdefault ( [string] , os . path . join ( project , [string] ) ) [EOL] import sdl2 [EOL] [EOL] logging . info ( [string] , sys . version ) [EOL] logging . info ( [string] , sdl2 . __version__ ) [EOL] [EOL] [EOL] def main ( ) : [EOL] setup ( ) [EOL] from game import MyGame [EOL] [EOL] game = MyGame ( ) [EOL] game . main_loop ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import IPython [EOL] [EOL] from main import setup [EOL] [EOL] [EOL] def main ( ) : [EOL] setup ( ) [EOL] IPython . start_ipython ( argv = [ ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from . game import Game [EOL] from . scene import Scene , ExitScene , SimpleScene [EOL] [EOL] [EOL] version_info = ( [number] , [number] , [number] , [string] ) [EOL] __version__ = [string] % version_info [EOL] __author__ = [string] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.str]$ 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
class Context : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , last_scene ) : [EOL] self . last_scene = last_scene [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] import ctypes [EOL] [EOL] import sdl2 [EOL] [EOL] [EOL] def get_mouse_state ( ) : [EOL] [docstring] [EOL] [EOL] x , y = ctypes . c_int ( [number] ) , ctypes . c_int ( [number] ) [EOL] button_state = sdl2 . mouse . SDL_GetMouseState ( ctypes . byref ( x ) , ctypes . byref ( y ) ) [EOL] return x . value , y . value , button_state [EOL] [EOL] [EOL] def get_clipboard_text ( encoding = [string] ) : [EOL] [docstring] [EOL] [EOL] data = sdl2 . SDL_GetClipboardText ( ) [EOL] try : [EOL] return data . decode ( encoding ) [EOL] except UnicodeDecodeError : [EOL] return [string] [EOL] finally : [EOL] sdl2 . SDL_free ( data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Literal , Any , Tuple , Type [EOL] import builtins [EOL] import sdl2 [EOL] import typing_extensions [EOL] import time [EOL] import context [EOL] import logging [EOL] import render [EOL] import typing [EOL] import project [EOL] import collections [EOL] import logging [EOL] import typing [EOL] import time [EOL] import sys [EOL] import gc [EOL] [EOL] import sdl2 [EOL] import sdl2 . ext [EOL] [EOL] from . render import GfxRenderer [EOL] from . context import Context [EOL] from . time import FPSCounter , TimeFeeder [EOL] from . utils import get_mouse_state [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Game : [EOL] [docstring] [EOL] [EOL] context_class = Context [EOL] [EOL] def __init__ ( self ) : [EOL] logger . debug ( [string] ) [EOL] self . init ( ) [EOL] [EOL] self . config = self . get_config ( ) [EOL] self . width = self . config [ [string] ] [EOL] self . height = self . config [ [string] ] [EOL] self . max_fps = self . config [ [string] ] [EOL] self . show_fps = self . config [ [string] ] [EOL] self . caption = self . config [ [string] ] [EOL] self . fullscreen = self . config [ [string] ] [EOL] self . time_step = self . config [ [string] ] [EOL] self . time_speed = self . config [ [string] ] [EOL] self . time_max_iter = self . config [ [string] ] [EOL] [EOL] self . window = None [EOL] self . renderer = None [EOL] self . sprite_factory = None [EOL] self . font_manager = None [EOL] self . frame_num = [number] [EOL] self . init_display ( ) [EOL] self . init_renderer ( ) [EOL] self . init_sprite_factory ( ) [EOL] self . init_font_manager ( ) [EOL] self . display_loading_screen ( ) [EOL] self . init_heavy ( ) [EOL] [EOL] self . fps_counter = FPSCounter ( ) [EOL] self . feeder = TimeFeeder ( self . time_step , self . time_speed ) [EOL] self . key_state = sdl2 . SDL_GetKeyboardState ( None ) [EOL] self . mouse_state = get_mouse_state ( ) [EOL] self . running = False [EOL] self . scenes = { } [EOL] self . scene_switch_queue = collections . deque ( ) [EOL] self . active_scene = self . add_exit_scene ( ) [EOL] self . context = self . get_initial_context ( ) [EOL] self . logger . debug ( [string] ) [EOL] self . init_scenes ( ) [EOL] self . fps_counter . clear ( ) [EOL] self . time_time = time . monotonic ( ) [EOL] self . logger . info ( [string] ) [EOL] gc . collect ( ) [EOL] [EOL] @ property def logger ( self ) : [EOL] return logger [EOL] [EOL] def init ( self ) : [EOL] sdl2 . ext . init ( ) [EOL] [EOL] def init_display ( self ) : [EOL] self . logger . debug ( [string] ) [EOL] flags = None [EOL] if self . fullscreen : [EOL] flags = sdl2 . SDL_WINDOW_FULLSCREEN [EOL] self . window = sdl2 . ext . Window ( self . caption , size = ( self . width , self . height ) , flags = flags ) [EOL] self . window . show ( ) [EOL] [EOL] def init_renderer ( self ) : [EOL] self . logger . debug ( [string] ) [EOL] self . renderer = GfxRenderer ( self . window ) [EOL] self . renderer . blendmode = sdl2 . SDL_BLENDMODE_BLEND [EOL] self . renderer . clip = ( [number] , [number] , self . width , self . height ) [EOL] [EOL] def init_sprite_factory ( self ) : [EOL] self . logger . debug ( [string] ) [EOL] self . sprite_factory = sdl2 . ext . SpriteFactory ( renderer = self . renderer ) [EOL] [EOL] def init_font_manager ( self ) : [EOL] self . logger . warning ( [string] ) [EOL] [EOL] def init_scenes ( self ) : [EOL] for scene in self . scenes . values ( ) : [EOL] scene . init ( ) [EOL] self . active_scene . start ( self . context ) [EOL] [EOL] def display_loading_screen ( self ) : [EOL] if self . font_manager : [EOL] text = self . font_manager . render ( [string] , size = [number] ) [EOL] pos = ( int ( self . width / [number] - text . w / [number] ) , int ( self . height / [number] - text . h / [number] ) , text . w , text . h , ) [EOL] text = self . sprite_factory . from_surface ( text , True ) [EOL] self . renderer . copy ( text , None , pos ) [EOL] self . renderer . present ( ) [EOL] [EOL] def display_fps ( self ) : [EOL] fps = int ( self . fps_counter . get_fps ( ) ) [EOL] logger . debug ( f" [string] { fps }" ) [EOL] if self . font_manager : [EOL] text = self . font_manager . render ( f"{ fps }" , size = [number] , color = ( [number] , [number] , [number] ) , bg_color = ( [number] , [number] , [number] ) ) [EOL] pos = ( [number] , [number] , text . w , text . h ) [EOL] text = self . sprite_factory . from_surface ( text , True ) [EOL] self . renderer . copy ( text , None , pos ) [EOL] [EOL] def frame ( self ) : [EOL] self . mouse_state = get_mouse_state ( ) [EOL] self . frame_num += [number] [EOL] if self . scene_switch_queue : [EOL] self . switch_scene ( self . scene_switch_queue . popleft ( ) ) [EOL] for event in sdl2 . ext . get_events ( ) : [EOL] logger . debug ( [string] , event . common . timestamp , event . type ) [EOL] self . active_scene . event ( event ) [EOL] self . tick ( ) [EOL] self . active_scene . frame ( ) [EOL] self . fps_counter . frame ( ) [EOL] if self . show_fps : [EOL] self . display_fps ( ) [EOL] self . fps_counter . target_fps ( self . max_fps ) [EOL] self . renderer . present ( ) [EOL] [EOL] def tick ( self ) : [EOL] new_time = time . monotonic ( ) [EOL] for delta in self . feeder . tick ( new_time - self . time_time , self . time_max_iter ) : [EOL] self . active_scene . tick ( delta ) [EOL] self . time_time = new_time [EOL] [EOL] def add_scene ( self , name , scene , * args , ** kwargs ) : [EOL] logger . debug ( f" [string] { scene . __name__ } [string] { name !r} [string] " ) [EOL] if name in self . scenes : [EOL] raise ValueError ( f" [string] { name !r} [string] " ) [EOL] s = scene ( self , name , * args , ** kwargs ) [EOL] self . scenes [ name ] = s [EOL] return s [EOL] [EOL] def queue_scene_switch ( self , name ) : [EOL] logger . debug ( f" [string] { name !r}" ) [EOL] self . scene_switch_queue . append ( self . scenes [ name ] ) [EOL] [EOL] def switch_scene ( self , scene ) : [EOL] logger . info ( f" [string] { self . active_scene . name !r} [string] { scene . name !r}" ) [EOL] self . context = self . active_scene . stop ( ) [EOL] logger . debug ( [string] , self . context ) [EOL] self . context . last_scene = self . active_scene [EOL] self . active_scene = scene [EOL] self . active_scene . start ( self . context ) [EOL] [EOL] def stop ( self ) : [EOL] logger . debug ( [string] ) [EOL] for scene in self . scenes . values ( ) : [EOL] scene . uninit ( ) [EOL] sdl2 . ext . quit ( ) [EOL] [EOL] def main_loop ( self ) : [EOL] self . running = True [EOL] while self . running : [EOL] self . frame ( ) [EOL] self . stop ( ) [EOL] self . logger . info ( [string] ) [EOL] [EOL] def wrapped_main_loop ( self ) : [EOL] try : [EOL] self . main_loop ( ) [EOL] r = [number] [EOL] except : [comment] [EOL] logger . exception ( [string] ) [EOL] sdl2 . ext . quit ( ) [EOL] r = [number] [EOL] sys . exit ( r ) [comment] [EOL] [EOL] def get_config ( self ) : [EOL] return { [string] : [number] , [string] : [number] , [string] : self . __class__ . __name__ , [string] : [number] , [string] : False , [string] : False , [string] : [number] / [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] def get_initial_context ( self ) : [EOL] return self . context_class ( last_scene = self . active_scene ) [EOL] [EOL] def add_exit_scene ( self ) : [EOL] return self . add_scene ( [string] , ExitScene ) [EOL] [EOL] @ property def world_time ( self ) : [EOL] return self . feeder . world_time [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . caption !r} [string] " [EOL] [EOL] def init_heavy ( self ) : [EOL] [docstring] [EOL] [EOL] [EOL] from . scene import Scene , ExitScene [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[context.Context]$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $sdl2.ext.Window$ 0 0 0 0 0 $render.GfxRenderer$ 0 0 0 0 0 $sdl2.ext.SpriteFactory$ 0 0 0 0 0 $sdl2.ext.FontManager$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $time.FPSCounter$ 0 0 0 0 0 0 0 $time.TimeFeeder$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $typing.Dict[builtins.int,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[builtins.str,"Scene"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Scene"$ 0 0 0 0 0 0 0 0 0 $context.Context$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $time.FPSCounter$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $project.gamepart.render.GfxRenderer$ 0 0 0 0 0 0 0 0 0 0 $project.gamepart.render.GfxRenderer$ 0 0 0 0 0 0 0 0 0 $project.gamepart.render.GfxRenderer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[builtins.int,builtins.int,unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,unknown,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Type["Scene"]$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Type["Scene"]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Type["Scene"]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $"Scene"$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Scene"$ 0 0 0 0 0 0 0 $project.gamepart.context.Context$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $project.gamepart.context.Context$ 0 0 0 0 $project.gamepart.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 $"Scene"$ 0 0 0 0 0 0 0 0 0 $project.gamepart.context.Context$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Scene"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import SupportsInt , Callable , List , Sequence , Any , Tuple , Type [EOL] import builtins [EOL] import typing [EOL] import sdl2 [EOL] import ctypes [EOL] import typing [EOL] [EOL] import sdl2 [EOL] import sdl2 . sdlgfx [EOL] import sdl2 . ext [EOL] from sdl2 import Sint16 [EOL] [EOL] _t_circle = typing . Tuple [ typing . SupportsInt , typing . SupportsInt , typing . SupportsInt ] [EOL] _t_circles = typing . Sequence [ _t_circle ] [EOL] _t_anys = typing . Sequence [ typing . Sequence [ typing . SupportsInt ] ] [EOL] [EOL] [EOL] class GfxRenderer ( sdl2 . ext . Renderer ) : [EOL] [docstring] [EOL] [EOL] color = ... [EOL] blendmode = ... [EOL] [EOL] @ property def clip ( self ) : [EOL] rect = sdl2 . SDL_Rect ( ) [EOL] ret = sdl2 . SDL_RenderGetClipRect ( self . sdlrenderer , ctypes . byref ( rect ) ) [EOL] if ret : [EOL] raise sdl2 . ext . SDLError ( ) [EOL] return rect . x , rect . y , rect . w , rect . h [EOL] [EOL] @ clip . setter def clip ( self , value ) : [EOL] rect = sdl2 . SDL_Rect ( * value ) [EOL] ret = sdl2 . SDL_RenderSetClipRect ( self . sdlrenderer , ctypes . byref ( rect ) ) [EOL] if ret : [EOL] raise sdl2 . ext . SDLError ( ) [EOL] [EOL] def _shape ( self , shapes , color = ( [number] , [number] , [number] ) , * , gfx_fun = lambda : None , map_pos = int ) : [EOL] [docstring] [EOL] color = sdl2 . ext . convert_to_color ( color ) [EOL] blendmode = self . blendmode [EOL] for cords in shapes : [EOL] ret = gfx_fun ( self . sdlrenderer , * map ( map_pos , cords ) , color . r , color . g , color . b , color . a ) [EOL] if ret == - [number] : [EOL] raise sdl2 . ext . SDLError ( ) [EOL] self . blendmode = blendmode [EOL] [EOL] def circle ( self , circles , color = None ) : [EOL] return self . _shape ( circles , color , gfx_fun = sdl2 . sdlgfx . circleRGBA ) [EOL] [EOL] def filled_circle ( self , circles , color = None ) : [EOL] return self . _shape ( circles , color , gfx_fun = sdl2 . sdlgfx . filledCircleRGBA ) [EOL] [EOL] def aa_circle ( self , circles , color = None ) : [EOL] return self . _shape ( circles , color , gfx_fun = sdl2 . sdlgfx . aacircleRGBA ) [EOL] [EOL] def pixel ( self , pixels , color = None ) : [EOL] return self . _shape ( pixels , color , gfx_fun = sdl2 . sdlgfx . pixelRGBA ) [EOL] [EOL] def rounded_rectangle ( self , rects , color = None ) : [EOL] return self . _shape ( rects , color , gfx_fun = sdl2 . sdlgfx . roundedRectangleRGBA ) [EOL] [EOL] def rounded_box ( self , rects , color = None ) : [EOL] return self . _shape ( rects , color , gfx_fun = sdl2 . sdlgfx . roundedBoxRGBA ) [EOL] [EOL] def line ( self , lines , color = None ) : [EOL] return self . _shape ( lines , color , gfx_fun = sdl2 . sdlgfx . lineRGBA ) [EOL] [EOL] def aa_line ( self , lines , color = None ) : [EOL] return self . _shape ( lines , color , gfx_fun = sdl2 . sdlgfx . aalineRGBA ) [EOL] [EOL] def thick_line ( self , lines , color = None ) : [EOL] return self . _shape ( lines , color , gfx_fun = sdl2 . sdlgfx . thickLineRGBA ) [EOL] [EOL] def arc ( self , arcs , color = None ) : [EOL] return self . _shape ( arcs , color , gfx_fun = sdl2 . sdlgfx . arcRGBA ) [EOL] [EOL] def ellipse ( self , ellipses , color = None ) : [EOL] return self . _shape ( ellipses , color , gfx_fun = sdl2 . sdlgfx . ellipseRGBA ) [EOL] [EOL] def aa_ellipse ( self , ellipses , color = None ) : [EOL] return self . _shape ( ellipses , color , gfx_fun = sdl2 . sdlgfx . aaellipseRGBA ) [EOL] [EOL] def filled_ellipse ( self , ellipses , color = None ) : [EOL] return self . _shape ( ellipses , color , gfx_fun = sdl2 . sdlgfx . filledEllipseRGBA ) [EOL] [EOL] def pie ( self , pies , color = None ) : [EOL] return self . _shape ( pies , color , gfx_fun = sdl2 . sdlgfx . pieRGBA ) [EOL] [EOL] def filled_pie ( self , pies , color = None ) : [EOL] return self . _shape ( pies , color , gfx_fun = sdl2 . sdlgfx . pieRGBA ) [EOL] [EOL] def trigon ( self , trigons , color = None ) : [EOL] return self . _shape ( trigons , color , gfx_fun = sdl2 . sdlgfx . trigonRGBA ) [EOL] [EOL] def aa_trigon ( self , trigons , color = None ) : [EOL] return self . _shape ( trigons , color , gfx_fun = sdl2 . sdlgfx . aatrigonRGBA ) [EOL] [EOL] def filled_trigon ( self , trigons , color = None ) : [EOL] return self . _shape ( trigons , color , gfx_fun = sdl2 . sdlgfx . filledTrigonRGBA ) [EOL] [EOL] def _polygon ( self , polygons , color = None , * , gfx_fun = lambda : None ) : [EOL] [docstring] [EOL] polys = [ ] [EOL] for points in polygons : [EOL] num = len ( points ) [EOL] vx = ( Sint16 * num ) ( * [ int ( p [ [number] ] ) for p in points ] ) [EOL] vy = ( Sint16 * num ) ( * [ int ( p [ [number] ] ) for p in points ] ) [EOL] polys . append ( ( vx , vy , num ) ) [EOL] return self . _shape ( polys , color , gfx_fun = gfx_fun , map_pos = lambda x : x ) [EOL] [EOL] def polygon ( self , polygons , color = None ) : [EOL] return self . _polygon ( polygons , color , gfx_fun = sdl2 . sdlgfx . polygonRGBA ) [EOL] [EOL] def aa_polygon ( self , polygons , color = None ) : [EOL] return self . _polygon ( polygons , color , gfx_fun = sdl2 . sdlgfx . aapolygonRGBA ) [EOL] [EOL] def filled_polygon ( self , polygons , color = None ) : [EOL] return self . _polygon ( polygons , color , gfx_fun = sdl2 . sdlgfx . filledPolygonRGBA ) [EOL] [EOL] def bezier ( self , beziers , color = None ) : [EOL] [docstring] [EOL] curves = [ ] [EOL] for s , points in beziers : [EOL] num = len ( points ) [EOL] vx = ( Sint16 * num ) ( * [ int ( p [ [number] ] ) for p in points ] ) [EOL] vy = ( Sint16 * num ) ( * [ int ( p [ [number] ] ) for p in points ] ) [EOL] curves . append ( ( vx , vy , num , s ) ) [EOL] return self . _shape ( curves , color , gfx_fun = sdl2 . sdlgfx . bezierRGBA , map_pos = lambda x : x ) [EOL] [EOL] [comment] [EOL] [EOL] def fill_color ( self , color = None ) : [EOL] if color is not None : [EOL] tmp = self . color [EOL] self . color = color [EOL] ret = sdl2 . SDL_RenderFillRect ( self . sdlrenderer , None ) [EOL] if color is not None : [EOL] self . color = tmp [EOL] if ret == - [number] : [EOL] raise sdl2 . ext . SDLError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.ext.Color$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_t_anys$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $_t_anys$ 0 0 $typing.Any$ 0 $typing.Callable$ 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $_t_circles$ 0 0 0 0 0 0 0 0 0 0 0 0 $_t_circles$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_t_circles$ 0 0 0 0 0 0 0 0 0 0 0 0 $_t_circles$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_t_circles$ 0 0 0 0 0 0 0 0 0 0 0 0 $_t_circles$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import event [EOL] import sdl2 [EOL] import context [EOL] import render [EOL] import project [EOL] import gamepart [EOL] import sdl2 [EOL] import sdl2 . ext [EOL] [EOL] from gamepart . subsystem import SystemManager [EOL] from . context import Context [EOL] from . event import EventDispatcher , KeyEventDispatcher , MouseEventDispatcher [EOL] from . render import GfxRenderer [EOL] [EOL] [EOL] class Scene : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , game , name , * args , ** kwargs ) : [EOL] self . game = game [EOL] self . name = name [EOL] self . args = args [EOL] self . kwargs = kwargs [EOL] self . is_first_frame = True [EOL] self . context = Context ( None ) [EOL] [EOL] def init ( self ) : [EOL] [docstring] [EOL] [EOL] def start ( self , context ) : [EOL] [docstring] [EOL] self . context = context [EOL] [EOL] def tick ( self , delta ) : [EOL] [docstring] [EOL] [EOL] def event ( self , event ) : [EOL] [docstring] [EOL] [EOL] def frame ( self ) : [EOL] [docstring] [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] return self . context [EOL] [EOL] def uninit ( self ) : [EOL] [docstring] [EOL] self . context = Context ( None ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . game !r} [string] { self . name !r} [string] " [EOL] [EOL] [EOL] class ExitScene ( Scene ) : [EOL] [docstring] [EOL] [EOL] def frame ( self ) : [EOL] self . game . running = False [EOL] [EOL] [EOL] class SimpleScene ( Scene ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . system = None [EOL] self . event = None [comment] [EOL] self . key_event = None [EOL] self . mouse_event = None [EOL] [EOL] def init ( self ) : [EOL] super ( ) . init ( ) [EOL] self . system = SystemManager ( ) [EOL] self . event = EventDispatcher ( ) [EOL] self . key_event = KeyEventDispatcher ( ) [EOL] self . mouse_event = MouseEventDispatcher ( ) [EOL] self . event . on ( sdl2 . SDL_QUIT , self . on_exit ) [EOL] self . event . on ( sdl2 . SDL_KEYDOWN , self . key_event ) [EOL] self . event . on ( sdl2 . SDL_KEYUP , self . key_event ) [EOL] self . event . on ( sdl2 . SDL_MOUSEBUTTONDOWN , self . mouse_event ) [EOL] self . event . on ( sdl2 . SDL_MOUSEBUTTONUP , self . mouse_event ) [EOL] [EOL] def start ( self , context ) : [EOL] self . is_first_frame = True [EOL] return super ( ) . start ( context ) [EOL] [EOL] def frame ( self ) : [EOL] self . system . remove_queued_all ( ) [EOL] if self . is_first_frame : [EOL] self . first_frame ( self . game . renderer ) [EOL] self . is_first_frame = False [EOL] return self . every_frame ( self . game . renderer ) [EOL] [EOL] def uninit ( self ) : [EOL] self . event . clear ( ) [EOL] self . key_event . clear ( ) [EOL] self . mouse_event . clear ( ) [EOL] self . system . clear_all ( ) [EOL] self . system . clear ( ) [EOL] super ( ) . uninit ( ) [EOL] [EOL] def on_exit ( self , _ ) : [EOL] [docstring] [EOL] self . exit ( ) [EOL] [EOL] def exit ( self ) : [EOL] [docstring] [EOL] return self . game . queue_scene_switch ( [string] ) [EOL] [EOL] def first_frame ( self , renderer ) : [EOL] [docstring] [EOL] [EOL] def every_frame ( self , renderer ) : [EOL] [docstring] [EOL] [EOL] [EOL] from . game import Game [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Game"$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $"Game"$ 0 $"Game"$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $project.gamepart.context.Context$ 0 0 0 0 0 0 0 $project.gamepart.context.Context$ 0 $project.gamepart.context.Context$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gamepart.subsystem.SystemManager$ 0 0 0 0 0 $event.EventDispatcher$ 0 0 0 0 0 0 $event.KeyEventDispatcher$ 0 0 0 0 0 $event.MouseEventDispatcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $project.gamepart.event.EventDispatcher$ 0 0 0 0 0 0 0 $project.gamepart.event.KeyEventDispatcher$ 0 0 0 0 0 0 0 $project.gamepart.event.MouseEventDispatcher$ 0 0 0 0 0 0 0 $project.gamepart.event.EventDispatcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $project.gamepart.event.EventDispatcher$ 0 0 0 0 0 0 0 0 0 $project.gamepart.event.KeyEventDispatcher$ 0 0 0 0 $project.gamepart.event.EventDispatcher$ 0 0 0 0 0 0 0 0 0 $project.gamepart.event.KeyEventDispatcher$ 0 0 0 0 $project.gamepart.event.EventDispatcher$ 0 0 0 0 0 0 0 0 0 $project.gamepart.event.MouseEventDispatcher$ 0 0 0 0 $project.gamepart.event.EventDispatcher$ 0 0 0 0 0 0 0 0 0 $project.gamepart.event.MouseEventDispatcher$ 0 0 0 0 0 0 0 0 $context.Context$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $render.GfxRenderer$ 0 0 0 0 0 0 0 0 0 0 0 $render.GfxRenderer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . utils import pymunk , make_body , update_shape , typed_property [comment] [EOL] from . vector import Vector [comment] [EOL] from . world import World [comment] [EOL] from . physicalobject import ( PhysicalObject , CollisionObject , AwareObject , SimplePhysicalObject , ) [EOL] from . category import Category , cat_all , cat_none [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import SupportsInt , Tuple , Type [EOL] import builtins [EOL] import typing [EOL] import project [EOL] import utils [EOL] import typing [EOL] [EOL] from . utils import pymunk [EOL] [EOL] [EOL] class Category : [EOL] global_index = [number] [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , forced_index = None ) : [EOL] if forced_index is None : [EOL] forced_index = Category . global_index [EOL] Category . global_index *= [number] [EOL] self . _index = int ( forced_index ) [EOL] assert [number] <= self . _index <= pymunk . ShapeFilter . ALL_MASKS , self . _index [EOL] [EOL] def __int__ ( self ) : [EOL] return self . _index [EOL] [EOL] def __bool__ ( self ) : [EOL] return self . _index == [number] [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { bin ( self . _index ) } [string] " [EOL] [EOL] def __or__ ( self , other ) : [EOL] return Category ( self . _index | int ( other ) ) [EOL] [EOL] def __and__ ( self , other ) : [EOL] return Category ( self . _index & int ( other ) ) [EOL] [EOL] def __xor__ ( self , other ) : [EOL] return Category ( self . _index ^ int ( other ) ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return Category ( ~ self . _index ) [EOL] [EOL] __add__ = __or__ [EOL] [EOL] def __sub__ ( self , other ) : [EOL] return Category ( self . _index & ~ int ( other ) ) [EOL] [EOL] def __contains__ ( self , item ) : [EOL] return self . _index & int ( item ) [EOL] [EOL] def filter ( self , mask = pymunk . ShapeFilter . ALL_MASKS , group = [number] , ) : [EOL] return pymunk . ShapeFilter ( group , self . _index , int ( mask ) ) [EOL] [EOL] [EOL] cat_none = Category ( [number] ) [EOL] cat_all = Category ( pymunk . ShapeFilter . ALL_MASKS ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Category"$ 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 $"Category"$ 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 $"Category"$ 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 $"Category"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Category"$ 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 $utils.pymunk.ShapeFilter$ 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 $typing.SupportsInt$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , TextIO [EOL] import builtins [EOL] import typing [EOL] import pymunk [EOL] import functools [EOL] import logging [EOL] import sys [EOL] import io [EOL] [EOL] [comment] [EOL] import typing [EOL] [EOL] import pymunkoptions [EOL] [EOL] pymunkoptions . options [ [string] ] = False [EOL] sys . stdout = io . StringIO ( ) [EOL] import pymunk [comment] [EOL] [EOL] sys . stdout = sys . __stdout__ [EOL] logging . info ( [string] , pymunk . version , pymunk . chipmunk_version ) [EOL] [EOL] [EOL] def make_body ( mass = [number] , moment = [number] , body_type = pymunk . Body . DYNAMIC , ** kwargs ) : [EOL] body = pymunk . Body ( mass , moment , body_type ) [EOL] for key , value in kwargs : [EOL] setattr ( body , key , value ) [EOL] return body [EOL] [EOL] [EOL] def update_shape ( shape , ** kwargs ) : [EOL] for key , value in kwargs : [EOL] setattr ( shape , key , value ) [EOL] return shape [EOL] [EOL] [EOL] def typed_property ( rtype ) : [EOL] @ functools . wraps ( property ) def prop ( * args , ** kwargs ) : [EOL] return property ( * args , ** kwargs ) [EOL] [EOL] prop . __annotations__ [ [string] ] = rtype [EOL] return prop [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import sdl2 [EOL] import sdl2 [EOL] [EOL] from . . subsystem import SubSystemObject [EOL] [EOL] [EOL] class GUIObject ( SubSystemObject ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . enabled = True [EOL] self . visible = True [EOL] [EOL] def draw ( self , manager ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def event ( self , event ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def focus ( self ) : [EOL] pass [EOL] [EOL] def unfocus ( self ) : [EOL] pass [EOL] [EOL] [EOL] from . system import GUISystem [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $"GUISystem"$ 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import builtins [EOL] import sdl2 [EOL] import guiobject [EOL] import render [EOL] import typing [EOL] import typing [EOL] [EOL] import sdl2 . ext [EOL] [EOL] from . . subsystem import SubSystem [EOL] from . . render import GfxRenderer [EOL] [EOL] [EOL] class GUISystem ( SubSystem [ [string] ] ) : [EOL] def __init__ ( self , renderer , font_manager , sprite_factory , width , height , ) : [EOL] super ( ) . __init__ ( ) [EOL] self . renderer = renderer [EOL] self . font_manager = font_manager [EOL] self . sprite_factory = sprite_factory [EOL] self . width = width [EOL] self . height = height [EOL] self . focused_object = None [EOL] [EOL] @ staticmethod def accepts ( obj ) : [EOL] return isinstance ( obj , GUIObject ) [EOL] [EOL] def draw ( self ) : [EOL] for obj in self . objects : [EOL] if obj . visible : [EOL] obj . draw ( self ) [EOL] [EOL] def event ( self , event ) : [EOL] for obj in self . objects : [EOL] if obj . enabled : [EOL] obj . event ( event ) [EOL] [EOL] def change_focus ( self , obj ) : [EOL] if self . focused_object : [EOL] self . focused_object . unfocus ( ) [EOL] self . focused_object = obj [EOL] if self . focused_object : [EOL] self . focused_object . focus ( ) [EOL] [EOL] [EOL] from . guiobject import GUIObject [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $guiobject.GUIObject$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 $typing.Optional["GUIObject"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional["GUIObject"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . system import GUISystem [comment] [EOL] from . guiobject import GUIObject [comment] [EOL] from . console import Console [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List , Dict , Union , Any , Tuple [EOL] import builtins [EOL] import sdl2 [EOL] import io [EOL] import typing [EOL] import project [EOL] import code [EOL] import io [EOL] import sys [EOL] import time [EOL] import typing [EOL] [EOL] import sdl2 [EOL] [EOL] from . . utils import get_clipboard_text [EOL] from . system import GUISystem [EOL] from . guiobject import GUIObject [EOL] [EOL] [EOL] class BufferedConsole ( code . InteractiveConsole ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . output_buffer = io . StringIO ( ) [EOL] [EOL] def write ( self , data ) : [EOL] self . output_buffer . write ( data ) [EOL] [EOL] def push_line ( self , line , prefix = [string] ) : [EOL] self . output_buffer . write ( prefix ) [EOL] self . output_buffer . write ( line ) [EOL] self . output_buffer . write ( [string] ) [EOL] so , se = sys . stdout , sys . stderr [EOL] sys . stdout = sys . stderr = self . output_buffer [EOL] more = self . push ( line ) [EOL] sys . stdout , sys . stderr = so , se [EOL] return more [EOL] [EOL] [EOL] class ConsoleService : [EOL] def __init__ ( self , shell ) : [EOL] self . shell = shell [EOL] [EOL] self . prompt1 = [string] [EOL] self . prompt2 = [string] [EOL] self . prompt = self . prompt1 [EOL] self . input_buffer = [string] [EOL] self . input_buffer2 = [string] [EOL] self . input_index = [number] [EOL] self . history = [ ] [EOL] self . history_index = None [EOL] [EOL] def get_all_buffer ( self ) : [EOL] return self . get_buffer_start ( ) + self . get_buffer_end ( ) [EOL] [EOL] def get_buffer_start ( self ) : [EOL] return ( self . shell . output_buffer . getvalue ( ) + self . prompt + self . input_buffer [ : self . input_index ] ) [EOL] [EOL] def get_buffer_end ( self ) : [EOL] return self . input_buffer [ self . input_index : ] [EOL] [EOL] def exit_history ( self ) : [EOL] self . history_index = None [EOL] [EOL] def enter_text ( self , text ) : [EOL] self . exit_history ( ) [EOL] self . input_buffer = [string] . format ( self . input_buffer [ : self . input_index ] , text , self . input_buffer [ self . input_index : ] , ) [EOL] self . input_index += len ( text ) [EOL] [EOL] def press_backspace ( self , amount = [number] ) : [EOL] self . exit_history ( ) [EOL] self . input_buffer = [string] . format ( self . input_buffer [ : self . input_index ] [ : - amount ] , self . input_buffer [ self . input_index : ] , ) [EOL] self . input_index = max ( self . input_index - amount , [number] ) [EOL] [EOL] def press_delete ( self , amount = [number] ) : [EOL] self . exit_history ( ) [EOL] self . input_buffer = [string] . format ( self . input_buffer [ : self . input_index ] , self . input_buffer [ self . input_index : ] [ amount : ] , ) [EOL] self . input_index = max ( self . input_index , [number] ) [EOL] [EOL] def press_left ( self , amount = [number] ) : [EOL] self . exit_history ( ) [EOL] self . input_index = max ( self . input_index - amount , [number] ) [EOL] [EOL] def press_right ( self , amount = [number] ) : [EOL] self . exit_history ( ) [EOL] self . input_index = min ( self . input_index + amount , len ( self . input_buffer ) ) [EOL] [EOL] def press_end ( self ) : [EOL] self . exit_history ( ) [EOL] self . input_index = len ( self . input_buffer ) [EOL] [EOL] def press_home ( self ) : [EOL] self . exit_history ( ) [EOL] self . input_index = [number] [EOL] [EOL] def press_up ( self ) : [EOL] if self . history : [EOL] if self . history_index is None : [EOL] self . history_index = len ( self . history ) [EOL] self . input_buffer2 = self . input_buffer [EOL] self . history_index = max ( self . history_index - [number] , [number] ) [EOL] self . input_buffer = self . history [ self . history_index ] [EOL] self . input_index = len ( self . input_buffer ) [EOL] [EOL] def press_down ( self ) : [EOL] if self . history_index is not None : [EOL] self . history_index = min ( self . history_index + [number] , len ( self . history ) ) [EOL] if self . history_index == len ( self . history ) : [EOL] self . input_buffer = self . input_buffer2 [EOL] self . input_index = len ( self . input_buffer ) [EOL] self . history_index = None [EOL] else : [EOL] self . input_buffer = self . history [ self . history_index ] [EOL] self . input_index = len ( self . input_buffer ) [EOL] [EOL] def press_enter ( self ) : [EOL] data = self . input_buffer [EOL] if self . history_index is not None : [EOL] data = self . history [ self . history_index ] [EOL] self . exit_history ( ) [EOL] if data : [EOL] self . history . append ( data ) [EOL] if self . shell . push_line ( data , self . prompt ) : [EOL] self . prompt = self . prompt2 [EOL] else : [EOL] self . prompt = self . prompt1 [EOL] self . input_buffer = [string] [EOL] self . input_index = [number] [EOL] [EOL] [EOL] class Console ( GUIObject ) : [EOL] def __init__ ( self , shell_locals = None ) : [EOL] super ( ) . __init__ ( ) [EOL] locals_ = { [string] : [string] , [string] : None , [string] : self } [EOL] if shell_locals : [EOL] locals_ . update ( shell_locals ) [EOL] self . shell = BufferedConsole ( locals = locals_ ) [EOL] self . service = ConsoleService ( self . shell ) [EOL] self . font = [string] [EOL] self . font_size = [number] [EOL] self . line_spacing = [number] [EOL] self . position = [ [number] , [number] ] [EOL] self . width = [number] [EOL] self . height = [number] [EOL] self . scroll = [ [number] , [number] ] [EOL] self . color = ( [number] , [number] , [number] , [number] ) [EOL] self . bg_color = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] def focus ( self ) : [EOL] sdl2 . SDL_StartTextInput ( ) [EOL] sdl2 . SDL_SetTextInputRect ( sdl2 . SDL_Rect ( self . position [ [number] ] , self . position [ [number] ] + self . height - self . font_size , self . width , self . font_size , ) ) [EOL] [EOL] def unfocus ( self ) : [EOL] sdl2 . SDL_StopTextInput ( ) [EOL] [EOL] def draw ( self , manager ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] line_height = self . font_size + self . line_spacing [EOL] buffer = self . service . get_buffer_start ( ) [EOL] old_clip = manager . renderer . clip [EOL] manager . renderer . clip = ( self . position [ [number] ] , self . position [ [number] ] , self . width , self . height , ) [EOL] manager . renderer . fill ( [ ( self . position [ [number] ] , self . position [ [number] ] , self . width , self . height ) ] , self . bg_color , ) [EOL] [EOL] self . scroll [ [number] ] = ( self . height - ( buffer . count ( [string] ) + [number] ) * line_height - self . line_spacing ) [EOL] py = [number] [EOL] for row in buffer . split ( [string] ) : [EOL] spy = py + self . scroll [ [number] ] [EOL] if row and spy <= self . height and spy + line_height >= [number] : [EOL] text = manager . font_manager . render ( row , alias = self . font , size = self . font_size , color = self . color ) [EOL] tw = text . w [EOL] th = text . h [EOL] tx = self . position [ [number] ] + self . scroll [ [number] ] [EOL] ty = self . position [ [number] ] + self . scroll [ [number] ] + py [EOL] text = manager . sprite_factory . from_surface ( text , True ) [EOL] manager . renderer . copy ( text , ( [number] , [number] , tw , th ) , ( tx , ty , tw , th ) ) [EOL] py += line_height [EOL] [EOL] ttx = tx + tw [EOL] if time . time ( ) % [number] <= [number] : [EOL] text = manager . font_manager . render ( [string] , alias = self . font , size = self . font_size , color = self . color ) [EOL] ttw = text . w [EOL] tth = text . h [EOL] text = manager . sprite_factory . from_surface ( text , True ) [EOL] manager . renderer . copy ( text , ( [number] , [number] , ttw , tth ) , ( ttx - int ( ttw / [number] ) , ty , ttw , tth ) ) [EOL] [EOL] rest = self . service . get_buffer_end ( ) [EOL] if rest : [EOL] text = manager . font_manager . render ( rest , alias = self . font , size = self . font_size , color = self . color ) [EOL] tw = text . w [EOL] th = text . h [EOL] text = manager . sprite_factory . from_surface ( text , True ) [EOL] manager . renderer . copy ( text , ( [number] , [number] , tw , th ) , ( ttx , ty , tw , th ) ) [EOL] [EOL] manager . renderer . clip = old_clip [EOL] [EOL] def event ( self , event ) : [EOL] if event . type == sdl2 . SDL_TEXTINPUT : [EOL] self . service . enter_text ( event . text . text . decode ( [string] ) ) [EOL] if event . type == sdl2 . SDL_KEYDOWN : [EOL] if event . key . keysym . sym in ( sdl2 . SDLK_BACKSPACE , sdl2 . SDLK_KP_BACKSPACE ) : [EOL] self . service . press_backspace ( ) [EOL] if event . key . keysym . sym == sdl2 . SDLK_DELETE : [EOL] self . service . press_delete ( ) [EOL] elif event . key . keysym . sym == sdl2 . SDLK_LEFT : [EOL] self . service . press_left ( ) [EOL] elif event . key . keysym . sym == sdl2 . SDLK_RIGHT : [EOL] self . service . press_right ( ) [EOL] elif event . key . keysym . sym == sdl2 . SDLK_END : [EOL] self . service . press_end ( ) [EOL] elif event . key . keysym . sym == sdl2 . SDLK_HOME : [EOL] self . service . press_home ( ) [EOL] elif event . key . keysym . sym == sdl2 . SDLK_UP : [EOL] self . service . press_up ( ) [EOL] elif event . key . keysym . sym == sdl2 . SDLK_DOWN : [EOL] self . service . press_down ( ) [EOL] elif ( event . key . keysym . sym == sdl2 . SDLK_v [EOL] and event . key . keysym . mod & sdl2 . KMOD_CTRL ) : [EOL] self . service . enter_text ( get_clipboard_text ( ) ) [EOL] elif event . key . keysym . sym in ( sdl2 . SDLK_KP_ENTER , sdl2 . SDLK_RETURN , sdl2 . SDLK_RETURN2 , ) : [EOL] self . service . press_enter ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $BufferedConsole$ 0 0 0 0 0 $BufferedConsole$ 0 $BufferedConsole$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,project.gamepart.gui.console.Console,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 $typing.Dict[builtins.str,typing.Union[None,project.gamepart.gui.console.Console,builtins.str]]$ 0 0 0 $builtins.dict$ 0 0 0 0 $project.gamepart.gui.console.BufferedConsole$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,project.gamepart.gui.console.Console,builtins.str]]$ 0 0 0 0 $project.gamepart.gui.console.ConsoleService$ 0 0 0 0 0 $project.gamepart.gui.console.BufferedConsole$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"GUISystem"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $"GUISystem"$ 0 0 0 0 0 $"GUISystem"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"GUISystem"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $"GUISystem"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $"GUISystem"$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $"GUISystem"$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $"GUISystem"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $"GUISystem"$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $"GUISystem"$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $"GUISystem"$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $"GUISystem"$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $"GUISystem"$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $"GUISystem"$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 $sdl2.SDL_Event$ 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Iterable [EOL] import builtins [EOL] import typing [EOL] import math [EOL] import typing [EOL] [EOL] import sdl2 . ext [EOL] [EOL] from . . subsystem import SubSystemObject [EOL] from . . physics . vector import Vector [EOL] [EOL] [EOL] class GraphicalObject ( SubSystemObject ) : [EOL] position = ... [EOL] angle = ... [EOL] [EOL] def draw ( self , vp ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] [EOL] class ComplexGraphicalObject ( GraphicalObject ) : [EOL] position = ( [number] , [number] ) [EOL] angle = [number] [EOL] [EOL] def __init__ ( self , objects = ( ) ) : [EOL] super ( ) . __init__ ( ) [EOL] self . objects = list ( objects ) [EOL] [EOL] def draw ( self , vp ) : [EOL] for obj in self . objects : [EOL] obj . draw ( vp ) [EOL] [EOL] [EOL] class TexturedObject ( GraphicalObject ) : [EOL] texture = ... [EOL] scale = [number] [EOL] [EOL] def draw ( self , vp ) : [EOL] texture = self . texture [EOL] w , h = texture . size [EOL] w , h = vp . d_to_view ( w ) * self . scale , vp . d_to_view ( h ) * self . scale [EOL] x , y = vp . to_view ( self . position ) [EOL] x , y = x - w / [number] , y - h / [number] [EOL] angle = ( self . angle / ( [number] * math . pi ) ) * [number] + texture . angle [EOL] dst = ( int ( x ) , int ( y ) , int ( w ) , int ( h ) ) [EOL] vp . renderer . copy ( texture . texture , None , dst , angle , None , texture . flip ) [EOL] [EOL] [EOL] class GFXObject ( GraphicalObject ) : [EOL] color = ... [EOL] [EOL] [EOL] class Point ( GFXObject ) : [EOL] def draw ( self , vp ) : [EOL] vp . renderer . pixel ( [ vp . to_view ( self . position ) ] , self . color ) [EOL] [EOL] [EOL] class Line ( GFXObject ) : [EOL] end_points = ... [EOL] [EOL] def draw ( self , vp ) : [EOL] start , end = self . end_points [EOL] sx , sy = vp . to_view ( start ) [EOL] ex , ey = vp . to_view ( end ) [EOL] vp . renderer . line ( [ ( sx , sy , ex , ey ) ] , self . color ) [EOL] [EOL] [EOL] class Polygon ( GFXObject ) : [EOL] points = ... [EOL] [EOL] def draw ( self , vp ) : [EOL] points = [ vp . to_view ( p ) for p in self . points ] [EOL] vp . renderer . filled_polygon ( [ points ] , self . color ) [EOL] [EOL] [EOL] class Circle ( GFXObject ) : [EOL] radius = ... [EOL] [EOL] def draw ( self , vp ) : [EOL] r = vp . d_to_view ( self . radius ) [EOL] px , py = vp . to_view ( self . position ) [EOL] lx , ly = tuple ( ( px , py ) + Vector . polar ( r , self . angle ) ) [EOL] vp . renderer . filled_circle ( [ ( px , py , r ) ] , self . color ) [EOL] vp . renderer . line ( [ ( px , py , lx , ly ) ] , sdl2 . ext . Color ( [number] , [number] , [number] ) ) [EOL] [EOL] [EOL] from . viewport import ViewPort [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 $sdl2.ext.TextureSprite$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Tuple[builtins.int,builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int],sdl2.ext.Color]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.float,builtins.float],typing.Tuple[builtins.float,builtins.float]]$ 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.float,builtins.float]]$ 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . viewport import ViewPort , FlippedViewPort [comment] [EOL] from . graphicalobject import ( GraphicalObject , TexturedObject , GFXObject , Point , Line , Polygon , Circle , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Tuple [EOL] import render [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] [EOL] from . . subsystem import SubSystem [EOL] from . . render import GfxRenderer [EOL] [EOL] [EOL] class ViewPort ( SubSystem [ [string] ] ) : [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , renderer , width , height , zoom = [number] , x = [number] , y = [number] , ) : [EOL] super ( ) . __init__ ( ) [EOL] self . renderer = renderer [EOL] self . width = width [EOL] self . height = height [EOL] self . zoom = zoom [EOL] self . x = x [EOL] self . y = y [EOL] [EOL] @ staticmethod def accepts ( obj ) : [EOL] return isinstance ( obj , GraphicalObject ) [EOL] [EOL] def draw ( self ) : [EOL] for obj in self . objects : [EOL] obj . draw ( self ) [EOL] [EOL] def x_to_view ( self , x ) : [EOL] return ( x - self . x ) * self . zoom [EOL] [EOL] def y_to_view ( self , y ) : [EOL] return ( y - self . y ) * self . zoom [EOL] [EOL] def to_view ( self , pos ) : [EOL] return self . x_to_view ( pos [ [number] ] ) , self . y_to_view ( pos [ [number] ] ) [comment] [EOL] [EOL] def d_to_view ( self , d ) : [EOL] return d * self . zoom [EOL] [EOL] def x_to_world ( self , x ) : [EOL] return ( x / self . zoom ) + self . x [EOL] [EOL] def y_to_world ( self , y ) : [EOL] return ( y / self . zoom ) + self . y [EOL] [EOL] def to_world ( self , pos ) : [EOL] return self . x_to_world ( pos [ [number] ] ) , self . y_to_world ( pos [ [number] ] ) [comment] [EOL] [EOL] def d_to_world ( self , d ) : [EOL] return d / self . zoom [EOL] [EOL] @ property def center ( self ) : [EOL] return self . to_world ( ( self . width / [number] , self . height / [number] ) ) [EOL] [EOL] @ center . setter def center ( self , value ) : [EOL] cx , cy = self . center [EOL] self . x += value [ [number] ] - cx [EOL] self . y += value [ [number] ] - cy [EOL] [EOL] def change_zoom ( self , change = [number] , pos = None ) : [EOL] if pos is None : [EOL] pos = self . center [EOL] self . x += ( [number] - [number] / change ) * ( pos [ [number] ] - self . x ) [EOL] self . y += ( [number] - [number] / change ) * ( pos [ [number] ] - self . y ) [EOL] self . zoom *= change [EOL] [EOL] [EOL] class FlippedViewPort ( ViewPort ) : [EOL] def y_to_view ( self , y ) : [EOL] return self . height - ( y - self . y ) * self . zoom [comment] [EOL] [EOL] def y_to_world ( self , y ) : [EOL] return ( ( self . height - y ) / self . zoom ) + self . y [comment] [EOL] [EOL] [EOL] from . graphicalobject import GraphicalObject [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $render.GfxRenderer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $render.GfxRenderer$ 0 $render.GfxRenderer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0
from . test import TestScene [comment] [EOL] from . balls import BallScene [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import context [EOL] import gamepart [EOL] import sdl2 . ext [EOL] [EOL] from context import MyContext [EOL] from gamepart import SimpleScene [EOL] from gamepart . render import GfxRenderer [EOL] from gamepart . gui import GUISystem , Console [EOL] [EOL] [EOL] class MyBaseScene ( SimpleScene ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . gui = None [EOL] self . console = None [EOL] [EOL] def init ( self ) : [EOL] super ( ) . init ( ) [EOL] self . gui = GUISystem ( self . game . renderer , self . game . font_manager , self . game . sprite_factory , self . game . width , self . game . height , ) [EOL] self . system . add ( self . gui ) [EOL] self . key_event . on_down ( sdl2 . SDLK_F1 , self . toggle_console ) [EOL] self . key_event . on_up ( sdl2 . SDLK_F1 , self . key_event . stop ) [EOL] self . key_event . on_up ( sdl2 . SDLK_F3 , self . toggle_fps ) [EOL] self . event . chain ( self . gui . event ) [EOL] [EOL] def every_frame ( self , renderer ) : [EOL] self . gui . draw ( ) [EOL] [EOL] def toggle_console ( self , _ = None ) : [EOL] if self . console . visible : [EOL] self . console . visible = False [EOL] self . console . enabled = False [EOL] self . gui . change_focus ( None ) [EOL] else : [EOL] self . console . visible = True [EOL] self . console . enabled = True [EOL] self . gui . change_focus ( self . console ) [EOL] return True [EOL] [EOL] def toggle_fps ( self , _ = None ) : [EOL] self . game . show_fps = not self . game . show_fps [EOL] [EOL] def stop ( self ) : [EOL] context = super ( ) . stop ( ) [EOL] context . console = self . console [EOL] return context [EOL] [EOL] def start ( self , context ) : [comment] [EOL] super ( ) . start ( context ) [EOL] if context . console is None : [EOL] self . console = Console ( { [string] : self . game } ) [EOL] self . console . visible = False [EOL] self . console . enabled = False [EOL] self . gui . add ( self . console ) [EOL] else : [EOL] self . console = context . console [EOL] if self . console not in self . gui . objects : [EOL] self . gui . add ( self . console ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import gamepart [EOL] import time [EOL] import math [EOL] [EOL] import sdl2 . ext [EOL] [EOL] from gamepart . render import GfxRenderer [EOL] [EOL] from . base import MyBaseScene [EOL] [EOL] [EOL] class TestScene ( MyBaseScene ) : [EOL] def init ( self ) : [EOL] super ( ) . init ( ) [EOL] self . key_event . on_up ( sdl2 . SDLK_COMMA , self . decrease_fps ) [EOL] self . key_event . on_up ( sdl2 . SDLK_PERIOD , self . increase_fps ) [EOL] self . key_event . on_up ( sdl2 . SDLK_F2 , self . switch_to_balls ) [EOL] [EOL] def every_frame ( self , renderer ) : [EOL] self . game . renderer . clear ( ( [number] , [number] , [number] , [number] ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] x = int ( ( math . sin ( time . perf_counter ( ) ) + [number] ) * [number] ) + [number] [EOL] y = int ( ( math . cos ( time . perf_counter ( ) ) + [number] ) * [number] ) + [number] [EOL] self . game . renderer . fill ( ( x , y , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ) [EOL] super ( ) . every_frame ( renderer ) [EOL] [EOL] def decrease_fps ( self , _ = None ) : [EOL] self . game . max_fps /= [number] [EOL] self . game . fps_counter . clear ( ) [EOL] [EOL] def increase_fps ( self , _ = None ) : [EOL] self . game . max_fps *= [number] [EOL] self . game . fps_counter . clear ( ) [EOL] [EOL] def switch_to_balls ( self , _ = None ) : [EOL] self . game . queue_scene_switch ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gamepart.render.GfxRenderer$ 0 0 0 0 0 0 0 $gamepart.render.GfxRenderer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gamepart.render.GfxRenderer$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gamepart.render.GfxRenderer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from gamepart . physics . category import Category , cat_all , cat_none [comment] [EOL] [EOL] cat_terrain = Category ( ) [EOL] cat_player = Category ( ) [EOL] cat_enemy = Category ( ) [EOL] cat_player_projectile = Category ( ) [EOL] cat_enemy_projectile = Category ( ) [EOL] cat_collectible = Category ( ) [EOL] [EOL] cat_terrain_collide = cat_all [EOL] cat_player_collide = cat_terrain + cat_enemy_projectile + cat_collectible [EOL] cat_enemy_collide = cat_terrain + cat_player_projectile + cat_enemy [EOL] cat_player_projectile_collide = cat_terrain + cat_enemy [EOL] cat_enemy_projectile_collide = cat_terrain + cat_player [EOL] cat_collectible_collide = cat_terrain + cat_player [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0
from typing import Any , Tuple , Type [EOL] import builtins [EOL] import sdl2 [EOL] import base [EOL] import player [EOL] import typing [EOL] import project [EOL] import gamepart [EOL] import sdl2 [EOL] import sdl2 . ext [EOL] [EOL] from gamepart . physics import World [EOL] from gamepart . physics . vector import Vector [EOL] from gamepart . render import GfxRenderer [EOL] from gamepart . viewport import ViewPort , FlippedViewPort [EOL] [EOL] from . . base import MyBaseScene , MyContext [EOL] from . line import BoundLine [EOL] from . ball import Ball , TexturedBall [EOL] from . player import Player , PlayerController [EOL] [EOL] [EOL] class BallScene ( MyBaseScene ) : [EOL] bg_color = sdl2 . ext . Color ( [number] , [number] , [number] ) [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . world = None [EOL] self . viewport = None [EOL] self . last_click = ( [number] , [number] ) [EOL] self . player = None [EOL] self . player_ctrl = None [EOL] [EOL] def init ( self ) : [EOL] super ( ) . init ( ) [EOL] self . world = World ( ) [EOL] self . world . space . gravity = ( [number] , - [number] ) [EOL] self . system . add ( self . world ) [EOL] self . viewport = FlippedViewPort ( self . game . renderer , self . game . width , self . game . height ) [EOL] self . viewport . change_zoom ( [number] ) [EOL] self . system . add ( self . viewport ) [EOL] [EOL] self . key_event . on_up ( sdl2 . SDLK_F2 , self . switch_to_test ) [EOL] self . key_event . on_down ( sdl2 . SDLK_w , self . player_jump ) [EOL] self . mouse_event . on_down ( sdl2 . SDL_BUTTON_LEFT , self . start_drag ) [EOL] self . mouse_event . on_up ( sdl2 . SDL_BUTTON_LEFT , self . end_drag ) [EOL] self . mouse_event . on_up ( sdl2 . SDL_BUTTON_RIGHT , self . delete_ball ) [EOL] self . event . on ( sdl2 . SDL_MOUSEWHEEL , self . change_zoom ) [EOL] [EOL] self . player = Player ( position = ( [number] , [number] ) ) [EOL] self . player_ctrl = PlayerController ( self . player ) [EOL] self . key_event . on_down ( sdl2 . SDLK_e , self . player_ctrl . setter ( [string] , True ) ) [EOL] [EOL] def start ( self , context ) : [EOL] self . system . clear_all ( ) [EOL] super ( ) . start ( context ) [EOL] tex = self . game . sprite_factory . from_image ( [string] ) [EOL] self . system . add_all ( Ball ( [number] , [number] , ( [number] , [number] ) , ( [number] , [number] ) ) , Ball ( [number] , [number] , ( [number] , [number] ) , ( [number] , [number] ) ) , TexturedBall ( [number] , [number] , ( [number] , [number] ) , ( [number] , [number] ) , texture = tex , scale = [number] ) , self . player , ) [EOL] self . system . add_all ( * BoundLine . make_box ( self . world . space . static_body , self . game . width - [number] , self . game . height - [number] , [number] , [number] , ) ) [EOL] [EOL] def change_zoom ( self , event ) : [EOL] pos = self . viewport . to_world ( self . game . mouse_state [ [number] : [number] ] ) [EOL] if event . wheel . y > [number] : [EOL] if self . viewport . zoom <= [number] : [EOL] self . viewport . change_zoom ( [number] , pos ) [EOL] elif event . wheel . y < [number] : [EOL] if self . viewport . zoom >= [number] / [number] : [EOL] self . viewport . change_zoom ( [number] , pos ) [EOL] [EOL] def start_drag ( self , event ) : [EOL] self . last_click = self . viewport . to_world ( ( event . button . x , event . button . y ) ) [EOL] [EOL] def end_drag ( self , event ) : [EOL] click = self . viewport . to_world ( ( event . button . x , event . button . y ) ) [EOL] p = Vector . to ( self . last_click ) [EOL] v = Vector . to ( click ) - p [EOL] self . system . add_all ( Ball ( position = p , velocity = v * [number] , radius = [number] , mass = [number] ) ) [EOL] [EOL] def delete_ball ( self , event ) : [EOL] pos = Vector . to ( self . viewport . to_world ( ( event . button . x , event . button . y ) ) ) [EOL] rem = None [EOL] for c in self . world . get_objects ( Ball ) : [EOL] if ( pos - c . position ) . r <= c . radius : [EOL] rem = c [EOL] if rem : [EOL] self . system . remove_all ( rem ) [EOL] [EOL] def switch_to_test ( self , _ = None ) : [EOL] self . game . queue_scene_switch ( [string] ) [EOL] [EOL] def player_jump ( self , event ) : [EOL] if not event . key . repeat : [EOL] self . player_ctrl . input . jump = True [EOL] [EOL] def tick ( self , delta ) : [EOL] self . player_ctrl . input . left = bool ( self . game . key_state [ sdl2 . SDL_SCANCODE_A ] ) [EOL] self . player_ctrl . input . right = bool ( self . game . key_state [ sdl2 . SDL_SCANCODE_D ] ) [EOL] self . player_ctrl . input . shoot = bool ( self . game . key_state [ sdl2 . SDL_SCANCODE_E ] ) [EOL] self . player_ctrl . control ( self . game . world_time , delta ) [EOL] self . world . tick ( delta ) [EOL] [EOL] def every_frame ( self , renderer ) : [EOL] renderer . clear ( self . bg_color ) [EOL] self . viewport . draw ( ) [EOL] super ( ) . every_frame ( renderer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 $player.Player$ 0 0 0 0 0 $player.Player.Controller$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $project.scenes.balls.player.Player$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $project.scenes.balls.player.PlayerController$ 0 0 0 0 0 $project.scenes.balls.player.Player$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $project.scenes.balls.player.PlayerController$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.MyContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.MyContext$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 $sdl2.SDL_Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $gamepart.render.GfxRenderer$ 0 0 0 $gamepart.render.GfxRenderer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gamepart.render.GfxRenderer$ 0 0
from . scene import BallScene [comment] [EOL]	0 0 0 0 0 0 0
from typing import Any , Type [EOL] import builtins [EOL] import typing [EOL] import project [EOL] import sdl2 [EOL] import sdl2 . ext [EOL] [EOL] from gamepart . physics import pymunk , SimplePhysicalObject , typed_property [EOL] from gamepart . viewport import ViewPort , Circle , TexturedObject [EOL] [EOL] from . category import cat_enemy , cat_enemy_collide [EOL] [EOL] [EOL] class Ball ( Circle , SimplePhysicalObject [ pymunk . Circle ] ) : [EOL] color = sdl2 . ext . Color ( [number] , [number] , [number] ) [EOL] [EOL] def __init__ ( self , radius = [number] , mass = [number] , position = ( [number] , [number] ) , velocity = ( [number] , [number] ) ) : [EOL] body = pymunk . Body ( mass , pymunk . moment_for_circle ( mass , [number] , radius ) ) [EOL] body . position = position [EOL] body . velocity = velocity [EOL] shape = pymunk . Circle ( body , radius ) [EOL] shape . filter = cat_enemy . filter ( cat_enemy_collide ) [EOL] shape . elasticity = [number] [EOL] shape . friction = [number] [EOL] super ( ) . __init__ ( body , shape , cat_enemy ) [EOL] [EOL] @ typed_property ( float ) def radius ( self ) : [EOL] return self . shape . radius [EOL] [EOL] @ property def angle ( self ) : [EOL] return self . body . angle [EOL] [EOL] [EOL] class TexturedBall ( Ball , TexturedObject ) : [EOL] def __init__ ( self , * args , texture , scale = [number] , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . texture = texture [EOL] self . scale = scale [EOL] [EOL] def draw ( self , vp ) : [EOL] Ball . draw ( self , vp ) [EOL] TexturedObject . draw ( self , vp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[project.scenes.balls.ball.Ball]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0 0 0 0 0 0 0 $"ViewPort"$ 0 0
from typing import Any , Generator , Type [EOL] import builtins [EOL] import typing [EOL] import project [EOL] import gamepart [EOL] import typing [EOL] [EOL] import sdl2 . ext [EOL] [EOL] from gamepart . physics import pymunk , SimplePhysicalObject [EOL] from gamepart . viewport import Line [EOL] [EOL] from . category import cat_terrain , cat_terrain_collide [EOL] [EOL] [EOL] class BoundLine ( Line , SimplePhysicalObject [ pymunk . Segment ] ) : [EOL] color = sdl2 . ext . Color ( [number] , [number] , [number] ) [EOL] [EOL] def __init__ ( self , static_body , p1x , p1y , p2x , p2y ) : [EOL] shape = pymunk . Segment ( static_body , ( p1x , p1y ) , ( p2x , p2y ) , [number] ) [EOL] shape . filter = cat_terrain . filter ( cat_terrain_collide ) [EOL] shape . elasticity = [number] [EOL] shape . friction = [number] [EOL] super ( ) . __init__ ( None , shape , cat_terrain ) [EOL] [EOL] @ property def end_points ( self ) : [EOL] return self . shape . a , self . shape . b [EOL] [EOL] @ classmethod def make_box ( cls , static_body , width , height , start_x = [number] , start_y = [number] , ) : [EOL] end_x = start_x + width [EOL] end_y = start_y + height [EOL] yield cls ( static_body , start_x , start_y , end_x , start_y ) [EOL] yield cls ( static_body , end_x , start_y , end_x , end_y ) [EOL] yield cls ( static_body , end_x , end_y , start_x , end_y ) [EOL] yield cls ( static_body , start_x , end_y , start_x , start_y ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[project.scenes.balls.line.BoundLine]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gamepart.physics.pymunk.Body$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $gamepart.physics.pymunk.Body$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator["BoundLine",None,None]$ 0 0 0 $gamepart.physics.pymunk.Body$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $gamepart.physics.pymunk.Body$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $gamepart.physics.pymunk.Body$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $gamepart.physics.pymunk.Body$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $gamepart.physics.pymunk.Body$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0
from typing import Any , Dict , Iterable [EOL] import builtins [EOL] import utils [EOL] import typing [EOL] import physicalobject [EOL] import typing [EOL] [EOL] from . . subsystem import SubSystem [EOL] from . utils import pymunk [EOL] from . physicalobject import PhysicalObject , CollisionObject , AwareObject [EOL] [EOL] [EOL] class World ( SubSystem [ PhysicalObject ] ) : [EOL] def __init__ ( self , speed = [number] ) : [EOL] super ( ) . __init__ ( ) [EOL] self . speed = speed [EOL] self . space = pymunk . Space ( ) [EOL] self . shape_map = { } [EOL] [EOL] @ staticmethod def accepts ( obj ) : [EOL] return isinstance ( obj , PhysicalObject ) [EOL] [EOL] def add ( self , * objects ) : [EOL] super ( ) . add ( * objects ) [EOL] for obj in objects : [EOL] self . space . add ( * obj . bodies , * obj . shapes ) [EOL] for shape in obj . shapes : [EOL] self . shape_map [ shape ] = obj [EOL] return objects [EOL] [EOL] def remove ( self , * objects ) : [EOL] for obj in objects : [EOL] self . space . remove ( * obj . bodies , * obj . shapes ) [EOL] for shape in obj . shapes : [EOL] del self . shape_map [ shape ] [EOL] return super ( ) . remove ( * objects ) [EOL] [EOL] def _collide ( self , arbiter , obj ) : [EOL] other = self . shape_map [ arbiter . shapes [ [number] ] ] [EOL] return obj . collide ( arbiter , other ) [EOL] [EOL] def tick ( self , delta ) : [EOL] self . space . step ( delta * self . speed ) [EOL] for a_obj in self . get_objects ( AwareObject ) : [EOL] a_obj . tick ( delta ) [EOL] for c_obj in self . get_objects ( CollisionObject ) : [EOL] for body in c_obj . bodies : [EOL] body . each_arbiter ( self . _collide , c_obj ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[utils.pymunk.Shape,physicalobject.PhysicalObject]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Iterable[physicalobject.PhysicalObject]$ 0 0 0 0 $physicalobject.PhysicalObject$ 0 0 0 0 0 0 0 0 0 0 $physicalobject.PhysicalObject$ 0 0 0 0 0 $physicalobject.PhysicalObject$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $physicalobject.PhysicalObject$ 0 0 0 $typing.Iterable[physicalobject.PhysicalObject]$ 0 0 0 0 $physicalobject.PhysicalObject$ 0 0 0 0 0 0 $physicalobject.PhysicalObject$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $physicalobject.PhysicalObject$ 0 0 0 0 0 0 0 0 $utils.pymunk.Arbiter$ 0 $physicalobject.CollisionObject$ 0 0 0 $typing.Any$ 0 0 0 0 0 $utils.pymunk.Arbiter$ 0 0 0 0 0 0 0 0 $physicalobject.CollisionObject$ 0 0 0 $utils.pymunk.Arbiter$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0