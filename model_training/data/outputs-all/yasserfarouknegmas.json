from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import re [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from io import open [EOL] from os import path [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] here = path . abspath ( path . dirname ( __file__ ) ) [EOL] [comment] [EOL] with open ( path . join ( here , [string] ) , encoding = [string] ) as f : [EOL] readme_txt = f . read ( ) [EOL] with open ( path . join ( here , [string] ) , encoding = [string] ) as f : [EOL] history_txt = f . read ( ) [EOL] [EOL] long_description = [string] % ( re . compile ( [string] , re . M | re . S ) . sub ( [string] , readme_txt ) , re . sub ( [string] , [string] , history_txt ) , ) [EOL] [comment] [EOL] [comment] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , url = [string] , author = [string] , author_email = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , ] , keywords = [string] . join ( [ [string] , [string] , [string] , [string] , [string] ] ) , packages = find_packages ( exclude = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , extras_require = { [string] : [ [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , } , dependency_links = [ ] , include_package_data = True , entry_points = { [string] : [ [string] , [string] ] } , project_urls = { [string] : [string] } , python_requires = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import tests [EOL] import pathlib [EOL] import random [EOL] import time [EOL] [EOL] import hypothesis . strategies as st [EOL] from hypothesis import given [EOL] [EOL] from negmas import Entity , NamedObject [EOL] from negmas . helpers import unique_name [EOL] [EOL] random . seed ( time . perf_counter ( ) ) [EOL] [EOL] good_attribs = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] bad_attribs = [ [string] , [string] ] [EOL] [EOL] [EOL] class WithStep ( NamedObject ) : [EOL] _step = [number] [EOL] [EOL] [EOL] class MyEntity ( NamedObject ) : [EOL] pass [EOL] [EOL] [EOL] @ given ( exist_ok = st . booleans ( ) , single_checkpoint = st . booleans ( ) , with_name = st . booleans ( ) , with_info = st . booleans ( ) , step_attribs = st . tuples ( st . sampled_from ( good_attribs + bad_attribs ) ) , ) def test_checkpoint ( tmp_path , exist_ok , with_name , with_info , single_checkpoint , step_attribs ) : [EOL] [EOL] x = WithStep ( ) [EOL] [EOL] fname = unique_name ( [string] , rand_digits = [number] , add_time = True , sep = [string] ) [EOL] try : [EOL] file_name = x . checkpoint ( path = tmp_path , file_name = fname if with_name else None , info = { [string] : [number] } if with_info else None , exist_ok = exist_ok , single_checkpoint = single_checkpoint , step_attribs = step_attribs , ) [EOL] assert ( file_name . name . split ( [string] ) [ [number] ] . isnumeric ( ) or single_checkpoint or all ( _ in bad_attribs for _ in set ( step_attribs ) ) or not any ( hasattr ( x , _ ) for _ in step_attribs ) ) [EOL] except ValueError as e : [EOL] if [string] in str ( e ) : [EOL] assert not exist_ok [EOL] else : [EOL] raise e [EOL] [EOL] x = MyEntity ( ) [EOL] [EOL] fname = unique_name ( [string] , rand_digits = [number] , add_time = True , sep = [string] ) [EOL] try : [EOL] file_name = x . checkpoint ( path = tmp_path , file_name = fname if with_name else None , info = { [string] : [number] } if with_info else None , exist_ok = exist_ok , single_checkpoint = single_checkpoint , step_attribs = step_attribs , ) [EOL] assert ( file_name . name . split ( [string] ) [ [number] ] . isnumeric ( ) or single_checkpoint or all ( _ in bad_attribs for _ in set ( step_attribs ) ) or not any ( hasattr ( x , _ ) for _ in step_attribs ) ) [EOL] except ValueError as e : [EOL] if [string] in str ( e ) : [EOL] assert not exist_ok [EOL] else : [EOL] raise e [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Union , List , Dict , Tuple , Any [EOL] import typing [EOL] import negmas [EOL] import os [EOL] from os import walk [EOL] [EOL] import pkg_resources [EOL] import pytest [EOL] [EOL] from negmas import AspirationNegotiator , load_genius_domain_from_folder [EOL] from negmas . genius import genius_bridge_is_running [EOL] [EOL] [EOL] @ pytest . fixture def scenarios_folder ( ) : [EOL] return pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] [EOL] [EOL] def test_reading_writing_linear_ufun ( tmp_path ) : [EOL] from negmas . utilities import LinearUtilityAggregationFunction , UtilityFunction [EOL] from negmas . outcomes import Issue [EOL] [EOL] base_folder = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] neg , agent_info , issues = load_genius_domain_from_folder ( base_folder , keep_issue_names = True , keep_value_names = True , ) [EOL] ufuns = [ _ [ [string] ] for _ in agent_info ] [EOL] for ufun in ufuns : [EOL] assert isinstance ( ufun , LinearUtilityAggregationFunction ) [EOL] dst = tmp_path / [string] [EOL] print ( dst ) [EOL] UtilityFunction . to_genius ( ufun , issues , dst ) [EOL] ufun2 , _ = UtilityFunction . from_genius ( dst ) [EOL] assert isinstance ( ufun2 , LinearUtilityAggregationFunction ) [EOL] for outcome in Issue . enumerate ( issues ) : [EOL] assert abs ( ufun2 ( outcome ) - ufun ( outcome ) ) < [number] [EOL] [EOL] [EOL] def test_importing_file_without_exceptions ( scenarios_folder ) : [EOL] folder_name = scenarios_folder + [string] [EOL] domain = load_genius_domain_from_folder ( folder_name , n_discretization = [number] ) [EOL] [comment] [EOL] [EOL] [EOL] def test_convert_dir_no_names ( tmpdir ) : [EOL] from negmas import convert_genius_domain_from_folder [EOL] [EOL] dst = tmpdir . mkdir ( [string] ) [EOL] src = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] dst = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] [EOL] assert convert_genius_domain_from_folder ( src_folder_name = src , dst_folder_name = dst , force_single_issue = True , cache_and_discretize_outcomes = True , n_discretization = [number] , keep_issue_names = False , keep_value_names = False , normalize_utilities = True , ) [EOL] mechanism , agent_info , issues = load_genius_domain_from_folder ( dst ) [EOL] assert len ( issues ) == [number] [EOL] for k , v in enumerate ( issues ) : [EOL] assert ( f"{ k } [string] { v }" == [string] ) [EOL] [EOL] [EOL] def test_simple_run_with_aspiration_agents ( ) : [EOL] file_name = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] assert os . path . exists ( file_name ) [EOL] mechanism , agents , issues = load_genius_domain_from_folder ( file_name , n_steps = [number] , time_limit = [number] , force_single_issue = True , keep_issue_names = False , keep_value_names = False , agent_factories = AspirationNegotiator , ) [EOL] assert mechanism is not None [EOL] state = mechanism . run ( ) [EOL] [EOL] [EOL] def test_encoding_decoding_all ( capsys , scenarios_folder ) : [EOL] from negmas . genius import AgentX , Atlas3 [EOL] [EOL] [comment] [EOL] [EOL] with capsys . disabled ( ) : [EOL] base = scenarios_folder [EOL] for root , dirs , files in walk ( base ) : [EOL] if len ( files ) == [number] or len ( dirs ) != [number] : [EOL] continue [EOL] [comment] [EOL] m , ufun_info , _ = load_genius_domain_from_folder ( root ) [EOL] assert m is not None [EOL] if genius_bridge_is_running ( ) : [EOL] for info in ufun_info : [EOL] n1 = Atlas3 ( domain_file_name = f"{ root } [string] { m . name } [string] " , ufun = info [ [string] ] , ) [EOL] n2 = AgentX ( domain_file_name = f"{ root } [string] { m . name } [string] " , utility_file_name = info [ [string] ] , ) [EOL] m . add ( n1 ) [EOL] m . add ( n2 ) [EOL] u1 , u2 = n1 . ufun , n2 . ufun [EOL] outcomes = m . discrete_outcomes ( n_max = [number] ) [EOL] for outcome in outcomes : [EOL] assert abs ( u1 ( outcome ) - u2 ( outcome ) ) < [number] [EOL] n1 . destroy_java_counterpart ( ) [EOL] n2 . destroy_java_counterpart ( ) [EOL] [EOL] [EOL] def test_importing_all_single_issue_without_exceptions ( capsys , scenarios_folder ) : [EOL] with capsys . disabled ( ) : [EOL] base = scenarios_folder [EOL] nxt , success = [number] , [number] [EOL] for root , dirs , files in walk ( base ) : [EOL] if len ( files ) == [number] or len ( dirs ) != [number] : [EOL] continue [EOL] try : [EOL] domain , _ , _ = load_genius_domain_from_folder ( root , force_single_issue = True , max_n_outcomes = [number] ) [EOL] except Exception as x : [EOL] print ( f" [string] { root }" ) [EOL] raise x [EOL] nxt += [number] [EOL] success += domain is not None [EOL] [comment] [EOL] [EOL] [EOL] def test_convert_dir_keep_names ( tmpdir ) : [EOL] from negmas import convert_genius_domain_from_folder [EOL] [EOL] dst = tmpdir . mkdir ( [string] ) [EOL] src = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] dst = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] assert convert_genius_domain_from_folder ( src_folder_name = src , dst_folder_name = dst , force_single_issue = True , cache_and_discretize_outcomes = True , n_discretization = [number] , keep_issue_names = True , keep_value_names = True , normalize_utilities = True , ) [EOL] mechanism , agent_info , issues = load_genius_domain_from_folder ( dst ) [EOL] assert len ( issues ) == [number] [EOL] for k , v in enumerate ( issues ) : [EOL] assert ( f"{ k } [string] { v }" == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Literal , List [EOL] import typing [EOL] import typing_extensions [EOL] import negmas [EOL] import hypothesis . strategies as st [EOL] import pkg_resources [EOL] import pytest [EOL] from hypothesis import given , settings [EOL] from py4j . protocol import Py4JNetworkError [EOL] [EOL] from negmas import ( GeniusNegotiator , genius_bridge_is_running , init_genius_bridge , load_genius_domain , load_genius_domain_from_folder , ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( condition = not genius_bridge_is_running ( ) , reason = [string] , ) def test_genius_does_not_freeze ( ) : [EOL] from negmas . inout import load_genius_domain_from_folder [EOL] from negmas . genius import GeniusNegotiator [EOL] from pathlib import Path [EOL] [EOL] folder_name = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] mechanism , ufuns , issues = load_genius_domain_from_folder ( folder_name , time_limit = [number] ) [EOL] a1 = GeniusNegotiator ( java_class_name = [string] , domain_file_name = f"{ folder_name } [string] { mechanism . name } [string] " , utility_file_name = ufuns [ [number] ] [ [string] ] , ) [EOL] [EOL] a2 = GeniusNegotiator ( java_class_name = [string] , domain_file_name = f"{ folder_name } [string] { mechanism . name } [string] " , utility_file_name = ufuns [ [number] ] [ [string] ] , ) [EOL] [EOL] mechanism . add ( a1 ) [EOL] mechanism . add ( a2 ) [EOL] print ( mechanism . run ( ) ) [EOL] print ( a1 . ufun . __call__ ( mechanism . agreement ) , a2 . ufun . __call__ ( mechanism . agreement ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . mark . skipif ( condition = not genius_bridge_is_running ( ) , reason = [string] , ) @ settings ( max_examples = [number] , deadline = [number] ) @ given ( agent_name1 = st . sampled_from ( GeniusNegotiator . robust_negotiators ( ) ) , agent_name2 = st . sampled_from ( GeniusNegotiator . robust_negotiators ( ) ) , single_issue = st . booleans ( ) , keep_issue_names = st . booleans ( ) , keep_value_names = st . booleans ( ) , ) def test_genius_agents_run_using_hypothesis ( agent_name1 , agent_name2 , single_issue , keep_issue_names , keep_value_names , ) : [EOL] from negmas import convert_genius_domain_from_folder [EOL] [EOL] [comment] [EOL] if keep_issue_names != keep_value_names : [EOL] return [EOL] utils = ( [number] , [number] ) [EOL] src = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] dst = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] if single_issue : [EOL] assert convert_genius_domain_from_folder ( src_folder_name = src , dst_folder_name = dst , force_single_issue = True , cache_and_discretize_outcomes = True , n_discretization = [number] , ) [EOL] base_folder = dst [EOL] else : [EOL] base_folder = src [EOL] neg , agent_info , issues = load_genius_domain_from_folder ( base_folder , keep_issue_names = keep_issue_names , keep_value_names = keep_value_names , time_limit = [number] , ) [EOL] if neg is None : [EOL] raise ValueError ( f" [string] { base_folder }" ) [EOL] a1 = GeniusNegotiator ( java_class_name = agent_name1 , domain_file_name = base_folder + [string] , utility_file_name = base_folder + f" [string] { utils [ [number] ] } [string] " , keep_issue_names = keep_issue_names , keep_value_names = keep_value_names , ) [EOL] a2 = GeniusNegotiator ( java_class_name = agent_name2 , domain_file_name = base_folder + [string] , utility_file_name = base_folder + f" [string] { utils [ [number] ] } [string] " , keep_issue_names = keep_issue_names , keep_value_names = keep_value_names , ) [EOL] neg . _enable_callbacks = True [EOL] neg . add ( a1 ) [EOL] neg . add ( a2 ) [EOL] neg . run ( ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( condition = not genius_bridge_is_running ( ) , reason = [string] , ) def test_genius_agent_gets_ufun ( ) : [EOL] agents = [ [string] , [string] ] [EOL] base_folder = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] neg , agent_info , issues = load_genius_domain_from_folder ( base_folder , keep_issue_names = True , keep_value_names = True , ) [EOL] a1 = GeniusNegotiator ( java_class_name = [string] , domain_file_name = base_folder + [string] , utility_file_name = base_folder + f" [string] " , keep_issue_names = True , keep_value_names = True , ) [EOL] assert a1 . ufun is not None [EOL] assert not a1 . _temp_ufun_file [EOL] assert not a1 . _temp_domain_file [EOL] a2 = GeniusNegotiator ( java_class_name = [string] , domain_file_name = base_folder + [string] , ufun = agent_info [ [number] ] [ [string] ] , keep_issue_names = True , keep_value_names = True , ) [EOL] neg . add ( a1 ) [EOL] neg . add ( a2 ) [EOL] assert a2 . ufun is not None [EOL] assert a2 . _temp_ufun_file [EOL] assert not a2 . _temp_domain_file [EOL] neg . run ( ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( condition = not genius_bridge_is_running ( ) , reason = [string] , ) def test_genius_agents_run_example ( ) : [EOL] from random import randint [EOL] [EOL] agents = [ [string] , [string] ] [EOL] for _ in range ( [number] ) : [EOL] agent_name1 = agents [ randint ( [number] , [number] ) ] [EOL] agent_name2 = agents [ randint ( [number] , [number] ) ] [EOL] print ( [string] ) [EOL] utils = ( [number] , [number] ) [EOL] [EOL] base_folder = pkg_resources . resource_filename ( [string] , resource_name = [string] ) [EOL] neg , agent_info , issues = load_genius_domain_from_folder ( base_folder , keep_issue_names = True , keep_value_names = True , ) [EOL] if neg is None : [EOL] raise ValueError ( f" [string] { base_folder }" ) [EOL] atlas = GeniusNegotiator ( java_class_name = agent_name1 , domain_file_name = base_folder + [string] , utility_file_name = base_folder + f" [string] { utils [ [number] ] } [string] " , keep_issue_names = True , keep_value_names = True , ) [EOL] agentx = GeniusNegotiator ( java_class_name = agent_name2 , domain_file_name = base_folder + [string] , utility_file_name = base_folder + f" [string] { utils [ [number] ] } [string] " , keep_issue_names = True , keep_value_names = True , ) [EOL] neg . add ( atlas ) [EOL] neg . add ( agentx ) [EOL] neg . run ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] pytest . main ( args = [ __file__ ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List [EOL] import typing [EOL] import pathlib [EOL] import negmas [EOL] from datetime import timedelta [EOL] from pathlib import Path , PosixPath [EOL] [EOL] import hypothesis . strategies as st [EOL] from hypothesis import example , given , settings [EOL] [EOL] from negmas import AspirationNegotiator , MappingUtilityFunction , SAOMechanism [EOL] from negmas . checkpoints import CheckpointRunner [EOL] from negmas . helpers import unique_name [EOL] [EOL] [EOL] def checkpoint_every ( args ) : [EOL] pass [EOL] [EOL] [EOL] @ given ( single_checkpoint = st . booleans ( ) , checkpoint_every = st . integers ( [number] , [number] ) , exist_ok = st . booleans ( ) , ) def test_can_run_from_checkpoint ( tmp_path , single_checkpoint , checkpoint_every , exist_ok ) : [EOL] import shutil [EOL] [EOL] new_folder = tmp_path / unique_name ( [string] , sep = [string] ) [EOL] second_folder = tmp_path / unique_name ( [string] , sep = [string] ) [EOL] new_folder . mkdir ( parents = True , exist_ok = True ) [EOL] shutil . rmtree ( new_folder ) [EOL] new_folder . mkdir ( parents = True , exist_ok = True ) [EOL] filename = [string] [EOL] second_folder . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] n_outcomes , n_negotiators = [number] , [number] [EOL] n_steps = [number] [EOL] mechanism = SAOMechanism ( outcomes = n_outcomes , n_steps = n_steps , offering_is_accepting = True , avoid_ultimatum = False , checkpoint_every = checkpoint_every , checkpoint_folder = new_folder , checkpoint_filename = filename , extra_checkpoint_info = None , exist_ok = exist_ok , single_checkpoint = single_checkpoint , ) [EOL] ufuns = MappingUtilityFunction . generate_random ( n_negotiators , outcomes = n_outcomes ) [EOL] for i in range ( n_negotiators ) : [EOL] mechanism . add ( AspirationNegotiator ( name = f" [string] { i }" ) , ufun = ufuns [ i ] ) [EOL] [EOL] mechanism . run ( ) [EOL] files = list ( new_folder . glob ( [string] ) ) [EOL] if [number] < checkpoint_every <= n_steps : [EOL] if single_checkpoint : [EOL] assert len ( list ( new_folder . glob ( [string] ) ) ) == [number] [EOL] else : [EOL] assert len ( list ( new_folder . glob ( [string] ) ) ) >= [number] * ( max ( [number] , mechanism . state . step // checkpoint_every ) ) [EOL] elif checkpoint_every > n_steps : [EOL] assert len ( list ( new_folder . glob ( [string] ) ) ) == [number] [EOL] else : [EOL] assert len ( list ( new_folder . glob ( [string] ) ) ) == [number] [EOL] [EOL] runner = CheckpointRunner ( folder = new_folder ) [EOL] [EOL] assert len ( runner . steps ) * [number] == len ( files ) [EOL] assert runner . current_step == - [number] [EOL] assert runner . loaded_object is None [EOL] [EOL] runner . step ( ) [EOL] [EOL] assert runner . current_step == ( [number] if not single_checkpoint else runner . steps [ - [number] ] ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . reset ( ) [EOL] assert len ( runner . steps ) * [number] == len ( files ) [EOL] assert runner . current_step == - [number] [EOL] assert runner . loaded_object is None [EOL] [EOL] runner . goto ( runner . last_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . goto ( runner . next_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . goto ( runner . previous_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . goto ( runner . first_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . reset ( ) [EOL] [EOL] runner . run ( ) [EOL] [EOL] [EOL] @ given ( checkpoint_every = st . integers ( [number] , [number] ) , exist_ok = st . booleans ( ) , copy = st . booleans ( ) , fork_after_reset = st . booleans ( ) , ) @ settings ( deadline = [number] , max_examples = [number] ) def test_can_run_from_checkpoint ( tmp_path , checkpoint_every , exist_ok , copy , fork_after_reset ) : [EOL] import shutil [EOL] [EOL] new_folder = tmp_path / unique_name ( [string] , sep = [string] ) [EOL] second_folder = tmp_path / unique_name ( [string] , sep = [string] ) [EOL] new_folder . mkdir ( parents = True , exist_ok = True ) [EOL] shutil . rmtree ( new_folder ) [EOL] new_folder . mkdir ( parents = True , exist_ok = True ) [EOL] second_folder . mkdir ( parents = True , exist_ok = True ) [EOL] shutil . rmtree ( second_folder ) [EOL] second_folder . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] filename = [string] [EOL] [EOL] n_outcomes , n_negotiators = [number] , [number] [EOL] n_steps = [number] [EOL] mechanism = SAOMechanism ( outcomes = n_outcomes , n_steps = n_steps , offering_is_accepting = True , avoid_ultimatum = False , checkpoint_every = checkpoint_every , checkpoint_folder = new_folder , checkpoint_filename = filename , extra_checkpoint_info = None , exist_ok = exist_ok , single_checkpoint = False , ) [EOL] ufuns = MappingUtilityFunction . generate_random ( n_negotiators , outcomes = n_outcomes ) [EOL] for i in range ( n_negotiators ) : [EOL] mechanism . add ( AspirationNegotiator ( name = f" [string] { i }" ) , ufun = ufuns [ i ] , aspiration_type = [string] , ) [EOL] [EOL] mechanism . run ( ) [EOL] files = list ( new_folder . glob ( [string] ) ) [EOL] if [number] < checkpoint_every <= n_steps : [EOL] assert len ( list ( new_folder . glob ( [string] ) ) ) >= [number] * ( max ( [number] , mechanism . state . step // checkpoint_every ) ) [EOL] elif checkpoint_every > n_steps : [EOL] assert len ( list ( new_folder . glob ( [string] ) ) ) == [number] [EOL] else : [EOL] assert len ( list ( new_folder . glob ( [string] ) ) ) == [number] [EOL] [EOL] runner = CheckpointRunner ( folder = new_folder ) [EOL] [EOL] assert len ( runner . steps ) * [number] == len ( files ) [EOL] assert runner . current_step == - [number] [EOL] assert runner . loaded_object is None [EOL] [EOL] runner . step ( ) [EOL] [EOL] assert runner . current_step == [number] [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . reset ( ) [EOL] assert len ( runner . steps ) * [number] == len ( files ) [EOL] assert runner . current_step == - [number] [EOL] assert runner . loaded_object is None [EOL] [EOL] runner . goto ( runner . last_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . goto ( runner . next_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . goto ( runner . previous_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . goto ( runner . first_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . reset ( ) [EOL] [EOL] if fork_after_reset : [EOL] m = runner . fork ( copy_past_checkpoints = copy , folder = second_folder ) [EOL] assert m is None [EOL] return [EOL] runner . step ( ) [EOL] m = runner . fork ( copy_past_checkpoints = copy , folder = second_folder ) [EOL] [EOL] if copy : [EOL] step = runner . current_step [EOL] assert len ( list ( second_folder . glob ( [string] ) ) ) >= [number] [EOL] assert len ( list ( second_folder . glob ( f" [string] { step } [string] " ) ) ) > [number] [EOL] else : [EOL] assert len ( list ( second_folder . glob ( [string] ) ) ) == [number] [EOL] [EOL] assert isinstance ( m , SAOMechanism ) [EOL] step = m . current_step [EOL] m . step ( ) [EOL] assert m . current_step == step + [number] [EOL] [EOL] state = m . run ( ) [EOL] assert state . agreement is not None [EOL] [EOL] runner . reset ( ) [EOL] assert len ( runner . steps ) * [number] == len ( files ) [EOL] assert runner . current_step == - [number] [EOL] assert runner . loaded_object is None [EOL] [EOL] runner . goto ( runner . last_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . goto ( runner . next_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . goto ( runner . previous_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . goto ( runner . first_step , exact = True ) [EOL] assert isinstance ( runner . loaded_object , SAOMechanism ) [EOL] assert runner . loaded_object . state . step == runner . current_step [EOL] [EOL] runner . reset ( ) [EOL] [EOL] runner . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0