[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from collections import defaultdict [EOL] [EOL] import click [EOL] [EOL] from mygeotab import API , dates [EOL] from mygeotab . ext import feed [EOL] [EOL] [EOL] class ExceptionDataFeedListener ( feed . DataFeedListener ) : [EOL] def __init__ ( self , api ) : [EOL] [docstring] [EOL] self . api = api [EOL] self . _cache = defaultdict ( dict ) [EOL] super ( feed . DataFeedListener , self ) . __init__ ( ) [EOL] [EOL] def _populate_sub_entity ( self , entity , type_name ) : [EOL] [docstring] [EOL] key = type_name . lower ( ) [EOL] if isinstance ( entity [ key ] , str ) : [EOL] [comment] [EOL] entity [ key ] = dict ( id = entity [ key ] ) [EOL] return [EOL] cache = self . _cache [ key ] [EOL] subentity = cache . get ( entity [ key ] [ [string] ] ) [EOL] if not subentity : [EOL] subentities = self . api . get ( type_name , id = entity [ key ] [ [string] ] , results_limit = [number] ) [EOL] if len ( subentities ) > [number] : [EOL] subentity = subentities [ [number] ] [EOL] entity [ key ] = subentity [EOL] else : [EOL] entity [ key ] = subentity [EOL] [EOL] def on_data ( self , data ) : [EOL] [docstring] [EOL] for d in data : [EOL] self . _populate_sub_entity ( d , [string] ) [EOL] self . _populate_sub_entity ( d , [string] ) [EOL] date = dates . localize_datetime ( d [ [string] ] ) [EOL] click . echo ( [string] . format ( date = date , device = d [ [string] ] . get ( [string] , [string] ) , rule = d [ [string] ] . get ( [string] , [string] ) , ) ) [EOL] [EOL] def on_error ( self , error ) : [EOL] [docstring] [EOL] click . secho ( error , fg = [string] ) [EOL] return True [EOL] [EOL] [EOL] @ click . command ( help = [string] ) @ click . argument ( [string] , nargs = [number] , required = True ) @ click . option ( [string] , [string] , prompt = True , help = [string] ) @ click . option ( [string] , [string] , prompt = True , hide_input = True , help = [string] ) @ click . option ( [string] , default = None , help = [string] ) @ click . option ( [string] , [string] , type = click . IntRange ( [number] , [number] ) , default = [number] , help = [string] , ) def main ( database , user = None , password = None , server = None , interval = [number] ) : [EOL] api = API ( database = database , username = user , password = password , server = server ) [EOL] api . authenticate ( ) [EOL] feed . DataFeed ( api , ExceptionDataFeedListener ( api ) , [string] , interval = interval ) . start ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] class MyGeotabException ( IOError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , full_error , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . _full_error = full_error [EOL] main_error = full_error [ [string] ] [ [number] ] [EOL] self . name = main_error [ [string] ] [EOL] self . message = main_error [ [string] ] [EOL] self . data = main_error . get ( [string] ) [EOL] self . stack_trace = main_error . get ( [string] ) [EOL] super ( MyGeotabException , self ) . __init__ ( self . message , * args , ** kwargs ) [EOL] [EOL] def __str__ ( self ) : [EOL] error_str = [string] . format ( self . name , self . message ) [EOL] if self . stack_trace : [EOL] error_str += [string] . format ( self . stack_trace ) [EOL] return error_str [EOL] [EOL] [EOL] class AuthenticationException ( IOError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , username , database , server , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . username = username [EOL] self . database = database [EOL] self . server = server [EOL] super ( AuthenticationException , self ) . __init__ ( self . message , * args , ** kwargs ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . message [EOL] [EOL] @ property def message ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . username , self . server , self . database ) [EOL] [EOL] [EOL] class TimeoutException ( IOError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , server , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . server = server [EOL] super ( TimeoutException , self ) . __init__ ( self . message , * args , ** kwargs ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . message [EOL] [EOL] @ property def message ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . server ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import configparser [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os . path [EOL] [EOL] import sys [EOL] [EOL] import click [EOL] [EOL] import mygeotab [EOL] import mygeotab . api [EOL] import mygeotab . dates [EOL] [EOL] from six . moves import configparser [EOL] [EOL] [EOL] class Session ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . credentials = None [EOL] [EOL] @ staticmethod def _get_config_file ( ) : [EOL] config_path = click . get_app_dir ( mygeotab . __title__ ) [EOL] if not os . path . exists ( config_path ) : [EOL] os . makedirs ( config_path ) [EOL] return os . path . join ( config_path , [string] ) [EOL] [EOL] @ staticmethod def _section_name ( database ) : [EOL] return [string] . format ( database ) [EOL] [EOL] @ staticmethod def session_names ( config ) : [EOL] if not config : [EOL] return [ ] [EOL] names = [ ] [EOL] section_names = config . sections ( ) [EOL] for name in section_names : [EOL] if [string] in name : [EOL] names . append ( name . split ( [string] ) [ - [number] ] ) [EOL] return names [EOL] [EOL] def save ( self ) : [EOL] if not self . credentials : [EOL] return [EOL] config = configparser . ConfigParser ( ) [EOL] config . read ( self . _get_config_file ( ) ) [EOL] database = self . credentials . database [EOL] [EOL] section_name = self . _section_name ( database ) [EOL] if section_name not in config . sections ( ) : [EOL] config . add_section ( section_name ) [EOL] config . set ( section_name , [string] , self . credentials . username ) [EOL] config . set ( section_name , [string] , self . credentials . session_id ) [EOL] config . set ( section_name , [string] , self . credentials . database ) [EOL] config . set ( section_name , [string] , self . credentials . server ) [EOL] [EOL] with open ( self . _get_config_file ( ) , [string] ) as configfile : [EOL] config . write ( configfile ) [EOL] [EOL] def load ( self , name = None ) : [EOL] config = configparser . ConfigParser ( ) [EOL] config . read ( self . _get_config_file ( ) ) [EOL] try : [EOL] if name is None : [EOL] sections = config . sections ( ) [EOL] if len ( sections ) < [number] : [EOL] self . credentials = None [EOL] return [EOL] section_name = sections [ - [number] ] [EOL] else : [EOL] section_name = self . _section_name ( name ) [EOL] username = config . get ( section_name , [string] ) [EOL] session_id = config . get ( section_name , [string] ) [EOL] database = config . get ( section_name , [string] ) [EOL] server = config . get ( section_name , [string] ) [EOL] self . credentials = mygeotab . Credentials ( username , session_id , database , server ) [EOL] except configparser . NoSectionError : [EOL] self . credentials = None [EOL] except configparser . NoOptionError : [EOL] self . credentials = None [EOL] [EOL] def get_sessions ( self ) : [EOL] config = configparser . ConfigParser ( ) [EOL] config . read ( self . _get_config_file ( ) ) [EOL] return self . session_names ( config ) [EOL] [EOL] def get_api ( self ) : [EOL] if self . credentials : [EOL] return mygeotab . API . from_credentials ( self . credentials ) [EOL] return None [EOL] [EOL] def login ( self , username , password = None , database = None , server = None ) : [EOL] if server : [EOL] api = mygeotab . API ( username = username , password = password , database = database , server = server ) [EOL] else : [EOL] api = mygeotab . API ( username = username , password = password , database = database ) [EOL] self . credentials = api . authenticate ( ) [EOL] self . save ( ) [EOL] [EOL] def logout ( self ) : [EOL] if self . credentials : [EOL] database = self . credentials . database [EOL] section_name = self . _section_name ( database ) [EOL] config = configparser . ConfigParser ( ) [EOL] config . read ( self . _get_config_file ( ) ) [EOL] config . remove_section ( section_name ) [EOL] with open ( self . _get_config_file ( ) , [string] ) as configfile : [EOL] config . write ( configfile ) [EOL] self . credentials = None [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def login ( session , user , password , database = None , server = None ) : [EOL] [docstring] [EOL] if not user : [EOL] user = click . prompt ( [string] , type = str ) [EOL] if not password : [EOL] password = click . prompt ( [string] , hide_input = True , type = str ) [EOL] try : [EOL] with click . progressbar ( length = [number] , label = [string] ) as progressbar : [EOL] session . login ( user , password , database , server ) [EOL] progressbar . update ( [number] ) [EOL] if session . credentials : [EOL] click . echo ( [string] % session . credentials ) [EOL] session . load ( database ) [EOL] return session . get_api ( ) [EOL] except mygeotab . AuthenticationException : [EOL] click . echo ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] @ click . group ( invoke_without_command = True , help = [string] ) @ click . pass_obj def sessions ( session ) : [EOL] [docstring] [EOL] active_sessions = session . get_sessions ( ) [EOL] if not active_sessions : [EOL] click . echo ( [string] ) [EOL] return [EOL] for active_session in active_sessions : [EOL] click . echo ( active_session ) [EOL] [EOL] [EOL] @ click . command ( help = [string] ) @ click . argument ( [string] , nargs = [number] , required = True ) @ click . pass_obj def remove ( session , database ) : [EOL] [docstring] [EOL] session . load ( database ) [EOL] session . logout ( ) [EOL] [EOL] [EOL] @ click . command ( help = [string] ) @ click . argument ( [string] , nargs = [number] , required = False ) @ click . option ( [string] , [string] ) @ click . option ( [string] , [string] ) @ click . option ( [string] , default = None , help = [string] ) @ click . pass_obj def console ( session , database = None , user = None , password = None , server = None ) : [EOL] [docstring] [EOL] local_vars = _populate_locals ( database , password , server , session , user ) [EOL] version = [string] . format ( mygeotab . __version__ , sys . version . replace ( [string] , [string] ) ) [EOL] auth_line = ( [string] % session . credentials ) if session . credentials else [string] [EOL] banner = [string] . join ( [ version , auth_line ] ) [EOL] try : [EOL] from IPython import embed [EOL] [EOL] embed ( banner1 = banner , user_ns = local_vars ) [EOL] except ImportError : [EOL] import code [EOL] [EOL] code . interact ( banner , local = local_vars ) [EOL] [EOL] [EOL] @ click . group ( ) @ click . version_option ( ) @ click . pass_context def main ( ctx ) : [EOL] [docstring] [EOL] ctx . obj = Session ( ) [EOL] try : [EOL] ctx . obj . load ( ) [EOL] except IOError : [EOL] pass [EOL] [EOL] [EOL] def _populate_locals ( database , password , server , session , user ) : [EOL] if not session . credentials : [EOL] login ( session , user , password , database , server ) [EOL] session . load ( database ) [EOL] api = session . get_api ( ) [EOL] if not api : [EOL] [comment] [EOL] api = login ( session , user , password , database , server ) [EOL] try : [EOL] api . get ( [string] , name = session . credentials . username ) [EOL] except mygeotab . AuthenticationException : [EOL] [comment] [EOL] click . echo ( [string] ) [EOL] api = login ( session , user , password , database , server ) [EOL] return dict ( myg = api , mygeotab = mygeotab , dates = mygeotab . dates ) [EOL] [EOL] [EOL] main . add_command ( console ) [EOL] sessions . add_command ( remove ) [EOL] main . add_command ( sessions ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 $typing.Any$ 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $six.moves.configparser.ConfigParser$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $six.moves.configparser.ConfigParser$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $six.moves.configparser.ConfigParser$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $six.moves.configparser.ConfigParser$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $six.moves.configparser.ConfigParser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $six.moves.configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Pattern [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] [EOL] import arrow [EOL] import six [EOL] [EOL] use_rapidjson = False [EOL] try : [EOL] import rapidjson [EOL] [EOL] DATETIME_MODE = rapidjson . DM_SHIFT_TO_UTC | rapidjson . DM_ISO8601 [EOL] [EOL] use_rapidjson = True [EOL] except ImportError : [EOL] pass [EOL] import json [EOL] [EOL] from mygeotab import dates [EOL] [EOL] DATETIME_REGEX = re . compile ( [string] ) [EOL] [EOL] [EOL] def json_serialize ( obj ) : [EOL] if use_rapidjson : [EOL] return rapidjson . dumps ( obj , default = object_serializer ) [EOL] return json . dumps ( obj , default = object_serializer , separators = ( [string] , [string] ) ) [EOL] [EOL] [EOL] def json_deserialize ( json_str ) : [EOL] if use_rapidjson : [EOL] return rapidjson . loads ( json_str , datetime_mode = DATETIME_MODE ) [EOL] return json . loads ( json_str , object_hook = object_deserializer ) [EOL] [EOL] [EOL] def object_serializer ( obj ) : [EOL] [docstring] [EOL] return dates . format_iso_datetime ( obj ) if hasattr ( obj , [string] ) else obj [EOL] [EOL] [EOL] def object_deserializer ( obj ) : [EOL] [docstring] [EOL] for key , val in obj . items ( ) : [EOL] if isinstance ( val , six . string_types ) and DATETIME_REGEX . search ( val ) : [EOL] try : [EOL] obj [ key ] = dates . localize_datetime ( arrow . get ( val ) . datetime ) [EOL] except ( ValueError , arrow . parser . ParserError ) : [EOL] obj [ key ] = val [EOL] return obj [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import warnings [EOL] [EOL] from . . py3 . api_async import API [EOL] from . . api import MyGeotabException , AuthenticationException , Credentials [EOL] [EOL] warnings . warn ( [string] , DeprecationWarning , ) [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [EOL] from typing import List , Any , Literal , Dict [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] import sys [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] raise Exception ( [string] ) [EOL] import ssl [EOL] from concurrent . futures import TimeoutError [EOL] [EOL] import aiohttp [EOL] [EOL] from mygeotab import api [EOL] from mygeotab . api import DEFAULT_TIMEOUT , get_headers [EOL] from mygeotab . exceptions import MyGeotabException , TimeoutException , AuthenticationException [EOL] from mygeotab . serializers import json_serialize , json_deserialize [EOL] [EOL] [EOL] class API ( api . API ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , username , password = None , database = None , session_id = None , server = [string] , timeout = DEFAULT_TIMEOUT ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( username , password , database , session_id , server , timeout ) [EOL] [EOL] async def call_async ( self , method , ** parameters ) : [EOL] [docstring] [EOL] if method is None : [EOL] raise Exception ( [string] ) [EOL] params = api . process_parameters ( parameters ) [EOL] if self . credentials and not self . credentials . session_id : [EOL] self . authenticate ( ) [EOL] if [string] not in params and self . credentials . session_id : [EOL] params [ [string] ] = self . credentials . get_param ( ) [EOL] [EOL] try : [EOL] result = await _query ( self . _server , method , params , verify_ssl = self . _is_verify_ssl ) [EOL] if result is not None : [EOL] self . __reauthorize_count = [number] [EOL] return result [EOL] except MyGeotabException as exception : [EOL] if exception . name == [string] : [EOL] if self . __reauthorize_count == [number] and self . credentials . password : [EOL] self . __reauthorize_count += [number] [EOL] self . authenticate ( ) [EOL] return await self . call_async ( method , ** parameters ) [EOL] else : [EOL] raise AuthenticationException ( self . credentials . username , self . credentials . database , self . credentials . server ) [EOL] raise [EOL] [EOL] async def multi_call_async ( self , calls ) : [EOL] [docstring] [EOL] formatted_calls = [ dict ( method = call [ [number] ] , params = call [ [number] ] if len ( call ) > [number] else { } ) for call in calls ] [EOL] return await self . call_async ( [string] , calls = formatted_calls ) [EOL] [EOL] async def get_async ( self , type_name , ** parameters ) : [EOL] [docstring] [EOL] if parameters : [EOL] results_limit = parameters . get ( [string] , None ) [EOL] if results_limit is not None : [EOL] del parameters [ [string] ] [EOL] if [string] in parameters : [EOL] parameters . update ( parameters [ [string] ] ) [EOL] parameters = dict ( search = parameters , resultsLimit = results_limit ) [EOL] return await self . call_async ( [string] , type_name = type_name , ** parameters ) [EOL] [EOL] async def add_async ( self , type_name , entity ) : [EOL] [docstring] [EOL] return await self . call_async ( [string] , type_name = type_name , entity = entity ) [EOL] [EOL] async def set_async ( self , type_name , entity ) : [EOL] [docstring] [EOL] return await self . call_async ( [string] , type_name = type_name , entity = entity ) [EOL] [EOL] async def remove_async ( self , type_name , entity ) : [EOL] [docstring] [EOL] return await self . call_async ( [string] , type_name = type_name , entity = entity ) [EOL] [EOL] @ staticmethod def from_credentials ( credentials ) : [EOL] [docstring] [EOL] return API ( username = credentials . username , password = credentials . password , database = credentials . database , session_id = credentials . session_id , server = credentials . server , ) [EOL] [EOL] [EOL] async def server_call_async ( method , server , timeout = DEFAULT_TIMEOUT , verify_ssl = True , ** parameters ) : [EOL] [docstring] [EOL] if method is None : [EOL] raise Exception ( [string] ) [EOL] if server is None : [EOL] raise Exception ( [string] ) [EOL] parameters = api . process_parameters ( parameters ) [EOL] return await _query ( server , method , parameters , timeout = timeout , verify_ssl = verify_ssl ) [EOL] [EOL] [EOL] async def _query ( server , method , parameters , timeout = DEFAULT_TIMEOUT , verify_ssl = True ) : [EOL] [docstring] [EOL] api_endpoint = api . get_api_url ( server ) [EOL] params = dict ( id = - [number] , method = method , params = parameters ) [EOL] headers = get_headers ( ) [EOL] conn = aiohttp . TCPConnector ( ssl = ssl . SSLContext ( ssl . PROTOCOL_TLSv1_2 ) if verify_ssl else False ) [EOL] try : [EOL] async with aiohttp . ClientSession ( connector = conn ) as session : [EOL] response = await session . post ( api_endpoint , data = json_serialize ( params ) , headers = headers , timeout = timeout , allow_redirects = True ) [EOL] response . raise_for_status ( ) [EOL] content_type = response . headers . get ( [string] ) [EOL] body = await response . text ( ) [EOL] except TimeoutError : [EOL] raise TimeoutException ( server ) [EOL] if content_type and [string] not in content_type . lower ( ) : [EOL] return body [EOL] return api . _process ( json_deserialize ( body ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import threading [EOL] import typing [EOL] import threading [EOL] [EOL] [EOL] class TestAsyncThreadImport : [EOL] def test_thread_import ( self ) : [EOL] def thread_func ( results ) : [EOL] try : [EOL] import mygeotab [EOL] [EOL] mygeotab . API ( [string] , session_id = [string] ) [EOL] results . append ( None ) [EOL] except Exception as e : [EOL] results . append ( e ) [EOL] [EOL] results = [ ] [EOL] thread = threading . Thread ( target = thread_func , args = ( results , ) ) [EOL] thread . start ( ) [EOL] thread . join ( ) [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $threading.Thread$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Any , Union , Dict , List [EOL] import typing [EOL] import mygeotab [EOL] import os [EOL] import sys [EOL] [EOL] import pytest [EOL] [EOL] from mygeotab import api [EOL] from mygeotab . exceptions import TimeoutException [EOL] [EOL] USERNAME = os . environ . get ( [string] ) [EOL] PASSWORD = os . environ . get ( [string] ) [EOL] DATABASE = os . environ . get ( [string] ) [EOL] TRAILER_NAME = [string] [EOL] [EOL] pytestmark = pytest . mark . skipif ( sys . version_info < ( [number] , [number] ) , reason = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def populated_api ( ) : [EOL] if USERNAME and PASSWORD : [EOL] session = api . API ( USERNAME , password = PASSWORD , database = DATABASE , server = None ) [EOL] try : [EOL] session . authenticate ( ) [EOL] except api . MyGeotabException as exception : [EOL] pytest . fail ( exception ) [EOL] return [EOL] yield session [EOL] else : [EOL] pytest . skip ( [string] [string] [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def populated_api_entity ( populated_api ) : [EOL] def clean_trailers ( ) : [EOL] try : [EOL] trailers = populated_api . get ( [string] , name = TRAILER_NAME ) [EOL] for trailer in trailers : [EOL] populated_api . remove ( [string] , trailer ) [EOL] except Exception : [EOL] pass [EOL] [EOL] clean_trailers ( ) [EOL] yield populated_api [EOL] clean_trailers ( ) [EOL] [EOL] [EOL] class TestCallApi : [EOL] def test_get_version ( self , populated_api ) : [EOL] version = populated_api . call ( [string] ) [EOL] version_split = version . split ( [string] ) [EOL] assert len ( version_split ) == [number] [EOL] [EOL] def test_get_user ( self , populated_api ) : [EOL] user = populated_api . get ( [string] , name = USERNAME ) [EOL] assert len ( user ) == [number] [EOL] user = user [ [number] ] [EOL] assert user [ [string] ] == USERNAME [EOL] [EOL] def test_multi_call ( self , populated_api ) : [EOL] calls = [ [ [string] , dict ( typeName = [string] , search = dict ( name = [string] . format ( USERNAME ) ) ) ] , [ [string] ] ] [EOL] results = populated_api . multi_call ( calls ) [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] is not None [EOL] assert len ( results [ [number] ] ) == [number] [EOL] assert results [ [number] ] [ [number] ] [ [string] ] == USERNAME [EOL] assert results [ [number] ] is not None [EOL] version_split = results [ [number] ] . split ( [string] ) [EOL] assert len ( version_split ) == [number] [EOL] [EOL] def test_pythonic_parameters ( self , populated_api ) : [EOL] users = populated_api . get ( [string] ) [EOL] count_users = populated_api . call ( [string] , type_name = [string] ) [EOL] assert len ( count_users ) >= [number] [EOL] assert len ( count_users ) == len ( users ) [EOL] [EOL] def test_api_from_credentials ( self , populated_api ) : [EOL] new_api = api . API . from_credentials ( populated_api . credentials ) [EOL] users = new_api . get ( [string] ) [EOL] assert len ( users ) >= [number] [EOL] [EOL] def test_results_limit ( self , populated_api ) : [EOL] users = populated_api . get ( [string] , resultsLimit = [number] ) [EOL] assert len ( users ) == [number] [EOL] [EOL] def test_session_expired ( self , populated_api ) : [EOL] credentials = populated_api . credentials [EOL] credentials . password = PASSWORD [EOL] credentials . session_id = [string] [EOL] test_api = api . API . from_credentials ( credentials ) [EOL] users = test_api . get ( [string] ) [EOL] assert len ( users ) >= [number] [EOL] [EOL] def test_missing_method ( self , populated_api ) : [EOL] with pytest . raises ( Exception ) : [EOL] populated_api . call ( None ) [EOL] [EOL] def test_call_without_credentials ( self ) : [EOL] if not ( USERNAME and PASSWORD ) : [EOL] pytest . skip ( [string] [string] [string] ) [EOL] new_api = api . API ( USERNAME , password = PASSWORD , database = DATABASE , server = None ) [EOL] user = new_api . get ( [string] , name = [string] . format ( USERNAME ) ) [EOL] assert len ( user ) == [number] [EOL] [EOL] def test_bad_parameters ( self , populated_api ) : [EOL] with pytest . raises ( api . MyGeotabException ) as excinfo : [EOL] populated_api . call ( [string] , not_a_property = [string] ) [EOL] assert [string] in str ( excinfo . value ) [EOL] [EOL] def test_get_search_parameter ( self , populated_api ) : [EOL] user = populated_api . get ( [string] , search = dict ( name = USERNAME ) ) [EOL] assert len ( user ) == [number] [EOL] user = user [ [number] ] [EOL] assert user [ [string] ] == USERNAME [EOL] [EOL] [EOL] class TestEntity : [EOL] def test_add_edit_remove ( self , populated_api_entity ) : [EOL] def get_trailer ( ) : [EOL] trailers = populated_api_entity . get ( [string] , name = TRAILER_NAME ) [EOL] assert len ( trailers ) == [number] [EOL] return trailers [ [number] ] [EOL] [EOL] user = populated_api_entity . get ( [string] , name = USERNAME ) [ [number] ] [EOL] trailer = { [string] : TRAILER_NAME , [string] : user [ [string] ] } [EOL] trailer [ [string] ] = populated_api_entity . add ( [string] , trailer ) [EOL] assert trailer [ [string] ] is not None [EOL] trailer = get_trailer ( ) [EOL] assert trailer [ [string] ] == TRAILER_NAME [EOL] comment = [string] [EOL] trailer [ [string] ] = comment [EOL] populated_api_entity . set ( [string] , trailer ) [EOL] trailer = get_trailer ( ) [EOL] assert trailer [ [string] ] == comment [EOL] populated_api_entity . remove ( [string] , trailer ) [EOL] trailers = populated_api_entity . get ( [string] , name = TRAILER_NAME ) [EOL] assert len ( trailers ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . skipif ( USERNAME is None or DATABASE is None , reason = ( [string] [string] ) , ) class TestAuthentication : [EOL] def test_invalid_session ( self ) : [EOL] test_api = api . API ( USERNAME , session_id = [string] , database = DATABASE ) [EOL] assert USERNAME in str ( test_api . credentials ) [EOL] assert DATABASE in str ( test_api . credentials ) [EOL] with pytest . raises ( api . AuthenticationException ) as excinfo : [EOL] test_api . get ( [string] ) [EOL] assert [string] in str ( excinfo . value ) [EOL] assert DATABASE in str ( excinfo . value ) [EOL] assert USERNAME in str ( excinfo . value ) [EOL] [EOL] def test_auth_exception ( self ) : [EOL] test_api = api . API ( USERNAME , password = [string] , database = [string] ) [EOL] with pytest . raises ( api . MyGeotabException ) as excinfo : [EOL] test_api . authenticate ( False ) [EOL] assert excinfo . value . name == [string] [EOL] [EOL] def test_username_password_exists ( self ) : [EOL] with pytest . raises ( Exception ) as excinfo1 : [EOL] api . API ( None ) [EOL] with pytest . raises ( Exception ) as excinfo2 : [EOL] api . API ( USERNAME ) [EOL] assert [string] in str ( excinfo1 . value ) [EOL] assert [string] in str ( excinfo2 . value ) [EOL] [EOL] [EOL] class TestServerCallApi : [EOL] def test_get_version ( self ) : [EOL] version = api . server_call ( [string] , server = [string] ) [EOL] version_split = version . split ( [string] ) [EOL] assert len ( version_split ) == [number] [EOL] [EOL] def test_invalid_server_call ( self ) : [EOL] with pytest . raises ( Exception ) as excinfo1 : [EOL] api . server_call ( None , None ) [EOL] with pytest . raises ( Exception ) as excinfo2 : [EOL] api . server_call ( [string] , None ) [EOL] assert [string] in str ( excinfo1 . value ) [EOL] assert [string] in str ( excinfo2 . value ) [EOL] [EOL] def test_timeout ( self ) : [EOL] with pytest . raises ( TimeoutException ) as excinfo : [EOL] api . server_call ( [string] , server = [string] , timeout = [number] ) [EOL] assert [string] in str ( excinfo . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $mygeotab.api.API$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Union , Dict , Literal , List [EOL] import typing [EOL] import mygeotab [EOL] import typing_extensions [EOL] import os [EOL] import sys [EOL] [EOL] import pytest [EOL] [EOL] from mygeotab import api [EOL] [EOL] [EOL] class TestAttributes : [EOL] def test_should_verify_ssl ( self ) : [EOL] my_api = api . API ( [string] , session_id = [number] , server = [string] ) [EOL] assert my_api . _is_verify_ssl is True [EOL] my_api = api . API ( [string] , session_id = [number] , server = [string] ) [EOL] assert my_api . _is_verify_ssl is False [EOL] my_api = api . API ( [string] , session_id = [number] , server = [string] ) [EOL] assert my_api . _is_verify_ssl is False [EOL] [EOL] [EOL] class TestProcessParameters : [EOL] def test_camel_case_transformer ( self ) : [EOL] params = dict ( search = dict ( device_search = dict ( id = [number] ) , include_overlapped_trips = True ) ) [EOL] fixed_params = api . process_parameters ( params ) [EOL] assert fixed_params is not None [EOL] assert [string] in fixed_params [EOL] assert [string] in fixed_params [ [string] ] [EOL] assert [string] in fixed_params [ [string] ] [ [string] ] [EOL] assert fixed_params [ [string] ] [ [string] ] [ [string] ] == [number] [EOL] assert [string] in fixed_params [ [string] ] [EOL] assert fixed_params [ [string] ] [ [string] ] [EOL] [EOL] [EOL] class TestProcessResults : [EOL] def test_handle_server_exception ( self ) : [EOL] exception_response = dict ( error = dict ( errors = [ dict ( message = ( [string] [string] [string] [string] ) , name = [string] , stackTrace = ( [string] [string] [string] [string] [string] [string] [string] [string] [string] ) , ) ] , message = ( [string] [string] [string] [string] ) , name = [string] , ) , requestIndex = [number] , ) [EOL] with pytest . raises ( api . MyGeotabException ) as excinfo : [EOL] api . _process ( exception_response ) [EOL] ex = excinfo . value [EOL] assert ex . name == [string] [EOL] assert ex . message == ( [string] [string] [string] [string] ) [EOL] [EOL] def test_handle_server_results ( self ) : [EOL] results_response = { [string] : [ dict ( id = [string] , name = [string] ) ] } [EOL] result = api . _process ( results_response ) [EOL] assert len ( result ) == [number] [EOL] assert result [ [number] ] [ [string] ] == [string] [EOL] assert result [ [number] ] [ [string] ] == [string] [EOL] [EOL] def test_handle_none ( self ) : [EOL] result = api . _process ( None ) [EOL] assert result is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mygeotab.api.API$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing_extensions.Literal],builtins.bool]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing_extensions.Literal],builtins.bool]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from datetime import datetime [EOL] [EOL] import pytest [EOL] from six . moves import UserList [EOL] [EOL] from mygeotab . api import EntityList [EOL] [EOL] [EOL] class TestEntityList : [EOL] def test_create ( self ) : [EOL] type_name = [string] [EOL] entitylist = get_entitylist ( type_name ) [EOL] assert entitylist . type_name == type_name [EOL] [EOL] def test_get ( self ) : [EOL] entity_name = [string] [EOL] entitylist = get_entitylist ( second_device_name = entity_name ) [EOL] assert entitylist [ [number] ] [ [string] ] == entity_name [EOL] [EOL] def test_get_slice ( self ) : [EOL] entity_name = [string] [EOL] entitylist = get_entitylist ( second_device_name = entity_name ) [EOL] sliced_entitylist = entitylist [ [number] : ] [EOL] assert sliced_entitylist [ [number] ] [ [string] ] == entity_name [EOL] assert sliced_entitylist . type_name == [string] [EOL] [EOL] def test_add_entitylist ( self ) : [EOL] entitylist1 = get_entitylist ( ) [EOL] entitylist2 = get_entitylist ( ) [EOL] combined_entitylist = entitylist1 + entitylist2 [EOL] assert len ( combined_entitylist ) == len ( entitylist1 ) + len ( entitylist2 ) [EOL] assert combined_entitylist . type_name == [string] [EOL] [EOL] def test_sort_id ( self ) : [EOL] entitylist = get_entitylist ( ) [EOL] sorted_by_id = entitylist . sort_by ( [string] ) [EOL] assert sorted_by_id [ [number] ] [ [string] ] == [string] [EOL] assert sorted_by_id [ - [number] ] [ [string] ] == [string] [EOL] [EOL] def test_sort_id_reverse ( self ) : [EOL] entitylist = get_entitylist ( ) [EOL] sorted_by_id = entitylist . sort_by ( [string] , True ) [EOL] assert sorted_by_id [ [number] ] [ [string] ] == [string] [EOL] assert sorted_by_id [ - [number] ] [ [string] ] == [string] [EOL] [EOL] def test_sort_datetime ( self ) : [EOL] entitylist = get_entitylist ( ) [EOL] sorted_by_id = entitylist . sort_by ( [string] ) [EOL] assert sorted_by_id [ [number] ] [ [string] ] == datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert sorted_by_id [ - [number] ] [ [string] ] == datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] def test_sort_odometer ( self ) : [EOL] entitylist = get_entitylist ( ) [EOL] sorted_by_id = entitylist . sort_by ( [string] ) [EOL] assert sorted_by_id [ [number] ] [ [string] ] == [number] [EOL] assert sorted_by_id [ - [number] ] [ [string] ] == [number] [EOL] [EOL] def test_first_and_last ( self ) : [EOL] entitylist = get_entitylist ( ) [EOL] assert entitylist . first [ [string] ] == [string] [EOL] assert entitylist . last [ [string] ] == [string] [EOL] [EOL] def test_single_entity ( self ) : [EOL] entitylist = get_entitylist ( ) [EOL] with pytest . raises ( AssertionError ) : [EOL] assert entitylist . entity [ [string] ] == [string] [EOL] sub_entitylist = entitylist [ [number] : [number] ] [EOL] assert sub_entitylist . entity [ [string] ] == [string] [EOL] [EOL] def test_to_dataframe ( self ) : [EOL] entitylist = get_entitylist ( ) [EOL] dataframe = entitylist . to_dataframe ( ) [EOL] assert len ( dataframe ) == [number] [EOL] dataframe = entitylist . to_dataframe ( True ) [EOL] assert len ( dataframe ) == [number] [EOL] assert int ( dataframe [ [string] ] [ - [number] : ] ) == [number] [EOL] [EOL] [EOL] def get_entitylist ( type_name = [string] , second_device_name = [string] ) : [EOL] return EntityList ( [ { [string] : [string] , [string] : datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , [string] : [number] , [string] : [string] , } , { [string] : [string] , [string] : datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , [string] : [number] , [string] : second_device_name , } , { [string] : [string] , [string] : datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , [string] : [number] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] } , } , ] , type_name , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sys [EOL] [EOL] import requests_mock [EOL] import pytest [EOL] [EOL] from mygeotab import api , serializers [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def mock_api ( ) : [EOL] username = [string] [EOL] session_id = [number] [EOL] database = [string] [EOL] [EOL] yield api . API ( username , database = database , session_id = session_id , server = [string] ) [EOL] [EOL] [EOL] @ pytest . mark . skip ( [string] ) class TestApiPerformance : [EOL] @ pytest . mark . skipif ( sys . version_info < ( [number] , [number] ) , reason = [string] ) def test_timeout_large_json_rapidjson ( self , mock_api , datadir , benchmark ) : [EOL] server = [string] [EOL] json_response = ( datadir / [string] ) . read_text ( ) [EOL] [EOL] mock_api . timeout = [number] [EOL] [EOL] with requests_mock . mock ( ) as m : [EOL] m . post ( server , text = json_response ) [EOL] [EOL] benchmark ( mock_api . get , [string] ) [EOL] [EOL] def test_timeout_large_json ( self , mock_api , datadir , benchmark , monkeypatch ) : [EOL] server = [string] [EOL] json_response = ( datadir / [string] ) . read_text ( ) [EOL] [EOL] mock_api . timeout = [number] [EOL] [EOL] with requests_mock . mock ( ) as m : [EOL] m . post ( server , text = json_response ) [EOL] [EOL] monkeypatch . setattr ( serializers , [string] , False ) [EOL] [EOL] benchmark ( mock_api . get , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any , Dict , Union [EOL] import datetime [EOL] import typing [EOL] import pytz [EOL] import json [EOL] from datetime import date , datetime [EOL] [EOL] import pytz [EOL] [EOL] from mygeotab import serializers , dates [EOL] from mygeotab . serializers import json_serialize , json_deserialize [EOL] [EOL] [EOL] class TestSerialization : [EOL] def test_top_level_utc_datetime ( self ) : [EOL] data = dict ( dateTime = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] expected_str = [string] [EOL] data_str = json_serialize ( data ) [EOL] assert data_str == expected_str [EOL] [EOL] def test_top_level_zoned_datetime ( self ) : [EOL] est = pytz . timezone ( [string] ) [EOL] data = dict ( dateTime = est . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) ) [EOL] expected_str = [string] [EOL] data_str = json_serialize ( data ) [EOL] assert data_str == expected_str [EOL] [EOL] def test_min_datetime ( self ) : [EOL] data = dict ( dateTime = dates . MIN_DATE ) [EOL] expected_str = [string] [EOL] data_str = json_serialize ( data ) [EOL] assert data_str == expected_str [EOL] [EOL] def test_max_datetime ( self ) : [EOL] data = dict ( dateTime = dates . MAX_DATE ) [EOL] expected_str = [string] [EOL] data_str = json_serialize ( data ) [EOL] assert data_str == expected_str [EOL] [EOL] def test_only_date ( self ) : [EOL] this_date = date ( [number] , [number] , [number] ) [EOL] data = dict ( date = this_date ) [EOL] expected_str = [string] [EOL] data_str = json_serialize ( data ) [EOL] assert data_str == expected_str [EOL] [EOL] [EOL] class TestDeserialization : [EOL] def test_top_level_datetime ( self ) : [EOL] data_str = [string] [EOL] data = json_deserialize ( data_str ) [EOL] utc_date = data . get ( [string] ) [EOL] assert utc_date is not None [EOL] check_date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert utc_date . year == check_date . year [EOL] assert utc_date . month == check_date . month [EOL] assert utc_date . day == check_date . day [EOL] assert utc_date . hour == check_date . hour [EOL] assert utc_date . minute == check_date . minute [EOL] assert utc_date . second == check_date . second [EOL] [EOL] def test_second_level_datetime ( self ) : [EOL] data_str = [string] [EOL] data = json_deserialize ( data_str ) [EOL] assert len ( data ) == [number] [EOL] group = data [ [number] ] . get ( [string] ) [EOL] assert group is not None [EOL] utc_date = group . get ( [string] ) [EOL] assert utc_date is not None [EOL] check_date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert utc_date . year == check_date . year [EOL] assert utc_date . month == check_date . month [EOL] assert utc_date . day == check_date . day [EOL] assert utc_date . hour == check_date . hour [EOL] assert utc_date . minute == check_date . minute [EOL] assert utc_date . second == check_date . second [EOL] [EOL] def test_invalid_datetime ( self ) : [EOL] date_str = [string] [EOL] data_str = [string] . format ( date_str ) [EOL] data = json_deserialize ( data_str ) [EOL] utc_date = data . get ( [string] ) [EOL] assert utc_date is not None [EOL] assert utc_date == date_str [EOL] [EOL] def test_only_date ( self ) : [EOL] date_str = [string] [EOL] data_str = [string] . format ( date_str ) [EOL] data = json_deserialize ( data_str ) [EOL] utc_date = data . get ( [string] ) [EOL] assert utc_date is not None [EOL] check_date = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert utc_date . year == check_date . year [EOL] assert utc_date . month == check_date . month [EOL] assert utc_date . day == check_date . day [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,datetime.datetime]$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime]$ 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,datetime.datetime]$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.date.time.date$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.date.time.date]$ 0 0 0 0 0 $datetime.date.time.date$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,datetime.date.time.date]$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0
[comment] [EOL] [EOL] from typing import Any , Union [EOL] import datetime [EOL] import typing [EOL] import pytz [EOL] from datetime import datetime [EOL] [EOL] import pytz [EOL] [EOL] from mygeotab import dates [EOL] [EOL] [EOL] class TestGetUtcDate : [EOL] def test_naive_datetime_to_utc ( self ) : [EOL] date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] utc_date = dates . localize_datetime ( date , pytz . utc ) [EOL] assert utc_date . tzinfo is not None [EOL] assert utc_date . tzinfo is pytz . utc [EOL] assert utc_date . year == date . year [EOL] assert utc_date . month == date . month [EOL] assert utc_date . day == date . day [EOL] assert utc_date . hour == date . hour [EOL] [EOL] def test_utc_datetime_to_utc ( self ) : [EOL] date = pytz . utc . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] utc_date = dates . localize_datetime ( date , pytz . utc ) [EOL] assert utc_date . tzinfo is not None [EOL] assert utc_date . tzinfo is pytz . utc [EOL] assert utc_date . year == date . year [EOL] assert utc_date . month == date . month [EOL] assert utc_date . day == date . day [EOL] assert utc_date . hour == date . hour [EOL] [EOL] def test_zoned_datetime_to_utc ( self ) : [EOL] tz = pytz . timezone ( [string] ) [EOL] date = tz . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] utc_date = dates . localize_datetime ( date , pytz . utc ) [EOL] check_date = date . astimezone ( pytz . utc ) [EOL] assert utc_date . tzinfo is not None [EOL] assert utc_date . tzinfo is pytz . utc [EOL] assert utc_date . year == check_date . year [EOL] assert utc_date . month == check_date . month [EOL] assert utc_date . day == check_date . day [EOL] assert utc_date . hour == check_date . hour [EOL] [EOL] def test_zoned_min_datetime ( self ) : [EOL] tz_aus = pytz . timezone ( [string] ) [EOL] tz_est = pytz . timezone ( [string] ) [EOL] date = datetime ( [number] , [number] , [number] , tzinfo = tz_aus ) [EOL] est_date = dates . localize_datetime ( date , tz_est ) [EOL] check_date = dates . MIN_DATE [EOL] assert est_date . tzinfo is not None [EOL] assert est_date . year == check_date . year [EOL] assert est_date . month == check_date . month [EOL] assert est_date . day == check_date . day [EOL] assert est_date . hour == check_date . hour [EOL] [EOL] def test_zoned_max_datetime ( self ) : [EOL] tz_aus = pytz . timezone ( [string] ) [EOL] tz_est = pytz . timezone ( [string] ) [EOL] date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = tz_est ) [EOL] aus_date = dates . localize_datetime ( date , tz_aus ) [EOL] check_date = dates . MAX_DATE [EOL] assert aus_date . tzinfo is not None [EOL] assert aus_date . year == check_date . year [EOL] assert aus_date . month == check_date . month [EOL] assert aus_date . day == check_date . day [EOL] assert aus_date . hour == check_date . hour [EOL] [EOL] [EOL] class TestFormatIsoDate : [EOL] def test_format_naive_datetime ( self ) : [EOL] date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] check_fmt = [string] [EOL] fmt_date = dates . format_iso_datetime ( date ) [EOL] assert fmt_date == check_fmt [EOL] [EOL] def test_format_utc_datetime ( self ) : [EOL] date = pytz . utc . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] check_fmt = [string] [EOL] fmt_date = dates . format_iso_datetime ( date ) [EOL] assert fmt_date == check_fmt [EOL] [EOL] def test_format_local_datetime ( self ) : [EOL] est = pytz . timezone ( [string] ) [EOL] date = est . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] check_fmt = [string] [EOL] fmt_date = dates . format_iso_datetime ( date ) [EOL] assert fmt_date == check_fmt [EOL] [EOL] def test_format_far_past_date ( self ) : [EOL] date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] check_fmt = [string] [EOL] fmt_date = dates . format_iso_datetime ( date ) [EOL] assert fmt_date == check_fmt [EOL] [EOL] def test_format_far_past_date_utc ( self ) : [EOL] date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = pytz . utc ) [EOL] check_fmt = [string] [EOL] fmt_date = dates . format_iso_datetime ( date ) [EOL] assert fmt_date == check_fmt [EOL] [EOL] def test_format_far_past_date_invalid ( self ) : [EOL] date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = pytz . timezone ( [string] ) ) [EOL] check_fmt = [string] [EOL] fmt_date = dates . format_iso_datetime ( date ) [EOL] assert fmt_date == check_fmt [EOL] [EOL] def test_format_far_future_date ( self ) : [EOL] date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] check_fmt = [string] [EOL] fmt_date = dates . format_iso_datetime ( date ) [EOL] assert fmt_date == check_fmt [EOL] [EOL] def test_format_far_future_date_utc ( self ) : [EOL] date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = pytz . utc ) [EOL] check_fmt = [string] [EOL] fmt_date = dates . format_iso_datetime ( date ) [EOL] assert fmt_date == check_fmt [EOL] [EOL] def test_format_far_future_date_invalid ( self ) : [EOL] date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = pytz . timezone ( [string] ) ) [EOL] check_fmt = [string] [EOL] fmt_date = dates . format_iso_datetime ( date ) [EOL] assert fmt_date == check_fmt [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0
[comment] [EOL] [EOL] from typing import List , Any , Dict , Union [EOL] import typing [EOL] import pytest [EOL] [EOL] asyncio = pytest . importorskip ( [string] ) [EOL] import os [EOL] import sys [EOL] [EOL] from mygeotab import API , server_call_async [EOL] from mygeotab . exceptions import AuthenticationException , MyGeotabException , TimeoutException [EOL] from tests . test_api_call import USERNAME , PASSWORD , DATABASE , TRAILER_NAME [EOL] [EOL] USERNAME = os . environ . get ( [string] , USERNAME ) [EOL] PASSWORD = os . environ . get ( [string] , PASSWORD ) [EOL] [EOL] pytestmark = pytest . mark . skipif ( sys . version_info < ( [number] , [number] ) , reason = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def async_populated_api ( ) : [EOL] if USERNAME and PASSWORD : [EOL] session = API ( USERNAME , password = PASSWORD , database = DATABASE , server = None ) [EOL] try : [EOL] session . authenticate ( ) [EOL] except MyGeotabException as exception : [EOL] pytest . fail ( exception ) [EOL] return [EOL] yield session [EOL] else : [EOL] pytest . skip ( [string] [string] [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def async_populated_api_entity ( async_populated_api ) : [EOL] def clean_trailers ( ) : [EOL] try : [EOL] trailers = async_populated_api . get ( [string] , name = TRAILER_NAME ) [EOL] for trailer in trailers : [EOL] async_populated_api . remove ( [string] , trailer ) [EOL] except Exception : [EOL] pass [EOL] [EOL] clean_trailers ( ) [EOL] yield async_populated_api [EOL] clean_trailers ( ) [EOL] [EOL] [EOL] class TestAsyncCallApi : [EOL] @ pytest . mark . asyncio async def test_get_version ( self , async_populated_api ) : [EOL] version = await async_populated_api . call_async ( [string] ) [EOL] version_split = version . split ( [string] ) [EOL] assert len ( version_split ) == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_user ( self , async_populated_api ) : [EOL] user = await async_populated_api . get_async ( [string] , name = USERNAME ) [EOL] assert len ( user ) == [number] [EOL] user = user [ [number] ] [EOL] assert user [ [string] ] == USERNAME [EOL] [EOL] @ pytest . mark . asyncio async def test_multi_call ( self , async_populated_api ) : [EOL] calls = [ [ [string] , dict ( typeName = [string] , search = dict ( name = [string] . format ( USERNAME ) ) ) ] , [ [string] ] ] [EOL] results = await async_populated_api . multi_call_async ( calls ) [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] is not None [EOL] assert len ( results [ [number] ] ) == [number] [EOL] assert results [ [number] ] [ [number] ] [ [string] ] == USERNAME [EOL] assert results [ [number] ] is not None [EOL] version_split = results [ [number] ] . split ( [string] ) [EOL] assert len ( version_split ) == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_pythonic_parameters ( self , async_populated_api ) : [EOL] users = async_populated_api . get ( [string] ) [EOL] count_users = await async_populated_api . call_async ( [string] , type_name = [string] ) [EOL] assert len ( count_users ) >= [number] [EOL] assert len ( count_users ) == len ( users ) [EOL] [EOL] @ pytest . mark . asyncio async def test_api_from_credentials ( self , async_populated_api ) : [EOL] new_api = API . from_credentials ( async_populated_api . credentials ) [EOL] users = await new_api . get_async ( [string] ) [EOL] assert len ( users ) >= [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_results_limit ( self , async_populated_api ) : [EOL] users = await async_populated_api . get_async ( [string] , resultsLimit = [number] ) [EOL] assert len ( users ) == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_session_expired ( self , async_populated_api ) : [EOL] credentials = async_populated_api . credentials [EOL] credentials . password = PASSWORD [EOL] credentials . session_id = [string] [EOL] test_api = API . from_credentials ( credentials ) [EOL] users = await test_api . get_async ( [string] ) [EOL] assert len ( users ) >= [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_missing_method ( self , async_populated_api ) : [EOL] with pytest . raises ( Exception ) : [EOL] await async_populated_api . call_async ( None ) [EOL] [EOL] @ pytest . mark . asyncio async def test_call_without_credentials ( self ) : [EOL] new_api = API ( USERNAME , password = PASSWORD , database = DATABASE , server = None ) [EOL] user = await new_api . get_async ( [string] , name = [string] . format ( USERNAME ) ) [EOL] assert len ( user ) == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_bad_parameters ( self , async_populated_api ) : [EOL] with pytest . raises ( MyGeotabException ) as excinfo : [EOL] await async_populated_api . call_async ( [string] , not_a_property = [string] ) [EOL] assert [string] in str ( excinfo . value ) [EOL] [EOL] @ pytest . mark . asyncio async def test_get_search_parameter ( self , async_populated_api ) : [EOL] user = await async_populated_api . get_async ( [string] , search = dict ( name = USERNAME ) ) [EOL] assert len ( user ) == [number] [EOL] user = user [ [number] ] [EOL] assert user [ [string] ] == USERNAME [EOL] [EOL] @ pytest . mark . asyncio async def test_add_edit_remove ( self , async_populated_api_entity ) : [EOL] async def get_trailer ( ) : [EOL] trailers = await async_populated_api_entity . get_async ( [string] , name = TRAILER_NAME ) [EOL] assert len ( trailers ) == [number] [EOL] return trailers [ [number] ] [EOL] [EOL] user = async_populated_api_entity . get ( [string] , name = USERNAME ) [ [number] ] [EOL] trailer = { [string] : TRAILER_NAME , [string] : user [ [string] ] } [EOL] trailer_id = await async_populated_api_entity . add_async ( [string] , trailer ) [EOL] trailer [ [string] ] = trailer_id [EOL] trailer = await get_trailer ( ) [EOL] assert trailer [ [string] ] == TRAILER_NAME [EOL] comment = [string] [EOL] trailer [ [string] ] = comment [EOL] await async_populated_api_entity . set_async ( [string] , trailer ) [EOL] trailer = await get_trailer ( ) [EOL] assert trailer [ [string] ] == comment [EOL] await async_populated_api_entity . remove_async ( [string] , trailer ) [EOL] trailers = await async_populated_api_entity . get_async ( [string] , name = TRAILER_NAME ) [EOL] assert len ( trailers ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . skipif ( USERNAME is None or DATABASE is None , reason = ( [string] [string] ) , ) class TestAuthentication : [EOL] def test_invalid_session ( self ) : [EOL] test_api = API ( USERNAME , session_id = [string] , database = DATABASE ) [EOL] assert USERNAME in str ( test_api . credentials ) [EOL] assert DATABASE in str ( test_api . credentials ) [EOL] with pytest . raises ( AuthenticationException ) as excinfo : [EOL] test_api . get ( [string] ) [EOL] assert [string] in str ( excinfo . value ) [EOL] assert DATABASE in str ( excinfo . value ) [EOL] assert USERNAME in str ( excinfo . value ) [EOL] [EOL] def test_auth_exception ( self ) : [EOL] test_api = API ( USERNAME , password = [string] , database = [string] ) [EOL] with pytest . raises ( MyGeotabException ) as excinfo : [EOL] test_api . authenticate ( False ) [EOL] assert excinfo . value . name == [string] [EOL] [EOL] def test_username_password_exists ( self ) : [EOL] with pytest . raises ( Exception ) as excinfo1 : [EOL] API ( None ) [EOL] with pytest . raises ( Exception ) as excinfo2 : [EOL] API ( USERNAME ) [EOL] assert [string] in str ( excinfo1 . value ) [EOL] assert [string] in str ( excinfo2 . value ) [EOL] [EOL] [EOL] class TestAsyncServerCallApi : [EOL] @ pytest . mark . asyncio async def test_get_version ( self ) : [EOL] version = await server_call_async ( [string] , server = [string] ) [EOL] version_split = version . split ( [string] ) [EOL] assert len ( version_split ) == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_invalid_server_call ( self ) : [EOL] with pytest . raises ( Exception ) as excinfo1 : [EOL] await server_call_async ( None , None ) [EOL] with pytest . raises ( Exception ) as excinfo2 : [EOL] await server_call_async ( [string] , None ) [EOL] assert [string] in str ( excinfo1 . value ) [EOL] assert [string] in str ( excinfo2 . value ) [EOL] [EOL] @ pytest . mark . asyncio async def test_timeout ( self ) : [EOL] with pytest . raises ( TimeoutException ) as excinfo : [EOL] await server_call_async ( [string] , server = [string] , timeout = [number] ) [EOL] assert [string] in str ( excinfo . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple , Any , Dict [EOL] import typing [EOL] import sys [EOL] import os [EOL] import datetime [EOL] import mygeotab [EOL] import sphinx_rtd_theme [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys . path . append ( os . path . abspath ( [string] ) ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = [string] [EOL] copyright = [string] . format ( datetime . datetime . utcnow ( ) . year , mygeotab . __author__ ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = mygeotab . __version__ [EOL] [comment] [EOL] release = mygeotab . __version__ [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] on_rtd = os . environ . get ( [string] , None ) == [string] [EOL] [EOL] if not on_rtd : [comment] [EOL] import sphinx_rtd_theme [EOL] html_theme = [string] [EOL] html_theme_path = [ sphinx_rtd_theme . get_html_theme_path ( ) ] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( [string] , [string] , [string] , mygeotab . __author__ , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( [string] , [string] , [string] , [ mygeotab . __author__ ] , [number] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( [string] , [string] , [string] , mygeotab . __author__ , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0