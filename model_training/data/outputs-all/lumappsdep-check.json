import setuptools [EOL] setuptools . setup ( ) [EOL]	0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Any , Dict , Optional , Iterator [EOL] import argparse [EOL] import typing [EOL] import dep_check [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import logging [EOL] import sys [EOL] from dataclasses import dataclass [EOL] from typing import Callable [EOL] [EOL] from dep_check . infra . file_system import source_file_iterator [EOL] from dep_check . infra . go_parser import GoParser [EOL] from dep_check . infra . io import ( Graph , GraphDrawer , ReportPrinter , YamlConfigurationIO , read_graph_config , ) [EOL] from dep_check . infra . python_parser import PythonParser [EOL] from dep_check . infra . std_lib_filter import StdLibSimpleFilter [EOL] from dep_check . use_cases . app_configuration import ( AppConfiguration , AppConfigurationSingleton , ) [EOL] from dep_check . use_cases . build import BuildConfigurationUC [EOL] from dep_check . use_cases . check import CheckDependenciesUC , ForbiddenDepencyError [EOL] from dep_check . use_cases . draw_graph import DrawGraphUC [EOL] [EOL] FEATURE_PARSER = argparse . ArgumentParser ( description = [string] ) [EOL] FEATURE_PARSER . add_argument ( [string] , type = str , help = [string] , choices = [ [string] , [string] , [string] ] , ) [EOL] [EOL] BUILD_PARSER = argparse . ArgumentParser ( description = [string] ) [EOL] BUILD_PARSER . add_argument ( [string] , type = str , help = [string] , choices = [ [string] ] ) [EOL] BUILD_PARSER . add_argument ( [string] , type = str , help = [string] ) [EOL] BUILD_PARSER . add_argument ( [string] , [string] , type = str , help = [string] , default = [string] , ) [EOL] BUILD_PARSER . add_argument ( [string] , type = str , help = [string] , default = [string] , choices = [ [string] , [string] , [string] , [string] ] , ) [EOL] [EOL] [EOL] CHECK_PARSER = argparse . ArgumentParser ( description = [string] ) [EOL] CHECK_PARSER . add_argument ( [string] , type = str , help = [string] , choices = [ [string] ] ) [EOL] CHECK_PARSER . add_argument ( [string] , type = str , help = [string] ) [EOL] CHECK_PARSER . add_argument ( [string] , [string] , type = str , help = [string] , default = [string] , ) [EOL] [EOL] [EOL] GRAPH_PARSER = argparse . ArgumentParser ( description = [string] ) [EOL] GRAPH_PARSER . add_argument ( [string] , type = str , help = [string] , choices = [ [string] ] ) [EOL] GRAPH_PARSER . add_argument ( [string] , type = str , help = [string] ) [EOL] GRAPH_PARSER . add_argument ( [string] , [string] , type = str , help = [string] , default = [string] , ) [EOL] GRAPH_PARSER . add_argument ( [string] , [string] , type = str , help = [string] ) [EOL] GRAPH_PARSER . add_argument ( [string] , type = str , help = [string] , choices = [ [string] , [string] , [string] , [string] ] , ) [EOL] [EOL] [EOL] class MissingOptionError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ dataclass class Feature : [EOL] parser = ... [EOL] use_case_factory = ... [EOL] [EOL] [EOL] class MainApp : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . feature = FEATURE_PARSER . parse_args ( sys . argv [ [number] : [number] ] ) . feature [EOL] [EOL] try : [EOL] self . args = DEP_CHECK_FEATURES [ self . feature ] . parser . parse_args ( ) [EOL] except KeyError : [EOL] raise MissingOptionError ( ) [EOL] [EOL] def main ( self ) : [EOL] self . create_app_configuration ( ) [EOL] try : [EOL] use_case = DEP_CHECK_FEATURES [ self . feature ] . use_case_factory ( self ) [EOL] use_case . run ( ) [EOL] except KeyError : [EOL] raise MissingOptionError ( ) [EOL] [EOL] @ staticmethod def create_app_configuration ( ) : [EOL] [docstring] [EOL] app_configuration = AppConfiguration ( std_lib_filter = StdLibSimpleFilter ( ) ) [EOL] AppConfigurationSingleton . define_app_configuration ( app_configuration ) [EOL] [EOL] def create_build_use_case ( self ) : [EOL] [docstring] [EOL] configuration_io = YamlConfigurationIO ( self . args . output ) [EOL] code_parser = ( PythonParser ( ) if self . args . lang in [ [string] , [string] ] else GoParser ( ) ) [EOL] source_files = source_file_iterator ( self . args . root_dir , self . args . lang [ : [number] ] ) [EOL] return BuildConfigurationUC ( configuration_io , code_parser , source_files , self . args . lang ) [EOL] [EOL] def create_check_use_case ( self ) : [EOL] [docstring] [EOL] configuration = YamlConfigurationIO ( self . args . config ) . read ( ) [EOL] code_parser = ( PythonParser ( ) if configuration . lang in [ [string] , [string] ] else GoParser ( ) ) [EOL] report_printer = ReportPrinter ( ) [EOL] source_files = source_file_iterator ( self . args . root_dir , configuration . lang [ : [number] ] ) [EOL] return CheckDependenciesUC ( configuration , report_printer , code_parser , source_files ) [EOL] [EOL] def create_graph_use_case ( self ) : [EOL] [docstring] [EOL] graph_conf = read_graph_config ( self . args . config ) if self . args . config else None [EOL] [EOL] if self . args . lang : [EOL] lang = self . args . lang [EOL] elif graph_conf and [string] in graph_conf : [EOL] lang = graph_conf [ [string] ] [EOL] else : [EOL] lang = [string] [EOL] [EOL] code_parser = PythonParser ( ) if lang in [ [string] , [string] ] else GoParser ( ) [EOL] source_files = source_file_iterator ( self . args . root_dir , lang [ : [number] ] ) [EOL] graph = Graph ( self . args . output , graph_conf ) [EOL] graph_drawer = GraphDrawer ( graph ) [EOL] return DrawGraphUC ( graph_drawer , code_parser , source_files , graph_conf ) [EOL] [EOL] [EOL] DEP_CHECK_FEATURES = { [string] : Feature ( BUILD_PARSER , MainApp . create_build_use_case ) , [string] : Feature ( CHECK_PARSER , MainApp . create_check_use_case ) , [string] : Feature ( GRAPH_PARSER , MainApp . create_graph_use_case ) , } [EOL] [EOL] [EOL] def main ( ) : [EOL] try : [EOL] MainApp ( ) . main ( ) [EOL] except ForbiddenDepencyError : [EOL] sys . exit ( [number] ) [EOL] except MissingOptionError : [EOL] logging . error ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,dep_check.main.Feature]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,dep_check.main.Feature]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $dep_check.use_cases.app_configuration.AppConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.use_cases.app_configuration.AppConfiguration$ 0 0 0 0 $dep_check.use_cases.build.BuildConfigurationUC$ 0 0 0 0 0 0 0 $dep_check.infra.io.YamlConfigurationIO$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[dep_check.infra.go_parser.GoParser,dep_check.infra.python_parser.PythonParser]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.io.YamlConfigurationIO$ 0 $typing.Union[dep_check.infra.go_parser.GoParser,dep_check.infra.python_parser.PythonParser]$ 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 0 0 0 0 0 0 0 0 0 $dep_check.use_cases.check.CheckDependenciesUC$ 0 0 0 0 0 0 0 $dep_check.use_cases.interfaces.Configuration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[dep_check.infra.go_parser.GoParser,dep_check.infra.python_parser.PythonParser]$ 0 0 0 0 0 0 $dep_check.use_cases.interfaces.Configuration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.io.ReportPrinter$ 0 0 0 0 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 0 0 0 0 0 0 0 0 $dep_check.use_cases.interfaces.Configuration$ 0 0 0 0 0 0 0 0 0 0 0 $dep_check.use_cases.interfaces.Configuration$ 0 $dep_check.infra.io.ReportPrinter$ 0 $typing.Union[dep_check.infra.go_parser.GoParser,dep_check.infra.python_parser.PythonParser]$ 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 0 0 0 $dep_check.use_cases.draw_graph.DrawGraphUC$ 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 $builtins.str$ 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Union[dep_check.infra.go_parser.GoParser,dep_check.infra.python_parser.PythonParser]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $dep_check.infra.io.Graph$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 $dep_check.infra.io.GraphDrawer$ 0 0 0 $dep_check.infra.io.Graph$ 0 0 0 0 0 $dep_check.infra.io.GraphDrawer$ 0 $typing.Union[dep_check.infra.go_parser.GoParser,dep_check.infra.python_parser.PythonParser]$ 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $typing.Dict[builtins.str,dep_check.main.Feature]$ 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Set , Tuple , Dict , FrozenSet , Iterator [EOL] import typing [EOL] import dep_check [EOL] [docstring] [EOL] [EOL] from dataclasses import dataclass , field [EOL] from typing import Dict , FrozenSet , Iterator , List , NewType , Set , Tuple [EOL] [EOL] Module = NewType ( [string] , str ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Dependency : [EOL] [docstring] [EOL] [EOL] main_import = Module ( [string] ) [EOL] sub_imports = field ( default_factory = frozenset ) [EOL] [EOL] [EOL] Dependencies = Set [ Dependency ] [EOL] [EOL] SourceCode = NewType ( [string] , str ) [EOL] [EOL] ModuleWildcard = NewType ( [string] , str ) [EOL] [EOL] Rule = Tuple [ ModuleWildcard , ModuleWildcard ] [EOL] Rules = Set [ Rule ] [EOL] [EOL] DependencyRules = Dict [ str , List [ ModuleWildcard ] ] [EOL] [EOL] GlobalDependencies = Dict [ Module , Dependencies ] [EOL] [EOL] [EOL] def get_parent ( module ) : [EOL] [docstring] [EOL] return Module ( module . rpartition ( [string] ) [ [number] ] ) [EOL] [EOL] [EOL] def iter_all_modules ( global_dep ) : [EOL] def iter_ ( global_dep ) : [EOL] for module , dependencies in global_dep . items ( ) : [EOL] yield module [EOL] yield from ( d . main_import for d in dependencies ) [EOL] [EOL] return iter ( set ( iter_ ( global_dep ) ) ) [EOL] [EOL] [EOL] @ dataclass class SourceFile : [EOL] [docstring] [EOL] [EOL] module = ... [EOL] code = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Module$ 0 0 0 0 0 0 $typing.FrozenSet[Module]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[Module]$ 0 0 0 0 0 0 $typing.Iterator[Module]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Module$ 0 0 0 $SourceCode$ 0 0 0
from typing import List , Optional , Tuple [EOL] import typing [EOL] import dep_check [EOL] [docstring] [EOL] import re [EOL] from typing import List , Optional [EOL] [EOL] from dep_check . dependency_finder import IParser [EOL] from dep_check . models import Dependency , Module , ModuleWildcard , Rule , Rules [EOL] [EOL] [EOL] class NotAllowedDependencyException ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , dependency , authorized_modules ) : [EOL] super ( ) . __init__ ( [string] . format ( dependency , authorized_modules ) ) [EOL] self . dependency = dependency [EOL] self . authorized_modules = authorized_modules [EOL] [EOL] [EOL] def check_dependency ( parser , dependency , rules ) : [EOL] [docstring] [EOL] used_rule = None [EOL] for module , rule in rules : [EOL] if re . match ( [string] . format ( parser . wildcard_to_regex ( rule ) ) , dependency . main_import ) : [EOL] used_rule = ( module , rule ) [EOL] return set ( ( used_rule , ) ) [EOL] if not dependency . sub_imports : [EOL] raise NotAllowedDependencyException ( dependency . main_import , [ r for _ , r in rules ] ) [EOL] [EOL] return check_import_from_dependency ( parser , dependency , rules ) [EOL] [EOL] [EOL] def check_import_from_dependency ( parser , dependency , rules ) : [EOL] used_rules = set ( ) [EOL] for import_module in dependency . sub_imports : [EOL] used_rule = None [EOL] for module , rule in rules : [EOL] if re . match ( [string] . format ( parser . wildcard_to_regex ( rule ) ) , f"{ dependency . main_import } [string] { import_module }" , ) : [EOL] used_rule = ( module , rule ) [EOL] used_rules . add ( used_rule ) [EOL] if not used_rule : [EOL] raise NotAllowedDependencyException ( Module ( f"{ dependency . main_import } [string] { import_module }" ) , [ r for _ , r in rules ] , ) [EOL] return used_rules [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dep_check.models.Module$ 0 $typing.List[dep_check.models.ModuleWildcard]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 $typing.List[dep_check.models.ModuleWildcard]$ 0 0 0 0 0 $dep_check.models.Module$ 0 $dep_check.models.Module$ 0 0 0 $typing.List[dep_check.models.ModuleWildcard]$ 0 $typing.List[dep_check.models.ModuleWildcard]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] __author__ = [string] [EOL] __email__ = [string] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
import builtins [EOL] import dep_check [EOL] from abc import ABC , abstractmethod [EOL] [EOL] from dep_check . models import Dependencies , ModuleWildcard , SourceFile [EOL] [EOL] [EOL] class IParser ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def wildcard_to_regex ( self , module ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def find_dependencies ( self , source_file ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def find_import_from_dependencies ( self , source_file ) : [EOL] [docstring] [EOL] [EOL] [EOL] def get_dependencies ( source_file , parser ) : [EOL] return parser . find_dependencies ( source_file ) [EOL] [EOL] [EOL] def get_import_from_dependencies ( source_file , parser ) : [EOL] return parser . find_import_from_dependencies ( source_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 $dep_check.models.Dependencies$ 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 0 0 0 0 $dep_check.models.Dependencies$ 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 0 0 0 $dep_check.models.Dependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Dependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import dep_check [EOL] [docstring] [EOL] from abc import ABC , abstractmethod [EOL] from dataclasses import dataclass , field [EOL] [EOL] from dep_check . models import Dependencies , DependencyRules [EOL] [EOL] [EOL] @ dataclass class Configuration : [EOL] [docstring] [EOL] [EOL] dependency_rules = field ( default_factory = dict ) [EOL] lang = [string] [EOL] local_init = False [EOL] [EOL] [EOL] class IStdLibFilter ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def filter ( self , dependencies ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Dependencies$ 0 0 0 $dep_check.models.Dependencies$ 0 0 0 0 0
import builtins [EOL] import dep_check [EOL] [docstring] [EOL] from dataclasses import dataclass [EOL] [EOL] from . interfaces import IStdLibFilter [EOL] [EOL] [EOL] class AppConfigurationAlreadySetException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class AppConfiguration : [EOL] [docstring] [EOL] [EOL] std_lib_filter = ... [EOL] [EOL] [EOL] class AppConfigurationSingleton : [EOL] [docstring] [EOL] [EOL] _instance = ... [EOL] _already_set = False [EOL] [EOL] @ classmethod def define_app_configuration ( cls , configuration ) : [EOL] [docstring] [EOL] if cls . _already_set : [EOL] raise AppConfigurationAlreadySetException ( [string] ) [EOL] cls . _instance = configuration [EOL] cls . _already_set = True [EOL] [EOL] @ classmethod def get_instance ( cls ) : [EOL] [docstring] [EOL] return cls . _instance [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $interfaces.IStdLibFilter$ 0 0 0 0 0 0 0 0 0 0 0 0 $AppConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AppConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Dict , Any [EOL] import interfaces [EOL] import builtins [EOL] import typing [EOL] import dep_check [EOL] [docstring] [EOL] from abc import ABC , abstractmethod [EOL] from typing import Dict , Iterator [EOL] [EOL] from dep_check . dependency_finder import IParser , get_dependencies [EOL] from dep_check . models import Dependencies , Module , ModuleWildcard , SourceFile [EOL] [EOL] from . app_configuration import AppConfigurationSingleton [EOL] from . interfaces import Configuration [EOL] [EOL] [EOL] class IConfigurationWriter ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def write ( self , configuration ) : [EOL] [docstring] [EOL] [EOL] [EOL] class BuildConfigurationUC : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , printer , parser , source_files , lang , ) : [EOL] app_configuration = AppConfigurationSingleton . get_instance ( ) [EOL] self . std_lib_filter = app_configuration . std_lib_filter [EOL] self . printer = printer [EOL] self . parser = parser [EOL] self . source_files = source_files [EOL] self . lang = lang [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] global_dependencies = { } [EOL] for source_file in self . source_files : [EOL] dependencies = get_dependencies ( source_file , self . parser ) [EOL] dependencies = self . std_lib_filter . filter ( dependencies ) [EOL] [EOL] global_dependencies [ source_file . module ] = dependencies [EOL] [EOL] dependency_rules = { } [EOL] for module , dependencies in global_dependencies . items ( ) : [EOL] dependency_rules [ str ( module ) ] = [ ModuleWildcard ( dependency . main_import ) for dependency in dependencies ] [EOL] [EOL] self . printer . write ( Configuration ( dependency_rules , self . lang ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Set , Tuple , Dict , Optional , Iterator [EOL] import builtins [EOL] import typing [EOL] import dep_check [EOL] [docstring] [EOL] from abc import ABC , abstractmethod [EOL] from collections import defaultdict [EOL] from typing import Dict , Iterator , Optional [EOL] [EOL] from dep_check . dependency_finder import IParser , get_dependencies [EOL] from dep_check . models import ( Dependencies , Dependency , GlobalDependencies , Module , SourceFile , ) [EOL] [EOL] from . app_configuration import AppConfigurationSingleton [EOL] [EOL] [EOL] class IGraphDrawer ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def write ( self , global_dep ) : [EOL] [docstring] [EOL] [EOL] [EOL] def _fold_dep ( global_dep , fold_module ) : [EOL] [EOL] fold_global_dep = defaultdict ( set ) [EOL] for module , deps in global_dep . items ( ) : [EOL] new_deps = set ( ) [EOL] if module . startswith ( tuple ( ( f"{ fold_module } [string] " , f"{ fold_module } [string] " ) ) ) : [EOL] module = fold_module [EOL] fold_dep = set ( Dependency ( fold_module ) if dep . main_import . startswith ( fold_module ) else dep for dep in deps ) [EOL] new_deps |= fold_dep [EOL] fold_global_dep [ module ] |= new_deps [EOL] [EOL] return fold_global_dep [EOL] [EOL] [EOL] class DrawGraphUC : [EOL] def __init__ ( self , drawer , parser , source_files , config = None , ) : [EOL] app_configuration = AppConfigurationSingleton . get_instance ( ) [EOL] self . std_lib_filter = app_configuration . std_lib_filter [EOL] self . source_files = source_files [EOL] self . drawer = drawer [EOL] self . parser = parser [EOL] self . config = config or { } [EOL] [EOL] def _hide ( self , global_dep ) : [EOL] hide_modules = tuple ( self . config . get ( [string] , ( ) ) ) [EOL] if not hide_modules : [EOL] return global_dep [EOL] [EOL] filtered_global_dep = { } [EOL] for module , dependencies in global_dep . items ( ) : [EOL] if not module . startswith ( hide_modules ) : [EOL] [EOL] filtered_global_dep [ module ] = set ( dependency for dependency in dependencies if not dependency . main_import . startswith ( hide_modules ) ) [EOL] [EOL] return filtered_global_dep [EOL] [EOL] def run ( self ) : [EOL] global_dependencies = { } [EOL] for source_file in self . source_files : [EOL] module = Module ( source_file . module . replace ( [string] , [string] ) ) [EOL] dependencies = get_dependencies ( source_file , self . parser ) [EOL] dependencies = self . std_lib_filter . filter ( dependencies ) [EOL] global_dependencies [ module ] = dependencies [EOL] [EOL] global_dependencies = self . _hide ( global_dependencies ) [EOL] [EOL] for fold_module in self . config . get ( [string] , [ ] ) : [EOL] global_dependencies = _fold_dep ( global_dependencies , fold_module ) [EOL] [EOL] [comment] [EOL] for module , deps in list ( global_dependencies . items ( ) ) : [EOL] deps -= { dep for dep in deps if dep . main_import == module } [EOL] [EOL] if not global_dependencies [ module ] : [EOL] global_dependencies . pop ( module , None ) [EOL] [EOL] self . drawer . write ( global_dependencies ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.use_cases.draw_graph.IGraphDrawer$ 0 $dep_check.dependency_finder.IParser$ 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 0 0 0 0 0 0 0 $dep_check.use_cases.app_configuration.AppConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 $dep_check.use_cases.app_configuration.AppConfiguration$ 0 0 0 0 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 0 0 $dep_check.use_cases.draw_graph.IGraphDrawer$ 0 $dep_check.use_cases.draw_graph.IGraphDrawer$ 0 0 0 $dep_check.dependency_finder.IParser$ 0 $dep_check.dependency_finder.IParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[dep_check.models.Module,typing.Set[dep_check.models.Dependency]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[dep_check.models.Module,typing.Set[dep_check.models.Dependency]]$ 0 $dep_check.models.Module$ 0 0 $typing.Any$ 0 0 $typing.Dict[dep_check.models.Module,typing.Set[dep_check.models.Dependency]]$ 0 0 0 0 0 $typing.Dict[dep_check.models.Module,typing.Set[dep_check.models.Dependency]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[dep_check.models.Module,typing.Set[dep_check.models.Dependency]]$ 0 0 0 $typing.Dict[dep_check.models.Module,typing.Set[dep_check.models.Dependency]]$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 $typing.Dict[dep_check.models.Module,typing.Set[dep_check.models.Dependency]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 $typing.Dict[dep_check.models.Module,typing.Set[dep_check.models.Dependency]]$ 0 $dep_check.models.Module$ 0 0 0 $typing.Dict[dep_check.models.Module,typing.Set[dep_check.models.Dependency]]$ 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[dep_check.models.Module,typing.Set[dep_check.models.Dependency]]$ 0 0
from typing import Any , Set , Tuple , List , Iterator [EOL] import builtins [EOL] import interfaces [EOL] import typing [EOL] import dep_check [EOL] [docstring] [EOL] [EOL] [EOL] import re [EOL] from abc import ABC , abstractmethod [EOL] from dataclasses import dataclass [EOL] from typing import Iterator , List , Tuple [EOL] [EOL] from dep_check . checker import NotAllowedDependencyException , check_dependency [EOL] from dep_check . dependency_finder import IParser , get_import_from_dependencies [EOL] from dep_check . models import Module , ModuleWildcard , Rules , SourceFile [EOL] [EOL] from . app_configuration import AppConfigurationSingleton [EOL] from . interfaces import Configuration [EOL] [EOL] [EOL] class ForbiddenDepencyError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DependencyError : [EOL] [docstring] [EOL] [EOL] module = ... [EOL] dependency = ... [EOL] rules = ... [EOL] [EOL] [EOL] class IReportPrinter ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def _error ( self , dep_errors ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def _warning ( self , unused_rules ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def print_report ( self , errors , unused_rules , nb_files ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CheckDependenciesUC : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , configuration , report_printer , parser , source_files , ) : [EOL] app_configuration = AppConfigurationSingleton . get_instance ( ) [EOL] self . std_lib_filter = app_configuration . std_lib_filter [EOL] self . configuration = configuration [EOL] self . report_printer = report_printer [EOL] self . parser = parser [EOL] self . source_files = source_files [EOL] self . used_rules = set ( ) [EOL] self . all_rules = set ( ) [EOL] [EOL] def _get_rules ( self , module ) : [EOL] [docstring] [EOL] matching_rules = set ( ) [EOL] for module_wildcard , rules in self . configuration . dependency_rules . items ( ) : [EOL] if re . match ( [string] . format ( self . parser . wildcard_to_regex ( ModuleWildcard ( module_wildcard ) ) ) , module , ) : [EOL] matching_rules . update ( ( ModuleWildcard ( module_wildcard ) , r ) for r in rules ) [EOL] [EOL] return matching_rules [EOL] [EOL] def _iter_error ( self , source_file ) : [EOL] rules = self . _get_rules ( source_file . module ) [EOL] self . all_rules . update ( set ( rules ) ) [EOL] dependencies = get_import_from_dependencies ( source_file , self . parser ) [EOL] dependencies = self . std_lib_filter . filter ( dependencies ) [EOL] for dependency in dependencies : [EOL] try : [EOL] self . used_rules |= check_dependency ( self . parser , dependency , rules ) [EOL] except NotAllowedDependencyException as error : [EOL] yield DependencyError ( source_file . module , error . dependency , tuple ( sorted ( error . authorized_modules ) ) , ) [EOL] [EOL] def run ( self ) : [EOL] errors = [ ] [EOL] nb_files = [number] [EOL] [EOL] for source_file in self . source_files : [EOL] nb_files += [number] [EOL] for error in self . _iter_error ( source_file ) : [EOL] errors . append ( error ) [EOL] [EOL] unused = self . all_rules . difference ( self . used_rules ) [EOL] self . report_printer . print_report ( errors , unused , nb_files ) [EOL] [EOL] if errors : [EOL] raise ForbiddenDepencyError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 $dep_check.models.Module$ 0 0 0 $typing.Tuple[dep_check.models.ModuleWildcard,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.use_cases.check.IReportPrinter$ 0 $dep_check.dependency_finder.IParser$ 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.use_cases.check.IReportPrinter$ 0 $dep_check.use_cases.check.IReportPrinter$ 0 0 0 $dep_check.dependency_finder.IParser$ 0 $dep_check.dependency_finder.IParser$ 0 0 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 0 0 $dep_check.models.Rules$ 0 0 0 0 0 0 0 $dep_check.models.Rules$ 0 0 0 0 0 0 0 $dep_check.models.Rules$ 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 $dep_check.models.Rules$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 $dep_check.models.Rules$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Rules$ 0 0 0 $typing.Iterator[DependencyError]$ 0 0 0 $dep_check.models.SourceFile$ 0 0 0 $typing.Set[typing.Tuple[dep_check.models.ModuleWildcard,dep_check.models.ModuleWildcard]]$ 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[dep_check.models.ModuleWildcard,dep_check.models.ModuleWildcard]]$ 0 0 0 $typing.Any$ 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[dep_check.models.ModuleWildcard,dep_check.models.ModuleWildcard]]$ 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[dep_check.models.ModuleWildcard,dep_check.models.ModuleWildcard]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Set[typing.Tuple[dep_check.models.ModuleWildcard,dep_check.models.ModuleWildcard]]$ 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0
import dep_check [EOL] [docstring] [EOL] from dep_check . models import Dependencies [EOL] from dep_check . use_cases . interfaces import IStdLibFilter [EOL] [EOL] _KNOWN_STANDARD_LIBRARIES = frozenset ( ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) ) [EOL] [EOL] [EOL] class StdLibSimpleFilter ( IStdLibFilter ) : [EOL] [docstring] [EOL] [EOL] def filter ( self , dependencies ) : [EOL] return dependencies - { dep for dep in dependencies if dep . main_import . startswith ( tuple ( _KNOWN_STANDARD_LIBRARIES ) ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Dependencies$ 0 0 0 $dep_check.models.Dependencies$ 0 0 0 0 $dep_check.models.Dependencies$ 0 0 0 0 0 0 $dep_check.models.Dependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import dep_check [EOL] import logging [EOL] from os import chdir , getcwd , path [EOL] from subprocess import CalledProcessError , run [EOL] [EOL] from dep_check . dependency_finder import IParser [EOL] from dep_check . models import Dependencies , Dependency , ModuleWildcard , SourceFile [EOL] [EOL] try : [EOL] from . lib import goparse [EOL] except ImportError : [EOL] CURRENT_WD = getcwd ( ) [EOL] [EOL] chdir ( [string] . format ( path . dirname ( path . realpath ( __file__ ) ) ) ) [EOL] try : [EOL] run ( [ [string] , [string] , [string] , [string] ] , check = True ) [EOL] from . lib import goparse [comment] [EOL] except ( CalledProcessError , FileNotFoundError ) : [EOL] logging . warning ( [string] ) [EOL] except ImportError : [EOL] logging . warning ( [string] ) [EOL] chdir ( CURRENT_WD ) [EOL] [EOL] [EOL] class GoParser ( IParser ) : [EOL] [docstring] [EOL] [EOL] def wildcard_to_regex ( self , module ) : [EOL] [docstring] [EOL] module_regex = module . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] module_regex = module_regex . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] module_regex = module_regex . replace ( [string] , [string] ) [EOL] return module_regex [EOL] [EOL] def find_dependencies ( self , source_file ) : [EOL] if not source_file . code : [EOL] return set ( ) [EOL] deps_string = goparse . find_dependencies ( source_file . code ) [EOL] deps_list = deps_string . replace ( [string] , [string] ) . split ( [string] ) [ : - [number] ] [EOL] [EOL] dependecies = { Dependency ( dep ) for dep in deps_list } [EOL] return dependecies [EOL] [EOL] def find_import_from_dependencies ( self , source_file ) : [EOL] return self . find_dependencies ( source_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 $builtins.str$ 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $dep_check.models.Dependencies$ 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Dependencies$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $dep_check.models.Dependencies$ 0 0 0 $dep_check.models.Dependencies$ 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0
from typing import Iterator [EOL] import builtins [EOL] import pathlib [EOL] import typing [EOL] import dep_check [EOL] [docstring] [EOL] import os [EOL] from contextlib import contextmanager [EOL] from pathlib import Path [EOL] from typing import Iterator [EOL] [EOL] from dep_check . models import Module , SourceCode , SourceFile [EOL] [EOL] [EOL] def _get_module_from_file_path ( path , separator ) : [EOL] [docstring] [EOL] path_without_extention = path . parents [ [number] ] / path . stem [EOL] return Module ( separator . join ( path_without_extention . parts ) ) [EOL] [EOL] [EOL] @ contextmanager def _change_dir ( directory ) : [EOL] [docstring] [EOL] saved_dir = os . getcwd ( ) [EOL] try : [EOL] os . chdir ( directory ) [EOL] yield [EOL] finally : [EOL] os . chdir ( saved_dir ) [EOL] [EOL] [EOL] def _get_python_project_root ( root_dir ) : [EOL] [docstring] [EOL] project_root = [string] [EOL] [EOL] if [string] in os . listdir ( Path ( root_dir ) ) : [EOL] project_root = Path ( root_dir ) . name + [string] [EOL] [EOL] for directory in Path ( root_dir ) . parents : [EOL] if [string] in os . listdir ( directory ) : [EOL] project_root = f"{ directory . name } [string] { project_root }" [EOL] else : [EOL] break [EOL] return project_root [EOL] [EOL] [EOL] def source_file_iterator ( root_dir , file_extension ) : [EOL] [docstring] [EOL] if file_extension == [string] : [EOL] project_root = _get_python_project_root ( root_dir ) [EOL] separator = [string] [EOL] elif file_extension == [string] : [EOL] project_root = [string] [EOL] separator = [string] [EOL] [EOL] with _change_dir ( root_dir ) : [EOL] for file_path in Path ( [string] ) . rglob ( f" [string] { file_extension }" ) : [EOL] with open ( str ( file_path ) , [string] ) as stream : [EOL] content = stream . read ( ) [EOL] yield SourceFile ( Module ( project_root + _get_module_from_file_path ( file_path , separator ) ) , SourceCode ( content ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[dep_check.models.SourceFile]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import _ast [EOL] import builtins [EOL] import typing [EOL] import dep_check [EOL] import ast [EOL] from typing import Any , FrozenSet , List [EOL] [EOL] from dep_check . dependency_finder import IParser [EOL] from dep_check . models import ( Dependencies , Dependency , Module , ModuleWildcard , SourceFile , ) [EOL] [EOL] [EOL] class _ImportVisitor ( ast . NodeVisitor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , current_module ) : [EOL] self . _dependencies = set ( ) [EOL] self . current_module_parts = current_module . split ( [string] ) [EOL] [EOL] @ property def dependencies ( self ) : [EOL] [docstring] [EOL] return self . _dependencies [EOL] [EOL] def visit ( self , node ) : [EOL] modules = frozenset ( ) [EOL] if isinstance ( node , ast . Import ) : [EOL] modules = frozenset ( Dependency ( Module ( alias . name ) ) for alias in node . names ) [EOL] [EOL] elif isinstance ( node , ast . ImportFrom ) : [EOL] module = Module ( node . module or [string] ) [EOL] if node . level : [EOL] parent_module = [string] . join ( self . current_module_parts [ : - node . level ] ) [EOL] if node . module : [EOL] module = Module ( [string] . format ( parent_module , node . module ) ) [EOL] else : [EOL] module = Module ( parent_module ) [EOL] modules = frozenset ( ( Dependency ( module ) , ) ) [EOL] self . _dependencies |= modules [EOL] [EOL] super ( ) . visit ( node ) [EOL] [EOL] [EOL] class _ImportFromVisitor ( ast . NodeVisitor ) : [EOL] def __init__ ( self , current_module ) : [EOL] self . _dependencies = set ( ) [EOL] self . current_module_parts = current_module . split ( [string] ) [EOL] [EOL] @ property def dependencies ( self ) : [EOL] [docstring] [EOL] return self . _dependencies [EOL] [EOL] def visit ( self , node ) : [EOL] modules = frozenset ( ) [EOL] if isinstance ( node , ast . Import ) : [EOL] modules = frozenset ( Dependency ( Module ( alias . name ) ) for alias in node . names ) [EOL] elif isinstance ( node , ast . ImportFrom ) : [EOL] module = Module ( node . module or [string] ) [EOL] if node . level : [EOL] parent_module = [string] . join ( self . current_module_parts [ : - node . level ] ) [EOL] if node . module : [EOL] module = Module ( [string] . format ( parent_module , node . module ) ) [EOL] else : [EOL] module = Module ( parent_module ) [EOL] sub_imports = frozenset ( Module ( alias . name ) for alias in node . names ) [EOL] modules = frozenset ( ( Dependency ( module , sub_imports ) , ) ) [EOL] [EOL] self . _dependencies |= modules [EOL] [EOL] super ( ) . visit ( node ) [EOL] [EOL] [EOL] class PythonParser ( IParser ) : [EOL] [docstring] [EOL] [EOL] def wildcard_to_regex ( self , module ) : [EOL] [docstring] [EOL] module_regex = module . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] module_regex = module_regex . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] module_regex = module_regex . replace ( [string] , [string] ) [EOL] return module_regex [EOL] [EOL] def find_dependencies ( self , source_file ) : [EOL] [docstring] [EOL] visitor = _ImportVisitor ( source_file . module ) [EOL] node = ast . parse ( source_file . code ) [EOL] visitor . visit ( node ) [EOL] return visitor . dependencies [EOL] [EOL] def find_import_from_dependencies ( self , source_file ) : [EOL] [docstring] [EOL] visitor = _ImportFromVisitor ( source_file . module ) [EOL] node = ast . parse ( source_file . code ) [EOL] visitor . visit ( node ) [EOL] return visitor . dependencies [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $dep_check.models.Dependencies$ 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 $dep_check.infra.python_parser._ImportVisitor$ 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 $_ast.Module$ 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 $dep_check.infra.python_parser._ImportVisitor$ 0 0 0 $_ast.Module$ 0 0 0 $dep_check.infra.python_parser._ImportVisitor$ 0 0 0 0 0 $dep_check.models.Dependencies$ 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 $dep_check.infra.python_parser._ImportFromVisitor$ 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 $_ast.Module$ 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 $dep_check.infra.python_parser._ImportFromVisitor$ 0 0 0 $_ast.Module$ 0 0 0 $dep_check.infra.python_parser._ImportFromVisitor$ 0 0 0
from typing import List , Iterable , TextIO , Tuple , Dict , Optional , Iterator [EOL] import builtins [EOL] import typing [EOL] import dep_check [EOL] import jinja2 [EOL] [docstring] [EOL] from dataclasses import asdict , dataclass [EOL] from enum import Enum [EOL] from pathlib import Path [EOL] from subprocess import check_output [EOL] from sys import stdin , stdout [EOL] from typing import Dict , Iterable , Iterator , List , Optional , Tuple [EOL] [EOL] import yaml [EOL] from jinja2 import Template [EOL] [EOL] from dep_check . models import GlobalDependencies , Module , Rules , iter_all_modules [EOL] from dep_check . use_cases . build import IConfigurationWriter [EOL] from dep_check . use_cases . check import DependencyError , IReportPrinter [EOL] from dep_check . use_cases . draw_graph import IGraphDrawer [EOL] from dep_check . use_cases . interfaces import Configuration [EOL] [EOL] [EOL] class Format ( Enum ) : [EOL] SUCCESS = [string] [EOL] WARNING = [string] [EOL] FAIL = [string] [EOL] ENDC = [string] [EOL] BOLD = [string] [EOL] INFO = [string] [EOL] [EOL] [EOL] class YamlConfigurationIO ( IConfigurationWriter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config_path ) : [EOL] self . config_path = config_path [EOL] [EOL] def write ( self , configuration ) : [EOL] if self . config_path == [string] : [EOL] stream = stdout [EOL] stream . write ( [string] ) [EOL] yaml . safe_dump ( asdict ( configuration ) , stream ) [EOL] else : [EOL] with open ( self . config_path , [string] ) as stream : [EOL] stream . write ( [string] ) [EOL] yaml . safe_dump ( asdict ( configuration ) , stream ) [EOL] [EOL] def read ( self ) : [EOL] if self . config_path == [string] : [EOL] return Configuration ( ** yaml . safe_load ( stdin ) ) [EOL] [EOL] with open ( self . config_path ) as stream : [EOL] return Configuration ( ** yaml . safe_load ( stream ) ) [EOL] [EOL] [EOL] class ReportPrinter ( IReportPrinter ) : [EOL] [docstring] [EOL] [EOL] def _error ( self , dep_errors ) : [EOL] [docstring] [EOL] module_errors = { error . module : [ e for e in dep_errors if e . module == error . module ] for error in dep_errors } [EOL] [EOL] for module , errors in sorted ( module_errors . items ( ) ) : [EOL] print ( [string] + Format . BOLD . value + module + Format . ENDC . value + [string] ) [EOL] print ( [string] + Format . FAIL . value + [string] + Format . ENDC . value ) [EOL] [EOL] for error in errors : [EOL] print ( f" [string] { error . dependency }" ) [EOL] print ( [string] + Format . INFO . value + [string] + Format . ENDC . value ) [EOL] [EOL] for rule in errors [ [number] ] . rules : [EOL] print ( f" [string] { rule }" ) [EOL] [EOL] def _warning ( self , unused_rules ) : [EOL] [docstring] [EOL] previous_wildcard = [string] [EOL] for wildcard , rule in sorted ( unused_rules ) : [EOL] if wildcard != previous_wildcard : [EOL] print ( [string] + Format . BOLD . value + wildcard + Format . ENDC . value + [string] ) [EOL] print ( [string] + Format . WARNING . value + [string] + Format . ENDC . value ) [EOL] previous_wildcard = wildcard [EOL] print ( f" [string] { wildcard } [string] { rule }" ) [EOL] [EOL] def print_report ( self , errors , unused_rules , nb_files ) : [EOL] [docstring] [EOL] if errors : [EOL] print ( [string] + Format . BOLD . value + Format . FAIL . value + [string] . center ( [number] ) + Format . ENDC . value ) [EOL] self . _error ( errors ) [EOL] [EOL] if unused_rules : [EOL] print ( [string] + Format . BOLD . value + Format . WARNING . value + [string] . center ( [number] ) + Format . ENDC . value ) [EOL] self . _warning ( unused_rules ) [EOL] [EOL] if not errors and not unused_rules : [EOL] print ( Format . SUCCESS . value + [string] + Format . ENDC . value ) [EOL] print ( [string] + Format . FAIL . value + f"{ len ( errors ) } [string] " + Format . ENDC . value + [string] + Format . WARNING . value + f"{ len ( unused_rules ) } [string] " + Format . ENDC . value + f" [string] { nb_files } [string] " ) [EOL] [EOL] [EOL] def read_graph_config ( conf_path ) : [EOL] [docstring] [EOL] with open ( conf_path ) as stream : [EOL] return yaml . safe_load ( stream ) [EOL] [EOL] [EOL] @ dataclass ( init = False ) class Graph : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , svg_file_name , graph_config = None ) : [EOL] self . svg_file_name = svg_file_name [EOL] self . graph_config = graph_config or { } [EOL] self . dot_file_name = [string] [EOL] self . node_color = self . graph_config . get ( [string] , [string] ) [EOL] self . background_color = self . graph_config . get ( [string] , [string] ) [EOL] self . layers = self . graph_config . get ( [string] , { } ) [EOL] [EOL] [EOL] class GraphDrawer ( IGraphDrawer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , graph ) : [EOL] self . graph = graph [EOL] self . header = Template ( [string] [string] [string] [string] ) . render ( nodecolor = self . graph . node_color , bgcolor = self . graph . background_color ) [EOL] self . body = [string] [EOL] self . footer = [string] [EOL] [EOL] self . subgraph = Template ( [string] [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] def _iter_layer_modules ( self , global_dep ) : [EOL] [EOL] for layer in self . graph . layers : [EOL] yield layer , [ m for m in iter_all_modules ( global_dep ) if m . startswith ( tuple ( self . graph . layers [ layer ] [ [string] ] ) ) ] [EOL] [EOL] def _write_dot ( self , global_dep ) : [EOL] if not global_dep : [EOL] return False [EOL] [EOL] for layer , modules in self . _iter_layer_modules ( global_dep ) : [EOL] [EOL] self . body += self . subgraph . render ( subgraph_name = layer , color = self . graph . layers [ layer ] . get ( [string] , self . graph . node_color ) , list_modules = str ( modules ) [ [number] : - [number] ] . replace ( [string] , [string] ) , ) [EOL] [EOL] for module , deps in global_dep . items ( ) : [EOL] for dep in deps : [EOL] self . body += [string] . format ( module , dep . main_import ) [EOL] [EOL] with open ( self . graph . dot_file_name , [string] ) as out : [EOL] out . write ( self . header ) [EOL] out . write ( self . body ) [EOL] out . write ( self . footer ) [EOL] [EOL] return True [EOL] [EOL] def _write_svg ( self ) : [EOL] svg_string = check_output ( [ [string] , [string] , self . graph . dot_file_name ] ) . decode ( ) [EOL] if self . graph . svg_file_name == [string] : [EOL] stdout . write ( svg_string ) [EOL] else : [EOL] with open ( self . graph . svg_file_name , [string] ) as stream : [EOL] stream . write ( svg_string ) [EOL] [EOL] def write ( self , global_dep ) : [EOL] if Path ( self . graph . svg_file_name ) . suffix == [string] : [EOL] self . graph . dot_file_name = self . graph . svg_file_name [EOL] self . _write_dot ( global_dep ) [EOL] else : [EOL] if self . _write_dot ( global_dep ) : [EOL] self . _write_svg ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $dep_check.use_cases.interfaces.Configuration$ 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.use_cases.interfaces.Configuration$ 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.use_cases.interfaces.Configuration$ 0 0 $typing.TextIO$ 0 0 0 0 $dep_check.use_cases.interfaces.Configuration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[dep_check.use_cases.check.DependencyError]$ 0 0 0 0 0 $typing.Dict[dep_check.models.Module,typing.List[dep_check.use_cases.check.DependencyError]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[dep_check.use_cases.check.DependencyError]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[dep_check.use_cases.check.DependencyError]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[dep_check.models.Module,typing.List[dep_check.use_cases.check.DependencyError]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dep_check.models.Rules$ 0 0 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Rules$ 0 0 0 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[dep_check.use_cases.check.DependencyError]$ 0 $dep_check.models.Rules$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[dep_check.use_cases.check.DependencyError]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[dep_check.use_cases.check.DependencyError]$ 0 0 0 0 $dep_check.models.Rules$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Rules$ 0 0 0 0 0 $typing.List[dep_check.use_cases.check.DependencyError]$ 0 0 $dep_check.models.Rules$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[dep_check.use_cases.check.DependencyError]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.Rules$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.io.Graph$ 0 0 0 0 0 $dep_check.infra.io.Graph$ 0 $dep_check.infra.io.Graph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.io.Graph$ 0 0 0 0 0 0 0 $dep_check.infra.io.Graph$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $jinja2.environment.Template$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[builtins.str,typing.Iterable[dep_check.models.Module]]]$ 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 0 0 $dep_check.models.GlobalDependencies$ 0 0 0 0 0 0 0 0 0
from setuptools import Extension , setup [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , build_golang = { [string] : [string] } , ext_modules = [ Extension ( [string] , sources = [ [string] ] , py_limited_api = True , define_macros = [ ( [string] , None ) ] , ) ] , setup_requires = [ [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import typing [EOL] import dep_check [EOL] from dep_check . dependency_finder import get_dependencies [EOL] from dep_check . infra . go_parser import GoParser [EOL] from dep_check . models import Dependency , Module , SourceCode , SourceFile [EOL] [EOL] PARSER = GoParser ( ) [EOL] [EOL] [EOL] def test_empty ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] source_code = SourceCode ( [string] ) [EOL] source_file = SourceFile ( module = module , code = source_code ) [EOL] [EOL] [comment] [EOL] dependencies = get_dependencies ( source_file , PARSER ) [EOL] [EOL] [comment] [EOL] assert dependencies == frozenset ( ) [EOL] [EOL] [EOL] def test_nominal ( ) : [EOL] source_file = SourceFile ( Module ( [string] ) , SourceCode ( [string] ) , ) [EOL] [EOL] assert get_dependencies ( source_file , PARSER ) == { Dependency ( [string] ) , Dependency ( [string] ) , Dependency ( [string] ) , Dependency ( [string] ) , Dependency ( [string] ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.go_parser.GoParser$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.go_parser.GoParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.go_parser.GoParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] from pytest import raises [EOL] [EOL] from dep_check . use_cases . app_configuration import ( AppConfigurationAlreadySetException , AppConfigurationSingleton , ) [EOL] [EOL] [EOL] def test_app_configuration_already_set ( ) : [EOL] [docstring] [EOL] [comment] [EOL] AppConfigurationSingleton . _already_set = True [comment] [EOL] config = Mock ( ) [EOL] [EOL] [comment] [EOL] with raises ( AppConfigurationAlreadySetException ) : [EOL] AppConfigurationSingleton . define_app_configuration ( config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Dict [EOL] import typing [EOL] import dep_check [EOL] from dep_check . models import Dependency , Module , SourceCode , SourceFile [EOL] [EOL] SIMPLE_FILE = SourceFile ( module = Module ( [string] ) , code = SourceCode ( [string] ) , ) [EOL] FILE_WITH_LOCAL_IMPORT = SourceFile ( module = Module ( [string] ) , code = SourceCode ( [string] ) , ) [EOL] FILE_WITH_STD_IMPORT = SourceFile ( module = Module ( [string] ) , code = SourceCode ( [string] ) , ) [EOL] [EOL] GLOBAL_DEPENDENCIES = { [string] : set ( ( Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) ) , ) ) , [string] : set ( ( Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) ) , ) ) , [string] : set ( ( Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) ) ) ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[dep_check.models.Dependency]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import dep_check [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] from pytest import raises [EOL] [EOL] from dep_check . checker import NotAllowedDependencyException , check_dependency [EOL] from dep_check . infra . python_parser import PythonParser [EOL] from dep_check . models import Dependency , Module , ModuleWildcard , Rules [EOL] [EOL] PARSER = PythonParser ( ) [EOL] [EOL] [EOL] def test_empty ( ) : [EOL] [docstring] [EOL] [comment] [EOL] dependency = Dependency ( Module ( [string] ) ) [EOL] authorized_modules = [ ] [EOL] [EOL] [comment] [EOL] with raises ( NotAllowedDependencyException ) as error : [EOL] check_dependency ( PARSER , dependency , authorized_modules ) [EOL] [EOL] [comment] [EOL] assert error [EOL] assert error . value . dependency == dependency . main_import [EOL] assert error . value . authorized_modules == authorized_modules [EOL] [EOL] [EOL] def test_passing_case ( ) : [EOL] [docstring] [EOL] [comment] [EOL] dependency = Dependency ( Module ( [string] ) ) [EOL] rules = [ ( ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) ) , ( ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) ) , ] [EOL] [EOL] [comment] [EOL] error = None [EOL] try : [EOL] check_dependency ( PARSER , dependency , rules ) [EOL] except NotAllowedDependencyException as exception : [EOL] error = exception [EOL] [EOL] [comment] [EOL] assert not error [EOL] [EOL] [EOL] def test_not_passing_case ( ) : [EOL] [docstring] [EOL] [comment] [EOL] dependency = Dependency ( Module ( [string] ) ) [EOL] rules = [ ( ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) ) , ( ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) ) , ( ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) ) , ] [EOL] [EOL] [comment] [EOL] with raises ( NotAllowedDependencyException ) as error : [EOL] check_dependency ( PARSER , dependency , rules ) [EOL] [EOL] [comment] [EOL] assert error [EOL] assert error . value . dependency == dependency . main_import [EOL] assert error . value . authorized_modules == [ r for _ , r in rules ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Set [EOL] import typing [EOL] import dep_check [EOL] [docstring] [EOL] import re [EOL] [EOL] from dep_check . dependency_finder import get_dependencies , get_import_from_dependencies [EOL] from dep_check . infra . python_parser import PythonParser [EOL] from dep_check . models import Dependency , Module , ModuleWildcard , SourceCode , SourceFile [EOL] [EOL] _SIMPLE_CASE = [string] [EOL] _SIMPLE_RESULT = frozenset ( ( Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) ) , ) ) [EOL] _SIMPLE_RESULT_IMPORT_FROM = frozenset ( ( Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) , frozenset ( ( Module ( [string] ) , ) ) ) , Dependency ( Module ( [string] ) ) , ) ) [EOL] [EOL] _LOCAL_CASE = [string] [EOL] _LOCAL_RESULT = set ( ( Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) ) , ) ) [EOL] _LOCAL_RESULT_IMPORT_FROM = set ( ( Dependency ( Module ( [string] ) ) , Dependency ( Module ( [string] ) , frozenset ( ( Module ( [string] ) , ) ) ) , Dependency ( Module ( [string] ) , frozenset ( ( Module ( [string] ) , ) ) ) , ) ) [EOL] [EOL] PARSER = PythonParser ( ) [EOL] [EOL] [EOL] class TestGetDependencies : [EOL] @ staticmethod def test_empty ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] source_code = SourceCode ( [string] ) [EOL] source_file = SourceFile ( module = module , code = source_code ) [EOL] [EOL] [comment] [EOL] dependencies = get_dependencies ( source_file , PARSER ) [EOL] [EOL] [comment] [EOL] assert dependencies == frozenset ( ) [EOL] [EOL] @ staticmethod def test_simple_case ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] source_file = SourceFile ( module = module , code = SourceCode ( _SIMPLE_CASE ) ) [EOL] [EOL] [comment] [EOL] dependencies = get_dependencies ( source_file , PARSER ) [EOL] [EOL] [comment] [EOL] assert dependencies == _SIMPLE_RESULT [EOL] [EOL] @ staticmethod def test_local_import_case ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] source_file = SourceFile ( module = module , code = SourceCode ( _LOCAL_CASE ) ) [EOL] [EOL] [comment] [EOL] dependencies = get_dependencies ( source_file , PARSER ) [EOL] [EOL] [comment] [EOL] assert dependencies == _LOCAL_RESULT [EOL] [EOL] [EOL] class TestGetImportFromDependencies : [EOL] @ staticmethod def test_empty ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] source_code = SourceCode ( [string] ) [EOL] source_file = SourceFile ( module = module , code = source_code ) [EOL] [EOL] [comment] [EOL] dependencies = get_import_from_dependencies ( source_file , PARSER ) [EOL] [EOL] [comment] [EOL] assert dependencies == frozenset ( ) [EOL] [EOL] @ staticmethod def test_simple_case ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] source_file = SourceFile ( module = module , code = SourceCode ( _SIMPLE_CASE ) ) [EOL] [EOL] [comment] [EOL] dependencies = get_import_from_dependencies ( source_file , PARSER ) [EOL] [EOL] [comment] [EOL] assert dependencies == _SIMPLE_RESULT_IMPORT_FROM [EOL] [EOL] @ staticmethod def test_local_import_case ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] source_file = SourceFile ( module = module , code = SourceCode ( _LOCAL_CASE ) ) [EOL] [EOL] [comment] [EOL] dependencies = get_import_from_dependencies ( source_file , PARSER ) [EOL] [EOL] [comment] [EOL] assert dependencies == _LOCAL_RESULT_IMPORT_FROM [EOL] [EOL] @ staticmethod def test_multi_imports_after_from ( ) : [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] source_file = SourceFile ( module = module , code = SourceCode ( [string] ) , ) [EOL] [EOL] [comment] [EOL] dependencies = get_import_from_dependencies ( source_file , PARSER ) [EOL] [EOL] [comment] [EOL] assert dependencies == set ( ( Dependency ( Module ( [string] ) , frozenset ( ( Module ( [string] ) , Module ( [string] ) , Module ( [string] ) , ) ) , ) , ) ) [EOL] [EOL] [EOL] class TestRegexToWildcard : [EOL] [docstring] [EOL] [EOL] @ staticmethod def test_empty ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = ModuleWildcard ( [string] ) [EOL] [EOL] [comment] [EOL] regex = PARSER . wildcard_to_regex ( module ) [EOL] [EOL] [comment] [EOL] assert regex == [string] [EOL] [EOL] @ staticmethod def test_simple_module ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = ModuleWildcard ( [string] ) [EOL] [EOL] [comment] [EOL] regex = PARSER . wildcard_to_regex ( module ) [EOL] [EOL] [comment] [EOL] assert re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] [EOL] @ staticmethod def test_nested_module ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = ModuleWildcard ( [string] ) [EOL] [EOL] [comment] [EOL] regex = PARSER . wildcard_to_regex ( module ) [EOL] [EOL] [comment] [EOL] assert re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] [EOL] @ staticmethod def test_quesiton_mark ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = ModuleWildcard ( [string] ) [EOL] [EOL] [comment] [EOL] regex = PARSER . wildcard_to_regex ( module ) [EOL] [EOL] [comment] [EOL] assert re . match ( regex , [string] ) [EOL] assert re . match ( regex , [string] ) [EOL] assert re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] [EOL] @ staticmethod def test_asterisk ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = ModuleWildcard ( [string] ) [EOL] [EOL] [comment] [EOL] regex = PARSER . wildcard_to_regex ( module ) [EOL] [EOL] [comment] [EOL] assert re . match ( regex , [string] ) [EOL] assert re . match ( regex , [string] ) [EOL] assert re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] [EOL] @ staticmethod def test_percentage ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = ModuleWildcard ( [string] ) [EOL] [EOL] [comment] [EOL] regex = PARSER . wildcard_to_regex ( module ) [EOL] [EOL] [comment] [EOL] assert re . match ( regex , [string] ) [EOL] assert re . match ( regex , [string] ) [EOL] assert re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL] assert not re . match ( regex , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.SourceCode$ 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 $dep_check.models.Module$ 0 $dep_check.models.Module$ 0 0 0 $dep_check.models.SourceCode$ 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 $dep_check.models.SourceFile$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 $dep_check.models.Module$ 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 $dep_check.models.SourceFile$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 $dep_check.models.Module$ 0 $dep_check.models.Module$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 $dep_check.models.SourceFile$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.SourceCode$ 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 $dep_check.models.Module$ 0 $dep_check.models.Module$ 0 0 0 $dep_check.models.SourceCode$ 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 $dep_check.models.SourceFile$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 $dep_check.models.Module$ 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 $dep_check.models.SourceFile$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 $dep_check.models.Module$ 0 $dep_check.models.Module$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 $dep_check.models.SourceFile$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.SourceFile$ 0 0 0 $dep_check.models.Module$ 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 $dep_check.models.SourceFile$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 $typing.Set[dep_check.models.Dependency]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 $dep_check.models.ModuleWildcard$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import Set , Iterator , Dict , Any [EOL] import typing [EOL] import dep_check [EOL] import unittest [EOL] [docstring] [EOL] [EOL] from typing import Iterator [EOL] from unittest . mock import Mock [EOL] [EOL] from dep_check . infra . python_parser import PythonParser [EOL] from dep_check . models import ModuleWildcard , SourceFile [EOL] from dep_check . use_cases . build import BuildConfigurationUC [EOL] from dep_check . use_cases . interfaces import Configuration [EOL] [EOL] PARSER = PythonParser ( ) [EOL] [EOL] [EOL] def test_empty ( ) : [EOL] [docstring] [EOL] [comment] [EOL] source_files = iter ( [ ] ) [EOL] dependencies_writer = Mock ( ) [EOL] use_case = BuildConfigurationUC ( dependencies_writer , PARSER , source_files , [string] ) [EOL] [EOL] [comment] [EOL] use_case . run ( ) [EOL] [EOL] [comment] [EOL] dependencies_writer . write . assert_called_with ( Configuration ( ) ) [EOL] [EOL] [EOL] def test_nominal ( source_files ) : [EOL] [docstring] [EOL] [comment] [EOL] dependencies_writer = Mock ( ) [EOL] use_case = BuildConfigurationUC ( dependencies_writer , PARSER , source_files , [string] ) [EOL] [EOL] [comment] [EOL] use_case . run ( ) [EOL] [EOL] [comment] [EOL] dependencies_writer . write . assert_called ( ) [comment] [EOL] configuration = dependencies_writer . write . call_args [ [number] ] [ [number] ] [EOL] assert not configuration . local_init [EOL] dependency_rules = { module_regex : set ( rules ) for module_regex , rules in configuration . dependency_rules . items ( ) } [EOL] assert dependency_rules == { [string] : set ( ( ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) , ) ) , [string] : set ( ( ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) , ) ) , [string] : set ( ( ModuleWildcard ( [string] ) , ModuleWildcard ( [string] ) ) ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dep_check.infra.python_parser.PythonParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterable [EOL] import typing [EOL] import dep_check [EOL] from typing import Iterable [EOL] [EOL] import pytest [EOL] [EOL] from dep_check . infra . std_lib_filter import StdLibSimpleFilter [EOL] from dep_check . models import SourceFile [EOL] from dep_check . use_cases . app_configuration import ( AppConfiguration , AppConfigurationSingleton , ) [EOL] [EOL] from . fakefile import FILE_WITH_LOCAL_IMPORT , FILE_WITH_STD_IMPORT , SIMPLE_FILE [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = [string] ) def setup_application_config ( ) : [EOL] [docstring] [EOL] app_configuration = AppConfiguration ( std_lib_filter = StdLibSimpleFilter ( ) ) [EOL] AppConfigurationSingleton . define_app_configuration ( app_configuration ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def source_files ( ) : [EOL] [docstring] [EOL] return SIMPLE_FILE , FILE_WITH_LOCAL_IMPORT , FILE_WITH_STD_IMPORT [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[dep_check.models.SourceFile]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Iterator , Dict , Any [EOL] import typing [EOL] import dep_check [EOL] [docstring] [EOL] [EOL] from pytest import raises [EOL] [EOL] from dep_check . models import Module , get_parent , iter_all_modules [EOL] [EOL] from . fakefile import GLOBAL_DEPENDENCIES [EOL] [EOL] [EOL] class TestGetParent : [EOL] [docstring] [EOL] [EOL] @ staticmethod def test_empty ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] [EOL] [comment] [EOL] parent = get_parent ( module ) [EOL] [EOL] [comment] [EOL] assert parent == [string] [EOL] [EOL] @ staticmethod def test_simple_module ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] [EOL] [comment] [EOL] parent = get_parent ( module ) [EOL] [EOL] [comment] [EOL] assert parent == Module ( [string] ) [EOL] [EOL] @ staticmethod def test_nested_module ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] [EOL] [comment] [EOL] parent = get_parent ( module ) [EOL] [EOL] [comment] [EOL] assert parent == Module ( [string] ) [EOL] [EOL] @ staticmethod def test_long_nested_module ( ) : [EOL] [docstring] [EOL] [comment] [EOL] module = Module ( [string] ) [EOL] [EOL] [comment] [EOL] parent = get_parent ( module ) [EOL] [EOL] [comment] [EOL] assert parent == Module ( [string] ) [EOL] [EOL] [EOL] class TestIterAllModules : [EOL] [docstring] [EOL] [EOL] @ staticmethod def test_empty ( ) : [EOL] [docstring] [EOL] [comment] [EOL] global_deps = { } [EOL] [EOL] [comment] [EOL] result_iter = iter_all_modules ( global_deps ) [EOL] [EOL] [comment] [EOL] with raises ( StopIteration ) : [EOL] next ( result_iter ) [EOL] [EOL] @ staticmethod def test_nominal ( ) : [EOL] [docstring] [EOL] [comment] [EOL] global_deps = GLOBAL_DEPENDENCIES [EOL] [EOL] [comment] [EOL] result_iter = iter_all_modules ( global_deps ) [EOL] [EOL] [comment] [EOL] all_modules = list ( ) [EOL] for module in result_iter : [EOL] all_modules . append ( module ) [EOL] [EOL] assert sorted ( all_modules ) == sorted ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 $dep_check.models.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Iterator[dep_check.models.Module]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[dep_check.models.Module]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Iterator[dep_check.models.Module]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Iterator[dep_check.models.Module]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0