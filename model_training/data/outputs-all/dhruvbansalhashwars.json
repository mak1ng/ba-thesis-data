	0
from typing import Union , Dict [EOL] import typing [EOL] from hashwars import * [EOL] [EOL] FIXTURES = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] def new_genesis_block ( id = None , initial_difficulty = None ) : [EOL] return Block ( ( id if id is not None else FIXTURES [ [string] ] ) , None , ( initial_difficulty if initial_difficulty is not None else FIXTURES [ [string] ] ) , height = [number] ) [comment] [EOL] [EOL] def new_blockchain ( id = None , genesis_block = None , block_time = None , difficulty_readjustment_period = None , initial_difficulty = None , max_difficulty_change_factor = None ) : [EOL] return Blockchain ( ( id if id is not None else FIXTURES [ [string] ] ) , ( genesis_block if genesis_block is not None else new_genesis_block ( ) ) , block_time = ( block_time if block_time is not None else FIXTURES [ [string] ] ) , difficulty_readjustment_period = ( difficulty_readjustment_period if difficulty_readjustment_period is not None else FIXTURES [ [string] ] ) , initial_difficulty = ( initial_difficulty if initial_difficulty is not None else FIXTURES [ [string] ] ) , max_difficulty_change_factor = ( max_difficulty_change_factor if max_difficulty_change_factor is not None else FIXTURES [ [string] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0
from pytest import raises [EOL] from pytest import mark [EOL] from mock import patch [EOL] [EOL] from hashwars import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . base import * [EOL] [EOL] class TestTransmission ( object ) : [EOL] [EOL] def setup ( self ) : [EOL] reset_simulation ( ) [EOL] self . source_agent = Agent ( [string] , [number] ) [EOL] self . transmission = Transmission ( [string] , self . source_agent , current_time ( ) ) [EOL] self . near_target = Agent ( [string] , [number] ) [EOL] self . far_target = Agent ( [string] , [number] ) [EOL] add_agent ( self . source_agent ) [EOL] add_agent ( self . transmission ) [EOL] add_agent ( self . near_target ) [EOL] add_agent ( self . far_target ) [EOL] [EOL] def test_receive ( self ) : [EOL] other_transmission = Transmission ( [string] , self . near_target , current_time ( ) ) [EOL] self . transmission . receive ( other_transmission , current_time ( ) + [number] ) [EOL] assert len ( self . transmission . transmissions_received ) == [number] [EOL] [EOL] def test_advance_once_without_reaching_any_targets ( self ) : [EOL] with patch . object ( self . transmission , [string] ) as transmission_receive : [EOL] with patch . object ( self . source_agent , [string] ) as source_agent_receive : [EOL] with patch . object ( self . near_target , [string] ) as near_target_receive : [EOL] with patch . object ( self . far_target , [string] ) as far_target_receive : [EOL] advance_time ( [number] ) [EOL] assert not transmission_receive . called [EOL] assert not source_agent_receive . called [EOL] assert not near_target_receive . called [EOL] assert not far_target_receive . called [EOL] [EOL] def test_advance_once_reaching_near_target ( self ) : [EOL] with patch . object ( self . transmission , [string] ) as transmission_receive : [EOL] with patch . object ( self . source_agent , [string] ) as source_agent_receive : [EOL] with patch . object ( self . near_target , [string] ) as near_target_receive : [EOL] with patch . object ( self . far_target , [string] ) as far_target_receive : [EOL] advance_time ( [number] ) [EOL] assert not transmission_receive . called [EOL] assert not source_agent_receive . called [EOL] assert near_target_receive . called [EOL] assert not far_target_receive . called [EOL] [EOL] def test_advance_once_reaching_both_targets ( self ) : [EOL] with patch . object ( self . transmission , [string] ) as transmission_receive : [EOL] with patch . object ( self . source_agent , [string] ) as source_agent_receive : [EOL] with patch . object ( self . near_target , [string] ) as near_target_receive : [EOL] with patch . object ( self . far_target , [string] ) as far_target_receive : [EOL] advance_time ( [number] ) [EOL] assert not transmission_receive . called [EOL] assert not source_agent_receive . called [EOL] assert near_target_receive . called [EOL] assert far_target_receive . called [EOL] [comment] [EOL] [EOL] def test_advance_twice_reaching_each_target_in_turn ( self ) : [EOL] advance_time ( [number] ) [EOL] with patch . object ( self . transmission , [string] ) as transmission_receive : [EOL] with patch . object ( self . source_agent , [string] ) as source_agent_receive : [EOL] with patch . object ( self . near_target , [string] ) as near_target_receive : [EOL] with patch . object ( self . far_target , [string] ) as far_target_receive : [EOL] advance_time ( [number] ) [EOL] assert not transmission_receive . called [EOL] assert not source_agent_receive . called [EOL] assert not near_target_receive . called [EOL] assert far_target_receive . called [EOL] [EOL] def test_advance_once_reaching_near_target_at_double_speed ( self ) : [EOL] self . transmission . speed = [number] [EOL] with patch . object ( self . transmission , [string] ) as transmission_receive : [EOL] with patch . object ( self . source_agent , [string] ) as source_agent_receive : [EOL] with patch . object ( self . near_target , [string] ) as near_target_receive : [EOL] with patch . object ( self . far_target , [string] ) as far_target_receive : [EOL] advance_time ( [number] ) [EOL] assert not transmission_receive . called [EOL] assert not source_agent_receive . called [EOL] assert near_target_receive . called [EOL] assert not far_target_receive . called [EOL] [EOL] def test_transmission_removes_itself_from_simulation_after_reaching_boundary ( self ) : [EOL] assert get_agent ( self . transmission . id ) is not None [EOL] advance_time ( [number] ) [EOL] with raises ( KeyError ) : [EOL] get_agent ( self . transmission . id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from test . base import * [EOL] [EOL] class TestDuration ( ) : [EOL] [EOL] def test_requires_correctly_ordered_start_and_end ( self ) : [EOL] with raises ( AssertionError , match = [string] ) : [EOL] Duration ( [number] , [number] ) [EOL] [EOL] def test_length ( self ) : [EOL] assert Duration ( [number] , [number] ) . length == [number] [EOL] assert Duration ( [number] , [number] ) . length == [number] [EOL] assert Duration ( [number] , [number] ) . length == [number] [EOL] assert Duration ( - [number] , [number] ) . length == [number] [EOL] [EOL] def test_contains ( self ) : [EOL] assert Duration ( [number] , [number] ) . contains ( [number] ) [EOL] assert Duration ( [number] , [number] ) . contains ( [number] ) [EOL] assert not Duration ( [number] , [number] ) . contains ( [number] ) [EOL] [EOL] def test_random_time ( self ) : [EOL] assert [number] < Duration ( [number] , [number] ) . random_time ( ) < [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . utils import * [EOL] from . state import * [EOL] from . agent import * [EOL] from . blockchain import * [EOL] from . miners import * [EOL] from . simulate import * [EOL] from . plot import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import hashwars [EOL] from . agent import PoissonAgent [EOL] from . blockchain import Block , BlockchainTransmission [EOL] from . state import add_agent , log [EOL] [EOL] class Miners ( PoissonAgent ) : [EOL] [EOL] def __init__ ( self , id , location , blockchain , initial_hashrate = [number] , difficulty_premium = [number] , active = True ) : [EOL] PoissonAgent . __init__ ( self , id , location , active = active ) [EOL] self . blockchain = blockchain [EOL] self . hashrate = initial_hashrate [EOL] self . difficulty_premium = difficulty_premium [EOL] [EOL] def log_advance ( self , duration ) : [EOL] log ( [string] . format ( self . id , [ transmission . id for transmission in self . transmissions_received . values ( ) ] , self . blockchain . height , self . blockchain . weight ) ) [EOL] [EOL] def mean_time_between_actions ( self ) : [EOL] return ( ( self . blockchain . difficulty * self . difficulty_premium ) / self . hashrate ) [EOL] [EOL] def act ( self , time ) : [EOL] block = Block ( id = [string] . format ( self . id , Block . new_id ( ) ) , previous = self . blockchain . tip , difficulty = ( self . blockchain . difficulty * self . difficulty_premium ) , time = time , ) [EOL] if self . blockchain . add ( block ) : [EOL] log ( [string] . format ( self . id , block . id ) ) [EOL] transmission = BlockchainTransmission ( [string] . format ( self . blockchain ) , self , time , self . blockchain . copy ( ) ) [EOL] add_agent ( transmission ) [EOL] [EOL] def react ( self , time , transmission ) : [EOL] if isinstance ( transmission , ( BlockchainTransmission , ) ) : [EOL] self . blockchain . merge ( transmission . blockchain ) [EOL] PoissonAgent . react ( self , time , transmission ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashwars.blockchain.block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashwars.blockchain.block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashwars.blockchain.block.Block$ 0 0 0 0 0 $hashwars.blockchain.blockchain.BlockchainTransmission$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashwars.blockchain.blockchain.BlockchainTransmission$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from concurrent . futures import ProcessPoolExecutor [EOL] from random import shuffle [EOL] [EOL] from . utils import notify [EOL] [EOL] def single_static_binary_simulation ( namespace , name , distance , hashrate_ratio , simulator_argv ) : [EOL] simulator = getattr ( namespace , name ) [EOL] distance = float ( distance ) [EOL] hashrate_ratio = float ( hashrate_ratio ) [EOL] notify ( [string] . format ( name ) ) [EOL] notify ( [string] . format ( distance ) ) [EOL] notify ( [string] . format ( hashrate_ratio ) ) [EOL] notify ( [string] . format ( simulator_argv ) ) [EOL] return simulator ( ( distance , hashrate_ratio , simulator_argv ) ) [EOL] [EOL] def many_static_binary_simulations ( namespace , name , count , distances , hashrate_ratios , simulator_argv ) : [EOL] simulator = getattr ( namespace , name ) [EOL] notify ( [string] . format ( name ) ) [EOL] notify ( [string] . format ( distances [ [number] ] , distances [ - [number] ] , len ( distances ) ) ) [EOL] notify ( [string] . format ( hashrate_ratios [ [number] ] , hashrate_ratios [ - [number] ] , len ( hashrate_ratios ) ) ) [EOL] notify ( [string] . format ( count ) ) [EOL] notify ( [string] . format ( simulator_argv ) ) [EOL] [EOL] runs = [ ] [EOL] for distance in distances : [EOL] for hashrate_ratio in hashrate_ratios : [EOL] for run in range ( count ) : [EOL] runs . append ( ( distance , hashrate_ratio , simulator_argv ) ) [EOL] [EOL] notify ( [string] . format ( len ( runs ) ) ) [EOL] notify ( [string] ) [EOL] shuffle ( runs ) [EOL] notify ( [string] ) [EOL] with ProcessPoolExecutor ( ) as executor : [EOL] results_list = list ( executor . map ( simulator , runs ) ) [EOL] notify ( [string] ) [EOL] results_matrix = [ ] [EOL] for distance in distances : [EOL] results_row_at_distance = [ ] [EOL] results_at_distance_list = [ result for result in results_list if result [ [number] ] == distance ] [EOL] for hashrate_ratio in hashrate_ratios : [EOL] results_row_at_distance . append ( [ result [ [number] ] for result in results_at_distance_list if result [ [number] ] == hashrate_ratio ] ) [EOL] results_matrix . append ( results_row_at_distance ) [EOL] notify ( [string] ) [EOL] return ( distances , hashrate_ratios , results_matrix ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . base import Agent [EOL] from . poisson import PoissonAgent [EOL] from . transmission import Transmission [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Type , List [EOL] import typing [EOL] import hashwars [EOL] from math import exp , factorial [EOL] from random import random [EOL] [EOL] from . base import Agent [EOL] [EOL] [comment] [EOL] class PoissonAgent ( Agent ) : [EOL] [EOL] MAX_FACTORIAL = [number] [comment] [EOL] FACTORIALS = [ factorial ( k ) for k in range ( MAX_FACTORIAL ) ] [EOL] MAX_ACTIONS = [number] [EOL] [EOL] def __init__ ( self , id , location , max_actions_per_advance = None , active = True ) : [EOL] Agent . __init__ ( self , id , location , active = active ) [EOL] self . max_actions_per_advance = ( max_actions_per_advance if max_actions_per_advance is not None else self . MAX_ACTIONS ) [EOL] assert self . max_actions_per_advance <= self . MAX_FACTORIAL [EOL] [EOL] def actions_for ( self , duration ) : [EOL] actions = [ ] [EOL] if not self . active : return actions [EOL] for action in range ( self . number_of_actions_for ( duration ) ) : [EOL] actions . append ( ( duration . random_time ( ) , None ) ) [EOL] return actions [EOL] [EOL] def number_of_actions_for ( self , duration ) : [EOL] [comment] [EOL] l = ( [number] / self . mean_time_between_actions ( ) ) * duration . length [EOL] [comment] [EOL] k_max = self . max_actions_per_advance [EOL] [comment] [EOL] [comment] [EOL] probabilities = [ exp ( - [number] * l ) * ( pow ( l , k ) / self . FACTORIALS [ k ] ) for k in range ( k_max ) ] [EOL] [comment] [EOL] r = random ( ) [EOL] [comment] [EOL] for k , p_k in enumerate ( probabilities ) : [EOL] if r <= p_k : [EOL] return k [EOL] else : [EOL] r -= p_k [EOL] [comment] [EOL] [comment] [EOL] return k_max [EOL] [EOL] def mean_time_between_actions ( self ) : [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from itertools import chain [EOL] [EOL] from hashwars . state import log [EOL] [EOL] class Agent ( object ) : [EOL] [EOL] def __init__ ( self , id , location , active = True ) : [EOL] self . id = id [EOL] self . location = location [EOL] self . transmissions_received = { } [EOL] self . active = active [EOL] self . priority = [number] [EOL] [EOL] def __str__ ( self ) : [EOL] return self . id [EOL] [EOL] def log_advance ( self , duration ) : [EOL] log ( [string] . format ( self . id , [ transmission . id for transmission in self . transmissions_received . values ( ) ] ) ) [EOL] [EOL] def advance ( self , duration ) : [EOL] self . log_advance ( duration ) [EOL] for action in sorted ( chain ( self . actions_for ( duration ) , list ( self . transmissions_received . items ( ) ) ) , key = lambda action : action [ [number] ] ) : [EOL] if action [ [number] ] is not None : [EOL] self . react ( action [ [number] ] , action [ [number] ] ) [EOL] else : [EOL] self . act ( action [ [number] ] ) [EOL] [EOL] def actions_for ( self , duration ) : [EOL] return [ ] [EOL] [EOL] def distance_to ( self , location ) : [EOL] return abs ( self . location - location ) [EOL] [EOL] def receive ( self , time , transmission ) : [EOL] log ( [string] . format ( self . id , transmission . id ) ) [EOL] self . transmissions_received [ time ] = transmission [EOL] [EOL] def act ( self , time ) : [EOL] pass [EOL] [EOL] def react ( self , time , transmission ) : [EOL] self . transmissions_received = { time : t for time , t in self . transmissions_received . items ( ) if t != transmission } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from . base import Agent [EOL] [EOL] class DelayedAgent ( Agent ) : [EOL] [EOL] def __init__ ( self , id , location , act_at , active = True ) : [EOL] Agent . __init__ ( self , id , location , active = active ) [EOL] self . act_at = act_at [EOL] [EOL] def actions_for ( self , duration ) : [EOL] actions = [ ] [EOL] if not self . active : return actions [EOL] if duration . contains ( self . act_at ) : [EOL] actions . append ( [ ( self . act_at , None ) ] ) [EOL] return actions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from random import random [EOL] [EOL] class Duration ( object ) : [EOL] [EOL] def __init__ ( self , start , end ) : [EOL] assert end > start , [string] [EOL] self . start = start [EOL] self . end = end [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . start , self . end ) [EOL] [EOL] @ property def length ( self ) : [EOL] return ( self . end - self . start ) [EOL] [EOL] def contains ( self , time ) : [EOL] if time < self . start : return False [EOL] if time > self . end : return False [EOL] return True [EOL] [EOL] def random_time ( self ) : [EOL] return self . start + ( self . length * random ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] import hashwars [EOL] from typing import Optional [EOL] [EOL] from hashwars . utils import random_string [EOL] [EOL] class Block ( ) : [EOL] [EOL] def __init__ ( self , id , previous , difficulty , height = None , time = None ) : [EOL] self . id = id [EOL] self . previous = previous [EOL] self . difficulty = difficulty [EOL] self . height = height [EOL] self . time = time [EOL] [EOL] def __str__ ( self ) : [EOL] height_info = [string] . format ( self . height ) if self . height is not None else [string] [EOL] return [string] . format ( self . id , self . difficulty , height_info ) [EOL] [EOL] @ classmethod def new_id ( self ) : [EOL] return random_string ( [number] ) [EOL] [EOL] @ property def weight ( self ) : [EOL] return self . difficulty [EOL] [EOL] def copy ( self , include_height = False ) : [EOL] return Block ( id = self . id , previous = self . previous , difficulty = self . difficulty , time = self . time , height = ( self . height if include_height else None ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $hashwars.blockchain.block.Block$ 0 $builtins.float$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $hashwars.blockchain.block.Block$ 0 $hashwars.blockchain.block.Block$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $'Block'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , List [EOL] import typing [EOL] import block [EOL] import hashwars [EOL] import builtins [EOL] from typing import Optional [EOL] [EOL] from numpy import mean [EOL] [EOL] from hashwars . state import log [EOL] from hashwars . agent import Agent , Transmission [EOL] [EOL] from . block import Block [EOL] [EOL] class Blockchain ( ) : [EOL] [EOL] def __init__ ( self , id , genesis_block , block_time = [number] , difficulty_readjustment_period = [number] , initial_difficulty = [number] , max_difficulty_change_factor = [number] ) : [EOL] [EOL] assert genesis_block . height == [number] [EOL] assert genesis_block . previous is None [EOL] [EOL] assert block_time > [number] [EOL] assert difficulty_readjustment_period > [number] [EOL] assert initial_difficulty > [number] [EOL] assert max_difficulty_change_factor > [number] [EOL] [EOL] self . id = id [EOL] self . genesis_block = genesis_block [EOL] self . block_time = block_time [EOL] [EOL] self . blocks = { } [EOL] self . blocks [ self . genesis_block . id ] = self . genesis_block [EOL] self . heights = [ self . genesis_block . id ] [EOL] self . height = len ( self . heights ) [EOL] self . weight = self . genesis_block . difficulty [EOL] [EOL] self . difficulty_readjustment_period = difficulty_readjustment_period [EOL] self . difficulty = initial_difficulty [EOL] self . max_difficulty_change_factor = max_difficulty_change_factor [EOL] self . inverse_max_difficulty_change_factor = ( [number] / self . max_difficulty_change_factor ) [EOL] [EOL] self . chain_params = ( self . genesis_block . id , self . block_time , self . difficulty_readjustment_period , self . max_difficulty_change_factor , ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . id , self . tip . id , self . tip . previous . id if self . tip . previous else [string] , self . weight , self . height ) [EOL] [EOL] @ property def tip ( self ) : [EOL] return self . blocks [ self . heights [ - [number] ] ] [EOL] [EOL] def copy ( self ) : [EOL] blockchain = Blockchain ( id = self . id , genesis_block = self . genesis_block , block_time = self . block_time , difficulty_readjustment_period = self . difficulty_readjustment_period , initial_difficulty = self . difficulty , max_difficulty_change_factor = self . max_difficulty_change_factor ) [EOL] blockchain . blocks = { block_id : block for ( block_id , block ) in self . blocks . items ( ) } [EOL] blockchain . heights = [ block_id for block_id in self . heights ] [EOL] blockchain . height = self . height [EOL] blockchain . weight = self . weight [EOL] return blockchain [EOL] [EOL] def merge ( self , other ) : [EOL] log ( [string] . format ( self , other ) ) [EOL] [EOL] assert other . chain_params == self . chain_params [EOL] [EOL] if other . weight < self . weight : [EOL] log ( [string] . format ( self , other ) ) [EOL] return False [EOL] [EOL] log ( [string] . format ( self , other ) ) [EOL] self . blocks = { block_id : block for ( block_id , block ) in other . blocks . items ( ) } [EOL] self . heights = [ block_id for block_id in other . heights ] [EOL] self . height = other . height [EOL] self . weight = other . weight [EOL] self . difficulty = other . difficulty [EOL] return True [EOL] [EOL] def add ( self , block ) : [EOL] log ( [string] . format ( self , block ) ) [EOL] if block . difficulty < self . difficulty : [EOL] log ( [string] . format ( self , block , block . difficulty , self . difficulty ) ) [EOL] return False [EOL] if block . previous . id != self . tip . id : [EOL] if block . previous . id in self . blocks : [EOL] log ( [string] . format ( self , block ) ) [EOL] else : [EOL] log ( [string] . format ( self , block , block . previous . id ) ) [EOL] return False [EOL] [EOL] log ( [string] . format ( self , block ) ) [EOL] self . blocks [ block . id ] = block [EOL] self . heights . append ( block . id ) [EOL] self . height += [number] [EOL] self . weight += block . difficulty [EOL] [comment] [EOL] [comment] [EOL] return True [EOL] [EOL] def readjust_difficulty ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] log ( [string] . format ( self , self . height ) ) [EOL] blocks = [ self . blocks [ block_id ] for block_id in list ( reversed ( self . heights ) ) [ : self . difficulty_readjustment_period ] ] [EOL] block_gaps = [ ( blocks [ index + [number] ] . time - block . time ) for index , block in enumerate ( blocks [ : - [number] ] ) ] [EOL] observed_block_time = mean ( block_gaps ) [EOL] old_difficulty = self . difficulty [EOL] new_difficulty = ( self . block_time * old_difficulty ) / observed_block_time [EOL] difficulty_change_ratio = new_difficulty / old_difficulty [EOL] if difficulty_change_ratio > self . max_difficulty_change_factor : [EOL] difficulty_change_ratio = self . max_difficulty_change_factor [EOL] elif difficulty_change_ratio < self . inverse_max_difficulty_change_factor : [EOL] difficulty_change_ratio = self . inverse_max_difficulty_change_factor [EOL] self . difficulty = old_difficulty * difficulty_change_ratio [EOL] log ( [string] . format ( self , old_difficulty , self . difficulty ) ) [EOL] [EOL] [EOL] class BlockchainTransmission ( Transmission ) : [EOL] [EOL] def __init__ ( self , id , source_agent , transmission_time , blockchain , speed = [number] ) : [EOL] Transmission . __init__ ( self , id , source_agent , transmission_time , speed = speed ) [EOL] self . blockchain = blockchain [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $hashwars.blockchain.block.Block$ 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $hashwars.blockchain.block.Block$ 0 0 0 0 0 0 $hashwars.blockchain.block.Block$ 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $hashwars.blockchain.block.Block$ 0 $hashwars.blockchain.block.Block$ 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashwars.blockchain.block.Block$ 0 $builtins.str$ 0 0 0 0 $hashwars.blockchain.block.Block$ 0 0 0 0 0 0 0 0 $hashwars.blockchain.block.Block$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashwars.blockchain.block.Block$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $hashwars.blockchain.block.Block$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Blockchain'$ 0 0 0 0 0 $hashwars.blockchain.blockchain.Blockchain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashwars.blockchain.blockchain.Blockchain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashwars.blockchain.blockchain.Blockchain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $hashwars.blockchain.blockchain.Blockchain$ 0 0 0 0 0 0 0 $hashwars.blockchain.blockchain.Blockchain$ 0 0 0 0 0 0 0 0 $hashwars.blockchain.blockchain.Blockchain$ 0 0 0 $builtins.bool$ 0 0 0 $'Blockchain'$ 0 0 0 0 0 0 0 0 0 0 0 $'Blockchain'$ 0 0 0 0 0 $'Blockchain'$ 0 0 0 0 0 0 0 0 0 $'Blockchain'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Blockchain'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Blockchain'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Blockchain'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Blockchain'$ 0 0 0 0 0 0 0 0 $'Blockchain'$ 0 0 0 0 0 0 0 $'Blockchain'$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $'Blockchain'$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $block.Block$ 0 0 0 0 0 0 0 0 0 0 0 $block.Block$ 0 0 0 0 $block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $block.Block$ 0 $block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $block.Block$ 0 $block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $block.Block$ 0 0 0 0 0 0 0 $block.Block$ 0 0 0 0 $block.Block$ 0 0 0 0 0 0 0 $block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $hashwars.agent.Agent$ 0 $builtins.float$ 0 $hashwars.blockchain.blockchain.Blockchain$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $hashwars.agent.Agent$ 0 $builtins.float$ 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 $hashwars.blockchain.blockchain.Blockchain$ 0 $hashwars.blockchain.blockchain.Blockchain$ 0
from . block import Block [EOL] from . blockchain import Blockchain , BlockchainTransmission [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . blockchain_launch_history import * [EOL] from . hashrate_distance_landscape import * [EOL] from . hashrate_distance_slices import * [EOL] from . money_supply import * [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import simulations [EOL] import hashwars [EOL] import argparse [EOL] from argparse import ArgumentParser [EOL] [EOL] from hashwars import * [EOL] [EOL] _DEFAULT_MIN_TIME = [number] [comment] [EOL] _DEFAULT_TIME_DISTANCE_RATIO = [number] [EOL] [EOL] _DEFAULT_STEPS = [number] [comment] [EOL] _DEFAULT_STEP_VARIANCE = [number] [comment] [EOL] [EOL] _DEFAULT_PREMIUM = [number] [EOL] [EOL] _parser = ArgumentParser ( description = [string] ) [EOL] _parser . add_argument ( [string] , [string] , help = [string] , type = float , default = _DEFAULT_MIN_TIME ) [EOL] _parser . add_argument ( [string] , [string] , help = [string] , type = float , default = _DEFAULT_TIME_DISTANCE_RATIO ) [EOL] _parser . add_argument ( [string] , help = [string] , type = int , default = _DEFAULT_STEPS ) [EOL] _parser . add_argument ( [string] , help = [string] , type = float , default = _DEFAULT_PREMIUM ) [EOL] [EOL] class MajorityMiners ( Miners ) : [EOL] [EOL] def react ( self , time , transmission ) : [EOL] if ( not self . active ) and isinstance ( transmission , ( BlockchainLaunch , ) ) : [EOL] self . active = True [EOL] log ( [string] . format ( self . id ) ) [EOL] Miners . react ( self , time , transmission ) [EOL] [EOL] class BlockchainLaunch ( Transmission ) : [EOL] pass [EOL] [EOL] def blockchain_launch ( params ) : [EOL] return _launch ( params , [string] ) [EOL] [EOL] def miner_launch ( params ) : [EOL] return _launch ( params , [string] ) [EOL] [EOL] def _launch ( params , mode ) : [EOL] distance , hashrate_ratio , argv = params [EOL] distance = float ( distance ) [EOL] hashrate_ratio = float ( hashrate_ratio ) [EOL] args = _parser . parse_args ( argv ) [EOL] [EOL] run_id = random_string ( ) [EOL] reset_simulation ( ) [EOL] set_log_id ( run_id ) [EOL] set_spatial_boundary ( - [number] , distance + [number] ) [EOL] [EOL] genesis_block = Block ( [string] , None , difficulty = [number] , height = [number] , time = current_time ( ) ) [EOL] minority_blockchain = Blockchain ( [string] , genesis_block ) [EOL] majority_blockchain = Blockchain ( [string] , genesis_block ) [EOL] minority_miners = Miners ( [string] , [number] , minority_blockchain , initial_hashrate = [number] ) [EOL] majority_miners = MajorityMiners ( [string] , distance , majority_blockchain , initial_hashrate = hashrate_ratio , difficulty_premium = args . premium , active = ( mode == [string] ) ) [EOL] [EOL] add_agent ( minority_miners ) [EOL] add_agent ( majority_miners ) [EOL] [EOL] if mode == [string] : [EOL] genesis_block_mined = BlockchainLaunch ( [string] , minority_miners , current_time ( ) ) [EOL] add_agent ( genesis_block_mined ) [EOL] [EOL] times = [ ] [EOL] minority_miners_minority_weight = [ ] [EOL] minority_miners_majority_weight = [ ] [EOL] majority_miners_minority_weight = [ ] [EOL] majority_miners_majority_weight = [ ] [EOL] [EOL] max_time = ( distance * args . time_distance_ratio ) [EOL] if max_time < args . min_time : max_time = args . min_time [EOL] [EOL] step = max_time / args . steps [EOL] steps_taken = [number] [EOL] while current_time ( ) < max_time : [EOL] advance_time ( _jitter ( step ) ) [EOL] steps_taken += [number] [EOL] [EOL] times . append ( current_time ( ) ) [EOL] [EOL] if minority_miners . blockchain . height > [number] : [EOL] minority_miners_minority_weight . append ( sum ( [ block . weight for block in minority_miners . blockchain . blocks . values ( ) if minority_miners . id in block . id ] ) ) [EOL] minority_miners_majority_weight . append ( sum ( [ block . weight for block in minority_miners . blockchain . blocks . values ( ) if majority_miners . id in block . id ] ) ) [EOL] else : [EOL] minority_miners_minority_weight . append ( [number] ) [EOL] minority_miners_majority_weight . append ( [number] ) [EOL] [EOL] if majority_miners . blockchain . height > [number] : [EOL] majority_miners_minority_weight . append ( sum ( [ block . weight for block in majority_miners . blockchain . blocks . values ( ) if minority_miners . id in block . id ] ) ) [EOL] majority_miners_majority_weight . append ( sum ( [ block . weight for block in majority_miners . blockchain . blocks . values ( ) if majority_miners . id in block . id ] ) ) [EOL] else : [EOL] majority_miners_minority_weight . append ( [number] ) [EOL] majority_miners_majority_weight . append ( [number] ) [EOL] [EOL] notify ( [string] . format ( run_id , max_time , step , steps_taken , distance , hashrate_ratio , minority_miners_minority_weight [ - [number] ] / ( minority_miners_minority_weight [ - [number] ] + minority_miners_majority_weight [ - [number] ] ) ) ) [EOL] return ( distance , hashrate_ratio , times , minority_miners_minority_weight , minority_miners_majority_weight , majority_miners_minority_weight , majority_miners_majority_weight , ) [EOL] [EOL] def _jitter ( step ) : [EOL] return ( step * ( [number] - _DEFAULT_STEP_VARIANCE / [number] ) ) + ( step * _DEFAULT_STEP_VARIANCE * random ( ) ) [EOL] [EOL] def blockchain_launch_minority_weight_fraction ( params ) : [EOL] return _minority_weight_fraction ( blockchain_launch ( params ) ) [EOL] [EOL] def miner_launch_minority_weight_fraction ( params ) : [EOL] return _minority_weight_fraction ( miner_launch ( params ) ) [EOL] [EOL] def _minority_weight_fraction ( results ) : [EOL] ( distance , hashrate_ratio , times , minority_miners_minority_weight , minority_miners_majority_weight , majority_miners_minority_weight , majority_miners_majority_weight ) = results [EOL] minority_weight_fraction = minority_miners_minority_weight [ - [number] ] / ( minority_miners_minority_weight [ - [number] ] + minority_miners_majority_weight [ - [number] ] ) [EOL] return ( distance , hashrate_ratio , minority_weight_fraction ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . blockchain_launch import * [EOL] from . money_supply import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0