from setuptools import setup , find_packages [EOL] [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , packages = find_packages ( exclude = [ [string] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
from typing import TypeVar , Callable , Iterable [EOL] import fmap [EOL] import builtins [EOL] import typing [EOL] from typing import Generic , TypeVar , Callable , Iterable [EOL] from abc import ABCMeta , abstractmethod [EOL] from . util import compose [EOL] [EOL] [EOL] A = TypeVar ( [string] ) [EOL] B = TypeVar ( [string] ) [EOL] C = TypeVar ( [string] ) [EOL] D = TypeVar ( [string] ) [EOL] E = TypeVar ( [string] ) [EOL] [EOL] [EOL] class Functor ( Generic [ A ] , metaclass = ABCMeta ) : [EOL] @ abstractmethod def fmap ( self , f ) : [EOL] ... [EOL] [EOL] def __or__ ( self , other ) : [EOL] return self . fmap ( other ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class MappedFunctor ( Generic [ A , B ] , Functor [ B ] ) : [EOL] def __init__ ( self , pipe , source , ) : [EOL] [comment] [EOL] self . _pipe = pipe [EOL] self . _source = source [EOL] [EOL] @ classmethod def from_mapped ( cls , f , source , ) : [EOL] new_pipe = compose ( f , source . _pipe ) [EOL] return cls ( new_pipe , source . _source ) [EOL] [EOL] def fmap ( self , f ) : [EOL] return self . from_mapped ( f , self ) [EOL] [EOL] def __repr__ ( self ) : [EOL] try : [EOL] return f' [string] { self . _pipe . __name__ } [string] { repr ( self . _source ) } [string] ' [EOL] except AttributeError : [EOL] return f' [string] { repr ( self . _pipe ) } [string] { repr ( self . _source ) } [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'MappedFunctor[A,C]'$ 0 0 0 $typing.Callable[[B],C]$ 0 0 0 0 0 0 0 0 $typing.Callable[[B],C]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar , Callable , Iterator , Iterable [EOL] import fmap [EOL] import builtins [EOL] import typing [EOL] from typing import TypeVar , Iterable , Callable , Iterator [EOL] from . meta import Functor , MappedFunctor [EOL] [EOL] [EOL] A = TypeVar ( [string] ) [EOL] B = TypeVar ( [string] ) [EOL] [EOL] [EOL] class IterableFunctor ( Functor [ A ] , Iterable [ A ] ) : [EOL] def __init__ ( self , source ) : [EOL] self . _source = source [EOL] [EOL] def fmap ( self , f ) : [EOL] return MappedIterableFunctor ( f , self . _source ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . _source ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f'{ self . __class__ . __name__ } [string] { self . _source } [string] ' [EOL] [EOL] [EOL] class MappedIterableFunctor ( MappedFunctor [ A , B ] , Iterable [ B ] ) : [EOL] _source = ... [EOL] [EOL] def __iter__ ( self ) : [EOL] return map ( self . _pipe , self . _source ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[A]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , TypeVar , Any , List , Callable [EOL] import typing [EOL] import fmap [EOL] from typing import Callable , TypeVar [EOL] from functools import reduce [EOL] [EOL] [EOL] A = TypeVar ( [string] ) [EOL] B = TypeVar ( [string] ) [EOL] C = TypeVar ( [string] ) [EOL] [EOL] [EOL] def const ( a ) : [EOL] return lambda b : a [EOL] [EOL] [EOL] def compose ( f , g , ) : [EOL] [docstring] [EOL] [EOL] args = [ f , g ] [EOL] functions = [ ] [comment] [EOL] name = [ ] [comment] [EOL] [EOL] for func in args : [EOL] try : [EOL] name . append ( func . __name__ ) [EOL] except AttributeError : [EOL] name . append ( repr ( func ) ) [EOL] [EOL] try : [EOL] functions += getattr ( func , [string] ) [EOL] except AttributeError : [EOL] functions . append ( func ) [EOL] [EOL] def _compose ( arg ) : [EOL] result = ... [EOL] result = reduce ( lambda acc , n : n ( acc ) , reversed ( functions ) , arg ) [EOL] return result [EOL] [EOL] _compose . __name__ = [string] . join ( name ) [EOL] setattr ( _compose , [string] , functions ) [EOL] [EOL] return _compose [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[A],C]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar , Callable , Iterable , Sequence [EOL] import meta [EOL] import sequence [EOL] import iterable [EOL] import typing [EOL] from typing import Callable , Iterable , Sequence , TypeVar , overload [EOL] from . meta import Functor [EOL] from . sequence import SequenceFunctor , MappedSequenceFunctor [EOL] from . iterable import IterableFunctor , MappedIterableFunctor [EOL] [EOL] [EOL] A = TypeVar ( [string] ) [EOL] B = TypeVar ( [string] ) [EOL] [EOL] [EOL] @ overload def fmap ( f , fa ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def fmap ( f , it ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def fmap ( f , seq ) : [EOL] ... [EOL] [EOL] [EOL] def fmap ( f , it ) : [comment] [EOL] try : [EOL] return it . fmap ( f ) [EOL] [EOL] except AttributeError : [EOL] if isinstance ( it , Sequence ) : [EOL] return SequenceFunctor ( it ) . fmap ( f ) [EOL] [EOL] elif isinstance ( it , Iterable ) : [EOL] return IterableFunctor ( it ) . fmap ( f ) [EOL] [EOL] raise TypeError ( f" [string] { type ( it ) }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0