import unittest [EOL] from hypothesis import given [EOL] from hypothesis . strategies import floats [EOL] from random import random [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] from undulator . utilities import wavelength2energy [EOL] [EOL] hc = [number] [EOL] [EOL] [EOL] class TestWavelength2Energy ( unittest . TestCase ) : [EOL] [EOL] def test_1nm ( self ) : [EOL] [docstring] [EOL] E = wavelength2energy ( [number] ) [EOL] self . assertAlmostEqual ( E , [number] ) [EOL] [EOL] @ given ( exmpl = floats ( min_value = [number] , exclude_min = True , allow_infinity = False , ) ) def test_back_conversion_works ( self , exmpl ) : [EOL] [docstring] [EOL] new_wavelength = hc / wavelength2energy ( exmpl ) [EOL] self . assertAlmostEqual ( new_wavelength / exmpl , [number] ) [EOL] [EOL] def test_no_negative_wavelengths ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( ValueError ) : [EOL] wavelength2energy ( - [number] ) [EOL] [EOL] def test_no_zero_wavelengths ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( ValueError ) : [EOL] wavelength2energy ( [number] ) [EOL] with self . assertRaises ( ValueError ) : [EOL] wavelength2energy ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] from hypothesis import given [EOL] from hypothesis . strategies import floats [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] from undulator . ebeam import sig , sigp , beamgamma , m [EOL] [EOL] [EOL] class TestSigFunction ( unittest . TestCase ) : [EOL] [EOL] def test_maxiv_y_params ( self ) : [EOL] [docstring] [EOL] self . assertAlmostEqual ( sig ( [number] , [number] ) , [number] ) [EOL] [EOL] def test_maxiv_x_params ( self ) : [EOL] [docstring] [EOL] self . assertAlmostEqual ( sig ( [number] , [number] ) , [number] ) [EOL] [EOL] @ given ( val = floats ( max_value = [number] , exclude_max = True ) ) def test_negative_emit_valueerror ( self , val ) : [EOL] [docstring] [EOL] with self . assertRaises ( ValueError ) : [EOL] sig ( val , [number] ) [EOL] [EOL] @ given ( val = floats ( max_value = [number] , exclude_max = True ) ) def test_negative_beta_valueerror ( self , val ) : [EOL] [docstring] [EOL] with self . assertRaises ( ValueError ) : [EOL] sig ( [number] , val ) [EOL] [EOL] [EOL] class TestSigpFunction ( unittest . TestCase ) : [EOL] [EOL] def test_maxiv_y_params ( self ) : [EOL] [docstring] [EOL] self . assertAlmostEqual ( sigp ( [number] , [number] ) , [number] ) [EOL] [EOL] def test_maxiv_x_params ( self ) : [EOL] [docstring] [EOL] self . assertAlmostEqual ( sigp ( [number] , [number] ) , [number] ) [EOL] [EOL] @ given ( val = floats ( max_value = [number] , exclude_max = True ) ) def test_negative_emit_valueerror ( self , val ) : [EOL] [docstring] [EOL] with self . assertRaises ( ValueError ) : [EOL] sig ( val , [number] ) [EOL] [EOL] @ given ( val = floats ( max_value = [number] , exclude_max = True ) ) def test_negative_beta_valueerror ( self , val ) : [EOL] [docstring] [EOL] with self . assertRaises ( ValueError ) : [EOL] sig ( [number] , val ) [EOL] [EOL] [EOL] class TestBeamGammaFunction ( unittest . TestCase ) : [EOL] [EOL] def test_maxiv_params ( self ) : [EOL] self . assertAlmostEqual ( beamgamma ( [number] ) , [number] , places = [number] ) [EOL] self . assertAlmostEqual ( beamgamma ( [number] ) , [number] , places = [number] ) [EOL] [EOL] def test_restframe_gamma ( self ) : [EOL] self . assertEqual ( beamgamma ( m ) , [number] ) [EOL] [EOL] @ given ( val = floats ( max_value = m , exclude_max = True ) ) def test_nonphysical_energy ( self , val ) : [EOL] [docstring] [EOL] with self . assertRaises ( ValueError ) : [EOL] beamgamma ( val ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import undulator [EOL] import unittest [EOL] from hypothesis import given [EOL] from hypothesis . strategies import integers [EOL] from math import pi [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] from undulator . undulator import Undulator [EOL] [EOL] [EOL] def quadrature_sum ( * args ) : [EOL] return sum ( v ** [number] for v in args ) ** [number] [EOL] [EOL] [EOL] class TestSigFunction ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . insdev = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] * [number] } [EOL] self . beam = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] self . ID = Undulator ( insdev = self . insdev , beam = self . beam ) [EOL] [EOL] def test_beam_attribute_references ( self ) : [EOL] [docstring] [EOL] for key , val in self . insdev . items ( ) : [EOL] val_in_ID = getattr ( self . ID . insdev , key ) [EOL] self . assertEqual ( val_in_ID , val ) [EOL] [EOL] for key , val in self . beam . items ( ) : [EOL] val_in_ID = getattr ( self . ID . beam , key ) [EOL] self . assertEqual ( val_in_ID , val ) [EOL] [EOL] def test_nanomax_lamdan ( self ) : [EOL] [docstring] [EOL] actual_value = self . ID . lamda_n ( ) [EOL] expected_value = [number] [EOL] self . assertAlmostEqual ( actual_value / expected_value , [number] ) [EOL] [EOL] def test_nanomax_energyn ( self ) : [EOL] [docstring] [EOL] actual_value = self . ID . energy_n ( ) [EOL] expected_value = [number] [EOL] self . assertAlmostEqual ( actual_value , expected_value ) [EOL] [EOL] @ given ( val = integers ( min_value = [number] , max_value = [number] ) ) def test_harmonic_wavelengths ( self , val ) : [EOL] expected_value = self . ID . lamda_n ( n = [number] ) / val [EOL] actual_value = self . ID . lamda_n ( n = val ) [EOL] self . assertAlmostEqual ( expected_value / actual_value , [number] ) [EOL] [EOL] @ given ( val = integers ( min_value = [number] , max_value = [number] ) ) def test_harmonic_energy ( self , val ) : [EOL] expected_value = self . ID . energy_n ( n = [number] ) * val [EOL] actual_value = self . ID . energy_n ( n = val ) [EOL] self . assertAlmostEqual ( expected_value / actual_value , [number] ) [EOL] [EOL] @ given ( val = integers ( min_value = [number] , max_value = [number] ) ) def test_spectralwidth_undulator ( self , val ) : [EOL] expected_value = ( [number] / ( val * self . ID . insdev . Np ) ) * self . ID . lamda_n ( n = val ) [EOL] actual_value = self . ID . spectralwidth_undulator ( n = val ) [EOL] self . assertAlmostEqual ( expected_value / actual_value , [number] ) [EOL] [EOL] @ given ( val = integers ( min_value = [number] , max_value = [number] ) ) def test_diffspotsize ( self , val ) : [EOL] spotsize = self . ID . difflimited_spot ( n = val ) [EOL] actual_value = ( spotsize * [number] * pi ) ** [number] [EOL] expected_value = self . ID . lamda_n ( n = val ) * self . ID . insdev . L [EOL] self . assertAlmostEqual ( expected_value / actual_value , [number] ) [EOL] [EOL] @ given ( val = integers ( min_value = [number] , max_value = [number] ) ) def test_diffspotdiv ( self , val ) : [EOL] spotsize = self . ID . difflimited_div ( n = val ) [EOL] actual_value = spotsize ** [number] [EOL] expected_value = self . ID . lamda_n ( n = val ) / self . ID . insdev . L [EOL] self . assertAlmostEqual ( expected_value / actual_value , [number] ) [EOL] [EOL] def test_sourcespot_plane_must_be_right ( self ) : [EOL] [docstring] [EOL] alfa = [string] [EOL] for c in alfa + alfa . upper ( ) + [string] : [EOL] with self . assertRaises ( ValueError ) : [EOL] self . ID . source_spot ( plane = c ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $undulator.undulator.Undulator$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type , Any , Dict [EOL] import typing [EOL] import undulator [EOL] import builtins [EOL] [docstring] [EOL] from undulator . ebeam import sig , sigp , beamgamma , m [EOL] from undulator . utilities import wavelength2energy [EOL] c = [number] [EOL] [EOL] from collections import namedtuple [EOL] from math import pi [EOL] from typing import Dict [EOL] [EOL] Str2Float = Dict [ str , float ] [EOL] [EOL] class Undulator : [EOL] [docstring] [EOL] def __init__ ( self , insdev , beam ) : [EOL] [docstring] [EOL] self . insdev = objectdict ( insdev ) [EOL] self . beam = objectdict ( beam ) [EOL] [EOL] def __repr__ ( self ) : [EOL] insdev_repr = repr ( self . insdev . asdict ( ) ) [EOL] beam_repr = repr ( self . beam . asdict ( ) ) [EOL] return [string] + insdev_repr + [string] + beam_repr + [string] [EOL] [EOL] def lamda_n ( self , n = [number] , theta = [number] ) : [EOL] [docstring] [EOL] if n > [number] : [EOL] raise ValueError ( [string] + [string] ) [EOL] gamma = beamgamma ( self . beam . energy ) [EOL] unscaled = self . insdev . period / ( [number] * n * gamma ** [number] ) [EOL] return unscaled * ( [number] + self . insdev . Kmax ** [number] + ( gamma * theta ) ** [number] ) [EOL] [EOL] def energy_n ( self , n = [number] , theta = [number] ) : [EOL] [docstring] [EOL] return wavelength2energy ( self . lamda_n ( n = n , theta = theta ) ) [EOL] [EOL] def d2l_dtheta2 ( self , n = [number] ) : [EOL] return self . insdev . period / n [EOL] [EOL] def dl_dgamma ( self , n = [number] ) : [EOL] gamma = beamgamma ( self . beam . energy ) [EOL] return - ( [number] + self . insdev . Kmax ** [number] ) * self . insdev . period / ( n * gamma ** [number] ) [EOL] [EOL] def spectralwidth_ebeam ( self , n = [number] ) : [EOL] beam = self . beam [EOL] gamma = beamgamma ( beam . energy ) [EOL] sigp_y_sqr = sigp ( beam . emity , beam . betay ) ** [number] [EOL] dgamma = beam . energy * beam . espread / m [EOL] disp_term = [number] * self . d2l_dtheta2 ( n ) * sigp_y_sqr [EOL] energy_term = self . dl_dgamma ( n ) * gamma * dgamma / gamma [EOL] return ( disp_term ** [number] + energy_term ** [number] ) ** [number] [EOL] [EOL] def spectralwidth_undulator ( self , n = [number] , theta = [number] ) : [EOL] magic_num = [number] [comment] [EOL] return magic_num * self . lamda_n ( n , theta ) / ( n * self . insdev . Np ) [EOL] [EOL] def spectralwidth_total ( self , n = [number] , theta = [number] ) : [EOL] ebeam = self . spectralwidth_ebeam ( n ) [EOL] undulator = self . spectralwidth_undulator ( n , theta ) [EOL] return ( ebeam ** [number] + undulator ** [number] ) ** [number] [EOL] [EOL] def difflimited_spot ( self , n = [number] ) : [EOL] [docstring] [EOL] L = self . insdev . L [EOL] return ( [number] / ( [number] * pi ) ) * ( self . lamda_n ( n = n , theta = [number] ) * L ) ** [number] [EOL] [EOL] def difflimited_div ( self , n = [number] ) : [EOL] [docstring] [EOL] L = self . insdev . L [EOL] return ( self . lamda_n ( n = n , theta = [number] ) / L ) ** [number] [EOL] [EOL] def source_spot ( self , plane , n = [number] , theta = [number] ) : [EOL] if plane == [string] : [EOL] beta = self . beam . betay [EOL] emit = self . beam . emity [EOL] elif plane == [string] : [EOL] beta = self . beam . betax [EOL] emit = self . beam . emitx [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] insdev = self . insdev [EOL] gamma = beamgamma ( self . beam . energy ) [EOL] osc_amplitude = insdev . period * insdev . Kmax / ( [number] * pi * gamma ) [EOL] spot_sqr = self . difflimited_spot ( n = n ) ** [number] [EOL] spot_sqr += sig ( emit , beta ) ** [number] [EOL] spot_sqr += osc_amplitude ** [number] [EOL] spot_sqr += ( [number] / [number] ) * sigp ( emit , beta ) ** [number] * insdev . L ** [number] [EOL] return spot_sqr ** [number] [EOL] [EOL] def source_div ( self , plane , n = [number] , theta = [number] ) : [EOL] if plane == [string] : [EOL] beta = self . beam . betay [EOL] emit = self . beam . emity [EOL] elif plane == [string] : [EOL] beta = self . beam . betax [EOL] emit = self . beam . emitx [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] spot_sqr = self . difflimited_div ( n = n ) ** [number] [EOL] spot_sqr += sigp ( emit , beta ) ** [number] [EOL] return spot_sqr ** [number] [EOL] [EOL] def brightness ( self , n = [number] , theta = [number] ) : [EOL] sigx = self . source_spot ( [string] , n , theta ) [EOL] sigxp = self . source_div ( [string] , n , theta ) [EOL] sigy = self . source_spot ( [string] , n , theta ) [EOL] sigyp = self . source_div ( [string] , n , theta ) [EOL] centre_freq = c / self . lamda_n ( n ) [EOL] high_freq = c / ( self . lamda_n ( n ) - self . spectralwidth_total ( n ) ) [EOL] delta_f = high_freq - centre_freq [EOL] frac_freqdiff = delta_f / centre_freq [EOL] return [number] / ( sigx * sigxp * sigy * sigyp * frac_freqdiff ) [EOL] [EOL] [EOL] class objectdict ( dict ) : [EOL] def __getattr__ ( self , name ) : [EOL] if name in self : [EOL] return self [ name ] [EOL] else : [EOL] raise AttributeError ( [string] + name ) [EOL] [EOL] def __setattr__ ( self , name , value ) : [EOL] self [ name ] = value [EOL] [EOL] def __delattr__ ( self , name ) : [EOL] if name in self : [EOL] del self [ name ] [EOL] else : [EOL] raise AttributeError ( [string] + name ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $undulator.undulator.objectdict$ 0 $undulator.undulator.objectdict$ 0 0 0 0 0 0 0 $undulator.undulator.objectdict$ 0 0 0 $undulator.undulator.objectdict$ 0 0 0 0 $undulator.undulator.objectdict$ 0 0 0 $undulator.undulator.objectdict$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 $undulator.undulator.objectdict$ 0 0 0 $undulator.undulator.objectdict$ 0 $builtins.float$ 0 0 0 $undulator.undulator.objectdict$ 0 0 0 0 $builtins.float$ 0 0 0 $undulator.undulator.objectdict$ 0 0 0 $undulator.undulator.objectdict$ 0 0 0 0 0 0 $typing.Any$ 0 $undulator.undulator.objectdict$ 0 0 0 $undulator.undulator.objectdict$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.float$ 0 $typing.Any$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $undulator.undulator.objectdict$ 0 0 0 $undulator.undulator.objectdict$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $undulator.undulator.objectdict$ 0 0 0 $undulator.undulator.objectdict$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $undulator.undulator.objectdict$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] m = [number] [EOL] [EOL] def sig ( emit , beta ) : [EOL] [docstring] [EOL] if emit < [number] or beta < [number] : [EOL] raise ValueError ( [string] ) [EOL] return ( emit * beta ) ** [number] [EOL] [EOL] def sigp ( emit , beta ) : [EOL] [docstring] [EOL] if emit < [number] or beta < [number] : [EOL] raise ValueError ( [string] ) [EOL] return ( emit / beta ) ** [number] [EOL] [EOL] def beamgamma ( energy ) : [EOL] [docstring] [EOL] if energy < m : [EOL] raise ValueError ( [string] ) [EOL] return energy / m [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( ) [EOL]	0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] hc = [number] [EOL] [EOL] def wavelength2energy ( wavelength ) : [EOL] [docstring] [EOL] if wavelength < [number] : [EOL] raise ValueError ( [string] ) [EOL] if wavelength < [number] : [EOL] raise ValueError ( [string] + [string] ) [EOL] if wavelength == float ( [string] ) : [EOL] raise ValueError ( [string] ) [EOL] return hc / wavelength [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( ) [EOL]	0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0