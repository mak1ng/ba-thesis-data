from setuptools import find_packages , setup [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , author = [string] , author_email = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , keywords = [string] . join ( sorted ( { [string] , [string] , [string] [string] , [string] } ) ) , packages = find_packages ( exclude = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) ) , install_requires = ( [string] , [string] , [string] , [string] , ) , python_requires = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , Type [EOL] import typing [EOL] import tests [EOL] import unittest [EOL] from contextlib import closing [EOL] [EOL] import sqlalchemy as sa [EOL] from dynaconf import settings [EOL] from sqlalchemy import create_engine [EOL] from sqlalchemy . dialects . postgresql import ARRAY [EOL] from sqlalchemy . ext . declarative import declarative_base [EOL] from sqlalchemy . orm import Session [EOL] [EOL] try : [EOL] DATABASE_URL = settings . DATABASE_URL [EOL] assert DATABASE_URL , [string] [EOL] except AttributeError as err : [EOL] raise AssertionError ( [string] ) [EOL] [EOL] Base = declarative_base ( ) [EOL] [EOL] [EOL] class Model ( Base ) : [comment] [EOL] __tablename__ = [string] [EOL] [EOL] id = sa . Column ( sa . Integer , primary_key = True , autoincrement = True ) [EOL] [EOL] v_default = sa . Column ( sa . Integer , default = [string] ) [EOL] [EOL] v_array = sa . Column ( ARRAY ( sa . Text ) ) [EOL] v_bool = sa . Column ( sa . Boolean ) [EOL] v_date = sa . Column ( sa . Date ) [EOL] v_datetime = sa . Column ( sa . DateTime ) [EOL] v_float = sa . Column ( sa . Float ) [EOL] v_int = sa . Column ( sa . Integer ) [EOL] v_numeric = sa . Column ( sa . Numeric ) [EOL] v_text = sa . Column ( sa . Text ) [EOL] [EOL] [EOL] def get_engine ( ) : [EOL] engine = create_engine ( DATABASE_URL ) [EOL] return engine [EOL] [EOL] [EOL] def create_tables ( engine ) : [EOL] Model . metadata . create_all ( engine ) [EOL] [EOL] [EOL] def drop_tables ( engine ) : [EOL] with closing ( engine . connect ( ) ) as conn : [EOL] conn = conn . execution_options ( autocommit = True ) [EOL] [EOL] conn . execute ( sa . text ( [string] . format ( Model . __tablename__ ) ) ) [EOL] [EOL] [EOL] def db_setup ( ) : [EOL] engine = get_engine ( ) [EOL] drop_tables ( engine ) [EOL] create_tables ( engine ) [EOL] [EOL] [EOL] def db_teardown ( ) : [EOL] engine = get_engine ( ) [EOL] drop_tables ( engine ) [EOL] [EOL] [EOL] class BulkyTest ( unittest . TestCase ) : [EOL] longMessage = True [EOL] [EOL] @ classmethod def setUpClass ( cls ) : [EOL] super ( ) . setUpClass ( ) [EOL] db_setup ( ) [EOL] [EOL] @ classmethod def tearDownClass ( cls ) : [EOL] db_teardown ( ) [EOL] super ( ) . tearDownClass ( ) [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] [EOL] self . _engine = get_engine ( ) [EOL] self . _connection = self . _engine . connect ( ) [EOL] [EOL] try : [EOL] self . _transaction = self . _connection . begin ( ) [EOL] except : [EOL] self . _connection . close ( ) [EOL] [EOL] try : [EOL] self . session = Session ( bind = self . _connection ) [EOL] except : [EOL] try : [EOL] self . _transaction . rollback ( ) [EOL] finally : [EOL] self . _connection . close ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] try : [EOL] self . _transaction . rollback ( ) [EOL] finally : [EOL] self . _connection . close ( ) [EOL] [EOL] self . _engine = self . _connection = self . _transaction = None [EOL] [EOL] super ( ) . tearDown ( ) [EOL] [EOL] [EOL] __all__ = ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Type[tests.db.Model]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.db.Model]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.db.Model]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.db.Model]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.db.Model]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.db.Model]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.db.Model]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.db.Model]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.db.Model]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.db.Model]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0
from typing import Set , Dict , List , Tuple , Any [EOL] import typing [EOL] import sqlalchemy as sa [EOL] [EOL] from bulky import consts , errors , insert [EOL] from tests . db import * [EOL] [EOL] [EOL] class InsertTest ( BulkyTest ) : [EOL] def test_single ( self ) : [EOL] dataset = [ { Model . v_text : [number] , Model . v_int : [number] } ] [EOL] returning = ( Model . id , Model . v_text , Model . v_int ) [EOL] [EOL] rows = insert ( self . session , Model , dataset , returning ) [EOL] self . assertEqual ( [number] , len ( rows ) , [string] ) [EOL] [EOL] row = rows [ [number] ] [EOL] self . assertTrue ( row , [string] ) [EOL] self . assertEqual ( [number] , len ( row ) , [string] ) [EOL] self . assertTrue ( hasattr ( row , Model . id . key ) , f" [string] { Model . id . key } [string] " ) [EOL] self . assertTrue ( hasattr ( row , Model . v_text . key ) , f" [string] { Model . v_text . key } [string] " ) [EOL] self . assertTrue ( hasattr ( row , Model . v_int . key ) , f" [string] { Model . v_int . key } [string] " ) [EOL] self . assertTrue ( row . id , f" [string] { Model . id . key } [string] " ) [EOL] self . assertEqual ( row . v_text , [string] , f" [string] { Model . v_text . key } [string] " ) [EOL] self . assertEqual ( row . v_int , [number] , f" [string] { Model . v_int . key } [string] " ) [EOL] [EOL] def test_empty_dataset ( self ) : [EOL] rows = insert ( self . session , Model , [ ] ) [EOL] self . assertFalse ( rows , [string] ) [EOL] [EOL] def test_no_returning ( self ) : [EOL] dataset = [ { Model . v_int : [number] } ] [EOL] [EOL] rows = insert ( self . session , Model , dataset ) [EOL] self . assertFalse ( rows , [string] ) [EOL] [EOL] query = sa . select ( [ Model . id , Model . v_int ] ) [EOL] [EOL] rows = self . session . execute ( query ) . fetchall ( ) [EOL] self . assertTrue ( rows , [string] ) [EOL] self . assertEqual ( [number] , len ( rows ) , [string] ) [EOL] [EOL] row = rows [ [number] ] [EOL] self . assertTrue ( row . id , f" [string] { Model . id . key } [string] " ) [EOL] self . assertEqual ( row . v_int , [number] , f" [string] { Model . v_int . key } [string] " ) [EOL] [EOL] def test_bulk ( self ) : [EOL] values_expected = { ( i , str ( i ) ) for i in range ( consts . BULK_CHUNK_SIZE + [number] ) } [EOL] [EOL] rows = insert ( self . session , Model , [ { Model . v_int : i , Model . v_text : j } for i , j in values_expected ] , [ Model . v_int , Model . v_text ] , ) [EOL] self . assertTrue ( rows , [string] ) [EOL] self . assertEqual ( len ( values_expected ) , len ( rows ) , [string] , ) [EOL] [EOL] values_returned = { ( row . v_int , row . v_text ) for row in rows } [EOL] self . assertSetEqual ( values_expected , values_returned , [string] ) [EOL] [EOL] def test_errors_wrong_data_column ( self ) : [EOL] dataset = [ { Model . v_int : [number] , [string] : [number] } ] [EOL] [EOL] with self . assertRaises ( errors . InvalidColumnError ) as arc : [EOL] insert ( self . session , Model , dataset ) [EOL] self . assertEqual ( [string] , str ( arc . exception ) , ) [EOL] [EOL] def test_errors_wrong_returning_column ( self ) : [EOL] dataset = [ { Model . v_int : [number] } ] [EOL] [EOL] with self . assertRaises ( errors . InvalidColumnError ) as arc : [EOL] insert ( self . session , Model , dataset , [ [string] ] ) [EOL] self . assertEqual ( [string] , str ( arc . exception ) , ) [EOL] [EOL] def test_sqlalchemy_default_value ( self ) : [EOL] dataset = [ { Model . v_int : [number] } ] [EOL] returning = ( Model . id , Model . v_int , Model . v_default ) [EOL] [EOL] rows = insert ( self . session , Model , dataset , returning ) [EOL] self . assertEqual ( [number] , len ( rows ) , [string] ) [EOL] [EOL] row = rows [ [number] ] [EOL] self . assertTrue ( row , [string] ) [EOL] self . assertEqual ( [number] , len ( row ) , [string] ) [EOL] self . assertTrue ( hasattr ( row , Model . id . key ) , f" [string] { Model . id . key } [string] " ) [EOL] self . assertTrue ( hasattr ( row , Model . v_int . key ) , f" [string] { Model . v_int . key } [string] " ) [EOL] self . assertTrue ( hasattr ( row , Model . v_default . key ) , f" [string] { Model . v_default . key } [string] " , ) [EOL] self . assertTrue ( row . id , f" [string] { Model . id . key } [string] " ) [EOL] self . assertEqual ( row . v_int , [number] , f" [string] { Model . v_int . key } [string] " ) [EOL] self . assertEqual ( row . v_default , [number] , f" [string] { Model . v_default . key } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,builtins.int]]$ 0 $typing.Tuple[unknown,unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,builtins.int]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[unknown,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.str]]$ 0 $typing.Set[typing.Tuple[unknown,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,builtins.int]]$ 0 $typing.Tuple[unknown,unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import jinja2 [EOL] import typing [EOL] import bulky [EOL] from datetime import datetime [EOL] from decimal import Decimal [EOL] [EOL] from jinja2 import Template [EOL] [EOL] from bulky import update [EOL] from bulky . types import ReferenceType [EOL] from . db import * [EOL] [EOL] [EOL] class UpdateTest ( BulkyTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] [EOL] obj = Model ( ) [EOL] self . session . add ( obj ) [EOL] self . session . flush ( ) [EOL] [EOL] self . obj = obj [EOL] [EOL] def test_scalar_fields ( self ) : [EOL] dataset = { Model . id : self . obj . id , Model . v_array : None , Model . v_bool : None , Model . v_date : None , Model . v_datetime : None , Model . v_float : None , Model . v_int : None , Model . v_numeric : None , Model . v_text : None , } [EOL] [EOL] self . update_and_validate ( dataset ) [EOL] [EOL] dataset = { Model . id : self . obj . id , Model . v_array : [ [string] , [string] , [string] , [string] , [string] , [string] ] , Model . v_bool : True , Model . v_date : datetime . now ( ) . date ( ) , Model . v_datetime : datetime . now ( ) , Model . v_float : [number] , Model . v_int : [number] , Model . v_numeric : Decimal ( [number] ) , Model . v_text : [string] , } [EOL] [EOL] self . update_and_validate ( dataset ) [EOL] [EOL] def test_multiple_references ( self ) : [EOL] dataset = { Model . id : self . obj . id , Model . v_int : [number] , Model . v_text : [string] } [EOL] self . update_and_validate ( dataset ) [EOL] [EOL] dataset = { Model . id : self . obj . id , Model . v_int : [number] , Model . v_text : [string] } [EOL] self . update_and_validate ( dataset , references = [ Model . id , Model . v_int ] ) [EOL] [EOL] def test_returning ( self ) : [EOL] dataset = { Model . id : self . obj . id , Model . v_text : [string] } [EOL] [EOL] r = self . update_and_validate ( dataset , returning = [ Model . v_date , Model . v_text ] ) [EOL] [EOL] self . assertTrue ( r , [string] ) [EOL] self . assertEqual ( [number] , len ( r ) , [string] ) [EOL] self . assertEqual ( [number] , len ( r [ [number] ] ) , [string] ) [EOL] [EOL] r = r [ [number] ] [EOL] [EOL] self . assertEqual ( [string] , r . v_text , [string] ) [EOL] self . assertEqual ( None , r . v_date , [string] ) [EOL] [EOL] def test_diff_update ( self ) : [EOL] dataset = { Model . id : self . obj . id , Model . v_int : [number] } [EOL] [EOL] r = update ( self . session , Model , [ dataset ] , returning = [ Model . id ] ) [EOL] self . assertEqual ( len ( r ) , [number] ) [EOL] [EOL] r = update ( self . session , Model , [ dataset ] , returning = [ Model . id ] ) [EOL] self . assertEqual ( len ( r ) , [number] , [string] ) [EOL] [EOL] def update_and_validate ( self , dataset , returning = None , references = ( [string] , ) ) : [EOL] [docstring] [EOL] [EOL] r = update ( self . session , Model , [ dataset , dataset ] , returning = returning , reference = references , ) [EOL] [EOL] self . session . refresh ( self . obj ) [EOL] [EOL] mismatches = [ ] [EOL] [EOL] for attr , expected_value in dataset . items ( ) : [EOL] key = attr . key [EOL] got_value = getattr ( self . obj , key ) [EOL] [EOL] if isinstance ( got_value , list ) : [EOL] got_value = [ ( str ( elm ) if isinstance ( elm , str ) else elm ) for elm in got_value ] [EOL] [EOL] if str ( expected_value ) != str ( got_value ) : [EOL] mismatches . append ( ( key , expected_value , got_value ) ) [EOL] [EOL] tmpl = Template ( [string] [string] [string] [string] ) [EOL] [EOL] self . assertFalse ( mismatches , tmpl . render ( mismatches = mismatches , type = type ) ) [EOL] [EOL] return r [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bulky.types.ReferenceType$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bulky.types.ReferenceType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $jinja2.environment.Template$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $jinja2.environment.Template$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import Literal , Set , Dict , Union , List , Optional , Tuple , Any [EOL] import decimal [EOL] import typing_extensions [EOL] import typing [EOL] from decimal import Decimal [EOL] [EOL] from sqlalchemy import Table [EOL] [EOL] from bulky import errors [EOL] from bulky . internals import utils as u [EOL] from tests . db import * [EOL] [EOL] [EOL] class UtilsTest ( BulkyTest ) : [EOL] def test_get_table ( self ) : [EOL] tbl = u . get_table ( Model ) [EOL] self . assertIsInstance ( tbl , Table , f" [string] { Table } [string] { type ( tbl ) }" ) [EOL] self . assertEqual ( [string] , tbl . name , f" [string] { tbl . name } [string] " ) [EOL] [EOL] tbl = u . get_table ( tbl ) [EOL] self . assertIsInstance ( tbl , Table , f" [string] { Table } [string] { type ( tbl ) }" ) [EOL] self . assertEqual ( [string] , tbl . name , f" [string] { tbl . name } [string] " ) [EOL] [EOL] def test_get_table_name ( self ) : [EOL] name = u . get_table_name ( Model ) [EOL] self . assertEqual ( [string] , name , f" [string] { name } [string] " ) [EOL] [EOL] def test_is_db_type_comparable ( self ) : [EOL] db_types = { [string] : True , [string] : True , [string] : False , [string] : False } [EOL] [EOL] for db_type , expected in db_types . items ( ) : [EOL] got = u . is_db_type_comparable ( db_type ) [EOL] self . assertEqual ( expected , got , f" [string] { db_type } [string] { expected } [string] { got }" , ) [EOL] [EOL] def test_clean_returning ( self ) : [EOL] self . assertEqual ( [ ] , u . clean_returning ( Model , [ ] ) ) [EOL] [EOL] r_attrs = [ Model . id , Model . v_default , Model . v_int ] [EOL] r_keys = [ _a . key for _a in r_attrs ] [EOL] [EOL] self . assertSequenceEqual ( r_keys , [ _c . text for _c in u . clean_returning ( Model , r_attrs ) ] ) [EOL] self . assertSequenceEqual ( r_keys , [ _c . text for _c in u . clean_returning ( Model , r_keys ) ] ) [EOL] [EOL] with self . assertRaises ( errors . InvalidColumnError ) as arc : [EOL] u . clean_returning ( Model , [ [string] ] ) [EOL] self . assertEqual ( str ( arc . exception ) , [string] , ) [EOL] [EOL] def test_validate_values ( self ) : [EOL] with self . assertRaises ( errors . InvalidValueError ) as arc : [EOL] u . validate_values ( { } , [number] ) [EOL] self . assertEqual ( str ( arc . exception ) , [string] ) [EOL] [EOL] def test_clean_values ( self ) : [EOL] dataset_good = ( { Model . v_int : [number] , Model . v_text . key : [string] } , ) [EOL] cleaned_values = u . clean_values ( Model , dataset_good ) [EOL] self . assertSequenceEqual ( cleaned_values , [ { [string] : [number] , [string] : [string] } ] ) [EOL] [EOL] def test_clean_values_empty_dataset ( self ) : [EOL] dataset_empty = [ ] [EOL] cleaned_values = u . clean_values ( Model , dataset_empty ) [EOL] self . assertFalse ( cleaned_values ) [EOL] [EOL] def test_clean_values_fields_mismatch ( self ) : [EOL] dataset_fields_excess = [ { Model . v_int : [number] } , { Model . v_int : [number] , Model . v_text : [string] } , ] [EOL] with self . assertRaises ( errors . InvalidValueError ) as arc : [EOL] u . clean_values ( Model , dataset_fields_excess ) [EOL] self . assertEqual ( str ( arc . exception ) , [string] , ) [EOL] [EOL] dataset_fields_missing = [ { Model . v_int : [number] , Model . v_text : [string] } , { Model . v_int : [number] } , ] [EOL] with self . assertRaises ( errors . InvalidValueError ) as arc : [EOL] u . clean_values ( Model , dataset_fields_missing ) [EOL] self . assertEqual ( str ( arc . exception ) , [string] , ) [EOL] [EOL] dataset_both = [ { Model . v_int : [number] } , { Model . v_text : [string] } ] [EOL] with self . assertRaises ( errors . InvalidValueError ) as arc : [EOL] u . clean_values ( Model , dataset_both ) [EOL] self . assertEqual ( str ( arc . exception ) , [string] , ) [EOL] [EOL] def test_clean_values_type_cast ( self ) : [EOL] dataset = [ { Model . v_array . key : [ [string] , [string] , [string] ] , Model . v_bool . key : True , Model . v_default . key : None , Model . v_float . key : [number] , Model . v_int . key : [number] , Model . v_numeric . key : Decimal ( [string] ) , Model . v_text . key : [string] , } ] [EOL] [EOL] values_set_trusted = u . clean_values ( Model , dataset ) [EOL] self . assertEqual ( len ( values_set_trusted ) , [number] ) [EOL] values_trusted = values_set_trusted [ [number] ] [EOL] self . assertDictEqual ( values_trusted , { [string] : [ [string] , [string] , [string] ] , [string] : True , [string] : None , [string] : [number] , [string] : [number] , [string] : Decimal ( [string] ) , [string] : [string] , } , ) [EOL] [EOL] values_set_casted = u . clean_values ( Model , dataset , cast_db_types = True ) [EOL] self . assertEqual ( len ( values_set_casted ) , [number] ) [EOL] values_casted = values_set_casted [ [number] ] [EOL] [EOL] self . assertDictEqual ( values_casted , { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , } , ) [EOL] [EOL] def test_get_column_types ( self ) : [EOL] column_types = u . get_column_types ( self . session , Model ) [EOL] self . assertDictEqual ( column_types , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ) [EOL] [EOL] def test_to_db_literal ( self ) : [EOL] scalar_casts = ( ( None , [string] ) , ( [string] , [string] ) , ( True , [number] ) , ( False , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( Decimal ( [string] ) , [string] ) , ) [EOL] [EOL] for original , cast_expect in scalar_casts : [EOL] cast_got = u . to_db_literal ( original ) [EOL] self . assertEqual ( cast_expect , cast_got , f" [string] { original } [string] { cast_got } [string] { cast_expect }" , ) [EOL] [EOL] collection_casts = { [string] : ( ( [ [string] , [string] ] , repr ( [string] ) ) , ( [ [string] ] , repr ( [string] ) ) , ( [ [number] , [number] ] , repr ( [string] ) ) , ( [ [number] ] , repr ( [string] ) ) , ( [ ] , repr ( [string] ) ) , ( { [string] : [string] } , repr ( [string] ) ) , ( { [string] : [number] } , repr ( [string] ) ) , ( { [string] : [number] , [string] : [string] } , repr ( [string] ) ) , ( { [string] : [number] } , repr ( [string] ) ) , ( { [string] : False } , repr ( [string] ) ) , ( { [string] : None } , repr ( [string] ) ) , ( { [string] : True } , repr ( [string] ) ) , ( { } , repr ( [string] ) ) , ) , [string] : ( ( [ [string] , [string] ] , repr ( [string] ) ) , ( [ [string] ] , repr ( [string] ) ) , ( [ [number] , [number] ] , repr ( [string] ) ) , ( [ [number] ] , repr ( [string] ) ) , ( [ ] , repr ( [string] ) ) , ( { [string] : [string] } , repr ( [string] ) ) , ( { [string] : [number] } , repr ( [string] ) ) , ( { [string] : [number] , [string] : [string] } , repr ( [string] ) ) , ( { [string] : [number] } , repr ( [string] ) ) , ( { [string] : False } , repr ( [string] ) ) , ( { [string] : None } , repr ( [string] ) ) , ( { [string] : True } , repr ( [string] ) ) , ( { } , repr ( [string] ) ) , ) , [string] : ( ( { [string] : [string] } , repr ( [string] ) ) , ( { [string] : [number] } , repr ( [string] ) ) , ( { [string] : [number] , [string] : [string] } , repr ( [string] ) ) , ( { [string] : [number] } , repr ( [string] ) ) , ( { [string] : False } , repr ( [string] ) ) , ( { [string] : None } , repr ( [string] ) ) , ( { [string] : True } , repr ( [string] ) ) , ( { } , [string] ) , ) , None : ( ( [ [string] , [string] ] , [string] ) , ( [ [string] ] , [string] ) , ( [ [number] , [number] ] , [string] ) , ( [ [number] ] , [string] ) , ( [ ] , [string] ) , ) , } [EOL] [EOL] for cast_to , args in collection_casts . items ( ) : [EOL] for original , cast_expect in args : [EOL] cast_got = u . to_db_literal ( original , cast_to = cast_to ) [EOL] self . assertEqual ( cast_expect , cast_got , f" [string] { original !r} [string] { cast_to !r} [string] { cast_got !r} [string] { cast_expect !r}" , ) [EOL] [EOL] def test_get_table_columns ( self ) : [EOL] expected = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] got = u . get_table_columns ( Model ) [EOL] self . assertSetEqual ( expected , got ) [EOL] [EOL] def test_get_column_key ( self ) : [EOL] columns = u . get_table_columns ( Model ) [EOL] [EOL] with self . assertRaises ( errors . InvalidColumnError ) as arc : [EOL] u . get_column_key ( Model , [string] , None , None ) [EOL] self . assertEqual ( str ( arc . exception ) , [string] ) [EOL] [EOL] with self . assertRaises ( errors . InvalidColumnError ) as arc : [EOL] u . get_column_key ( Model , [string] , [number] , None ) [EOL] self . assertEqual ( str ( arc . exception ) , [string] ) [EOL] [EOL] with self . assertRaises ( errors . InvalidColumnError ) as arc : [EOL] u . get_column_key ( Model , [string] , None , frozenset ( { [string] , [string] } ) ) [EOL] self . assertEqual ( str ( arc . exception ) , [string] ) [EOL] [EOL] key = u . get_column_key ( Model , Model . id ) [EOL] self . assertEqual ( key , [string] ) [EOL] [EOL] key = u . get_column_key ( Model , [string] ) [EOL] self . assertEqual ( key , [string] ) [EOL] [EOL] key = u . get_column_key ( Model , Model . id , columns = columns ) [EOL] self . assertEqual ( key , [string] ) [EOL] [EOL] key = u . get_column_key ( Model , [string] , columns = columns ) [EOL] self . assertEqual ( key , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[unknown,builtins.int],typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[unknown,builtins.int],typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[unknown,builtins.int],typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[unknown,builtins.int],typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[unknown,builtins.int],typing.Dict[unknown,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[unknown,builtins.int],typing.Dict[unknown,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Union[None,typing.List[builtins.str],decimal.Decimal,builtins.float,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Union[None,typing.List[builtins.str],decimal.Decimal,builtins.float,builtins.str]]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Union[None,typing.List[builtins.str],decimal.Decimal,builtins.float,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[None,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal[True],typing_extensions.Literal],typing.Tuple[typing_extensions.Literal[False],typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[builtins.float,builtins.float],typing.Tuple[decimal.Decimal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[None,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal[True],typing_extensions.Literal],typing.Tuple[typing_extensions.Literal[False],typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[builtins.float,builtins.float],typing.Tuple[decimal.Decimal,typing_extensions.Literal]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Optional[builtins.str],typing.Union[typing.Tuple[typing.Tuple[typing.Dict[builtins.str,builtins.str],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.int],builtins.str],typing.Tuple[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.int],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.bool],builtins.str],typing.Tuple[typing.Dict[builtins.str,None],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.bool],builtins.str],typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.str]],typing.Tuple[typing.Tuple[typing.List[builtins.str],builtins.str],typing.Tuple[typing.List[builtins.str],builtins.str],typing.Tuple[typing.List[builtins.int],builtins.str],typing.Tuple[typing.List[builtins.int],builtins.str],typing.Tuple[typing.List[typing.Any],builtins.str]],typing.Tuple[typing.Tuple[typing.List[builtins.str],builtins.str],typing.Tuple[typing.List[builtins.str],builtins.str],typing.Tuple[typing.List[builtins.int],builtins.str],typing.Tuple[typing.List[builtins.int],builtins.str],typing.Tuple[typing.List[typing.Any],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.str],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.int],builtins.str],typing.Tuple[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.int],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.bool],builtins.str],typing.Tuple[typing.Dict[builtins.str,None],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.bool],builtins.str],typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Optional[builtins.str],typing.Union[typing.Tuple[typing.Tuple[typing.Dict[builtins.str,builtins.str],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.int],builtins.str],typing.Tuple[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.int],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.bool],builtins.str],typing.Tuple[typing.Dict[builtins.str,None],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.bool],builtins.str],typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.str]],typing.Tuple[typing.Tuple[typing.List[builtins.str],builtins.str],typing.Tuple[typing.List[builtins.str],builtins.str],typing.Tuple[typing.List[builtins.int],builtins.str],typing.Tuple[typing.List[builtins.int],builtins.str],typing.Tuple[typing.List[typing.Any],builtins.str]],typing.Tuple[typing.Tuple[typing.List[builtins.str],builtins.str],typing.Tuple[typing.List[builtins.str],builtins.str],typing.Tuple[typing.List[builtins.int],builtins.str],typing.Tuple[typing.List[builtins.int],builtins.str],typing.Tuple[typing.List[typing.Any],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.str],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.int],builtins.str],typing.Tuple[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.int],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.bool],builtins.str],typing.Tuple[typing.Dict[builtins.str,None],builtins.str],typing.Tuple[typing.Dict[builtins.str,builtins.bool],builtins.str],typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
import unittest [EOL] [EOL] from bulky import errors [EOL] [EOL] [EOL] class ErrorsTest ( unittest . TestCase ) : [EOL] longMessage = True [EOL] [EOL] def test_error_messages_rendering ( self ) : [EOL] self . assertEqual ( str ( errors . BulkOperationError ( [string] ) ) , [string] , f" [string] { errors . BulkOperationError }" , ) [EOL] [EOL] self . assertEqual ( str ( errors . InvalidColumnError ( [string] ) ) , [string] , f" [string] { errors . InvalidColumnError }" , ) [EOL] [EOL] self . assertEqual ( str ( errors . InvalidColumnError ( [string] , [string] ) ) , [string] , f" [string] { errors . InvalidColumnError }" , ) [EOL] [EOL] self . assertEqual ( str ( errors . InvalidColumnError ( [string] , [string] , [number] ) ) , [string] , f" [string] { errors . InvalidColumnError }" , ) [EOL] [EOL] self . assertEqual ( str ( errors . InvalidColumnError ( [string] , index = [number] ) ) , [string] , f" [string] { errors . InvalidColumnError }" , ) [EOL] [EOL] self . assertEqual ( str ( errors . InvalidValueError ( [number] ) ) , [string] , f" [string] { errors . InvalidValueError }" , ) [EOL] [EOL] self . assertEqual ( str ( errors . InvalidValueError ( [number] , [string] ) ) , [string] , f" [string] { errors . InvalidValueError }" , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple [EOL] import typing [EOL] from bulky . functions . insert import insert [EOL] from bulky . functions . update import update [EOL] [EOL] __all__ = ( [string] , [string] ) [EOL] name = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
BULK_CHUNK_SIZE = [number] [EOL] [EOL] NON_COMPARABLE_DB_TYPES = frozenset ( ( [string] , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence , Dict , List , Type , Any [EOL] import typing [EOL] from typing import Any , Dict , FrozenSet , Iterable , List , Sequence , Text , Union [EOL] [EOL] from sqlalchemy import Column , Table , text [EOL] from sqlalchemy . ext . declarative import DeclarativeMeta [EOL] from sqlalchemy . orm import Mapper , Session , ColumnProperty [EOL] from sqlalchemy . orm . attributes import InstrumentedAttribute [EOL] [EOL] TableType = Union [ Table , Mapper , DeclarativeMeta ] [EOL] TableColumnsSetType = FrozenSet [ Text ] [EOL] ColumnType = Union [ Text , InstrumentedAttribute , Column ] [EOL] ColumnPropertyType = ColumnProperty [EOL] ColumnTypesMapType = Dict [ Text , Text ] [EOL] SessionType = Session [EOL] [EOL] ValuesType = Dict [ ColumnType , Any ] [EOL] ValuesSeriesType = Sequence [ ValuesType ] [EOL] CleanedValuesType = Dict [ Text , Any ] [EOL] CleanedValuesSeriesType = Sequence [ CleanedValuesType ] [EOL] [EOL] ReturningType = Sequence [ ColumnType ] [EOL] CleanReturningType = Sequence [ text ] [EOL] [EOL] ReferenceType = Iterable [ ColumnType ] [EOL] [EOL] RowType = Any [comment] [EOL] RowsType = List [ RowType ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class BulkOperationError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidColumnError ( BulkOperationError ) : [EOL] def __init__ ( self , key , message = [string] , index = None ) : [EOL] e = f" [string] { key } [string] " [EOL] if index is not None : [EOL] e += f" [string] { index } [string] " [EOL] if message : [EOL] e += f" [string] { message }" [EOL] [EOL] super ( ) . __init__ ( e ) [EOL] [EOL] [EOL] class InvalidValueError ( BulkOperationError ) : [EOL] def __init__ ( self , index , message = [string] ) : [EOL] e = f" [string] { index } [string] " [EOL] if message : [EOL] e += f" [string] { message }" [EOL] [EOL] super ( ) . __init__ ( e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Set , Dict , List , Optional , Any [EOL] import sqlalchemy [EOL] import builtins [EOL] import typing [EOL] import bulky [EOL] import json [EOL] from decimal import Decimal [EOL] from typing import Dict , List , Optional , Text [EOL] [EOL] import sqlalchemy as sa [EOL] from jinja2 import Template [EOL] from psycopg2 . extensions import QuotedString , adapt [EOL] from sqlalchemy import Table [EOL] from sqlalchemy . ext . declarative import DeclarativeMeta [EOL] from sqlalchemy . orm import Mapper , Session [EOL] from sqlalchemy . orm . attributes import InstrumentedAttribute [EOL] from typeguard import check_type , typechecked [EOL] [EOL] from bulky import consts [EOL] from bulky import errors [EOL] from bulky . internals import sql [EOL] from bulky . types import ( CleanReturningType , CleanedValuesSeriesType , ColumnPropertyType , ColumnType , ColumnTypesMapType , ReturningType , TableColumnsSetType , TableType , ValuesSeriesType , ValuesType , ) [EOL] [EOL] _column_type_cache = { } [EOL] [EOL] [EOL] @ typechecked ( always = True ) def get_table ( table_or_model ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( table_or_model , Table ) : [EOL] table = table_or_model [EOL] else : [EOL] table = table_or_model . __table__ [comment] [EOL] [EOL] return table [EOL] [EOL] [EOL] @ typechecked ( always = True ) def get_table_name ( table_or_model ) : [EOL] [docstring] [EOL] [EOL] inspected = sa . inspect ( table_or_model ) [EOL] [EOL] if isinstance ( inspected , Table ) : [EOL] table_name = inspected . name [EOL] elif isinstance ( inspected , Mapper ) : [EOL] table_name = inspected . tables [ [number] ] . name [EOL] else : [comment] [EOL] raise ValueError ( f" [string] { table_or_model }" ) [EOL] [EOL] return table_name [EOL] [EOL] [EOL] @ typechecked ( always = True ) def is_db_type_comparable ( db_type ) : [EOL] [docstring] [EOL] [EOL] if db_type . endswith ( [string] ) : [EOL] return False [EOL] [EOL] if db_type in consts . NON_COMPARABLE_DB_TYPES : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def clean_returning ( table_or_model , returning ) : [EOL] if not returning : [EOL] return [ ] [EOL] [EOL] columns = get_table_columns ( table_or_model ) [EOL] cleaned = [ sa . text ( k ) for k in sorted ( { get_column_key ( table_or_model , key , None , columns ) for key_index , key in enumerate ( returning ) } ) ] [EOL] return cleaned [EOL] [EOL] [EOL] def validate_values ( values , values_index ) : [EOL] try : [EOL] check_type ( [string] , values , ValuesType ) [EOL] except TypeError : [comment] [EOL] raise errors . InvalidValueError ( values_index , f" [string] { ValuesType }" ) [EOL] [EOL] if not values . keys ( ) : [EOL] raise errors . InvalidValueError ( values_index , [string] ) [EOL] [EOL] [EOL] @ typechecked ( always = True ) def clean_values ( table_or_model , values_series , cast_db_types = False , column_types = None , ) : [EOL] [docstring] [EOL] [EOL] result = [ ] [EOL] [EOL] if not values_series : [EOL] return result [EOL] [EOL] [comment] [EOL] [comment] [EOL] columns_common = None [EOL] [EOL] columns_table = get_table_columns ( table_or_model ) [EOL] [EOL] [comment] [EOL] columns_cleaned = { column : column for column in columns_table } [EOL] [EOL] column_types = column_types or { } [EOL] [EOL] [comment] [EOL] [EOL] for values_index , values in enumerate ( values_series ) : [EOL] validate_values ( values , values_index ) [EOL] [EOL] columns_current = set ( ) [EOL] [EOL] values_cleaned = { } [EOL] [EOL] [comment] [EOL] [EOL] for column_dirty , value in values . items ( ) : [EOL] column_cleaned = columns_cleaned . get ( column_dirty ) [EOL] [EOL] if not column_cleaned : [EOL] column_cleaned = get_column_key ( table_or_model , column_dirty , values_index , columns_table ) [EOL] columns_cleaned [ column_cleaned ] = column_cleaned [EOL] [EOL] if not cast_db_types : [EOL] value_cleaned = value [EOL] else : [EOL] value_cleaned = to_db_literal ( value , cast_to = column_types . get ( column_cleaned ) ) [EOL] [EOL] values_cleaned [ column_cleaned ] = value_cleaned [EOL] [EOL] columns_current . add ( column_cleaned ) [EOL] [EOL] [comment] [EOL] [EOL] columns_common = columns_common or frozenset ( columns_current ) [EOL] [EOL] columns_excess = columns_current - columns_common [EOL] columns_missing = columns_common - columns_current [EOL] [EOL] if any ( ( columns_excess , columns_missing ) ) : [EOL] raise errors . InvalidValueError ( values_index , f" [string] { sorted ( columns_excess ) } [string] { sorted ( columns_missing ) }" , ) [EOL] [EOL] [comment] [EOL] [EOL] result . append ( values_cleaned ) [EOL] [EOL] return result [EOL] [EOL] [EOL] @ typechecked ( always = True ) def get_column_types ( session , table_or_model ) : [EOL] [docstring] [EOL] [EOL] table_name = get_table_name ( table_or_model ) [EOL] [EOL] if table_name in _column_type_cache : [EOL] return _column_type_cache [ table_name ] [EOL] [EOL] stmt = Template ( sql . STMT_GET_COLUMN_TYPES ) . render ( table_name = table_name ) [EOL] [EOL] response = session . execute ( sa . text ( stmt ) ) . fetchall ( ) [EOL] [EOL] result = { row . column_name : row . column_type for row in response } [EOL] _column_type_cache [ table_name ] = result [EOL] [EOL] return result [EOL] [EOL] [EOL] def to_db_literal ( value , cast_to = None ) : [EOL] if value is None : [EOL] return [string] [EOL] elif isinstance ( value , str ) : [EOL] value = QuotedString ( value . encode ( [string] ) ) . getquoted ( ) . decode ( [string] ) [EOL] return value [EOL] elif isinstance ( value , bool ) : [EOL] value = int ( value ) [EOL] return value [EOL] elif isinstance ( value , ( int , float ) ) : [EOL] return value [EOL] elif isinstance ( value , ( dict , list ) ) : [EOL] if cast_to == [string] or cast_to == [string] : [EOL] value = json . dumps ( value ) [EOL] return QuotedString ( value ) . getquoted ( ) . decode ( [string] ) [EOL] elif cast_to == [string] : [EOL] assert isinstance ( value , dict ) [comment] [EOL] s = [string] . join ( [string] . format ( k , [string] if v is None else [string] . format ( v ) ) for k , v in value . items ( ) ) [EOL] return QuotedString ( s ) . getquoted ( ) . decode ( [string] ) [EOL] else : [EOL] return adapt ( value ) . getquoted ( ) . decode ( [string] ) [EOL] elif isinstance ( value , Decimal ) : [EOL] return str ( value ) [EOL] else : [EOL] return QuotedString ( str ( value ) ) . getquoted ( ) . decode ( [string] ) [EOL] [EOL] [EOL] @ typechecked ( always = True ) def get_table_columns ( table_or_model ) : [EOL] [docstring] [EOL] [EOL] inspected = sa . inspect ( table_or_model ) [EOL] columns = frozenset ( inspected . columns . keys ( ) ) [EOL] [EOL] return columns [EOL] [EOL] [EOL] @ typechecked ( always = True ) def get_column_key ( table_or_model , column , value_index = None , columns = None , ) : [EOL] [docstring] [EOL] [EOL] columns = columns or get_table_columns ( table_or_model ) [EOL] [EOL] if isinstance ( column , Text ) : [EOL] if column not in columns : [EOL] raise errors . InvalidColumnError ( column , [string] , value_index ) [EOL] [EOL] [comment] [EOL] [EOL] if isinstance ( table_or_model , DeclarativeMeta ) : [EOL] column = getattr ( table_or_model , column ) [EOL] else : [EOL] column = table_or_model . columns [ column ] [EOL] [EOL] if isinstance ( column , InstrumentedAttribute ) : [EOL] check_type ( [string] , column . property , ColumnPropertyType ) [EOL] [EOL] return str ( column . key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
STMT_UPDATE = [string] [EOL] [EOL] STMT_GET_COLUMN_TYPES = [string] [EOL]	$builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0
import builtins [EOL] from typing import Generator , Any , List , Optional [EOL] import jinja2 [EOL] import typing [EOL] import bulky [EOL] from typing import List , Optional [EOL] [EOL] from jinja2 import Template [EOL] [EOL] from bulky import consts [EOL] from bulky . internals import sql [EOL] from bulky . internals import utils [EOL] from bulky . types import ( ReferenceType , ReturningType , RowsType , SessionType , TableType , ValuesSeriesType , ) [EOL] [EOL] _template = Template ( sql . STMT_UPDATE ) [EOL] [EOL] [EOL] def update ( session , table_or_model , values_series , returning = None , reference = ( [string] , ) , ) : [EOL] [docstring] [EOL] [EOL] if not values_series : [EOL] return [ ] [EOL] [EOL] table = utils . get_table ( table_or_model ) [EOL] [EOL] column_types = utils . get_column_types ( session , table ) [EOL] values_series = utils . clean_values ( table , values_series , cast_db_types = True , column_types = column_types ) [EOL] [EOL] columns = frozenset ( values_series [ [number] ] . keys ( ) ) [EOL] [EOL] reference_fields = frozenset ( utils . get_column_key ( table , f ) for f in reference ) [EOL] [EOL] if reference_fields - columns : [EOL] raise ValueError ( [string] . format ( rf = sorted ( reference_fields ) , tbl = table . name ) ) [EOL] [EOL] columns_to_update = sorted ( columns - reference_fields ) [EOL] columns_sorted = sorted ( columns ) [EOL] reference_fields_sorted = sorted ( reference_fields ) [EOL] [EOL] update_changed = all ( utils . is_db_type_comparable ( column_types [ column ] ) for column in columns_to_update ) [EOL] [EOL] returning = list ( utils . get_column_key ( table , column ) for column in ( returning or [ ] ) ) [EOL] [EOL] chunked_values = ( values_series [ i : i + consts . BULK_CHUNK_SIZE ] for i in range ( [number] , len ( values_series ) , consts . BULK_CHUNK_SIZE ) ) [EOL] [EOL] conn = session . connection ( ) . execution_options ( no_parameters = True ) [EOL] [EOL] result = [ ] [EOL] [EOL] for chunk in chunked_values : [EOL] stmt = _template . render ( src = [string] , dst = table . name , columns = columns_sorted , values_list = chunk , column_types = column_types , columns_to_update = columns_to_update , update_changed = update_changed , reference_fields = reference_fields_sorted , returning = returning , ) [EOL] [EOL] response = conn . execute ( stmt ) [EOL] [EOL] if returning : [EOL] result . extend ( response . fetchall ( ) ) [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bulky.types.RowsType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Generator [EOL] import typing [EOL] import bulky [EOL] from typing import Optional [EOL] [EOL] import sqlalchemy as sa [EOL] from typeguard import typechecked [EOL] [EOL] from bulky import consts [EOL] from bulky . internals import utils [EOL] from bulky . types import ( ReturningType , RowsType , SessionType , TableType , ValuesSeriesType , ) [EOL] [EOL] [EOL] @ typechecked ( always = True ) def insert ( session , table_or_model , values_series , returning = None , ) : [EOL] [docstring] [EOL] [EOL] result = [ ] [EOL] [EOL] if not values_series : [EOL] return result [EOL] [EOL] table = utils . get_table ( table_or_model ) [EOL] [EOL] returning_cleaned = utils . clean_returning ( table , returning ) [EOL] values_series_cleaned = utils . clean_values ( table , values_series ) [EOL] [EOL] values_series_chunks = ( values_series_cleaned [ i : i + consts . BULK_CHUNK_SIZE ] for i in range ( [number] , len ( values_series_cleaned ) , consts . BULK_CHUNK_SIZE ) ) [EOL] [EOL] for n_chunk , chunk in enumerate ( values_series_chunks ) : [EOL] query = sa . insert ( table , values = chunk , returning = returning_cleaned , inline = True ) [EOL] query_result = session . execute ( query ) [EOL] [EOL] if returning : [EOL] data = query_result . fetchall ( ) [EOL] result . extend ( data ) [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0