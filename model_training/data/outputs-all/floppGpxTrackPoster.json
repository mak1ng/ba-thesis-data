[comment] [EOL] [EOL] from typing import Tuple , List [EOL] import typing [EOL] import os [EOL] [EOL] import setuptools [EOL] [EOL] [EOL] def _read_reqs ( relpath ) : [EOL] fullpath = os . path . join ( os . path . dirname ( __file__ ) , relpath ) [EOL] with open ( fullpath ) as f : [EOL] return [ s . strip ( ) for s in f . readlines ( ) if ( s . strip ( ) and not s . startswith ( [string] ) ) ] [EOL] [EOL] [EOL] setuptools . setup ( name = [string] , version = [string] , install_requires = _read_reqs ( [string] ) , tests_require = _read_reqs ( [string] ) , data_files = [ ( [string] , [ [string] , [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ] , packages = setuptools . find_packages ( ) , entry_points = { [string] : [ [string] , ] , } , ) [EOL] data_files = [ ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] , [string] , [string] , [string] ] ) , ] ,	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Tuple[builtins.str,typing.List[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Tuple[builtins.str,typing.List[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List , Tuple [EOL] import builtins [EOL] import typing [EOL] import gpxtrackposter [EOL] import s2sphere [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import locale [EOL] import math [EOL] import typing [EOL] [EOL] import colour [comment] [EOL] import s2sphere [comment] [EOL] [EOL] from gpxtrackposter . value_range import ValueRange [EOL] from gpxtrackposter . xy import XY [EOL] [EOL] [EOL] [comment] [EOL] def latlng2xy ( latlng ) : [EOL] return XY ( lng2x ( latlng . lng ( ) . degrees ) , lat2y ( latlng . lat ( ) . degrees ) ) [EOL] [EOL] [EOL] def lng2x ( lng_deg ) : [EOL] return lng_deg / [number] + [number] [EOL] [EOL] [EOL] def lat2y ( lat_deg ) : [EOL] return [number] - math . log ( math . tan ( math . pi / [number] * ( [number] + lat_deg / [number] ) ) ) / math . pi [EOL] [EOL] [EOL] def project ( bbox , size , offset , latlnglines ) : [EOL] min_x = lng2x ( bbox . lng_lo ( ) . degrees ) [EOL] d_x = lng2x ( bbox . lng_hi ( ) . degrees ) - min_x [EOL] while d_x >= [number] : [EOL] d_x -= [number] [EOL] while d_x < [number] : [EOL] d_x += [number] [EOL] min_y = lat2y ( bbox . lat_lo ( ) . degrees ) [EOL] max_y = lat2y ( bbox . lat_hi ( ) . degrees ) [EOL] d_y = abs ( max_y - min_y ) [EOL] [EOL] scale = size . x / d_x if size . x / size . y <= d_x / d_y else size . y / d_y [EOL] offset = offset + [number] * ( size - scale * XY ( d_x , - d_y ) ) - scale * XY ( min_x , min_y ) [EOL] lines = [ ] [EOL] for latlngline in latlnglines : [EOL] line = [ ] [EOL] for latlng in latlngline : [EOL] if bbox . contains ( latlng ) : [EOL] line . append ( ( offset + scale * latlng2xy ( latlng ) ) . tuple ( ) ) [EOL] else : [EOL] if len ( line ) > [number] : [EOL] lines . append ( line ) [EOL] line = [ ] [EOL] if len ( line ) > [number] : [EOL] lines . append ( line ) [EOL] return lines [EOL] [EOL] [EOL] def compute_bounds_xy ( lines ) : [EOL] range_x = ValueRange ( ) [EOL] range_y = ValueRange ( ) [EOL] for line in lines : [EOL] for xy in line : [EOL] range_x . extend ( xy . x ) [EOL] range_y . extend ( xy . y ) [EOL] return range_x , range_y [EOL] [EOL] [EOL] def compute_grid ( count , dimensions ) : [EOL] [comment] [EOL] min_waste = - [number] [EOL] best_size = None [EOL] best_counts = None [EOL] for count_x in range ( [number] , count + [number] ) : [EOL] size_x = dimensions . x / count_x [EOL] for count_y in range ( [number] , count + [number] ) : [EOL] if count_x * count_y >= count : [EOL] size_y = dimensions . y / count_y [EOL] size = min ( size_x , size_y ) [EOL] waste = dimensions . x * dimensions . y - count * size * size [EOL] if waste < [number] : [EOL] continue [EOL] if best_size is None or waste < min_waste : [EOL] best_size = size [EOL] best_counts = count_x , count_y [EOL] min_waste = waste [EOL] return best_size , best_counts [EOL] [EOL] [EOL] def interpolate_color ( color1 , color2 , ratio ) : [EOL] if ratio < [number] : [EOL] ratio = [number] [EOL] elif ratio > [number] : [EOL] ratio = [number] [EOL] c1 = colour . Color ( color1 ) [EOL] c2 = colour . Color ( color2 ) [EOL] c3 = colour . Color ( hue = ( ( [number] - ratio ) * c1 . hue + ratio * c2 . hue ) , saturation = ( ( [number] - ratio ) * c1 . saturation + ratio * c2 . saturation ) , luminance = ( ( [number] - ratio ) * c1 . luminance + ratio * c2 . luminance ) , ) [EOL] return c3 . hex_l [EOL] [EOL] [EOL] def format_float ( f ) : [EOL] return locale . format_string ( [string] , f ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Tuple[builtins.float,builtins.float]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[gpxtrackposter.value_range.ValueRange,gpxtrackposter.value_range.ValueRange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.float],typing.Optional[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import svgwrite [EOL] import typing [EOL] import gpxtrackposter [EOL] import argparse [EOL] import s2sphere [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import argparse [EOL] import logging [EOL] import math [EOL] [EOL] import svgwrite [comment] [EOL] import s2sphere [comment] [EOL] [EOL] from gpxtrackposter . exceptions import ParameterError [EOL] from gpxtrackposter . poster import Poster [EOL] from gpxtrackposter . tracks_drawer import TracksDrawer [EOL] from gpxtrackposter . xy import XY [EOL] from gpxtrackposter import utils [EOL] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class HeatmapDrawer ( TracksDrawer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , the_poster ) : [EOL] super ( ) . __init__ ( the_poster ) [EOL] self . _center = None [EOL] self . _radius = None [EOL] [EOL] def create_args ( self , args_parser ) : [EOL] group = args_parser . add_argument_group ( [string] ) [EOL] group . add_argument ( [string] , dest = [string] , metavar = [string] , type = str , help = [string] , ) [EOL] group . add_argument ( [string] , dest = [string] , metavar = [string] , type = float , help = [string] [string] , ) [EOL] [EOL] def fetch_args ( self , args ) : [EOL] [docstring] [EOL] self . _center = None [EOL] if args . heatmap_center : [EOL] latlng_str = args . heatmap_center . split ( [string] ) [EOL] if len ( latlng_str ) != [number] : [EOL] raise ParameterError ( f" [string] { args . heatmap_center }" ) [EOL] try : [EOL] lat = float ( latlng_str [ [number] ] . strip ( ) ) [EOL] lng = float ( latlng_str [ [number] ] . strip ( ) ) [EOL] except ValueError as e : [EOL] raise ParameterError ( f" [string] { args . heatmap_center }" ) from e [EOL] if not - [number] <= lat <= [number] or not - [number] <= lng <= [number] : [EOL] raise ParameterError ( f" [string] { args . heatmap_center }" ) [EOL] self . _center = s2sphere . LatLng . from_degrees ( lat , lng ) [EOL] if args . heatmap_radius : [EOL] if args . heatmap_radius <= [number] : [EOL] raise ParameterError ( f" [string] { args . heatmap_radius } [string] " ) [EOL] if not args . heatmap_center : [EOL] raise ParameterError ( [string] ) [EOL] self . _radius = args . heatmap_radius [EOL] [EOL] def _determine_bbox ( self ) : [EOL] if self . _center : [EOL] log . info ( [string] , str ( self . _center ) ) [EOL] dlat , dlng = [number] , [number] [EOL] if self . _radius : [EOL] er = [number] [EOL] quarter = er * math . pi / [number] [EOL] dlat = [number] * self . _radius / quarter [EOL] scale = [number] / math . cos ( self . _center . lat ( ) . radians ) [EOL] dlng = scale * [number] * self . _radius / quarter [EOL] else : [EOL] for tr in self . poster . tracks : [EOL] for line in tr . polylines : [EOL] for latlng in line : [EOL] d = abs ( self . _center . lat ( ) . degrees - latlng . lat ( ) . degrees ) [EOL] dlat = max ( dlat , d ) [EOL] d = abs ( self . _center . lng ( ) . degrees - latlng . lng ( ) . degrees ) [EOL] while d > [number] : [EOL] d -= [number] [EOL] if d > [number] : [EOL] d = [number] - d [EOL] dlng = max ( dlng , d ) [EOL] return s2sphere . LatLngRect . from_center_size ( self . _center , s2sphere . LatLng . from_degrees ( [number] * dlat , [number] * dlng ) ) [EOL] [EOL] tracks_bbox = s2sphere . LatLngRect ( ) [EOL] for tr in self . poster . tracks : [EOL] tracks_bbox = tracks_bbox . union ( tr . bbox ( ) ) [EOL] return tracks_bbox [EOL] [EOL] def draw ( self , dr , size , offset ) : [EOL] [docstring] [EOL] bbox = self . _determine_bbox ( ) [EOL] for tr in self . poster . tracks : [EOL] color = self . color ( self . poster . length_range , tr . length ( ) , tr . special ) [EOL] for line in utils . project ( bbox , size , offset , tr . polylines ) : [EOL] for opacity , width in [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] : [EOL] dr . add ( dr . polyline ( points = line , stroke = color , stroke_opacity = opacity , fill = [string] , stroke_width = width , stroke_linejoin = [string] , stroke_linecap = [string] , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.poster.Poster$ 0 0 0 0 0 0 0 0 0 $gpxtrackposter.poster.Poster$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 $argparse._ArgumentGroup$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $s2sphere.LatLngRect$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $svgwrite.Drawing$ 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import svgwrite [EOL] import typing [EOL] import gpxtrackposter [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import svgwrite [comment] [EOL] [EOL] from gpxtrackposter . exceptions import PosterError [EOL] from gpxtrackposter . poster import Poster [EOL] from gpxtrackposter . track import Track [EOL] from gpxtrackposter . tracks_drawer import TracksDrawer [EOL] from gpxtrackposter . xy import XY [EOL] from gpxtrackposter import utils [EOL] [EOL] [EOL] class GridDrawer ( TracksDrawer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , the_poster ) : [EOL] super ( ) . __init__ ( the_poster ) [EOL] [EOL] def draw ( self , dr , size , offset ) : [EOL] [docstring] [EOL] if self . poster . tracks is None : [EOL] raise PosterError ( [string] ) [EOL] cell_size , counts = utils . compute_grid ( len ( self . poster . tracks ) , size ) [EOL] if cell_size is None or counts is None : [EOL] raise PosterError ( [string] ) [EOL] count_x , count_y = counts [ [number] ] , counts [ [number] ] [EOL] spacing_x = [number] if count_x <= [number] else ( size . x - cell_size * count_x ) / ( count_x - [number] ) [EOL] spacing_y = [number] if count_y <= [number] else ( size . y - cell_size * count_y ) / ( count_y - [number] ) [EOL] offset . x += ( size . x - count_x * cell_size - ( count_x - [number] ) * spacing_x ) / [number] [EOL] offset . y += ( size . y - count_y * cell_size - ( count_y - [number] ) * spacing_y ) / [number] [EOL] for ( index , tr ) in enumerate ( self . poster . tracks ) : [EOL] p = XY ( index % count_x , index // count_x ) * XY ( cell_size + spacing_x , cell_size + spacing_y ) [EOL] self . _draw_track ( dr , tr , [number] * XY ( cell_size , cell_size ) , offset + [number] * XY ( cell_size , cell_size ) + p , ) [EOL] [EOL] def _draw_track ( self , dr , tr , size , offset ) : [EOL] color = self . color ( self . poster . length_range , tr . length ( ) , tr . special ) [EOL] str_length = utils . format_float ( self . poster . m2u ( tr . length ( ) ) ) [EOL] [EOL] date_title = str ( tr . start_time . date ( ) ) if tr . start_time else [string] [EOL] for line in utils . project ( tr . bbox ( ) , size , offset , tr . polylines ) : [EOL] polyline = dr . polyline ( points = line , stroke = color , fill = [string] , stroke_width = [number] , stroke_linejoin = [string] , stroke_linecap = [string] , ) [EOL] polyline . set_desc ( title = f"{ date_title } [string] { str_length } [string] { self . poster . u ( ) }" ) [EOL] dr . add ( polyline ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $gpxtrackposter.poster.Poster$ 0 0 0 0 0 0 0 0 0 $gpxtrackposter.poster.Poster$ 0 0 0 0 $None$ 0 0 0 $svgwrite.Drawing$ 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 $None$ 0 0 0 $svgwrite.Drawing$ 0 $gpxtrackposter.track.Track$ 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $gpxtrackposter.track.Track$ 0 0 0 0 0 $gpxtrackposter.track.Track$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.track.Track$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $gpxtrackposter.track.Track$ 0 0 0 0 0 0 0 0 $gpxtrackposter.track.Track$ 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.track.Track$ 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.track.Track$ 0 0 0 0 0 $typing.Any$ 0 $svgwrite.Drawing$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $typing.Any$ 0 0
from typing import Tuple , List [EOL] import svgwrite [EOL] import typing [EOL] import gpxtrackposter [EOL] import datetime [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import calendar [EOL] import datetime [EOL] [EOL] import svgwrite [comment] [EOL] [EOL] from gpxtrackposter import utils [EOL] from gpxtrackposter . exceptions import PosterError [EOL] from gpxtrackposter . localization import localized_day_of_week_name [EOL] from gpxtrackposter . poster import Poster [EOL] from gpxtrackposter . tracks_drawer import TracksDrawer [EOL] from gpxtrackposter . xy import XY [EOL] [EOL] [EOL] class CalendarDrawer ( TracksDrawer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , the_poster ) : [EOL] super ( ) . __init__ ( the_poster ) [EOL] [EOL] def draw ( self , dr , size , offset ) : [EOL] [docstring] [EOL] if self . poster . tracks is None : [EOL] raise PosterError ( [string] ) [EOL] years = self . poster . years . count ( ) [EOL] _ , counts = utils . compute_grid ( years , size ) [EOL] if counts is None : [EOL] raise PosterError ( [string] ) [EOL] count_x , count_y = counts [ [number] ] , counts [ [number] ] [EOL] x , y = [number] , [number] [EOL] cell_size = size * XY ( [number] / count_x , [number] / count_y ) [EOL] margin = XY ( [number] , [number] ) [EOL] if count_x <= [number] : [EOL] margin . x = [number] [EOL] if count_y <= [number] : [EOL] margin . y = [number] [EOL] sub_size = cell_size - [number] * margin [EOL] [EOL] for year in self . poster . years . iter ( ) : [EOL] self . _draw ( dr , sub_size , offset + margin + cell_size * XY ( x , y ) , year ) [EOL] x += [number] [EOL] if x >= count_x : [EOL] x = [number] [EOL] y += [number] [EOL] [EOL] def _draw ( self , dr , size , offset , year ) : [EOL] min_size = min ( size . x , size . y ) [EOL] year_size = min_size * [number] / [number] [EOL] year_style = f" [string] { year_size } [string] " [EOL] month_style = f" [string] { min_size * [number] / [number] } [string] " [EOL] day_style = f" [string] { min_size * [number] / [number] } [string] " [EOL] day_length_style = f" [string] { min_size * [number] / [number] } [string] " [EOL] [EOL] dr . add ( dr . text ( f"{ year }" , insert = offset . tuple ( ) , fill = self . poster . colors [ [string] ] , alignment_baseline = [string] , style = year_style , ) ) [EOL] offset . y += year_size [EOL] size . y -= year_size [EOL] count_x = [number] [EOL] for month in range ( [number] , [number] ) : [EOL] date = datetime . date ( year , month , [number] ) [EOL] ( _ , last_day ) = calendar . monthrange ( year , month ) [EOL] count_x = max ( count_x , date . weekday ( ) + last_day ) [EOL] [EOL] cell_size = min ( size . x / count_x , size . y / [number] ) [EOL] spacing = XY ( ( size . x - cell_size * count_x ) / ( count_x - [number] ) , ( size . y - cell_size * [number] * [number] ) / [number] , ) [EOL] [EOL] for month in range ( [number] , [number] ) : [EOL] date = datetime . date ( year , month , [number] ) [EOL] y = month - [number] [EOL] y_pos = offset . y + ( y * [number] + [number] ) * cell_size + y * spacing . y [EOL] dr . add ( dr . text ( self . poster . month_name ( month ) , insert = ( offset . x , y_pos - [number] ) , fill = self . poster . colors [ [string] ] , alignment_baseline = [string] , style = month_style , ) ) [EOL] [EOL] day_offset = date . weekday ( ) [EOL] while date . month == month : [EOL] x = date . day - [number] [EOL] x_pos = offset . x + ( day_offset + x ) * cell_size + x * spacing . x [EOL] pos = ( x_pos + [number] * cell_size , y_pos + [number] * cell_size ) [EOL] dim = ( cell_size * [number] , cell_size * [number] ) [EOL] text_date = date . strftime ( [string] ) [EOL] if text_date in self . poster . tracks_by_date : [EOL] tracks = self . poster . tracks_by_date [ text_date ] [EOL] length = sum ( [ t . length ( ) for t in tracks ] ) [EOL] has_special = len ( [ t for t in tracks if t . special ] ) > [number] [EOL] color = self . color ( self . poster . length_range_by_date , length , has_special ) [EOL] dr . add ( dr . rect ( pos , dim , fill = color ) ) [EOL] dr . add ( dr . text ( utils . format_float ( self . poster . m2u ( length ) ) , insert = ( pos [ [number] ] + cell_size / [number] , pos [ [number] ] + cell_size + cell_size / [number] , ) , text_anchor = [string] , style = day_length_style , fill = self . poster . colors [ [string] ] , ) ) [EOL] else : [EOL] dr . add ( dr . rect ( pos , dim , fill = [string] ) ) [EOL] [EOL] dr . add ( dr . text ( localized_day_of_week_name ( date . weekday ( ) , short = True ) , insert = ( offset . x + ( day_offset + x ) * cell_size + cell_size / [number] , pos [ [number] ] + cell_size / [number] , ) , text_anchor = [string] , alignment_baseline = [string] , style = day_style , ) ) [EOL] date += datetime . timedelta ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $svgwrite.Drawing$ 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 $builtins.int$ 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 $builtins.float$ 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 $builtins.float$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 $builtins.int$ 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 $builtins.float$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.int$ 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 $datetime.date$ 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 $builtins.int$ 0 $datetime.date$ 0 0 0 0 0 $builtins.float$ 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.float$ 0 $builtins.int$ 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 $datetime.date$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 $builtins.str$ 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 $builtins.float$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import builtins [EOL] import typing [EOL] import gpxtrackposter [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import typing [EOL] [EOL] [EOL] class ValueRange : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _lower = None [EOL] self . _upper = None [EOL] [EOL] @ classmethod def from_pair ( cls , value1 , value2 ) : [EOL] r = cls ( ) [EOL] r . extend ( value1 ) [EOL] r . extend ( value2 ) [EOL] return r [EOL] [EOL] def clear ( self ) : [EOL] self . _lower = None [EOL] self . _upper = None [EOL] [EOL] def is_valid ( self ) : [EOL] return self . _lower is not None [EOL] [EOL] def lower ( self ) : [EOL] return self . _lower [EOL] [EOL] def upper ( self ) : [EOL] return self . _upper [EOL] [EOL] def diameter ( self ) : [EOL] if self . is_valid ( ) : [EOL] assert self . _upper is not None [EOL] assert self . _lower is not None [EOL] return self . _upper - self . _lower [EOL] return [number] [EOL] [EOL] def contains ( self , value ) : [EOL] if not self . is_valid ( ) : [EOL] return False [EOL] [EOL] assert self . _upper is not None [EOL] assert self . _lower is not None [EOL] return self . _lower <= value <= self . _upper [EOL] [EOL] def extend ( self , value ) : [EOL] if not self . is_valid ( ) : [EOL] self . _lower = value [EOL] self . _upper = value [EOL] else : [EOL] assert self . _upper is not None [EOL] assert self . _lower is not None [EOL] self . _lower = min ( self . _lower , value ) [EOL] self . _upper = max ( self . _upper , value ) [EOL] [EOL] def interpolate ( self , relative ) : [EOL] if not self . is_valid ( ) : [EOL] raise ValueError ( [string] ) [EOL] assert self . _lower is not None [EOL] assert self . _upper is not None [EOL] return self . _lower + relative * ( self . _upper - self . _lower ) [EOL] [EOL] def relative_position ( self , value ) : [EOL] if not self . is_valid ( ) : [EOL] raise ValueError ( [string] ) [EOL] assert self . _lower is not None [EOL] assert self . _upper is not None [EOL] if value <= self . _lower : [EOL] return [number] [EOL] if value >= self . _upper : [EOL] return [number] [EOL] diff = self . _upper - self . _lower [EOL] if diff == [number] : [EOL] return [number] [EOL] return ( value - self . _lower ) / diff [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $"ValueRange"$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $gpxtrackposter.value_range.ValueRange$ 0 0 0 0 0 $gpxtrackposter.value_range.ValueRange$ 0 0 0 $builtins.float$ 0 0 $gpxtrackposter.value_range.ValueRange$ 0 0 0 $builtins.float$ 0 0 0 $gpxtrackposter.value_range.ValueRange$ 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $builtins.float$ 0 0 0 $typing.Optional[builtins.float]$ 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $builtins.float$ 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0
from typing import Tuple , Union [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Union [EOL] [EOL] [EOL] class XY : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , x = [number] , y = [number] ) : [EOL] self . x = x [EOL] self . y = y [EOL] [EOL] def __mul__ ( self , factor ) : [EOL] if isinstance ( factor , XY ) : [EOL] return XY ( self . x * factor . x , self . y * factor . y ) [EOL] return XY ( self . x * factor , self . y * factor ) [EOL] [EOL] def __rmul__ ( self , factor ) : [EOL] if isinstance ( factor , XY ) : [EOL] return XY ( self . x * factor . x , self . y * factor . y ) [EOL] return XY ( self . x * factor , self . y * factor ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] return XY ( self . x + other . x , self . y + other . y ) [EOL] [EOL] def __sub__ ( self , other ) : [EOL] return XY ( self . x - other . x , self . y - other . y ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . x } [string] { self . y }" [EOL] [EOL] def tuple ( self ) : [EOL] return self . x , self . y [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $"XY"$ 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 $"XY"$ 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 0 $typing.Union[builtins.float,"XY"]$ 0 0 0 0 $"XY"$ 0 0 0 $"XY"$ 0 0 0 0 0 0 0 0 0 0 $"XY"$ 0 0 0 0 0 0 0 $"XY"$ 0 0 0 0 0 0 $"XY"$ 0 0 0 $"XY"$ 0 0 0 0 0 0 0 0 0 0 $"XY"$ 0 0 0 0 0 0 0 $"XY"$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] import locale [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def localized_day_of_week_name ( day_of_week , short ) : [EOL] assert [number] <= day_of_week <= [number] [EOL] [EOL] locale_name = locale . getlocale ( ) [ [number] ] [EOL] [EOL] name = locale . nl_langinfo ( [ locale . DAY_2 , locale . DAY_3 , locale . DAY_4 , locale . DAY_5 , locale . DAY_6 , locale . DAY_7 , locale . DAY_1 , ] [ day_of_week ] ) [EOL] if short : [EOL] [comment] [EOL] if locale_name == [string] : [EOL] return name [ [number] ] . upper ( ) [EOL] return name [ [number] ] . upper ( ) [EOL] return name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Union [EOL] import logging [EOL] import typing [EOL] import gpxtrackposter [EOL] import argparse [EOL] import argparse [EOL] import logging [EOL] import os [EOL] import sys [EOL] [EOL] import appdirs [comment] [EOL] [EOL] from gpxtrackposter import poster , track_loader [EOL] from gpxtrackposter import grid_drawer , circular_drawer , heatmap_drawer [EOL] from gpxtrackposter import github_drawer , calendar_drawer [EOL] from gpxtrackposter . exceptions import ParameterError , PosterError [EOL] from gpxtrackposter . units import Units [EOL] [EOL] [EOL] __app_name__ = [string] [EOL] __app_author__ = [string] [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] p = poster . Poster ( ) [EOL] drawers = { [string] : grid_drawer . GridDrawer ( p ) , [string] : calendar_drawer . CalendarDrawer ( p ) , [string] : heatmap_drawer . HeatmapDrawer ( p ) , [string] : circular_drawer . CircularDrawer ( p ) , [string] : github_drawer . GithubDrawer ( p ) , } [EOL] [EOL] args_parser = argparse . ArgumentParser ( prog = __app_name__ ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , type = str , default = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , metavar = [string] , type = str , default = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , metavar = [string] , type = str , default = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] , ) [EOL] args_parser . add_argument ( [string] , metavar = [string] , type = str , default = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] ) [EOL] args_parser . add_argument ( [string] , metavar = [string] , type = str , default = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , metavar = [string] , action = [string] , default = [ ] , help = [string] [string] , ) [EOL] types = [string] . join ( drawers . keys ( ) ) [EOL] args_parser . add_argument ( [string] , metavar = [string] , default = [string] , choices = drawers . keys ( ) , help = f' [string] { types } [string] ' , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , type = str , default = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , type = str , default = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , type = str , help = [string] , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , type = str , default = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , default = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , type = str , choices = [ [string] , [string] ] , default = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , type = str ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , type = float , default = [number] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , type = float , default = [number] , help = [string] , ) [EOL] args_parser . add_argument ( [string] , dest = [string] , metavar = [string] , type = float , default = [number] , help = [string] , ) [EOL] [EOL] for _ , drawer in drawers . items ( ) : [EOL] drawer . create_args ( args_parser ) [EOL] [EOL] args = args_parser . parse_args ( ) [EOL] [EOL] for _ , drawer in drawers . items ( ) : [EOL] drawer . fetch_args ( args ) [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] log . setLevel ( logging . INFO if args . verbose else logging . ERROR ) [EOL] if args . logfile : [EOL] handler = logging . FileHandler ( args . logfile ) [EOL] log . addHandler ( handler ) [EOL] [EOL] loader = track_loader . TrackLoader ( ) [EOL] loader . set_cache_dir ( os . path . join ( appdirs . user_cache_dir ( __app_name__ , __app_author__ ) , [string] ) ) [EOL] if not loader . year_range . parse ( args . year ) : [EOL] raise ParameterError ( f" [string] { args . year } [string] " ) [EOL] [EOL] loader . special_file_names = args . special [EOL] loader . set_min_length ( args . min_distance * Units ( ) . km ) [EOL] if args . clear_cache : [EOL] print ( [string] ) [EOL] loader . clear_cache ( ) [EOL] [EOL] tracks = loader . load_tracks ( args . gpx_dir ) [EOL] if not tracks : [EOL] if not args . clear_cache : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] print ( f" [string] { args . type } [string] { len ( tracks ) } [string] { args . output } [string] " ) [EOL] p . set_language ( args . language , args . localedir ) [EOL] p . set_athlete ( args . athlete ) [EOL] p . set_title ( args . title if args . title else p . translate ( [string] ) ) [EOL] [EOL] p . special_distance = { [string] : args . special_distance * Units ( ) . km , [string] : args . special_distance2 * Units ( ) . km , } [EOL] [EOL] p . colors = { [string] : args . background_color , [string] : args . track_color , [string] : args . track_color2 or args . track_color , [string] : args . special_color , [string] : args . special_color2 or args . special_color , [string] : args . text_color , } [EOL] p . units = args . units [EOL] p . set_tracks ( tracks ) [EOL] if args . type == [string] : [EOL] p . height = [number] + p . years . count ( ) * [number] [EOL] p . draw ( drawers [ args . type ] , args . output ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] main ( ) [EOL] except PosterError as e : [EOL] print ( e ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Any , Union [EOL] import typing [EOL] import pytz [EOL] import s2sphere [EOL] import timezonefinder [EOL] import datetime [EOL] import datetime [EOL] import typing [EOL] [EOL] import pytz [EOL] import s2sphere [comment] [EOL] import timezonefinder [comment] [EOL] [EOL] [EOL] class TimezoneAdjuster : [EOL] _timezonefinder = None [EOL] [EOL] def __init__ ( self ) : [EOL] if not TimezoneAdjuster . _timezonefinder : [EOL] TimezoneAdjuster . _timezonefinder = timezonefinder . TimezoneFinder ( ) [EOL] [EOL] @ classmethod def adjust ( cls , time , latlng ) : [EOL] [comment] [EOL] if time . utcoffset ( ) : [EOL] return time [EOL] assert cls . _timezonefinder [EOL] tz_name = cls . _timezonefinder . timezone_at ( lat = latlng . lat ( ) . degrees , lng = latlng . lng ( ) . degrees ) [EOL] if tz_name is None : [EOL] return time [EOL] tz = pytz . timezone ( tz_name ) [EOL] tz_time = time . astimezone ( tz ) [EOL] return tz_time [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[timezonefinder.TimezoneFinder]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 $s2sphere.LatLng$ 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $s2sphere.LatLng$ 0 0 0 0 0 0 0 0 0 $s2sphere.LatLng$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 $typing.Any$ 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 $datetime.datetime$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Type , Any [EOL] import builtins [EOL] import typing [EOL] import gpxtrackposter [EOL] import typing [EOL] [EOL] import pint [comment] [EOL] [EOL] [EOL] class Units : [EOL] _instance = None [EOL] [EOL] def __init__ ( self ) : [EOL] if not Units . _instance : [EOL] Units . _instance = pint . UnitRegistry ( ) [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return getattr ( Units . _instance , name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Optional , Generator , Match [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import datetime [EOL] import re [EOL] import typing [EOL] [EOL] [EOL] class YearRange : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . from_year = None [EOL] self . to_year = None [EOL] [EOL] def parse ( self , s ) : [EOL] [docstring] [EOL] if s == [string] : [EOL] self . from_year = None [EOL] self . to_year = None [EOL] return True [EOL] m = re . match ( [string] , s ) [EOL] if m : [EOL] self . from_year = int ( s ) [EOL] self . to_year = self . from_year [EOL] return True [EOL] m = re . match ( [string] , s ) [EOL] if m : [EOL] y1 , y2 = int ( m . group ( [number] ) ) , int ( m . group ( [number] ) ) [EOL] if y1 <= y2 : [EOL] self . from_year = y1 [EOL] self . to_year = y2 [EOL] return True [EOL] return False [EOL] [EOL] def clear ( self ) : [EOL] self . from_year = None [EOL] self . to_year = None [EOL] [EOL] def add ( self , t ) : [EOL] [docstring] [EOL] if self . from_year is None : [EOL] self . from_year = t . year [EOL] self . to_year = t . year [EOL] return [EOL] [EOL] assert self . from_year is not None [EOL] assert self . to_year is not None [EOL] if t . year < self . from_year : [EOL] self . from_year = t . year [EOL] elif t . year > self . to_year : [EOL] self . to_year = t . year [EOL] [EOL] def contains ( self , t ) : [EOL] [docstring] [EOL] if self . from_year is None : [EOL] return True [EOL] [EOL] assert self . from_year is not None [EOL] assert self . to_year is not None [EOL] return self . from_year <= t . year <= self . to_year [EOL] [EOL] def count ( self ) : [EOL] [docstring] [EOL] if self . from_year is None : [EOL] return [number] [EOL] [EOL] assert self . to_year is not None [EOL] return [number] + self . to_year - self . from_year [EOL] [EOL] def iter ( self ) : [EOL] if self . from_year is None : [EOL] return [EOL] [EOL] assert self . to_year is not None [EOL] for year in range ( self . from_year , self . to_year + [number] ) : [EOL] yield year [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $None$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $datetime.datetime$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 $datetime.datetime$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 $datetime.datetime$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.int,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Any , List , Tuple [EOL] import svgwrite [EOL] import typing [EOL] import gpxtrackposter [EOL] import datetime [EOL] import calendar [EOL] import datetime [EOL] import locale [EOL] [EOL] import svgwrite [comment] [EOL] [EOL] from gpxtrackposter import utils [EOL] from gpxtrackposter . exceptions import PosterError [EOL] from gpxtrackposter . poster import Poster [EOL] from gpxtrackposter . tracks_drawer import TracksDrawer [EOL] from gpxtrackposter . xy import XY [EOL] [EOL] [EOL] class GithubDrawer ( TracksDrawer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , the_poster ) : [EOL] super ( ) . __init__ ( the_poster ) [EOL] [EOL] def draw ( self , dr , size , offset ) : [EOL] if self . poster . tracks is None : [EOL] raise PosterError ( [string] ) [EOL] year_size = [number] * [number] / [number] [EOL] year_style = f" [string] { year_size } [string] " [EOL] year_length_style = f" [string] { [number] * [number] / [number] } [string] " [EOL] month_names_style = [string] [EOL] total_length_year_dict = self . poster . total_length_year_dict [EOL] for year in self . poster . years . iter ( ) : [EOL] start_date_weekday , _ = calendar . monthrange ( year , [number] ) [EOL] github_rect_first_day = datetime . date ( year , [number] , [number] ) [EOL] [comment] [EOL] [comment] [EOL] github_rect_day = github_rect_first_day + datetime . timedelta ( - start_date_weekday ) [EOL] year_length = total_length_year_dict . get ( year , [number] ) [EOL] year_length_str = utils . format_float ( self . poster . m2u ( year_length ) ) [EOL] month_names = [ locale . nl_langinfo ( day ) [ : [number] ] for day in [ locale . MON_1 , locale . MON_2 , locale . MON_3 , locale . MON_4 , locale . MON_5 , locale . MON_6 , locale . MON_7 , locale . MON_8 , locale . MON_9 , locale . MON_10 , locale . MON_11 , locale . MON_12 , ] ] [EOL] km_or_mi = self . poster . u ( ) [EOL] dr . add ( dr . text ( f"{ year }" , insert = offset . tuple ( ) , fill = self . poster . colors [ [string] ] , alignment_baseline = [string] , style = year_style , ) ) [EOL] [EOL] dr . add ( dr . text ( f"{ year_length_str } [string] { km_or_mi }" , insert = ( offset . tuple ( ) [ [number] ] + [number] , offset . tuple ( ) [ [number] ] + [number] ) , fill = self . poster . colors [ [string] ] , alignment_baseline = [string] , style = year_length_style , ) ) [EOL] [comment] [EOL] for num , name in enumerate ( month_names ) : [EOL] dr . add ( dr . text ( f"{ name }" , insert = ( offset . tuple ( ) [ [number] ] + [number] * num , offset . tuple ( ) [ [number] ] + [number] ) , fill = self . poster . colors [ [string] ] , style = month_names_style , ) ) [EOL] [EOL] rect_x = [number] [EOL] dom = ( [number] , [number] ) [EOL] [comment] [EOL] for _i in range ( [number] ) : [EOL] rect_y = offset . y + year_size + [number] [EOL] for _j in range ( [number] ) : [EOL] if int ( github_rect_day . year ) > year : [EOL] break [EOL] rect_y += [number] [EOL] color = [string] [EOL] date_title = str ( github_rect_day ) [EOL] if date_title in self . poster . tracks_by_date : [EOL] tracks = self . poster . tracks_by_date [ date_title ] [EOL] length = sum ( [ t . length ( ) for t in tracks ] ) [EOL] distance1 = self . poster . special_distance [ [string] ] [EOL] distance2 = self . poster . special_distance [ [string] ] [EOL] has_special = distance1 < length < distance2 [EOL] color = self . color ( self . poster . length_range_by_date , length , has_special ) [EOL] if length >= distance2 : [EOL] special_color = self . poster . colors . get ( [string] ) or self . poster . colors . get ( [string] ) [EOL] if special_color is not None : [EOL] color = special_color [EOL] str_length = utils . format_float ( self . poster . m2u ( length ) ) [EOL] date_title = f"{ date_title } [string] { str_length } [string] { km_or_mi }" [EOL] [EOL] rect = dr . rect ( ( rect_x , rect_y ) , dom , fill = color ) [EOL] rect . set_desc ( title = date_title ) [EOL] dr . add ( rect ) [EOL] github_rect_day += datetime . timedelta ( [number] ) [EOL] rect_x += [number] [EOL] offset . y += [number] * [number] + year_size + [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.poster.Poster$ 0 0 0 0 0 0 0 0 0 $gpxtrackposter.poster.Poster$ 0 0 0 0 $None$ 0 0 0 $svgwrite.Drawing$ 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $gpxtrackposter.xy.XY$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $datetime.date$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.float$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $svgwrite.Drawing$ 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $svgwrite.Drawing$ 0 0 0 $typing.Any$ 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0
from typing import Optional , Any , Callable , Dict , List , Tuple [EOL] import svgwrite [EOL] import logging [EOL] import typing [EOL] import pint [EOL] import gpxtrackposter [EOL] import builtins [EOL] import gettext [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from collections import defaultdict [EOL] import gettext [EOL] import locale [EOL] import logging [EOL] import typing [EOL] [EOL] import pint [comment] [EOL] import svgwrite [comment] [EOL] [EOL] from gpxtrackposter . quantity_range import QuantityRange [EOL] from gpxtrackposter . track import Track [EOL] from gpxtrackposter . units import Units [EOL] from gpxtrackposter . utils import format_float [EOL] from gpxtrackposter . xy import XY [EOL] from gpxtrackposter . year_range import YearRange [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] [comment] [EOL] from gpxtrackposter . tracks_drawer import TracksDrawer [comment] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Poster : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _athlete = None [EOL] self . _title = None [EOL] self . tracks_by_date = defaultdict ( list ) [EOL] self . tracks = [ ] [EOL] self . length_range = QuantityRange ( ) [EOL] self . length_range_by_date = QuantityRange ( ) [EOL] self . total_length_year_dict = defaultdict ( int ) [EOL] self . units = [string] [EOL] self . colors = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] self . special_distance = { [string] : [number] , [string] : [number] } [EOL] self . width = [number] [EOL] self . height = [number] [EOL] self . years = YearRange ( ) [EOL] self . tracks_drawer = None [EOL] self . _trans = None [EOL] self . set_language ( None , None ) [EOL] [EOL] def set_language ( self , language , localedir ) : [EOL] if language : [EOL] try : [EOL] locale . setlocale ( locale . LC_ALL , f"{ language } [string] " ) [EOL] except locale . Error as e : [EOL] log . warning ( [string] , language , str ( e ) ) [EOL] language = None [EOL] [EOL] [comment] [EOL] if language : [EOL] lang = gettext . translation ( [string] , localedir = localedir , languages = [ language ] , fallback = True ) [EOL] if len ( lang . info ( ) ) == [number] : [EOL] log . warning ( [string] , language , localedir if localedir else [string] , ) [EOL] else : [EOL] lang = gettext . NullTranslations ( ) [EOL] self . _trans = lang . gettext [EOL] [EOL] def translate ( self , s ) : [EOL] if self . _trans is None : [EOL] return s [EOL] return self . _trans ( s ) [EOL] [EOL] def month_name ( self , month ) : [EOL] assert [number] <= month <= [number] [EOL] [EOL] return [ self . translate ( [string] ) , self . translate ( [string] ) , self . translate ( [string] ) , self . translate ( [string] ) , self . translate ( [string] ) , self . translate ( [string] ) , self . translate ( [string] ) , self . translate ( [string] ) , self . translate ( [string] ) , self . translate ( [string] ) , self . translate ( [string] ) , self . translate ( [string] ) , ] [ month - [number] ] [EOL] [EOL] def set_athlete ( self , athlete ) : [EOL] self . _athlete = athlete [EOL] [EOL] def set_title ( self , title ) : [EOL] self . _title = title [EOL] [EOL] def set_tracks ( self , tracks ) : [EOL] [docstring] [EOL] self . tracks = tracks [EOL] self . tracks_by_date . clear ( ) [EOL] self . length_range . clear ( ) [EOL] self . length_range_by_date . clear ( ) [EOL] self . _compute_years ( tracks ) [EOL] for track in tracks : [EOL] assert track . start_time is not None [EOL] if not self . years . contains ( track . start_time ) : [EOL] continue [EOL] text_date = track . start_time . strftime ( [string] ) [EOL] self . tracks_by_date [ text_date ] . append ( track ) [EOL] self . length_range . extend ( track . length ( ) ) [EOL] for date_tracks in self . tracks_by_date . values ( ) : [EOL] length = sum ( [ t . length ( ) for t in date_tracks ] ) [EOL] self . length_range_by_date . extend ( length ) [EOL] [EOL] def draw ( self , drawer , output ) : [EOL] [docstring] [EOL] self . tracks_drawer = drawer [EOL] d = svgwrite . Drawing ( output , ( f"{ self . width } [string] " , f"{ self . height } [string] " ) ) [EOL] d . viewbox ( [number] , [number] , self . width , self . height ) [EOL] d . add ( d . rect ( ( [number] , [number] ) , ( self . width , self . height ) , fill = self . colors [ [string] ] ) ) [EOL] self . _draw_header ( d ) [EOL] self . _draw_footer ( d ) [EOL] self . _draw_tracks ( d , XY ( self . width - [number] , self . height - [number] - [number] ) , XY ( [number] , [number] ) ) [EOL] d . save ( ) [EOL] [EOL] def m2u ( self , m ) : [EOL] [docstring] [EOL] if self . units == [string] : [EOL] return m . m_as ( Units ( ) . km ) [EOL] return m . m_as ( Units ( ) . mile ) [EOL] [EOL] def u ( self ) : [EOL] [docstring] [EOL] if self . units == [string] : [EOL] return self . translate ( [string] ) [EOL] return self . translate ( [string] ) [EOL] [EOL] def format_distance ( self , d ) : [EOL] [docstring] [EOL] return format_float ( self . m2u ( d ) ) + [string] + self . u ( ) [EOL] [EOL] def _draw_tracks ( self , d , size , offset ) : [EOL] assert self . tracks_drawer [EOL] self . tracks_drawer . draw ( d , size , offset ) [EOL] [EOL] def _draw_header ( self , d ) : [EOL] text_color = self . colors [ [string] ] [EOL] title_style = [string] [EOL] assert self . _title is not None [EOL] d . add ( d . text ( self . _title , insert = ( [number] , [number] ) , fill = text_color , style = title_style ) ) [EOL] [EOL] def _draw_footer ( self , d ) : [EOL] text_color = self . colors [ [string] ] [EOL] header_style = [string] [EOL] value_style = [string] [EOL] small_value_style = [string] [EOL] [EOL] ( total_length , average_length , length_range , weeks , ) = self . _compute_track_statistics ( ) [EOL] [EOL] d . add ( d . text ( self . translate ( [string] ) , insert = ( [number] , self . height - [number] ) , fill = text_color , style = header_style , ) ) [EOL] d . add ( d . text ( self . _athlete , insert = ( [number] , self . height - [number] ) , fill = text_color , style = value_style , ) ) [EOL] d . add ( d . text ( self . translate ( [string] ) , insert = ( [number] , self . height - [number] ) , fill = text_color , style = header_style , ) ) [EOL] d . add ( d . text ( self . translate ( [string] ) + f" [string] { len ( self . tracks ) }" , insert = ( [number] , self . height - [number] ) , fill = text_color , style = small_value_style , ) ) [EOL] d . add ( d . text ( self . translate ( [string] ) + [string] + format_float ( len ( self . tracks ) / weeks ) , insert = ( [number] , self . height - [number] ) , fill = text_color , style = small_value_style , ) ) [EOL] d . add ( d . text ( self . translate ( [string] ) + [string] + self . format_distance ( total_length ) , insert = ( [number] , self . height - [number] ) , fill = text_color , style = small_value_style , ) ) [EOL] d . add ( d . text ( self . translate ( [string] ) + [string] + self . format_distance ( average_length ) , insert = ( [number] , self . height - [number] ) , fill = text_color , style = small_value_style , ) ) [EOL] if length_range . is_valid ( ) : [EOL] min_length = length_range . lower ( ) [EOL] max_length = length_range . upper ( ) [EOL] assert min_length is not None [EOL] assert max_length is not None [EOL] else : [EOL] min_length = [number] [EOL] max_length = [number] [EOL] d . add ( d . text ( self . translate ( [string] ) + [string] + self . format_distance ( min_length ) , insert = ( [number] , self . height - [number] ) , fill = text_color , style = small_value_style , ) ) [EOL] d . add ( d . text ( self . translate ( [string] ) + [string] + self . format_distance ( max_length ) , insert = ( [number] , self . height - [number] ) , fill = text_color , style = small_value_style , ) ) [EOL] [EOL] def _compute_track_statistics ( self , ) : [EOL] length_range = QuantityRange ( ) [EOL] total_length = [number] * Units ( ) . meter [EOL] self . total_length_year_dict . clear ( ) [EOL] weeks = { } [EOL] for t in self . tracks : [EOL] assert t . start_time is not None [EOL] total_length += t . length ( ) [EOL] self . total_length_year_dict [ t . start_time . year ] += t . length ( ) [EOL] length_range . extend ( t . length ( ) ) [EOL] [comment] [EOL] weeks [ ( t . start_time . year , t . start_time . isocalendar ( ) [ [number] ] ) ] = [number] [EOL] return ( total_length , total_length / len ( self . tracks ) , length_range , len ( weeks ) , ) [EOL] [EOL] def _compute_years ( self , tracks ) : [EOL] self . years . clear ( ) [EOL] for t in tracks : [EOL] assert t . start_time is not None [EOL] self . years . add ( t . start_time ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[gpxtrackposter.track.Track]]$ 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,pint.quantity.Quantity]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $gpxtrackposter.year_range.YearRange$ 0 0 0 0 0 0 0 $typing.Optional["TracksDrawer"]$ 0 0 0 0 0 $typing.Optional[typing.Callable[[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $gettext.NullTranslations$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $gettext.NullTranslations$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $gettext.NullTranslations$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Callable[[builtins.str],builtins.str]]$ 0 $gettext.NullTranslations$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 $"TracksDrawer"$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[gpxtrackposter.tracks_drawer.TracksDrawer]$ 0 $"TracksDrawer"$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $pint.quantity.Quantity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pint.quantity.Quantity$ 0 0 0 0 0 0 0 0 0 0 0 $pint.quantity.Quantity$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pint.quantity.Quantity$ 0 0 0 0 0 0 0 0 0 0 0 0 $pint.quantity.Quantity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $svgwrite.Drawing$ 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $svgwrite.Drawing$ 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 0 0 0 $None$ 0 0 0 $svgwrite.Drawing$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $svgwrite.Drawing$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $svgwrite.Drawing$ 0 0 0 $svgwrite.Drawing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Tuple[pint.quantity.Quantity,pint.quantity.Quantity,gpxtrackposter.quantity_range.QuantityRange,builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Dict , List , Generator [EOL] import logging [EOL] import typing [EOL] import gpxtrackposter [EOL] import pint [EOL] import concurrent [EOL] import datetime [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import concurrent . futures [EOL] import hashlib [EOL] import logging [EOL] import os [EOL] import shutil [EOL] import typing [EOL] [EOL] import pint [comment] [EOL] [EOL] from gpxtrackposter . exceptions import ParameterError , TrackLoadError [EOL] from gpxtrackposter . timezone_adjuster import TimezoneAdjuster [EOL] from gpxtrackposter . track import Track [EOL] from gpxtrackposter . units import Units [EOL] from gpxtrackposter . year_range import YearRange [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def load_gpx_file ( file_name , timezone_adjuster ) : [EOL] [docstring] [EOL] log . info ( [string] , os . path . basename ( file_name ) ) [EOL] t = Track ( ) [EOL] t . load_gpx ( file_name , timezone_adjuster ) [EOL] return t [EOL] [EOL] [EOL] def load_cached_track_file ( cache_file_name , file_name ) : [EOL] [docstring] [EOL] try : [EOL] t = Track ( ) [EOL] t . load_cache ( cache_file_name ) [EOL] t . file_names = [ os . path . basename ( file_name ) ] [EOL] log . info ( [string] , file_name , cache_file_name ) [EOL] return t [EOL] except Exception as e : [EOL] raise TrackLoadError ( [string] ) from e [EOL] [EOL] [EOL] class TrackLoader : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _min_length = [number] * Units ( ) . km [EOL] self . special_file_names = [ ] [EOL] self . year_range = YearRange ( ) [EOL] self . cache_dir = None [EOL] self . _cache_file_names = { } [EOL] [EOL] def set_cache_dir ( self , cache_dir ) : [EOL] self . cache_dir = cache_dir [EOL] [EOL] def clear_cache ( self ) : [EOL] [docstring] [EOL] if self . cache_dir is not None and os . path . isdir ( self . cache_dir ) : [EOL] log . info ( [string] , self . cache_dir ) [EOL] try : [EOL] shutil . rmtree ( self . cache_dir ) [EOL] except OSError as e : [EOL] log . error ( [string] , str ( e ) ) [EOL] [EOL] def set_min_length ( self , min_length ) : [EOL] self . _min_length = min_length [EOL] [EOL] def load_tracks ( self , base_dir ) : [EOL] [docstring] [EOL] file_names = list ( self . _list_gpx_files ( base_dir ) ) [EOL] log . info ( [string] , len ( file_names ) ) [EOL] [EOL] tracks = [ ] [EOL] [EOL] [comment] [EOL] cached_tracks = { } [EOL] if self . cache_dir : [EOL] log . info ( [string] , len ( file_names ) ) [EOL] cached_tracks = self . _load_tracks_from_cache ( file_names ) [EOL] log . info ( [string] , len ( cached_tracks ) ) [EOL] tracks = list ( cached_tracks . values ( ) ) [EOL] [EOL] [comment] [EOL] remaining_file_names = [ f for f in file_names if f not in cached_tracks ] [EOL] if remaining_file_names : [EOL] log . info ( [string] , len ( remaining_file_names ) ) [EOL] timezone_adjuster = TimezoneAdjuster ( ) [EOL] loaded_tracks = self . _load_tracks ( remaining_file_names , timezone_adjuster ) [EOL] tracks . extend ( loaded_tracks . values ( ) ) [EOL] log . info ( [string] , len ( loaded_tracks ) ) [EOL] self . _store_tracks_to_cache ( loaded_tracks ) [EOL] [EOL] tracks = self . _filter_tracks ( tracks ) [EOL] [EOL] [comment] [EOL] tracks = self . _merge_tracks ( tracks ) [EOL] [comment] [EOL] return [ t for t in tracks if t . length ( ) >= self . _min_length ] [EOL] [EOL] def _filter_tracks ( self , tracks ) : [EOL] filtered_tracks = [ ] [EOL] for t in tracks : [EOL] file_name = t . file_names [ [number] ] [EOL] if t . length ( ) . magnitude == [number] : [EOL] log . info ( [string] , file_name ) [EOL] elif not t . start_time : [EOL] log . info ( [string] , file_name ) [EOL] elif not self . year_range . contains ( t . start_time ) : [EOL] log . info ( [string] , file_name , t . start_time . year ) [EOL] else : [EOL] t . special = file_name in self . special_file_names [EOL] filtered_tracks . append ( t ) [EOL] return filtered_tracks [EOL] [EOL] @ staticmethod def _merge_tracks ( tracks ) : [EOL] log . info ( [string] ) [EOL] tracks = sorted ( tracks , key = lambda t1 : t1 . start_time ) [EOL] merged_tracks = [ ] [EOL] last_end_time = None [EOL] for t in tracks : [EOL] if last_end_time is None : [EOL] merged_tracks . append ( t ) [EOL] else : [EOL] dt = ( t . start_time - last_end_time ) . total_seconds ( ) [EOL] if [number] < dt < [number] : [EOL] merged_tracks [ - [number] ] . append ( t ) [EOL] else : [EOL] merged_tracks . append ( t ) [EOL] last_end_time = t . end_time [EOL] log . info ( [string] , len ( tracks ) - len ( merged_tracks ) ) [EOL] return merged_tracks [EOL] [EOL] @ staticmethod def _load_tracks ( file_names , timezone_adjuster ) : [EOL] tracks = { } [EOL] with concurrent . futures . ProcessPoolExecutor ( ) as executor : [EOL] future_to_file_name = { executor . submit ( load_gpx_file , file_name , timezone_adjuster ) : file_name for file_name in file_names } [EOL] for future in concurrent . futures . as_completed ( future_to_file_name ) : [EOL] file_name = future_to_file_name [ future ] [EOL] try : [EOL] t = future . result ( ) [EOL] except TrackLoadError as e : [EOL] log . error ( [string] , file_name , str ( e ) ) [EOL] else : [EOL] tracks [ file_name ] = t [EOL] [EOL] return tracks [EOL] [EOL] def _load_tracks_from_cache ( self , file_names ) : [EOL] tracks = { } [EOL] with concurrent . futures . ProcessPoolExecutor ( ) as executor : [EOL] future_to_file_name = { executor . submit ( load_cached_track_file , self . _get_cache_file_name ( file_name ) , file_name ) : file_name for file_name in file_names } [EOL] for future in concurrent . futures . as_completed ( future_to_file_name ) : [EOL] file_name = future_to_file_name [ future ] [EOL] try : [EOL] t = future . result ( ) [EOL] except Exception : [EOL] [comment] [EOL] pass [EOL] else : [EOL] tracks [ file_name ] = t [EOL] return tracks [EOL] [EOL] def _store_tracks_to_cache ( self , tracks ) : [EOL] if ( not tracks ) or ( not self . cache_dir ) : [EOL] return [EOL] [EOL] log . info ( [string] , len ( tracks ) ) [EOL] for ( file_name , t ) in tracks . items ( ) : [EOL] try : [EOL] t . store_cache ( self . _get_cache_file_name ( file_name ) ) [EOL] except Exception as e : [EOL] log . error ( [string] , file_name , str ( e ) ) [EOL] else : [EOL] log . info ( [string] , file_name ) [EOL] [EOL] @ staticmethod def _list_gpx_files ( base_dir ) : [EOL] base_dir = os . path . abspath ( base_dir ) [EOL] if not os . path . isdir ( base_dir ) : [EOL] raise ParameterError ( f" [string] { base_dir }" ) [EOL] for name in os . listdir ( base_dir ) : [EOL] path_name = os . path . join ( base_dir , name ) [EOL] if name . endswith ( [string] ) and os . path . isfile ( path_name ) : [EOL] yield path_name [EOL] [EOL] def _get_cache_file_name ( self , file_name ) : [EOL] assert self . cache_dir [EOL] [EOL] if file_name in self . _cache_file_names : [EOL] return self . _cache_file_names [ file_name ] [EOL] [EOL] try : [EOL] checksum = hashlib . sha256 ( open ( file_name , [string] ) . read ( ) ) . hexdigest ( ) [EOL] except PermissionError as e : [EOL] raise TrackLoadError ( [string] ) from e [EOL] except Exception as e : [EOL] raise TrackLoadError ( [string] ) from e [EOL] [EOL] cache_file_name = os . path . join ( self . cache_dir , f"{ checksum } [string] " ) [EOL] self . _cache_file_names [ file_name ] = cache_file_name [EOL] return cache_file_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[gpxtrackposter.track.Track]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,gpxtrackposter.track.Track]$ 0 $typing.List[builtins.str]$ 0 $gpxtrackposter.timezone_adjuster.TimezoneAdjuster$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[concurrent.futures._base.Future[gpxtrackposter.track.Track],builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $gpxtrackposter.timezone_adjuster.TimezoneAdjuster$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[concurrent.futures._base.Future[gpxtrackposter.track.Track],builtins.str]$ 0 0 0 $builtins.str$ 0 $typing.Dict[concurrent.futures._base.Future[gpxtrackposter.track.Track],builtins.str]$ 0 0 0 0 0 0 0 $gpxtrackposter.track.Track$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $gpxtrackposter.track.Track$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,gpxtrackposter.track.Track]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[concurrent.futures._base.Future[gpxtrackposter.track.Track],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[concurrent.futures._base.Future[gpxtrackposter.track.Track],builtins.str]$ 0 0 0 $builtins.str$ 0 $typing.Dict[concurrent.futures._base.Future[gpxtrackposter.track.Track],builtins.str]$ 0 0 0 0 0 0 0 $gpxtrackposter.track.Track$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $gpxtrackposter.track.Track$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,gpxtrackposter.track.Track]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,gpxtrackposter.track.Track]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.str,None,None]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0
from typing import Optional , Any , List [EOL] import typing [EOL] import gpxtrackposter [EOL] import pint [EOL] import gpxpy [EOL] import s2sphere [EOL] import datetime [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import datetime [EOL] import json [EOL] import os [EOL] import typing [EOL] [EOL] import gpxpy [comment] [EOL] import pint [comment] [EOL] import s2sphere [comment] [EOL] [EOL] from gpxtrackposter . exceptions import TrackLoadError [EOL] from gpxtrackposter . timezone_adjuster import TimezoneAdjuster [EOL] from gpxtrackposter . units import Units [EOL] [EOL] [EOL] class Track : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . file_names = [ ] [EOL] self . polylines = [ ] [EOL] self . start_time = None [EOL] self . end_time = None [EOL] [comment] [EOL] [comment] [EOL] self . _length_meters = [number] [EOL] self . special = False [EOL] [EOL] def load_gpx ( self , file_name , timezone_adjuster ) : [EOL] [docstring] [EOL] try : [EOL] self . file_names = [ os . path . basename ( file_name ) ] [EOL] [comment] [EOL] [comment] [EOL] if os . path . getsize ( file_name ) == [number] : [EOL] raise TrackLoadError ( [string] ) [EOL] with open ( file_name , [string] ) as file : [EOL] self . _load_gpx_data ( gpxpy . parse ( file ) , timezone_adjuster ) [EOL] except TrackLoadError as e : [EOL] raise e [EOL] except gpxpy . gpx . GPXXMLSyntaxException as e : [EOL] raise TrackLoadError ( [string] ) from e [EOL] except PermissionError as e : [EOL] raise TrackLoadError ( [string] ) from e [EOL] except Exception as e : [EOL] raise TrackLoadError ( [string] ) from e [EOL] [EOL] def length_meters ( self ) : [EOL] return self . _length_meters [EOL] [EOL] def length ( self ) : [EOL] return self . _length_meters * Units ( ) . meter [EOL] [EOL] def bbox ( self ) : [EOL] [docstring] [EOL] bbox = s2sphere . LatLngRect ( ) [EOL] for line in self . polylines : [EOL] for latlng in line : [EOL] bbox = bbox . union ( s2sphere . LatLngRect . from_point ( latlng . normalized ( ) ) ) [EOL] return bbox [EOL] [EOL] def _load_gpx_data ( self , gpx , timezone_adjuster ) : [EOL] self . start_time , self . end_time = gpx . get_time_bounds ( ) [EOL] if self . start_time is None : [EOL] raise TrackLoadError ( [string] ) [EOL] if self . end_time is None : [EOL] raise TrackLoadError ( [string] ) [EOL] if timezone_adjuster : [EOL] lat , _ , lng , _ = list ( gpx . get_bounds ( ) ) [EOL] latlng = s2sphere . LatLng . from_degrees ( lat , lng ) [EOL] self . start_time = timezone_adjuster . adjust ( self . start_time , latlng ) [EOL] self . end_time = timezone_adjuster . adjust ( self . end_time , latlng ) [EOL] self . _length_meters = gpx . length_2d ( ) [EOL] if self . _length_meters <= [number] : [EOL] raise TrackLoadError ( [string] ) [EOL] gpx . simplify ( ) [EOL] for t in gpx . tracks : [EOL] for s in t . segments : [EOL] line = [ s2sphere . LatLng . from_degrees ( p . latitude , p . longitude ) for p in s . points ] [EOL] self . polylines . append ( line ) [EOL] [EOL] def append ( self , other ) : [EOL] [docstring] [EOL] self . end_time = other . end_time [EOL] self . polylines . extend ( other . polylines ) [EOL] self . _length_meters += other . length_meters ( ) [EOL] self . file_names . extend ( other . file_names ) [EOL] self . special = self . special or other . special [EOL] [EOL] def load_cache ( self , cache_file_name ) : [EOL] [docstring] [EOL] try : [EOL] with open ( cache_file_name ) as data_file : [EOL] data = json . load ( data_file ) [EOL] self . start_time = datetime . datetime . strptime ( data [ [string] ] , [string] ) [EOL] self . end_time = datetime . datetime . strptime ( data [ [string] ] , [string] ) [EOL] self . _length_meters = float ( data [ [string] ] ) [EOL] self . polylines = [ ] [EOL] for data_line in data [ [string] ] : [EOL] self . polylines . append ( [ s2sphere . LatLng . from_degrees ( float ( d [ [string] ] ) , float ( d [ [string] ] ) ) for d in data_line ] ) [EOL] except Exception as e : [EOL] raise TrackLoadError ( [string] ) from e [EOL] [EOL] def store_cache ( self , cache_file_name ) : [EOL] [docstring] [EOL] dir_name = os . path . dirname ( cache_file_name ) [EOL] if not os . path . isdir ( dir_name ) : [EOL] os . makedirs ( dir_name ) [EOL] with open ( cache_file_name , [string] ) as json_file : [EOL] lines_data = [ ] [EOL] for line in self . polylines : [EOL] lines_data . append ( [ { [string] : latlng . lat ( ) . degrees , [string] : latlng . lng ( ) . degrees } for latlng in line ] ) [EOL] assert self . start_time is not None [EOL] assert self . end_time is not None [EOL] json . dump ( { [string] : self . start_time . strftime ( [string] ) , [string] : self . end_time . strftime ( [string] ) , [string] : self . _length_meters , [string] : lines_data , } , json_file , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[typing.List[s2sphere.LatLng]]$ 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[gpxtrackposter.timezone_adjuster.TimezoneAdjuster]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[gpxtrackposter.timezone_adjuster.TimezoneAdjuster]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $pint.quantity.Quantity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $s2sphere.LatLngRect$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $gpxpy.gpx.GPX$ 0 $typing.Optional[gpxtrackposter.timezone_adjuster.TimezoneAdjuster]$ 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 $typing.Optional[datetime.datetime]$ 0 $gpxpy.gpx.GPX$ 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[gpxtrackposter.timezone_adjuster.TimezoneAdjuster]$ 0 0 0 0 0 0 0 0 0 0 0 0 $gpxpy.gpx.GPX$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 $typing.Optional[gpxtrackposter.timezone_adjuster.TimezoneAdjuster]$ 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 $typing.Any$ 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 $typing.Optional[gpxtrackposter.timezone_adjuster.TimezoneAdjuster]$ 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 $gpxpy.gpx.GPX$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $gpxpy.gpx.GPX$ 0 0 0 0 0 0 0 0 $gpxpy.gpx.GPX$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 $"Track"$ 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 $"Track"$ 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 $"Track"$ 0 0 0 0 0 0 0 0 $"Track"$ 0 0 0 0 0 0 0 0 0 0 0 $"Track"$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $"Track"$ 0 $builtins.bool$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0
	0
import svgwrite [EOL] import argparse [EOL] import pint [EOL] import gpxtrackposter [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import argparse [EOL] [EOL] import pint [comment] [EOL] import svgwrite [comment] [EOL] [EOL] from gpxtrackposter . poster import Poster [EOL] from gpxtrackposter . quantity_range import QuantityRange [EOL] from gpxtrackposter . xy import XY [EOL] from gpxtrackposter import utils [EOL] [EOL] [EOL] class TracksDrawer : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , the_poster ) : [EOL] self . poster = the_poster [EOL] [EOL] def create_args ( self , args_parser ) : [EOL] pass [EOL] [EOL] def fetch_args ( self , args ) : [EOL] pass [EOL] [EOL] def draw ( self , dr , size , offset ) : [EOL] pass [EOL] [EOL] def color ( self , length_range , length , is_special = False ) : [EOL] color1 = self . poster . colors [ [string] ] if is_special else self . poster . colors [ [string] ] [EOL] color2 = self . poster . colors [ [string] ] if is_special else self . poster . colors [ [string] ] [EOL] return utils . interpolate_color ( color1 , color2 , length_range . relative_position ( length ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gpxtrackposter.poster.Poster$ 0 0 0 0 0 $gpxtrackposter.poster.Poster$ 0 $gpxtrackposter.poster.Poster$ 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $None$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $None$ 0 0 0 $svgwrite.Drawing$ 0 $gpxtrackposter.xy.XY$ 0 $gpxtrackposter.xy.XY$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $gpxtrackposter.quantity_range.QuantityRange$ 0 $pint.quantity.Quantity$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $gpxtrackposter.quantity_range.QuantityRange$ 0 0 0 $pint.quantity.Quantity$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class PosterError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class TrackLoadError ( PosterError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ParameterError ( PosterError ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Any , List [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import re [EOL] import sys [EOL] [EOL] THIS_YEAR = str ( datetime . datetime . now ( ) . year ) [EOL] re_year = re . compile ( [string] ) [EOL] re_year_range = re . compile ( [string] ) [EOL] [EOL] [EOL] def bump_year ( file_name ) : [EOL] lines = [ ] [EOL] with open ( file_name , [string] ) as f : [EOL] for line in f . readlines ( ) : [EOL] m = re_year . search ( line ) [EOL] if m and ( m . group ( [number] ) != THIS_YEAR ) : [EOL] start , end = m . span ( [number] ) [EOL] lines . append ( f"{ line [ : end ] } [string] { THIS_YEAR }{ line [ end : ] }" ) [EOL] continue [EOL] [EOL] m = re_year_range . search ( line ) [EOL] if m and ( m . group ( [number] ) != THIS_YEAR ) : [EOL] start , end = m . span ( [number] ) [EOL] lines . append ( f"{ line [ : start ] }{ THIS_YEAR }{ line [ end : ] }" ) [EOL] continue [EOL] [EOL] lines . append ( line ) [EOL] [EOL] with open ( file_name , [string] ) as f : [EOL] f . writelines ( lines ) [EOL] [EOL] [EOL] for arg in sys . argv : [EOL] bump_year ( arg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import sys [EOL] [EOL] usage = sys . stdin . read ( ) [EOL] if not usage . startswith ( [string] ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] readme_md_file_name = sys . argv [ [number] ] [EOL] if not readme_md_file_name . endswith ( [string] ) : [EOL] raise RuntimeError ( f" [string] { readme_md_file_name }" ) [EOL] [EOL] [comment] [EOL] with open ( readme_md_file_name , [string] ) as f : [EOL] lines = f . readlines ( ) [EOL] [EOL] with open ( readme_md_file_name , [string] ) as f : [EOL] STATE = [number] [EOL] for line in lines : [EOL] if STATE == [number] : [EOL] if line . startswith ( [string] ) : [EOL] f . write ( usage ) [EOL] STATE = [number] [EOL] else : [EOL] f . write ( line ) [EOL] elif STATE == [number] : [EOL] if line . startswith ( [string] ) : [EOL] f . write ( line ) [EOL] STATE = [number] [EOL] else : [EOL] f . write ( line ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import re [EOL] import sys [EOL] [EOL] [EOL] def has_valid_copyright ( file_name ) : [EOL] re_copyright = re . compile ( rf"{ datetime . datetime . now ( ) . year } [string] " ) [EOL] re_copyright_bad_year = re . compile ( [string] ) [EOL] [EOL] ok = True [EOL] empty = True [EOL] copyright_found = False [EOL] copyright_bad_year_found = False [EOL] [EOL] with open ( file_name , [string] ) as f : [EOL] for line in f . readlines ( ) : [EOL] empty = False [EOL] if re_copyright . search ( line ) : [EOL] copyright_found = True [EOL] break [EOL] if re_copyright_bad_year . search ( line ) : [EOL] copyright_bad_year_found = True [EOL] break [EOL] [EOL] if not empty : [EOL] if copyright_bad_year_found : [EOL] print ( f"{ file_name } [string] " ) [EOL] ok = False [EOL] elif not copyright_found : [EOL] print ( f"{ file_name } [string] " ) [EOL] ok = False [EOL] [EOL] return ok [EOL] [EOL] [EOL] if not all ( [ has_valid_copyright ( file_name ) for file_name in sys . argv ] ) : [EOL] sys . exit ( [number] ) [EOL] [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import gpxtrackposter [EOL] import datetime [EOL] import dateutil . parser [EOL] import s2sphere [comment] [EOL] [EOL] from gpxtrackposter . timezone_adjuster import TimezoneAdjuster [EOL] [EOL] [EOL] def test_adjust ( ) : [EOL] tza = TimezoneAdjuster ( ) [EOL] [EOL] time = dateutil . parser . parse ( [string] ) [EOL] [EOL] freiburg = s2sphere . LatLng . from_degrees ( [number] , [number] ) [EOL] time_freiburg = tza . adjust ( time , freiburg ) [EOL] assert time_freiburg . hour == [number] [EOL] [EOL] newyork = s2sphere . LatLng . from_degrees ( [number] , - [number] ) [EOL] time_newyork = tza . adjust ( time , newyork ) [EOL] assert time_newyork . hour == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0