[comment] [EOL] from typing import Dict [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] import table [EOL] [docstring] [EOL] import logging [EOL] from math import cos , radians , sin [EOL] [EOL] from table import Terrain [EOL] [EOL] __author__ = [string] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] DIRECTIONS_DEGREES = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] DEGREES_DIRECTION = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } [EOL] [EOL] [EOL] class NavigationSystem : [EOL] [docstring] [EOL] def __init__ ( self , x = None , y = None , direction = None , terrain = None ) : [EOL] self . x = x [EOL] self . y = y [EOL] self . direction = direction [EOL] self . degree = DIRECTIONS_DEGREES . get ( direction , None ) [EOL] self . terrain = terrain [EOL] [EOL] def set_terrain ( self , terrain ) : [EOL] [docstring] [EOL] self . terrain = terrain [EOL] [EOL] def update ( self , x , y , direction = None , terrain = None ) : [EOL] [docstring] [EOL] [EOL] self . terrain = terrain if terrain is not None else self . terrain [EOL] if direction in DIRECTIONS_DEGREES . keys ( ) : [EOL] self . x = x [EOL] self . y = y [EOL] self . direction = direction if direction is not None \ [EOL] else self . direction [EOL] self . degree = DIRECTIONS_DEGREES . get ( direction , None ) [EOL] [EOL] def move ( self ) : [EOL] [docstring] [EOL] try : [EOL] new_x = self . x + int ( cos ( radians ( self . degree ) ) ) [EOL] new_y = self . y + int ( sin ( radians ( self . degree ) ) ) [EOL] if self . terrain . coordinates_within_limits ( new_x , new_y ) : [EOL] self . update ( new_x , new_y , self . direction ) [EOL] return ( self . x , self . y ) [EOL] except TypeError as te : [EOL] logger . debug ( [string] . format ( te ) ) [EOL] [EOL] def left ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . degree += [number] [EOL] self . degree = self . degree % [number] [EOL] self . direction = DEGREES_DIRECTION . get ( self . degree ) [EOL] except TypeError as te : [EOL] logger . debug ( [string] . format ( te ) ) [EOL] pass [EOL] [EOL] def right ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . degree -= [number] [EOL] self . degree = self . degree % [number] [EOL] self . direction = DEGREES_DIRECTION . get ( self . degree ) [EOL] except TypeError as te : [EOL] logger . debug ( [string] . format ( te ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return [string] . format ( x = self . x , y = self . y , direction = self . direction ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 $table.Terrain$ 0 0 0 0 0 0 0 0 0 0 $table.Terrain$ 0 $table.Terrain$ 0 $table.Terrain$ 0 0 0 0 0 0 $table.Terrain$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import robot [EOL] import run [EOL] [docstring] [EOL] import logging . config [EOL] from cmd import Cmd [EOL] [EOL] from robot import Robot [EOL] from table import Table [EOL] [EOL] __author__ = [string] [EOL] logging . config . fileConfig ( [string] , disable_existing_loggers = False ) [EOL] [EOL] [EOL] class RobotPrompt ( Cmd ) : [EOL] [docstring] [EOL] intro = [string] [EOL] prompt = [string] [EOL] robot = Robot ( Table ( [number] , [number] ) ) [EOL] [EOL] def do_place ( self , place_cmd ) : [EOL] [docstring] [EOL] x_coord , y_coord , direction = place_cmd . split ( [string] ) [EOL] x_coord = int ( x_coord ) [EOL] y_coord = int ( y_coord ) [EOL] direction = direction . upper ( ) [EOL] self . robot . place ( x_coord , y_coord , direction ) [EOL] print ( [string] . format ( direction ) ) [EOL] [EOL] def do_move ( self , line ) : [EOL] [docstring] [EOL] print ( line ) [EOL] self . robot . navigation_system . move ( ) [EOL] [EOL] def do_left ( self , _line ) : [EOL] [docstring] [EOL] self . robot . navigation_system . left ( ) [EOL] [EOL] def do_right ( self , _line ) : [EOL] [docstring] [EOL] self . robot . navigation_system . right ( ) [EOL] [EOL] def do_report ( self , _line ) : [EOL] [docstring] [EOL] print ( _line ) [EOL] print ( self . robot . report ( ) ) [EOL] [EOL] def precmd ( self , line ) : [EOL] line = line . lower ( ) [EOL] if line == [string] : [EOL] print ( [string] ) [EOL] exit ( [number] ) [EOL] return line [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] PROMPT = RobotPrompt ( ) [EOL] PROMPT . cmdloop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $RobotPrompt.robot.Robot$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $run.RobotPrompt$ 0 0 0 0 0 $run.RobotPrompt$ 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import builtins [EOL] import logging [EOL] import table [EOL] import navigation [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from navigation import NavigationSystem [EOL] from table import Terrain [EOL] [EOL] __author__ = [string] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Robot : [EOL] [docstring] [EOL] valid_directions = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , terrain = None ) : [EOL] logger . debug ( [string] . format ( terrain ) ) [EOL] self . terrain = terrain [EOL] self . ready = False [EOL] self . navigation_system = NavigationSystem ( ) [EOL] [EOL] def set_terrain ( self , terrain ) : [EOL] [docstring] [EOL] self . terrain = terrain [EOL] [EOL] def place ( self , x_coord , y_coord , direction ) : [EOL] [docstring] [EOL] if self . terrain is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if ( self . terrain . coordinates_within_limits ( x_coord , y_coord ) and direction in self . valid_directions ) : [EOL] logger . debug ( [string] ) [EOL] self . ready = True [EOL] self . navigation_system . update ( x_coord , y_coord , direction , self . terrain ) [EOL] else : [EOL] logger . error ( [string] ) [EOL] [EOL] def position ( self ) : [EOL] [docstring] [EOL] return ( self . navigation_system . x , self . navigation_system . y , self . navigation_system . direction ) [EOL] [EOL] def report ( self ) : [EOL] [docstring] [EOL] return str ( self ) [EOL] [EOL] def __str__ ( self ) : [EOL] status = str ( self . navigation_system ) [EOL] return status [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $table.Terrain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $table.Terrain$ 0 0 0 0 0 $table.Terrain$ 0 $table.Terrain$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $navigation.NavigationSystem$ 0 0 0 0 0 0 0 0 0 0 0 $table.Terrain$ 0 0 0 0 0 0 0 $table.Terrain$ 0 $table.Terrain$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[comment] [EOL] import logging [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] [EOL] __author__ = [string] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Terrain : [EOL] [docstring] [EOL] def __init__ ( self , x_pos , y_pos ) : [EOL] self . x_pos = x_pos [EOL] self . y_pos = y_pos [EOL] [EOL] def coordinates_within_limits ( self , _x_pos , _y_pos ) : [EOL] [docstring] [EOL] True [EOL] [EOL] [EOL] class Table ( Terrain ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , length , width ) : [EOL] if ( length < [number] or width < [number] ) : [EOL] raise ValueError ( [string] ) [EOL] logger . debug ( [string] . format ( length , width ) ) [EOL] self . length = length [EOL] self . width = width [EOL] [EOL] def coordinates_within_limits ( self , x_pos , y_pos ) : [EOL] [docstring] [EOL] logger . debug ( [string] . format ( self . length , self . width ) ) [EOL] logger . debug ( [string] . format ( x_pos , y_pos ) ) [EOL] return ( [number] <= x_pos <= self . width ) and ( [number] <= y_pos <= self . length ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( width = self . width , length = self . length ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import table [EOL] [docstring] [EOL] import unittest [EOL] [EOL] import ddt [EOL] [EOL] from table import Table [EOL] [EOL] __author__ = [string] [EOL] [EOL] [EOL] @ ddt . ddt class TableTest ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . default_table = Table ( [number] , [number] ) [EOL] [EOL] @ ddt . data ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) @ ddt . unpack def test_if_table_created_properly ( self , length , width ) : [EOL] [EOL] table = Table ( length , width ) [EOL] self . assertEqual ( table . width , width ) [EOL] self . assertEqual ( table . length , length ) [EOL] [EOL] @ ddt . data ( ( - [number] , [number] ) , ( [number] , - [number] ) , ( - [number] , - [number] ) ) @ ddt . unpack def test_if_table_throws_valueerror ( self , length , width ) : [EOL] with self . assertRaises ( ValueError ) : [EOL] Table ( length , width ) [EOL] [EOL] @ ddt . data ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) @ ddt . unpack def test_if_given_cordinates_are_on_table ( self , x_pos , y_pos ) : [EOL] self . assertTrue ( self . default_table . coordinates_within_limits ( x_pos , y_pos ) ) [EOL] [EOL] @ ddt . data ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , [number] ) ) @ ddt . unpack def test_if_given_cordinates_are_not_on_table ( self , x_pos , y_pos ) : [EOL] self . assertFalse ( self . default_table . coordinates_within_limits ( x_pos , y_pos ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import logging [EOL] import robot [EOL] import table [EOL] [docstring] [EOL] import logging [EOL] import unittest [EOL] [EOL] from ddt import data , ddt , unpack [EOL] [EOL] from robot import Robot [EOL] from table import Table [EOL] [EOL] __author__ = [string] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ ddt class RobotTest ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . terrain = Table ( [number] , [number] ) [EOL] self . robot = Robot ( self . terrain ) [EOL] [EOL] def test_robot_created_properly ( self ) : [EOL] self . assertFalse ( self . robot . ready ) [EOL] self . assertEqual ( self . robot . position ( ) , ( None , None , None ) ) [EOL] self . assertEqual ( self . robot . terrain , self . terrain ) [EOL] [EOL] def test_robot_not_on_table ( self ) : [EOL] robot_in_air = Robot ( ) [EOL] self . assertFalse ( robot_in_air . ready ) [EOL] self . robot . navigation_system . move ( ) [EOL] self . robot . navigation_system . left ( ) [EOL] self . robot . navigation_system . right ( ) [EOL] self . assertEqual ( self . robot . position ( ) , ( None , None , None ) ) [EOL] [EOL] @ data ( ( [number] , [number] , [string] ) , ( [number] , [number] , [string] ) , ( [number] , [number] , [string] ) ) @ unpack def test_placing_robot_correctly ( self , x_coord , y_coord , direction ) : [EOL] self . robot . place ( x_coord , y_coord , direction ) [EOL] self . assertEqual ( self . robot . ready , True ) [EOL] self . assertEqual ( self . robot . position ( ) , ( x_coord , y_coord , direction ) ) [EOL] logger . debug ( self . robot . report ( ) ) [EOL] [EOL] def test_discard_until_placing_robot ( self ) : [EOL] new_robot = Robot ( self . terrain ) [EOL] new_robot . navigation_system . move ( ) [EOL] new_robot . navigation_system . move ( ) [EOL] new_robot . navigation_system . left ( ) [EOL] self . assertEqual ( self . robot . position ( ) , ( None , None , None ) ) [EOL] [EOL] @ data ( ( [number] , [number] , [string] ) , ( [number] , [number] , [string] ) , ( [number] , [number] , [string] ) ) @ unpack def test_placing_robot_trying_to_fall_down ( self , x_coord , y_coord , direction ) : [EOL] self . robot . place ( x_coord , y_coord , direction ) [EOL] self . assertEqual ( self . robot . ready , True ) [EOL] [comment] [EOL] for x in range ( [number] , [number] ) : [EOL] self . robot . navigation_system . move ( ) [EOL] ( x , y , _d ) = self . robot . position ( ) [EOL] self . assertTrue ( self . terrain . coordinates_within_limits ( x , y ) ) [EOL] [EOL] @ data ( ( [number] , [number] , [string] ) , ( - [number] , [number] , [string] ) , ( [number] , - [number] , [string] ) , ( [number] , [number] , [string] ) ) @ unpack def test_placing_robot_incorrectly ( self , x , y , direction ) : [EOL] self . robot . place ( x , y , direction ) [EOL] self . assertEqual ( self . robot . position ( ) , ( None , None , None ) ) [EOL] [EOL] @ data ( ( [number] , [string] , [string] , [string] ) , ( [number] , [string] , [string] , [string] ) , ( [number] , [string] , [string] , [string] ) ) @ unpack def test_rotate_robot ( self , times , start_d , end_d_l , end_d_r ) : [EOL] self . robot . place ( [number] , [number] , start_d ) [EOL] for m in range ( [number] , times ) : [EOL] self . robot . navigation_system . left ( ) [EOL] self . assertEqual ( self . robot . position ( ) [ [number] ] , end_d_l ) [EOL] [comment] [EOL] self . robot . place ( [number] , [number] , start_d ) [EOL] for m in range ( [number] , times ) : [EOL] self . robot . navigation_system . right ( ) [EOL] self . assertEqual ( self . robot . position ( ) [ [number] ] , end_d_r ) [EOL] [EOL] @ data ( ( [number] , [number] , [string] ) , ( [number] , [number] , [string] ) , ( [number] , [number] , [string] ) , ( [number] , [number] , [string] ) ) @ unpack def test_report_robot_position ( self , x , y , d ) : [EOL] self . robot . place ( x , y , d ) [EOL] exp = [string] . format ( x = x , y = y , direction = d ) [EOL] self . assertEqual ( self . robot . report ( ) , exp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0 0 0 0 $robot.Robot$ 0 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $robot.Robot$ 0 0 0 0 0 0 0 0 0 $robot.Robot$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $robot.Robot$ 0 0 0 0 0 0 0 0 $robot.Robot$ 0 0 0 0 0 0 0 $robot.Robot$ 0 0 0 0 0 0 0 $robot.Robot$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0