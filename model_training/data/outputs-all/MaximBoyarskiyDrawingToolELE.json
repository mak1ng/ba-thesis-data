from typing import TextIO , Any , Optional [EOL] import drawing [EOL] import builtins [EOL] import typing [EOL] import sys [EOL] from enum import Enum [EOL] from typing import ( NamedTuple , Optional , TextIO , ) [EOL] [EOL] [EOL] DEFAULT_POINT_VALUE = [string] [EOL] [EOL] [EOL] class Coord ( NamedTuple ) : [EOL] x = ... [EOL] y = ... [EOL] [EOL] [EOL] class Command ( Enum ) : [EOL] create_canvas = [string] [EOL] create_line = [string] [EOL] create_rectangle = [string] [EOL] bucket_fill = [string] [EOL] [EOL] [EOL] class Canvas : [EOL] def __init__ ( self , coord ) : [EOL] self . size = coord [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . square = [ [ DEFAULT_POINT_VALUE ] * coord . y for _ in range ( coord . x ) ] [EOL] [EOL] def get_point ( self , coord ) : [EOL] return self . square [ coord . x - [number] ] [ coord . y - [number] ] [EOL] [EOL] def set_point ( self , coord , value ) : [EOL] self . square [ coord . x - [number] ] [ coord . y - [number] ] = value [EOL] [EOL] [EOL] class CanvasCommandProcessor : [EOL] canvas = None [EOL] [EOL] def process ( self , command_raw ) : [EOL] command_name , * args = command_raw . strip ( ) . split ( [string] ) [EOL] command = Command ( command_name ) [EOL] if command == Command . create_canvas : [EOL] x , y = map ( int , args ) [EOL] self . create_canvas ( Coord ( x , y ) ) [EOL] elif command == Command . create_line : [EOL] x1 , y1 , x2 , y2 = map ( int , args ) [EOL] assert x1 == x2 or y1 == y2 [EOL] self . create_line ( Coord ( x1 , y1 ) , Coord ( x2 , y2 ) ) [EOL] elif command == Command . create_rectangle : [EOL] x1 , y1 , x2 , y2 = map ( int , args ) [EOL] self . create_rectangle ( Coord ( x1 , y1 ) , Coord ( x2 , y2 ) ) [EOL] elif command == Command . bucket_fill : [EOL] x_ , y_ , value = args [EOL] x , y = map ( int , ( x_ , y_ , ) ) [EOL] self . bucket_fill ( Coord ( x , y ) , value ) [EOL] else : [EOL] raise ValueError ( [string] , command ) [EOL] [EOL] assert self . canvas is not None [EOL] return self . canvas [EOL] [EOL] def create_canvas ( self , coord ) : [EOL] self . canvas = Canvas ( coord ) [EOL] [EOL] def create_line ( self , start , end ) : [EOL] assert self . canvas is not None [EOL] [EOL] if start . x == end . x : [EOL] y_start , y_end = sorted ( ( start . y , end . y , ) ) [EOL] for y in range ( y_start , y_end + [number] ) : [EOL] self . canvas . set_point ( Coord ( start . x , y ) , [string] ) [EOL] else : [EOL] x_start , x_end = sorted ( ( start . x , end . x , ) ) [EOL] for x in range ( x_start , x_end + [number] ) : [EOL] self . canvas . set_point ( Coord ( x , start . y ) , [string] ) [EOL] [EOL] def create_rectangle ( self , vertex1 , vertex2 ) : [EOL] assert self . canvas is not None [EOL] [EOL] for start , end in ( ( vertex1 , Coord ( vertex2 . x , vertex1 . y ) , ) , ( Coord ( vertex2 . x , vertex1 . y ) , vertex2 , ) , ( vertex2 , Coord ( vertex1 . x , vertex2 . y ) , ) , ( Coord ( vertex1 . x , vertex2 . y ) , vertex1 , ) , ) : [EOL] self . create_line ( start , end ) [EOL] [EOL] def bucket_fill ( self , coord , new_value , old_value = None ) : [EOL] assert self . canvas is not None [EOL] [EOL] [comment] [EOL] [comment] [EOL] if old_value is None : [EOL] old_value = self . canvas . get_point ( coord ) [EOL] self . canvas . set_point ( coord , new_value ) [EOL] else : [EOL] if self . canvas . get_point ( coord ) != old_value : [EOL] return [EOL] [EOL] self . canvas . set_point ( coord , new_value ) [EOL] [EOL] for neighbor_coord in ( coord . _replace ( x = coord . x - [number] ) , coord . _replace ( x = coord . x + [number] ) , coord . _replace ( y = coord . y - [number] ) , coord . _replace ( y = coord . y + [number] ) , ) : [EOL] if ( neighbor_coord . x in range ( [number] , self . canvas . size . x + [number] ) ) and ( neighbor_coord . y in range ( [number] , self . canvas . size . y + [number] ) ) : [EOL] self . bucket_fill ( neighbor_coord , new_value , old_value ) [EOL] [EOL] [EOL] def canvas_to_out ( canvas , out ) : [EOL] size = canvas . size [EOL] print ( [string] * ( size . x + [number] ) , file = out , ) [EOL] [EOL] [comment] [EOL] for y in range ( [number] , size . y + [number] ) : [EOL] line = [string] [EOL] line += [string] [EOL] for x in range ( [number] , size . x + [number] ) : [EOL] line += canvas . get_point ( Coord ( x , y ) ) [EOL] line += [string] [EOL] print ( line , file = out ) [EOL] [EOL] print ( [string] * ( size . x + [number] ) , file = out ) [EOL] [EOL] [EOL] def main ( ) : [EOL] processor = CanvasCommandProcessor ( ) [EOL] try : [EOL] while True : [EOL] canvas = processor . process ( sys . stdin . readline ( ) ) [EOL] canvas_to_out ( canvas , sys . stdout ) [EOL] except KeyboardInterrupt : [EOL] pass [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Coord$ 0 0 0 0 0 $drawing.Coord$ 0 $Coord$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $Coord$ 0 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Coord$ 0 $builtins.str$ 0 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[Canvas]$ 0 0 0 0 0 $Canvas$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $drawing.Command$ 0 0 0 0 0 0 0 $drawing.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $drawing.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $drawing.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $drawing.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $drawing.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Coord$ 0 0 0 0 0 $typing.Optional[drawing.Canvas]$ 0 0 0 $Coord$ 0 0 0 0 $None$ 0 0 0 $Coord$ 0 $Coord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Coord$ 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 0 0 0 $Coord$ 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Coord$ 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Coord$ 0 $Coord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Coord$ 0 0 0 $Coord$ 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 0 $Coord$ 0 0 0 $Coord$ 0 0 0 0 $Coord$ 0 0 0 0 $Coord$ 0 0 0 $Coord$ 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 0 $Coord$ 0 0 0 $Coord$ 0 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Coord$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 $Coord$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $Coord$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $Coord$ 0 $builtins.str$ 0 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 $Coord$ 0 0 0 0 0 $Coord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import io [EOL] import pathlib [EOL] import typing [EOL] from io import StringIO [EOL] from pathlib import Path [EOL] [EOL] from pytest import fixture [EOL] [EOL] from drawing import ( DEFAULT_POINT_VALUE , CanvasCommandProcessor , Coord , canvas_to_out , ) [EOL] [EOL] [EOL] @ fixture ( ) def processor ( ) : [EOL] yield CanvasCommandProcessor ( ) [EOL] [EOL] [EOL] def test_crate_canvas ( processor ) : [EOL] canvas = processor . process ( [string] ) [EOL] [EOL] assert canvas . size == Coord ( [number] , [number] ) [EOL] assert canvas . square == [ [ DEFAULT_POINT_VALUE , DEFAULT_POINT_VALUE ] , [ DEFAULT_POINT_VALUE , DEFAULT_POINT_VALUE ] , [ DEFAULT_POINT_VALUE , DEFAULT_POINT_VALUE ] , ] [EOL] [EOL] [EOL] def test_integration ( processor ) : [EOL] out = StringIO ( ) [EOL] current_dir = Path ( __file__ ) . parent [EOL] [EOL] with open ( current_dir / [string] , [string] ) as f : [EOL] for command in f : [EOL] canvas = processor . process ( command . rstrip ( [string] ) ) [EOL] canvas_to_out ( canvas , out ) [EOL] [EOL] with open ( current_dir / [string] , [string] ) as f : [EOL] assert out . getvalue ( ) == f . read ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0