from typing import Any [EOL] import logging [EOL] import typing [EOL] from logging import getLogger [EOL] import pickle [EOL] [EOL] import logging_config [EOL] from KB2E import KnowledgeGraph [EOL] from KB2E . models import TransE [EOL] [EOL] logger = getLogger ( __name__ ) [EOL] [EOL] if __name__ == [string] : [EOL] model_path = [string] [EOL] [comment] [EOL] with open ( model_path , [string] ) as f : [EOL] trans_e = pickle . load ( f ) [EOL] [comment] [EOL] [comment] [EOL] while True : [EOL] [comment] [EOL] [comment] [EOL] print ( [string] , end = [string] ) [EOL] subj = input ( ) . strip ( ) [EOL] print ( [string] , end = [string] ) [EOL] pred = input ( ) . strip ( ) [EOL] ranking = trans_e . predict_spv ( subj = subj , pred = pred , limit = [number] ) [comment] [EOL] print ( [string] . format ( subj , pred ) ) [EOL] for ( obj , diff ) in ranking : [EOL] print ( [string] . format ( diff , obj ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import KB2E [EOL] import logging [EOL] import io [EOL] from logging import getLogger [EOL] import pickle [EOL] [EOL] import logging_config [EOL] from KB2E import KnowledgeGraph [EOL] from KB2E . models import TransE [EOL] [EOL] logger = getLogger ( __name__ ) [EOL] [EOL] if __name__ == [string] : [EOL] kb = KnowledgeGraph ( ) [EOL] [comment] [EOL] model_path = [string] [EOL] [comment] [EOL] kb_file = open ( [string] ) [EOL] logger . info ( [string] . format ( kb_file . name ) ) [EOL] kb . load ( kb_file , format = [string] ) [EOL] [comment] [EOL] [comment] [EOL] trans_e = TransE ( ganma = [number] , k = [number] , lmd = [number] ) [EOL] trans_e . fit ( kb ) [comment] [EOL] [EOL] with open ( model_path , [string] ) as f : [EOL] pickle . dump ( trans_e , f )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $KB2E.models.trans_e.TransE$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $KB2E.models.trans_e.TransE$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $KB2E.models.trans_e.TransE$ 0 0 0
class Model : [EOL] pass	0 0 0 0 0
from . util . knowledge_graph import KnowledgeGraph [EOL] from . model import Model	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List [EOL] import logging [EOL] import builtins [EOL] import _csv [EOL] import typing [EOL] import csv [EOL] from logging import getLogger [EOL] from typing import Dict , List [EOL] [EOL] from bidict import bidict [EOL] [EOL] logger = getLogger ( __name__ ) [EOL] Triple = List [ int ] [EOL] [EOL] [EOL] class KnowledgeGraph ( ) : [EOL] def __init__ ( self ) : [EOL] self . _subject_dict = bidict ( ) [EOL] self . _predicate_dict = bidict ( ) [EOL] self . _object_dict = bidict ( ) [EOL] self . _entity_dict = bidict ( ) [EOL] self . _relation_dict = self . _predicate_dict [EOL] self . _id_triples = list ( ) [EOL] [EOL] def load ( self , kb_file , * , format = [string] , encode = [string] ) : [EOL] [docstring] [EOL] if format == [string] : [EOL] kb = csv . reader ( kb_file , delimiter = [string] ) [EOL] for triple in kb : [EOL] [ subj , pred , obj ] = triple [EOL] [EOL] def get_resource_id ( resource , bidict ) : [EOL] if resource not in bidict . inverse : [EOL] id = len ( bidict ) [EOL] bidict [ id ] = resource [EOL] return id [EOL] else : [EOL] return bidict . inverse [ resource ] [EOL] [comment] [EOL] [comment] [EOL] subj_id = get_resource_id ( subj , self . _entity_dict ) [EOL] obj_id = get_resource_id ( obj , self . _entity_dict ) [EOL] pred_id = get_resource_id ( pred , self . _predicate_dict ) [EOL] self . _id_triples . append ( [ subj_id , pred_id , obj_id ] ) [EOL] elif format == [string] : [EOL] [comment] [EOL] kb = csv . reader ( kb_file , delimiter = [string] ) [EOL] for triple in kb : [EOL] [ subj , pred , obj , _ ] = triple [EOL] [EOL] def get_resource_id ( resource , bidict ) : [EOL] if resource not in bidict . inverse : [EOL] id = len ( bidict ) [EOL] bidict [ id ] = resource [EOL] return id [EOL] else : [EOL] return bidict . inverse [ resource ] [EOL] [comment] [EOL] [comment] [EOL] subj_id = get_resource_id ( subj , self . _entity_dict ) [EOL] obj_id = get_resource_id ( obj , self . _entity_dict ) [EOL] pred_id = get_resource_id ( pred , self . _predicate_dict ) [EOL] self . _id_triples . append ( [ subj_id , pred_id , obj_id ] ) [EOL] else : [EOL] raise NotImplementedError ( [string] ) [EOL] logger . info ( [string] . format ( len ( self . _entity_dict ) , len ( self . _subject_dict ) , len ( self . _predicate_dict ) , len ( self . _object_dict ) ) ) [EOL] logger . info ( [string] . format ( len ( self . _id_triples ) ) ) [EOL] [EOL] def decode_triple ( self , id_triple ) : [EOL] return ( self . _entity_dict [ id_triple [ [number] ] ] , self . _relation_dict [ id_triple [ [number] ] ] , self . _entity_dict [ id_triple [ [number] ] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Triple]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._reader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._reader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $_csv._reader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._reader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Tuple , Any [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] import KB2E [EOL] from copy import deepcopy [EOL] from logging import getLogger [EOL] from typing import Any , List [EOL] import random [EOL] [EOL] import numpy [EOL] from numpy import sqrt [EOL] from numpy import random as np_random [EOL] from tqdm import tqdm [EOL] [EOL] from KB2E import KnowledgeGraph , Model [EOL] [EOL] logger = getLogger ( __name__ ) [EOL] [EOL] [EOL] class TransE ( Model ) : [EOL] def __init__ ( self , ganma = [number] , k = [number] , lmd = [number] , batch_size = [number] ) : [EOL] [docstring] [EOL] logger . info ( [string] . format ( ganma , k , lmd , batch_size ) ) [EOL] self . _ganma = ganma [EOL] self . _k = k [EOL] self . _lambda = lmd [EOL] self . _batch_size = batch_size [EOL] self . _kb = None [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def fit ( self , kb ) : [EOL] self . _kb = kb [EOL] ganma = self . _ganma [EOL] k = self . _k [EOL] lmd = self . _lambda [EOL] [EOL] def l2_normalize ( row ) : [EOL] l2_norm = numpy . linalg . norm ( row , ord = [number] ) [EOL] return row / l2_norm [EOL] [EOL] [comment] [EOL] relations = numpy . array ( [ np_random . uniform ( low = - [number] / sqrt ( k ) , high = [number] / sqrt ( k ) , size = k ) for _ in kb . _relation_dict ] ) [comment] [EOL] relations = numpy . apply_along_axis ( l2_normalize , axis = [number] , arr = relations ) [comment] [EOL] entities = numpy . array ( [ np_random . uniform ( low = - [number] / sqrt ( k ) , high = [number] / sqrt ( k ) , size = k ) for _ in kb . _entity_dict ] ) [comment] [EOL] [EOL] kb . _id_triples = kb . _id_triples [ : int ( len ( kb . _id_triples ) ) ] [EOL] T = self . _make_triple_pairs ( kb . _id_triples ) [comment] [EOL] self . _T = T [EOL] [EOL] [comment] [EOL] batch_size = int ( len ( kb . _id_triples ) * self . _batch_size ) [comment] [EOL] updated = numpy . finfo ( float ) . max [EOL] logger . debug ( [string] . format ( batch_size , len ( kb . _id_triples ) ) ) [EOL] while True : [EOL] entities = numpy . apply_along_axis ( l2_normalize , axis = [number] , arr = entities ) [comment] [EOL] S_batch = [ i for i in range ( len ( kb . _id_triples ) ) ] [EOL] np_random . shuffle ( S_batch ) [EOL] S_batch = [ S_batch [ i ] for i in range ( batch_size ) ] [EOL] [docstring] [EOL] T_batch = [ T [ i ] for i in S_batch ] [EOL] updates = list ( ) [EOL] for ( triple , corrupted_triple ) in tqdm ( T_batch , desc = [string] . format ( batch_size ) ) : [EOL] [comment] [EOL] [ h , ell , t ] = triple [EOL] [ h_ , _ , t_ ] = corrupted_triple [EOL] update = ganma + self . _l2_distance ( entities [ h ] + relations [ ell ] , entities [ t ] ) - self . _l2_distance ( entities [ h_ ] + relations [ ell ] , entities [ t_ ] ) [EOL] if update > [number] : [EOL] true_triple_update = lmd * ( entities [ h ] + relations [ ell ] - entities [ t ] ) / self . _l2_distance ( entities [ h ] + relations [ ell ] , entities [ t ] ) [EOL] corrupted_triple_update = lmd * ( entities [ h_ ] + relations [ ell ] - entities [ t_ ] ) / self . _l2_distance ( entities [ h_ ] + relations [ ell ] , entities [ t_ ] ) [EOL] [EOL] entities [ h ] = entities [ h ] - true_triple_update [EOL] entities [ t ] = entities [ t ] + true_triple_update [EOL] relations [ ell ] = relations [ ell ] - true_triple_update [EOL] [EOL] entities [ h_ ] = entities [ h_ ] + corrupted_triple_update [EOL] entities [ t_ ] = entities [ t_ ] - corrupted_triple_update [EOL] relations [ ell ] = relations [ ell ] + corrupted_triple_update [EOL] updates . append ( max ( [ [number] , update ] ) ) [comment] [EOL] [EOL] updates = numpy . array ( updates ) [EOL] updates = numpy . sum ( updates ) / len ( updates ) [EOL] logger . debug ( updates ) [comment] [EOL] if updated < updates : [EOL] break [EOL] updated = updates [EOL] self . _entities = entities [EOL] self . _relations = relations [EOL] [EOL] def predict_spv ( self , subj , pred , limit = [number] ) : [EOL] subj_id = self . _kb . _entity_dict . inverse [ subj ] [EOL] pred_id = self . _kb . _relation_dict . inverse [ pred ] [EOL] subj_vec = self . _entities [ subj_id ] [EOL] pred_vec = self . _relations [ pred_id ] [EOL] ranking = list ( ) [EOL] for id , e in enumerate ( self . _entities ) : [EOL] diff = numpy . linalg . norm ( subj_vec + pred_vec - e , ord = [number] ) [EOL] ranking . append ( ( id , diff ) ) [EOL] ranking = sorted ( ranking , key = lambda obj : obj [ [number] ] ) [EOL] ranking = ranking [ : limit ] [EOL] ranking = list ( map ( lambda obj : ( self . _kb . _entity_dict [ obj [ [number] ] ] , obj [ [number] ] ) , ranking ) ) [EOL] return ranking [EOL] [EOL] def _make_triple_pairs ( self , true_triples ) : [EOL] triple_pairs = list ( ) [EOL] all_triples = [ i for i in range ( len ( true_triples ) ) ] [EOL] np_random . shuffle ( all_triples ) [EOL] pivot = int ( len ( true_triples ) / [number] ) [EOL] subj_replaces = true_triples [ [number] : pivot ] [EOL] obj_replaces = true_triples [ pivot : len ( true_triples ) ] [EOL] entities = [ i for i in range ( len ( self . _kb . _entity_dict ) ) ] [EOL] logger . debug ( [string] . format ( len ( entities ) ) ) [EOL] subj_cands = np_random . randint ( [number] , len ( entities ) , len ( subj_replaces ) ) [EOL] obj_cands = np_random . randint ( [number] , len ( entities ) , len ( obj_replaces ) ) [EOL] for triple , candidate in tqdm ( zip ( subj_replaces , subj_cands ) , total = len ( subj_replaces ) , desc = [string] ) : [EOL] [comment] [EOL] [comment] [EOL] while True : [EOL] if candidate != triple [ [number] ] and [ candidate , triple [ [number] ] , triple [ [number] ] ] not in self . _kb . _id_triples : [comment] [EOL] break [EOL] candidate = np_random . randint ( [number] , len ( entities ) ) [EOL] triple_pairs . append ( ( triple , [ candidate , triple [ [number] ] , triple [ [number] ] ] ) ) [EOL] for triple , candidate in tqdm ( zip ( obj_replaces , obj_cands ) , total = len ( obj_replaces ) , desc = [string] ) : [EOL] [comment] [EOL] [comment] [EOL] while True : [EOL] if candidate != triple [ [number] ] and [ triple [ [number] ] , triple [ [number] ] , candidate ] not in self . _kb . _id_triples : [EOL] break [EOL] candidate = np_random . randint ( [number] , len ( entities ) ) [EOL] triple_pairs . append ( ( triple , [ triple [ [number] ] , triple [ [number] ] , candidate ] ) ) [EOL] [comment] [EOL] return triple_pairs [EOL] [EOL] def _l2_distance ( self , target , source ) : [EOL] return numpy . linalg . norm ( target - source , ord = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 $builtins.int$ 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . trans_e import TransE	0 0 0 0 0