from typing import Any , List [EOL] import typing [EOL] import builtins [EOL] import configparser [EOL] import configparser [EOL] import json [EOL] import base64 [EOL] [EOL] import requests [EOL] from bottle import Bottle , run , jinja2_view , jinja2_template , TEMPLATE_PATH , redirect , request , response [EOL] from slackclient import SlackClient [EOL] [EOL] from imeerk . migrations import MigrationInit [EOL] from imeerk . sessions import DbSessions [EOL] from imeerk . users import DbUser [EOL] from imeerk . users import DbUsers [EOL] from imeerk . periodic import ImeerkPeriodic [EOL] [EOL] config = configparser . RawConfigParser ( ) [EOL] config . read ( [string] ) [EOL] [EOL] url = config . get ( [string] , [string] ) [EOL] host = config . get ( [string] , [string] ) [EOL] port = int ( config . get ( [string] , [string] ) ) [EOL] db = config . get ( [string] , [string] ) [EOL] store_dir = config . get ( [string] , [string] ) [EOL] client_id = config . get ( [string] , [string] ) [EOL] client_secret = config . get ( [string] , [string] ) [EOL] scope = [ [string] , [string] , [string] ] [EOL] [EOL] TEMPLATE_PATH [ : ] = [ [string] ] [EOL] app = Bottle ( ) [EOL] [EOL] [EOL] @ app . get ( [string] ) def index ( ) : [EOL] token = request . get_cookie ( [string] , [string] ) [EOL] if token == [string] : [EOL] return jinja2_template ( [string] , slack_auth_url = [string] . format ( client_id , [string] . join ( scope ) , [string] . format ( url ) ) ) [EOL] else : [EOL] return redirect ( [string] ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def slack_login ( ) : [EOL] code = request . query [ [string] ] [EOL] result = requests . get ( [string] . format ( client_id , client_secret , code , [string] . format ( url ) ) ) [EOL] slack_token = result . json ( ) [ [string] ] [EOL] team = result . json ( ) [ [string] ] [EOL] [EOL] sc = SlackClient ( slack_token ) [EOL] result = sc . api_call ( [string] ) [EOL] if result [ [string] ] : [EOL] email = result [ [string] ] [ [string] ] [EOL] users = DbUsers ( db ) [EOL] if not users . contains ( email ) : [EOL] users . add ( email ) [EOL] DbUser ( db , email ) . notifications ( ) . add ( team = team , token = slack_token , profile = json . dumps ( result [ [string] ] ) ) [EOL] token = DbSessions ( db ) . add ( email ) [EOL] response . add_header ( [string] , [string] . format ( token ) ) [EOL] return redirect ( [string] ) [EOL] [EOL] [EOL] @ app . get ( [string] ) @ jinja2_view ( [string] ) def dashboard ( ) : [EOL] user = DbSessions ( db ) . user ( request . get_cookie ( [string] , [string] ) ) [EOL] return { [string] : user . as_html ( ) , [string] : user . calendars ( ) . as_html ( lambda url : app . get_url ( [string] , calendar = base64 . b64encode ( url . encode ( [string] ) ) . decode ( [string] ) ) ) , [string] : app . get_url ( [string] ) , [string] : user . notifications ( ) . as_html ( ) , [string] : app . get_url ( [string] ) } [EOL] [EOL] [EOL] @ app . get ( [string] , name = [string] ) @ jinja2_view ( [string] ) def add_slack_notification ( ) : [EOL] return { [string] : app . get_url ( [string] ) } [EOL] [EOL] [EOL] @ app . post ( [string] , name = [string] ) def add_slack_notification ( ) : [EOL] slack_token = request . forms [ [string] ] [EOL] notifications = DbSessions ( db ) . user ( request . get_cookie ( [string] , [string] ) ) . notifications ( ) [EOL] notifications . add ( [string] , slack_token , [string] ) [EOL] notification = notifications . notification ( slack_token ) [EOL] notification . update_busy ( request . forms [ [string] ] , request . forms [ [string] ] ) [EOL] notification . update_available ( request . forms [ [string] ] , request . forms [ [string] ] ) [EOL] return redirect ( [string] ) [EOL] [EOL] [EOL] @ app . get ( [string] , name = [string] ) @ jinja2_view ( [string] ) def calendar ( calendar ) : [EOL] token = request . get_cookie ( [string] , [string] ) [EOL] return { [string] : DbSessions ( db ) . user ( token ) . calendars ( ) . calendar ( base64 . b64decode ( calendar ) . decode ( [string] ) ) . as_html ( lambda url : app . get_url ( [string] , calendar = base64 . b64encode ( url . encode ( [string] ) ) . decode ( [string] ) ) ) } [EOL] [EOL] [EOL] @ app . get ( [string] , name = [string] ) def sync_calendar ( calendar ) : [EOL] DbSessions ( db ) . user ( request . get_cookie ( [string] , [string] ) ) . calendars ( ) . calendar ( base64 . b64decode ( calendar ) . decode ( [string] ) ) . sync ( store_dir ) [EOL] return redirect ( app . get_url ( [string] , calendar = calendar ) ) [EOL] [EOL] [EOL] @ app . get ( [string] , name = [string] ) @ jinja2_view ( [string] ) def add_calendar ( ) : [EOL] return { [string] : app . get_url ( [string] ) } [EOL] [EOL] [EOL] @ app . post ( [string] , name = [string] ) def add_calendar_form ( ) : [EOL] DbSessions ( db ) . user ( request . get_cookie ( [string] , [string] ) ) . calendars ( ) . add ( request . forms [ [string] ] , request . forms [ [string] ] ) [EOL] return redirect ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] MigrationInit ( db ) . apply ( ) [EOL] run ( app , host = host , port = port ) [EOL] ImeerkPeriodic ( ) . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 $builtins.str$ 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import setuptools [EOL] [EOL] with open ( [string] , [string] ) as fh : [EOL] long_description = fh . read ( ) [EOL] [EOL] with open ( [string] ) as r : [EOL] install_requirements = [ ] [EOL] for line in r : [EOL] install_requirements . append ( line ) [EOL] [EOL] setuptools . setup ( name = [string] , version = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , author = [string] , author_email = [string] , url = [string] , license = [string] , packages = setuptools . find_packages ( ) , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , install_requires = install_requirements , setup_requires = [ [string] ] , tests_require = [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import shutil [EOL] import tempfile [EOL] from datetime import datetime [EOL] from os import path [EOL] from unittest import TestCase [EOL] [EOL] from imeerk . calendars . icalendar import FileTimeIntervals [EOL] [EOL] [EOL] class FileTimeIntervalsTest ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . test_dir = tempfile . mkdtemp ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] shutil . rmtree ( self . test_dir ) [EOL] [EOL] def test_add ( self ) : [EOL] file = path . join ( self . test_dir , [string] ) [EOL] intervals = FileTimeIntervals ( file ) [EOL] intervals . add ( datetime ( [number] , [number] , [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] , [number] , [number] ) , [string] ) [EOL] self . assertTrue ( intervals . is_inside ( datetime ( [number] , [number] , [number] , [number] , [number] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from . DbIcalCalendar import DbIcalCalendar [EOL] from . DbIcalCalendars import DbIcalCalendars [EOL] from . FileTimeIntervals import FileTimeIntervals [EOL] from . IcalCalendar import IcalCalendar [EOL] from . IcalCalendars import IcalCalendars [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable [EOL] import typing [EOL] import builtins [EOL] import abc [EOL] import typing [EOL] [EOL] [EOL] class IcalCalendar ( metaclass = abc . ABCMeta ) : [EOL] @ abc . abstractmethod def as_html ( self , sync_url ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def sync ( self , folder ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Any , Callable [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] import datetime [EOL] import sqlite3 [EOL] import time [EOL] import typing [EOL] import urllib . parse [EOL] from os import makedirs [EOL] from os import path [EOL] [EOL] from dateutil import tz [EOL] from meerk . calendar import IcsCalendar [EOL] from meerk . intervals import SimpleCalEventsIntervals [EOL] from sqlbuilder . smartsql import Q , T , Result [EOL] from sqlbuilder . smartsql . dialects . sqlite import compile [EOL] [EOL] from . FileTimeIntervals import FileTimeIntervals [EOL] from . IcalCalendar import IcalCalendar [EOL] [EOL] [EOL] class DbIcalCalendar ( IcalCalendar ) : [EOL] [EOL] def __init__ ( self , db_name , user , url ) : [EOL] self . db_name = db_name [EOL] self . user = user [EOL] self . url = url [EOL] [EOL] def as_html ( self , sync_url ) : [EOL] result = [string] [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] row = connection . execute ( * compile ( Q ( T . icalendar ) . fields ( [string] ) . where ( T . icalendar . user == self . user and T . icalendar . url == self . url ) ) ) . fetchone ( ) [EOL] try : [EOL] sync = datetime . datetime . fromtimestamp ( row [ [number] ] / [number] ) [EOL] except OSError : [EOL] sync = datetime . datetime . min [EOL] name = row [ [number] ] [EOL] url = row [ [number] ] [EOL] [EOL] delta = datetime . datetime . now ( ) - sync [EOL] [EOL] if delta . seconds > [number] : [EOL] sync_html = f' [string] { str ( sync ) } [string] ' [EOL] else : [EOL] sync_html = f' [string] { str ( sync ) } [string] ' [EOL] result = f''' [string] { name } [string] { url } [string] { sync_html } [string] { sync_url ( url ) } [string] ''' [EOL] [EOL] return result [EOL] [EOL] def sync ( self , folder ) : [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] row = connection . execute ( * compile ( Q ( T . icalendar ) . fields ( [string] ) . where ( T . icalendar . user == self . user and T . icalendar . url == self . url ) ) ) . fetchone ( ) [EOL] url = row [ [number] ] [EOL] [EOL] sync_dir = path . join ( folder , self . user , [string] ) [EOL] if not path . exists ( sync_dir ) : [EOL] makedirs ( sync_dir ) [EOL] [EOL] IcsCalendar ( url , SimpleCalEventsIntervals ( tz . tzlocal ( ) , FileTimeIntervals ( path . join ( sync_dir , urllib . parse . quote ( self . url , safe = [string] ) ) ) ) ) . sync ( ) [EOL] [EOL] connection . execute ( * Q ( T . icalendar , result = Result ( compile = compile ) ) . where ( T . icalendar . user == self . user and T . icalendar . url == self . url ) . update ( { T . icalendar . sync_time : int ( round ( time . time ( ) * [number] ) ) } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Callable[[builtins.str],builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import datetime [EOL] import base64 [EOL] import pickle [EOL] from datetime import datetime [EOL] [EOL] from meerk . intervals . TimeIntervals import TimeIntervals [EOL] [EOL] [EOL] class FileTimeIntervals ( TimeIntervals ) : [EOL] [EOL] def __init__ ( self , file ) : [EOL] self . file = file [EOL] [EOL] def clear ( self ) : [EOL] open ( self . file , [string] ) . close ( ) [EOL] [EOL] def add ( self , start , end , data ) : [EOL] with open ( self . file , [string] ) as store : [EOL] start_b64 = base64 . b64encode ( pickle . dumps ( start ) ) . decode ( [string] ) [EOL] end_b64 = base64 . b64encode ( pickle . dumps ( end ) ) . decode ( [string] ) [EOL] data_b64 = base64 . b64encode ( pickle . dumps ( data ) ) . decode ( [string] ) [EOL] store . write ( f"{ start_b64 } [string] { end_b64 } [string] { data_b64 } [string] " ) [EOL] [EOL] def is_inside ( self , time ) : [EOL] is_inside = False [EOL] with open ( self . file ) as store : [EOL] for line in store : [EOL] start_b64 , end_b64 , _ = line . split ( [string] ) [EOL] start = pickle . loads ( base64 . b64decode ( start_b64 ) ) [EOL] end = pickle . loads ( base64 . b64decode ( end_b64 ) ) [EOL] is_inside = is_inside or ( start <= time <= end ) [EOL] [EOL] return is_inside [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $datetime.datetime$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 $builtins.bool$ 0
from typing import Any , Callable , List [EOL] import typing [EOL] import builtins [EOL] import IcalCalendar [EOL] import sqlite3 [EOL] import typing [EOL] [EOL] from sqlbuilder . smartsql import Q , T , Result [EOL] from sqlbuilder . smartsql . dialects . sqlite import compile [EOL] [EOL] from . IcalCalendars import IcalCalendars [EOL] from . IcalCalendar import IcalCalendar [EOL] from . DbIcalCalendar import DbIcalCalendar [EOL] [EOL] [EOL] class DbIcalCalendars ( IcalCalendars ) : [EOL] [EOL] def __init__ ( self , db_name , user ) : [EOL] self . db_name = db_name [EOL] self . user = user [EOL] [EOL] def add ( self , url , name ) : [EOL] [comment] [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] connection . execute ( * Q ( T . icalendar , result = Result ( compile = compile ) ) . insert ( { T . icalendar . user : self . user , T . icalendar . url : url , T . icalendar . name : name , T . icalendar . sync_time : [number] } ) ) [EOL] [EOL] def calendar ( self , url ) : [EOL] return DbIcalCalendar ( self . db_name , self . user , url ) [EOL] [EOL] def as_html ( self , url ) : [EOL] result = [string] [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] rows = connection . execute ( * compile ( Q ( T . icalendar ) . fields ( [string] ) . where ( T . icalendar . user == self . user ) ) ) . fetchall ( ) [EOL] [EOL] result = [string] . format ( [string] . join ( map ( lambda row : [string] . format ( row [ [number] ] , url ( row [ [number] ] ) ) , rows ) ) ) [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $IcalCalendar.IcalCalendar$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0
from . DbUser import DbUser [EOL] from . DbUsers import DbUsers [EOL] from . User import User [EOL] from . Users import Users [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import sqlite3 [EOL] from sqlbuilder . smartsql import Q , T , Result [EOL] from sqlbuilder . smartsql . dialects . sqlite import compile [EOL] from . Users import Users [EOL] [EOL] [EOL] class DbUsers ( Users ) : [EOL] [EOL] def __init__ ( self , db_name ) : [EOL] self . db_name = db_name [EOL] [EOL] def add ( self , email ) : [EOL] [comment] [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] connection . execute ( * Q ( T . user , result = Result ( compile = compile ) ) . insert ( { T . user . email : email } ) ) [EOL] [EOL] def contains ( self , email ) : [EOL] [comment] [EOL] contains = False [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] info = connection . execute ( * compile ( Q ( T . user ) . fields ( [string] ) . where ( T . user . email == email ) ) ) . fetchone ( ) [EOL] if info : [EOL] contains = True [EOL] return contains [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0
import builtins [EOL] import imeerk [EOL] from imeerk . calendars . icalendar import DbIcalCalendars [EOL] from imeerk . calendars . icalendar import IcalCalendars [EOL] from imeerk . notifications . slack import DbSlackNotifications [EOL] from imeerk . notifications . slack import SlackNotifications [EOL] from . User import User [EOL] [EOL] [EOL] class DbUser ( User ) : [EOL] [EOL] def __init__ ( self , db_name , email ) : [EOL] self . db_name = db_name [EOL] self . email = email [EOL] [EOL] def notifications ( self ) : [EOL] return DbSlackNotifications ( self . db_name , self . email ) [EOL] [EOL] def calendars ( self ) : [EOL] return DbIcalCalendars ( self . db_name , self . email ) [EOL] [EOL] def url ( self ) : [EOL] return [string] + self . email [EOL] [EOL] def as_html ( self ) : [EOL] return self . email [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $imeerk.notifications.slack.SlackNotifications$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imeerk.calendars.icalendar.IcalCalendars$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from . Periodic import Periodic [EOL] [EOL] [EOL] class NotificationsPeriodic ( Periodic ) : [EOL] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def run ( self ) : [EOL] [comment] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0
from . CalendarsPeriodic import CalendarsPeriodic [EOL] from . GroupPeriodic import GroupPeriodic [EOL] from . ImeerkPeriodic import ImeerkPeriodic [EOL] from . NotificationsPeriodic import NotificationsPeriodic [EOL] from . Periodic import Periodic [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . CalendarsPeriodic import CalendarsPeriodic [EOL] from . GroupPeriodic import GroupPeriodic [EOL] from . NotificationsPeriodic import NotificationsPeriodic [EOL] from . Periodic import Periodic [EOL] [EOL] [EOL] class ImeerkPeriodic ( Periodic ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . group = GroupPeriodic ( [ CalendarsPeriodic ( ) , NotificationsPeriodic ( ) ] ) [EOL] [EOL] def run ( self ) : [EOL] self . group . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import abc [EOL] [EOL] [EOL] class Periodic ( metaclass = abc . ABCMeta ) : [EOL] @ abc . abstractmethod def run ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0
from celery import current_app [EOL] from celery . bin import worker [EOL] [EOL] from . Periodic import Periodic [EOL] [EOL] [EOL] class CalendarsPeriodic ( Periodic ) : [EOL] def run ( self ) : [EOL] worker . worker ( app = current_app ) . run ( broker = [string] , loglevel = [string] , traceback = True ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import Periodic [EOL] import typing [EOL] [EOL] from . Periodic import Periodic [EOL] [EOL] [EOL] class GroupPeriodic ( Periodic ) : [EOL] [EOL] def __init__ ( self , periodics ) : [EOL] self . periodics = periodics [EOL] [EOL] def run ( self ) : [EOL] for periodic in self . periodics : [EOL] periodic . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] import SlackNotification [EOL] import abc [EOL] [EOL] from . SlackNotification import SlackNotification [EOL] [EOL] [EOL] class SlackNotifications ( metaclass = abc . ABCMeta ) : [EOL] [EOL] @ abc . abstractmethod def add ( self , team , token , profile ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def notification ( self , token ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def as_html ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $SlackNotification.SlackNotification.SlackNotification$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
import builtins [EOL] import sqlite3 [EOL] [EOL] from sqlbuilder . smartsql import Q , T , Result [EOL] from sqlbuilder . smartsql . dialects . sqlite import compile [EOL] [EOL] from . SlackNotification import SlackNotification [EOL] [EOL] [EOL] class DbSlackNotification ( SlackNotification ) : [EOL] [EOL] def __init__ ( self , db_name , user , token ) : [EOL] self . db_name = db_name [EOL] self . user = user [EOL] self . token = token [EOL] [EOL] def update_busy ( self , busy_text , busy_emoji ) : [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] connection . execute ( * Q ( T . slack , result = Result ( compile = compile ) ) . where ( T . slack . user == self . user and T . slack . token == self . token ) . update ( { T . slack . busy_text : busy_text , T . slack . busy_emoji : busy_emoji , } ) ) [EOL] [EOL] def update_available ( self , available_text , available_emoji ) : [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] connection . execute ( * Q ( T . slack , result = Result ( compile = compile ) ) . where ( T . slack . user == self . user and T . slack . token == self . token ) . update ( { T . slack . available_text : available_text , T . slack . available_emoji : available_emoji , } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import builtins [EOL] import imeerk [EOL] import sqlite3 [EOL] [EOL] from sqlbuilder . smartsql import Q , T , Result [EOL] from sqlbuilder . smartsql . dialects . sqlite import compile [EOL] [EOL] from imeerk . notifications . slack import SlackNotification [EOL] from . DbSlackNotification import DbSlackNotification [EOL] from . SlackNotifications import SlackNotifications [EOL] [EOL] [EOL] class DbSlackNotifications ( SlackNotifications ) : [EOL] [EOL] def __init__ ( self , db_name , user ) : [EOL] self . db_name = db_name [EOL] self . user = user [EOL] [EOL] def add ( self , team , token , profile ) : [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] connection . execute ( * Q ( T . slack , result = Result ( compile = compile ) ) . insert ( { T . slack . user : self . user , T . slack . team : team , T . slack . token : token , T . slack . profile : profile , T . slack . busy_text : [string] , T . slack . busy_emoji : [string] , T . slack . available_text : [string] , T . slack . available_emoji : [string] , } ) ) [EOL] [EOL] def notification ( self , token ) : [EOL] return DbSlackNotification ( self . db_name , self . user , token ) [EOL] [EOL] def as_html ( self ) : [EOL] result = [string] [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] rows = connection . execute ( * compile ( Q ( T . slack ) . fields ( [string] ) . where ( T . slack . user == self . user ) ) ) . fetchall ( ) [EOL] [EOL] for row in rows : [EOL] [comment] [EOL] team = row [ [number] ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] result += f' [string] { team } [string] ' [EOL] [EOL] return f' [string] { result } [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imeerk.notifications.slack.SlackNotification$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
import builtins [EOL] import abc [EOL] [EOL] [EOL] class SlackNotification ( metaclass = abc . ABCMeta ) : [EOL] [EOL] @ abc . abstractmethod def update_busy ( self , busy_text , busy_emoji ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def update_available ( self , available_text , available_emoji ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0
from . DbSlackNotification import DbSlackNotification [EOL] from . DbSlackNotifications import DbSlackNotifications [EOL] from . SlackNotification import SlackNotification [EOL] from . SlackNotifications import SlackNotifications [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sqlite3 [EOL] import builtins [EOL] import sqlite3 [EOL] from sqlite3 . dbapi2 import Connection [EOL] from sqlbuilder . smartsql import Q , T , Result [EOL] from sqlbuilder . smartsql . dialects . sqlite import compile [EOL] [EOL] [EOL] class DbVersion : [EOL] [EOL] def __init__ ( self , db_name , table = [string] ) : [EOL] self . db_name = db_name [EOL] self . table = table [EOL] [EOL] def number ( self ) : [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] self . __ensure_table ( connection ) [EOL] version = connection . execute ( * compile ( Q ( T ( self . table ) ) . fields ( [string] ) ) ) . fetchone ( ) [ [number] ] [EOL] [EOL] return version [EOL] [EOL] def update ( self , number ) : [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] self . __ensure_table ( connection ) [EOL] connection . execute ( * Q ( T ( self . table ) , result = Result ( compile = compile ) ) . update ( { T ( self . table ) . number : number } ) ) [EOL] [EOL] def __ensure_table ( self , connection ) : [EOL] info = connection . execute ( * compile ( Q ( T . sqlite_master ) . fields ( [string] ) . where ( ( T . sqlite_master . name == [string] ) & ( T . sqlite_master . type == [string] ) ) ) ) . fetchone ( ) [EOL] [EOL] if not info : [EOL] connection . execute ( [string] ) [EOL] connection . execute ( * Q ( T ( self . table ) , result = Result ( compile = compile ) ) . insert ( { T ( self . table ) . number : [number] } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $None$ 0 0 0 $sqlite3.dbapi2.Connection$ 0 0 0 $typing.Any$ 0 $sqlite3.dbapi2.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $sqlite3.dbapi2.Connection$ 0 0 0 0 0 0 $sqlite3.dbapi2.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . Migration import Migration [EOL] from . MigrationInit import MigrationInit [EOL] from . DbVersion import DbVersion [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import sqlite3 [EOL] [EOL] from . DbVersion import DbVersion [EOL] from . Migration import Migration [EOL] [EOL] [EOL] class MigrationInit ( Migration ) : [EOL] [EOL] def __init__ ( self , db_name ) : [EOL] [comment] [EOL] self . version = DbVersion ( db_name ) [EOL] self . db_name = db_name [EOL] [EOL] def apply ( self ) : [EOL] [comment] [EOL] if self . version . number ( ) == [number] : [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] connection . execute ( [string] ) [EOL] connection . execute ( [string] ) [EOL] connection . execute ( [string] ) [EOL] connection . execute ( [string] ) [EOL] connection . execute ( [string] ) [EOL] [EOL] self . version . update ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import imeerk [EOL] import sqlite3 [EOL] import uuid [EOL] [EOL] from sqlbuilder . smartsql import Q , T , Result [EOL] from sqlbuilder . smartsql . dialects . sqlite import compile [EOL] [EOL] from imeerk . users import DbUser [EOL] from imeerk . users import User [EOL] from . Sessions import Sessions [EOL] [EOL] [EOL] class DbSessions ( Sessions ) : [EOL] [EOL] def __init__ ( self , db_name ) : [EOL] self . db_name = db_name [EOL] [EOL] def user ( self , token ) : [EOL] user = [string] [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] row = connection . execute ( * compile ( Q ( T . session ) . fields ( [string] ) . where ( T . session . token == token ) ) ) . fetchone ( ) [EOL] user = row [ [number] ] [EOL] return DbUser ( self . db_name , user ) [EOL] [EOL] def add ( self , user ) : [EOL] token = str ( uuid . uuid4 ( ) ) [EOL] with sqlite3 . connect ( self . db_name ) as connection : [EOL] connection . execute ( * Q ( T . session , result = Result ( compile = compile ) ) . insert ( { T . session . user : user , T . session . token : token } ) ) [EOL] return token [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $imeerk.users.User$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0
from . Sessions import Sessions [EOL] from . DbSessions import DbSessions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import imeerk [EOL] import abc [EOL] [EOL] from imeerk . users import User [EOL] [EOL] [EOL] class Sessions ( metaclass = abc . ABCMeta ) : [EOL] @ abc . abstractmethod def user ( self , token ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def add ( self , user ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imeerk.users.User$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0