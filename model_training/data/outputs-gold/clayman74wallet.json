	0
from typing import Type , Any [EOL] import aiohttp [EOL] import typing [EOL] import src [EOL] import builtins [EOL] import config [EOL] from aiohttp import web [EOL] from aiohttp_metrics import setup as setup_metrics [comment] [EOL] from aiohttp_micro import ( AppConfig as BaseConfig , setup as setup_micro , ) [EOL] from asyncpg . pool import create_pool [comment] [EOL] from passport . app import TokenConfig [comment] [EOL] [EOL] from wallet . handlers import accounts , operations [EOL] [EOL] [EOL] class AppConfig ( BaseConfig ) : [EOL] db = config . NestedField ( config . PostgresConfig ) [EOL] tokens = config . NestedField ( TokenConfig ) [EOL] [EOL] [EOL] async def db_engine ( app ) : [EOL] config = app [ [string] ] [EOL] [EOL] app [ [string] ] = await create_pool ( host = config . db . host , port = config . db . port , user = config . db . user , password = config . db . password , database = config . db . database , min_size = config . db . min_pool_size , max_size = config . db . max_pool_size , ) [EOL] [EOL] yield [EOL] [EOL] await app [ [string] ] . close ( ) [EOL] [EOL] [EOL] async def init ( app_name , config ) : [EOL] app = web . Application ( ) [EOL] [EOL] setup_micro ( app , app_name = app_name , config = config ) [EOL] setup_metrics ( app , app_name = app_name ) [EOL] [EOL] app . cleanup_ctx . append ( db_engine ) [EOL] [EOL] app . router . add_routes ( [ web . get ( [string] , accounts . search , name = [string] ) , web . post ( [string] , accounts . register , name = [string] ) , web . get ( [string] , accounts . balance , name = [string] , ) , web . put ( [string] , accounts . update , name = [string] , ) , web . delete ( [string] , accounts . remove , name = [string] , ) , ] ) [EOL] [EOL] app . router . add_routes ( [ web . get ( [string] , operations . search , name = [string] , ) , web . post ( [string] , operations . add , name = [string] , ) , web . get ( [string] , operations . fetch , name = [string] , ) , web . delete ( [string] , operations . remove , name = [string] , ) , ] ) [EOL] [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.wallet.app.AppConfig]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.wallet.app.AppConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import builtins [EOL] import asyncio [EOL] import os [EOL] [EOL] import click [EOL] import uvloop [comment] [EOL] from aiohttp_micro . management . server import server [comment] [EOL] from config import ( ConsulConfig , EnvValueProvider , FileValueProvider , load , ) [EOL] [EOL] [EOL] from wallet . app import AppConfig , init [EOL] [EOL] [EOL] @ click . group ( ) @ click . option ( [string] , default = None ) @ click . option ( [string] , is_flag = True , default = False ) @ click . pass_context def cli ( ctx , conf_dir = None , debug = False ) : [EOL] uvloop . install ( ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] [EOL] if not conf_dir : [EOL] conf_dir = os . path . dirname ( __file__ ) [EOL] [EOL] consul_config = ConsulConfig ( ) [EOL] load ( consul_config , providers = [ EnvValueProvider ( ) ] ) [EOL] [EOL] config = AppConfig ( defaults = { [string] : consul_config , [string] : debug , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , } ) [EOL] load ( config , providers = [ FileValueProvider ( conf_dir ) , EnvValueProvider ( ) ] ) [EOL] [EOL] app = loop . run_until_complete ( init ( [string] , config ) ) [EOL] [EOL] ctx . obj [ [string] ] = app [EOL] ctx . obj [ [string] ] = config [EOL] ctx . obj [ [string] ] = loop [EOL] [EOL] [EOL] cli . add_command ( server , name = [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cli ( obj = { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import asyncpg [EOL] from asyncpg . connection import Connection [comment] [EOL] [EOL] from wallet . domain . storage import Storage [EOL] from wallet . storage . accounts import AccountsDBRepo [EOL] from wallet . storage . operations import OperationsDBRepo [EOL] from wallet . storage . tags import TagsDBRepo [EOL] [EOL] [EOL] class DBStorage ( Storage ) : [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , conn ) : [EOL] super ( DBStorage , self ) . __init__ ( AccountsDBRepo ( conn ) , OperationsDBRepo ( conn ) , TagsDBRepo ( conn ) ) [EOL] [EOL] self . _conn = conn [EOL] [EOL] async def __aenter__ ( self ) : [EOL] self . _tr = self . _conn . transaction ( ) [EOL] await self . _tr . start ( ) [EOL] [EOL] return self [EOL] [EOL] async def __aexit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] if exc_type : [EOL] await self . rollback ( ) [EOL] [EOL] async def commit ( self ) : [EOL] await self . _tr . commit ( ) [EOL] [EOL] async def rollback ( self ) : [EOL] await self . _tr . rollback ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $asyncpg.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncpg.connection.Connection$ 0 0 0 0 $asyncpg.connection.Connection$ 0 0 0 0 $asyncpg.connection.Connection$ 0 0 0 0 0 0 0 0 $asyncpg.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Iterable , List , Match , Optional , Any , Dict [EOL] import typing [EOL] import wallet [EOL] import datetime [EOL] import builtins [EOL] import asyncpg [EOL] import re [EOL] from datetime import date [EOL] from typing import Dict , Iterable , List , Optional [EOL] [EOL] from asyncpg . connection import Connection [comment] [EOL] from asyncpg . exceptions import UniqueViolationError [comment] [EOL] [EOL] from wallet . domain import Account , Operation , OperationType , Tag [EOL] from wallet . domain . storage import ( EntityAlreadyExist , EntityNotFound , OperationRepo , ) [EOL] [EOL] [EOL] class OperationsDBRepo ( OperationRepo ) : [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , connection ) : [EOL] self . _conn = connection [EOL] [EOL] def _check_update ( self , result ) : [EOL] count = [number] [EOL] match = re . search ( [string] , result ) [EOL] if match : [EOL] try : [EOL] count = int ( match . group ( [string] ) ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] return count > [number] [EOL] [EOL] async def add ( self , operation ) : [EOL] query = [string] [EOL] key = await self . _conn . fetchval ( query , operation . amount , operation . account . key , operation . type . value , operation . description , operation . created_on , ) [EOL] [EOL] query = [string] [EOL] await self . _conn . executemany ( query , [ ( key , tag . key ) for tag in operation . tags ] ) [EOL] [EOL] return key [EOL] [EOL] async def _fetch ( self , filters , account , * args ) : [EOL] result = { } [EOL] [EOL] rows = await self . _conn . fetch ( f""" [string] { filters } [string] """ , account . key , * args , ) [EOL] [EOL] for row in rows : [EOL] result [ row [ [string] ] ] = Operation ( key = row [ [string] ] , amount = row [ [string] ] , account = account , description = row [ [string] ] , type = OperationType ( row [ [string] ] ) , created_on = row [ [string] ] , ) [EOL] [EOL] return result [EOL] [EOL] async def find ( self , account , month = None ) : [EOL] filters = [string] [EOL] result = await self . _fetch ( filters , account ) [EOL] [EOL] return list ( result . values ( ) ) [EOL] [EOL] async def find_by_key ( self , account , key ) : [EOL] filters = [string] [EOL] result = await self . _fetch ( filters , account , key ) [EOL] [EOL] if key not in result : [EOL] raise EntityNotFound ( ) [EOL] [EOL] return result [ key ] [EOL] [EOL] async def update ( self , operation , fields ) : [EOL] pass [EOL] [EOL] async def remove ( self , operation ) : [EOL] query = [string] [EOL] [EOL] result = await self . _conn . execute ( query , operation . key , operation . account . key ) [EOL] [EOL] return self . _check_update ( result ) [EOL] [EOL] async def add_tag ( self , operation , tag ) : [EOL] try : [EOL] result = await self . _conn . execute ( [string] , operation . key , tag . key , ) [EOL] except UniqueViolationError : [EOL] raise EntityAlreadyExist ( ) [EOL] [EOL] count = [number] [EOL] match = re . search ( [string] , result ) [EOL] if match : [EOL] try : [EOL] count = int ( match . group ( [string] ) ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] return count > [number] [EOL] [EOL] async def remove_tag ( self , operation , tag ) : [EOL] result = await self . _conn . execute ( [string] , operation . key , tag . key , ) [EOL] [EOL] count = [number] [EOL] match = re . search ( [string] , result ) [EOL] if match : [EOL] try : [EOL] count = int ( match . group ( [string] ) ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] return count > [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $asyncpg.connection.Connection$ 0 0 0 0 0 0 0 $asyncpg.connection.Connection$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $wallet.domain.Operation$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $wallet.domain.Operation$ 0 0 0 $wallet.domain.Operation$ 0 0 0 $typing.Any$ 0 $wallet.domain.Operation$ 0 0 0 0 0 $wallet.domain.Operation$ 0 0 0 $wallet.domain.Operation$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $wallet.domain.Operation$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.int,wallet.domain.Operation]$ 0 0 0 $builtins.str$ 0 $wallet.domain.Account$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[wallet.domain.Operation]$ 0 0 0 $wallet.domain.Account$ 0 $typing.Optional[datetime.date]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $wallet.domain.Account$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $wallet.domain.Operation$ 0 0 0 $wallet.domain.Account$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $wallet.domain.Account$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Operation$ 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Operation$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $wallet.domain.Operation$ 0 0 0 $wallet.domain.Operation$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Operation$ 0 $wallet.domain.Tag$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Operation$ 0 0 0 $wallet.domain.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Operation$ 0 $wallet.domain.Tag$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Operation$ 0 0 0 $wallet.domain.Tag$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
from typing import Any [EOL] import aiohttp [EOL] import typing [EOL] from aiohttp import web [EOL] from aiohttp_micro . handlers import json_response [comment] [EOL] from passport . handlers . users import user_required [EOL] [EOL] from wallet . domain . storage import EntityAlreadyExist , EntityNotFound [EOL] from wallet . handlers import get_instance_id , validate_payload [EOL] from wallet . schemas import AccountSchema , BalanceSchema [EOL] from wallet . services . accounts import AccountsService [EOL] from wallet . storage import DBStorage [EOL] [EOL] [EOL] @ user_required ( ) @ validate_payload ( AccountSchema , [string] ) async def register ( request ) : [EOL] account = request [ [string] ] [EOL] [EOL] async with request . app [ [string] ] . acquire ( ) as conn : [EOL] storage = DBStorage ( conn ) [EOL] [EOL] try : [EOL] service = AccountsService ( storage ) [EOL] await service . register ( account ) [EOL] except EntityAlreadyExist : [EOL] return json_response ( { [string] : { [string] : [string] } } , status = [number] ) [EOL] [EOL] schema = AccountSchema ( only = ( [string] , [string] , [string] ) ) [EOL] return json_response ( { [string] : schema . dump ( account ) } , status = [number] ) [EOL] [EOL] [EOL] @ user_required ( ) async def search ( request ) : [EOL] async with request . app [ [string] ] . acquire ( ) as conn : [EOL] storage = DBStorage ( conn ) [EOL] accounts = await storage . accounts . find ( user = request [ [string] ] ) [EOL] [EOL] schema = AccountSchema ( only = ( [string] , [string] , [string] ) ) [EOL] return json_response ( { [string] : schema . dump ( accounts , many = True ) } ) [EOL] [EOL] [EOL] @ user_required ( ) async def balance ( request ) : [EOL] async with request . app [ [string] ] . acquire ( ) as conn : [EOL] storage = DBStorage ( conn ) [EOL] [EOL] try : [EOL] account = await storage . accounts . find_by_key ( user = request [ [string] ] , key = get_instance_id ( request , [string] ) , ) [EOL] except EntityNotFound : [EOL] raise web . HTTPNotFound ( ) [EOL] [EOL] schema = BalanceSchema ( exclude = ( [string] , ) ) [EOL] return json_response ( { [string] : schema . dump ( account . balance , many = True ) } ) [EOL] [EOL] [EOL] @ user_required ( ) @ validate_payload ( AccountSchema , [string] ) async def update ( request ) : [EOL] next_account = request [ [string] ] [EOL] [EOL] async with request . app [ [string] ] . acquire ( ) as conn : [EOL] storage = DBStorage ( conn ) [EOL] [EOL] try : [EOL] account = await storage . accounts . find_by_key ( user = request [ [string] ] , key = get_instance_id ( request , [string] ) , ) [EOL] except EntityNotFound : [EOL] raise web . HTTPNotFound ( ) [EOL] [EOL] if next_account . name : [EOL] account . name = next_account . name [EOL] await storage . accounts . update ( account , fields = ( [string] , ) ) [EOL] [EOL] return web . Response ( status = [number] ) [EOL] [EOL] [EOL] @ user_required ( ) async def remove ( request ) : [EOL] async with request . app [ [string] ] . acquire ( ) as conn : [EOL] storage = DBStorage ( conn ) [EOL] [EOL] try : [EOL] account = await storage . accounts . find_by_key ( user = request [ [string] ] , key = get_instance_id ( request , [string] ) , ) [EOL] except EntityNotFound : [EOL] raise web . HTTPNotFound ( ) [EOL] [EOL] await storage . accounts . remove ( account ) [EOL] [EOL] return web . Response ( status = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Callable [EOL] import aiohttp [EOL] import typing [EOL] import wallet [EOL] import builtins [EOL] from typing import Awaitable , Callable , Type [EOL] [EOL] from aiohttp import web [EOL] from aiohttp_micro . handlers import get_payload , json_response [EOL] from marshmallow import ValidationError [EOL] [EOL] from wallet . schemas import Schema [EOL] [EOL] [EOL] Handler = Callable [ [ web . Request ] , Awaitable [ web . Response ] ] [EOL] [EOL] [EOL] def get_instance_id ( request , key = [string] ) : [EOL] if key not in request . match_info : [EOL] raise web . HTTPInternalServerError ( text = [string] % key ) [EOL] [EOL] try : [EOL] instance_id = int ( request . match_info [ key ] ) [EOL] except ValueError : [EOL] raise web . HTTPBadRequest ( text = [string] % request . match_info [ key ] ) [EOL] [EOL] return instance_id [EOL] [EOL] [EOL] def validate_payload ( schema_cls , entity_name ) : [EOL] def wrapper ( f ) : [EOL] async def wrapped ( request ) : [EOL] payload = await get_payload ( request ) [EOL] [EOL] schema = schema_cls ( ) [EOL] if [string] in request : [EOL] schema . context = { [string] : request [ [string] ] } [EOL] [EOL] try : [EOL] entity = schema . load ( payload ) [EOL] except ValidationError as exc : [EOL] return json_response ( { [string] : exc . messages } , status = [number] ) [EOL] [EOL] request [ [string] ] = schema [EOL] request [ entity_name ] = entity [EOL] [EOL] return await f ( request ) [EOL] [EOL] return wrapped [EOL] [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import aiohttp [EOL] import typing [EOL] from aiohttp import web [EOL] from aiohttp_micro . handlers import json_response [comment] [EOL] from passport . handlers . users import user_required [EOL] [EOL] from wallet . domain . storage import EntityNotFound [EOL] from wallet . handlers import get_instance_id , validate_payload [EOL] from wallet . schemas import OperationSchema [EOL] from wallet . services . operations import OperationsService [EOL] from wallet . storage import DBStorage [EOL] [EOL] [EOL] @ user_required ( ) @ validate_payload ( OperationSchema , [string] ) async def add ( request ) : [EOL] operation = request [ [string] ] [EOL] [EOL] async with request . app [ [string] ] . acquire ( ) as conn : [EOL] storage = DBStorage ( conn ) [EOL] [EOL] try : [EOL] account = await storage . accounts . find_by_key ( user = request [ [string] ] , key = get_instance_id ( request , [string] ) , ) [EOL] except EntityNotFound : [EOL] raise web . HTTPNotFound ( ) [EOL] [EOL] service = OperationsService ( storage ) [EOL] await service . add_to_account ( account , operation ) [EOL] [EOL] schema = OperationSchema ( only = ( [string] , [string] , [string] , [string] , [string] ) ) [EOL] return json_response ( { [string] : schema . dump ( operation ) } , status = [number] ) [EOL] [EOL] [EOL] @ user_required ( ) async def search ( request ) : [EOL] async with request . app [ [string] ] . acquire ( ) as conn : [EOL] storage = DBStorage ( conn ) [EOL] [EOL] try : [EOL] account = await storage . accounts . find_by_key ( user = request [ [string] ] , key = get_instance_id ( request , [string] ) , ) [EOL] except EntityNotFound : [EOL] raise web . HTTPNotFound ( ) [EOL] [EOL] service = OperationsService ( storage ) [EOL] operations = await service . fetch ( account = account ) [EOL] [EOL] schema = OperationSchema ( only = ( [string] , [string] , [string] , [string] , [string] ) ) [EOL] return json_response ( { [string] : schema . dump ( operations , many = True ) } ) [EOL] [EOL] [EOL] @ user_required ( ) async def fetch ( request ) : [EOL] async with request . app [ [string] ] . acquire ( ) as conn : [EOL] storage = DBStorage ( conn ) [EOL] [EOL] try : [EOL] account = await storage . accounts . find_by_key ( user = request [ [string] ] , key = get_instance_id ( request , [string] ) , ) [EOL] except EntityNotFound : [EOL] raise web . HTTPNotFound ( ) [EOL] [EOL] service = OperationsService ( storage ) [EOL] try : [EOL] operation = await service . fetch_by_key ( account = account , key = get_instance_id ( request , [string] ) ) [EOL] except EntityNotFound : [EOL] raise web . HTTPNotFound ( ) [EOL] [EOL] schema = OperationSchema ( only = ( [string] , [string] , [string] , [string] , [string] ) ) [EOL] return json_response ( { [string] : schema . dump ( operation ) } ) [EOL] [EOL] [EOL] @ user_required ( ) async def remove ( request ) : [EOL] async with request . app [ [string] ] . acquire ( ) as conn : [EOL] storage = DBStorage ( conn ) [EOL] [EOL] try : [EOL] account = await storage . accounts . find_by_key ( user = request [ [string] ] , key = get_instance_id ( request , [string] ) , ) [EOL] except EntityNotFound : [EOL] raise web . HTTPNotFound ( ) [EOL] [EOL] service = OperationsService ( storage ) [EOL] try : [EOL] operation = await service . fetch_by_key ( account = account , key = get_instance_id ( request , [string] ) ) [EOL] except EntityNotFound : [EOL] raise web . HTTPNotFound ( ) [EOL] [EOL] await service . remove_from_account ( account , operation ) [EOL] [EOL] return web . Response ( status = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Iterable [EOL] import typing [EOL] import wallet [EOL] import builtins [EOL] from typing import Iterable , List [EOL] [EOL] from wallet . domain import Account , User [EOL] [EOL] [EOL] class AccountNotFound ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class AccountsRepo : [EOL] async def find ( self , user ) : [EOL] raise NotImplementedError [EOL] [EOL] async def find_by_key ( self , user , key ) : [EOL] raise NotImplementedError [EOL] [EOL] async def find_by_name ( self , user , name ) : [EOL] raise NotImplementedError [EOL] [EOL] async def add ( self , operation ) : [EOL] raise NotImplementedError [EOL] [EOL] async def update ( self , operation , fields ) : [EOL] raise NotImplementedError [EOL] [EOL] async def remove ( self , operation ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[wallet.domain.Account]$ 0 0 0 $wallet.domain.User$ 0 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 0 0 $wallet.domain.User$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[wallet.domain.Account]$ 0 0 0 $wallet.domain.User$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Account$ 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import wallet [EOL] from wallet . domain . storage . accounts import AccountsRepo [EOL] from wallet . domain . storage . operations import OperationRepo [EOL] from wallet . domain . storage . tags import TagsRepo [EOL] [EOL] [EOL] class EntityAlreadyExist ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class EntityNotFound ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Storage : [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , accounts , operations , tags ) : [EOL] self . _accounts = accounts [EOL] self . _operations = operations [EOL] self . _tags = tags [EOL] [EOL] async def __aenter__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] async def __aexit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] raise NotImplementedError [EOL] [EOL] async def commit ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] async def rollback ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def accounts ( self ) : [EOL] return self . _accounts [EOL] [EOL] @ property def operations ( self ) : [EOL] return self . _operations [EOL] [EOL] @ property def tags ( self ) : [EOL] return self . _tags [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $wallet.domain.storage.accounts.AccountsRepo$ 0 $wallet.domain.storage.operations.OperationRepo$ 0 $wallet.domain.storage.tags.TagsRepo$ 0 0 0 0 0 0 0 $wallet.domain.storage.accounts.AccountsRepo$ 0 0 0 0 0 $wallet.domain.storage.operations.OperationRepo$ 0 0 0 0 0 $wallet.domain.storage.tags.TagsRepo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.storage.accounts.AccountsRepo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.storage.operations.OperationRepo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.storage.tags.TagsRepo$ 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List , Iterable [EOL] import typing [EOL] import datetime [EOL] import wallet [EOL] import builtins [EOL] from datetime import date [EOL] from typing import Iterable , List , Optional [EOL] [EOL] from wallet . domain import Account , Operation , Tag [EOL] [EOL] [EOL] class OperationRepo : [EOL] async def find ( self , account , month = None ) : [EOL] raise NotImplementedError [EOL] [EOL] async def find_by_key ( self , account , key ) : [EOL] raise NotImplementedError [EOL] [EOL] async def add ( self , operation ) : [EOL] raise NotImplementedError [EOL] [EOL] async def update ( self , operation , fields ) : [EOL] raise NotImplementedError [EOL] [EOL] async def remove ( self , operation ) : [EOL] raise NotImplementedError [EOL] [EOL] async def add_tag ( self , operation , tag ) : [EOL] raise NotImplementedError [EOL] [EOL] async def remove_tag ( self , operation , tag ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[wallet.domain.Operation]$ 0 0 0 $wallet.domain.Account$ 0 $typing.Optional[datetime.date]$ 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Operation$ 0 0 0 $wallet.domain.Account$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $wallet.domain.Operation$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Operation$ 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Operation$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Operation$ 0 $wallet.domain.Tag$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Operation$ 0 $wallet.domain.Tag$ 0 0 0 0 0 0
from typing import List , Dict , Iterable [EOL] import typing [EOL] import wallet [EOL] import builtins [EOL] from typing import Dict , Iterable , List [EOL] [EOL] from wallet . domain import Tag , User [EOL] [EOL] [EOL] class TagsRepo : [EOL] async def find ( self , user ) : [EOL] raise NotImplementedError [EOL] [EOL] async def find_by_key ( self , user , key ) : [EOL] raise NotImplementedError [EOL] [EOL] async def find_by_name ( self , user , name ) : [EOL] raise NotImplementedError [EOL] [EOL] async def find_by_operations ( self , user , operations ) : [EOL] raise NotImplementedError [EOL] [EOL] async def add ( self , tag ) : [EOL] raise NotImplementedError [EOL] [EOL] async def update ( self , tag , fields ) : [EOL] raise NotImplementedError [EOL] [EOL] async def remove ( self , tag ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[wallet.domain.Tag]$ 0 0 0 $wallet.domain.User$ 0 0 0 0 0 0 0 0 0 $wallet.domain.Tag$ 0 0 0 $wallet.domain.User$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[wallet.domain.Tag]$ 0 0 0 $wallet.domain.User$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[wallet.domain.Tag]]$ 0 0 0 $wallet.domain.User$ 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $wallet.domain.Tag$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Tag$ 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $wallet.domain.Tag$ 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import typing [EOL] import wallet [EOL] import builtins [EOL] from wallet . domain import Tag , User [EOL] from wallet . domain . storage import EntityAlreadyExist , Storage [EOL] [EOL] [EOL] class TagsService : [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , storage ) : [EOL] self . _storage = storage [EOL] [EOL] async def add ( self , name , user ) : [EOL] tag = Tag ( key = [number] , name = name , user = user ) [EOL] [EOL] async with self . _storage as store : [EOL] existed = await store . tags . find_by_name ( user , name ) [EOL] [EOL] if existed : [EOL] raise EntityAlreadyExist ( ) [EOL] [EOL] tag . key = await store . tags . add ( tag ) [EOL] await store . commit ( ) [EOL] [EOL] return tag [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $wallet.domain.storage.Storage$ 0 0 0 0 0 0 0 $wallet.domain.storage.Storage$ 0 0 0 0 $wallet.domain.Tag$ 0 0 0 $builtins.str$ 0 $wallet.domain.User$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $wallet.domain.User$ 0 $wallet.domain.User$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $wallet.domain.User$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Tuple , Any [EOL] import typing [EOL] import wallet [EOL] from wallet . domain import Account [EOL] from wallet . domain . storage import EntityAlreadyExist , Storage [EOL] [EOL] [EOL] class AccountsService : [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , storage ) : [EOL] self . _storage = storage [EOL] [EOL] async def register ( self , account ) : [EOL] async with self . _storage as store : [EOL] existed = await store . accounts . find_by_name ( account . user , account . name ) [EOL] [EOL] if len ( existed ) > [number] : [EOL] raise EntityAlreadyExist ( ) [EOL] [EOL] account . key = await store . accounts . add ( account ) [EOL] await store . commit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $wallet.domain.storage.Storage$ 0 0 0 0 0 0 0 $wallet.domain.storage.Storage$ 0 0 0 0 $None$ 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , List , Any [EOL] import typing [EOL] import wallet [EOL] import builtins [EOL] from typing import List [EOL] [EOL] from wallet . domain import Account , Operation [EOL] from wallet . domain . storage import Storage [EOL] [EOL] [EOL] class OperationsService : [EOL] __slots = ( [string] , ) [EOL] [EOL] def __init__ ( self , storage ) : [EOL] self . _storage = storage [EOL] [EOL] async def add_to_account ( self , account , operation ) : [EOL] operation . account = account [EOL] [EOL] async with self . _storage as store : [EOL] operation . key = await store . operations . add ( operation ) [EOL] [EOL] account . apply_operation ( operation ) [EOL] [EOL] await store . accounts . update ( account , fields = ( [string] , ) ) [EOL] await store . commit ( ) [EOL] [EOL] async def remove_from_account ( self , account , operation ) : [EOL] async with self . _storage as store : [EOL] account . rollback_operation ( operation ) [EOL] [EOL] await store . accounts . update ( account , fields = ( [string] , ) ) [EOL] removed = await store . operations . remove ( operation ) [EOL] [EOL] if removed : [EOL] await store . commit ( ) [EOL] else : [EOL] await store . rollback ( ) [EOL] [EOL] return removed [EOL] [EOL] async def fetch ( self , account ) : [EOL] async with self . _storage as store : [EOL] operations = await store . operations . find ( account ) [EOL] [EOL] tags = await store . tags . find_by_operations ( account . user , operations = [ item . key for item in operations ] ) [EOL] [EOL] for operation in operations : [EOL] if operation . key in tags : [EOL] operation . tags = tags [ operation . key ] [EOL] [EOL] return operations [EOL] [EOL] async def fetch_by_key ( self , account , key ) : [EOL] async with self . _storage as store : [EOL] operation = await store . operations . find_by_key ( account , key ) [EOL] [EOL] tags = await store . tags . find_by_operations ( account . user , operations = ( operation . key , ) ) [EOL] [EOL] if operation . key in tags : [EOL] operation . tags = tags [ operation . key ] [EOL] [EOL] return operation [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $wallet.domain.storage.Storage$ 0 0 0 0 0 0 0 $wallet.domain.storage.Storage$ 0 0 0 0 $None$ 0 0 0 0 0 $wallet.domain.Operation$ 0 0 0 $wallet.domain.Operation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Operation$ 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Operation$ 0 0 0 0 0 0 0 $wallet.domain.Operation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $wallet.domain.Account$ 0 $wallet.domain.Operation$ 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 0 0 $wallet.domain.Operation$ 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $wallet.domain.Operation$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[wallet.domain.Operation]$ 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $wallet.domain.Operation$ 0 0 0 $wallet.domain.Account$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0
from typing import Any [EOL] import typing [EOL] import passport [EOL] import pathlib [EOL] import os [EOL] import subprocess [EOL] from pathlib import Path [EOL] from typing import Any [EOL] [EOL] import faker [comment] [EOL] import pendulum [comment] [EOL] import pytest [comment] [EOL] from aiohttp import web [EOL] from passport . domain import User [comment] [EOL] [EOL] from wallet . app import AppConfig , init [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def config ( ) : [EOL] conf = AppConfig ( ) [EOL] [EOL] conf . tokens . public_key = [string] [comment] [EOL] conf . tokens . private_key = [string] [EOL] [EOL] return conf [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def app ( loop , pg_server , config ) : [EOL] config . db . host = pg_server [ [string] ] [ [string] ] [EOL] config . db . port = pg_server [ [string] ] [ [string] ] [EOL] config . db . user = pg_server [ [string] ] [ [string] ] [EOL] config . db . password = pg_server [ [string] ] [ [string] ] [EOL] config . db . database = pg_server [ [string] ] [ [string] ] [EOL] [EOL] app = loop . run_until_complete ( init ( [string] , config ) ) [EOL] runner = web . AppRunner ( app ) [EOL] [EOL] cwd = Path ( os . path . dirname ( __file__ ) ) [EOL] sql_root = cwd / [string] / [string] / [string] / [string] / [string] [EOL] [EOL] cmd = [string] [comment] [EOL] [EOL] subprocess . call ( [ cmd . format ( schema = ( sql_root / [string] ) . as_posix ( ) , host = config . db . host , port = config . db . port , user = config . db . user , password = config . db . password , database = config . db . database , ) ] , shell = True , cwd = cwd . as_posix ( ) , ) [EOL] [EOL] loop . run_until_complete ( runner . setup ( ) ) [EOL] [EOL] yield app [EOL] [EOL] loop . run_until_complete ( runner . cleanup ( ) ) [EOL] [EOL] subprocess . call ( [ cmd . format ( schema = ( sql_root / [string] ) . as_posix ( ) , host = config . db . host , port = config . db . port , user = config . db . user , password = config . db . password , database = config . db . database , ) ] , shell = True , cwd = cwd . as_posix ( ) , ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def fake ( ) : [EOL] return faker . Faker ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def today ( ) : [EOL] return pendulum . today ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def month ( today ) : [EOL] return today . start_of ( [string] ) . date ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def user ( fake ) : [EOL] return User ( key = [number] , email = fake . free_email ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $passport.domain.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import wallet [EOL] import passport [EOL] from typing import Any [EOL] [EOL] import pytest [comment] [EOL] from passport . domain import User [EOL] [EOL] from wallet . domain import Account [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def account ( fake , user ) : [EOL] return Account ( [number] , fake . credit_card_provider ( ) , user = user ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import wallet [EOL] from decimal import Decimal [EOL] from typing import List [EOL] [EOL] import pendulum [comment] [EOL] import pytest [comment] [EOL] [EOL] from wallet . domain import Account , Balance , Operation , OperationType [EOL] [EOL] [EOL] @ pytest . mark . unit @ pytest . fixture ( scope = [string] ) def operations_factory ( fake ) : [EOL] def build ( raw ) : [EOL] operations = [ ] [EOL] [EOL] for index , item in enumerate ( raw , start = [number] ) : [EOL] amount , account , operation_type , created_on = item [EOL] [EOL] start = created_on . start_of ( [string] ) [EOL] end = created_on . end_of ( [string] ) [EOL] created_on = fake . date_time_between_dates ( datetime_start = start , datetime_end = end ) [EOL] [EOL] operation = Operation ( index , Decimal ( amount ) , account , type = OperationType ( operation_type ) , created_on = created_on , ) [EOL] operations . append ( operation ) [EOL] [EOL] return operations [EOL] [EOL] return build [EOL] [EOL] [EOL] @ pytest . mark . unit def test_initial_balance ( fake , user ) : [EOL] account = Account ( [number] , fake . credit_card_provider ( ) , user ) [EOL] [EOL] created = pendulum . today ( ) [EOL] assert account . balance == [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = created . start_of ( [string] ) . date ( ) , ) ] [EOL] [EOL] [EOL] @ pytest . mark . unit def test_skip_balance_initialization ( fake , user ) : [EOL] created = pendulum . yesterday ( ) [EOL] [EOL] balance = [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = created . start_of ( [string] ) . date ( ) , ) ] [EOL] [EOL] account = Account ( [number] , fake . credit_card_provider ( ) , user , balance = balance ) [EOL] assert account . balance == balance [EOL] [EOL] [EOL] @ pytest . mark . unit def test_apply_operation_to_current_month ( fake , user , operations_factory ) : [EOL] today = pendulum . today ( ) . date ( ) [EOL] [EOL] account = Account ( [number] , fake . credit_card_provider ( ) , user ) [EOL] operations = operations_factory ( ( ( [string] , account , [string] , today ) , ) ) [EOL] [EOL] account . apply_operation ( operations [ [number] ] ) [EOL] [EOL] assert account . balance == [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , month = today . start_of ( [string] ) , ) ] [EOL] [EOL] [EOL] @ pytest . mark . unit def test_apply_operations_two_month_earlier_missing_month ( fake , user , operations_factory ) : [EOL] today = pendulum . today ( ) . date ( ) [EOL] month = today . start_of ( [string] ) [EOL] [EOL] account = Account ( [number] , fake . credit_card_provider ( ) , user , balance = [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month , ) ] , ) [EOL] operations = operations_factory ( ( ( [string] , account , [string] , today . subtract ( months = [number] ) ) , ) ) [EOL] [EOL] account . apply_operation ( operations [ [number] ] ) [EOL] [EOL] assert account . balance == [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , month = month . subtract ( months = [number] ) ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . unit def test_apply_operation_two_month_earlier_existing_month ( fake , user , operations_factory ) : [EOL] today = pendulum . today ( ) . date ( ) [EOL] month = today . start_of ( [string] ) [EOL] [EOL] account = Account ( [number] , fake . credit_card_provider ( ) , user , balance = [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month , ) , ] , ) [EOL] operations = operations_factory ( ( ( [string] , account , [string] , today . subtract ( months = [number] ) ) , ) ) [EOL] [EOL] account . apply_operation ( operations [ [number] ] ) [EOL] [EOL] assert account . balance == [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . unit def test_apply_operation_two_month_in_future ( fake , user , operations_factory ) : [EOL] today = pendulum . today ( ) . date ( ) [EOL] month = today . start_of ( [string] ) [EOL] [EOL] account = Account ( [number] , fake . credit_card_provider ( ) , user , balance = [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month , ) , ] , ) [EOL] operations = operations_factory ( ( ( [string] , account , [string] , today . add ( months = [number] ) ) , ) ) [EOL] [EOL] account . apply_operation ( operations [ [number] ] ) [EOL] [EOL] assert account . balance == [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month . add ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month . add ( months = [number] ) , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . unit def test_rollback_operation_from_current_month ( fake , user , operations_factory ) : [EOL] created = pendulum . yesterday ( ) [EOL] [EOL] account = Account ( [number] , fake . credit_card_provider ( ) , user ) [EOL] operations = operations_factory ( ( ( [string] , account , [string] , created ) , ) ) [EOL] [EOL] account . rollback_operation ( operations [ [number] ] ) [EOL] [EOL] assert account . balance == [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = created . start_of ( [string] ) . date ( ) , ) ] [EOL] [EOL] [EOL] @ pytest . mark . unit def test_rollback_operation_two_month_earlier ( fake , user , operations_factory ) : [EOL] today = pendulum . today ( ) [EOL] [EOL] account = Account ( [number] , fake . credit_card_provider ( ) , user , balance = [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = today . subtract ( months = [number] ) . start_of ( [string] ) . date ( ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = today . subtract ( months = [number] ) . start_of ( [string] ) . date ( ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = today . subtract ( months = [number] ) . start_of ( [string] ) . date ( ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = today . start_of ( [string] ) . date ( ) , ) , ] , ) [EOL] operations = operations_factory ( ( ( [string] , account , [string] , today . subtract ( months = [number] ) ) , ) ) [EOL] [EOL] account . rollback_operation ( operations [ [number] ] ) [EOL] [EOL] assert account . balance == [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = today . subtract ( months = [number] ) . start_of ( [string] ) . date ( ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = today . subtract ( months = [number] ) . start_of ( [string] ) . date ( ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = today . subtract ( months = [number] ) . start_of ( [string] ) . date ( ) , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = today . start_of ( [string] ) . date ( ) , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[wallet.domain.Operation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Union , Tuple , Type , Optional , Any , Dict [EOL] import typing [EOL] import builtins [EOL] from typing import Any , Dict , Optional , Tuple , Union [EOL] [EOL] import ujson [comment] [EOL] [EOL] [EOL] async def assert_valid_response ( response , status = [number] , content_type = None , schema = None , ) : [EOL] assert response . status == status [EOL] [EOL] if content_type : [EOL] assert response . headers [ [string] ] == content_type [EOL] [EOL] [EOL] Payload = Dict [ str , Any ] [EOL] Headers = Dict [ str , str ] [EOL] [EOL] [EOL] def prepare_payload ( data , headers = None , json = False ) : [EOL] [EOL] if headers is None : [EOL] headers = { } [EOL] [EOL] payload = data [EOL] if json : [EOL] payload = ujson . dumps ( data ) [EOL] headers [ [string] ] = [string] [EOL] [EOL] return payload , headers [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Union[builtins.str,Payload],Headers]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from decimal import Decimal [EOL] [EOL] import pytest [comment] [EOL] from passport . domain import TokenType [EOL] from passport . services . tokens import TokenService [EOL] [EOL] [EOL] from wallet . domain import Account , Balance , Operation , Tag [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def token ( user , config ) : [EOL] service = TokenService ( ) [EOL] [EOL] return service . generate_token ( user , token_type = TokenType . access , private_key = config . tokens . private_key , expire = config . tokens . expire , ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def account ( fake , user , month ) : [EOL] return Account ( key = [number] , name = fake . credit_card_provider ( ) , user = user , balance = [ Balance ( month = month ) ] , ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def operation ( fake , today , account ) : [EOL] return Operation ( key = [number] , amount = Decimal ( [string] ) , account = account , description = [string] , created_on = today , ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def tag ( fake , user ) : [EOL] return Tag ( key = [number] , name = fake . word ( ) , user = user ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from decimal import Decimal [EOL] [EOL] import pytest [comment] [EOL] [EOL] from tests . handlers import assert_valid_response , prepare_payload [EOL] from tests . storage import prepare_accounts [EOL] from wallet . domain import Account , Balance [EOL] [EOL] [EOL] class TestRegisterAccount : [EOL] @ pytest . mark . integration @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_unauthorized ( self , fake , aiohttp_client , app , json ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( ) [EOL] payload , headers = prepare_payload ( { [string] : fake . credit_card_provider ( ) } , json = json ) [EOL] resp = await client . post ( url , data = payload , headers = headers ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_success ( self , fake , aiohttp_client , app , token , json ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( ) [EOL] payload , headers = prepare_payload ( { [string] : fake . credit_card_provider ( ) } , { [string] : token } , json = json , ) [EOL] resp = await client . post ( url , data = payload , headers = headers ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] , content_type = [string] , ) [EOL] [EOL] @ pytest . mark . integration @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_duplicate ( self , fake , aiohttp_client , app , json , user , token , account ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] name = fake . credit_card_number ( ) [EOL] account . name = name [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( ) [EOL] payload , headers = prepare_payload ( { [string] : name } , { [string] : token } , json = json ) [EOL] resp = await client . post ( url , data = payload , headers = headers ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] [EOL] class TestSearchAccounts : [EOL] @ pytest . mark . integration async def test_unauthorized ( self , fake , aiohttp_client , app ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( ) [EOL] resp = await client . get ( url , headers = { [string] : [string] } ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration async def test_success ( self , fake , aiohttp_client , month , app , user , token ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] accounts = [ Account ( key = [number] , name = fake . credit_card_number ( ) , user = user , balance = [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , month = month , ) ] , ) , Account ( key = [number] , name = fake . credit_card_number ( ) , user = user , balance = [ Balance ( month = month ) ] , ) , ] [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , accounts ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( ) [EOL] resp = await client . get ( url , headers = { [string] : token } ) [EOL] [EOL] await assert_valid_response ( resp , content_type = [string] , ) [EOL] [EOL] [EOL] class TestUpdateAccount : [EOL] @ pytest . mark . integration @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_unauthorized ( self , fake , aiohttp_client , app , json ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = [string] ) [EOL] payload , headers = prepare_payload ( { [string] : fake . credit_card_provider ( ) } , json = json ) [EOL] resp = await client . put ( url , data = payload , headers = headers ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_missing ( self , fake , aiohttp_client , app , token , json ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = [string] ) [EOL] payload , headers = prepare_payload ( { [string] : fake . credit_card_provider ( ) } , { [string] : token } , json , ) [EOL] resp = await client . put ( url , data = payload , headers = headers ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_success ( self , fake , aiohttp_client , app , json , user , token , account ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) ) [EOL] payload , headers = prepare_payload ( { [string] : fake . credit_card_provider ( ) } , { [string] : token } , True , ) [EOL] resp = await client . put ( url , data = payload , headers = headers ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] [EOL] class TestRemoveAccount : [EOL] @ pytest . mark . integration async def test_unauthorized ( self , fake , aiohttp_client , app ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = [string] ) [EOL] resp = await client . delete ( url ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration async def test_missing ( self , fake , aiohttp_client , token , app ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = [string] ) [EOL] resp = await client . delete ( url , headers = { [string] : token } ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration async def test_success ( self , fake , aiohttp_client , app , user , account , token ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) ) [EOL] resp = await client . delete ( url , headers = { [string] : token } ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from decimal import Decimal [EOL] [EOL] import pendulum [comment] [EOL] import pytest [comment] [EOL] [EOL] from tests . handlers import assert_valid_response , prepare_payload [EOL] from tests . storage import prepare_accounts , prepare_operations , prepare_tags [EOL] from wallet . domain import Operation [EOL] [EOL] [EOL] class TestAddOperationToAccount : [EOL] @ pytest . mark . integration @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_unauthorized ( self , aiohttp_client , app , json , account ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) ) [EOL] payload , headers = prepare_payload ( { [string] : [string] } , json = json ) [EOL] resp = await client . post ( url , data = payload , headers = headers ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_success ( self , aiohttp_client , app , json , token , account ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) ) [EOL] payload , headers = prepare_payload ( { [string] : [string] } , { [string] : token } , json = json ) [EOL] resp = await client . post ( url , data = payload , headers = headers ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] , content_type = [string] ) [EOL] [EOL] [EOL] class TestFetchAccountOperations : [EOL] @ pytest . mark . integration async def test_unauthorized ( self , aiohttp_client , app , account ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) ) [EOL] resp = await client . get ( url ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration async def test_success ( self , aiohttp_client , app , token , account , operation , tag ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] operation . tags = [ tag ] [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) ) [EOL] resp = await client . get ( url , headers = { [string] : token } ) [EOL] [EOL] await assert_valid_response ( resp , content_type = [string] , ) [EOL] [EOL] [EOL] class TestFetchOperationFromAccount : [EOL] @ pytest . mark . integration async def test_unauthorized ( self , aiohttp_client , app , account ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] operation = Operation ( [number] , Decimal ( [string] ) , account , created_on = pendulum . today ( ) ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) , operation_key = str ( operation . key ) ) [EOL] resp = await client . get ( url ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration async def test_missing ( self , aiohttp_client , app , token , account ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) , operation_key = [string] ) [EOL] resp = await client . get ( url , headers = { [string] : token } ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration async def test_success ( self , aiohttp_client , app , token , account , operation ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) , operation_key = str ( operation . key ) ) [EOL] resp = await client . get ( url , headers = { [string] : token } ) [EOL] [EOL] await assert_valid_response ( resp , content_type = [string] , ) [EOL] [EOL] [EOL] class TestRemoveOperationFromAccount : [EOL] @ pytest . mark . integration async def test_unauthorized ( self , aiohttp_client , app , account , operation ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) , operation_key = str ( operation . key ) ) [EOL] resp = await client . delete ( url ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration async def test_missing ( self , aiohttp_client , app , token , account ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) , operation_key = [string] ) [EOL] resp = await client . delete ( url , headers = { [string] : token } ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL] [EOL] @ pytest . mark . integration async def test_success ( self , aiohttp_client , app , token , account , operation ) : [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] [EOL] url = app . router . named_resources ( ) [ [string] ] . url_for ( account_key = str ( account . key ) , operation_key = str ( operation . key ) ) [EOL] resp = await client . delete ( url , headers = { [string] : token } ) [EOL] [EOL] await assert_valid_response ( resp , status = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from tests . storage import prepare_accounts , prepare_operations , prepare_tags [EOL] from wallet . domain . storage import EntityAlreadyExist [EOL] from wallet . storage . operations import OperationsDBRepo [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_add_operation ( fake , today , app , account , operation ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] repo = OperationsDBRepo ( conn ) [EOL] key = await repo . add ( operation ) [EOL] [EOL] assert key == [number] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_add_operation_with_tags ( fake , today , app , user , account , operation , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] operation . tags = [ tag ] [EOL] [EOL] repo = OperationsDBRepo ( conn ) [EOL] key = await repo . add ( operation ) [EOL] [EOL] assert key == [number] [EOL] [EOL] query = [string] [EOL] operation_tags = await conn . fetchval ( query , key ) [EOL] [EOL] assert operation_tags == [number] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_find_operation_by_key ( fake , app , account , operation ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] [EOL] repo = OperationsDBRepo ( conn ) [EOL] result = await repo . find_by_key ( account , key = operation . key ) [EOL] [EOL] assert result == operation [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_remove_operation ( fake , app , account , operation ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] [EOL] repo = OperationsDBRepo ( conn ) [EOL] result = await repo . remove ( operation ) [EOL] [EOL] assert result is True [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_remove_operation_failed ( fake , app , account , operation ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] operation . key = [number] [EOL] [EOL] repo = OperationsDBRepo ( conn ) [EOL] result = await repo . remove ( operation ) [EOL] [EOL] assert result is False [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_add_tag_to_operation ( fake , app , user , account , operation , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] repo = OperationsDBRepo ( conn ) [EOL] result = await repo . add_tag ( operation , tag ) [EOL] [EOL] assert result is True [EOL] [EOL] query = [string] [EOL] count = await conn . fetchval ( query , operation . key , tag . key ) [EOL] [EOL] assert count == [number] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_add_existed_tag_to_operation ( fake , app , user , account , operation , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] await conn . execute ( [string] , operation . key , tag . key , ) [EOL] [EOL] with pytest . raises ( EntityAlreadyExist ) : [EOL] repo = OperationsDBRepo ( conn ) [EOL] await repo . add_tag ( operation , tag ) [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_remove_tag_from_operation ( fake , app , user , account , operation , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] await conn . execute ( [string] , operation . key , tag . key , ) [EOL] [EOL] repo = OperationsDBRepo ( conn ) [EOL] result = await repo . remove_tag ( operation , tag ) [EOL] [EOL] assert result is True [EOL] [EOL] query = [string] [EOL] count = await conn . fetchval ( query , operation . key , tag . key ) [EOL] [EOL] assert count == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from decimal import Decimal [EOL] [EOL] import pytest [comment] [EOL] [EOL] from tests . storage import prepare_accounts [EOL] from wallet . domain import Account , Balance [EOL] from wallet . domain . storage import EntityAlreadyExist , EntityNotFound [EOL] from wallet . storage . accounts import AccountsDBRepo [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def accounts ( fake , month , user ) : [EOL] return [ Account ( key = [number] , name = fake . credit_card_number ( ) , user = user , balance = [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , month = month , ) ] , ) , Account ( key = [number] , name = fake . credit_card_number ( ) , user = user , balance = [ Balance ( month = month ) ] , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_add_account ( fake , app , user ) : [EOL] account = Account ( [number] , fake . credit_card_provider ( ) , user ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] repo = AccountsDBRepo ( conn ) [EOL] key = await repo . add ( account ) [EOL] [EOL] assert key == [number] [EOL] [EOL] name = await conn . fetchval ( [string] , user . key , key , ) [EOL] [EOL] assert name == account . name [EOL] [EOL] balance_entities = await conn . fetchval ( [string] , key , ) [EOL] [EOL] assert balance_entities == [number] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_add_account_failed ( fake , app , month , user , account ) : [EOL] name = fake . credit_card_number ( ) [EOL] [EOL] account . name = name [EOL] account . balance = [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , month = month ) ] [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] with pytest . raises ( EntityAlreadyExist ) : [EOL] account = Account ( key = [number] , name = name , user = user ) [EOL] [EOL] repo = AccountsDBRepo ( conn ) [EOL] await repo . add ( account ) [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_find_account_by_key ( app , user , accounts ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , accounts ) [EOL] [EOL] repo = AccountsDBRepo ( conn ) [EOL] result = await repo . find_by_key ( user , key = accounts [ [number] ] . key ) [EOL] [EOL] assert result == accounts [ [number] ] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_find_account_by_key_missing ( app , user ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] with pytest . raises ( EntityNotFound ) : [EOL] repo = AccountsDBRepo ( conn ) [EOL] await repo . find_by_key ( user , key = [number] ) [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_find_account_by_name ( app , user , accounts ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] expected = await prepare_accounts ( conn , accounts ) [EOL] [EOL] repo = AccountsDBRepo ( conn ) [EOL] result = await repo . find_by_name ( user , name = expected [ [number] ] . name ) [EOL] [EOL] assert result == [ expected [ [number] ] ] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_update_account_name ( fake , app , user , accounts ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , accounts ) [EOL] [EOL] account = accounts [ [number] ] [EOL] account . name = fake . credit_card_number ( ) [EOL] [EOL] repo = AccountsDBRepo ( conn ) [EOL] result = await repo . update ( account , fields = ( [string] , ) ) [EOL] [EOL] assert result is True [EOL] [EOL] name = await conn . fetchval ( [string] , user . key , account . key , ) [EOL] [EOL] assert name == account . name [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_update_account_duplicate_name ( app , user , accounts ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , accounts ) [EOL] [EOL] account = accounts [ [number] ] [EOL] account . name = accounts [ [number] ] . name [EOL] [EOL] repo = AccountsDBRepo ( conn ) [EOL] result = await repo . update ( accounts [ [number] ] , fields = ( [string] , ) ) [EOL] [EOL] assert result is False [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_update_account_name_failed ( fake , app , user , account ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] account . name = fake . credit_card_number ( ) [EOL] [EOL] repo = AccountsDBRepo ( conn ) [EOL] result = await repo . update ( account , fields = ( [string] , ) ) [EOL] [EOL] assert result is False [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_update_balance_single_entry ( app , month , user , account ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] account . balance = [ Balance ( rest = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month , ) ] [EOL] [EOL] repo = AccountsDBRepo ( conn ) [EOL] result = await repo . update ( account , fields = ( [string] , ) ) [EOL] [EOL] assert result is True [EOL] [EOL] result = await repo . find_by_key ( user , key = account . key ) [EOL] assert result . balance == [ Balance ( rest = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month , ) ] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_update_balance_with_missing_entries ( app , month , user , account ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] account . balance = [ Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , Balance ( rest = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month , ) , ] [EOL] [EOL] repo = AccountsDBRepo ( conn ) [EOL] result = await repo . update ( account , fields = ( [string] , ) ) [EOL] [EOL] assert result is True [EOL] [EOL] result = await repo . find_by_key ( user , key = account . key ) [EOL] assert result . balance == [ Balance ( rest = Decimal ( [string] ) , incomes = Decimal ( [string] ) , month = month , ) , Balance ( rest = Decimal ( [string] ) , expenses = Decimal ( [string] ) , month = month . subtract ( months = [number] ) , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_remove_account ( app , user , account ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] [EOL] repo = AccountsDBRepo ( conn ) [EOL] result = await repo . remove ( account ) [EOL] [EOL] assert result is True [EOL] [EOL] count = await conn . fetchval ( [string] , user . key , ) [EOL] assert count == [number] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_remove_account_failed ( app , account ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] repo = AccountsDBRepo ( conn ) [EOL] result = await repo . remove ( account ) [EOL] [EOL] assert result is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from decimal import Decimal [EOL] [EOL] import pytest [comment] [EOL] [EOL] from wallet . domain import Account , Balance , Operation , Tag [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def account ( fake , user , month ) : [EOL] return Account ( key = [number] , name = fake . credit_card_provider ( ) , user = user , balance = [ Balance ( month = month ) ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def operation ( fake , today , account ) : [EOL] return Operation ( key = [number] , amount = Decimal ( [string] ) , account = account , description = [string] , created_on = today ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def tag ( fake , user ) : [EOL] return Tag ( key = [number] , name = fake . word ( ) , user = user ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Iterable [EOL] import typing [EOL] import wallet [EOL] import asyncpg [EOL] from typing import Iterable , List [EOL] [EOL] import pendulum [comment] [EOL] from asyncpg . connection import Connection [comment] [EOL] [EOL] from wallet . domain import Account , Operation , Tag [EOL] [EOL] [EOL] async def prepare_accounts ( conn , accounts ) : [EOL] now = pendulum . today ( ) [EOL] [EOL] for account in accounts : [EOL] query = [string] [EOL] account . key = await conn . fetchval ( query , account . name , account . user . key , True , now ) [EOL] [EOL] query = [string] [EOL] await conn . executemany ( query , [ ( item . rest , item . expenses , item . incomes , item . month , account . key , ) for item in account . balance ] , ) [EOL] [EOL] return accounts [EOL] [EOL] [EOL] async def prepare_operations ( conn , operations ) : [EOL] query = [string] [EOL] [EOL] for operation in operations : [EOL] operation . key = await conn . fetchval ( query , operation . amount , operation . account . key , operation . type . value , operation . description , operation . created_on , ) [EOL] [EOL] if operation . tags : [EOL] await conn . executemany ( [string] , [ ( operation . key , tag . key ) for tag in operation . tags ] , ) [EOL] [EOL] return operations [EOL] [EOL] [EOL] async def prepare_tags ( conn , tags ) : [EOL] now = pendulum . today ( ) [EOL] [EOL] query = [string] [EOL] [EOL] for tag in tags : [EOL] tag . key = await conn . fetchval ( query , tag . name , tag . user . key , True , now ) [EOL] [EOL] return tags [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[wallet.domain.Account]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[wallet.domain.Operation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[wallet.domain.Tag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from tests . storage import prepare_accounts , prepare_operations , prepare_tags [EOL] from wallet . domain import Tag [EOL] from wallet . domain . storage import EntityAlreadyExist [EOL] from wallet . storage . tags import TagsDBRepo [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_add_tag ( fake , app , user , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] repo = TagsDBRepo ( conn ) [EOL] key = await repo . add ( tag ) [EOL] [EOL] assert key == [number] [EOL] [EOL] query = [string] [EOL] name = await conn . fetchval ( query , user . key , key ) [EOL] [EOL] assert name == tag . name [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_add_tag_failed ( fake , app , user , tag ) : [EOL] name = fake . word ( ) [EOL] tag . name = name [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] with pytest . raises ( EntityAlreadyExist ) : [EOL] tag = Tag ( [number] , name , user ) [EOL] [EOL] repo = TagsDBRepo ( conn ) [EOL] await repo . add ( tag ) [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_find_tag_by_key ( fake , app , user , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] repo = TagsDBRepo ( conn ) [EOL] result = await repo . find_by_key ( user , key = tag . key ) [EOL] [EOL] assert result == tag [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_find_tag_by_name ( fake , app , user , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] repo = TagsDBRepo ( conn ) [EOL] result = await repo . find_by_name ( user , name = tag . name ) [EOL] [EOL] assert result == [ tag ] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_find_tags_by_operations ( fake , app , user , account , operation , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_accounts ( conn , [ account ] ) [EOL] await prepare_operations ( conn , [ operation ] ) [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] await conn . execute ( [string] , operation . key , tag . key , ) [EOL] [EOL] repo = TagsDBRepo ( conn ) [EOL] tags = await repo . find_by_operations ( user , ( operation . key , ) ) [EOL] [EOL] assert tags == { operation . key : [ tag ] } [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_rename_tag_name ( fake , app , user , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] tag . name = fake . word ( ) [EOL] [EOL] repo = TagsDBRepo ( conn ) [EOL] result = await repo . update ( tag , fields = ( [string] , ) ) [EOL] [EOL] assert result is True [EOL] [EOL] query = [string] [EOL] name = await conn . fetchval ( query , user . key , tag . key ) [EOL] [EOL] assert name == tag . name [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_update_tag_duplicate_name ( fake , app , user , tag ) : [EOL] another_tag = Tag ( key = [number] , name = fake . word ( ) , user = user ) [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_tags ( conn , [ tag , another_tag ] ) [EOL] [EOL] tag . name = another_tag . name [EOL] [EOL] repo = TagsDBRepo ( conn ) [EOL] result = await repo . update ( tag , fields = ( [string] , ) ) [EOL] [EOL] assert result is False [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_remove_tag ( fake , app , user , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] await prepare_tags ( conn , [ tag ] ) [EOL] [EOL] repo = TagsDBRepo ( conn ) [EOL] result = await repo . remove ( tag ) [EOL] [EOL] assert result is True [EOL] [EOL] query = ( [string] ) [EOL] count = await conn . fetchval ( query , user . key ) [EOL] [EOL] assert count == [number] [EOL] [EOL] [EOL] @ pytest . mark . integration async def test_remove_tag_failed ( fake , app , user , tag ) : [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] tag . key = [number] [EOL] [EOL] repo = TagsDBRepo ( conn ) [EOL] result = await repo . remove ( tag ) [EOL] [EOL] assert result is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import wallet [EOL] from decimal import Decimal [EOL] from typing import Any [EOL] [EOL] import pytest [comment] [EOL] [EOL] from wallet . domain import Account , Operation , Tag , User [EOL] from wallet . domain . storage import AccountsRepo , OperationRepo , Storage , TagsRepo [EOL] [EOL] [EOL] class FakeStorage ( Storage ) : [EOL] def __init__ ( self , accounts , operations , tags ) : [EOL] super ( FakeStorage , self ) . __init__ ( accounts , operations , tags ) [EOL] [EOL] self . was_committed = False [EOL] self . was_rolled_back = False [EOL] [EOL] async def __aenter__ ( self ) : [EOL] return self [EOL] [EOL] async def __aexit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] self . exc_type = exc_type [EOL] self . exc_val = exc_val [EOL] self . exc_tb = exc_tb [EOL] [EOL] await self . rollback ( ) [EOL] [EOL] async def commit ( self ) : [EOL] self . was_committed = True [EOL] [EOL] async def rollback ( self ) : [EOL] self . was_rolled_back = True [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def account ( fake , user ) : [EOL] return Account ( [number] , fake . credit_card_provider ( ) , user = user ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def operation ( fake , today , account ) : [EOL] return Operation ( key = [number] , amount = Decimal ( [string] ) , account = account , description = [string] , created_on = today , ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def tag ( fake , user ) : [EOL] return Tag ( [number] , fake . safe_color_name ( ) , user = user ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def accounts_repo ( ) : [EOL] return AccountsRepo ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def operations_repo ( ) : [EOL] return OperationRepo ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def tags_repo ( ) : [EOL] return TagsRepo [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def storage ( accounts_repo , operations_repo , tags_repo ) : [EOL] return FakeStorage ( accounts_repo , operations_repo , tags_repo ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $wallet.domain.storage.AccountsRepo$ 0 $wallet.domain.storage.OperationRepo$ 0 $wallet.domain.storage.TagsRepo$ 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.storage.AccountsRepo$ 0 $wallet.domain.storage.OperationRepo$ 0 $wallet.domain.storage.TagsRepo$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Account$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $wallet.domain.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] from unittest import mock [EOL] [EOL] import pytest [comment] [EOL] [EOL] from wallet . domain import Tag [EOL] from wallet . domain . storage import EntityAlreadyExist [EOL] from wallet . services . tags import TagsService [EOL] [EOL] [EOL] class TestTagsService : [EOL] @ pytest . mark . unit async def test_add_tag ( self , fake , user , storage ) : [EOL] name = fake . safe_color_name ( ) [EOL] [EOL] add = asyncio . Future ( ) [EOL] add . set_result ( [number] ) [EOL] [EOL] find = asyncio . Future ( ) [EOL] find . set_result ( [ ] ) [EOL] [EOL] storage . tags . add = mock . MagicMock ( return_value = add ) [EOL] storage . tags . find_by_name = mock . MagicMock ( return_value = find ) [EOL] [EOL] service = TagsService ( storage ) [EOL] tag = await service . add ( name , user ) [EOL] [EOL] storage . tags . add . assert_called ( ) [EOL] assert tag == Tag ( key = [number] , name = name , user = user ) [EOL] [EOL] @ pytest . mark . unit async def test_reject_tag_with_duplicate_name ( self , fake , user , storage ) : [EOL] name = fake . safe_color_name ( ) [EOL] [EOL] find = asyncio . Future ( ) [EOL] find . set_result ( [ Tag ( key = [number] , name = name , user = user ) ] ) [EOL] [EOL] storage . tags . find_by_name = mock . MagicMock ( return_value = find ) [EOL] [EOL] with pytest . raises ( EntityAlreadyExist ) : [EOL] service = TagsService ( storage ) [EOL] await service . add ( name , user ) [EOL] [EOL] storage . tags . find_by_name . assert_called ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $asyncio.futures.Future[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] from unittest import mock [EOL] [EOL] import pytest [comment] [EOL] [EOL] from wallet . domain import Account [EOL] from wallet . domain . storage import EntityAlreadyExist [EOL] from wallet . services . accounts import AccountsService [EOL] [EOL] [EOL] class TestAccountsService : [EOL] @ pytest . mark . unit async def test_register_account ( self , fake , user , storage ) : [EOL] name = fake . credit_card_provider ( ) [EOL] [EOL] add = asyncio . Future ( ) [EOL] add . set_result ( [number] ) [EOL] [EOL] find = asyncio . Future ( ) [EOL] find . set_result ( [ ] ) [EOL] [EOL] storage . accounts . add = mock . MagicMock ( return_value = add ) [EOL] storage . accounts . find_by_name = mock . MagicMock ( return_value = find ) [EOL] [EOL] account = Account ( key = [number] , name = name , user = user ) [EOL] [EOL] service = AccountsService ( storage ) [EOL] await service . register ( account ) [EOL] [EOL] storage . accounts . add . assert_called_once ( ) [EOL] assert account == Account ( key = [number] , name = name , user = user ) [EOL] assert storage . was_committed [EOL] [EOL] @ pytest . mark . unit async def test_reject_account_with_duplicate_name ( self , fake , user , storage ) : [EOL] name = fake . credit_card_provider ( ) [EOL] [EOL] find = asyncio . Future ( ) [EOL] find . set_result ( [ Account ( key = [number] , name = name , user = user ) ] ) [EOL] [EOL] storage . accounts . find_by_name = mock . MagicMock ( return_value = find ) [EOL] [EOL] account = Account ( key = [number] , name = name , user = user ) [EOL] [EOL] with pytest . raises ( EntityAlreadyExist ) : [EOL] service = AccountsService ( storage ) [EOL] await service . register ( account ) [EOL] [EOL] storage . accounts . find_by_name . assert_called ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] import asyncio [EOL] import asyncio [EOL] from datetime import datetime [EOL] from decimal import Decimal [EOL] from unittest import mock [EOL] [EOL] import pytest [comment] [EOL] [EOL] from wallet . domain import Operation , OperationType [EOL] from wallet . services . operations import OperationsService [EOL] [EOL] [EOL] class TestOperationsService : [EOL] @ pytest . mark . unit async def test_add_operation_to_account ( self , account , storage ) : [EOL] now = datetime . now ( ) [EOL] [EOL] update_account = asyncio . Future ( ) [EOL] update_account . set_result ( True ) [EOL] [EOL] storage . accounts . update = mock . MagicMock ( return_value = update_account ) [EOL] [EOL] add = asyncio . Future ( ) [EOL] add . set_result ( [number] ) [EOL] [EOL] storage . operations . add = mock . MagicMock ( return_value = add ) [EOL] [EOL] operation = Operation ( key = [number] , amount = Decimal ( [string] ) , account = account , type = OperationType . expense , created_on = now , ) [EOL] [EOL] service = OperationsService ( storage ) [EOL] await service . add_to_account ( account , operation ) [EOL] [EOL] assert operation == Operation ( key = [number] , amount = Decimal ( [string] ) , account = account , type = OperationType . expense , created_on = now , ) [EOL] [EOL] storage . operations . add . assert_called ( ) [EOL] storage . accounts . update . assert_called ( ) [EOL] assert storage . was_committed [EOL] [EOL] @ pytest . mark . unit async def test_remove_operation_from_account ( self , account , operation , storage ) : [EOL] update_account = asyncio . Future ( ) [EOL] update_account . set_result ( True ) [EOL] [EOL] storage . accounts . update = mock . MagicMock ( return_value = update_account ) [EOL] [EOL] remove = asyncio . Future ( ) [EOL] remove . set_result ( True ) [EOL] [EOL] storage . operations . remove = mock . MagicMock ( return_value = remove ) [EOL] [EOL] service = OperationsService ( storage ) [EOL] await service . remove_from_account ( account , operation ) [EOL] [EOL] storage . operations . remove . assert_called ( ) [EOL] storage . accounts . update . assert_called ( ) [EOL] assert storage . was_committed [EOL] [EOL] @ pytest . mark . unit async def test_fetch_operations ( self , account , operation , tag , storage ) : [EOL] operation . tags = [ tag ] [EOL] [EOL] find_by_operations = asyncio . Future ( ) [EOL] find_by_operations . set_result ( { operation . key : [ tag ] } ) [EOL] [EOL] storage . tags . find_by_operations = mock . MagicMock ( return_value = find_by_operations ) [EOL] [EOL] find = asyncio . Future ( ) [EOL] find . set_result ( [ operation ] ) [EOL] [EOL] storage . operations . find = mock . MagicMock ( return_value = find ) [EOL] [EOL] service = OperationsService ( storage ) [EOL] result = await service . fetch ( account ) [EOL] [EOL] assert len ( result ) == [number] [EOL] assert result [ [number] ] == operation [EOL] [EOL] @ pytest . mark . unit async def test_fetch_operation ( self , account , operation , tag , storage ) : [EOL] operation . tags = [ tag ] [EOL] [EOL] find_by_operations = asyncio . Future ( ) [EOL] find_by_operations . set_result ( { operation . key : [ tag ] } ) [EOL] [EOL] storage . tags . find_by_operations = mock . MagicMock ( return_value = find_by_operations ) [EOL] [EOL] find = asyncio . Future ( ) [EOL] find . set_result ( operation ) [EOL] [EOL] storage . operations . find_by_key = mock . MagicMock ( return_value = find ) [EOL] [EOL] service = OperationsService ( storage ) [EOL] result = await service . fetch_by_key ( account , key = operation . key ) [EOL] [EOL] assert result == operation [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0