[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Dict , Optional , Tuple [EOL] import typing [EOL] import builtins [EOL] from abc import ABCMeta , abstractmethod [EOL] from random import expovariate [EOL] from typing import Dict , Optional , Tuple [EOL] [EOL] [EOL] class LatencyPolicy ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def get_delay ( self , src_node , dst_node ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class StaticLatencyPolicy ( LatencyPolicy ) : [EOL] def __init__ ( self , base_delay = [number] ) : [EOL] self . base_delay = base_delay [EOL] self . node2node_delays = { } [EOL] [EOL] def set_delay ( self , src_node , dst_node , delay ) : [EOL] if delay is None : [EOL] self . node2node_delays . pop ( ( src_node , dst_node ) , None ) [EOL] else : [EOL] self . node2node_delays [ ( src_node , dst_node ) ] = delay [EOL] [EOL] def get_delay ( self , src_node , dst_node ) : [EOL] if ( src_node , dst_node ) in self . node2node_delays : [EOL] return self . node2node_delays [ ( src_node , dst_node ) ] [EOL] return self . base_delay [EOL] [EOL] [EOL] class ExponentiallyDistributedLatencyPolicy ( LatencyPolicy ) : [EOL] def __init__ ( self , avg_delay = [number] ) : [EOL] self . avg_delay = avg_delay [EOL] self . node2node_avg_delays = { } [EOL] [EOL] def set_avg_delay ( self , src_node , dst_node , avg_delay ) : [EOL] if avg_delay is None : [EOL] self . node2node_avg_delays . pop ( ( src_node , dst_node ) , None ) [EOL] else : [EOL] self . node2node_avg_delays [ ( src_node , dst_node ) ] = avg_delay [EOL] [EOL] def get_delay ( self , src_node , dst_node ) : [EOL] if ( src_node , dst_node ) in self . node2node_avg_delays : [EOL] avg_delay = self . node2node_avg_delays [ ( src_node , dst_node ) ] [EOL] else : [EOL] avg_delay = self . avg_delay [EOL] [EOL] if avg_delay == [number] : [EOL] return [number] [EOL] [EOL] return expovariate ( [number] / avg_delay ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Dict[typing.Tuple[builtins.int,builtins.int],builtins.float]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Dict[typing.Tuple[builtins.int,builtins.int],builtins.float]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Literal , Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import typing_extensions [EOL] from psutil import net_connections [EOL] [EOL] [EOL] def get_pid_for_network_client ( server_port , client_port ) : [EOL] enforce_host = ( [string] , [string] ) [EOL] all_connections = net_connections ( kind = [string] ) [EOL] [EOL] for connection in all_connections : [EOL] if ( connection . laddr == ( ) or connection . raddr == ( ) or connection . laddr [ [number] ] not in enforce_host or connection . raddr [ [number] ] not in enforce_host ) : [EOL] continue [comment] [EOL] if client_port == connection . laddr [ [number] ] : [EOL] if server_port != connection . raddr [ [number] ] : [EOL] continue [EOL] else : [EOL] continue [EOL] if [string] == connection . status : [EOL] continue [comment] [EOL] [EOL] return connection . pid [EOL] [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] def get_pid_for_network_server ( server_port ) : [EOL] enforce_host = ( [string] , [string] ) [EOL] all_connections = net_connections ( kind = [string] ) [EOL] [EOL] for connection in all_connections : [EOL] if connection . laddr [ [number] ] not in enforce_host : [EOL] continue [EOL] if server_port != connection . laddr [ [number] ] : [EOL] continue [EOL] if [string] != connection . status : [EOL] continue [EOL] [EOL] return connection . pid [EOL] [EOL] raise RuntimeError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import BinaryIO , Optional [EOL] import typing [EOL] import builtins [EOL] from abc import ABCMeta , abstractmethod [EOL] from time import time as time_time [EOL] from typing import BinaryIO , Optional [EOL] [EOL] [EOL] class NetworkStatsCollector ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def register_event ( self , command_name , command_size , src_node_id , dst_node_id ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def close ( self ) : [EOL] pass [EOL] [EOL] [EOL] class CsvNetworkStatsCollector ( NetworkStatsCollector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , output_file ) : [EOL] self . output_file = output_file [EOL] self . running = True [EOL] [EOL] def register_event ( self , command_name , command_size , src_node_id , dst_node_id ) : [EOL] if not self . running : [EOL] return [EOL] [EOL] self . output_file . write ( ( f'{ int ( time_time ( ) * [number] ) } [string] { src_node_id } [string] { dst_node_id } [string] ' f'{ command_name } [string] { command_size } [string] ' ) . encode ( ) ) [EOL] [EOL] def close ( self ) : [EOL] if not self . running : [EOL] return [EOL] [EOL] self . running = False [EOL] [EOL] if ( self . output_file is not None and not self . output_file . closed ) : [EOL] self . output_file . close ( ) [EOL] [EOL] [EOL] class NullNetworkStatsCollector ( NetworkStatsCollector ) : [EOL] def register_event ( self , command_name , command_size , src_node_id , dst_node_id ) : [EOL] pass [EOL] [EOL] def close ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.BinaryIO$ 0 0 0 0 0 $typing.BinaryIO$ 0 $typing.BinaryIO$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import network [EOL] from network . latencies import ( ExponentiallyDistributedLatencyPolicy , StaticLatencyPolicy ) [EOL] [EOL] [EOL] def test_static_latency_policy ( ) : [EOL] latency_policy = StaticLatencyPolicy ( base_delay = [number] ) [EOL] [EOL] assert ( latency_policy . get_delay ( [number] , [number] ) == [number] ) [EOL] assert ( latency_policy . get_delay ( [number] , [number] ) == [number] ) [EOL] [EOL] latency_policy . set_delay ( src_node = [number] , dst_node = [number] , delay = [number] ) [EOL] latency_policy . set_delay ( src_node = [number] , dst_node = [number] , delay = [number] ) [EOL] [EOL] assert ( latency_policy . get_delay ( [number] , [number] ) == [number] ) [EOL] assert ( latency_policy . get_delay ( [number] , [number] ) == [number] ) [EOL] [EOL] latency_policy . set_delay ( src_node = [number] , dst_node = [number] , delay = None ) [EOL] latency_policy . set_delay ( src_node = [number] , dst_node = [number] , delay = None ) [EOL] [EOL] assert ( latency_policy . get_delay ( src_node = [number] , dst_node = [number] ) == [number] ) [EOL] assert ( latency_policy . get_delay ( src_node = [number] , dst_node = [number] ) == [number] ) [EOL] [EOL] [EOL] def test_exponentially_distributed_latency_policy ( ) : [EOL] [comment] [EOL] latency_policy = ExponentiallyDistributedLatencyPolicy ( avg_delay = [number] ) [EOL] assert ( latency_policy . get_delay ( [number] , [number] ) == [number] ) [EOL] assert ( latency_policy . get_delay ( [number] , [number] ) == [number] ) [EOL] [EOL] [comment] [EOL] latency_policy = ExponentiallyDistributedLatencyPolicy ( avg_delay = [number] ) [EOL] [EOL] [comment] [EOL] assert ( [number] == len ( { latency_policy . get_delay ( [number] , [number] ) for _ in range ( [number] ) } ) ) [EOL] assert ( [number] == len ( { latency_policy . get_delay ( [number] , [number] ) for _ in range ( [number] ) } ) ) [EOL] [EOL] [comment] [EOL] n = [number] [EOL] assert ( abs ( [number] - ( sum ( [ latency_policy . get_delay ( [number] , [number] ) for _ in range ( n ) ] ) / n ) ) < [number] ) [EOL] assert ( abs ( [number] - ( sum ( [ latency_policy . get_delay ( [number] , [number] ) for _ in range ( n ) ] ) / n ) ) < [number] ) [EOL] [EOL] [comment] [EOL] latency_policy . set_avg_delay ( src_node = [number] , dst_node = [number] , avg_delay = [number] ) [EOL] latency_policy . set_avg_delay ( src_node = [number] , dst_node = [number] , avg_delay = [number] ) [EOL] [EOL] [comment] [EOL] assert ( [number] == len ( { latency_policy . get_delay ( [number] , [number] ) for _ in range ( [number] ) } ) ) [EOL] assert ( [number] == len ( { latency_policy . get_delay ( [number] , [number] ) for _ in range ( [number] ) } ) ) [EOL] [EOL] [comment] [EOL] n = [number] [EOL] assert ( abs ( [number] - ( sum ( [ latency_policy . get_delay ( [number] , [number] ) for _ in range ( n ) ] ) / n ) ) < [number] ) [EOL] assert ( abs ( [number] - ( sum ( [ latency_policy . get_delay ( [number] , [number] ) for _ in range ( n ) ] ) / n ) ) < [number] ) [EOL] [EOL] [comment] [EOL] latency_policy . set_avg_delay ( src_node = [number] , dst_node = [number] , avg_delay = None ) [EOL] latency_policy . set_avg_delay ( src_node = [number] , dst_node = [number] , avg_delay = None ) [EOL] [EOL] [comment] [EOL] n = [number] [EOL] assert ( abs ( [number] - ( sum ( [ latency_policy . get_delay ( [number] , [number] ) for _ in range ( n ) ] ) / n ) ) < [number] ) [EOL] assert ( abs ( [number] - ( sum ( [ latency_policy . get_delay ( [number] , [number] ) for _ in range ( n ) ] ) / n ) ) < [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import network [EOL] import unittest [EOL] from typing import BinaryIO [EOL] from unittest . mock import Mock , patch [EOL] [EOL] from network . stats import ( CsvNetworkStatsCollector , NullNetworkStatsCollector ) [EOL] [EOL] [EOL] def test_csv_network_stats_collector ( ) : [EOL] mocked_file = Mock ( spec = BinaryIO ) [EOL] network_stats_collector = CsvNetworkStatsCollector ( output_file = mocked_file ) [EOL] [EOL] with patch ( target = [string] , new = lambda : [number] ) : [EOL] network_stats_collector . register_event ( command_name = [string] , command_size = [number] , src_node_id = [number] , dst_node_id = [number] ) [EOL] network_stats_collector . close ( ) [EOL] [EOL] mocked_file . write . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_null_network_stats_collector ( ) : [EOL] [comment] [EOL] [comment] [EOL] network_stats_collector = NullNetworkStatsCollector ( ) [EOL] network_stats_collector . register_event ( command_name = [string] , command_size = [number] , src_node_id = [number] , dst_node_id = [number] ) [EOL] network_stats_collector . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import socket [EOL] import typing [EOL] import builtins [EOL] import asyncio [EOL] from asyncio import ( AbstractEventLoop , start_server , ) [EOL] from os import getpid [EOL] from random import randint [EOL] from socket import ( AF_INET , SOCK_STREAM , socket as socket_socket ) [EOL] [EOL] import pytest [EOL] [EOL] from network . utils import get_pid_for_network_client [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_pid_for_tcp_connection_port ( event_loop ) : [EOL] [comment] [EOL] server_port , server = await __get_server ( event_loop ) [EOL] listening_port = server . sockets [ [number] ] . getsockname ( ) [ [number] ] [EOL] [EOL] [comment] [EOL] client_socket = await event_loop . run_in_executor ( None , __get_client_socket , listening_port ) [EOL] [EOL] [comment] [EOL] client_port = client_socket . getsockname ( ) [ [number] ] [EOL] client_pid = get_pid_for_network_client ( client_port = client_port , server_port = server_port ) [EOL] assert ( getpid ( ) == client_pid ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( expected_exception = RuntimeError , match = [string] ) : [EOL] get_pid_for_network_client ( client_port = listening_port , server_port = server_port + [number] ) [EOL] [EOL] with pytest . raises ( expected_exception = RuntimeError , match = [string] ) : [EOL] get_pid_for_network_client ( client_port = listening_port + [number] , server_port = server_port ) [EOL] [EOL] client_socket . close ( ) [EOL] server . close ( ) [EOL] [EOL] [EOL] async def __get_server ( event_loop ) : [EOL] server_port = randint ( [number] , [number] ) [EOL] [EOL] server = await start_server ( client_connected_cb = ( lambda reader , writer : None ) , host = [string] , port = server_port , loop = event_loop ) [EOL] [EOL] assert ( server . sockets is not None ) [EOL] assert ( [number] == len ( server . sockets ) ) [EOL] [EOL] return server_port , server [EOL] [EOL] [EOL] def __get_client_socket ( listening_port ) : [EOL] client_socket = socket_socket ( AF_INET , SOCK_STREAM ) [EOL] client_socket . connect ( ( [string] , listening_port ) ) [EOL] [EOL] return client_socket [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , DefaultDict , Set , Dict , Tuple , List [EOL] import typing [EOL] from collections import defaultdict [EOL] from itertools import product as cartesian_product [EOL] [EOL] from experiments . graph import ( compute_degrees , create_simple_dense_graph , create_static_graph , create_growing_graph , create_preferential_attachment_graph , degrees_distribution , enforce_nodes_reconnections , get_node_neighbours , weighted_random_int , ) [EOL] [EOL] [EOL] torus_grid_7x7_rd = { e for ep in { ( ( i * [number] + j , i * [number] + ( j + [number] ) % [number] ) , ( i * [number] + j , ( ( ( i + [number] ) % [number] ) * [number] + j ) ) ) for i in range ( [number] ) for j in range ( [number] ) } for e in ep } [EOL] torus_grid_7x7_lu = { e for ep in { ( ( i * [number] + j , i * [number] + ( j - [number] ) % [number] ) , ( i * [number] + j , ( ( ( i - [number] ) % [number] ) * [number] + j ) ) ) for i in range ( [number] ) for j in range ( [number] ) } for e in ep } [EOL] [EOL] [EOL] def test_degrees_distribution ( ) : [EOL] assert [ [number] , [number] , [number] , [number] , [number] , [number] ] == degrees_distribution ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] assert [ [number] , [number] , [number] , [number] , [number] , [number] ] == degrees_distribution ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_weighted_random_int ( ) : [EOL] range5 = list ( range ( [number] ) ) [EOL] [EOL] counter = defaultdict ( int ) [EOL] for _ in range ( [number] ) : [EOL] rnd = weighted_random_int ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] counter [ rnd ] += [number] [EOL] assert rnd in range5 [EOL] for i in range ( [number] , [number] ) : [EOL] assert counter [ i - [number] ] < counter [ i ] [EOL] [EOL] counter = defaultdict ( int ) [EOL] for _ in range ( [number] ) : [EOL] rnd = weighted_random_int ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] counter [ rnd ] += [number] [EOL] assert rnd in range5 [EOL] for i in range ( [number] , [number] ) : [EOL] assert counter [ i - [number] ] > counter [ i ] [EOL] [EOL] [EOL] def test_get_node_neighbours ( ) : [EOL] assert { [number] , [number] , [number] , [number] } == get_node_neighbours ( node_id = [number] , graph_edges = torus_grid_7x7_rd , degree = [number] ) [EOL] assert { [number] , [number] , [number] , [number] } == get_node_neighbours ( node_id = [number] , graph_edges = torus_grid_7x7_lu , degree = [number] ) [EOL] assert { [number] , [number] , [number] , [number] } == get_node_neighbours ( node_id = [number] , graph_edges = torus_grid_7x7_rd , degree = [number] ) [EOL] assert { [number] , [number] , [number] , [number] } == get_node_neighbours ( node_id = [number] , graph_edges = torus_grid_7x7_lu , degree = [number] ) [EOL] [EOL] assert { [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] } == get_node_neighbours ( node_id = [number] , graph_edges = torus_grid_7x7_rd , degree = [number] ) [EOL] assert { [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] } == get_node_neighbours ( node_id = [number] , graph_edges = torus_grid_7x7_lu , degree = [number] ) [EOL] assert { [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] } == get_node_neighbours ( node_id = [number] , graph_edges = torus_grid_7x7_rd , degree = [number] ) [EOL] assert { [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] } == get_node_neighbours ( node_id = [number] , graph_edges = torus_grid_7x7_lu , degree = [number] ) [EOL] [EOL] [EOL] def test_compute_degrees ( ) : [EOL] [comment] [EOL] degrees , _ = compute_degrees ( torus_grid_7x7_rd , [number] * [number] ) [EOL] assert [number] * [number] == len ( degrees ) [EOL] for i in degrees : [EOL] assert [number] == degrees [ i ] [EOL] [EOL] degrees , _ = compute_degrees ( torus_grid_7x7_lu , [number] * [number] ) [EOL] assert [number] * [number] == len ( degrees ) [EOL] for i in degrees : [EOL] assert [number] == degrees [ i ] [EOL] [EOL] [comment] [EOL] g = torus_grid_7x7_rd . copy ( ) [EOL] g . add ( ( [number] , [number] ) ) [EOL] degrees , _ = compute_degrees ( g , [number] * [number] ) [EOL] assert [number] == degrees [ [number] ] [EOL] assert [number] == degrees [ [number] ] [EOL] for i in degrees : [EOL] assert i in [ [number] , [number] ] or [number] == degrees [ i ] [EOL] [EOL] [comment] [EOL] g . add ( ( [number] , [number] ) ) [EOL] degrees , processed_edges = compute_degrees ( g , [number] * [number] ) [EOL] assert [number] == degrees [ [number] ] [EOL] assert [number] == degrees [ [number] ] [EOL] for i in degrees : [EOL] assert i in [ [number] , [number] ] or [number] == degrees [ i ] [EOL] [EOL] [comment] [EOL] g = g . union ( { ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) } ) [EOL] [EOL] degrees , _ = compute_degrees ( g , [number] * [number] + [number] , processed_edges , degrees ) [EOL] assert [number] == degrees [ [number] ] [EOL] assert [number] == degrees [ [number] ] [EOL] assert [number] == degrees [ [number] ] [EOL] assert [number] == degrees [ [number] ] [EOL] assert [number] == degrees [ [number] ] [EOL] for i in degrees : [EOL] assert i in [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] or [number] == degrees [ i ] [EOL] [EOL] [EOL] def test_enforce_nodes_reconnections ( ) : [EOL] g = torus_grid_7x7_rd . copy ( ) [EOL] idg = { i : [number] for i in range ( [number] * [number] ) } [EOL] [EOL] g2 , idg2 = enforce_nodes_reconnections ( graph_edges = g , inbound_degrees = idg ) [EOL] [EOL] assert g is not g2 [EOL] assert len ( g ) == len ( g2 ) [EOL] [EOL] assert idg is not idg2 [EOL] assert set ( idg . keys ( ) ) == set ( idg2 . keys ( ) ) [EOL] assert min ( idg2 . values ( ) ) >= [number] [EOL] assert max ( idg2 . values ( ) ) <= [number] [EOL] [EOL] degrees , _ = compute_degrees ( g2 , [number] * [number] ) [EOL] assert min ( degrees ) >= [number] [EOL] assert max ( degrees ) <= [number] [EOL] for d in idg2 : [EOL] assert idg2 [ d ] <= degrees [ d ] [EOL] [EOL] [EOL] def test_create_static_graph ( ) : [EOL] g , d = create_static_graph ( num_nodes = [number] , num_outbound_connections = [number] ) [EOL] [EOL] assert [number] * [number] == len ( g ) [EOL] for i in range ( [number] ) : [EOL] assert [number] == len ( { e for e in g if e [ [number] ] == i } ) [EOL] assert ( i , i ) not in g [EOL] [EOL] [EOL] def test_create_growing_graph ( ) : [EOL] g , d = create_growing_graph ( num_nodes = [number] , num_outbound_connections = [number] ) [EOL] [EOL] assert [number] * [number] == len ( g ) [EOL] for i in range ( [number] ) : [EOL] assert [number] == len ( { e for e in g if e [ [number] ] == i } ) [EOL] assert ( i , i ) not in g [EOL] [EOL] assert max ( d . values ( ) ) >= [number] [EOL] assert d [ [number] ] == [number] [EOL] [EOL] [EOL] def test_create_preferential_attachment_graph ( ) : [EOL] g , d = create_preferential_attachment_graph ( num_nodes = [number] , num_outbound_connections = [number] ) [EOL] [EOL] assert [number] * [number] == len ( g ) [EOL] for i in range ( [number] ) : [EOL] assert [number] == len ( { e for e in g if e [ [number] ] == i } ) [EOL] assert ( i , i ) not in g [EOL] [EOL] assert max ( d . values ( ) ) >= [number] [EOL] assert d [ [number] ] == [number] [EOL] [EOL] [EOL] def test_create_simple_dense_graph ( ) : [EOL] all_node_ids = list ( range ( [number] , [number] , [number] ) ) [EOL] [EOL] for graph_size , outbound_degree in cartesian_product ( range ( [number] , [number] ) , range ( [number] , [number] ) ) : [EOL] node_ids = all_node_ids [ : graph_size ] [EOL] graph = create_simple_dense_graph ( node_ids = node_ids , num_outbound_connections = outbound_degree ) [EOL] [EOL] for node_id in node_ids : [EOL] assert ( node_id , node_id ) not in graph [EOL] assert len ( { ( i , j ) for i , j in graph if i == node_id } ) == min ( len ( node_ids ) - [number] , outbound_degree ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import blockchain [EOL] from blockchain . simnet import SimNet [EOL] [EOL] [EOL] def test_simnet_run ( ) : [EOL] simnet = SimNet ( simulation_time = [number] , num_proposer_nodes = [number] , num_relay_nodes = [number] , time_between_blocks = [number] , block_time_mask = [number] , difficulty_adjustment_window = [number] , difficulty_adjustment_period = [number] , num_blocks_for_median_timestamp = [number] , max_future_block_time_seconds = [number] , latency = [number] , processing_time = [number] ) [EOL] simnet . run ( ) [EOL] [EOL] assert len ( simnet . nodes ) == [number] [EOL] for node in simnet . nodes : [EOL] [comment] [EOL] assert [number] / [number] / [number] < node . main_chain . height < [number] * [number] / [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set [EOL] import blockchain [EOL] import typing [EOL] import network [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] from blockchain . block import Block [EOL] from blockchain . blockchain import BlockChain , CheatedClock [EOL] from blockchain . simple_node import SimpleNode [EOL] from network . latencies import LatencyPolicy , StaticLatencyPolicy [EOL] [EOL] [EOL] def test_receive_message ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] node = SimpleNode ( node_id = [number] , latency_policy = Mock ( spec = LatencyPolicy ) , chain = BlockChain ( genesis = Block . genesis ( ) , clock = CheatedClock ( [number] ) ) , initial_coins = set ( ) , processing_time = [number] ) [EOL] [EOL] assert [number] == len ( node . incoming_messages ) [EOL] [EOL] fake_block = Mock ( spec = Block ) [EOL] node . receive_message ( arrival_time = [number] , msg = fake_block , source_id = [number] ) [EOL] node . receive_message ( arrival_time = [number] , msg = fake_block , source_id = [number] ) [EOL] node . receive_message ( arrival_time = [number] , msg = fake_block , source_id = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert [number] == len ( node . incoming_messages ) [EOL] assert ( [number] , fake_block , [number] ) == node . incoming_messages [ [number] ] [EOL] assert ( [number] , fake_block , [number] ) == node . incoming_messages [ [number] ] [EOL] assert ( [number] , fake_block , [number] ) == node . incoming_messages [ [number] ] [EOL] [EOL] [EOL] def test_process_messages ( ) : [EOL] clock = CheatedClock ( time = [number] ) [EOL] latency_policy = StaticLatencyPolicy ( base_delay = [number] ) [EOL] genesis = Block . genesis ( timestamp = [number] , compact_target = [string] , vout = [ [number] , [number] , [number] , [number] ] ) [EOL] funds_a = set ( genesis . coinstake_tx . get_all_coins ( ) [ : [number] ] ) [EOL] funds_d = set ( genesis . coinstake_tx . get_all_coins ( ) [ [number] : ] ) [EOL] [EOL] [comment] [EOL] node_a = SimpleNode ( node_id = [number] , latency_policy = latency_policy , chain = BlockChain ( genesis = genesis , clock = clock ) , initial_coins = funds_a , processing_time = [number] , is_proposer = True ) [EOL] node_b = SimpleNode ( node_id = [number] , latency_policy = latency_policy , chain = BlockChain ( genesis = genesis , clock = clock ) , initial_coins = set ( ) , processing_time = [number] , is_proposer = False ) [EOL] node_c = SimpleNode ( node_id = [number] , latency_policy = latency_policy , chain = BlockChain ( genesis = genesis , clock = clock ) , initial_coins = set ( ) , processing_time = [number] , is_proposer = False ) [EOL] [EOL] [comment] [EOL] node_a . add_outbound_peer ( node_b ) [EOL] node_b . add_outbound_peer ( node_c ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] clock . advance_time ( [number] ) [comment] [EOL] [EOL] assert node_a . main_chain . height == [number] [EOL] assert node_a . try_to_propose ( ) [comment] [EOL] [EOL] assert node_a . main_chain . height == [number] [EOL] assert node_b . main_chain . height == [number] [EOL] assert node_c . main_chain . height == [number] [EOL] [EOL] node_b . process_messages ( ) [comment] [EOL] node_c . process_messages ( ) [EOL] assert node_a . main_chain . height == [number] [EOL] assert node_b . main_chain . height == [number] [EOL] assert node_c . main_chain . height == [number] [EOL] [EOL] clock . advance_time ( [number] ) [comment] [EOL] node_b . process_messages ( ) [comment] [EOL] node_c . process_messages ( ) [EOL] assert node_a . main_chain . height == [number] [EOL] assert node_b . main_chain . height == [number] [EOL] assert node_c . main_chain . height == [number] [EOL] [EOL] clock . advance_time ( [number] ) [comment] [EOL] node_b . process_messages ( ) [EOL] node_c . process_messages ( ) [EOL] assert node_a . main_chain . height == [number] [EOL] assert node_b . main_chain . height == [number] [comment] [EOL] assert node_c . main_chain . height == [number] [EOL] [EOL] clock . advance_time ( [number] ) [comment] [EOL] node_b . process_messages ( ) [EOL] node_c . process_messages ( ) [EOL] assert node_a . main_chain . height == [number] [EOL] assert node_b . main_chain . height == [number] [EOL] assert node_c . main_chain . height == [number] [comment] [EOL] [EOL] clock . advance_time ( [number] ) [comment] [EOL] node_b . process_messages ( ) [EOL] node_c . process_messages ( ) [EOL] assert node_a . main_chain . height == [number] [EOL] assert node_b . main_chain . height == [number] [EOL] assert node_c . main_chain . height == [number] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert [number] == len ( node_a . alternative_chains ) [EOL] assert [number] == len ( node_b . alternative_chains ) [EOL] assert [number] == len ( node_c . alternative_chains ) [EOL] [EOL] node_d = SimpleNode ( node_id = [number] , latency_policy = latency_policy , chain = BlockChain ( genesis = genesis , clock = clock ) , initial_coins = funds_d , processing_time = [number] , is_proposer = True ) [EOL] [comment] [EOL] [comment] [EOL] node_d . add_outbound_peer ( node_b ) [EOL] [EOL] assert node_d . try_to_propose ( ) [comment] [EOL] chain_b = node_b . main_chain [comment] [EOL] [EOL] clock . advance_time ( [number] ) [comment] [EOL] node_b . process_messages ( ) [EOL] [EOL] assert node_d . main_chain . height == [number] [EOL] assert node_b . main_chain . height == [number] [comment] [EOL] assert len ( node_d . alternative_chains ) == [number] [comment] [EOL] assert len ( node_b . alternative_chains ) == [number] [comment] [EOL] [EOL] [comment] [EOL] assert node_b . main_chain is chain_b [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert node_d . try_to_propose ( ) [EOL] clock . advance_time ( [number] ) [comment] [EOL] node_b . process_messages ( ) [EOL] [EOL] assert node_d . main_chain . height == [number] [EOL] assert node_b . main_chain . height == [number] [EOL] assert len ( node_d . alternative_chains ) == [number] [comment] [EOL] assert len ( node_b . alternative_chains ) == [number] [comment] [EOL] assert node_b . main_chain is not chain_b [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert len ( node_a . orphan_blocks ) == [number] [EOL] [EOL] [comment] [EOL] node_a . receive_message ( arrival_time = [number] , msg = node_d . main_chain . blocks [ - [number] ] , source_id = node_d . node_id ) [EOL] clock . advance_time ( [number] ) [comment] [EOL] [EOL] node_a . process_messages ( ) [EOL] assert len ( node_a . orphan_blocks ) == [number] [comment] [EOL] assert len ( node_a . alternative_chains ) == [number] [comment] [EOL] assert node_a . main_chain . height == [number] [comment] [EOL] [EOL] [comment] [EOL] node_a . receive_message ( arrival_time = [number] , msg = node_d . main_chain . blocks [ - [number] ] , source_id = node_d . node_id ) [EOL] clock . advance_time ( [number] ) [comment] [EOL] [EOL] node_a . process_messages ( ) [EOL] assert len ( node_a . orphan_blocks ) == [number] [comment] [EOL] assert len ( node_a . alternative_chains ) == [number] [comment] [EOL] assert node_a . main_chain . height == [number] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] clock . advance_time ( [number] ) [EOL] node_b . process_messages ( ) [EOL] node_c . process_messages ( ) [EOL] assert len ( node_b . incoming_messages ) == [number] [comment] [EOL] assert len ( node_c . incoming_messages ) == [number] [EOL] [EOL] [comment] [EOL] node_c . receive_message ( arrival_time = clock . get_time ( ) + [number] , msg = node_c . main_chain . blocks [ - [number] ] , source_id = [number] ) [EOL] node_c . receive_message ( arrival_time = clock . get_time ( ) + [number] , msg = node_c . main_chain . blocks [ - [number] ] , source_id = [number] ) [EOL] node_c . receive_message ( arrival_time = clock . get_time ( ) + [number] , msg = node_c . main_chain . blocks [ - [number] ] , source_id = [number] ) [EOL] [EOL] clock . advance_time ( [number] ) [EOL] [EOL] assert node_c . process_messages ( ) == [number] [comment] [EOL] assert len ( node_c . incoming_messages ) == [number] [EOL] assert len ( node_c . alternative_chains ) == [number] [EOL] assert node_c . main_chain . height == [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] node_c . receive_message ( arrival_time = clock . get_time ( ) + [number] , msg = node_c . alternative_chains [ [number] ] . blocks [ - [number] ] , source_id = [number] ) [EOL] clock . advance_time ( [number] ) [EOL] [EOL] assert node_c . process_messages ( ) == [number] [EOL] assert len ( node_c . incoming_messages ) == [number] [EOL] assert len ( node_c . alternative_chains ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any , Set [EOL] import blockchain [EOL] import typing [EOL] import pytest [EOL] [EOL] from blockchain . block import Block [EOL] from blockchain . blockchain import BlockChain , BiasedClock , CheatedClock [EOL] from blockchain . transaction import CoinStakeTransaction [EOL] [EOL] [EOL] def test_cheated_clock ( ) : [EOL] with pytest . raises ( expected_exception = AssertionError ) : [EOL] CheatedClock ( - [number] ) [EOL] clock = CheatedClock ( [number] ) [EOL] assert clock . get_time ( ) == [number] [EOL] [EOL] clock . advance_time ( ) [EOL] assert clock . get_time ( ) == [number] [EOL] [EOL] [EOL] def test_biased_clock ( ) : [EOL] base_clock = CheatedClock ( [number] ) [EOL] [EOL] avg_time = [number] [EOL] for _ in range ( [number] ) : [EOL] biased_clock = BiasedClock ( base_clock = base_clock ) [EOL] avg_time += biased_clock . get_time ( ) [EOL] avg_time /= [number] [EOL] assert abs ( [number] - avg_time ) < [number] [EOL] [EOL] [EOL] def test_blockchain_get_chain_work ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] genesis_block = Block . genesis ( timestamp = [number] , compact_target = [string] ) [EOL] [EOL] [comment] [EOL] blockchain_a = BlockChain ( genesis = genesis_block , clock = CheatedClock ( [number] ) , max_future_block_time_seconds = [number] , time_between_blocks = [number] , block_time_mask = [number] , difficulty_adjustment_period = [number] , difficulty_adjustment_window = [number] ) [EOL] [EOL] coins = set ( genesis_block . coinstake_tx . get_all_coins ( ) ) [EOL] for _ in range ( [number] ) : [EOL] min_timestamp = None [comment] [EOL] candidates = [ ] [EOL] while [number] == len ( candidates ) : [EOL] candidates = sorted ( [ b for b in ( blockchain_a . get_valid_block ( coinstake_tx = CoinStakeTransaction ( vin = [ coin ] ) , min_timestamp = min_timestamp , greedy_proposal = True ) for coin in coins ) if b is not None ] , key = lambda bb : bb . coinstake_tx . vin [ [number] ] ) [EOL] [EOL] blockchain_a . clock . advance_time ( [number] ) [EOL] min_timestamp = blockchain_a . clock . get_time ( ) + blockchain_a . max_future_block_time_seconds - [number] [EOL] [EOL] [comment] [EOL] block = candidates [ [number] ] [EOL] tx = block . coinstake_tx [EOL] [EOL] blockchain_a . add_block ( block ) [comment] [EOL] coins . difference_update ( tx . vin ) [comment] [EOL] coins . update ( tx . get_all_coins ( ) ) [comment] [EOL] [EOL] [comment] [EOL] blockchain_b = BlockChain ( genesis = genesis_block , clock = CheatedClock ( [number] ) , max_future_block_time_seconds = [number] , time_between_blocks = [number] , block_time_mask = [number] , difficulty_adjustment_period = [number] , difficulty_adjustment_window = [number] ) [EOL] coins = set ( genesis_block . coinstake_tx . get_all_coins ( ) ) [EOL] for _ in range ( [number] ) : [EOL] stakeable_coins = sorted ( list ( coins ) , key = lambda c : c . height ) [ : max ( [number] , len ( coins ) // [number] ) ] [EOL] [EOL] min_timestamp = None [comment] [EOL] candidates = [ ] [EOL] while [number] == len ( candidates ) : [EOL] candidates = sorted ( [ b for b in ( blockchain_b . get_valid_block ( coinstake_tx = CoinStakeTransaction ( vin = [ coin ] ) , min_timestamp = min_timestamp , greedy_proposal = True ) for coin in stakeable_coins ) if b is not None ] , key = lambda bb : bb . coinstake_tx . vin [ [number] ] ) [EOL] [EOL] blockchain_b . clock . advance_time ( [number] ) [EOL] min_timestamp = blockchain_b . clock . get_time ( ) + blockchain_b . max_future_block_time_seconds - [number] [EOL] [EOL] [comment] [EOL] block = candidates [ [number] ] [EOL] tx = block . coinstake_tx [EOL] [EOL] blockchain_b . add_block ( block ) [comment] [EOL] coins . difference_update ( tx . vin ) [comment] [EOL] coins . update ( tx . get_all_coins ( ) ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert blockchain_a . get_next_compact_target ( ) < blockchain_b . get_next_compact_target ( ) [EOL] assert blockchain_a . get_chain_work ( ) > blockchain_b . get_chain_work ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , Optional , Set , Union , Tuple , List [EOL] import blockchain [EOL] import typing [EOL] from itertools import product as cartesian_product [EOL] [EOL] from blockchain import zeroes_uint256 [EOL] from blockchain . block import Block [EOL] from blockchain . transaction import CoinStakeTransaction [EOL] from blockchain . utils import ( compact_target_to_bigint , compact_target_to_uint256 ) [EOL] [EOL] [EOL] def test_block_block_hash ( ) : [EOL] uncombined_params = [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ CoinStakeTransaction . genesis ( ) ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ] [EOL] block_params = list ( cartesian_product ( * uncombined_params ) ) [EOL] [EOL] hashes = set ( ) [EOL] for params in block_params : [EOL] block = Block ( prev_block_hash = params [ [number] ] , prev_block_stake_modifier = params [ [number] ] , compact_target = params [ [number] ] , coinstake_tx = params [ [number] ] , timestamp = params [ [number] ] ) [EOL] [EOL] test_hash = block . block_hash ( ) [comment] [EOL] assert len ( test_hash ) == [number] [EOL] hashes . add ( test_hash ) [EOL] [EOL] [comment] [EOL] assert len ( hashes ) == len ( block_params ) / len ( uncombined_params [ [number] ] ) [EOL] [EOL] [EOL] def test_block_try_to_be_valid ( ) : [EOL] [comment] [EOL] genesis = Block . genesis ( ) [EOL] [EOL] assert genesis . kernel_hash ( ) < compact_target_to_uint256 ( genesis . compact_target ) [EOL] assert int . from_bytes ( genesis . kernel_hash ( ) , [string] ) < compact_target_to_bigint ( genesis . compact_target ) [EOL] [EOL] valid_block_01 = Block . genesis ( ) . try_to_be_valid ( max_timestamp = [number] , time_mask = [number] ) [EOL] assert valid_block_01 . block_hash ( ) == genesis . block_hash ( ) [EOL] assert valid_block_01 . kernel_hash ( ) == genesis . kernel_hash ( ) [EOL] [EOL] [comment] [EOL] none_block = Block ( prev_block_hash = zeroes_uint256 , prev_block_stake_modifier = zeroes_uint256 , compact_target = [string] , coinstake_tx = CoinStakeTransaction . genesis ( ) , timestamp = [number] ) . try_to_be_valid ( max_timestamp = [number] , time_mask = [number] ) [EOL] assert none_block is None [EOL] [EOL] [comment] [EOL] valid_block_02 = Block ( prev_block_hash = zeroes_uint256 , prev_block_stake_modifier = zeroes_uint256 , compact_target = [string] , coinstake_tx = CoinStakeTransaction . genesis ( ) , timestamp = [number] ) . try_to_be_valid ( max_timestamp = [number] ** [number] , time_mask = [number] ) [EOL] [EOL] assert valid_block_02 is not None [EOL] assert valid_block_02 . kernel_hash ( ) < compact_target_to_uint256 ( valid_block_02 . compact_target ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from struct import pack [EOL] [EOL] from blockchain . utils import ( compact_target_to_uint256 , uint256_to_compact_target ) [EOL] [EOL] [EOL] def test_compact_target_to_uint256 ( ) : [EOL] [comment] [EOL] test_hash = compact_target_to_uint256 ( [string] ) [EOL] for i in range ( [number] ) : [EOL] assert [number] == test_hash [ i ] [EOL] assert [number] == test_hash [ [number] ] [EOL] [EOL] [comment] [EOL] for num_leading_zeros in range ( [number] ) : [EOL] compact_target = pack ( [string] , [number] - num_leading_zeros ) + [string] [EOL] test_hash = compact_target_to_uint256 ( compact_target ) [EOL] [EOL] for bit_index in range ( num_leading_zeros ) : [EOL] byte = test_hash [ bit_index // [number] ] [EOL] bit = bool ( byte & ( [number] ** ( [number] - bit_index % [number] ) ) ) [EOL] assert not bit [EOL] [EOL] [comment] [EOL] bit_index = num_leading_zeros [EOL] byte = test_hash [ bit_index // [number] ] [EOL] bit = bool ( byte & ( [number] ** ( [number] - bit_index % [number] ) ) ) [EOL] assert bit [EOL] [EOL] [comment] [EOL] [comment] [EOL] for num_leading_zeros in range ( [number] , [number] , [number] ) : [EOL] compact_target = pack ( [string] , [number] - num_leading_zeros ) + [string] [EOL] test_hash = compact_target_to_uint256 ( compact_target ) [EOL] byte_index = ( num_leading_zeros + [number] ) // [number] [EOL] [EOL] assert [string] == test_hash [ byte_index : byte_index + [number] ] [EOL] assert [string] * ( [number] - byte_index - [number] ) == test_hash [ byte_index + [number] : ] [EOL] [EOL] [EOL] def test_uint256_to_compact_target ( ) : [EOL] for num_leading_zeros in range ( [number] ) : [EOL] compact_target = pack ( [string] , [number] - num_leading_zeros ) + [string] [EOL] test_hash = compact_target_to_uint256 ( compact_target ) [EOL] [EOL] assert compact_target == uint256_to_compact_target ( test_hash ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Optional [EOL] import blockchain [EOL] import typing [EOL] import builtins [EOL] from hashlib import sha256 [EOL] from struct import pack [EOL] from typing import List , NamedTuple , Optional [EOL] [EOL] from blockchain import zeroes_uint256 [EOL] [EOL] [EOL] class TransactionOutput ( NamedTuple ) : [EOL] [docstring] [EOL] tx_hash = ... [EOL] out_idx = ... [EOL] [EOL] @ staticmethod def genesis ( ) : [EOL] return TransactionOutput ( tx_hash = zeroes_uint256 , out_idx = [number] ) [EOL] [EOL] [EOL] class Coin ( NamedTuple ) : [EOL] [docstring] [EOL] amount = ... [EOL] height = ... [EOL] txo = ... [EOL] [EOL] @ staticmethod def genesis ( amount = [number] ) : [EOL] return Coin ( amount = amount , height = [number] , txo = TransactionOutput . genesis ( ) ) [EOL] [EOL] [EOL] class CoinStakeTransaction : [EOL] def __init__ ( self , * , vin , vout = None , height = [number] , reward_amount = [number] ) : [EOL] [docstring] [EOL] self . vin = vin [EOL] [EOL] if vout is None : [EOL] [comment] [EOL] combined_stake = sum ( c . amount for c in vin ) [EOL] if combined_stake == [number] : [EOL] self . vout = [ reward_amount ] [EOL] else : [EOL] self . vout = [ reward_amount , combined_stake ] [EOL] else : [EOL] [comment] [EOL] self . vout = vout [EOL] [EOL] self . height = height [comment] [EOL] [EOL] self . _tx_hash = None [EOL] self . _all_coins = None [EOL] [EOL] @ staticmethod def genesis ( vout = None ) : [EOL] return CoinStakeTransaction ( vin = [ Coin . genesis ( amount = sum ( vout or [ ] ) ) ] , vout = vout , height = [number] ) [EOL] [EOL] def tx_hash ( self ) : [EOL] if self . _tx_hash is None : [EOL] self . _tx_hash = sha256 ( pack ( [string] , len ( self . vin ) ) + [string] . join ( c . txo . tx_hash + pack ( [string] , c . txo . out_idx , c . height , c . amount ) for c in self . vin ) + pack ( [string] , len ( self . vout ) ) + [string] . join ( pack ( [string] , o ) for o in self . vout ) ) . digest ( ) [EOL] return self . _tx_hash [EOL] [EOL] def get_nth_coin ( self , out_idx ) : [EOL] return Coin ( height = self . height , amount = self . vout [ out_idx ] , txo = TransactionOutput ( tx_hash = self . tx_hash ( ) , out_idx = out_idx ) ) [EOL] [EOL] def get_all_coins ( self ) : [EOL] [docstring] [EOL] if self . _all_coins is None : [EOL] self . _all_coins = [ self . get_nth_coin ( out_idx ) for out_idx in range ( len ( self . vout ) ) ] [EOL] return self . _all_coins [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . tx_hash ( ) . __hash__ ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , CoinStakeTransaction ) and self . tx_hash ( ) == other . tx_hash ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $'TransactionOutput'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $TransactionOutput$ 0 0 0 0 0 0 0 $'Coin'$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[blockchain.transaction.Coin]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[blockchain.transaction.Coin]$ 0 $typing.List[blockchain.transaction.Coin]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[blockchain.transaction.Coin]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 $typing.Optional[typing.List[Coin]]$ 0 0 0 0 0 0 0 $'CoinStakeTransaction'$ 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $Coin$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Coin]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[blockchain.transaction.Coin]]$ 0 0 0 0 0 0 $typing.Optional[typing.List[blockchain.transaction.Coin]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[blockchain.transaction.Coin]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] zeroes_uint256 = [string] * [number] [EOL] max_uint32_val = [number] ** [number] - [number] [EOL] max_uint256_val = [number] ** [number] - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , DefaultDict , Set , Tuple , List [EOL] import blockchain [EOL] import typing [EOL] import builtins [EOL] import network [EOL] from collections import defaultdict [EOL] from logging import getLogger [EOL] from random import sample [EOL] from typing import List , Set , Tuple [EOL] [EOL] from blockchain . block import Block [EOL] from blockchain . blockchain import BlockChain , CheatedClock [EOL] from blockchain . simple_node import SimpleNode [EOL] from experiments . graph import ( create_directed_graph , enforce_nodes_reconnections , ensure_one_inbound_connection_per_node ) [EOL] from network . latencies import ExponentiallyDistributedLatencyPolicy [EOL] [EOL] [EOL] class SimNet : [EOL] def __init__ ( self , * , simulation_time , num_proposer_nodes , num_relay_nodes , num_inbound_connections = [number] , num_outbound_connections = [number] , graph_model = [string] , num_coins_per_proposer = [number] , coins_amount = [number] , num_greedy_proposers = [number] , time_between_blocks = [number] , block_time_mask = [number] , difficulty_adjustment_window = [number] , difficulty_adjustment_period = [number] , num_blocks_for_median_timestamp = [number] , max_future_block_time_seconds = [number] , latency = [number] , processing_time = [number] , ) : [EOL] self . logger = getLogger ( [string] ) [EOL] [EOL] [comment] [EOL] self . proposer_node_ids = [ ] [EOL] self . simulation_time = simulation_time [EOL] [EOL] [comment] [EOL] self . num_proposer_nodes = num_proposer_nodes [EOL] self . num_relay_nodes = num_relay_nodes [EOL] self . num_nodes = num_proposer_nodes + num_relay_nodes [EOL] self . num_inbound_connections = num_inbound_connections [EOL] self . num_outbound_connections = num_outbound_connections [EOL] self . graph_model = graph_model [EOL] [EOL] [comment] [EOL] self . graph_edges = set ( ) [EOL] self . define_network_topology ( ) [EOL] [EOL] [comment] [EOL] assert [number] <= num_greedy_proposers <= num_proposer_nodes [EOL] self . num_coins_per_proposer = num_coins_per_proposer [EOL] self . coins_amount = coins_amount [EOL] self . num_greedy_proposers = num_greedy_proposers [EOL] [EOL] [comment] [EOL] self . time_between_blocks = time_between_blocks [EOL] self . block_time_mask = block_time_mask [EOL] self . difficulty_adjustment_window = difficulty_adjustment_window [EOL] self . difficulty_adjustment_period = difficulty_adjustment_period [EOL] self . num_blocks_for_median_timestamp = num_blocks_for_median_timestamp [EOL] self . max_future_block_time_seconds = max_future_block_time_seconds [EOL] [EOL] [comment] [EOL] self . latency_policy = ExponentiallyDistributedLatencyPolicy ( avg_delay = latency ) [EOL] self . processing_time = processing_time [comment] [EOL] [EOL] [comment] [EOL] self . clock = CheatedClock ( time = [number] ) [EOL] self . nodes = [ ] [EOL] self . setup_nodes ( ) [EOL] self . setup_network ( ) [EOL] [EOL] def define_network_topology ( self ) : [EOL] [docstring] [EOL] [EOL] self . logger . info ( [string] ) [EOL] [EOL] graph_edges , inbound_degrees = create_directed_graph ( num_nodes = self . num_nodes , max_inbound_connections = self . num_inbound_connections , num_outbound_connections = self . num_outbound_connections , model = self . graph_model ) [EOL] [EOL] [comment] [EOL] graph_edges , inbound_degrees = enforce_nodes_reconnections ( graph_edges = graph_edges , inbound_degrees = inbound_degrees , num_reconnection_rounds = [number] , ) [EOL] [EOL] [comment] [EOL] self . graph_edges , _ = ensure_one_inbound_connection_per_node ( num_nodes = self . num_nodes , graph_edges = graph_edges , inbound_degrees = inbound_degrees , ) [EOL] [EOL] def setup_nodes ( self ) : [EOL] [docstring] [EOL] [EOL] self . logger . info ( [string] ) [EOL] [EOL] genesis_block = Block . genesis ( timestamp = [number] , compact_target = [string] , vout = [ self . coins_amount ] * ( self . num_coins_per_proposer * self . num_proposer_nodes ) ) . fit_target ( ) [EOL] [EOL] self . proposer_node_ids = sample ( range ( self . num_nodes ) , self . num_proposer_nodes ) [EOL] [EOL] [comment] [EOL] all_coins = genesis_block . coinstake_tx . get_all_coins ( ) [EOL] coins_per_proposer = defaultdict ( set ) [EOL] coins_per_proposer . update ( { node_id : set ( all_coins [ self . num_coins_per_proposer * i : self . num_coins_per_proposer * ( i + [number] ) ] ) for i , node_id in enumerate ( self . proposer_node_ids ) } ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] greedy_node_ids = sample ( self . proposer_node_ids , self . num_greedy_proposers ) [EOL] [EOL] self . nodes = [ SimpleNode ( node_id = node_id , latency_policy = self . latency_policy , chain = BlockChain ( genesis = genesis_block , clock = self . clock , time_between_blocks = self . time_between_blocks , block_time_mask = self . block_time_mask , difficulty_adjustment_window = self . difficulty_adjustment_window , difficulty_adjustment_period = self . difficulty_adjustment_period , num_blocks_for_median_timestamp = self . num_blocks_for_median_timestamp , max_future_block_time_seconds = self . max_future_block_time_seconds ) , initial_coins = coins_per_proposer [ node_id ] , is_proposer = node_id in self . proposer_node_ids , greedy_proposal = node_id in greedy_node_ids , max_num_tips = self . num_proposer_nodes + [number] , max_outbound_peers = self . num_outbound_connections , processing_time = self . processing_time ) for node_id in range ( self . num_nodes ) ] [EOL] [EOL] def setup_network ( self ) : [EOL] [docstring] [EOL] [EOL] for src_id , dst_id in self . graph_edges : [EOL] self . nodes [ src_id ] . add_outbound_peer ( self . nodes [ dst_id ] ) [EOL] [EOL] def run ( self ) : [EOL] for _ in range ( [number] , [number] + self . simulation_time ) : [EOL] self . clock . advance_time ( [number] ) [EOL] [EOL] [comment] [EOL] processed_messages = [number] [EOL] while processed_messages > [number] : [EOL] processed_messages = [number] [EOL] for node in self . nodes : [EOL] processed_messages += node . process_messages ( ) [EOL] [EOL] [comment] [EOL] for node in self . nodes : [EOL] node . try_to_propose ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $network.latencies.ExponentiallyDistributedLatencyPolicy$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $blockchain.blockchain.CheatedClock$ 0 0 0 0 0 0 0 0 0 0 $typing.List[blockchain.simple_node.SimpleNode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $blockchain.block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[blockchain.transaction.Coin]$ 0 $blockchain.block.Block$ 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.Set[typing.Any]]$ 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.Set[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.List[blockchain.transaction.Coin]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[blockchain.simple_node.SimpleNode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $blockchain.block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.Set[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Optional , Any [EOL] import blockchain [EOL] import typing [EOL] import builtins [EOL] from hashlib import sha256 [EOL] from struct import pack [EOL] from typing import Any , List , Optional [EOL] [EOL] from blockchain import max_uint256_val , zeroes_uint256 [EOL] from blockchain . transaction import CoinStakeTransaction [EOL] from blockchain . utils import ( compact_target_to_bigint , bigint_to_compact_target ) [EOL] [EOL] [EOL] class Block : [EOL] def __init__ ( self , * , prev_block_hash , prev_block_stake_modifier , compact_target , coinstake_tx , timestamp , real_timestamp = None ) : [EOL] self . prev_block_hash = prev_block_hash [EOL] self . prev_block_stake_modifier = prev_block_stake_modifier [EOL] self . compact_target = compact_target [EOL] [EOL] self . coinstake_tx = coinstake_tx [EOL] [EOL] self . timestamp = timestamp [EOL] self . real_timestamp = timestamp if real_timestamp is None else real_timestamp [EOL] [EOL] self . _kernel_hash_base = None [comment] [EOL] self . _kernel_hash = None [EOL] [EOL] self . _stake_modifier = None [EOL] [EOL] self . _block_hash_base = None [comment] [EOL] self . _block_hash = None [EOL] [EOL] @ staticmethod def genesis ( * , timestamp = [number] , compact_target = [string] , vout = None ) : [EOL] return Block ( prev_block_hash = zeroes_uint256 , prev_block_stake_modifier = zeroes_uint256 , compact_target = compact_target , coinstake_tx = CoinStakeTransaction . genesis ( vout = vout ) , timestamp = timestamp , real_timestamp = timestamp ) [EOL] [EOL] def stake_modifier ( self ) : [EOL] if self . _stake_modifier is None : [EOL] self . _stake_modifier = sha256 ( self . coinstake_tx . vin [ [number] ] . txo . tx_hash + self . prev_block_stake_modifier ) . digest ( ) [EOL] return self . _stake_modifier [EOL] [EOL] def kernel_hash ( self ) : [EOL] if self . _kernel_hash is None : [EOL] if self . _kernel_hash_base is None : [EOL] self . _kernel_hash_base = sha256 ( self . prev_block_stake_modifier + self . coinstake_tx . vin [ [number] ] . txo . tx_hash + pack ( [string] , self . coinstake_tx . vin [ [number] ] . txo . out_idx ) ) [EOL] _kernel_hash = self . _kernel_hash_base . copy ( ) [EOL] _kernel_hash . update ( pack ( [string] , self . timestamp ) ) [EOL] self . _kernel_hash = _kernel_hash . digest ( ) [EOL] return self . _kernel_hash [EOL] [EOL] def block_hash ( self ) : [EOL] if self . _block_hash is None : [EOL] if self . _block_hash_base is None : [EOL] self . _block_hash_base = sha256 ( self . prev_block_hash + self . compact_target + self . coinstake_tx . tx_hash ( ) ) [EOL] _block_hash = self . _block_hash_base . copy ( ) [EOL] _block_hash . update ( pack ( [string] , self . timestamp ) ) [EOL] self . _block_hash = _block_hash . digest ( ) [EOL] return self . _block_hash [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . block_hash ( ) . __hash__ ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , Block ) and self . block_hash ( ) == other . block_hash ( ) ) [EOL] [EOL] def try_to_be_valid ( self , * , max_timestamp , time_mask , greedy_proposal = True ) : [EOL] [docstring] [EOL] if self . coinstake_tx . height == [number] and self . coinstake_tx . vin [ [number] ] . amount == [number] : [EOL] [comment] [EOL] custom_target = compact_target_to_bigint ( self . compact_target ) [EOL] else : [EOL] stake = self . coinstake_tx . vin [ [number] ] . amount [EOL] custom_target = compact_target_to_bigint ( self . compact_target ) * stake [EOL] [EOL] if greedy_proposal : [EOL] while ( int . from_bytes ( self . kernel_hash ( ) , [string] ) >= custom_target and self . timestamp < max_timestamp ) : [EOL] self . timestamp += time_mask [EOL] self . _kernel_hash = None [EOL] [EOL] if int . from_bytes ( self . kernel_hash ( ) , [string] ) < custom_target : [EOL] del self . _kernel_hash_base [comment] [EOL] self . _block_hash = None [EOL] self . block_hash ( ) [EOL] del self . _block_hash_base [comment] [EOL] [EOL] return self [EOL] else : [EOL] return None [EOL] [EOL] def fit_target ( self ) : [EOL] [docstring] [EOL] self . compact_target = bigint_to_compact_target ( min ( max_uint256_val , ( int . from_bytes ( self . kernel_hash ( ) , [string] ) // max ( [number] , self . coinstake_tx . vin [ [number] ] . amount ) ) + ( [number] ** [number] ) ) ) [EOL] assert self . is_valid ( ) [EOL] return self [EOL] [EOL] def is_valid ( self ) : [EOL] return int . from_bytes ( self . kernel_hash ( ) , [string] ) < ( compact_target_to_bigint ( self . compact_target ) * max ( [number] , self . coinstake_tx . vin [ [number] ] . amount ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $blockchain.transaction.CoinStakeTransaction$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 $blockchain.transaction.CoinStakeTransaction$ 0 $blockchain.transaction.CoinStakeTransaction$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 $'Block'$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['Block']$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Block'$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import builtins [EOL] from struct import pack [EOL] [EOL] [EOL] def compact_target_to_uint256 ( compact_target ) : [EOL] [docstring] [EOL] assert len ( compact_target ) == [number] [EOL] [EOL] [comment] [EOL] num_zero_bits = [number] - compact_target [ [number] ] [EOL] bits_shift = num_zero_bits % [number] [EOL] neg_bits_shift = [number] - bits_shift [EOL] [EOL] partial_result = [string] * ( num_zero_bits // [number] ) [EOL] [EOL] if len ( partial_result ) < [number] : [EOL] next_byte = ( [number] >> bits_shift ) [comment] [EOL] bits_shift = ( bits_shift + [number] ) % [number] [EOL] neg_bits_shift = [number] - bits_shift [EOL] if bits_shift > [number] : [EOL] next_byte += ( compact_target [ [number] ] >> bits_shift ) [EOL] partial_result += pack ( [string] , next_byte ) [EOL] [EOL] if bits_shift == [number] : [EOL] partial_result += compact_target [ [number] : [number] ] [EOL] [EOL] if len ( partial_result ) < [number] : [EOL] partial_result += pack ( [string] , ( ( ( compact_target [ [number] ] << neg_bits_shift ) & [number] ) + ( compact_target [ [number] ] >> bits_shift ) ) ) [EOL] if len ( partial_result ) < [number] : [EOL] partial_result += pack ( [string] , ( ( ( compact_target [ [number] ] << neg_bits_shift ) & [number] ) + ( compact_target [ [number] ] >> bits_shift ) ) ) [EOL] if len ( partial_result ) < [number] : [EOL] partial_result += pack ( [string] , ( ( ( compact_target [ [number] ] << neg_bits_shift ) & [number] ) + ( [number] >> bits_shift ) ) ) [EOL] [EOL] return partial_result + [string] * ( [number] - len ( partial_result ) ) [EOL] [EOL] [EOL] def compact_target_to_bigint ( compact_target ) : [EOL] return int . from_bytes ( compact_target_to_uint256 ( compact_target ) , [string] ) [EOL] [EOL] [EOL] def bigint_to_compact_target ( bigint ) : [EOL] return uint256_to_compact_target ( int . to_bytes ( bigint , [number] , [string] ) ) [EOL] [EOL] [EOL] def uint256_to_compact_target ( hash_target ) : [EOL] [docstring] [EOL] assert len ( hash_target ) == [number] [EOL] [EOL] num_leading_zeros = [number] [EOL] for bit_index in range ( [number] ) : [EOL] byte = hash_target [ bit_index // [number] ] [EOL] bit = bool ( byte & ( [number] ** ( [number] - bit_index % [number] ) ) ) [EOL] if bit : [EOL] break [EOL] num_leading_zeros += [number] [EOL] [EOL] bits_shift = ( num_leading_zeros + [number] ) % [number] [comment] [EOL] neg_bits_shift = [number] - bits_shift [EOL] byte_index = ( num_leading_zeros + [number] ) // [number] [EOL] [EOL] compact_target = pack ( [string] , [number] - num_leading_zeros ) [EOL] [EOL] if bits_shift == [number] : [EOL] compact_target += hash_target [ byte_index : byte_index + [number] ] [EOL] compact_target += [string] * ( [number] - len ( compact_target ) ) [EOL] return compact_target [EOL] [EOL] for _ in range ( [number] ) : [EOL] if byte_index <= [number] : [EOL] next_byte = ( hash_target [ byte_index ] << bits_shift ) & [number] [EOL] if byte_index + [number] <= [number] : [EOL] next_byte += ( hash_target [ byte_index + [number] ] >> neg_bits_shift ) [EOL] else : [EOL] next_byte += ( [number] >> bits_shift ) [EOL] compact_target += pack ( [string] , next_byte ) [EOL] else : [EOL] compact_target += [string] [EOL] byte_index += [number] [EOL] [EOL] return compact_target [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Optional , Set , Dict , Tuple , List [EOL] import typing [EOL] import network [EOL] import experiments [EOL] import argparse [EOL] import test_framework [EOL] import builtins [EOL] import asyncio [EOL] [docstring] [EOL] [EOL] [EOL] import sys [EOL] [EOL] from argparse import ArgumentParser [EOL] from asyncio import ( AbstractEventLoop , sleep as asyncio_sleep , get_event_loop , ) [EOL] from json import dumps as json_dumps [EOL] from logging import ( INFO , WARNING , basicConfig as loggingBasicConfig , getLogger ) [EOL] from math import floor [EOL] from os import environ [EOL] from os . path import ( dirname , exists as path_exists , normpath , realpath , ) [EOL] from pathlib import Path [EOL] from random import sample [EOL] from shutil import rmtree [EOL] from tempfile import mkdtemp [EOL] from time import time as _time [EOL] from typing import ( List , Optional , Set , Tuple ) [EOL] [EOL] import test_framework . util as tf_util [EOL] [EOL] from experiments . graph import ( enforce_nodes_reconnections , ensure_one_inbound_connection_per_node , create_directed_graph , create_simple_dense_graph ) [EOL] from network . latencies import StaticLatencyPolicy [EOL] from network . stats import ( CsvNetworkStatsCollector , NullNetworkStatsCollector ) [EOL] from network . nodes_hub import ( NodesHub , NUM_INBOUND_CONNECTIONS , NUM_OUTBOUND_CONNECTIONS ) [EOL] from test_framework . messages import UNIT [EOL] from test_framework . regtest_mnemonics import regtest_mnemonics [EOL] from test_framework . test_node import TestNode [EOL] from test_framework . util import initialize_datadir [EOL] [EOL] [EOL] class ForkingSimulation : [EOL] def __init__ ( self , * , loop , latency , num_proposer_nodes , num_validator_nodes , num_relay_nodes , simulation_time = [number] , sample_time = [number] , block_time_seconds = [number] , block_stake_timestamp_interval_seconds = [number] , network_stats_file_name , nodes_stats_directory , graph_model = [string] , ) : [EOL] if num_proposer_nodes < [number] or num_relay_nodes < [number] : [EOL] raise RuntimeError ( [string] ) [EOL] elif num_relay_nodes + num_proposer_nodes == [number] : [EOL] raise RuntimeError ( [string] ) [EOL] elif num_proposer_nodes > [number] : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] self . logger = getLogger ( [string] ) [EOL] [EOL] [comment] [EOL] self . block_time_seconds = block_time_seconds [EOL] self . block_stake_timestamp_interval_seconds = block_stake_timestamp_interval_seconds [EOL] [EOL] [comment] [EOL] self . num_proposer_nodes = num_proposer_nodes [EOL] self . num_validator_nodes = num_validator_nodes [EOL] self . num_relay_nodes = num_relay_nodes [EOL] self . num_nodes = num_proposer_nodes + num_validator_nodes + num_relay_nodes [EOL] self . graph_model = graph_model [EOL] self . graph_edges = set ( ) [EOL] self . latency = latency [comment] [EOL] self . define_network_topology ( ) [EOL] [EOL] [comment] [EOL] self . simulation_time = simulation_time [EOL] self . sample_time = sample_time [EOL] [EOL] [comment] [EOL] self . cache_dir = normpath ( dirname ( realpath ( __file__ ) ) + [string] ) [EOL] self . tmp_dir = [string] [EOL] self . network_stats_file_name = network_stats_file_name [EOL] self . nodes_stats_directory = Path ( nodes_stats_directory ) . resolve ( ) [EOL] [EOL] [comment] [EOL] self . loop = loop [EOL] self . nodes = [ ] [EOL] self . nodes_hub = None [EOL] self . proposer_node_ids = [ ] [EOL] self . validator_node_ids = [ ] [EOL] [EOL] self . is_running = False [EOL] [EOL] def run ( self ) : [EOL] self . logger . info ( [string] ) [EOL] self . setup_directories ( ) [EOL] self . setup_chain ( ) [EOL] self . setup_nodes ( ) [EOL] [EOL] try : [EOL] if self . num_validator_nodes > [number] : [EOL] self . autofinalization_workaround ( ) [EOL] self . start_nodes ( ) [EOL] except ( OSError , AssertionError ) : [EOL] return False [comment] [EOL] [EOL] self . nodes_hub = NodesHub ( loop = self . loop , latency_policy = StaticLatencyPolicy ( self . latency ) , nodes = self . nodes , network_stats_collector = CsvNetworkStatsCollector ( output_file = open ( file = self . network_stats_file_name , mode = [string] ) ) ) [EOL] self . nodes_hub . sync_start_proxies ( ) [EOL] self . nodes_hub . sync_connect_nodes_graph ( self . graph_edges ) [EOL] [EOL] [comment] [EOL] self . logger . info ( [string] ) [EOL] for idx , proposer_id in enumerate ( self . proposer_node_ids ) : [EOL] if idx > [number] : [EOL] self . nodes [ proposer_id ] . createwallet ( f' [string] { proposer_id }' ) [EOL] [EOL] tmp_wallet = self . nodes [ proposer_id ] . get_wallet_rpc ( f' [string] { proposer_id }' ) [EOL] tmp_wallet . importwallet ( normpath ( self . tmp_dir + f' [string] { proposer_id } [string] ' ) ) [EOL] [EOL] self . loop . run_until_complete ( self . trigger_simulation_stop ( ) ) [EOL] return True [EOL] [EOL] def autofinalization_workaround ( self ) : [EOL] [docstring] [EOL] self . logger . info ( [string] ) [EOL] [EOL] lucky_proposer_id = self . proposer_node_ids [ [number] ] [EOL] validators = [ self . nodes [ i ] for i in self . validator_node_ids ] [EOL] [EOL] self . start_node ( lucky_proposer_id ) [EOL] self . start_nodes ( validators ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tmp_hub = NodesHub ( loop = self . loop , latency_policy = StaticLatencyPolicy ( [number] ) , nodes = self . nodes , network_stats_collector = NullNetworkStatsCollector ( ) ) [EOL] lucky_node_ids = [ lucky_proposer_id ] + self . validator_node_ids [EOL] tmp_hub . sync_start_proxies ( lucky_node_ids ) [EOL] dense_graph = create_simple_dense_graph ( node_ids = lucky_node_ids ) [EOL] tmp_hub . sync_connect_nodes_graph ( dense_graph ) [EOL] [EOL] [comment] [EOL] lucky_proposer = self . nodes [ lucky_proposer_id ] [EOL] for proposer_id in self . proposer_node_ids : [EOL] lucky_proposer . createwallet ( f' [string] { proposer_id }' ) [EOL] tmp_wallet = lucky_proposer . get_wallet_rpc ( f' [string] { proposer_id }' ) [EOL] tmp_wallet . importmasterkey ( regtest_mnemonics [ proposer_id ] [ [string] ] ) [EOL] for validator_id in self . validator_node_ids : [EOL] self . nodes [ validator_id ] . createwallet ( f' [string] { validator_id }' ) [EOL] tmp_wallet = self . nodes [ validator_id ] . get_wallet_rpc ( f' [string] { validator_id }' ) [EOL] tmp_wallet . importmasterkey ( regtest_mnemonics [ validator_id ] [ [string] ] ) [EOL] [EOL] self . loop . run_until_complete ( self . ensure_autofinalization_is_off ( ) ) [EOL] [EOL] [comment] [EOL] for proposer_id in self . proposer_node_ids : [EOL] [comment] [EOL] tmp_wallet = lucky_proposer . get_wallet_rpc ( f' [string] { proposer_id }' ) [EOL] tmp_wallet . dumpwallet ( normpath ( self . tmp_dir + f' [string] { proposer_id } [string] ' ) ) [EOL] if proposer_id != lucky_proposer_id : [EOL] lucky_proposer . unloadwallet ( f' [string] { proposer_id }' ) [EOL] [EOL] tmp_hub . close ( ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . logger . info ( [string] ) [EOL] [EOL] async def ensure_autofinalization_is_off ( self ) : [EOL] for validator_id in self . validator_node_ids : [EOL] validator = self . nodes [ validator_id ] [EOL] tmp_wallet = validator . get_wallet_rpc ( f' [string] { validator_id }' ) [EOL] tmp_wallet . deposit ( tmp_wallet . getnewaddress ( [string] , [string] ) , tmp_wallet . getbalance ( ) - [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] await asyncio_sleep ( [number] ) [EOL] [EOL] [comment] [EOL] await asyncio_sleep ( [number] + self . block_time_seconds * [number] ) [EOL] [EOL] lucky_proposer = self . nodes [ self . proposer_node_ids [ [number] ] ] [EOL] is_autofinalization_off = False [EOL] [EOL] while not is_autofinalization_off : [EOL] finalization_state = lucky_proposer . getfinalizationstate ( ) [EOL] is_autofinalization_off = ( finalization_state is not None and [string] in finalization_state and finalization_state [ [string] ] >= [number] ) [EOL] await asyncio_sleep ( [number] ) [EOL] [EOL] def safe_run ( self , close_loop = True ) : [EOL] successful_run = False [EOL] try : [EOL] successful_run = self . run ( ) [EOL] finally : [EOL] self . logger . info ( [string] ) [EOL] if self . nodes_hub is not None : [EOL] self . nodes_hub . close ( ) [EOL] self . stop_nodes ( ) [EOL] [EOL] if successful_run : [EOL] self . cleanup_directories ( ) [EOL] [EOL] if close_loop : [EOL] self . loop . close ( ) [EOL] return successful_run [EOL] [EOL] async def trigger_simulation_stop ( self ) : [EOL] self . logger . info ( f' [string] { self . simulation_time } [string] ' ) [EOL] await asyncio_sleep ( self . simulation_time ) [EOL] self . is_running = False [EOL] await asyncio_sleep ( [number] * self . sample_time ) [EOL] self . logger . info ( [string] ) [EOL] [EOL] def setup_directories ( self ) : [EOL] if self . tmp_dir != [string] : [EOL] return [EOL] [EOL] self . logger . info ( [string] ) [EOL] self . tmp_dir = mkdtemp ( prefix = [string] ) [EOL] self . logger . info ( f' [string] { self . tmp_dir }' ) [EOL] [EOL] def cleanup_directories ( self ) : [EOL] if self . tmp_dir != [string] and path_exists ( self . tmp_dir ) : [EOL] self . logger . info ( [string] ) [EOL] rmtree ( self . tmp_dir ) [EOL] [comment] [EOL] [EOL] def setup_chain ( self ) : [EOL] self . logger . info ( [string] ) [EOL] for i in range ( self . num_nodes ) : [EOL] initialize_datadir ( self . tmp_dir , i ) [EOL] [EOL] def setup_nodes ( self ) : [EOL] if len ( self . nodes ) > [number] : [EOL] self . logger . info ( [string] ) [EOL] return [EOL] [EOL] self . logger . info ( [string] ) [EOL] [EOL] all_node_ids = set ( range ( self . num_nodes ) ) [EOL] self . proposer_node_ids = sample ( all_node_ids , self . num_proposer_nodes ) [EOL] self . validator_node_ids = sample ( all_node_ids . difference ( self . proposer_node_ids ) , self . num_validator_nodes ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] node_args = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , f' [string] { [number] * UNIT }' , f' [string] { [number] * UNIT }' , f''' [string] { json_dumps ( { [string] : self . block_time_seconds , [string] : self . block_stake_timestamp_interval_seconds , [string] : { [string] : floor ( _time ( ) ) - [number] , [string] : [ { [string] : [number] * UNIT , [string] : mnemonic [ [string] ] } for mnemonic in regtest_mnemonics ] } } , separators = ( [string] , [string] ) ) }''' ] [EOL] relay_args = [ [string] ] + node_args [EOL] proposer_args = [ [string] ] + node_args [EOL] validator_args = [ [string] , [string] ] + node_args [EOL] [EOL] if not self . nodes_stats_directory . exists ( ) : [EOL] self . nodes_stats_directory . mkdir ( ) [EOL] [EOL] def get_node_args ( node_id ) : [EOL] if node_id in self . proposer_node_ids : [EOL] _node_args = proposer_args [EOL] elif node_id in self . validator_node_ids : [EOL] _node_args = validator_args [EOL] else : [EOL] _node_args = relay_args [EOL] return [ f' [string] { NodesHub . get_p2p_node_port ( node_id ) }' , f' [string] { NodesHub . get_rpc_node_port ( node_id ) }' , f''' [string] { self . nodes_stats_directory . joinpath ( f" [string] { node_id } [string] " ) }''' , f' [string] { node_id }' ] + _node_args [EOL] [EOL] self . nodes = [ TestNode ( i = i , datadir = f'{ self . tmp_dir } [string] { i }' , extra_args = get_node_args ( i ) , rpchost = None , timewait = [number] , unit_e = environ [ [string] ] , unit_e_cli = environ [ [string] ] , mocktime = [number] , coverage_dir = None , use_cli = False ) for i in range ( self . num_nodes ) ] [EOL] [EOL] def start_node ( self , i ) : [EOL] node = self . nodes [ i ] [EOL] try : [EOL] node . start ( ) [EOL] node . wait_for_rpc_connection ( ) [EOL] except Exception : [EOL] self . stop_nodes ( ) [EOL] raise [EOL] [EOL] def start_nodes ( self , nodes = None ) : [EOL] self . logger . info ( [string] ) [EOL] [EOL] if nodes is None : [EOL] nodes = self . nodes [EOL] [EOL] for node_id , node in enumerate ( nodes ) : [EOL] try : [EOL] if not node . running : [EOL] node . start ( ) [EOL] except OSError as e : [EOL] self . logger . critical ( f' [string] { node_id } [string] ' , e ) [EOL] raise [EOL] for node_id , node in enumerate ( nodes ) : [EOL] try : [EOL] node . wait_for_rpc_connection ( ) [EOL] except AssertionError as e : [EOL] self . logger . critical ( f' [string] { node_id }' , e ) [EOL] raise [EOL] [EOL] self . logger . info ( [string] ) [EOL] [EOL] def stop_nodes ( self ) : [EOL] self . logger . info ( [string] ) [EOL] for node in self . nodes : [EOL] try : [EOL] node . stop_node ( ) [EOL] except AssertionError : [EOL] continue [EOL] for node in self . nodes : [EOL] node . wait_until_stopped ( ) [EOL] [EOL] def define_network_topology ( self ) : [EOL] [docstring] [EOL] [EOL] self . logger . info ( [string] ) [EOL] [EOL] graph_edges , inbound_degrees = create_directed_graph ( num_nodes = self . num_nodes , num_outbound_connections = NUM_OUTBOUND_CONNECTIONS , max_inbound_connections = NUM_INBOUND_CONNECTIONS , model = self . graph_model ) [EOL] [EOL] [comment] [EOL] graph_edges , inbound_degrees = enforce_nodes_reconnections ( graph_edges = graph_edges , inbound_degrees = inbound_degrees , num_reconnection_rounds = [number] , ) [EOL] [EOL] [comment] [EOL] self . graph_edges , _ = ensure_one_inbound_connection_per_node ( num_nodes = self . num_nodes , graph_edges = graph_edges , inbound_degrees = inbound_degrees , ) [EOL] [EOL] [EOL] def main ( ) : [EOL] loggingBasicConfig ( stream = sys . stdout , level = INFO , format = [string] ) [EOL] getLogger ( [string] ) . setLevel ( WARNING ) [EOL] [EOL] tf_util . MAX_NODES = [number] [comment] [EOL] tf_util . PortSeed . n = [number] [EOL] [EOL] parser = ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , default = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , default = [string] ) [EOL] cmd_args = vars ( parser . parse_args ( ) ) [EOL] [EOL] simulation = ForkingSimulation ( loop = get_event_loop ( ) , latency = [number] , num_proposer_nodes = [number] , num_validator_nodes = [number] , num_relay_nodes = [number] , simulation_time = [number] , sample_time = [number] , graph_model = [string] , block_time_seconds = [number] , block_stake_timestamp_interval_seconds = [number] , network_stats_file_name = cmd_args [ [string] ] , nodes_stats_directory = cmd_args [ [string] ] ) [EOL] [EOL] if not simulation . safe_run ( ) : [EOL] exit ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $typing.List[test_framework.test_node.TestNode]$ 0 0 0 0 0 0 $typing.Optional[network.nodes_hub.NodesHub]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[network.nodes_hub.NodesHub]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[network.nodes_hub.NodesHub]$ 0 0 0 0 0 0 0 $typing.Optional[network.nodes_hub.NodesHub]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $network.nodes_hub.NodesHub$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $builtins.int$ 0 0 0 0 0 0 $network.nodes_hub.NodesHub$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $network.nodes_hub.NodesHub$ 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $network.nodes_hub.NodesHub$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , Optional , DefaultDict , Set , Dict , Tuple , List [EOL] import typing [EOL] import builtins [EOL] from collections import defaultdict [EOL] from functools import reduce [EOL] from random import ( randint , sample , shuffle ) [EOL] from typing import ( DefaultDict , Dict , List , Optional , Set , Tuple , ) [EOL] [EOL] [EOL] def create_directed_graph ( num_nodes , num_outbound_connections = [number] , max_inbound_connections = [number] , graph_seed_size = None , model = [string] , ) : [EOL] [docstring] [EOL] if [string] == model : [EOL] return create_static_graph ( num_nodes , num_outbound_connections , max_inbound_connections ) [EOL] elif [string] == model : [EOL] return create_growing_graph ( num_nodes , num_outbound_connections , max_inbound_connections , graph_seed_size ) [EOL] elif [string] == model : [EOL] return create_preferential_attachment_graph ( num_nodes , num_outbound_connections , max_inbound_connections , graph_seed_size ) [EOL] [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def create_static_graph ( num_nodes , num_outbound_connections = [number] , max_ingoing_connections = [number] , ) : [EOL] if max_ingoing_connections < num_outbound_connections : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] graph_edges = set ( ) [EOL] inbound_degrees = defaultdict ( int ) [EOL] [EOL] for src_id in range ( num_nodes ) : [EOL] for _ in range ( min ( num_outbound_connections , num_nodes - [number] ) ) : [EOL] dst_id = randint ( [number] , num_nodes - [number] ) [EOL] while ( dst_id == src_id or ( src_id , dst_id ) in graph_edges or inbound_degrees [ dst_id ] >= max_ingoing_connections ) : [EOL] dst_id = randint ( [number] , num_nodes - [number] ) [EOL] [EOL] graph_edges . add ( ( src_id , dst_id ) ) [EOL] inbound_degrees [ dst_id ] += [number] [EOL] [EOL] return graph_edges , inbound_degrees [EOL] [EOL] [EOL] def create_growing_graph ( num_nodes , num_outbound_connections = [number] , max_inbound_connections = [number] , graph_seed_size = None , ) : [EOL] if graph_seed_size is None : [EOL] graph_seed_size = min ( num_nodes , num_outbound_connections + [number] ) [EOL] elif graph_seed_size > num_nodes : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] graph_edges , inbound_degrees = create_static_graph ( graph_seed_size , num_outbound_connections , max_inbound_connections ) [EOL] [EOL] graph_size = graph_seed_size [EOL] [EOL] for src_id in range ( graph_seed_size , num_nodes ) : [EOL] for _ in range ( num_outbound_connections ) : [EOL] dst_id = randint ( [number] , graph_size - [number] ) [EOL] while ( ( src_id , dst_id ) in graph_edges or inbound_degrees [ dst_id ] >= max_inbound_connections ) : [EOL] dst_id = randint ( [number] , graph_size - [number] ) [EOL] [EOL] graph_edges . add ( ( src_id , dst_id ) ) [EOL] inbound_degrees [ dst_id ] += [number] [EOL] [EOL] graph_size += [number] [EOL] [EOL] return graph_edges , inbound_degrees [EOL] [EOL] [EOL] def create_preferential_attachment_graph ( num_nodes , num_outbound_connections = [number] , max_inbound_connections = [number] , graph_seed_size = None , ) : [EOL] if graph_seed_size is None : [EOL] graph_seed_size = min ( num_nodes , num_outbound_connections + [number] ) [EOL] elif graph_seed_size > num_nodes : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] directed_edges , inbound_degrees = create_static_graph ( graph_seed_size , num_outbound_connections , max_inbound_connections ) [EOL] [EOL] degrees , normalized_edges = compute_degrees ( directed_edges , graph_seed_size ) [EOL] degrees_dist = degrees_distribution ( degrees ) [EOL] [EOL] graph_size = graph_seed_size [EOL] [EOL] for src_id in range ( graph_seed_size , num_nodes ) : [EOL] for _ in range ( num_outbound_connections ) : [EOL] dst_id = weighted_random_int ( degrees_dist ) [EOL] while ( ( src_id , dst_id ) in directed_edges or inbound_degrees [ dst_id ] >= max_inbound_connections ) : [EOL] dst_id = weighted_random_int ( degrees_dist ) [EOL] [EOL] directed_edges . add ( ( src_id , dst_id ) ) [EOL] inbound_degrees [ dst_id ] += [number] [EOL] [EOL] degrees , normalized_edges = compute_degrees ( graph_edges = { ( src_id , dst_id ) } , num_nodes = graph_size + [number] , processed_edges = normalized_edges , degrees = degrees ) [EOL] [EOL] degrees_dist = degrees_distribution ( degrees ) [EOL] graph_size += [number] [EOL] [EOL] return directed_edges , inbound_degrees [EOL] [EOL] [EOL] def create_simple_dense_graph ( node_ids , num_outbound_connections = [number] ) : [EOL] [docstring] [EOL] directed_edges = set ( ) [EOL] [EOL] for idx , node_id in enumerate ( node_ids ) : [EOL] num_cons = [number] [EOL] peers = node_ids [ idx + [number] : ] + node_ids [ : idx ] [EOL] for peer_id in peers : [EOL] if num_cons >= min ( num_outbound_connections , len ( node_ids ) - [number] ) : [EOL] break [EOL] directed_edges . add ( ( node_id , peer_id ) ) [EOL] num_cons += [number] [EOL] [EOL] return directed_edges [EOL] [EOL] [EOL] def enforce_nodes_reconnections ( graph_edges , inbound_degrees , num_reconnection_rounds = [number] , ) : [EOL] [docstring] [EOL] graph_edges = graph_edges . copy ( ) [EOL] inbound_degrees = inbound_degrees . copy ( ) [EOL] [EOL] node_ids = list ( { e [ [number] ] for e in graph_edges } ) [EOL] [EOL] for _ in range ( num_reconnection_rounds ) : [EOL] shuffle ( node_ids ) [comment] [EOL] [EOL] for node_id in node_ids : [EOL] neighbours2dg = get_node_neighbours ( node_id , graph_edges , [number] ) [EOL] [EOL] inbound_neighbours = { e [ [number] ] for e in graph_edges if e [ [number] ] == node_id } [EOL] neighbours_neighbours = { neighbour : get_node_neighbours ( neighbour , graph_edges , [number] ) for neighbour in inbound_neighbours } [EOL] [EOL] [comment] [EOL] num_outbound_connections = [number] [EOL] for e in graph_edges . copy ( ) : [EOL] if e [ [number] ] == node_id or e [ [number] ] == node_id : [EOL] graph_edges . remove ( e ) [EOL] inbound_degrees [ e [ [number] ] ] -= [number] [EOL] if e [ [number] ] == node_id : [EOL] num_outbound_connections += [number] [EOL] [EOL] [comment] [EOL] num_recreated_outbound_connections = [number] [EOL] while num_recreated_outbound_connections < num_outbound_connections : [EOL] e = ( node_id , sample ( neighbours2dg , [number] ) [ [number] ] ) [EOL] if e not in graph_edges : [EOL] graph_edges . add ( e ) [EOL] inbound_degrees [ e [ [number] ] ] += [number] [EOL] num_recreated_outbound_connections += [number] [EOL] [EOL] [comment] [EOL] for old_neighbour in inbound_neighbours : [EOL] e = ( old_neighbour , sample ( neighbours_neighbours [ old_neighbour ] , [number] ) [ [number] ] ) [EOL] while e in graph_edges : [EOL] e = ( old_neighbour , sample ( neighbours_neighbours [ old_neighbour ] , [number] ) [ [number] ] ) [EOL] graph_edges . add ( e ) [EOL] inbound_degrees [ e [ [number] ] ] += [number] [EOL] [EOL] return graph_edges , inbound_degrees [EOL] [EOL] [EOL] def get_node_neighbours ( node_id , graph_edges , degree = [number] ) : [EOL] [docstring] [EOL] neighbours = { e [ [number] ] for e in graph_edges if e [ [number] ] == node_id } . union ( { e [ [number] ] for e in graph_edges if e [ [number] ] == node_id } ) [EOL] [EOL] for _ in range ( [number] , degree ) : [EOL] neighbours = { e [ [number] ] for e in graph_edges if e [ [number] ] in neighbours } . union ( { e [ [number] ] for e in graph_edges if e [ [number] ] in neighbours } ) . union ( neighbours ) [EOL] [EOL] return neighbours . difference ( { node_id } ) [EOL] [EOL] [EOL] def compute_degrees ( graph_edges , num_nodes , processed_edges = None , degrees = None ) : [EOL] [docstring] [EOL] [EOL] if processed_edges is None : [EOL] processed_edges = set ( ) [EOL] [EOL] if degrees is None : [EOL] degrees = [ ] [EOL] if len ( degrees ) < num_nodes : [EOL] degrees = degrees + [ [number] ] * ( num_nodes - len ( degrees ) ) [EOL] [EOL] for edge in graph_edges : [EOL] normalized_edge = ( max ( edge ) , min ( edge ) ) [EOL] [EOL] if normalized_edge in processed_edges : [EOL] continue [EOL] [EOL] degrees [ edge [ [number] ] ] += [number] [EOL] degrees [ edge [ [number] ] ] += [number] [EOL] processed_edges . add ( normalized_edge ) [EOL] [EOL] return degrees , processed_edges [EOL] [EOL] [EOL] def degrees_distribution ( degrees ) : [EOL] [docstring] [EOL] return reduce ( lambda dd , d : dd + [ dd [ - [number] ] + d ] , degrees , [ [number] ] ) [ [number] : ] [EOL] [EOL] [EOL] def weighted_random_int ( degrees_dist ) : [EOL] [docstring] [EOL] uniform_rnd = randint ( [number] , degrees_dist [ - [number] ] ) [EOL] for idx , accumulated_weight in enumerate ( degrees_dist ) : [EOL] if uniform_rnd <= accumulated_weight : [EOL] return idx [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def ensure_one_inbound_connection_per_node ( num_nodes , graph_edges , inbound_degrees ) : [EOL] [docstring] [EOL] [EOL] graph_edges = graph_edges . copy ( ) [EOL] inbound_degrees = inbound_degrees . copy ( ) [EOL] [EOL] lonely_nodes = [ i for i in range ( num_nodes ) if inbound_degrees [ i ] == [number] ] [EOL] nodes_by_popularity = sorted ( inbound_degrees . items ( ) , key = lambda x : x [ [number] ] , reverse = True ) [EOL] [EOL] for lonely_node in lonely_nodes : [EOL] popular_node , popularity = nodes_by_popularity [ [number] ] [EOL] [EOL] edge_to_remove = [ e for e in graph_edges if e [ [number] ] == popular_node ] [ [number] ] [EOL] [EOL] graph_edges . remove ( edge_to_remove ) [EOL] graph_edges . add ( ( edge_to_remove [ [number] ] , lonely_node ) ) [EOL] [EOL] inbound_degrees [ popular_node ] -= [number] [EOL] inbound_degrees [ lonely_node ] += [number] [EOL] nodes_by_popularity = sorted ( inbound_degrees . items ( ) , key = lambda x : x [ [number] ] , reverse = True ) [EOL] [EOL] return graph_edges , inbound_degrees [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.int],typing.Set[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Set[typing.Tuple[builtins.int,builtins.int]],typing.Dict[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0