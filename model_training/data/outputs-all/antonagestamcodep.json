from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] from . decorators import make_partial [EOL] from . partial import Partial [EOL] from . runner import run [EOL] [EOL] __all__ = ( [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Type , TypeVar , Iterable , FrozenSet , Sequence [EOL] import immutables [EOL] import codep [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] import abc [EOL] from typing import Any [EOL] from typing import cast [EOL] from typing import FrozenSet [EOL] from typing import Generic [EOL] from typing import Iterable [EOL] from typing import Sequence [EOL] from typing import Type [EOL] from typing import TypeVar [EOL] [EOL] import immutables [EOL] from typing_extensions import final [EOL] [EOL] [EOL] R = TypeVar ( [string] , bound = Any ) [EOL] [EOL] [EOL] class Partial ( abc . ABC , Generic [ R ] ) : [EOL] depends = ( ) [EOL] [EOL] @ final def __init__ ( self ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] @ classmethod def value ( cls , state ) : [EOL] return cast ( R , state [ cls ] ) [EOL] [EOL] @ classmethod @ abc . abstractmethod async def run ( cls , state ) : [EOL] ... [EOL] [EOL] @ staticmethod def applied ( state ) : [EOL] return frozenset ( state . keys ( ) ) [EOL] [EOL] @ classmethod def missing ( cls , state ) : [EOL] return frozenset ( set ( cls . depends ) - cls . applied ( state ) ) [EOL] [EOL] @ classmethod def runnable_dependencies ( cls , state ) : [EOL] missing = cls . missing ( state ) [EOL] if len ( missing ) == [number] and cls not in cls . applied ( state ) : [EOL] yield cls [EOL] for dep in missing : [EOL] yield from dep . runnable_dependencies ( state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Type[Partial]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 $immutables.Map$ 0 0 0 0 0 0 0 0 $immutables.Map$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 $immutables.Map$ 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[typing.Type[Partial]]$ 0 $immutables.Map$ 0 0 0 0 0 0 $immutables.Map$ 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[typing.Type[Partial]]$ 0 0 0 $immutables.Map$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $immutables.Map$ 0 0 0 0 0 0 0 $typing.Iterable[typing.Type[Partial]]$ 0 0 0 $immutables.Map$ 0 0 0 $builtins.frozenset[typing.Type[codep.partial.Partial[typing.Any]]]$ 0 0 0 $builtins.frozenset[typing.Type[codep.partial.Partial[typing.Any]]]$ 0 $immutables.Map$ 0 0 0 0 0 $builtins.frozenset[typing.Type[codep.partial.Partial[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 $immutables.Map$ 0 0 0 0 0 0 0 0 0 $builtins.frozenset[typing.Type[codep.partial.Partial[typing.Any]]]$ 0 0 0 0 0 0 0 0 $immutables.Map$ 0 0
import logging [EOL] import sys [EOL] [EOL] import codep [EOL] from . import partials [EOL] [EOL] logging . basicConfig ( stream = sys . stdout , level = logging . DEBUG ) [EOL] [EOL] utc , local_time = codep . run ( partials . utc_time , partials . local_time ) [EOL] logging . info ( f" [string] { local_time } [string] { utc }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import immutables [EOL] import typing [EOL] import datetime [EOL] import requests [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] import datetime [EOL] [EOL] import immutables [EOL] import pytz [EOL] import requests [EOL] [EOL] import codep [EOL] [EOL] [EOL] @ codep . make_partial ( ) async def fetch_current_time ( _state ) : [EOL] response = requests . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] payload = response . json ( ) [EOL] return datetime . datetime . fromisoformat ( payload [ [string] ] ) [EOL] [EOL] [EOL] @ codep . make_partial ( ) async def fetch_day_of_year ( _state ) : [EOL] response = requests . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] payload = response . json ( ) [EOL] return int ( payload [ [string] ] ) [EOL] [EOL] [EOL] @ codep . decorators . make_partial ( depends = ( fetch_current_time , ) ) async def add_one_hour ( state ) : [EOL] return fetch_current_time . value ( state ) + datetime . timedelta ( hours = [number] ) [EOL] [EOL] [EOL] @ codep . decorators . make_partial ( depends = ( add_one_hour , ) ) async def local_time ( state ) : [EOL] return add_one_hour . value ( state ) . astimezone ( pytz . timezone ( [string] ) ) [EOL] [EOL] [EOL] @ codep . decorators . make_partial ( depends = ( add_one_hour , fetch_day_of_year ) ) async def utc_time ( state ) : [EOL] return add_one_hour . value ( state ) . astimezone ( datetime . timezone . utc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0