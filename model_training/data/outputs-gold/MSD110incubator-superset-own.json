[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import sqlparse [EOL] from sqlparse . sql import Identifier , IdentifierList [EOL] from sqlparse . tokens import DML , Keyword [EOL] [EOL] [EOL] def is_subselect ( parsed ) : [EOL] if not parsed . is_group ( ) : [EOL] return False [EOL] for item in parsed . tokens : [EOL] if item . ttype is DML and item . value . upper ( ) == [string] : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def extract_from_part ( parsed ) : [EOL] from_seen = False [EOL] for item in parsed . tokens : [EOL] if from_seen : [EOL] if is_subselect ( item ) : [EOL] for x in extract_from_part ( item ) : [EOL] yield x [EOL] elif item . ttype is Keyword : [EOL] raise StopIteration [EOL] else : [EOL] yield item [EOL] elif item . ttype is Keyword and item . value . upper ( ) == [string] : [EOL] from_seen = True [EOL] [EOL] [EOL] def extract_table_identifiers ( token_stream ) : [EOL] for item in token_stream : [EOL] if isinstance ( item , IdentifierList ) : [EOL] for identifier in item . get_identifiers ( ) : [EOL] yield identifier . get_name ( ) [EOL] elif isinstance ( item , Identifier ) : [EOL] yield item . get_name ( ) [EOL] [comment] [EOL] [comment] [EOL] elif item . ttype is Keyword : [EOL] yield item . value [EOL] [EOL] [EOL] [comment] [EOL] def extract_tables ( sql ) : [EOL] stream = extract_from_part ( sqlparse . parse ( sql ) [ [number] ] ) [EOL] return list ( extract_table_identifiers ( stream ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Pattern , List , Dict [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] [EOL] from superset import frontend_config [EOL] [EOL] FORM_DATA_KEY_WHITELIST = list ( frontend_config . get ( [string] ) . keys ( ) ) + [ [string] ] [EOL] [EOL] [EOL] def cast_filter_data ( form_data ) : [EOL] [docstring] [EOL] flts = [ ] [EOL] having_flts = [ ] [EOL] fd = form_data [EOL] filter_pattern = re . compile ( [string] ) [EOL] for i in range ( [number] , [number] ) : [EOL] for prefix in [ [string] , [string] ] : [EOL] col_str = [string] . format ( prefix , i ) [EOL] op_str = [string] . format ( prefix , i ) [EOL] val_str = [string] . format ( prefix , i ) [EOL] if col_str in fd and op_str in fd and val_str in fd \ [EOL] and len ( fd [ val_str ] ) > [number] : [EOL] f = { } [EOL] f [ [string] ] = fd [ col_str ] [EOL] f [ [string] ] = fd [ op_str ] [EOL] if prefix == [string] : [EOL] [comment] [EOL] splitted = filter_pattern . split ( fd [ val_str ] ) [ [number] : : [number] ] [EOL] values = [ types . replace ( [string] , [string] ) . strip ( ) for types in splitted ] [EOL] f [ [string] ] = values [EOL] flts . append ( f ) [EOL] if prefix == [string] : [EOL] f [ [string] ] = fd [ val_str ] [EOL] having_flts . append ( f ) [EOL] if col_str in fd : [EOL] del fd [ col_str ] [EOL] if op_str in fd : [EOL] del fd [ op_str ] [EOL] if val_str in fd : [EOL] del fd [ val_str ] [EOL] fd [ [string] ] = flts [EOL] fd [ [string] ] = having_flts [EOL] return fd [EOL] [EOL] [EOL] def cast_form_data ( form_data ) : [EOL] [docstring] [EOL] d = { } [EOL] fields = frontend_config . get ( [string] , { } ) [EOL] for k , v in form_data . items ( ) : [EOL] field_config = fields . get ( k , { } ) [EOL] ft = field_config . get ( [string] ) [EOL] if ft == [string] : [EOL] [comment] [EOL] if isinstance ( v , list ) : [EOL] v = [string] in v [EOL] else : [EOL] v = True if v in ( [string] , [string] ) or v is True else False [EOL] elif v and ft == [string] and field_config . get ( [string] ) : [EOL] v = int ( v ) if v != [string] else None [EOL] elif v and ft == [string] and field_config . get ( [string] ) : [EOL] v = float ( v ) if v != [string] else None [EOL] elif v and ft == [string] : [EOL] if field_config . get ( [string] ) : [EOL] if type ( form_data ) . __name__ == [string] : [EOL] v = form_data . getlist ( k ) [EOL] elif not isinstance ( v , list ) : [EOL] v = [ v ] [EOL] if d . get ( [string] ) : [EOL] d [ [string] ] = int ( d [ [string] ] ) [EOL] [EOL] d [ k ] = v [EOL] if [string] not in d : [EOL] d = cast_filter_data ( d ) [EOL] for k in list ( d . keys ( ) ) : [EOL] if k not in FORM_DATA_KEY_WHITELIST : [EOL] del d [ k ] [EOL] return d [EOL] [EOL] [EOL] def update_time_range ( form_data ) : [EOL] [docstring] [EOL] if [string] in form_data or [string] in form_data : [EOL] form_data [ [string] ] = [string] . format ( form_data . pop ( [string] , [string] ) or [string] , form_data . pop ( [string] , [string] ) or [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Set , List [EOL] import typing [EOL] import logging [EOL] [EOL] import sqlparse [EOL] from sqlparse . sql import Identifier , IdentifierList [EOL] from sqlparse . tokens import Keyword , Name [EOL] [EOL] RESULT_OPERATIONS = { [string] , [string] , [string] , [string] } [EOL] ON_KEYWORD = [string] [EOL] PRECEDES_TABLE_NAME = { [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] CTE_PREFIX = [string] [EOL] [EOL] [EOL] class ParsedQuery ( object ) : [EOL] def __init__ ( self , sql_statement ) : [EOL] self . sql = sql_statement [EOL] self . _table_names = set ( ) [EOL] self . _alias_names = set ( ) [EOL] self . _limit = None [EOL] [EOL] logging . info ( [string] . format ( self . sql ) ) [EOL] self . _parsed = sqlparse . parse ( self . stripped ( ) ) [EOL] for statement in self . _parsed : [EOL] self . __extract_from_token ( statement ) [EOL] self . _limit = self . _extract_limit_from_query ( statement ) [EOL] self . _table_names = self . _table_names - self . _alias_names [EOL] [EOL] @ property def tables ( self ) : [EOL] return self . _table_names [EOL] [EOL] @ property def limit ( self ) : [EOL] return self . _limit [EOL] [EOL] def is_select ( self ) : [EOL] return self . _parsed [ [number] ] . get_type ( ) == [string] [EOL] [EOL] def is_explain ( self ) : [EOL] return self . stripped ( ) . upper ( ) . startswith ( [string] ) [EOL] [EOL] def is_readonly ( self ) : [EOL] [docstring] [EOL] return self . is_select ( ) or self . is_explain ( ) [EOL] [EOL] def stripped ( self ) : [EOL] return self . sql . strip ( [string] ) [EOL] [EOL] def get_statements ( self ) : [EOL] [docstring] [EOL] statements = [ ] [EOL] for statement in self . _parsed : [EOL] if statement : [EOL] sql = str ( statement ) . strip ( [string] ) [EOL] if sql : [EOL] statements . append ( sql ) [EOL] return statements [EOL] [EOL] @ staticmethod def __get_full_name ( identifier ) : [EOL] if len ( identifier . tokens ) > [number] and identifier . tokens [ [number] ] . value == [string] : [EOL] return [string] . format ( identifier . tokens [ [number] ] . value , identifier . tokens [ [number] ] . value ) [EOL] return identifier . get_real_name ( ) [EOL] [EOL] @ staticmethod def __is_identifier ( token ) : [EOL] return isinstance ( token , ( IdentifierList , Identifier ) ) [EOL] [EOL] def __process_identifier ( self , identifier ) : [EOL] [comment] [EOL] if [string] not in str ( identifier ) : [EOL] table_name = self . __get_full_name ( identifier ) [EOL] if not table_name . startswith ( CTE_PREFIX ) : [EOL] self . _table_names . add ( self . __get_full_name ( identifier ) ) [EOL] return [EOL] [EOL] [comment] [EOL] if hasattr ( identifier , [string] ) : [EOL] self . _alias_names . add ( identifier . get_alias ( ) ) [EOL] if hasattr ( identifier , [string] ) : [EOL] [comment] [EOL] if identifier . tokens [ [number] ] . ttype == Name : [EOL] self . _alias_names . add ( identifier . tokens [ [number] ] . value ) [EOL] self . __extract_from_token ( identifier ) [EOL] [EOL] def as_create_table ( self , table_name , overwrite = False ) : [EOL] [docstring] [EOL] exec_sql = [string] [EOL] sql = self . stripped ( ) [EOL] if overwrite : [EOL] exec_sql = f' [string] { table_name } [string] ' [EOL] exec_sql += f' [string] { table_name } [string] { sql }' [EOL] return exec_sql [EOL] [EOL] def __extract_from_token ( self , token , depth = [number] ) : [EOL] if not hasattr ( token , [string] ) : [EOL] return [EOL] [EOL] table_name_preceding_token = False [EOL] [EOL] for item in token . tokens : [EOL] logging . debug ( ( [string] * depth ) + str ( item . ttype ) + str ( item . value ) ) [EOL] if item . is_group and not self . __is_identifier ( item ) : [EOL] self . __extract_from_token ( item , depth = depth + [number] ) [EOL] [EOL] if ( item . ttype in Keyword and ( item . normalized in PRECEDES_TABLE_NAME or item . normalized . endswith ( [string] ) ) ) : [EOL] table_name_preceding_token = True [EOL] continue [EOL] [EOL] if item . ttype in Keyword : [EOL] table_name_preceding_token = False [EOL] continue [EOL] [EOL] if table_name_preceding_token : [EOL] if isinstance ( item , Identifier ) : [EOL] self . __process_identifier ( item ) [EOL] elif isinstance ( item , IdentifierList ) : [EOL] for token in item . get_identifiers ( ) : [EOL] self . __process_identifier ( token ) [EOL] elif isinstance ( item , IdentifierList ) : [EOL] for token in item . tokens : [EOL] if not self . __is_identifier ( token ) : [EOL] self . __extract_from_token ( item , depth = depth + [number] ) [EOL] [EOL] def _get_limit_from_token ( self , token ) : [EOL] if token . ttype == sqlparse . tokens . Literal . Number . Integer : [EOL] return int ( token . value ) [EOL] elif token . is_group : [EOL] return int ( token . get_token_at_offset ( [number] ) . value ) [EOL] [EOL] def _extract_limit_from_query ( self , statement ) : [EOL] limit_token = None [EOL] for pos , item in enumerate ( statement . tokens ) : [EOL] if item . ttype in Keyword and item . value . lower ( ) == [string] : [EOL] limit_token = statement . tokens [ pos + [number] ] [EOL] return self . _get_limit_from_token ( limit_token ) [EOL] [EOL] def get_query_with_new_limit ( self , new_limit ) : [EOL] [docstring] [EOL] [docstring] [EOL] if not self . _limit : [EOL] return self . sql + [string] + str ( new_limit ) [EOL] limit_pos = None [EOL] tokens = self . _parsed [ [number] ] . tokens [EOL] [comment] [EOL] for pos , item in enumerate ( tokens ) : [EOL] if item . ttype in Keyword and item . value . lower ( ) == [string] : [EOL] limit_pos = pos [EOL] break [EOL] limit = tokens [ limit_pos + [number] ] [EOL] if limit . ttype == sqlparse . tokens . Literal . Number . Integer : [EOL] tokens [ limit_pos + [number] ] . value = new_limit [EOL] elif limit . is_group : [EOL] tokens [ limit_pos + [number] ] . value = ( [string] . format ( next ( limit . get_identifiers ( ) ) , new_limit ) ) [EOL] [EOL] str_res = [string] [EOL] for i in tokens : [EOL] str_res += str ( i . value ) [EOL] return str_res [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] from sqlalchemy . sql import expression [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = [string] [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] op . add_column ( [string] , sa . Column ( [string] , sa . Boolean ( ) , nullable = False , server_default = expression . true ( ) ) ) [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] op . drop_column ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] from contextlib2 import contextmanager [EOL] [EOL] from superset . utils . dates import now_as_float [EOL] [EOL] [EOL] @ contextmanager def stats_timing ( stats_key , stats_logger ) : [EOL] [docstring] [EOL] start_ts = now_as_float ( ) [EOL] try : [EOL] yield start_ts [EOL] except Exception as e : [EOL] raise e [EOL] finally : [EOL] stats_logger . timing ( stats_key , now_as_float ( ) - start_ts ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Optional , List , Dict [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , List , Optional [EOL] [EOL] from superset import app [EOL] from superset . utils import core as utils [EOL] [EOL] [comment] [EOL] [comment] [EOL] Metric = Dict [EOL] [EOL] [EOL] class QueryObject : [EOL] [docstring] [EOL] def __init__ ( self , granularity , groupby = None , metrics = None , filters = None , time_range = None , time_shift = None , is_timeseries = False , row_limit = app . config . get ( [string] ) , limit = [number] , timeseries_limit_metric = None , order_desc = True , extras = None , ) : [EOL] self . granularity = granularity [EOL] self . from_dttm , self . to_dttm = utils . get_since_until ( time_range , time_shift ) [EOL] self . is_timeseries = is_timeseries [EOL] self . groupby = groupby or [ ] [EOL] self . metrics = metrics or [ ] [EOL] self . filter = filters or [ ] [EOL] self . row_limit = row_limit [EOL] self . timeseries_limit = int ( limit ) [EOL] self . timeseries_limit_metric = timeseries_limit_metric [EOL] self . order_desc = order_desc [EOL] self . prequeries = [ ] [EOL] self . is_prequery = False [EOL] self . extras = extras [EOL] [EOL] def to_dict ( self ) : [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import superset [EOL] import json [EOL] [EOL] from flask import g , request [EOL] from flask_appbuilder import expose [EOL] from flask_appbuilder . security . decorators import has_access_api [EOL] [EOL] from superset import appbuilder , security_manager [EOL] from superset . common . query_context import QueryContext [EOL] from superset . models . core import Log [EOL] from . base import api , BaseSupersetView , data_payload_response , handle_api_exception [EOL] [EOL] [EOL] class Api ( BaseSupersetView ) : [EOL] @ Log . log_this @ api @ handle_api_exception @ has_access_api @ expose ( [string] , methods = [ [string] ] ) def query ( self ) : [EOL] [docstring] [EOL] query_context = QueryContext ( ** json . loads ( request . form . get ( [string] ) ) ) [EOL] security_manager . assert_datasource_permission ( query_context . datasource , g . user ) [EOL] payload_json = query_context . get_data ( ) [EOL] return data_payload_response ( payload_json ) [EOL] [EOL] [EOL] appbuilder . add_view_no_menu ( Api ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $superset.common.query_context.QueryContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $superset.common.query_context.QueryContext$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $superset.common.query_context.QueryContext$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Callable , Any , Dict , Union [EOL] import typing [EOL] import superset [EOL] import jinja2 [EOL] from __future__ import absolute_import [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import unicode_literals [EOL] [EOL] from flask import request , Response [EOL] from flask_appbuilder import expose [EOL] from flask_appbuilder . security . decorators import has_access_api [EOL] from jinja2 . sandbox import SandboxedEnvironment [EOL] import simplejson as json [EOL] from sqlalchemy import and_ , func [EOL] from werkzeug . routing import BaseConverter [EOL] [EOL] from superset import app , appbuilder , db , utils [EOL] from superset . jinja_context import current_user_id , current_username [EOL] import superset . models . core [EOL] from superset . models . sql_lab import SavedQuery [EOL] from superset . models . tags import ObjectTypes , Tag , TaggedObject , TagTypes [EOL] from . base import BaseSupersetView , json_success [EOL] [EOL] [EOL] class ObjectTypeConverter ( BaseConverter ) : [EOL] [EOL] [docstring] [EOL] [EOL] def to_python ( self , object_type ) : [EOL] return ObjectTypes [ object_type ] [EOL] [EOL] def to_url ( self , object_type ) : [EOL] return object_type . name [EOL] [EOL] [EOL] def process_template ( content ) : [EOL] env = SandboxedEnvironment ( ) [EOL] template = env . from_string ( content ) [EOL] context = { [string] : current_user_id , [string] : current_username , } [EOL] return template . render ( context ) [EOL] [EOL] [EOL] def get_name ( obj ) : [EOL] if obj . Dashboard : [EOL] return obj . Dashboard . dashboard_title [EOL] elif obj . Slice : [EOL] return obj . Slice . slice_name [EOL] elif obj . SavedQuery : [EOL] return obj . SavedQuery . label [EOL] [EOL] [EOL] def get_creator ( obj ) : [EOL] if obj . Dashboard : [EOL] return obj . Dashboard . creator ( ) [EOL] elif obj . Slice : [EOL] return obj . Slice . creator ( ) [EOL] elif obj . SavedQuery : [EOL] return obj . SavedQuery . creator ( ) [EOL] [EOL] [EOL] def get_attribute ( obj , attr ) : [EOL] if obj . Dashboard : [EOL] return getattr ( obj . Dashboard , attr ) [EOL] elif obj . Slice : [EOL] return getattr ( obj . Slice , attr ) [EOL] elif obj . SavedQuery : [EOL] return getattr ( obj . SavedQuery , attr ) [EOL] [EOL] [EOL] class TagView ( BaseSupersetView ) : [EOL] [EOL] @ has_access_api @ expose ( [string] , methods = [ [string] ] ) def suggestions ( self ) : [EOL] query = ( db . session . query ( TaggedObject ) . group_by ( TaggedObject . tag_id ) . order_by ( func . count ( ) . desc ( ) ) . all ( ) ) [EOL] tags = [ { [string] : obj . tag . id , [string] : obj . tag . name } for obj in query ] [EOL] return json_success ( json . dumps ( tags ) ) [EOL] [EOL] @ has_access_api @ expose ( [string] , methods = [ [string] ] ) def get ( self , object_type , object_id ) : [EOL] [docstring] [EOL] query = db . session . query ( TaggedObject ) . filter ( and_ ( TaggedObject . object_type == object_type , TaggedObject . object_id == object_id ) ) [EOL] tags = [ { [string] : obj . tag . id , [string] : obj . tag . name } for obj in query ] [EOL] return json_success ( json . dumps ( tags ) ) [EOL] [EOL] @ has_access_api @ expose ( [string] , methods = [ [string] ] ) def post ( self , object_type , object_id ) : [EOL] [docstring] [EOL] tagged_objects = [ ] [EOL] for name in request . get_json ( force = True ) : [EOL] if [string] in name : [EOL] type_name = name . split ( [string] , [number] ) [ [number] ] [EOL] type_ = TagTypes [ type_name ] [EOL] else : [EOL] type_ = TagTypes . custom [EOL] [EOL] tag = db . session . query ( Tag ) . filter_by ( name = name , type = type_ ) . first ( ) [EOL] if not tag : [EOL] tag = Tag ( name = name , type = type_ ) [EOL] [EOL] tagged_objects . append ( TaggedObject ( object_id = object_id , object_type = object_type , tag = tag , ) , ) [EOL] [EOL] db . session . add_all ( tagged_objects ) [EOL] db . session . commit ( ) [EOL] [EOL] return Response ( status = [number] ) [comment] [EOL] [EOL] @ has_access_api @ expose ( [string] , methods = [ [string] ] ) def delete ( self , object_type , object_id ) : [EOL] [docstring] [EOL] tag_names = request . get_json ( force = True ) [EOL] if not tag_names : [EOL] return Response ( status = [number] ) [EOL] [EOL] db . session . query ( TaggedObject ) . filter ( and_ ( TaggedObject . object_type == object_type , TaggedObject . object_id == object_id ) , TaggedObject . tag . has ( Tag . name . in_ ( tag_names ) ) , ) . delete ( synchronize_session = False ) [EOL] db . session . commit ( ) [EOL] [EOL] return Response ( status = [number] ) [comment] [EOL] [EOL] @ has_access_api @ expose ( [string] , methods = [ [string] , [string] ] ) def tagged_objects ( self ) : [EOL] query = db . session . query ( TaggedObject , superset . models . core . Dashboard , superset . models . core . Slice , SavedQuery , ) . join ( Tag ) [EOL] [EOL] tags = request . args . get ( [string] ) [EOL] if not tags : [EOL] return json_success ( json . dumps ( [ ] ) ) [EOL] [EOL] tags = [ process_template ( tag ) for tag in tags . split ( [string] ) ] [EOL] query = query . filter ( Tag . name . in_ ( tags ) ) [EOL] [EOL] [comment] [EOL] types = request . args . get ( [string] ) [EOL] if types : [EOL] query = query . filter ( TaggedObject . object_type . in_ ( types . split ( [string] ) ) ) [EOL] [EOL] [comment] [EOL] query = query . outerjoin ( superset . models . core . Dashboard , and_ ( TaggedObject . object_id == superset . models . core . Dashboard . id , TaggedObject . object_type == ObjectTypes . dashboard , ) , ) . outerjoin ( superset . models . core . Slice , and_ ( TaggedObject . object_id == superset . models . core . Slice . id , TaggedObject . object_type == ObjectTypes . chart , ) , ) . outerjoin ( SavedQuery , and_ ( TaggedObject . object_id == SavedQuery . id , TaggedObject . object_type == ObjectTypes . query , ) , ) . group_by ( TaggedObject . object_id , TaggedObject . object_type ) [EOL] [EOL] objects = [ { [string] : get_attribute ( obj , [string] ) , [string] : obj . TaggedObject . object_type . name , [string] : get_name ( obj ) , [string] : get_attribute ( obj , [string] ) , [string] : get_attribute ( obj , [string] ) , [string] : get_attribute ( obj , [string] ) , [string] : get_creator ( obj ) , } for obj in query if get_attribute ( obj , [string] ) ] [EOL] [EOL] return json_success ( json . dumps ( objects , default = utils . core . json_int_dttm_ser ) ) [EOL] [EOL] [EOL] app . url_map . converters [ [string] ] = ObjectTypeConverter [EOL] appbuilder . add_view_no_menu ( TagView ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , DefaultDict , Set , Dict [EOL] import typing [EOL] from collections import defaultdict [EOL] [EOL] from flask import g [EOL] from flask_appbuilder . security . sqla import models as ab_models [EOL] [EOL] from superset import db [EOL] [EOL] [EOL] def bootstrap_user_data ( username = None , include_perms = False ) : [EOL] if username : [EOL] username = username [EOL] else : [EOL] username = g . user . username [EOL] [EOL] user = ( db . session . query ( ab_models . User ) . filter_by ( username = username ) . one ( ) ) [EOL] [EOL] payload = { [string] : user . username , [string] : user . first_name , [string] : user . last_name , [string] : user . id , [string] : user . is_active , [string] : user . created_on . isoformat ( ) , [string] : user . email , } [EOL] [EOL] if include_perms : [EOL] roles , permissions = get_permissions ( user ) [EOL] payload [ [string] ] = roles [EOL] payload [ [string] ] = permissions [EOL] [EOL] return payload [EOL] [EOL] [EOL] def get_permissions ( user ) : [EOL] if not user . roles : [EOL] raise AttributeError ( [string] ) [EOL] [EOL] roles = { } [EOL] permissions = defaultdict ( set ) [EOL] for role in user . roles : [EOL] perms = set ( ) [EOL] for perm in role . permissions : [EOL] if perm . permission and perm . view_menu : [EOL] perms . add ( ( perm . permission . name , perm . view_menu . name ) , ) [EOL] if perm . permission . name in ( [string] , [string] ) : [EOL] permissions [ perm . permission . name ] . add ( perm . view_menu . name ) [EOL] roles [ role . name ] = [ [ perm . permission . name , perm . view_menu . name ] for perm in role . permissions if perm . permission and perm . view_menu ] [EOL] [EOL] return roles , permissions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Type , List , Dict [EOL] import typing [EOL] import superset [EOL] from flask_appbuilder . models . sqla . interface import SQLAInterface [EOL] from flask_babel import gettext as __ [EOL] from flask_babel import lazy_gettext as _ [EOL] [EOL] from superset import appbuilder [EOL] from superset . models . annotations import Annotation , AnnotationLayer [EOL] from . base import DeleteMixin , SupersetModelView [EOL] [EOL] [EOL] class AnnotationModelView ( SupersetModelView , DeleteMixin ) : [comment] [EOL] datamodel = SQLAInterface ( Annotation ) [EOL] [EOL] list_title = _ ( [string] ) [EOL] show_title = _ ( [string] ) [EOL] add_title = _ ( [string] ) [EOL] edit_title = _ ( [string] ) [EOL] [EOL] list_columns = [ [string] , [string] , [string] , [string] ] [EOL] edit_columns = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] add_columns = edit_columns [EOL] [EOL] label_columns = { [string] : _ ( [string] ) , [string] : _ ( [string] ) , [string] : _ ( [string] ) , [string] : _ ( [string] ) , [string] : _ ( [string] ) , [string] : _ ( [string] ) , } [EOL] [EOL] description_columns = { [string] : [string] , } [EOL] [EOL] def pre_add ( self , obj ) : [EOL] if not obj . layer : [EOL] raise Exception ( [string] ) [EOL] if not obj . start_dttm and not obj . end_dttm : [EOL] raise Exception ( [string] ) [EOL] elif not obj . start_dttm : [EOL] obj . start_dttm = obj . end_dttm [EOL] elif not obj . end_dttm : [EOL] obj . end_dttm = obj . start_dttm [EOL] elif obj . end_dttm < obj . start_dttm : [EOL] raise Exception ( [string] ) [EOL] [EOL] def pre_update ( self , obj ) : [EOL] self . pre_add ( obj ) [EOL] [EOL] [EOL] class AnnotationLayerModelView ( SupersetModelView , DeleteMixin ) : [EOL] datamodel = SQLAInterface ( AnnotationLayer ) [EOL] [EOL] list_title = _ ( [string] ) [EOL] show_title = _ ( [string] ) [EOL] add_title = _ ( [string] ) [EOL] edit_title = _ ( [string] ) [EOL] [EOL] list_columns = [ [string] , [string] ] [EOL] edit_columns = [ [string] , [string] ] [EOL] add_columns = edit_columns [EOL] [EOL] label_columns = { [string] : _ ( [string] ) , [string] : _ ( [string] ) , } [EOL] [EOL] [EOL] appbuilder . add_view ( AnnotationLayerModelView , [string] , label = __ ( [string] ) , icon = [string] , category = [string] , category_label = __ ( [string] ) , category_icon = [string] ) [EOL] appbuilder . add_view ( AnnotationModelView , [string] , label = __ ( [string] ) , icon = [string] , category = [string] , category_label = __ ( [string] ) , category_icon = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from superset import app [EOL] from superset . utils . core import get_celery_app [EOL] [EOL] [comment] [EOL] config = app . config [EOL] app = get_celery_app ( config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Set , List , Dict [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import json [EOL] import os [EOL] [EOL] from superset import app , db [EOL] from superset . connectors . connector_registry import ConnectorRegistry [EOL] from superset . models import core as models [EOL] [EOL] [comment] [EOL] DB = models . Database [EOL] Slice = models . Slice [EOL] Dash = models . Dashboard [EOL] [EOL] TBL = ConnectorRegistry . sources [ [string] ] [EOL] [EOL] config = app . config [EOL] [EOL] DATA_FOLDER = os . path . join ( config . get ( [string] ) , [string] ) [EOL] [EOL] misc_dash_slices = set ( ) [comment] [EOL] [EOL] [EOL] def update_slice_ids ( layout_dict , slices ) : [EOL] charts = [ component for component in layout_dict . values ( ) if isinstance ( component , dict ) and component [ [string] ] == [string] ] [EOL] sorted_charts = sorted ( charts , key = lambda k : k [ [string] ] [ [string] ] ) [EOL] for i , chart_component in enumerate ( sorted_charts ) : [EOL] if i < len ( slices ) : [EOL] chart_component [ [string] ] [ [string] ] = int ( slices [ i ] . id ) [EOL] [EOL] [EOL] def merge_slice ( slc ) : [EOL] o = db . session . query ( Slice ) . filter_by ( slice_name = slc . slice_name ) . first ( ) [EOL] if o : [EOL] db . session . delete ( o ) [EOL] db . session . add ( slc ) [EOL] db . session . commit ( ) [EOL] [EOL] [EOL] def get_slice_json ( defaults , ** kwargs ) : [EOL] d = defaults . copy ( ) [EOL] d . update ( kwargs ) [EOL] return json . dumps ( d , indent = [number] , sort_keys = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import gzip [EOL] import json [EOL] import os [EOL] [EOL] import pandas as pd [EOL] from sqlalchemy import BigInteger , Text [EOL] [EOL] from superset import db [EOL] from superset . utils import core as utils [EOL] from . helpers import DATA_FOLDER , TBL [EOL] [EOL] [EOL] def load_sf_population_polygons ( ) : [EOL] tbl_name = [string] [EOL] [EOL] with gzip . open ( os . path . join ( DATA_FOLDER , [string] ) ) as f : [EOL] df = pd . read_json ( f ) [EOL] df [ [string] ] = df . contour . map ( json . dumps ) [EOL] [EOL] df . to_sql ( tbl_name , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : BigInteger , [string] : BigInteger , [string] : Text , [string] : BigInteger , } , index = False ) [EOL] print ( [string] . format ( tbl_name ) ) [EOL] tbl = db . session . query ( TBL ) . filter_by ( table_name = tbl_name ) . first ( ) [EOL] if not tbl : [EOL] tbl = TBL ( table_name = tbl_name ) [EOL] tbl . description = [string] [EOL] tbl . database = utils . get_or_create_main_db ( ) [EOL] db . session . merge ( tbl ) [EOL] db . session . commit ( ) [EOL] tbl . fetch_metadata ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import gzip [EOL] import json [EOL] import os [EOL] [EOL] import pandas as pd [EOL] from sqlalchemy import String , Text [EOL] [EOL] from superset import db [EOL] from superset . utils import core as utils [EOL] from . helpers import DATA_FOLDER , TBL [EOL] [EOL] [EOL] def load_paris_iris_geojson ( ) : [EOL] tbl_name = [string] [EOL] [EOL] with gzip . open ( os . path . join ( DATA_FOLDER , [string] ) ) as f : [EOL] df = pd . read_json ( f ) [EOL] df [ [string] ] = df . features . map ( json . dumps ) [EOL] [EOL] df . to_sql ( tbl_name , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : Text , [string] : Text , } , index = False ) [EOL] print ( [string] . format ( tbl_name ) ) [EOL] tbl = db . session . query ( TBL ) . filter_by ( table_name = tbl_name ) . first ( ) [EOL] if not tbl : [EOL] tbl = TBL ( table_name = tbl_name ) [EOL] tbl . description = [string] [EOL] tbl . database = utils . get_or_create_main_db ( ) [EOL] db . session . merge ( tbl ) [EOL] db . session . commit ( ) [EOL] tbl . fetch_metadata ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import json [EOL] import textwrap [EOL] [EOL] [EOL] from superset import db [EOL] from . helpers import ( Dash , misc_dash_slices , Slice , update_slice_ids , ) [EOL] [EOL] DASH_SLUG = [string] [EOL] [EOL] [EOL] def load_misc_dashboard ( ) : [EOL] [docstring] [EOL] [EOL] print ( [string] ) [EOL] db . session . expunge_all ( ) [EOL] dash = db . session . query ( Dash ) . filter_by ( slug = DASH_SLUG ) . first ( ) [EOL] [EOL] if not dash : [EOL] dash = Dash ( ) [EOL] js = textwrap . dedent ( [string] ) [EOL] pos = json . loads ( js ) [EOL] slices = ( db . session . query ( Slice ) . filter ( Slice . slice_name . in_ ( misc_dash_slices ) ) . all ( ) ) [EOL] slices = sorted ( slices , key = lambda x : x . id ) [EOL] update_slice_ids ( pos , slices ) [EOL] dash . dashboard_title = [string] [EOL] dash . position_json = json . dumps ( pos , indent = [number] ) [EOL] dash . slug = DASH_SLUG [EOL] dash . slices = slices [EOL] db . session . merge ( dash ) [EOL] db . session . commit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import gzip [EOL] import os [EOL] [EOL] import pandas as pd [EOL] from sqlalchemy import DateTime [EOL] [EOL] from superset import db [EOL] from superset . utils import core as utils [EOL] from . helpers import DATA_FOLDER , TBL [EOL] [EOL] [EOL] def load_flights ( ) : [EOL] [docstring] [EOL] tbl_name = [string] [EOL] with gzip . open ( os . path . join ( DATA_FOLDER , [string] ) ) as f : [EOL] pdf = pd . read_csv ( f , encoding = [string] ) [EOL] [EOL] [comment] [EOL] with gzip . open ( os . path . join ( DATA_FOLDER , [string] ) ) as f : [EOL] airports = pd . read_csv ( f , encoding = [string] ) [EOL] airports = airports . set_index ( [string] ) [EOL] [EOL] pdf [ [string] ] = pdf . YEAR . map ( str ) + [string] + pdf . MONTH . map ( str ) + [string] + pdf . DAY . map ( str ) [EOL] pdf . ds = pd . to_datetime ( pdf . ds ) [EOL] del pdf [ [string] ] [EOL] del pdf [ [string] ] [EOL] del pdf [ [string] ] [EOL] [EOL] pdf = pdf . join ( airports , on = [string] , rsuffix = [string] ) [EOL] pdf = pdf . join ( airports , on = [string] , rsuffix = [string] ) [EOL] pdf . to_sql ( tbl_name , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : DateTime , } , index = False ) [EOL] tbl = db . session . query ( TBL ) . filter_by ( table_name = tbl_name ) . first ( ) [EOL] if not tbl : [EOL] tbl = TBL ( table_name = tbl_name ) [EOL] tbl . description = [string] [EOL] tbl . database = utils . get_or_create_main_db ( ) [EOL] db . session . merge ( tbl ) [EOL] db . session . commit ( ) [EOL] tbl . fetch_metadata ( ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import gzip [EOL] import json [EOL] import os [EOL] [EOL] import pandas as pd [EOL] import polyline [EOL] from sqlalchemy import String , Text [EOL] [EOL] from superset import db [EOL] from superset . utils . core import get_or_create_main_db [EOL] from . helpers import DATA_FOLDER , TBL [EOL] [EOL] [EOL] def load_bart_lines ( ) : [EOL] tbl_name = [string] [EOL] with gzip . open ( os . path . join ( DATA_FOLDER , [string] ) ) as f : [EOL] df = pd . read_json ( f , encoding = [string] ) [EOL] df [ [string] ] = df . path . map ( json . dumps ) [EOL] df [ [string] ] = df . path . map ( polyline . encode ) [EOL] del df [ [string] ] [EOL] df . to_sql ( tbl_name , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : Text , [string] : Text , } , index = False ) [EOL] print ( [string] . format ( tbl_name ) ) [EOL] tbl = db . session . query ( TBL ) . filter_by ( table_name = tbl_name ) . first ( ) [EOL] if not tbl : [EOL] tbl = TBL ( table_name = tbl_name ) [EOL] tbl . description = [string] [EOL] tbl . database = get_or_create_main_db ( ) [EOL] db . session . merge ( tbl ) [EOL] db . session . commit ( ) [EOL] tbl . fetch_metadata ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Dict , Any , Optional , Union [EOL] import typing [EOL] import gzip [EOL] import os [EOL] [EOL] import pandas as pd [EOL] from sqlalchemy import BigInteger , Date , DateTime , String [EOL] [EOL] from superset import db [EOL] from superset . utils import core as utils [EOL] from . helpers import ( config , DATA_FOLDER , get_slice_json , merge_slice , misc_dash_slices , Slice , TBL , ) [EOL] [EOL] [EOL] def load_multiformat_time_series ( ) : [EOL] [docstring] [EOL] with gzip . open ( os . path . join ( DATA_FOLDER , [string] ) ) as f : [EOL] pdf = pd . read_json ( f ) [EOL] pdf . ds = pd . to_datetime ( pdf . ds , unit = [string] ) [EOL] pdf . ds2 = pd . to_datetime ( pdf . ds2 , unit = [string] ) [EOL] pdf . to_sql ( [string] , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : Date , [string] : DateTime , [string] : BigInteger , [string] : BigInteger , [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : String ( [number] ) , } , index = False ) [EOL] print ( [string] ) [EOL] print ( [string] * [number] ) [EOL] print ( [string] ) [EOL] obj = db . session . query ( TBL ) . filter_by ( table_name = [string] ) . first ( ) [EOL] if not obj : [EOL] obj = TBL ( table_name = [string] ) [EOL] obj . main_dttm_col = [string] [EOL] obj . database = utils . get_or_create_main_db ( ) [EOL] dttm_and_expr_dict = { [string] : [ None , None ] , [string] : [ None , None ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , } [EOL] for col in obj . columns : [EOL] dttm_and_expr = dttm_and_expr_dict [ col . column_name ] [EOL] col . python_date_format = dttm_and_expr [ [number] ] [EOL] col . dbatabase_expr = dttm_and_expr [ [number] ] [EOL] col . is_dttm = True [EOL] db . session . merge ( obj ) [EOL] db . session . commit ( ) [EOL] obj . fetch_metadata ( ) [EOL] tbl = obj [EOL] [EOL] print ( [string] ) [EOL] for i , col in enumerate ( tbl . columns ) : [EOL] slice_data = { [string] : [ [string] ] , [string] : col . column_name , [string] : config . get ( [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] slc = Slice ( slice_name = f' [string] { i }' , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = get_slice_json ( slice_data ) , ) [EOL] merge_slice ( slc ) [EOL] misc_dash_slices . add ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Dict , Any , Type , Literal , Tuple [EOL] import typing [EOL] import superset [EOL] import typing_extensions [EOL] import json [EOL] [EOL] from sqlalchemy import ( and_ , Boolean , Column , Integer , String , Text , ) [EOL] from sqlalchemy . ext . declarative import declared_attr [EOL] from sqlalchemy . orm import foreign , relationship [EOL] [EOL] from superset . models . core import Slice [EOL] from superset . models . helpers import AuditMixinNullable , ImportMixin [EOL] from superset . utils import core as utils [EOL] [EOL] [EOL] class BaseDatasource ( AuditMixinNullable , ImportMixin ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] __tablename__ = None [comment] [EOL] type = None [comment] [EOL] baselink = None [comment] [EOL] column_class = None [comment] [EOL] metric_class = None [comment] [EOL] owner_class = None [EOL] [EOL] [comment] [EOL] query_language = None [EOL] [EOL] name = None [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] id = Column ( Integer , primary_key = True ) [EOL] description = Column ( Text ) [EOL] default_endpoint = Column ( Text ) [EOL] is_featured = Column ( Boolean , default = False ) [comment] [EOL] filter_select_enabled = Column ( Boolean , default = False ) [EOL] offset = Column ( Integer , default = [number] ) [EOL] cache_timeout = Column ( Integer ) [EOL] params = Column ( String ( [number] ) ) [EOL] perm = Column ( String ( [number] ) ) [EOL] [EOL] sql = None [EOL] owners = None [EOL] update_from_object_fields = None [EOL] [EOL] @ declared_attr def slices ( self ) : [EOL] return relationship ( [string] , primaryjoin = lambda : and_ ( foreign ( Slice . datasource_id ) == self . id , foreign ( Slice . datasource_type ) == self . type , ) , ) [EOL] [EOL] [comment] [EOL] columns = [ ] [EOL] [comment] [EOL] metrics = [ ] [EOL] [EOL] @ property def uid ( self ) : [EOL] [docstring] [EOL] return f'{ self . id } [string] { self . type }' [EOL] [EOL] @ property def column_names ( self ) : [EOL] return sorted ( [ c . column_name for c in self . columns ] ) [EOL] [EOL] @ property def columns_types ( self ) : [EOL] return { c . column_name : c . type for c in self . columns } [EOL] [EOL] @ property def main_dttm_col ( self ) : [EOL] return [string] [EOL] [EOL] @ property def datasource_name ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ property def connection ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] @ property def schema ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] @ property def filterable_column_names ( self ) : [EOL] return sorted ( [ c . column_name for c in self . columns if c . filterable ] ) [EOL] [EOL] @ property def dttm_cols ( self ) : [EOL] return [ ] [EOL] [EOL] @ property def url ( self ) : [EOL] return [string] . format ( self . baselink , self . id ) [EOL] [EOL] @ property def explore_url ( self ) : [EOL] if self . default_endpoint : [EOL] return self . default_endpoint [EOL] else : [EOL] return [string] . format ( obj = self ) [EOL] [EOL] @ property def column_formats ( self ) : [EOL] return { m . metric_name : m . d3format for m in self . metrics if m . d3format } [EOL] [EOL] def add_missing_metrics ( self , metrics ) : [EOL] exisiting_metrics = { m . metric_name for m in self . metrics } [EOL] for metric in metrics : [EOL] if metric . metric_name not in exisiting_metrics : [EOL] metric . table_id = self . id [EOL] self . metrics += [ metric ] [EOL] [EOL] @ property def short_data ( self ) : [EOL] [docstring] [EOL] return { [string] : self . url , [string] : self . id , [string] : self . uid , [string] : self . schema , [string] : self . name , [string] : self . type , [string] : self . connection , [string] : str ( self . created_by ) , } [EOL] [EOL] @ property def select_star ( self ) : [EOL] pass [EOL] [EOL] @ property def data ( self ) : [EOL] [docstring] [EOL] order_by_choices = [ ] [EOL] for s in sorted ( self . column_names ) : [EOL] order_by_choices . append ( ( json . dumps ( [ s , True ] ) , s + [string] ) ) [EOL] order_by_choices . append ( ( json . dumps ( [ s , False ] ) , s + [string] ) ) [EOL] [EOL] verbose_map = { [string] : [string] } [EOL] verbose_map . update ( { o . metric_name : o . verbose_name or o . metric_name for o in self . metrics } ) [EOL] verbose_map . update ( { o . column_name : o . verbose_name or o . column_name for o in self . columns } ) [EOL] return { [string] : self . id , [string] : self . column_formats , [string] : self . description , [string] : self . database . data , [string] : self . default_endpoint , [string] : self . filter_select_enabled , [string] : self . filter_select_enabled , [string] : self . name , [string] : self . datasource_name , [string] : self . type , [string] : self . schema , [string] : self . offset , [string] : self . cache_timeout , [string] : self . params , [string] : self . perm , [string] : self . url , [string] : self . sql , [string] : [ o . data for o in self . columns ] , [string] : [ o . data for o in self . metrics ] , [string] : order_by_choices , [string] : [ owner . id for owner in self . owners ] , [string] : verbose_map , [string] : self . select_star , } [EOL] [EOL] @ staticmethod def filter_values_handler ( values , target_column_is_numeric = False , is_list_target = False ) : [EOL] def handle_single_value ( v ) : [EOL] [comment] [EOL] if isinstance ( v , str ) : [EOL] v = v . strip ( [string] ) [EOL] if target_column_is_numeric : [EOL] [comment] [EOL] [comment] [EOL] v = utils . string_to_num ( v ) [EOL] if v == [string] : [EOL] return None [EOL] elif v == [string] : [EOL] return [string] [EOL] return v [EOL] if isinstance ( values , ( list , tuple ) ) : [EOL] values = [ handle_single_value ( v ) for v in values ] [EOL] else : [EOL] values = handle_single_value ( values ) [EOL] if is_list_target and not isinstance ( values , ( tuple , list ) ) : [EOL] values = [ values ] [EOL] elif not is_list_target and isinstance ( values , ( tuple , list ) ) : [EOL] if len ( values ) > [number] : [EOL] values = values [ [number] ] [EOL] else : [EOL] values = None [EOL] return values [EOL] [EOL] def external_metadata ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def get_query_str ( self , query_obj ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def query ( self , query_obj ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def values_for_column ( self , column_name , limit = [number] ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ staticmethod def default_query ( qry ) : [EOL] return qry [EOL] [EOL] def get_column ( self , column_name ) : [EOL] for col in self . columns : [EOL] if col . column_name == column_name : [EOL] return col [EOL] [EOL] def get_fk_many_from_list ( self , object_list , fkmany , fkmany_class , key_attr ) : [EOL] [docstring] [EOL] [EOL] object_dict = { o . get ( key_attr ) : o for o in object_list } [EOL] object_keys = [ o . get ( key_attr ) for o in object_list ] [EOL] [EOL] [comment] [EOL] fkmany = [ o for o in fkmany if getattr ( o , key_attr ) in object_keys ] [EOL] [EOL] [comment] [EOL] for fk in fkmany : [EOL] obj = object_dict . get ( getattr ( fk , key_attr ) ) [EOL] for attr in fkmany_class . update_from_object_fields : [EOL] setattr ( fk , attr , obj . get ( attr ) ) [EOL] [EOL] [comment] [EOL] new_fks = [ ] [EOL] orm_keys = [ getattr ( o , key_attr ) for o in fkmany ] [EOL] for obj in object_list : [EOL] key = obj . get ( key_attr ) [EOL] if key not in orm_keys : [EOL] del obj [ [string] ] [EOL] orm_kwargs = { } [EOL] for k in obj : [EOL] if ( k in fkmany_class . update_from_object_fields and k in obj ) : [EOL] orm_kwargs [ k ] = obj [ k ] [EOL] new_obj = fkmany_class ( ** orm_kwargs ) [EOL] new_fks . append ( new_obj ) [EOL] fkmany += new_fks [EOL] return fkmany [EOL] [EOL] def update_from_object ( self , obj ) : [EOL] [docstring] [EOL] for attr in self . update_from_object_fields : [EOL] setattr ( self , attr , obj . get ( attr ) ) [EOL] [EOL] self . owners = obj . get ( [string] , [ ] ) [EOL] [EOL] [comment] [EOL] metrics = self . get_fk_many_from_list ( obj . get ( [string] ) , self . metrics , self . metric_class , [string] ) [EOL] self . metrics = metrics [EOL] [EOL] [comment] [EOL] self . columns = self . get_fk_many_from_list ( obj . get ( [string] ) , self . columns , self . column_class , [string] ) [EOL] [EOL] [EOL] class BaseColumn ( AuditMixinNullable , ImportMixin ) : [EOL] [docstring] [EOL] [EOL] __tablename__ = None [comment] [EOL] [EOL] id = Column ( Integer , primary_key = True ) [EOL] column_name = Column ( String ( [number] ) ) [EOL] verbose_name = Column ( String ( [number] ) ) [EOL] is_active = Column ( Boolean , default = True ) [EOL] type = Column ( String ( [number] ) ) [EOL] groupby = Column ( Boolean , default = True ) [EOL] filterable = Column ( Boolean , default = True ) [EOL] description = Column ( Text ) [EOL] is_dttm = None [EOL] [EOL] [comment] [EOL] export_fields = [ ] [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . column_name [EOL] [EOL] num_types = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] date_types = ( [string] , [string] , [string] ) [EOL] str_types = ( [string] , [string] , [string] ) [EOL] [EOL] @ property def is_num ( self ) : [EOL] return ( self . type and any ( [ t in self . type . upper ( ) for t in self . num_types ] ) ) [EOL] [EOL] @ property def is_time ( self ) : [EOL] return ( self . type and any ( [ t in self . type . upper ( ) for t in self . date_types ] ) ) [EOL] [EOL] @ property def is_string ( self ) : [EOL] return ( self . type and any ( [ t in self . type . upper ( ) for t in self . str_types ] ) ) [EOL] [EOL] @ property def expression ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ property def data ( self ) : [EOL] attrs = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] return { s : getattr ( self , s ) for s in attrs if hasattr ( self , s ) } [EOL] [EOL] [EOL] class BaseMetric ( AuditMixinNullable , ImportMixin ) : [EOL] [EOL] [docstring] [EOL] [EOL] __tablename__ = None [comment] [EOL] [EOL] id = Column ( Integer , primary_key = True ) [EOL] metric_name = Column ( String ( [number] ) ) [EOL] verbose_name = Column ( String ( [number] ) ) [EOL] metric_type = Column ( String ( [number] ) ) [EOL] description = Column ( Text ) [EOL] is_restricted = Column ( Boolean , default = False , nullable = True ) [EOL] d3format = Column ( String ( [number] ) ) [EOL] warning_text = Column ( Text ) [EOL] [EOL] [docstring] [EOL] @ property def perm ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ property def expression ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ property def data ( self ) : [EOL] attrs = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] return { s : getattr ( self , s ) for s in attrs } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[superset.connectors.base.models.BaseMetric]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[superset.connectors.base.models.BaseMetric]$ 0 0 0 0 0 0 0 0 0 $typing.Type[superset.connectors.base.models.BaseMetric]$ 0 0 0 0 0 0 0 0 0 $typing.Type[superset.connectors.base.models.BaseMetric]$ 0 0 0 0 0 0 0 0 0 $typing.Type[superset.connectors.base.models.BaseMetric]$ 0 0 0 0 0 0 $typing.Type[superset.connectors.base.models.BaseMetric]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[superset.connectors.base.models.BaseMetric]$ 0 0 0 0 0 0 0 0 0 $typing.Type[superset.connectors.base.models.BaseMetric]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Type [EOL] import typing [EOL] import superset [EOL] from flask_appbuilder import Model [EOL] from sqlalchemy import Column , ForeignKey , Integer [EOL] from sqlalchemy . orm import relationship [EOL] [EOL] from superset import security_manager [EOL] from superset . models . helpers import AuditMixinNullable [EOL] [EOL] [EOL] class UserAttribute ( Model , AuditMixinNullable ) : [EOL] [EOL] [docstring] [EOL] [EOL] __tablename__ = [string] [EOL] id = Column ( Integer , primary_key = True ) [comment] [EOL] user_id = Column ( Integer , ForeignKey ( [string] ) ) [EOL] user = relationship ( security_manager . user_model , backref = [string] , foreign_keys = [ user_id ] , ) [EOL] [EOL] welcome_dashboard_id = Column ( Integer , ForeignKey ( [string] ) ) [EOL] welcome_dashboard = relationship ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[superset.models.user_attributes.UserAttribute]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[superset.models.user_attributes.UserAttribute]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[superset.models.user_attributes.UserAttribute]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[superset.models.user_attributes.UserAttribute]$ 0 0 0 0 0 $typing.Type[superset.models.user_attributes.UserAttribute]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[superset.models.user_attributes.UserAttribute]$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Type , List [EOL] import unittest [EOL] import datetime [EOL] import tests [EOL] import typing [EOL] from datetime import datetime , timedelta [EOL] import unittest [EOL] from unittest . mock import Mock , patch , PropertyMock [EOL] [EOL] from flask_babel import gettext as __ [EOL] from selenium . common . exceptions import WebDriverException [EOL] [EOL] from superset import app , db [EOL] from superset . models . core import Dashboard , Slice [EOL] from superset . models . schedules import ( DashboardEmailSchedule , EmailDeliveryType , SliceEmailReportFormat , SliceEmailSchedule , ) [EOL] from superset . tasks . schedules import ( create_webdriver , deliver_dashboard , deliver_slice , next_schedules , ) [EOL] from . utils import read_fixture [EOL] [EOL] [EOL] class SchedulesTestCase ( unittest . TestCase ) : [EOL] [EOL] RECIPIENTS = [string] [EOL] BCC = [string] [EOL] CSV = read_fixture ( [string] ) [EOL] [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . common_data = dict ( active = True , crontab = [string] , recipients = cls . RECIPIENTS , deliver_as_group = True , delivery_type = EmailDeliveryType . inline , ) [EOL] [EOL] [comment] [EOL] slce = db . session . query ( Slice ) . all ( ) [ [number] ] [EOL] dashboard = db . session . query ( Dashboard ) . all ( ) [ [number] ] [EOL] [EOL] dashboard_schedule = DashboardEmailSchedule ( ** cls . common_data ) [EOL] dashboard_schedule . dashboard_id = dashboard . id [EOL] dashboard_schedule . user_id = [number] [EOL] db . session . add ( dashboard_schedule ) [EOL] [EOL] slice_schedule = SliceEmailSchedule ( ** cls . common_data ) [EOL] slice_schedule . slice_id = slce . id [EOL] slice_schedule . user_id = [number] [EOL] slice_schedule . email_format = SliceEmailReportFormat . data [EOL] [EOL] db . session . add ( slice_schedule ) [EOL] db . session . commit ( ) [EOL] [EOL] cls . slice_schedule = slice_schedule . id [EOL] cls . dashboard_schedule = dashboard_schedule . id [EOL] [EOL] @ classmethod def tearDownClass ( cls ) : [EOL] db . session . query ( SliceEmailSchedule ) . filter_by ( id = cls . slice_schedule ) . delete ( ) [EOL] db . session . query ( DashboardEmailSchedule ) . filter_by ( id = cls . dashboard_schedule ) . delete ( ) [EOL] db . session . commit ( ) [EOL] [EOL] def test_crontab_scheduler ( self ) : [EOL] crontab = [string] [EOL] [EOL] start_at = datetime . now ( ) . replace ( microsecond = [number] , second = [number] , minute = [number] ) [EOL] stop_at = start_at + timedelta ( seconds = [number] ) [EOL] [EOL] [comment] [EOL] schedules = list ( next_schedules ( crontab , start_at , stop_at , resolution = [number] ) ) [EOL] [EOL] self . assertEqual ( schedules [ [number] ] , start_at ) [EOL] self . assertEqual ( schedules [ - [number] ] , stop_at - timedelta ( seconds = [number] ) ) [EOL] self . assertEqual ( len ( schedules ) , [number] ) [EOL] [EOL] [comment] [EOL] schedules = list ( next_schedules ( crontab , start_at , stop_at , resolution = [number] * [number] ) ) [EOL] [EOL] self . assertEqual ( schedules [ [number] ] , start_at ) [EOL] self . assertEqual ( schedules [ - [number] ] , stop_at - timedelta ( seconds = [number] * [number] ) ) [EOL] self . assertEqual ( len ( schedules ) , [number] ) [EOL] [EOL] [comment] [EOL] schedules = list ( next_schedules ( crontab , start_at , stop_at , resolution = [number] * [number] ) ) [EOL] [EOL] self . assertEqual ( schedules [ [number] ] , start_at ) [EOL] self . assertEqual ( schedules [ - [number] ] , stop_at - timedelta ( seconds = [number] * [number] ) ) [EOL] self . assertEqual ( len ( schedules ) , [number] ) [EOL] [EOL] def test_wider_schedules ( self ) : [EOL] crontab = [string] [EOL] [EOL] for hour in range ( [number] , [number] ) : [EOL] start_at = datetime . now ( ) . replace ( microsecond = [number] , second = [number] , minute = [number] , hour = hour ) [EOL] stop_at = start_at + timedelta ( seconds = [number] ) [EOL] schedules = list ( next_schedules ( crontab , start_at , stop_at , resolution = [number] ) ) [EOL] [EOL] if hour in ( [number] , [number] ) : [EOL] self . assertEqual ( len ( schedules ) , [number] ) [EOL] else : [EOL] self . assertEqual ( len ( schedules ) , [number] ) [EOL] [EOL] def test_complex_schedule ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] crontab = [string] [EOL] start_at = datetime . strptime ( [string] , [string] ) [EOL] stop_at = datetime . strptime ( [string] , [string] ) [EOL] [EOL] schedules = list ( next_schedules ( crontab , start_at , stop_at , resolution = [number] ) ) [EOL] self . assertEqual ( len ( schedules ) , [number] ) [EOL] fmt = [string] [EOL] self . assertEqual ( schedules [ [number] ] , datetime . strptime ( [string] , fmt ) ) [EOL] self . assertEqual ( schedules [ - [number] ] , datetime . strptime ( [string] , fmt ) ) [EOL] self . assertEqual ( schedules [ [number] ] , datetime . strptime ( [string] , fmt ) ) [EOL] self . assertEqual ( schedules [ [number] ] , datetime . strptime ( [string] , fmt ) ) [EOL] [EOL] @ patch ( [string] ) def test_create_driver ( self , mock_driver_class ) : [EOL] mock_driver = Mock ( ) [EOL] mock_driver_class . return_value = mock_driver [EOL] mock_driver . find_elements_by_id . side_effect = [ True , False ] [EOL] [EOL] create_webdriver ( ) [EOL] create_webdriver ( ) [EOL] mock_driver . add_cookie . assert_called_once ( ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) def test_deliver_dashboard_inline ( self , mtime , send_email_smtp , driver_class ) : [EOL] element = Mock ( ) [EOL] driver = Mock ( ) [EOL] mtime . sleep . return_value = None [EOL] [EOL] driver_class . return_value = driver [EOL] [EOL] [comment] [EOL] driver . find_elements_by_id . side_effect = [ True , False ] [EOL] driver . find_element_by_class_name . return_value = element [EOL] element . screenshot_as_png = read_fixture ( [string] ) [EOL] [EOL] schedule = db . session . query ( DashboardEmailSchedule ) . filter_by ( id = self . dashboard_schedule ) . all ( ) [ [number] ] [EOL] [EOL] deliver_dashboard ( schedule ) [EOL] mtime . sleep . assert_called_once ( ) [EOL] driver . screenshot . assert_not_called ( ) [EOL] send_email_smtp . assert_called_once ( ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) def test_deliver_dashboard_as_attachment ( self , mtime , send_email_smtp , driver_class ) : [EOL] element = Mock ( ) [EOL] driver = Mock ( ) [EOL] mtime . sleep . return_value = None [EOL] [EOL] driver_class . return_value = driver [EOL] [EOL] [comment] [EOL] driver . find_elements_by_id . side_effect = [ True , False ] [EOL] driver . find_element_by_id . return_value = element [EOL] driver . find_element_by_class_name . return_value = element [EOL] element . screenshot_as_png = read_fixture ( [string] ) [EOL] [EOL] schedule = db . session . query ( DashboardEmailSchedule ) . filter_by ( id = self . dashboard_schedule ) . all ( ) [ [number] ] [EOL] [EOL] schedule . delivery_type = EmailDeliveryType . attachment [EOL] deliver_dashboard ( schedule ) [EOL] [EOL] mtime . sleep . assert_called_once ( ) [EOL] driver . screenshot . assert_not_called ( ) [EOL] send_email_smtp . assert_called_once ( ) [EOL] self . assertIsNone ( send_email_smtp . call_args [ [number] ] [ [string] ] ) [EOL] self . assertEquals ( send_email_smtp . call_args [ [number] ] [ [string] ] [ [string] ] , element . screenshot_as_png , ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) def test_dashboard_chrome_like ( self , mtime , send_email_smtp , driver_class ) : [EOL] [comment] [EOL] [comment] [EOL] element = Mock ( ) [EOL] driver = Mock ( ) [EOL] mtime . sleep . return_value = None [EOL] type ( element ) . screenshot_as_png = PropertyMock ( side_effect = WebDriverException ) [EOL] [EOL] driver_class . return_value = driver [EOL] [EOL] [comment] [EOL] driver . find_elements_by_id . side_effect = [ True , False ] [EOL] driver . find_element_by_id . return_value = element [EOL] driver . find_element_by_class_name . return_value = element [EOL] driver . screenshot . return_value = read_fixture ( [string] ) [EOL] [EOL] schedule = db . session . query ( DashboardEmailSchedule ) . filter_by ( id = self . dashboard_schedule ) . all ( ) [ [number] ] [EOL] [EOL] deliver_dashboard ( schedule ) [EOL] mtime . sleep . assert_called_once ( ) [EOL] driver . screenshot . assert_called_once ( ) [EOL] send_email_smtp . assert_called_once ( ) [EOL] [EOL] self . assertEquals ( send_email_smtp . call_args [ [number] ] [ [number] ] , self . RECIPIENTS ) [EOL] self . assertEquals ( list ( send_email_smtp . call_args [ [number] ] [ [string] ] . values ( ) ) [ [number] ] , driver . screenshot . return_value , ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) def test_deliver_email_options ( self , mtime , send_email_smtp , driver_class ) : [EOL] element = Mock ( ) [EOL] driver = Mock ( ) [EOL] mtime . sleep . return_value = None [EOL] [EOL] driver_class . return_value = driver [EOL] [EOL] [comment] [EOL] driver . find_elements_by_id . side_effect = [ True , False ] [EOL] driver . find_element_by_class_name . return_value = element [EOL] element . screenshot_as_png = read_fixture ( [string] ) [EOL] [EOL] schedule = db . session . query ( DashboardEmailSchedule ) . filter_by ( id = self . dashboard_schedule ) . all ( ) [ [number] ] [EOL] [EOL] [comment] [EOL] schedule . deliver_as_group = False [EOL] [EOL] [comment] [EOL] app . config [ [string] ] = self . BCC [EOL] [EOL] deliver_dashboard ( schedule ) [EOL] mtime . sleep . assert_called_once ( ) [EOL] driver . screenshot . assert_not_called ( ) [EOL] [EOL] self . assertEquals ( send_email_smtp . call_count , [number] ) [EOL] self . assertEquals ( send_email_smtp . call_args [ [number] ] [ [string] ] , self . BCC ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) def test_deliver_slice_inline_image ( self , mtime , send_email_smtp , driver_class ) : [EOL] element = Mock ( ) [EOL] driver = Mock ( ) [EOL] mtime . sleep . return_value = None [EOL] [EOL] driver_class . return_value = driver [EOL] [EOL] [comment] [EOL] driver . find_elements_by_id . side_effect = [ True , False ] [EOL] driver . find_element_by_class_name . return_value = element [EOL] element . screenshot_as_png = read_fixture ( [string] ) [EOL] [EOL] schedule = db . session . query ( SliceEmailSchedule ) . filter_by ( id = self . slice_schedule ) . all ( ) [ [number] ] [EOL] [EOL] schedule . email_format = SliceEmailReportFormat . visualization [EOL] schedule . delivery_format = EmailDeliveryType . inline [EOL] [EOL] deliver_slice ( schedule ) [EOL] mtime . sleep . assert_called_once ( ) [EOL] driver . screenshot . assert_not_called ( ) [EOL] send_email_smtp . assert_called_once ( ) [EOL] [EOL] self . assertEquals ( list ( send_email_smtp . call_args [ [number] ] [ [string] ] . values ( ) ) [ [number] ] , element . screenshot_as_png , ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) def test_deliver_slice_attachment ( self , mtime , send_email_smtp , driver_class ) : [EOL] element = Mock ( ) [EOL] driver = Mock ( ) [EOL] mtime . sleep . return_value = None [EOL] [EOL] driver_class . return_value = driver [EOL] [EOL] [comment] [EOL] driver . find_elements_by_id . side_effect = [ True , False ] [EOL] driver . find_element_by_class_name . return_value = element [EOL] element . screenshot_as_png = read_fixture ( [string] ) [EOL] [EOL] schedule = db . session . query ( SliceEmailSchedule ) . filter_by ( id = self . slice_schedule ) . all ( ) [ [number] ] [EOL] [EOL] schedule . email_format = SliceEmailReportFormat . visualization [EOL] schedule . delivery_type = EmailDeliveryType . attachment [EOL] [EOL] deliver_slice ( schedule ) [EOL] mtime . sleep . assert_called_once ( ) [EOL] driver . screenshot . assert_not_called ( ) [EOL] send_email_smtp . assert_called_once ( ) [EOL] [EOL] self . assertEquals ( send_email_smtp . call_args [ [number] ] [ [string] ] [ [string] ] , element . screenshot_as_png , ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) def test_deliver_slice_csv_attachment ( self , send_email_smtp , get ) : [EOL] response = Mock ( ) [EOL] get . return_value = response [EOL] response . raise_for_status . return_value = None [EOL] response . content = self . CSV [EOL] [EOL] schedule = db . session . query ( SliceEmailSchedule ) . filter_by ( id = self . slice_schedule ) . all ( ) [ [number] ] [EOL] [EOL] schedule . email_format = SliceEmailReportFormat . data [EOL] schedule . delivery_type = EmailDeliveryType . attachment [EOL] [EOL] deliver_slice ( schedule ) [EOL] send_email_smtp . assert_called_once ( ) [EOL] [EOL] file_name = __ ( [string] , name = schedule . slice . slice_name ) [EOL] [EOL] self . assertEquals ( send_email_smtp . call_args [ [number] ] [ [string] ] [ file_name ] , self . CSV , ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) def test_deliver_slice_csv_inline ( self , send_email_smtp , get ) : [EOL] response = Mock ( ) [EOL] get . return_value = response [EOL] response . raise_for_status . return_value = None [EOL] response . content = self . CSV [EOL] [EOL] schedule = db . session . query ( SliceEmailSchedule ) . filter_by ( id = self . slice_schedule ) . all ( ) [ [number] ] [EOL] [EOL] schedule . email_format = SliceEmailReportFormat . data [EOL] schedule . delivery_type = EmailDeliveryType . inline [EOL] [EOL] deliver_slice ( schedule ) [EOL] send_email_smtp . assert_called_once ( ) [EOL] [EOL] self . assertIsNone ( send_email_smtp . call_args [ [number] ] [ [string] ] ) [EOL] self . assertTrue ( [string] in send_email_smtp . call_args [ [number] ] [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tests.schedules_test.SchedulesTestCase]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] from wtforms . form import Form [EOL] [EOL] from superset . forms import ( CommaSeparatedListField , filter_not_empty_values ) [EOL] from tests . base_tests import SupersetTestCase [EOL] [EOL] [EOL] class FormTestCase ( SupersetTestCase ) : [EOL] [EOL] def test_comma_separated_list_field ( self ) : [EOL] field = CommaSeparatedListField ( ) . bind ( Form ( ) , [string] ) [EOL] field . process_formdata ( [ [string] ] ) [EOL] self . assertEqual ( field . data , [ [string] ] ) [EOL] [EOL] field . process_formdata ( [ [string] ] ) [EOL] self . assertEqual ( field . data , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_filter_not_empty_values ( self ) : [EOL] self . assertEqual ( filter_not_empty_values ( None ) , None ) [EOL] self . assertEqual ( filter_not_empty_values ( [ ] ) , None ) [EOL] self . assertEqual ( filter_not_empty_values ( [ [string] ] ) , None ) [EOL] self . assertEqual ( filter_not_empty_values ( [ [string] ] ) , [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] from unittest import TestCase [EOL] from unittest . mock import Mock , patch [EOL] [EOL] from superset . stats_logger import StatsdStatsLogger [EOL] [EOL] [EOL] class StatsdStatsLoggerTest ( TestCase ) : [EOL] [EOL] def verify_client_calls ( self , logger , client ) : [EOL] logger . incr ( [string] ) [EOL] client . incr . assert_called_once ( ) [EOL] client . incr . assert_called_with ( [string] ) [EOL] logger . decr ( [string] ) [EOL] client . decr . assert_called_once ( ) [EOL] client . decr . assert_called_with ( [string] ) [EOL] logger . gauge ( [string] ) [EOL] client . gauge . assert_called_once ( ) [EOL] client . gauge . assert_called_with ( [string] ) [EOL] logger . timing ( [string] , [number] ) [EOL] client . timing . assert_called_once ( ) [EOL] client . timing . assert_called_with ( [string] , [number] ) [EOL] [EOL] def test_init_with_statsd_client ( self ) : [EOL] client = Mock ( ) [EOL] stats_logger = StatsdStatsLogger ( statsd_client = client ) [EOL] self . verify_client_calls ( stats_logger , client ) [EOL] [EOL] def test_init_with_params ( self ) : [EOL] with patch ( [string] ) as MockStatsdClient : [EOL] mock_client = MockStatsdClient . return_value [EOL] [EOL] stats_logger = StatsdStatsLogger ( ) [EOL] self . verify_client_calls ( stats_logger , mock_client ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Set , Dict [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] [EOL] from . base_tests import SupersetTestCase [EOL] from . fixtures . datasource import datasource_post [EOL] [EOL] [EOL] class DatasourceTests ( SupersetTestCase ) : [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( DatasourceTests , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def test_external_metadata ( self ) : [EOL] self . login ( username = [string] ) [EOL] tbl = self . get_table_by_name ( [string] ) [EOL] schema = tbl . schema or [string] [EOL] url = ( f' [string] { tbl . id } [string] ' f' [string] { tbl . database . id } [string] ' f' [string] { tbl . table_name } [string] ' f' [string] { schema } [string] ' ) [EOL] resp = self . get_json_resp ( url ) [EOL] col_names = { o . get ( [string] ) for o in resp } [EOL] self . assertEquals ( col_names , { [string] , [string] , [string] , [string] , [string] , [string] , [string] } , ) [EOL] [EOL] def compare_lists ( self , l1 , l2 , key ) : [EOL] l2_lookup = { o . get ( key ) : o for o in l2 } [EOL] for obj1 in l1 : [EOL] obj2 = l2_lookup . get ( obj1 . get ( key ) ) [EOL] for k in obj1 : [EOL] if k not in [string] and obj1 . get ( k ) : [EOL] self . assertEquals ( obj1 . get ( k ) , obj2 . get ( k ) ) [EOL] [EOL] def test_save ( self ) : [EOL] self . login ( username = [string] ) [EOL] tbl_id = self . get_table_by_name ( [string] ) . id [EOL] datasource_post [ [string] ] = tbl_id [EOL] data = dict ( data = json . dumps ( datasource_post ) ) [EOL] resp = self . get_json_resp ( [string] , data ) [EOL] for k in datasource_post : [EOL] if k == [string] : [EOL] self . compare_lists ( datasource_post [ k ] , resp [ k ] , [string] ) [EOL] elif k == [string] : [EOL] self . compare_lists ( datasource_post [ k ] , resp [ k ] , [string] ) [EOL] else : [EOL] self . assertEquals ( resp [ k ] , datasource_post [ k ] ) [EOL] [EOL] def test_get_datasource ( self ) : [EOL] self . login ( username = [string] ) [EOL] tbl = self . get_table_by_name ( [string] ) [EOL] url = f' [string] { tbl . type } [string] { tbl . id } [string] ' [EOL] resp = self . get_json_resp ( url ) [EOL] self . assertEquals ( resp . get ( [string] ) , [string] ) [EOL] col_names = { o . get ( [string] ) for o in resp [ [string] ] } [EOL] self . assertEquals ( col_names , { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] } , ) [EOL] [EOL] def test_get_datasource_failed ( self ) : [EOL] self . login ( username = [string] ) [EOL] url = f' [string] ' [EOL] resp = self . get_json_resp ( url ) [EOL] self . assertEquals ( resp . get ( [string] ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Row ( object ) : [EOL] def __init__ ( self , values ) : [EOL] self . values = values [EOL] [EOL] def __name__ ( self ) : [EOL] return [string] [EOL] [EOL] def __iter__ ( self ) : [EOL] return ( item for item in self . values ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0