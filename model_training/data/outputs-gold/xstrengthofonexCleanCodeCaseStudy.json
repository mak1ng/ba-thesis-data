from typing import Any , List [EOL] import cleancoderscom [EOL] import typing [EOL] import unittest [EOL] from datetime import date [EOL] [EOL] from cleancoderscom . context import Context [EOL] from cleancoderscom . entities . codecast import Codecast [EOL] from cleancoderscom . entities . license import License [EOL] from cleancoderscom . entities . user import User [EOL] from cleancoderscom . use_cases . present_codecasts_use_case import PresentCodecastsUseCase [EOL] from tests . test_setup import TestSetup [EOL] [EOL] [EOL] class PresentCodecastsUseCaseTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] TestSetup . setup ( ) [EOL] self . user = self . create_testable_user ( [string] ) [EOL] self . codecast = self . create_testable_codecast ( [string] , date ( [number] , [number] , [number] ) ) [EOL] self . use_case = PresentCodecastsUseCase ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] TestSetup . teardown ( ) [EOL] [EOL] def test_user_without_view_license_cannot_view_codecast ( self ) : [EOL] self . assertFalse ( self . use_case . is_licensed_for ( License . VIEWING , self . user , self . codecast ) ) [EOL] [EOL] def test_user_with_view_license_can_view_codecast ( self ) : [EOL] self . create_testable_view_license ( self . user , self . codecast ) [EOL] self . assertTrue ( self . use_case . is_licensed_for ( License . VIEWING , self . user , self . codecast ) ) [EOL] [EOL] def test_user_with_license_cannot_view_other_users_codecast ( self ) : [EOL] other_user = self . create_testable_user ( [string] ) [EOL] self . create_testable_view_license ( other_user , self . codecast ) [EOL] self . assertFalse ( self . use_case . is_licensed_for ( License . VIEWING , self . user , self . codecast ) ) [EOL] [EOL] def test_present_no_codecasts ( self ) : [EOL] Context . codecast_gateway . delete ( self . codecast ) [EOL] presentable_codecasts = self . use_case . present_codecasts ( self . user ) [EOL] self . assertEqual ( [number] , len ( presentable_codecasts ) ) [EOL] [EOL] def test_present_one_codecast ( self ) : [EOL] self . create_testable_view_license ( self . user , self . codecast ) [EOL] presentable_codecasts = self . use_case . present_codecasts ( self . user ) [EOL] self . assertEqual ( [number] , len ( presentable_codecasts ) ) [EOL] presentable_codecast = presentable_codecasts [ [number] ] [EOL] self . assertEqual ( [string] , presentable_codecast . title ) [EOL] self . assertEqual ( [string] , presentable_codecast . publication_date ) [EOL] [EOL] def test_presented_codecast_is_not_viewable_without_license ( self ) : [EOL] presentable_codecasts = self . use_case . present_codecasts ( self . user ) [EOL] self . assertFalse ( presentable_codecasts [ [number] ] . is_viewable ) [EOL] [EOL] def test_presented_codecast_is_viewable_with_view_license ( self ) : [EOL] self . create_testable_view_license ( self . user , self . codecast ) [EOL] presentable_codecasts = self . use_case . present_codecasts ( self . user ) [EOL] self . assertTrue ( presentable_codecasts [ [number] ] . is_viewable ) [EOL] [EOL] def test_presented_codecast_is_downloadable_with_download_license ( self ) : [EOL] self . create_testable_download_license ( self . user , self . codecast ) [EOL] presentable_codecasts = self . use_case . present_codecasts ( self . user ) [EOL] self . assertTrue ( presentable_codecasts [ [number] ] . is_downloadable ) [EOL] [EOL] @ staticmethod def create_testable_user ( username ) : [EOL] return Context . user_gateway . save ( User ( username ) ) [EOL] [EOL] @ staticmethod def create_testable_codecast ( title , publication_date ) : [EOL] return Context . codecast_gateway . save ( Codecast ( title , publication_date ) ) [EOL] [EOL] @ staticmethod def create_testable_view_license ( user , codecast ) : [EOL] return Context . license_gateway . save ( License ( user , codecast , License . VIEWING ) ) [EOL] [EOL] @ staticmethod def create_testable_download_license ( user , codecast ) : [EOL] return Context . license_gateway . save ( License ( user , codecast , License . DOWNLOADING ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cleancoderscom.use_cases.present_codecasts_use_case.PresentCodecastsUseCase$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 $cleancoderscom.use_cases.presentable_codecast.PresentableCodecast$ 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 0 0 0 0 0 0 0 $cleancoderscom.use_cases.presentable_codecast.PresentableCodecast$ 0 0 0 0 0 0 0 0 0 0 $cleancoderscom.use_cases.presentable_codecast.PresentableCodecast$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.use_cases.presentable_codecast.PresentableCodecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Optional [EOL] import cleancoderscom [EOL] import typing [EOL] from cleancoderscom . context import Context [EOL] from cleancoderscom . gatekeeper import GateKeeper [EOL] from tests . gateways . in_memory_codecast_gateway import InMemoryCodecastGateway [EOL] from tests . gateways . in_memory_license_gateway import InMemoryLicenseGateway [EOL] from tests . gateways . in_memory_user_gateway import InMemoryUserGateway [EOL] [EOL] [EOL] class TestSetup ( Context ) : [EOL] @ staticmethod def setup ( ) : [EOL] Context . user_gateway = InMemoryUserGateway ( ) [EOL] Context . license_gateway = InMemoryLicenseGateway ( ) [EOL] Context . codecast_gateway = InMemoryCodecastGateway ( ) [EOL] Context . gatekeeper = GateKeeper ( ) [EOL] [EOL] @ staticmethod def teardown ( ) : [EOL] Context . user_gateway = None [EOL] Context . license_gateway = None [EOL] Context . codecast_gateway = None [EOL] Context . gatekeeper = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tests [EOL] import unittest [EOL] [EOL] from tests . utilities . main import Main [EOL] [EOL] [EOL] class MainTest ( unittest . TestCase ) : [EOL] def test_creation ( self ) : [EOL] main = Main ( ) [EOL] self . assertIsNotNone ( main . get_server ( ) ) [EOL] self . assertIsNotNone ( main . get_codecast_gateway ( ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.utilities.main.Main$ 0 0 0 0 0 0 0 0 0 $tests.utilities.main.Main$ 0 0 0 0 0 0 0 0 0 0 $tests.utilities.main.Main$ 0 0 0 0 0
import cleancoderscom [EOL] import unittest [EOL] [EOL] from cleancoderscom . entities . entity import Entity [EOL] [EOL] [EOL] class EntityTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . e1 = Entity ( [string] ) [EOL] self . e2 = Entity ( [string] ) [EOL] [EOL] def test_two_different_entities_are_not_the_same ( self ) : [EOL] self . e1 . id_ = [string] [EOL] self . e2 . id_ = [string] [EOL] self . assertFalse ( self . e1 == self . e2 ) [EOL] [EOL] def test_one_entity_is_same_as_itself ( self ) : [EOL] self . e1 . id_ = [string] [EOL] self . assertTrue ( self . e1 == self . e1 ) [EOL] [EOL] def test_entity_with_the_same_id_are_the_same ( self ) : [EOL] self . e1 . id_ = [string] [EOL] self . e2 . id_ = [string] [EOL] self . assertTrue ( self . e1 == self . e2 ) [EOL] [EOL] def test_entity_with_none_id_are_not_the_same ( self ) : [EOL] self . e1 . id_ = None [EOL] self . e2 . id_ = None [EOL] self . assertFalse ( self . e1 == self . e2 )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cleancoderscom.entities.entity.Entity$ 0 0 0 0 0 0 0 0 $cleancoderscom.entities.entity.Entity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from cleancoderscom . socket_service import SocketService [EOL] [EOL] [EOL] class TestSocketService ( SocketService ) : [EOL] connections = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] self . message = [string] [EOL] [EOL] def serve ( self , conn ) : [EOL] self . connections += [number] [EOL] data = conn . recv ( [number] ) [EOL] self . message += data . decode ( ) [EOL] conn . sendall ( data ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
	0
from typing import Any [EOL] import cleancoderscom [EOL] import typing [EOL] import tests [EOL] import unittest [EOL] import socket [EOL] from threading import Thread [EOL] import time [EOL] [EOL] from cleancoderscom . socket_server import SocketServer [EOL] from tests . socket_server . test_socket_service import TestSocketService [EOL] [EOL] [EOL] class TestServerContext ( object ) : [EOL] def __init__ ( self , server ) : [EOL] self . server = server [EOL] self . server_thread = None [EOL] [EOL] def __enter__ ( self ) : [EOL] self . server_thread = Thread ( target = self . server . start , kwargs = { [string] : [number] } ) [EOL] self . server_thread . start ( ) [EOL] time . sleep ( [number] ) [EOL] [EOL] def __exit__ ( self , * exc ) : [EOL] self . server_thread . join ( ) [EOL] self . server_thread = None [EOL] self . server . stop ( ) [EOL] [EOL] [EOL] class TestConnectionContext ( object ) : [EOL] def __init__ ( self , host , port ) : [EOL] self . conn = None [EOL] self . host = host [EOL] self . port = port [EOL] [EOL] def __enter__ ( self ) : [EOL] self . conn = socket . socket ( ) [EOL] self . conn . connect ( ( self . host , self . port ) ) [EOL] return self . conn [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] self . conn . close ( ) [EOL] [EOL] [EOL] class SocketServerTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . port = [number] [EOL] self . host = [string] [EOL] self . service = TestSocketService ( ) [EOL] self . server = SocketServer ( self . port , self . service ) [EOL] [EOL] def test_instantiate ( self ) : [EOL] self . assertEqual ( self . port , self . server . port ) [EOL] self . assertEqual ( self . service , self . server . service ) [EOL] [EOL] def test_can_start_and_stop_server ( self ) : [EOL] self . server . start ( timeout = [number] ) [EOL] self . assertTrue ( self . server . is_running ( ) ) [EOL] self . server . stop ( ) [EOL] self . assertFalse ( self . server . is_running ( ) ) [EOL] [EOL] def test_accepts_an_incoming_connection ( self ) : [EOL] with self . get_test_server_context ( ) : [EOL] self . start_simple_test_connection ( ) [EOL] self . assertEqual ( self . service . connections , [number] ) [EOL] [EOL] def test_accepts_multiple_incoming_connections ( self ) : [EOL] with self . get_test_server_context ( ) : [EOL] self . start_simple_test_connection ( ) [EOL] self . start_simple_test_connection ( ) [EOL] self . assertEqual ( self . service . connections , [number] ) [EOL] [EOL] def test_can_send_and_recv_data ( self ) : [EOL] with self . get_test_server_context ( ) : [EOL] with self . get_test_connection_context ( ) as conn : [EOL] conn . sendall ( [string] ) [EOL] self . assertEqual ( self . service . message , [string] ) [EOL] [EOL] def test_can_send_and_recv_multiple_messages ( self ) : [EOL] with self . get_test_server_context ( ) : [EOL] with self . get_test_connection_context ( ) as conn1 : [EOL] conn1 . sendall ( [string] ) [EOL] with self . get_test_connection_context ( ) as conn2 : [EOL] conn2 . sendall ( [string] ) [EOL] self . assertEqual ( self . service . message , [string] ) [EOL] [EOL] def test_can_echo ( self ) : [EOL] with self . get_test_server_context ( ) : [EOL] with self . get_test_connection_context ( ) as conn : [EOL] conn . sendall ( [string] ) [EOL] response = conn . recv ( [number] ) [EOL] self . assertEqual ( response , [string] ) [EOL] [EOL] def get_test_server_context ( self ) : [EOL] return TestServerContext ( self . server ) [EOL] [EOL] def get_test_connection_context ( self ) : [EOL] return TestConnectionContext ( self . host , self . port ) [EOL] [EOL] def start_simple_test_connection ( self ) : [EOL] self . conn = socket . socket ( ) [EOL] self . conn . connect ( ( self . host , self . port ) ) [EOL] self . conn . close ( ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $tests.socket_server.test_socket_service.TestSocketService$ 0 0 0 0 0 0 0 $cleancoderscom.socket_server.SocketServer$ 0 0 0 0 0 $builtins.int$ 0 0 0 $tests.socket_server.test_socket_service.TestSocketService$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import cleancoderscom [EOL] import tests [EOL] from cleancoderscom . socket_server import SocketServer [EOL] from cleancoderscom . socket_service import SocketService [EOL] from tests . gateways . in_memory_codecast_gateway import InMemoryCodecastGateway [EOL] [EOL] [EOL] class MainService ( SocketService ) : [EOL] def serve ( self , conn ) : [EOL] pass [EOL] [EOL] [EOL] class Main ( object ) : [EOL] def __init__ ( self ) : [EOL] self . server = SocketServer ( [number] , MainService ( ) ) [EOL] self . codecast_gateway = InMemoryCodecastGateway ( ) [EOL] [EOL] def get_server ( self ) : [EOL] return self . server [EOL] [EOL] def get_codecast_gateway ( self ) : [EOL] return self . codecast_gateway [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cleancoderscom.socket_server.SocketServer$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.gateways.in_memory_codecast_gateway.InMemoryCodecastGateway$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import cleancoderscom [EOL] from cleancoderscom . socket_server import SocketServer [EOL] from cleancoderscom . socket_service import SocketService [EOL] [EOL] [EOL] class HelloWorld ( SocketService ) : [EOL] def serve ( self , conn ) : [EOL] body = [string] [EOL] response = [string] [EOL] response += [string] [EOL] response += [string] . format ( len ( body ) ) [EOL] response += [string] [EOL] response += body [EOL] conn . sendall ( response . encode ( ) ) [EOL] [EOL] @ staticmethod def main ( ) : [EOL] port = [number] [EOL] socket = SocketServer ( port , HelloWorld ( ) ) [EOL] print ( [string] . format ( port ) ) [EOL] socket . start ( ) [EOL] [EOL] if __name__ == [string] : [EOL] HelloWorld . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $cleancoderscom.socket_server.SocketServer$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $cleancoderscom.socket_server.SocketServer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional [EOL] import cleancoderscom [EOL] import builtins [EOL] import typing [EOL] import threading [EOL] import threading [EOL] import uuid [EOL] from copy import deepcopy [EOL] [EOL] from typing import Type , Dict , Optional [EOL] [EOL] from cleancoderscom . entities . entity import Entity [EOL] from cleancoderscom . gateways . gateway import Gateway [EOL] [EOL] [EOL] class InMemoryGateway ( Gateway ) : [EOL] def __init__ ( self ) : [EOL] self . entities = { } [EOL] self . lock = threading . Lock ( ) [EOL] [EOL] def delete ( self , entity ) : [EOL] with self . lock : [EOL] self . entities . pop ( entity . id_ ) [EOL] [EOL] def find_all ( self ) : [EOL] return deepcopy ( list ( self . entities . values ( ) ) ) [EOL] [EOL] def find ( self , id_ ) : [EOL] return next ( filter ( lambda e : e . id_ == id_ , self . find_all ( ) ) , None ) [EOL] [EOL] def save ( self , entity ) : [EOL] with self . lock : [EOL] entity = self . establish_id ( entity ) [EOL] self . entities [ entity . id_ ] = deepcopy ( entity ) [EOL] return entity [EOL] [EOL] @ staticmethod def establish_id ( entity ) : [EOL] if entity . id_ is None : [EOL] entity . id_ = str ( uuid . uuid4 ( ) ) [EOL] return entity [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cleancoderscom.entities.entity.Entity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Optional [EOL] import typing [EOL] import cleancoderscom [EOL] import builtins [EOL] from typing import List , Optional [EOL] [EOL] from cleancoderscom . entities . codecast import Codecast [EOL] from cleancoderscom . gateways . codecast_gateway import CodecastGateway [EOL] from tests . gateways . in_memory_gateway import InMemoryGateway [EOL] [EOL] [EOL] class InMemoryCodecastGateway ( InMemoryGateway , CodecastGateway ) : [EOL] def find_codecast_by_title ( self , title ) : [EOL] return next ( filter ( lambda c : c . title == title , self . find_all ( ) ) , None ) [EOL] [EOL] def find_all_codecasts_ordered_by_date ( self ) : [EOL] return list ( sorted ( self . find_all ( ) , key = lambda c : c . publication_date ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.entities.codecast.Codecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import cleancoderscom [EOL] import builtins [EOL] from cleancoderscom . entities . user import User [EOL] from cleancoderscom . gateways . user_gateway import UserGateway [EOL] from tests . gateways . in_memory_gateway import InMemoryGateway [EOL] [EOL] [EOL] class InMemoryUserGateway ( InMemoryGateway , UserGateway ) : [EOL] def find_user ( self , username ) : [EOL] return next ( filter ( lambda u : u . username == username , self . find_all ( ) ) , None )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import cleancoderscom [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from cleancoderscom . entities . codecast import Codecast [EOL] from cleancoderscom . entities . license import License [EOL] from cleancoderscom . entities . user import User [EOL] from cleancoderscom . gateways . license_gateway import LicenseGateway [EOL] from tests . gateways . in_memory_gateway import InMemoryGateway [EOL] [EOL] [EOL] class InMemoryLicenseGateway ( InMemoryGateway , LicenseGateway ) : [EOL] def find_license_for ( self , user , codecast ) : [EOL] return next ( filter ( lambda x : x . user == user and x . codecast == codecast , self . find_all ( ) ) , None ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from abc import ABCMeta , abstractmethod [EOL] [EOL] [EOL] class SocketService ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def serve ( self , conn ) : [EOL] pass [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import cleancoderscom [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from cleancoderscom . gatekeeper import GateKeeper [EOL] from cleancoderscom . gateways . codecast_gateway import CodecastGateway [EOL] from cleancoderscom . gateways . license_gateway import LicenseGateway [EOL] from cleancoderscom . gateways . user_gateway import UserGateway [EOL] [EOL] [EOL] class Context ( object ) : [EOL] license_gateway = None [EOL] codecast_gateway = None [EOL] user_gateway = None [EOL] gatekeeper = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cleancoderscom.gateways.license_gateway.LicenseGateway]$ 0 0 0 $typing.Optional[cleancoderscom.gateways.codecast_gateway.CodecastGateway]$ 0 0 0 $typing.Optional[cleancoderscom.gateways.user_gateway.UserGateway]$ 0 0 0 $typing.Optional[cleancoderscom.gatekeeper.GateKeeper]$ 0 0 0
from typing import Type , Optional [EOL] import typing [EOL] import builtins [EOL] import cleancoderscom [EOL] import threading [EOL] import socket [EOL] import socket [EOL] from threading import Thread [EOL] from typing import Optional [EOL] [EOL] from cleancoderscom . socket_service import SocketService [EOL] [EOL] Socket = socket . socket [EOL] [EOL] [EOL] class SocketServer ( object ) : [EOL] def __init__ ( self , port , service ) : [EOL] self . port = port [EOL] self . service = service [EOL] self . running = False [EOL] self . sock = None [EOL] [EOL] def start ( self , timeout = None ) : [EOL] self . running = True [EOL] self . sock = self . create_socket ( timeout ) [EOL] while self . running : [EOL] try : [EOL] conn , addr = self . sock . accept ( ) [EOL] service_thread = Thread ( target = self . service . serve , args = ( conn , ) ) [EOL] service_thread . start ( ) [EOL] service_thread . join ( ) [EOL] conn . close ( ) [EOL] continue [EOL] except ( socket . timeout , KeyboardInterrupt ) : [EOL] break [EOL] self . sock . close ( ) [EOL] self . sock = None [EOL] [EOL] def create_socket ( self , timeout = None , queue = [number] ) : [EOL] sock = socket . socket ( socket . AF_INET , socket . SOL_SOCKET ) [EOL] sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] try : [EOL] sock . bind ( ( [string] , self . port ) ) [EOL] sock . listen ( queue ) [EOL] if timeout is not None : [EOL] sock . settimeout ( timeout ) [EOL] except OSError : [EOL] sock . close ( ) [EOL] return None [EOL] return sock [EOL] [EOL] def stop ( self ) : [EOL] self . running = False [EOL] [EOL] def is_running ( self ) : [EOL] return self . running [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Socket]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $builtins.int$ 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $socket.socket$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import cleancoderscom [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from cleancoderscom . entities . user import User [EOL] [EOL] [EOL] class GateKeeper ( object ) : [EOL] def __init__ ( self ) : [EOL] self . logged_in_user = None [EOL] [EOL] def set_logged_in_user ( self , user ) : [EOL] self . logged_in_user = user [EOL] [EOL] def get_logged_in_user ( self ) : [EOL] return self . logged_in_user [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[cleancoderscom.entities.user.User]$ 0 0 0 0 0 $None$ 0 0 0 $cleancoderscom.entities.user.User$ 0 0 0 0 0 $typing.Optional[cleancoderscom.entities.user.User]$ 0 $cleancoderscom.entities.user.User$ 0 0 0 $typing.Optional[cleancoderscom.entities.user.User]$ 0 0 0 0 0 0 0 0 0 0
	0
from datetime import datetime [EOL] [EOL] [EOL] def datetime_from_string ( string , date_format = [string] ) : [EOL] return datetime . strptime ( string , date_format ) [EOL] [EOL] [EOL] def string_from_datetime ( datetime_obj , date_format = [string] ) : [EOL] return datetime_obj . strftime ( date_format )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import cleancoderscom [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] from cleancoderscom . context import Context [EOL] from cleancoderscom . entities . codecast import Codecast [EOL] from cleancoderscom . entities . license import License , LicenseType [EOL] from cleancoderscom . entities . user import User [EOL] from cleancoderscom . use_cases . presentable_codecast import PresentableCodecast [EOL] from cleancoderscom . utilities import string_from_datetime [EOL] [EOL] [EOL] class PresentCodecastsUseCase ( object ) : [EOL] def present_codecasts ( self , logged_in_user ) : [EOL] presentable_codecasts = [ ] [EOL] codecasts = Context . codecast_gateway . find_all_codecasts_ordered_by_date ( ) [EOL] for codecast in codecasts : [EOL] presentable_codecasts . append ( self . format_codecast ( codecast , logged_in_user ) ) [EOL] return presentable_codecasts [EOL] [EOL] def format_codecast ( self , codecast , logged_in_user ) : [EOL] pcc = PresentableCodecast ( codecast . title , string_from_datetime ( codecast . publication_date ) ) [EOL] pcc . is_viewable = self . is_licensed_for ( License . VIEWING , logged_in_user , codecast ) [EOL] pcc . is_downloadable = self . is_licensed_for ( License . DOWNLOADING , logged_in_user , codecast ) [EOL] return pcc [EOL] [EOL] @ staticmethod def is_licensed_for ( license_type , user , codecast ) : [EOL] license_ = Context . license_gateway . find_license_for ( user , codecast ) [EOL] if license_ and license_ . license_type == license_type : [EOL] return True [EOL] return False [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] [EOL] import builtins [EOL] class PresentableCodecast ( object ) : [EOL] def __init__ ( self , title , publication_date ) : [EOL] self . title = title [EOL] self . publication_date = publication_date [EOL] self . is_viewable = False [EOL] self . is_downloadable = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Type [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] from datetime import datetime [EOL] [EOL] from cleancoderscom . entities . entity import Entity [EOL] [EOL] [EOL] DateTime = datetime [EOL] [EOL] [EOL] class Codecast ( Entity ) : [EOL] def __init__ ( self , title , publication_date ) : [EOL] super ( ) . __init__ ( ) [EOL] self . title = title [EOL] self . publication_date = publication_date [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from cleancoderscom . entities . entity import Entity [EOL] [EOL] [EOL] class User ( Entity ) : [EOL] def __init__ ( self , username ) : [EOL] super ( ) . __init__ ( ) [EOL] self . username = username [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0
from typing import Type [EOL] import cleancoderscom [EOL] import typing [EOL] from enum import Enum [EOL] [EOL] from cleancoderscom . entities . codecast import Codecast [EOL] from cleancoderscom . entities . entity import Entity [EOL] from cleancoderscom . entities . user import User [EOL] [EOL] [EOL] class LicenseType ( Enum ) : [EOL] DOWNLOADING = [string] [EOL] VIEWING = [string] [EOL] [EOL] [EOL] class License ( Entity ) : [EOL] DOWNLOADING = LicenseType . DOWNLOADING [EOL] VIEWING = LicenseType . VIEWING [EOL] [EOL] def __init__ ( self , user , codecast , license_type ) : [EOL] super ( ) . __init__ ( ) [EOL] self . user = user [EOL] self . codecast = codecast [EOL] self . license_type = license_type [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $cleancoderscom.entities.user.User$ 0 $cleancoderscom.entities.codecast.Codecast$ 0 $cleancoderscom.entities.license.LicenseType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $cleancoderscom.entities.user.User$ 0 $cleancoderscom.entities.user.User$ 0 0 0 $cleancoderscom.entities.codecast.Codecast$ 0 $cleancoderscom.entities.codecast.Codecast$ 0 0 0 $cleancoderscom.entities.license.LicenseType$ 0 $cleancoderscom.entities.license.LicenseType$ 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] from typing import Any [EOL] [EOL] [EOL] class Entity ( object ) : [EOL] def __init__ ( self , id_ = None ) : [EOL] self . id_ = id_ [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if self . id_ and other . id_ : [EOL] return self . id_ == other . id_ [EOL] return False [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
	0
from typing import Optional [EOL] import cleancoderscom [EOL] import typing [EOL] import builtins [EOL] from abc import ABCMeta , abstractmethod [EOL] from typing import Optional [EOL] [EOL] from cleancoderscom . entities . user import User [EOL] [EOL] [EOL] class UserGateway ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def find_user ( self , username ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cleancoderscom.entities.user.User]$ 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import List , Optional [EOL] import cleancoderscom [EOL] import typing [EOL] import builtins [EOL] from abc import ABCMeta , abstractmethod [EOL] from typing import Optional , List [EOL] [EOL] from cleancoderscom . entities . entity import Entity [EOL] [EOL] [EOL] class Gateway ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def find_all ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def delete ( self , entity ) : [EOL] pass [EOL] [EOL] @ abstractmethod def save ( self , entity ) : [EOL] pass [EOL] [EOL] @ abstractmethod def find ( self , id_ ) : [EOL] pass [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.entities.entity.Entity]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $cleancoderscom.entities.entity.Entity$ 0 0 0 0 0 0 0 0 0 $typing.Optional[cleancoderscom.entities.entity.Entity]$ 0 0 0 $cleancoderscom.entities.entity.Entity$ 0 0 0 0 0 0 0 0 0 $typing.Optional[cleancoderscom.entities.entity.Entity]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0
from typing import Optional [EOL] import cleancoderscom [EOL] import typing [EOL] from abc import ABCMeta , abstractmethod [EOL] from typing import Optional [EOL] [EOL] from cleancoderscom . entities . codecast import Codecast [EOL] from cleancoderscom . entities . license import License [EOL] from cleancoderscom . entities . user import User [EOL] [EOL] [EOL] class LicenseGateway ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def find_license_for ( self , user , codecast ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cleancoderscom.entities.license.License]$ 0 0 0 $cleancoderscom.entities.user.User$ 0 $cleancoderscom.entities.codecast.Codecast$ 0 0 0 0 0
from typing import List , Optional [EOL] import cleancoderscom [EOL] import typing [EOL] from abc import ABCMeta , abstractmethod [EOL] from typing import List , Optional [EOL] [EOL] from cleancoderscom . entities . codecast import Codecast [EOL] [EOL] [EOL] class CodecastGateway ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def find_all_codecasts_ordered_by_date ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def find_codecast_by_title ( self , title ) : [EOL] pass [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cleancoderscom.entities.codecast.Codecast]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cleancoderscom.entities.codecast.Codecast]$ 0 0 0 0 0 0 0 0 0 0
	0
import cleancoderscom [EOL] from getgauge . python import step , continue_on_failure [EOL] [EOL] from cleancoderscom . context import Context [EOL] from cleancoderscom . entities . codecast import Codecast [EOL] from cleancoderscom . utilities import datetime_from_string [EOL] [EOL] [EOL] @ continue_on_failure @ step ( [string] ) def given_codecasts ( table ) : [EOL] for row in table : [EOL] codecast = Codecast ( title = row [ [number] ] , publication_date = datetime_from_string ( row [ [number] ] ) ) [EOL] Context . codecast_gateway . save ( codecast ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , List [EOL] import cleancoderscom [EOL] import typing [EOL] from getgauge . python import step , continue_on_failure [EOL] [EOL] from cleancoderscom . context import Context [EOL] from cleancoderscom . use_cases . present_codecasts_use_case import PresentCodecastsUseCase [EOL] [EOL] boolean_mapper = { [string] : True , [string] : False } [EOL] [EOL] [EOL] @ continue_on_failure @ step ( [string] ) def query_codecasts ( table ) : [EOL] logged_in_user = Context . gatekeeper . get_logged_in_user ( ) [EOL] presentable_codecasts = PresentCodecastsUseCase ( ) . present_codecasts ( logged_in_user ) [EOL] for pcc , row in zip ( presentable_codecasts , table ) : [EOL] assert pcc . title == row [ [number] ] [EOL] assert pcc . publication_date == row [ [number] ] [EOL] assert pcc . is_viewable == boolean_mapper . get ( row [ [number] ] ) [EOL] assert pcc . is_downloadable == boolean_mapper . get ( row [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import cleancoderscom [EOL] import typing [EOL] from copy import copy [EOL] [EOL] from getgauge . python import step , after_scenario , before_scenario , continue_on_failure [EOL] [EOL] from cleancoderscom . context import Context [EOL] from cleancoderscom . entities . license import License [EOL] from cleancoderscom . entities . user import User [EOL] from cleancoderscom . use_cases . present_codecasts_use_case import PresentCodecastsUseCase [EOL] from tests . test_setup import TestSetup [EOL] [EOL] [EOL] @ before_scenario def setup ( ) : [EOL] TestSetup . setup ( ) [EOL] [EOL] [EOL] @ after_scenario def teardown ( ) : [EOL] TestSetup . teardown ( ) [EOL] [EOL] [EOL] @ continue_on_failure @ step ( [string] ) def clear_codecasts ( ) : [EOL] codecasts = Context . codecast_gateway . find_all ( ) [EOL] for codecast in copy ( codecasts ) : [EOL] Context . codecast_gateway . delete ( codecast ) [EOL] assert len ( Context . codecast_gateway . find_all ( ) ) == [number] [EOL] [EOL] [EOL] @ continue_on_failure @ step ( [string] ) def add_user ( username ) : [EOL] user = User ( username ) [EOL] Context . user_gateway . save ( user ) [EOL] assert True [EOL] [EOL] [EOL] @ step ( [string] ) def login_user ( username ) : [EOL] user = Context . user_gateway . find_user ( username ) [EOL] if user : [EOL] Context . gatekeeper . set_logged_in_user ( user ) [EOL] assert True [EOL] else : [EOL] assert False [EOL] [EOL] [EOL] @ continue_on_failure @ step ( [string] ) def presentation_user ( username ) : [EOL] user = Context . gatekeeper . get_logged_in_user ( ) [EOL] assert user . username == username [EOL] [EOL] [EOL] @ continue_on_failure @ step ( [string] ) def count_of_codecasts ( ) : [EOL] logged_in_user = Context . gatekeeper . get_logged_in_user ( ) [EOL] presentations = PresentCodecastsUseCase ( ) . present_codecasts ( logged_in_user ) [EOL] assert len ( presentations ) == [number] [EOL] [EOL] [EOL] @ continue_on_failure @ step ( [string] ) def create_license_for_viewing ( username , codecast_title ) : [EOL] user = Context . user_gateway . find_user ( username ) [EOL] codecast = Context . codecast_gateway . find_codecast_by_title ( codecast_title ) [EOL] view_license = License ( user , codecast , License . VIEWING ) [EOL] Context . license_gateway . save ( view_license ) [EOL] assert PresentCodecastsUseCase ( ) . is_licensed_for ( License . VIEWING , user , codecast ) [EOL] [EOL] [EOL] @ continue_on_failure @ step ( [string] ) def create_license_downloading ( username , codecast_title ) : [EOL] user = Context . user_gateway . find_user ( username ) [EOL] codecast = Context . codecast_gateway . find_codecast_by_title ( codecast_title ) [EOL] view_license = License ( user , codecast , License . DOWNLOADING ) [EOL] Context . license_gateway . save ( view_license ) [EOL] assert PresentCodecastsUseCase ( ) . is_licensed_for ( License . DOWNLOADING , user , codecast ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0