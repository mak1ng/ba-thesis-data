import underscore [EOL] import functools as fnt [EOL] [EOL] [EOL] def op ( f ) : [EOL] def op_ ( self , other ) : [EOL] [EOL] def f_ ( elem ) : [EOL] return f ( elem , other ) [EOL] [EOL] return f_ [EOL] [EOL] [EOL] class Underscore : [EOL] [EOL] def apply ( self , func , * args , ** kwargs ) : [EOL] [docstring] [EOL] return fnt . partial ( func , * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] [docstring] [EOL] def getattr_ ( elem ) : [EOL] return getattr ( elem , name ) [EOL] [EOL] return getattr_ [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] [docstring] [EOL] def getitem_ ( elem ) : [EOL] return elem [ key ] [EOL] [EOL] return getitem_ [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __add__ ( self , other ) : [EOL] [docstring] [EOL] def add_ ( elem ) : [EOL] return elem + other [EOL] return add_ [EOL] [EOL] def __sub__ ( self , other ) : [EOL] [docstring] [EOL] def sub_ ( elem ) : [EOL] return elem - other [EOL] return sub_ [EOL] [EOL] def __mul__ ( self , other ) : [EOL] [docstring] [EOL] [EOL] def mul_ ( elem ) : [EOL] return elem * other [EOL] [EOL] return mul_ [EOL] [EOL] def __floordiv__ ( self , other ) : [EOL] [docstring] [EOL] [EOL] def floordiv_ ( elem ) : [EOL] return elem // other [EOL] [EOL] return floordiv_ [EOL] [EOL] def __div__ ( self , other ) : [EOL] [docstring] [EOL] [EOL] def div_ ( elem ) : [EOL] return elem / other [EOL] [EOL] return div_ [EOL] [EOL] def __mod__ ( self , other ) : [EOL] [docstring] [EOL] [EOL] def div_ ( elem ) : [EOL] return elem % other [EOL] [EOL] return div_ [EOL] [EOL] def __divmod__ ( self , other ) : [EOL] return Some ( divmod ( self . _some_value , other ) ) [EOL] [EOL] def __pow__ ( self , other ) : [EOL] return Some ( self . _some_value ** other ) [EOL] [EOL] def __lshift__ ( self , other ) : [EOL] return Some ( self . _some_value << other ) [EOL] [EOL] def __rshift__ ( self , other ) : [EOL] return Some ( self . _some_value >> other ) [EOL] [EOL] def __and__ ( self , other ) : [EOL] return Some ( self . _some_value & other ) [EOL] [EOL] def __or__ ( self , other ) : [EOL] return Some ( self . _some_value | other ) [EOL] [EOL] def __xor__ ( self , other ) : [EOL] return Some ( self . _some_value ^ other ) [EOL] [EOL] def __radd__ ( self , other ) : [EOL] return Some ( other + self . _some_value ) [EOL] [EOL] def __rsub__ ( self , other ) : [EOL] return Some ( other - self . _some_value ) [EOL] [EOL] def __rmul__ ( self , other ) : [EOL] return Some ( other * self . _some_value ) [EOL] [EOL] def __rfloordiv__ ( self , other ) : [EOL] return Some ( other // self . _some_value ) [EOL] [EOL] def __rdiv__ ( self , other ) : [EOL] return Some ( other / self . _some_value ) [EOL] [EOL] def __rmod__ ( self , other ) : [EOL] return Some ( other % self . _some_value ) [EOL] [EOL] def __rdivmod__ ( self , other ) : [EOL] return Some ( divmod ( other , self . _some_value ) ) [EOL] [EOL] def __rpow__ ( self , other ) : [EOL] return Some ( other ** self . _some_value ) [EOL] [EOL] def __rlshift__ ( self , other ) : [EOL] return Some ( other << self . _some_value ) [EOL] [EOL] def __rrshift__ ( self , other ) : [EOL] return Some ( other >> self . _some_value ) [EOL] [EOL] def __rand__ ( self , other ) : [EOL] return Some ( other & self . _some_value ) [EOL] [EOL] def __ror__ ( self , other ) : [EOL] return Some ( other | self . _some_value ) [EOL] [EOL] def __rxor__ ( self , other ) : [EOL] return Some ( other ^ self . _some_value ) [EOL] [EOL] def __iadd__ ( self , other ) : [EOL] self . _some_value += other [EOL] return self [EOL] [EOL] def __isub__ ( self , other ) : [EOL] self . _some_value -= other [EOL] return self [EOL] [EOL] def __imul__ ( self , other ) : [EOL] self . _some_value *= other [EOL] return self [EOL] [EOL] def __ifloordiv__ ( self , other ) : [EOL] self . _some_value //= other [EOL] return self [EOL] [EOL] def __idiv__ ( self , other ) : [EOL] self . _some_value /= other [EOL] return self [EOL] [EOL] def __imod__ ( self , other ) : [EOL] self . _some_value %= other [EOL] return self [EOL] [EOL] def __ipow__ ( self , other ) : [EOL] self . _some_value **= other [EOL] return self [EOL] [EOL] def __ilshift__ ( self , other ) : [EOL] self . _some_value <<= other [EOL] return self [EOL] [EOL] def __irshift__ ( self , other ) : [EOL] self . _some_value >>= other [EOL] return self [EOL] [EOL] def __iand__ ( self , other ) : [EOL] self . _some_value &= other [EOL] return self [EOL] [EOL] def __ior__ ( self , other ) : [EOL] self . _some_value |= other [EOL] return self [EOL] [EOL] def __ixor__ ( self , other ) : [EOL] self . _some_value ^= other [EOL] return self [EOL] [EOL] [EOL] _ = Underscore ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $underscore.Underscore$ 0 0 0 0 0
from carriage import Row , X [EOL] [EOL] [EOL] def test_basic ( ) : [EOL] assert X . y ( Row ( x = [number] , y = [number] ) ) == [number] [EOL] assert X [ [string] ] ( dict ( x = [number] , y = [number] ) ) == [number] [EOL] assert ( X + [number] ) ( [number] ) == [number] [EOL] assert ( X - [number] ) ( [number] ) == [number] [EOL] assert ( X * [number] ) ( [number] ) == [number] [EOL] assert ( X / [number] ) ( [number] ) == [number] [EOL] assert ( X // [number] ) ( [number] ) == [number] [EOL] assert ( X % [number] ) ( [number] ) == [number] [EOL] assert ( divmod ( X , [number] ) ) ( [number] ) == ( [number] , [number] ) [EOL] assert ( X ** [number] ) ( [number] ) == [number] [EOL] [EOL] assert ( X == [number] ) ( [number] ) == True [EOL] assert ( [number] == X ) ( [number] ) == False [EOL] assert ( X == [number] ) ( [number] ) == False [EOL] assert ( [number] == X ) ( [number] ) == True [EOL] assert ( X != [number] ) ( [number] ) == True [EOL] assert ( [number] != X ) ( [number] ) == False [EOL] assert ( X > [number] ) ( [number] ) == True [EOL] assert ( X > [number] ) ( [number] ) == False [EOL] assert ( [number] > X ) ( [number] ) == False [EOL] assert ( [number] > X ) ( [number] ) == True [EOL] assert ( X < [number] ) ( [number] ) == False [EOL] assert ( X < [number] ) ( [number] ) == True [EOL] assert ( X >= [number] ) ( [number] ) == True [EOL] assert ( X >= [number] ) ( [number] ) == False [EOL] assert ( X <= [number] ) ( [number] ) == True [EOL] assert ( X <= [number] ) ( [number] ) == True [EOL] [EOL] [EOL] def test_reflected ( ) : [EOL] [comment] [EOL] [comment] [EOL] assert ( [number] + X ) ( [number] ) == [number] [EOL] assert ( [number] - X ) ( [number] ) == - [number] [EOL] assert ( [number] * X ) ( [number] ) == [number] [EOL] assert ( [number] / X ) ( [number] ) == [number] [EOL] assert ( [number] // X ) ( [number] ) == [number] [EOL] assert ( [number] % X ) ( [number] ) == [number] [EOL] assert ( divmod ( [number] , X ) ) ( [number] ) == ( [number] , [number] ) [EOL] assert ( [number] ** X ) ( [number] ) == [number] [EOL] [EOL] [EOL] def test_multiple_X ( ) : [EOL] assert ( X . y + X . x ) ( Row ( x = [number] , y = [number] ) ) == [number] [EOL] assert ( X [ [string] ] + X [ [string] ] ) ( dict ( x = [number] , y = [number] ) ) == [number] [EOL] assert ( X + X ) ( [number] ) == [number] [EOL] assert ( X - X ) ( [number] ) == [number] [EOL] assert ( X * X ) ( [number] ) == [number] [EOL] assert ( X / X ) ( [number] ) == [number] [EOL] assert ( X . y / X . x ) ( Row ( x = [number] , y = [number] ) ) == [number] [EOL] assert ( X . y // X . x ) ( Row ( x = [number] , y = [number] ) ) == [number] [EOL] assert ( X . y % X . x ) ( Row ( x = [number] , y = [number] ) ) == [number] [EOL] assert ( divmod ( X . y , X . x ) ) ( Row ( x = [number] , y = [number] ) ) == ( [number] , [number] ) [EOL] assert ( X ** X ) ( [number] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import tests [EOL] import carriage [EOL] import functools as fnt [EOL] import itertools as itt [EOL] import operator as op [EOL] from collections import Counter [EOL] [EOL] import pandas as pd [EOL] import pytest [EOL] [EOL] from carriage import Array , Nothing , Some , Stream [EOL] from carriage . row import CurrNext , CurrPrev , Row , ValueIndex [EOL] from carriage . stream import Pipeline , Transformer [EOL] [EOL] [EOL] class Person : [EOL] def __init__ ( self , name , age , father = None , mother = None ) : [EOL] self . name = name [EOL] self . age = age [EOL] self . father = father [EOL] self . mother = mother [EOL] [EOL] def get_father ( self ) : [EOL] return self . father [EOL] [EOL] def get_mother ( self ) : [EOL] return self . mother [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . name !r} [string] { self . father !r} [string] { self . mother !r} [string] ' [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . name , self . father , self . mother ) == ( other . name , other . father , other . mother ) [EOL] [EOL] [EOL] def test_init ( ) : [EOL] assert Stream ( [ [number] , [number] , [number] ] ) . to_list ( ) == [ [number] , [number] , [number] ] [EOL] assert Stream ( range ( [number] ) ) . to_list ( ) == list ( range ( [number] ) ) [EOL] assert Stream . range ( [number] ) . to_list ( ) == list ( range ( [number] ) ) [EOL] [EOL] [EOL] def test_access ( ) : [EOL] assert Stream . range ( [number] , [number] ) . get ( [number] ) == [number] [EOL] assert Stream . range ( [number] , [number] ) . get ( [number] , [number] ) == [number] [EOL] assert Stream . range ( [number] , [number] ) . get ( [number] , [number] ) == [number] [EOL] assert Stream . range ( [number] , [number] ) . get ( [number] ) is None [EOL] with pytest . raises ( ValueError ) : [EOL] assert Stream . range ( [number] , [number] ) . get ( - [number] ) is None [EOL] assert Stream . range ( [number] , [number] ) [ [number] ] == [number] [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] assert Stream ( iter ( range ( [number] , [number] ) ) ) [ - [number] ] [EOL] with pytest . raises ( IndexError ) : [EOL] assert Stream . range ( [number] , [number] ) [ [number] ] [EOL] [EOL] assert Stream . range ( [number] , [number] ) . get_opt ( [number] ) == Some ( [number] ) [EOL] assert Stream . range ( [number] , [number] ) . get_opt ( [number] ) is Nothing [EOL] with pytest . raises ( ValueError ) : [EOL] assert Stream ( iter ( range ( [number] , [number] ) ) ) . get_opt ( - [number] ) is Nothing [EOL] [EOL] assert Stream . range ( [number] , [number] ) . first ( ) == [number] [EOL] assert Stream . range ( [number] , [number] ) . first_opt ( ) == Some ( [number] ) [EOL] assert Stream ( [ [number] ] ) . first_opt ( ) == Some ( [number] ) [EOL] assert Stream ( [ ] ) . first_opt ( ) is Nothing [EOL] assert Stream ( iter ( [ ] ) ) . first_opt ( ) is Nothing [EOL] [EOL] [EOL] def test_slice ( ) : [EOL] assert Stream . range ( [number] , [number] ) . take ( [number] ) . to_list ( ) == [ [number] , [number] , [number] ] [EOL] assert Stream . range ( [number] , [number] ) . drop ( [number] ) . to_list ( ) == [ [number] , [number] ] [EOL] [EOL] def less_than_3 ( n ) : [EOL] return n < [number] [EOL] [EOL] assert Stream . range ( [number] , [number] ) . takewhile ( less_than_3 ) . to_list ( ) == [ [number] , [number] , [number] ] [EOL] [EOL] assert Stream . range ( [number] , [number] ) . dropwhile ( less_than_3 ) . to_list ( ) == [ [number] , [number] ] [EOL] [EOL] [EOL] def test_split ( ) : [EOL] def divisible_by_three ( n ) : [EOL] return n % [number] == [number] [EOL] assert Stream . range ( [number] ) . split_before ( divisible_by_three ) . to_list ( ) == [ Array ( [ [number] , [number] , [number] ] ) , Array ( [ [number] , [number] , [number] ] ) , Array ( [ [number] , [number] , [number] ] ) , Array ( [ [number] ] ) ] [EOL] assert Stream . range ( [number] ) . split_after ( divisible_by_three ) . to_list ( ) == [ Array ( [ [number] ] ) , Array ( [ [number] , [number] , [number] ] ) , Array ( [ [number] , [number] , [number] ] ) , Array ( [ [number] , [number] , [number] ] ) ] [EOL] [EOL] [EOL] def test_pluck ( ) : [EOL] assert Stream ( [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] ) . pluck ( [string] ) . to_list ( ) == [ [number] , [number] ] [EOL] assert Stream ( [ { [string] : [number] , [string] : [number] } , { [string] : [number] } , { [string] : [number] , [string] : [number] } ] ) . pluck_opt ( [string] ) . to_list ( ) == [ Some ( [number] ) , Nothing , Some ( [number] ) ] [EOL] [EOL] people = [ Person ( [string] , [number] ) , Person ( [string] , [number] ) ] [EOL] assert Stream ( people ) . pluck_attr ( [string] ) . to_list ( ) == [ [string] , [string] ] [EOL] [EOL] [EOL] def test_filtering ( ) : [EOL] def is_even ( n ) : [EOL] return n % [number] == [number] [EOL] assert Stream . range ( [number] , [number] ) . filter ( is_even ) . to_list ( ) == [ [number] , [number] ] [EOL] assert Stream . range ( [number] , [number] ) . filter_false ( is_even ) . to_list ( ) == [ [number] , [number] , [number] ] [EOL] [EOL] assert Stream . range ( [number] , [number] ) . without ( [number] , [number] ) . to_list ( ) == [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_interpose ( ) : [EOL] assert Stream . range ( [number] , [number] ) . interpose ( [number] ) . to_list ( ) == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] assert Stream ( [ ] ) . interpose ( [number] ) . to_list ( ) == [ ] [EOL] [EOL] [EOL] def test_map ( ) : [EOL] [EOL] def multiply_2 ( n ) : [EOL] return n * [number] [EOL] [EOL] assert Stream . range ( [number] ) . map ( multiply_2 ) . to_list ( ) == list ( range ( [number] , [number] , [number] ) ) [EOL] [EOL] def duplicate ( v ) : [EOL] return [ v ] * [number] [EOL] [EOL] assert Stream . range ( [number] ) . flat_map ( duplicate ) . to_list ( ) == [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] assert Stream ( [ ( [number] , [number] ) , ( [number] , [number] ) ] ) . flatten ( ) . to_list ( ) == [ [number] , [number] , [number] , [number] ] [EOL] assert Stream . range ( [number] ) . len ( ) == [number] [EOL] assert Stream ( [ ( [number] , [number] ) , ( [number] , [number] ) ] ) . flatten ( ) . len ( ) == [number] [EOL] [EOL] [EOL] def test_zip ( ) : [EOL] assert Stream . range ( [number] , [number] ) . zip ( itt . count ( [number] ) ) . to_list ( ) == [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] assert Stream . range ( [number] , [number] ) . zip ( itt . count ( [number] ) ) . to_list ( ) == [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] [EOL] assert Stream . range ( [number] , [number] ) . zip_longest ( range ( [number] , [number] ) ) . to_list ( ) == [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( None , [number] ) ] [EOL] [EOL] assert ( Stream . range ( [number] , [number] ) . zip_longest ( range ( [number] , [number] ) , fillvalue = [number] ) . to_list ( ) == [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] [EOL] assert Stream . range ( [number] , [number] ) . zip_prev ( ) . to_list ( ) == [ CurrPrev ( [number] , None ) , CurrPrev ( [number] , [number] ) , CurrPrev ( [number] , [number] ) ] [EOL] [EOL] assert Stream . range ( [number] , [number] ) . zip_next ( ) . to_list ( ) == [ CurrNext ( [number] , [number] ) , CurrNext ( [number] , [number] ) , CurrNext ( [number] , None ) ] [EOL] [EOL] assert Stream . range ( [number] , [number] ) . zip_prev ( [number] ) . to_list ( ) == [ CurrPrev ( [number] , [number] ) , CurrPrev ( [number] , [number] ) , CurrPrev ( [number] , [number] ) ] [EOL] [EOL] assert Stream . range ( [number] , [number] ) . zip_next ( [number] ) . to_list ( ) == [ CurrNext ( [number] , [number] ) , CurrNext ( [number] , [number] ) , CurrNext ( [number] , [number] ) ] [EOL] [EOL] assert Stream . range ( [number] , [number] ) . zip_index ( ) . to_list ( ) == [ ValueIndex ( [number] , [number] ) , ValueIndex ( [number] , [number] ) , ValueIndex ( [number] , [number] ) ] [EOL] [EOL] [EOL] def test_ordering ( ) : [EOL] assert Stream . range ( [number] , [number] ) . reversed ( ) . to_list ( ) == [ [number] , [number] , [number] ] [EOL] assert Stream ( [ [number] , [number] , [number] , [number] ] ) . sorted ( ) . to_list ( ) == [ [number] , [number] , [number] , [number] ] [EOL] assert Stream ( [ [number] , [number] , [number] , [number] ] ) . sorted ( lambda x : - x ) . to_list ( ) == [ [number] , [number] , [number] , [number] ] [EOL] assert Stream ( [ [number] , [number] , [number] , [number] ] ) . sorted ( lambda x : x % [number] ) . to_list ( ) == [ [number] , [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_reduce ( ) : [EOL] assert Stream . range ( [number] , [number] ) . reduce ( lambda a , b : a + b ) == [number] [EOL] assert Stream . range ( [number] , [number] ) . fold_left ( lambda a , b : a + b , [number] ) == [number] [EOL] assert Stream . range ( [number] , [number] ) . mean ( ) == [number] [EOL] assert Stream . range ( [number] , [number] ) . sum ( ) == [number] [EOL] assert Stream . range ( [number] , [number] ) . accumulate ( ) . to_list ( ) == [ [number] , [number] , [number] ] [EOL] assert Stream . range ( [number] , [number] ) . accumulate ( op . mul ) . to_list ( ) == [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_extend ( ) : [EOL] assert Stream . range ( [number] , [number] ) . extended ( [ [number] , [number] ] ) . to_list ( ) == [ [number] , [number] , [number] , [number] , [number] ] [EOL] assert Stream . range ( [number] , [number] ) . appended ( [number] ) . to_list ( ) == [ [number] , [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_distincted ( ) : [EOL] assert Stream ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) . distincted ( ) . to_list ( ) == [ [number] , [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_to ( ) : [EOL] assert Stream . range ( [number] , [number] ) . to_array ( ) == Array ( [ [number] , [number] , [number] ] ) [EOL] assert Stream ( [ ( [number] , [number] ) , ( [number] , [number] ) ] ) . to_dict ( ) == { [number] : [number] , [number] : [number] } [EOL] assert Stream . range ( [number] , [number] ) . to_set ( ) == set ( [ [number] , [number] , [number] ] ) [EOL] [EOL] assert list ( Stream . range ( [number] , [number] ) ) == [ [number] , [number] , [number] ] [EOL] assert Stream . range ( [number] , [number] ) . to_series ( ) . equals ( pd . Series ( [ [number] , [number] , [number] ] ) ) [EOL] [EOL] [EOL] def test_sliding_window ( ) : [EOL] assert Stream . range ( [number] , [number] ) . sliding_window ( [number] ) . to_list ( ) == [ ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ] [EOL] [EOL] [EOL] def test_counter ( ) : [EOL] assert Stream ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) . value_counts ( ) == Counter ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_groupby ( ) : [EOL] assert ( Stream . range ( [number] ) . group_by_as_stream ( lambda n : n // [number] ) . starmap ( lambda k , vs : ( k , list ( vs ) ) ) . to_list ( ) == [ ( [number] , [ [number] , [number] , [number] ] ) , ( [number] , [ [number] , [number] , [number] ] ) , ( [number] , [ [number] , [number] , [number] ] ) , ( [number] , [ [number] ] ) ] ) [EOL] [EOL] assert Stream . range ( [number] ) . group_by_as_map ( lambda n : n // [number] ) == { [number] : Array ( [ [number] , [number] , [number] ] ) , [number] : Array ( [ [number] , [number] , [number] ] ) , [number] : Array ( [ [number] , [number] , [number] ] ) , [number] : Array ( [ [number] ] ) } [EOL] [EOL] [EOL] @ pytest . fixture def ipsum ( ) : [EOL] return [string] [EOL] [EOL] [EOL] def test_general_case ( ipsum , capsys ) : [EOL] out = ( Stream ( ipsum . splitlines ( ) ) . flat_map ( lambda line : line . split ( [string] ) ) . map ( lambda word : word . strip ( [string] ) ) . filter ( lambda word : len ( word ) > [number] ) . distincted ( ) . sorted ( key = lambda word : len ( word ) ) . group_by_as_stream ( lambda word : len ( word ) ) . map ( lambda keyvalues : keyvalues . transform ( values = lambda stream : stream . to_array ( ) ) ) . map ( lambda keyvalues : Row ( length = keyvalues . key , count = keyvalues . values . len ( ) ) ) . tap ( tag = [string] , n = [number] ) . nlargest ( [number] , key = lambda row : row . count ) . pluck_attr ( [string] ) . to_list ( ) ) [EOL] assert out == [ [number] , [number] , [number] ] [EOL] captured = capsys . readouterr ( ) [EOL] assert captured . out == [string] [EOL] assert captured . err == [string] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_pipeline ( ) : [EOL] add_2 = Transformer ( [string] , lambda x : x + [number] ) [EOL] mul_3 = Transformer ( [string] , lambda x : x * [number] ) [EOL] pipeline = Pipeline ( ) . then ( add_2 ) . then ( mul_3 ) [EOL] assert pipeline . transform ( [number] ) == [number] [EOL] [EOL] [EOL] def test_pipeline_iterable ( ) : [EOL] map_add_2 = Transformer ( [string] , lambda xs : map ( lambda x : x + [number] , xs ) ) [EOL] map_mul_3 = Transformer ( [string] , lambda xs : map ( lambda x : x * [number] , xs ) ) [EOL] pipeline = Pipeline ( ) . then ( map_add_2 ) . then ( map_mul_3 ) [EOL] assert list ( pipeline . transform ( range ( [number] ) ) ) == [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_tuple_as_row ( ) : [EOL] strm = Stream ( [ ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] rows = strm . tuple_as_row ( [ [string] , [string] ] ) . to_list ( ) [EOL] assert rows == [ Row ( x = [number] , y = [number] ) , Row ( x = [number] , y = [number] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import carriage [EOL] import attr [EOL] import pytest [EOL] [EOL] from carriage import Array , Nothing , Some , Stream [EOL] from carriage . row import CurrNext , CurrPrev , ValueIndex [EOL] [EOL] [EOL] def test_init ( ) : [EOL] alist = Array ( [ [number] , [number] , [number] ] ) [EOL] assert alist == Array . range ( [number] , [number] ) [EOL] alist = Array ( ( [number] , [number] , [number] ) ) [EOL] assert alist == Array . range ( [number] , [number] ) [EOL] [EOL] [EOL] def test_access ( ) : [EOL] alist = Array . range ( [number] , [number] ) [EOL] assert alist [ [number] ] == [number] [EOL] assert alist [ - [number] ] == [number] [EOL] assert alist [ - [number] ] == [number] [EOL] with pytest . raises ( IndexError ) : [EOL] alist [ [number] ] [EOL] with pytest . raises ( IndexError ) : [EOL] alist [ - [number] ] [EOL] [EOL] assert alist . get ( [number] ) == [number] [EOL] assert alist . get ( [number] ) is None [EOL] assert alist . get ( [number] , [number] ) == [number] [EOL] assert alist . get ( [number] , [number] ) == [number] [EOL] assert alist . get_opt ( [number] ) == Some ( [number] ) [EOL] assert alist . get_opt ( - [number] ) == Some ( [number] ) [EOL] assert alist . get_opt ( - [number] ) == Some ( [number] ) [EOL] assert alist . get_opt ( - [number] ) is Nothing [EOL] assert alist . get_opt ( [number] ) is Nothing [EOL] [EOL] assert alist . first ( ) == [number] [EOL] assert alist . second ( ) == [number] [EOL] assert alist . last ( ) == [number] [EOL] assert alist . first_opt ( ) == Some ( [number] ) [EOL] assert alist . last_opt ( ) == Some ( [number] ) [EOL] [EOL] emptylist = Array ( ) [EOL] assert emptylist . first_opt ( ) is Nothing [EOL] assert emptylist . last_opt ( ) is Nothing [EOL] [EOL] [EOL] def test_slice ( ) : [EOL] alist = Array . range ( [number] , [number] ) [EOL] assert alist [ : [number] ] == Array . range ( [number] , [number] ) [EOL] assert alist [ - [number] : ] == Array . range ( [number] , [number] ) [EOL] assert alist . take ( [number] ) == Array . range ( [number] , [number] ) [EOL] assert alist . drop ( [number] ) == Array . range ( [number] , [number] ) [EOL] assert alist . drop ( [number] ) == Array ( ) [EOL] assert alist . drop ( [number] ) == Array ( ) [EOL] assert alist . takeright ( [number] ) == Array . range ( [number] , [number] ) [EOL] assert alist . dropright ( [number] ) == Array . range ( [number] , [number] ) [EOL] assert alist . tail ( ) == Array . range ( [number] , [number] ) [EOL] assert alist . butlast ( ) == Array . range ( [number] , [number] ) [EOL] assert alist . slice ( [number] , [number] ) == Array . range ( [number] , [number] ) [EOL] assert alist [ [number] : [number] ] == Array . range ( [number] , [number] ) [EOL] [EOL] def less_than_15 ( n ) : [EOL] return n < [number] [EOL] [EOL] assert alist . takewhile ( less_than_15 ) == Array . range ( [number] , [number] ) [EOL] assert alist . dropwhile ( less_than_15 ) == Array . range ( [number] , [number] ) [EOL] [EOL] [EOL] def test_zip ( ) : [EOL] zip_index_list = Array . range ( [number] , [number] ) . zip_index ( ) [EOL] assert ( zip_index_list == Array ( [ ValueIndex ( [number] , [number] ) , ValueIndex ( [number] , [number] ) , ValueIndex ( [number] , [number] ) ] ) ) [EOL] [EOL] assert ( zip_index_list == Array . range ( [number] , [number] ) . zip ( [ [number] , [number] , [number] ] ) . starmap ( lambda a , b : ValueIndex ( a , b ) ) ) [EOL] [EOL] assert ( Array . range ( [number] , [number] ) . zip_longest ( [ [number] , [number] ] ) == Array ( [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , None ) ] ) ) [EOL] [EOL] assert ( Array . range ( [number] , [number] ) . zip_longest_opt ( [ [number] , [number] ] ) == Array ( [ ( Some ( [number] ) , Some ( [number] ) ) , ( Some ( [number] ) , Some ( [number] ) ) , ( Some ( [number] ) , Nothing ) ] ) ) [EOL] [EOL] assert ( Array . range ( [number] , [number] ) . zip_prev ( ) == Array ( [ CurrPrev ( [number] , None ) , CurrPrev ( [number] , [number] ) , CurrPrev ( [number] , [number] ) ] ) ) [EOL] assert ( Array . range ( [number] , [number] ) . zip_next ( ) == Array ( [ CurrNext ( [number] , [number] ) , CurrNext ( [number] , [number] ) , CurrNext ( [number] , None ) ] ) ) [EOL] [EOL] [EOL] def test_basic_transform ( ) : [EOL] alist = Array ( [ [number] , [number] , [number] ] ) [EOL] [EOL] def multiply_2 ( n ) : [EOL] return n * [number] [EOL] [EOL] assert alist . map ( multiply_2 ) == Array ( [ [number] , [number] , [number] ] ) [EOL] [EOL] def duplicate ( v ) : [EOL] return [ v ] * [number] [EOL] [EOL] assert alist . flat_map ( duplicate ) == Array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] assert alist . map ( duplicate ) == Array ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] assert alist . map ( duplicate ) . flatten ( ) == Array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] alist = Array . range ( [number] , [number] ) . zip ( Array . range ( [number] , [number] ) ) [EOL] assert alist . starmap ( lambda a , b : a - b ) == Array ( [ [number] ] * [number] ) [EOL] [EOL] alist = Array . range ( [number] ) [EOL] [EOL] def is_even ( n ) : [EOL] return n % [number] == [number] [EOL] [EOL] assert alist . filter ( is_even ) == Array ( [ [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_reorder ( ) : [EOL] alist = Array . range ( [number] ) [EOL] assert alist . reverse ( ) is alist [EOL] assert alist == Array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] alist = Array . range ( [number] ) [EOL] assert alist . reversed ( ) is not alist [EOL] assert alist . reversed ( ) == Array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] alist = Array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] assert alist . sort ( key = lambda n : - n ) is alist [EOL] assert alist == Array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] alist = Array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] assert alist . sorted ( key = lambda n : - n ) is not alist [EOL] assert alist . sorted ( key = lambda n : - n ) == Array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_extend ( ) : [EOL] alist = Array . range ( [number] ) [EOL] assert alist . extend ( [ [number] , [number] ] ) is alist [EOL] assert alist == Array ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] alist = Array . range ( [number] ) [EOL] assert alist . extended ( [ [number] , [number] ] ) is not alist [EOL] assert alist . extended ( [ [number] , [number] ] ) == Array ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_append ( ) : [EOL] alist = Array . range ( [number] ) [EOL] assert alist . append ( [number] ) is alist [EOL] assert alist == Array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] alist = Array . range ( [number] ) [EOL] assert alist . appended ( [number] ) is not alist [EOL] assert alist . appended ( [number] ) == Array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_distincted ( ) : [EOL] alist = Array ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] assert alist . distincted ( ) == Array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_combinatoric ( ) : [EOL] alist = Array . range ( [number] ) [EOL] assert alist . product ( repeat = [number] ) == Array ( [ ( [number] , ) , ( [number] , ) , ( [number] , ) ] ) [EOL] assert alist . product ( repeat = [number] ) == Array ( [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] ) [EOL] assert alist . product ( [ [number] , [number] , [number] ] ) == Array ( [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] ) [EOL] [EOL] [EOL] def test_to ( ) : [EOL] stm = Array . range ( [number] , [number] ) . to_stream ( ) [EOL] assert type ( stm ) is Stream [EOL] assert stm . to_list ( ) == [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , Any , List [EOL] import typing [EOL] import tests [EOL] import carriage [EOL] import pytest [EOL] from carriage import Nothing , NothingAttrError , Optional , Some [EOL] [EOL] [EOL] def test_from_value_init ( ) : [EOL] nothing = Optional . from_value ( None ) [EOL] assert nothing is Nothing [EOL] with pytest . raises ( NothingAttrError ) : [EOL] Nothing . value [EOL] [EOL] some = Optional . from_value ( [number] ) [EOL] assert type ( some ) is Some [EOL] assert some . value == [number] [EOL] [EOL] some = Optional . from_value ( [string] ) [EOL] assert type ( some ) is Some [EOL] assert some . value == [string] [EOL] [EOL] adict = { [string] : [number] , [string] : [number] } [EOL] some = Optional . from_value ( adict ) [EOL] assert type ( some ) is Some [EOL] assert some . value == { [string] : [number] , [string] : [number] } [EOL] assert some . value is adict [EOL] [EOL] [EOL] def test_call_exceptable ( ) : [EOL] def raise_exception ( ) : [EOL] raise Exception [EOL] assert Optional . from_call ( raise_exception ) is Nothing [EOL] [EOL] def raise_typeerror ( ) : [EOL] raise TypeError [EOL] assert Optional . from_call ( raise_typeerror , TypeError ) is Nothing [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] Optional . from_call ( raise_typeerror , errors = ValueError ) [EOL] [EOL] def identity ( x ) : [EOL] return x [EOL] [EOL] assert Optional . from_call ( identity , [number] ) . value == [number] [EOL] [EOL] def raise_error ( error ) : [EOL] raise error [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] Optional . from_call ( raise_error , TypeError , errors = ValueError ) [EOL] [EOL] assert Optional . from_call ( raise_error , AttributeError , errors = AttributeError ) is Nothing [EOL] [EOL] [EOL] def test_some_value ( ) : [EOL] assert Some ( [number] ) . value == [number] [EOL] assert Some ( None ) . value is None [EOL] assert Some ( None ) . value is None [EOL] assert Some ( [ [number] , [number] , [number] ] ) . value == [ [number] , [number] , [number] ] [EOL] alist = [ [number] , [number] , [number] ] [EOL] assert Some ( alist ) . value is alist [EOL] assert Some ( { [string] : [number] , [string] : [number] } ) . value == { [string] : [number] , [string] : [number] } [EOL] adict = { [string] : [number] , [string] : [number] } [EOL] assert Some ( adict ) . value is adict [EOL] [EOL] [EOL] def test_get_or ( ) : [EOL] assert Some ( [number] ) . get_or ( None ) == [number] [EOL] assert Some ( None ) . get_or ( None ) is None [EOL] assert Some ( None ) . get_or ( True ) is None [EOL] assert Some ( [ [number] , [number] , [number] ] ) . get_or ( True ) == [ [number] , [number] , [number] ] [EOL] [EOL] assert Nothing . get_or ( [number] ) == [number] [EOL] assert Nothing . get_or ( None ) is None [EOL] assert Nothing . get_or ( False ) is False [EOL] assert Nothing . get_or ( True ) is True [EOL] assert Nothing . get_or ( [string] ) == [string] [EOL] [EOL] [EOL] def test_map ( ) : [EOL] def multiply_2 ( n ) : [EOL] return n * [number] [EOL] res = Some ( [number] ) . map ( multiply_2 ) [EOL] assert res . value == [number] [EOL] [EOL] res = Some ( [number] ) . fmap ( multiply_2 ) [EOL] assert res . value == [number] [EOL] [EOL] res = Nothing . map ( multiply_2 ) [EOL] assert res is Nothing [EOL] [EOL] res = Nothing . fmap ( multiply_2 ) [EOL] assert res is Nothing [EOL] [EOL] def append_1_no_return ( alist ) : [EOL] alist . append ( [number] ) [EOL] [EOL] res = Some ( [ [number] , [number] , [number] ] ) . map ( append_1_no_return ) [EOL] assert res . value is None [EOL] [EOL] def append_1_return ( alist ) : [EOL] alist . append ( [number] ) [EOL] return alist [EOL] [EOL] res = Some ( [ [number] , [number] , [number] ] ) . map ( append_1_return ) [EOL] assert res . value == [ [number] , [number] , [number] , [number] ] [EOL] [EOL] alist = [ [number] , [number] , [number] ] [EOL] res = Some ( alist ) . map ( append_1_return ) [EOL] assert res . value is alist [EOL] [EOL] [EOL] def test_flat_map ( ) : [EOL] def get_foo_option ( adict ) : [EOL] key = [string] [EOL] if key in adict : [EOL] return Some ( adict [ key ] ) [EOL] return Nothing [EOL] [EOL] foo_adict = { [string] : [string] , [string] : [string] } [EOL] nofoo_adict = { [string] : [string] , [string] : [string] } [EOL] [EOL] res = Some ( foo_adict ) . flat_map ( get_foo_option ) [EOL] assert res . value == [string] [EOL] [EOL] res = Nothing . flat_map ( get_foo_option ) [EOL] assert res is Nothing [EOL] [EOL] res = Some ( nofoo_adict ) . flat_map ( get_foo_option ) [EOL] assert res is Nothing [EOL] [EOL] res = ( Some ( nofoo_adict ) . map ( lambda d : d . get ( [string] ) ) . flat_map ( Optional . from_value ) ) [EOL] assert res is Nothing [EOL] [EOL] res = ( Some ( nofoo_adict ) . map ( lambda d : Optional . from_value ( d . get ( [string] ) ) ) . join ( ) ) [EOL] assert res is Nothing [EOL] [EOL] res = ( Some ( nofoo_adict ) . map ( lambda d : Optional . from_value ( d . get ( [string] ) ) ) . flatten ( ) ) [EOL] assert res is Nothing [EOL] [EOL] res = ( Some ( nofoo_adict ) . map ( lambda d : d . get ( [string] ) ) . join_noneable ( ) ) [EOL] assert res is Nothing [EOL] [EOL] res = ( Some ( nofoo_adict ) . map ( lambda d : d . get ( [string] ) ) . join_noneable ( ) ) [EOL] assert res . value == [string] [EOL] [EOL] [EOL] def test_comparator ( ) : [EOL] some_hello = Some ( [string] ) [EOL] some_hello_2 = Some ( [string] ) [EOL] some_world = Some ( [string] ) [EOL] [EOL] assert some_hello == some_hello_2 [EOL] with pytest . raises ( TypeError ) : [EOL] assert some_hello == [string] [EOL] [EOL] assert some_hello != some_world [EOL] with pytest . raises ( TypeError ) : [EOL] assert some_hello != [string] [EOL] [EOL] some_100 = Some ( [number] ) [EOL] some_100_2 = Some ( [number] ) [EOL] some_200 = Some ( [number] ) [EOL] assert some_100 < some_200 [EOL] assert some_200 > some_100 [EOL] assert some_100 . value < [number] [EOL] assert some_200 . value > [number] [EOL] assert some_100 <= some_200 [EOL] assert some_200 >= some_100 [EOL] assert some_100 <= some_100_2 [EOL] assert some_100 >= some_100_2 [EOL] with pytest . raises ( TypeError ) : [EOL] assert some_200 < [number] [EOL] with pytest . raises ( TypeError ) : [EOL] assert some_200 > [number] [EOL] [EOL] [EOL] class Person : [EOL] def __init__ ( self , name , age , father = None , mother = None ) : [EOL] self . name = name [EOL] self . age = age [EOL] self . father = father [EOL] self . mother = mother [EOL] [EOL] def get_father ( self ) : [EOL] return self . father [EOL] [EOL] def get_mother ( self ) : [EOL] return self . mother [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . name !r} [string] { self . father !r} [string] { self . mother !r} [string] ' [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . name , self . father , self . mother ) == ( other . name , other . father , other . mother ) [EOL] [EOL] [EOL] def test_pluck ( ) : [EOL] d = { [string] : [number] , [string] : [number] } [EOL] [EOL] assert Some ( d ) . pluck ( [string] ) == Some ( [number] ) [EOL] with pytest . raises ( KeyError ) : [EOL] Some ( d ) . pluck ( [string] ) [EOL] [EOL] assert Some ( d ) . pluck_opt ( [string] ) is Nothing [EOL] johnny = Person ( [string] , [number] ) [EOL] assert Some ( johnny ) . pluck_attr ( [string] ) == Some ( [string] ) [EOL] [EOL] [EOL] def test_value_do ( ) : [EOL] [EOL] papa = Person ( [string] , [number] ) [EOL] mama = Person ( [string] , [number] ) [EOL] johnny = Person ( [string] , [number] , papa , mama ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_general ( ) : [EOL] class TreeNode : [EOL] def __init__ ( self , value , left = None , right = None ) : [EOL] self . value = value [EOL] self . left = left [EOL] self . right = right [EOL] [EOL] return None [EOL] [EOL] class TreeNodeOpt : [EOL] def __init__ ( self , name , left = Nothing , right = Nothing ) : [EOL] self . name = name [EOL] self . left = left [EOL] self . right = right [EOL] [EOL] n = TreeNode ( [number] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] result = [number] [EOL] if n . left is not None : [EOL] if n . left . left is not None : [EOL] if n . left . left . right is not None : [EOL] if n . left . left . right . left is not None : [EOL] if n . left . left . right . left . right is not None : [EOL] result = n . left . left . right . left . right . value * [number] [EOL] [EOL] assert result == [number] [EOL] [EOL] n = TreeNodeOpt ( [number] ) [EOL] result = ( n . left . and_then ( lambda n : n . left ) . and_then ( lambda n : n . right ) . and_then ( lambda n : n . left ) . and_then ( lambda n : n . right ) . map ( lambda n : n . value * [number] ) . get_or ( [number] ) ) [EOL] assert result == [number] [EOL] [EOL] n = TreeNode ( [number] ) [EOL] result = ( Optional . from_value ( n . left ) . and_then ( lambda n : n . left ) . join_noneable ( ) . and_then ( lambda n : n . right ) . join_noneable ( ) . and_then ( lambda n : n . left ) . join_noneable ( ) . and_then ( lambda n : n . right ) . join_noneable ( ) . map ( lambda n : n . value * [number] ) . get_or ( [number] ) ) [EOL] assert result == [number] [EOL] [EOL] [EOL] def test_first_elem_is_odd ( ) : [EOL] [EOL] contacts = { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } } , [string] : { [string] : [string] , [string] : { [string] : None , [string] : None } } , [string] : { [string] : None } , [string] : None } [EOL] [EOL] def get_city ( name ) : [EOL] contact = contacts . get ( name ) [EOL] if contact is not None : [EOL] address = contact . get ( [string] ) [EOL] if address is not None : [EOL] city = address . get ( [string] ) [EOL] if city is not None : [EOL] return f' [string] { city }' [EOL] [EOL] return [string] [EOL] [EOL] def getitem_opt ( obj , key ) : [EOL] try : [EOL] return Some ( obj [ key ] ) [EOL] except ( KeyError , TypeError ) as e : [EOL] return Nothing [EOL] [EOL] def get_city2 ( name ) : [EOL] return ( getitem_opt ( contacts , name ) . and_then ( lambda contact : getitem_opt ( contact , [string] ) ) . and_then ( lambda address : getitem_opt ( address , [string] ) ) . filter ( lambda city : city is not None ) . map ( lambda city : f' [string] { city }' ) . get_or ( [string] ) ) [EOL] [EOL] assert get_city ( [string] ) == [string] [EOL] assert get_city ( [string] ) == [string] [EOL] assert get_city ( [string] ) == [string] [EOL] assert get_city ( [string] ) == [string] [EOL] [EOL] assert get_city2 ( [string] ) == [string] [EOL] assert get_city2 ( [string] ) == [string] [EOL] assert get_city2 ( [string] ) == [string] [EOL] assert get_city2 ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0