[comment] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] from os import path [EOL] from setuptools import setup , find_packages [EOL] from duco . const import ( __version__ , PROJECT_PACKAGE_NAME , PROJECT_LICENSE , PROJECT_URL , PROJECT_EMAIL , PROJECT_DESCRIPTION , PROJECT_CLASSIFIERS , GITHUB_URL , PROJECT_AUTHOR ) [EOL] [EOL] HERE = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] DOWNLOAD_URL = ( [string] [string] . format ( GITHUB_URL , __version__ ) ) [EOL] [EOL] PACKAGES = find_packages ( exclude = [ [string] , [string] ] ) [EOL] [EOL] REQUIRES = [ [string] , ] [EOL] [EOL] def get_long_description ( ) : [EOL] [docstring] [EOL] this_directory = path . abspath ( path . dirname ( __file__ ) ) [EOL] with open ( path . join ( this_directory , [string] ) ) as readme : [EOL] long_description = readme . read ( ) [EOL] return long_description [EOL] [EOL] setup ( name = PROJECT_PACKAGE_NAME , version = __version__ , license = PROJECT_LICENSE , url = PROJECT_URL , download_url = DOWNLOAD_URL , author = PROJECT_AUTHOR , author_email = PROJECT_EMAIL , description = PROJECT_DESCRIPTION , long_description = get_long_description ( ) , long_description_content_type = [string] , packages = PACKAGES , include_package_data = True , zip_safe = False , platforms = [string] , install_requires = REQUIRES , test_suite = [string] , keywords = [ [string] , [string] ] , classifiers = PROJECT_CLASSIFIERS , entry_points = { [string] : [ [string] ] , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import unittest [EOL] import duco [EOL] from duco . const import ( MAJOR_VERSION , MINOR_VERSION , PATCH_VERSION ) [EOL] [EOL] [EOL] class TestDucoVersion ( unittest . TestCase ) : [EOL] def test_version ( self ) : [EOL] self . assertEqual ( duco . __version__ , [string] . format ( MAJOR_VERSION , MINOR_VERSION , PATCH_VERSION ) ) [EOL] [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def test_duco ( ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] import duco [EOL] [docstring] [EOL] import unittest [EOL] [comment] [EOL] from unittest . mock import MagicMock [EOL] from duco . const import ( DUCO_MODULE_TYPE_MASTER ) [EOL] from duco . enum_types import ( ModuleType ) [EOL] import duco . modbus [EOL] [EOL] [EOL] class TestModbusHub ( unittest . TestCase ) : [EOL] def test_init_1 ( self ) : [EOL] client_config = duco . modbus . create_client_config ( [string] , [string] ) [EOL] hub = duco . modbus . ModbusHub ( client_config ) [EOL] [EOL] self . assertEqual ( hub . _client , None , [string] ) [EOL] self . assertEqual ( hub . _kwargs , { [string] : client_config [ duco . modbus . CONF_MASTER_UNIT_ID ] } , [string] ) [EOL] self . assertEqual ( hub . _config_type , client_config [ duco . modbus . CONF_TYPE ] , [string] ) [EOL] self . assertEqual ( hub . _config_port , client_config [ duco . modbus . CONF_PORT ] , [string] ) [EOL] self . assertEqual ( hub . _config_timeout , client_config [ duco . modbus . CONF_TIMEOUT ] , [string] ) [EOL] self . assertEqual ( hub . _config_delay , [number] , [string] ) [EOL] self . assertEqual ( hub . _config_method , client_config [ duco . modbus . CONF_METHOD ] , [string] ) [EOL] self . assertEqual ( hub . _config_baudrate , client_config [ duco . modbus . CONF_BAUDRATE ] , [string] ) [EOL] self . assertEqual ( hub . _config_stopbits , client_config [ duco . modbus . CONF_STOPBITS ] , [string] ) [EOL] self . assertEqual ( hub . _config_bytesize , client_config [ duco . modbus . CONF_BYTESIZE ] , [string] ) [EOL] self . assertEqual ( hub . _config_parity , client_config [ duco . modbus . CONF_PARITY ] , [string] ) [EOL] [EOL] def test_close ( self ) : [EOL] modbus_client = MagicMock ( ) [EOL] client_config = duco . modbus . create_client_config ( [string] , [string] ) [EOL] hub = duco . modbus . ModbusHub ( client_config ) [EOL] hub . _client = modbus_client [EOL] hub . close ( ) [EOL] modbus_client . close . assert_called_once ( ) [EOL] [EOL] def test_connect ( self ) : [EOL] modbus_client = MagicMock ( ) [EOL] client_config = duco . modbus . create_client_config ( [string] , [string] ) [EOL] hub = duco . modbus . ModbusHub ( client_config ) [EOL] hub . _client = modbus_client [EOL] hub . connect ( ) [EOL] modbus_client . connect . assert_called_once ( ) [EOL] [EOL] def test_read_coils ( self ) : [EOL] master_id = [number] [EOL] modbus_client = MagicMock ( ) [EOL] client_config = duco . modbus . create_client_config ( [string] , [string] , None , master_id ) [EOL] hub = duco . modbus . ModbusHub ( client_config ) [EOL] hub . _client = modbus_client [EOL] address = [number] [EOL] count = [number] [EOL] hub . read_coils ( address , count ) [EOL] modbus_client . read_coils . assert_called_with ( address , count , unit = master_id ) [EOL] hub . read_coils ( address ) [EOL] modbus_client . read_coils . assert_called_with ( address , [number] , unit = master_id ) [EOL] [EOL] def test_read_input_registers ( self ) : [EOL] master_id = [number] [EOL] modbus_client = MagicMock ( ) [EOL] client_config = duco . modbus . create_client_config ( [string] , [string] , None , master_id ) [EOL] hub = duco . modbus . ModbusHub ( client_config ) [EOL] hub . _client = modbus_client [EOL] address = [number] [EOL] count = [number] [EOL] hub . read_input_registers ( address , count ) [EOL] modbus_client . read_input_registers . assert_called_with ( address , count , unit = master_id ) [EOL] hub . read_input_registers ( address ) [EOL] modbus_client . read_input_registers . assert_called_with ( address , [number] , unit = master_id ) [EOL] [EOL] def test_read_holding_registers ( self ) : [EOL] master_id = [number] [EOL] modbus_client = MagicMock ( ) [EOL] client_config = duco . modbus . create_client_config ( [string] , [string] , None , master_id ) [EOL] hub = duco . modbus . ModbusHub ( client_config ) [EOL] hub . _client = modbus_client [EOL] address = [number] [EOL] count = [number] [EOL] hub . read_holding_registers ( address , count ) [EOL] modbus_client . read_holding_registers . assert_called_with ( address , count , unit = master_id ) [EOL] hub . read_holding_registers ( address ) [EOL] modbus_client . read_holding_registers . assert_called_with ( address , [number] , unit = master_id ) [EOL] [EOL] def test_write_coil ( self ) : [EOL] master_id = [number] [EOL] modbus_client = MagicMock ( ) [EOL] client_config = duco . modbus . create_client_config ( [string] , [string] , None , master_id ) [EOL] hub = duco . modbus . ModbusHub ( client_config ) [EOL] hub . _client = modbus_client [EOL] address = [number] [EOL] value = [number] [EOL] hub . write_coil ( address , value ) [EOL] modbus_client . write_coil . assert_called_once_with ( address , value , unit = master_id ) [EOL] [EOL] def test_write_register ( self ) : [EOL] master_id = [number] [EOL] modbus_client = MagicMock ( ) [EOL] client_config = duco . modbus . create_client_config ( [string] , [string] , None , master_id ) [EOL] hub = duco . modbus . ModbusHub ( client_config ) [EOL] hub . _client = modbus_client [EOL] address = [number] [EOL] value = [number] [EOL] hub . write_register ( address , value ) [EOL] modbus_client . write_register . assert_called_once_with ( address , value , unit = master_id ) [EOL] [EOL] def test_write_registers ( self ) : [EOL] master_id = [number] [EOL] modbus_client = MagicMock ( ) [EOL] client_config = duco . modbus . create_client_config ( [string] , [string] , None , master_id ) [EOL] hub = duco . modbus . ModbusHub ( client_config ) [EOL] hub . _client = modbus_client [EOL] address = [number] [EOL] value = [number] [EOL] hub . write_registers ( address , value ) [EOL] modbus_client . write_registers . assert_called_once_with ( address , value , unit = master_id ) [EOL] [EOL] [EOL] class TestModbusRegister ( unittest . TestCase ) : [EOL] def test_init ( self ) : [EOL] r_hub = MagicMock ( ) [EOL] r_name = [string] [EOL] r_reg = [number] [EOL] r_reg_type = duco . modbus . REGISTER_TYPE_INPUT [EOL] r_unit = [string] [EOL] r_count = [number] [EOL] r_scale = [number] [EOL] r_offset = [number] [EOL] r_data_type = duco . modbus . DATA_TYPE_INT [EOL] r_precision = [number] [EOL] reg = duco . modbus . ModbusRegister ( r_hub , r_name , r_reg , r_reg_type , r_unit , r_count , r_scale , r_offset , r_data_type , r_precision ) [EOL] self . assertEqual ( reg . name , r_name , [string] ) [EOL] self . assertEqual ( reg . unit_of_measurement , r_unit , [string] ) [EOL] self . assertEqual ( reg . _count , r_count ) [EOL] self . assertEqual ( reg . _scale , r_scale ) [EOL] self . assertEqual ( reg . _offset , r_offset ) [EOL] self . assertEqual ( reg . _data_type , r_data_type ) [EOL] self . assertEqual ( reg . _precision , r_precision ) [EOL] self . assertEqual ( reg . _value , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $unittest.mock.MagicMock$ 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $unittest.mock.MagicMock$ 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $unittest.mock.MagicMock$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $builtins.int$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $unittest.mock.MagicMock$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $builtins.int$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $unittest.mock.MagicMock$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $builtins.int$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $unittest.mock.MagicMock$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $unittest.mock.MagicMock$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $duco.modbus.ModbusHub$ 0 0 0 $unittest.mock.MagicMock$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] [EOL] def test_nodes ( ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import unittest [EOL] from duco . const import ( DUCO_MODULE_TYPE_MASTER , DUCO_MODULE_TYPE_ACTUATOR_PRINT ) [EOL] from duco . enum_types import ( ModuleType ) [EOL] [EOL] [EOL] class TestModuleType ( unittest . TestCase ) : [EOL] def test_supported ( self ) : [EOL] for idx in range ( DUCO_MODULE_TYPE_MASTER , [number] ) : [EOL] self . assertTrue ( ModuleType . supported ( idx ) , [string] ) [EOL] [EOL] self . assertFalse ( ModuleType . supported ( DUCO_MODULE_TYPE_MASTER - [number] ) , [string] ) [EOL] self . assertFalse ( ModuleType . supported ( DUCO_MODULE_TYPE_ACTUATOR_PRINT + [number] ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import unittest [EOL] import duco . helpers [EOL] [EOL] [EOL] class TestVerifyValueInRange ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_is_none ( self ) : [EOL] self . assertIsNone ( duco . helpers . verify_value_in_range ( [number] , [number] , [number] , [number] ) ) [EOL] self . assertIsNone ( duco . helpers . verify_value_in_range ( [number] , [number] , [number] , [number] ) ) [EOL] for var in range ( [number] , [number] , [number] ) : [EOL] self . assertIsNone ( duco . helpers . verify_value_in_range ( var , [number] , [number] , [number] ) ) [EOL] [EOL] def test_raises ( self ) : [EOL] self . assertRaises ( ValueError , lambda : duco . helpers . verify_value_in_range ( - [number] , [number] , [number] , [number] ) ) [EOL] self . assertRaises ( ValueError , lambda : duco . helpers . verify_value_in_range ( [number] , [number] , [number] , [number] ) ) [EOL] self . assertRaises ( ValueError , lambda : duco . helpers . verify_value_in_range ( [number] , [number] , [number] , [number] ) ) [EOL] self . assertRaises ( ValueError , lambda : duco . helpers . verify_value_in_range ( [number] , [number] , [number] , [number] ) ) [EOL] [EOL] class TestToRegisterAddress ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_1 ( self ) : [EOL] node_id = [number] [EOL] param_id = [number] [EOL] self . assertEqual ( duco . helpers . to_register_addr ( node_id , param_id ) , ( node_id * [number] + param_id ) ) [EOL] [EOL] def test_2 ( self ) : [EOL] node_id = [number] [EOL] param_id = [number] [EOL] self . assertEqual ( duco . helpers . to_register_addr ( node_id , param_id ) , ( node_id * [number] + param_id ) ) [EOL] [EOL] class TestTwosComp ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_8b ( self ) : [EOL] [docstring] [EOL] n_bits = [number] [EOL] [comment] [EOL] for var in range ( [number] , [number] ** ( n_bits - [number] ) , [number] ) : [EOL] self . assertEqual ( duco . helpers . twos_comp ( var , n_bits ) , var ) [EOL] [comment] [EOL] for var in range ( [number] , [number] ** ( n_bits - [number] ) , [number] ) : [EOL] self . assertEqual ( duco . helpers . twos_comp ( ( [number] ** n_bits ) - var , n_bits ) , - var ) [EOL] [EOL] def test_16b ( self ) : [EOL] [docstring] [EOL] n_bits = [number] [EOL] [comment] [EOL] for var in range ( [number] , [number] ** ( n_bits - [number] ) , [number] ) : [EOL] self . assertEqual ( duco . helpers . twos_comp ( var , n_bits ) , var ) [EOL] [comment] [EOL] for var in range ( [number] , [number] ** ( n_bits - [number] ) , [number] ) : [EOL] self . assertEqual ( duco . helpers . twos_comp ( ( [number] ** n_bits ) - var , n_bits ) , - var ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import duco [EOL] [docstring] [EOL] import logging [EOL] [EOL] from duco . const import ( PROJECT_PACKAGE_NAME , DUCO_REG_ADDR_INPUT_MODULE_TYPE , DUCO_MODBUS_MASTER_DEFAULT_UNIT_ID ) [EOL] [EOL] from duco . enum_types import ( ModuleType ) [EOL] from duco . helpers import ( to_register_addr ) [EOL] from duco . modbus import ( create_client_config , ModbusHub ) [EOL] from duco . nodes import ( Node ) [EOL] [EOL] _LOGGER = logging . getLogger ( PROJECT_PACKAGE_NAME ) [EOL] [EOL] [EOL] class DucoBox : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , modbus_client_type , modbus_client_port , modbus_client_host = None , modbus_master_unit_id = DUCO_MODBUS_MASTER_DEFAULT_UNIT_ID ) : [EOL] [docstring] [EOL] client_config = create_client_config ( modbus_client_type , modbus_client_port , modbus_client_host , modbus_master_unit_id ) [EOL] self . _modbus_hub = ModbusHub ( client_config ) [EOL] self . node_list = list ( ) [EOL] [EOL] def __enter__ ( self ) : [EOL] [docstring] [EOL] self . _modbus_hub . setup ( ) [EOL] self . __enumerate_node_tree ( ) [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , _exc_value , traceback ) : [EOL] [docstring] [EOL] self . _modbus_hub . close ( ) [EOL] [EOL] def __enumerate_node_tree ( self ) : [EOL] [docstring] [EOL] node_id = [number] [EOL] node_found = True [EOL] self . node_list = list ( ) [EOL] [EOL] while node_found : [EOL] node_type = self . __probe_node_id ( node_id ) [EOL] [EOL] if node_type is False : [EOL] node_found = False [EOL] else : [EOL] self . node_list . append ( Node . factory ( node_id , node_type , self . _modbus_hub ) ) [EOL] [EOL] node_id = node_id + [number] [EOL] [EOL] def __probe_node_id ( self , node_id ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , node_id ) [EOL] modbus_result = self . _modbus_hub . read_input_registers ( to_register_addr ( node_id , DUCO_REG_ADDR_INPUT_MODULE_TYPE ) , [number] ) [EOL] try : [EOL] register = modbus_result . registers [EOL] response = register [ [number] ] [EOL] except AttributeError : [EOL] _LOGGER . debug ( [string] , node_id ) [EOL] return False [EOL] [EOL] if ModuleType . supported ( response ) : [EOL] module_type = ModuleType ( response ) [EOL] _LOGGER . debug ( [string] , node_id , module_type ) [EOL] return module_type [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusHub$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $duco.enum_types.ModuleType$ 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $duco.enum_types.ModuleType$ 0 0 0 $duco.enum_types.ModuleType$ 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] from . const import ( __version__ ) [EOL] from . duco import DucoBox [EOL] [EOL] __all__ = ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0
import duco [EOL] [docstring] [EOL] from duco . const import ( DUCO_REG_ADDR_INPUT_STATUS , DUCO_REG_ADDR_INPUT_FAN_ACTUAL , DUCO_REG_ADDR_INPUT_TEMPERATURE , DUCO_REG_ADDR_INPUT_CO2_ACTUAL , DUCO_REG_ADDR_INPUT_RH_ACTUAL , DUCO_REG_ADDR_INPUT_GROUP , DUCO_REG_ADDR_HOLD_FAN_SETPOINT , DUCO_REG_ADDR_HOLD_CO2_SETPOINT , DUCO_REG_ADDR_HOLD_RH_SETPOINT , DUCO_REG_ADDR_HOLD_RH_DELTA , DUCO_REG_ADDR_HOLD_FLOW , DUCO_REG_ADDR_HOLD_AUTOMIN , DUCO_REG_ADDR_HOLD_AUTOMAX , DUCO_REG_ADDR_HOLD_ACTION , DUCO_REG_ADDR_HOLD_BUTTON_1 , DUCO_REG_ADDR_HOLD_BUTTON_2 , DUCO_REG_ADDR_HOLD_BUTTON_3 , DUCO_REG_ADDR_HOLD_MANUAL_TIME , DUCO_TEMPERATURE_SCALE_FACTOR , DUCO_TEMPERATURE_PRECISION , DUCO_RH_SCALE_FACTOR , DUCO_RH_PRECISION , DUCO_ZONE_STATUS_OFFSET , DUCO_ACTION_OFFSET , DUCO_PCT_RANGE_START , DUCO_PCT_RANGE_STEP , DUCO_PCT_RANGE_STOP ) [EOL] from duco . enum_types import ( ModuleType , ZoneStatus , ZoneAction ) [EOL] from duco . helpers import ( to_register_addr , verify_value_in_range ) [EOL] from duco . modbus import ( REGISTER_TYPE_INPUT , REGISTER_TYPE_HOLDING , DATA_TYPE_INT , ModbusRegister ) [EOL] [EOL] [EOL] class Node : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] @ staticmethod def factory ( node_id , node_type , modbus_hub ) : [EOL] [docstring] [EOL] if node_type == ModuleType . MASTER : [EOL] return BoxNode ( node_id , node_type , modbus_hub ) [EOL] if node_type == ModuleType . VALVE_SENSORLESS : [EOL] return SensorlessValveNode ( node_id , node_type , modbus_hub ) [EOL] if node_type == ModuleType . VALVE_CO2 : [EOL] return CO2ValveNode ( node_id , node_type , modbus_hub ) [EOL] if node_type == ModuleType . VALVE_RH : [EOL] return RHValveNode ( node_id , node_type , modbus_hub ) [EOL] if node_type == ModuleType . USER_CONTROLLER : [EOL] return UserControllerNode ( node_id , node_type , modbus_hub ) [EOL] if node_type == ModuleType . ROOM_SENSOR_CO2 : [EOL] return CO2SensorNode ( node_id , node_type , modbus_hub ) [EOL] if node_type == ModuleType . ROOM_SENSOR_RH : [EOL] return RHSensorNode ( node_id , node_type , modbus_hub ) [EOL] raise ValueError ( [string] . format ( ModuleType ( node_type ) ) ) [EOL] [EOL] def __init__ ( self , node_id , node_type , modbus_hub ) : [EOL] [docstring] [EOL] self . _node_id = int ( node_id ) [EOL] self . _node_type = ModuleType ( node_type ) [EOL] self . _child_nodes = [ ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _reg_status = ModbusRegister ( modbus_hub , [string] , to_register_addr ( self . _node_id , DUCO_REG_ADDR_INPUT_STATUS ) , REGISTER_TYPE_INPUT , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [EOL] self . _reg_fan_actual = ModbusRegister ( modbus_hub , [string] , to_register_addr ( self . _node_id , DUCO_REG_ADDR_INPUT_FAN_ACTUAL ) , REGISTER_TYPE_INPUT , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [EOL] self . _reg_zone = ModbusRegister ( modbus_hub , [string] , to_register_addr ( self . _node_id , DUCO_REG_ADDR_INPUT_GROUP ) , REGISTER_TYPE_INPUT , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [comment] [EOL] self . _reg_setpoint = ModbusRegister ( modbus_hub , [string] , to_register_addr ( self . _node_id , DUCO_REG_ADDR_HOLD_FAN_SETPOINT ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [EOL] self . _reg_action = ModbusRegister ( modbus_hub , [string] , to_register_addr ( self . _node_id , DUCO_REG_ADDR_HOLD_ACTION ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( [string] + str ( self . node_id ) + [string] + [string] + str ( self . node_type ) + [string] + [string] + str ( self . _reg_zone ) + [string] + [string] + str ( self . status ) + [string] + [string] + str ( self . _reg_fan_actual ) + [string] + [string] + str ( self . _reg_setpoint ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return ( self . _reg_status . state , self . _reg_zone . state , self . _reg_fan_actual . state , self . _reg_setpoint . state ) [EOL] [EOL] @ property def node_id ( self ) : [EOL] [docstring] [EOL] return self . _node_id [EOL] [EOL] @ property def node_type ( self ) : [EOL] [docstring] [EOL] return self . _node_type [EOL] [EOL] @ property def action ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] @ action . setter def action ( self , new_action ) : [EOL] [docstring] [EOL] [comment] [EOL] new_action_i = int ( new_action ) [EOL] [comment] [EOL] if isinstance ( new_action , ZoneAction ) : [EOL] new_action_i = new_action_i - DUCO_ACTION_OFFSET [EOL] [comment] [EOL] verify_value_in_range ( new_action_i , [number] , [number] , [number] ) [EOL] [comment] [EOL] self . _reg_action . value = new_action_i [EOL] [EOL] @ property def fan_actual ( self ) : [EOL] [docstring] [EOL] return self . _reg_fan_actual . value [EOL] [EOL] @ property def status ( self ) : [EOL] [docstring] [EOL] return ZoneStatus ( int ( self . _reg_status . value ) + DUCO_ZONE_STATUS_OFFSET ) [EOL] [EOL] @ property def zone ( self ) : [EOL] [docstring] [EOL] return self . _reg_zone . value [EOL] [EOL] [EOL] class AutoMinMaxCapable : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , modbus_hub ) : [EOL] [docstring] [EOL] self . _reg_automin = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_HOLD_AUTOMIN ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [EOL] self . _reg_automax = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_HOLD_AUTOMAX ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( [string] + str ( self . _reg_automin ) + [string] + [string] + str ( self . _reg_automax ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return ( self . _reg_automin . state , self . _reg_automax . state ) [EOL] [EOL] @ property def auto_min ( self ) : [EOL] [docstring] [EOL] return self . _reg_automin . value [EOL] [EOL] @ auto_min . setter def auto_min ( self , new_min ) : [EOL] [docstring] [EOL] [comment] [EOL] new_min_i = int ( new_min ) [EOL] verify_value_in_range ( new_min_i , DUCO_PCT_RANGE_START , DUCO_PCT_RANGE_STEP , DUCO_PCT_RANGE_STOP ) [EOL] [comment] [EOL] self . _reg_automin . value = new_min_i [EOL] [EOL] @ property def auto_max ( self ) : [EOL] [docstring] [EOL] return self . _reg_automax . value [EOL] [EOL] @ auto_max . setter def auto_max ( self , new_max ) : [EOL] [docstring] [EOL] [comment] [EOL] new_max_i = int ( new_max ) [EOL] verify_value_in_range ( new_max_i , DUCO_PCT_RANGE_START , DUCO_PCT_RANGE_STEP , DUCO_PCT_RANGE_STOP ) [EOL] [comment] [EOL] self . _reg_automax . value = new_max_i [EOL] [EOL] [EOL] class BoxNode ( Node , AutoMinMaxCapable ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , node_type , modbus_hub ) : [EOL] [docstring] [EOL] Node . __init__ ( self , node_id , node_type , modbus_hub ) [EOL] AutoMinMaxCapable . __init__ ( self , node_id , modbus_hub ) [EOL] [comment] [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( Node . __str__ ( self ) + [string] + AutoMinMaxCapable . __str__ ( self ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return ( Node . state ( self ) + [string] + AutoMinMaxCapable . state ( self ) ) [EOL] [EOL] [EOL] class TemperatureSensor : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , modbus_hub ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _reg_temperature = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_INPUT_TEMPERATURE ) , REGISTER_TYPE_INPUT , [string] , [number] , DUCO_TEMPERATURE_SCALE_FACTOR , [number] , DATA_TYPE_INT , DUCO_TEMPERATURE_PRECISION ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return [string] + str ( self . _reg_temperature ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return ( self . _reg_temperature . state , ) [EOL] [EOL] @ property def temperature ( self ) : [EOL] [docstring] [EOL] return self . _reg_temperature . value [EOL] [EOL] [EOL] class Valve ( Node , AutoMinMaxCapable , TemperatureSensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , node_type , modbus_hub ) : [EOL] [docstring] [EOL] Node . __init__ ( self , node_id , node_type , modbus_hub ) [EOL] AutoMinMaxCapable . __init__ ( self , node_id , modbus_hub ) [EOL] TemperatureSensor . __init__ ( self , node_id , modbus_hub ) [EOL] [EOL] [comment] [EOL] self . _reg_flow = ModbusRegister ( modbus_hub , [string] , to_register_addr ( self . _node_id , DUCO_REG_ADDR_HOLD_FLOW ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [comment] [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( Node . __str__ ( self ) + [string] + AutoMinMaxCapable . __str__ ( self ) + [string] + TemperatureSensor . __str__ ( self ) + [string] + [string] + str ( self . _reg_flow ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return ( Node . state ( self ) , AutoMinMaxCapable . state ( self ) , TemperatureSensor . state ( self ) , self . _reg_flow . state ) [EOL] [EOL] @ property def flow ( self ) : [EOL] [docstring] [EOL] return self . _reg_flow . value [EOL] [EOL] [EOL] class CO2Sensor : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , modbus_hub ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _reg_co2_value = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_INPUT_CO2_ACTUAL ) , REGISTER_TYPE_INPUT , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [comment] [EOL] self . _reg_co2_setpoint = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_HOLD_CO2_SETPOINT ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( [string] + str ( self . _reg_co2_value ) + [string] + [string] + str ( self . _reg_co2_setpoint ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return ( self . _reg_co2_setpoint . state , self . _reg_co2_value . state ) [EOL] [EOL] @ property def co2_value ( self ) : [EOL] [docstring] [EOL] return self . _reg_co2_value . value [EOL] [EOL] @ property def co2_setpoint ( self ) : [EOL] [docstring] [EOL] return self . _reg_co2_setpoint . value [EOL] [EOL] [EOL] class RHSensor : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , modbus_hub ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _reg_rh_value = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_INPUT_RH_ACTUAL ) , REGISTER_TYPE_INPUT , [string] , [number] , DUCO_RH_SCALE_FACTOR , [number] , DATA_TYPE_INT , DUCO_RH_PRECISION ) [EOL] [comment] [EOL] self . _reg_rh_setpoint = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_HOLD_RH_SETPOINT ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] self . _reg_rh_delta = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_HOLD_RH_DELTA ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( [string] + str ( self . _reg_rh_value ) + [string] + [string] + str ( self . _reg_rh_setpoint ) + [string] + [string] + str ( self . _reg_rh_delta ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return ( self . _reg_rh_setpoint . state , self . _reg_rh_value . state , self . _reg_rh_delta . state ) [EOL] [EOL] @ property def rh_value ( self ) : [EOL] [docstring] [EOL] return self . _reg_rh_value . value [EOL] [EOL] @ property def rh_setpoint ( self ) : [EOL] [docstring] [EOL] return self . _reg_rh_setpoint . value [EOL] [EOL] @ property def is_rh_delta_enabled ( self ) : [EOL] [docstring] [EOL] return bool ( self . _reg_rh_delta . value ) [EOL] [EOL] [EOL] class UserController : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , modbus_hub ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _reg_button_1 = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_HOLD_BUTTON_1 ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] self . _reg_button_2 = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_HOLD_BUTTON_2 ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] self . _reg_button_3 = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_HOLD_BUTTON_3 ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] self . _reg_manual_time = ModbusRegister ( modbus_hub , [string] , to_register_addr ( node_id , DUCO_REG_ADDR_HOLD_MANUAL_TIME ) , REGISTER_TYPE_HOLDING , [string] , [number] , [number] , [number] , DATA_TYPE_INT , [number] ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( [string] + str ( self . _reg_button_1 ) + [string] + [string] + str ( self . _reg_button_2 ) + [string] + [string] + str ( self . _reg_button_3 ) + [string] + [string] + str ( self . _reg_manual_time ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return ( self . _reg_button_1 . state , self . _reg_button_2 . state , self . _reg_button_3 . state , self . _reg_manual_time . state ) [EOL] [EOL] @ property def button1 ( self ) : [EOL] [docstring] [EOL] return self . _reg_button_1 . value [EOL] [EOL] @ button1 . setter def button1 ( self , new_setpoint ) : [EOL] [docstring] [EOL] [comment] [EOL] new_setpoint_i = int ( new_setpoint ) [EOL] verify_value_in_range ( new_setpoint_i , DUCO_PCT_RANGE_START , DUCO_PCT_RANGE_STEP , DUCO_PCT_RANGE_STOP ) [EOL] [comment] [EOL] self . _reg_button_1 . value = new_setpoint_i [EOL] [EOL] @ property def button2 ( self ) : [EOL] [docstring] [EOL] return self . _reg_button_2 . value [EOL] [EOL] @ button2 . setter def button2 ( self , new_setpoint ) : [EOL] [docstring] [EOL] [comment] [EOL] new_setpoint_i = int ( new_setpoint ) [EOL] verify_value_in_range ( new_setpoint_i , DUCO_PCT_RANGE_START , DUCO_PCT_RANGE_STEP , DUCO_PCT_RANGE_STOP ) [EOL] [comment] [EOL] self . _reg_button_2 . value = new_setpoint_i [EOL] [EOL] @ property def button3 ( self ) : [EOL] [docstring] [EOL] return self . _reg_button_3 . value [EOL] [EOL] @ button3 . setter def button3 ( self , new_setpoint ) : [EOL] [docstring] [EOL] [comment] [EOL] new_setpoint_i = int ( new_setpoint ) [EOL] verify_value_in_range ( new_setpoint_i , DUCO_PCT_RANGE_START , DUCO_PCT_RANGE_STEP , DUCO_PCT_RANGE_STOP ) [EOL] [comment] [EOL] self . _reg_button_3 . value = new_setpoint_i [EOL] [EOL] @ property def manual_time ( self ) : [EOL] [docstring] [EOL] return self . _reg_manual_time . value [EOL] [EOL] [EOL] class SensorlessValveNode ( Valve ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , node_type , modbus_hub ) : [EOL] [docstring] [EOL] Valve . __init__ ( self , node_id , node_type , modbus_hub ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return Valve . __str__ ( self ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return Valve . state ( self ) [EOL] [EOL] [EOL] class CO2ValveNode ( Valve , CO2Sensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , node_type , modbus_hub ) : [EOL] [docstring] [EOL] Valve . __init__ ( self , node_id , node_type , modbus_hub ) [EOL] CO2Sensor . __init__ ( self , node_id , modbus_hub ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( Valve . __str__ ( self ) + [string] + CO2Sensor . __str__ ( self ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return Valve . state ( self ) + CO2Sensor . state ( self ) [EOL] [EOL] [EOL] class RHValveNode ( Valve , RHSensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , node_type , modbus_hub ) : [EOL] [docstring] [EOL] Valve . __init__ ( self , node_id , node_type , modbus_hub ) [EOL] RHSensor . __init__ ( self , node_id , modbus_hub ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( Valve . __str__ ( self ) + [string] + RHSensor . __str__ ( self ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return Valve . state ( self ) + RHSensor . state ( self ) [EOL] [EOL] [EOL] class UserControllerNode ( Node , UserController ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , node_type , modbus_hub ) : [EOL] [docstring] [EOL] Node . __init__ ( self , node_id , node_type , modbus_hub ) [EOL] UserController . __init__ ( self , node_id , modbus_hub ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( Node . __str__ ( self ) + [string] + UserController . __str__ ( self ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return Node . state ( self ) + UserController . state ( self ) [EOL] [EOL] [EOL] class CO2SensorNode ( Node , UserController , CO2Sensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , node_type , modbus_hub ) : [EOL] [docstring] [EOL] Node . __init__ ( self , node_id , node_type , modbus_hub ) [EOL] UserController . __init__ ( self , node_id , modbus_hub ) [EOL] CO2Sensor . __init__ ( self , node_id , modbus_hub ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( Node . __str__ ( self ) + [string] + UserController . __str__ ( self ) + [string] + CO2Sensor . __str__ ( self ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return ( Node . state ( self ) + UserController . state ( self ) + CO2Sensor . state ( self ) ) [EOL] [EOL] [EOL] class RHSensorNode ( Node , UserController , RHSensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id , node_type , modbus_hub ) : [EOL] [docstring] [EOL] Node . __init__ ( self , node_id , node_type , modbus_hub ) [EOL] UserController . __init__ ( self , node_id , modbus_hub ) [EOL] RHSensor . __init__ ( self , node_id , modbus_hub ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( Node . __str__ ( self ) + [string] + UserController . __str__ ( self ) + [string] + RHSensor . __str__ ( self ) ) [EOL] [EOL] def state ( self ) : [EOL] [docstring] [EOL] return ( Node . state ( self ) + UserController . state ( self ) + RHSensor . state ( self ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $duco.enum_types.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $duco.modbus.ModbusRegister$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import argparse [EOL] from duco . const import ( PROJECT_PACKAGE_NAME ) [EOL] from duco . enum_types import ( ModuleType , ZoneAction ) [EOL] from duco . duco import ( DucoBox ) [EOL] [EOL] [EOL] _LOGGER = logging . getLogger ( PROJECT_PACKAGE_NAME ) [EOL] [EOL] [EOL] def configure_logging ( ) : [EOL] [docstring] [EOL] _LOGGER . setLevel ( logging . DEBUG ) [EOL] [EOL] [comment] [EOL] console = logging . StreamHandler ( ) [EOL] console . setLevel ( logging . DEBUG ) [EOL] [EOL] [comment] [EOL] formatter = logging . Formatter ( [string] ) [EOL] [EOL] [comment] [EOL] console . setFormatter ( formatter ) [EOL] [EOL] [comment] [EOL] _LOGGER . addHandler ( console ) [EOL] [EOL] [EOL] def parse_args ( ) : [EOL] [docstring] [EOL] description = [string] [EOL] parser = argparse . ArgumentParser ( description = description ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , default = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , default = [string] , help = [string] ) [EOL] [EOL] return parser . parse_args ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] args = parse_args ( ) [EOL] [EOL] configure_logging ( ) [EOL] [EOL] with DucoBox ( args . modbus_type , args . modbus_port , args . modbus_host ) as duco_box : [EOL] for node in duco_box . node_list : [EOL] print ( node ) [EOL] if node . node_type == ModuleType . USER_CONTROLLER : [EOL] node . action = ZoneAction . ZONE_TO_AUTO [EOL] print ( node ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] import threading [EOL] [docstring] [EOL] import logging [EOL] import struct [EOL] import threading [EOL] [EOL] from duco . const import ( PROJECT_PACKAGE_NAME , DUCO_MODBUS_BAUD_RATE , DUCO_MODBUS_BYTE_SIZE , DUCO_MODBUS_STOP_BITS , DUCO_MODBUS_PARITY , DUCO_MODBUS_METHOD ) [EOL] from duco . helpers import ( twos_comp ) [EOL] [EOL] _LOGGER = logging . getLogger ( PROJECT_PACKAGE_NAME ) [EOL] [EOL] [comment] [EOL] CONF_MASTER_UNIT_ID = [string] [EOL] CONF_METHOD = [string] [EOL] CONF_HOST = [string] [EOL] CONF_PORT = [string] [EOL] CONF_BAUDRATE = [string] [EOL] CONF_BYTESIZE = [string] [EOL] CONF_STOPBITS = [string] [EOL] CONF_TYPE = [string] [EOL] CONF_PARITY = [string] [EOL] CONF_TIMEOUT = [string] [EOL] [EOL] REGISTER_TYPE_HOLDING = [string] [EOL] REGISTER_TYPE_INPUT = [string] [EOL] [EOL] DATA_TYPE_INT = [string] [EOL] DATA_TYPE_FLOAT = [string] [EOL] [EOL] [EOL] def create_client_config ( modbus_client_type , modbus_client_port , modbus_client_host = None , modbus_master_unit_id = [number] ) : [EOL] [docstring] [EOL] config = { CONF_TYPE : str ( modbus_client_type ) , CONF_PORT : str ( modbus_client_port ) , CONF_MASTER_UNIT_ID : int ( modbus_master_unit_id ) , CONF_TIMEOUT : int ( [number] ) } [EOL] [comment] [EOL] if modbus_client_type == [string] : [EOL] config [ CONF_METHOD ] = DUCO_MODBUS_METHOD [EOL] config [ CONF_BAUDRATE ] = DUCO_MODBUS_BAUD_RATE [EOL] config [ CONF_BYTESIZE ] = DUCO_MODBUS_BYTE_SIZE [EOL] config [ CONF_STOPBITS ] = DUCO_MODBUS_STOP_BITS [EOL] config [ CONF_PARITY ] = DUCO_MODBUS_PARITY [EOL] elif modbus_client_type == [string] : [EOL] config [ CONF_HOST ] = str ( modbus_client_host ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] return config [EOL] [EOL] [EOL] class ModbusHub : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client_config ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _client = None [EOL] self . _kwargs = { [string] : client_config [ CONF_MASTER_UNIT_ID ] } [EOL] self . _lock = threading . Lock ( ) [EOL] self . _config_type = client_config [ CONF_TYPE ] [EOL] self . _config_port = client_config [ CONF_PORT ] [EOL] self . _config_timeout = client_config [ CONF_TIMEOUT ] [EOL] self . _config_delay = [number] [EOL] [EOL] if self . _config_type == [string] : [EOL] [comment] [EOL] self . _config_method = client_config [ CONF_METHOD ] [EOL] self . _config_baudrate = client_config [ CONF_BAUDRATE ] [EOL] self . _config_stopbits = client_config [ CONF_STOPBITS ] [EOL] self . _config_bytesize = client_config [ CONF_BYTESIZE ] [EOL] self . _config_parity = client_config [ CONF_PARITY ] [EOL] else : [EOL] [comment] [EOL] self . _config_host = client_config [ CONF_HOST ] [EOL] [EOL] def setup ( self ) : [EOL] [docstring] [EOL] if self . _config_type == [string] : [EOL] from pymodbus . client . sync import ModbusSerialClient [EOL] self . _client = ModbusSerialClient ( method = self . _config_method , port = self . _config_port , baudrate = self . _config_baudrate , stopbits = self . _config_stopbits , bytesize = self . _config_bytesize , parity = self . _config_parity , timeout = self . _config_timeout , retry_on_empty = True , ) [EOL] elif self . _config_type == [string] : [EOL] from pymodbus . client . sync import ModbusTcpClient [EOL] from pymodbus . transaction import ModbusRtuFramer [EOL] self . _client = ModbusTcpClient ( host = self . _config_host , port = self . _config_port , framer = ModbusRtuFramer , timeout = self . _config_timeout , ) [EOL] elif self . _config_type == [string] : [EOL] from pymodbus . client . sync import ModbusTcpClient [EOL] self . _client = ModbusTcpClient ( host = self . _config_host , port = self . _config_port , timeout = self . _config_timeout , ) [EOL] elif self . _config_type == [string] : [EOL] from pymodbus . client . sync import ModbusUdpClient [EOL] self . _client = ModbusUdpClient ( host = self . _config_host , port = self . _config_port , timeout = self . _config_timeout , ) [EOL] else : [EOL] raise ValueError ( ( [string] + [string] ) ) [EOL] [EOL] [comment] [EOL] self . connect ( ) [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] self . _client . close ( ) [EOL] [EOL] def connect ( self ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] self . _client . connect ( ) [EOL] [EOL] def read_coils ( self , address , count = [number] ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] return self . _client . read_coils ( address , count , ** self . _kwargs ) [EOL] [EOL] def read_input_registers ( self , address , count = [number] ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] return self . _client . read_input_registers ( address , count , ** self . _kwargs ) [EOL] [EOL] def read_holding_registers ( self , address , count = [number] ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] return self . _client . read_holding_registers ( address , count , ** self . _kwargs ) [EOL] [EOL] def write_coil ( self , address , value ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] self . _client . write_coil ( address , value , ** self . _kwargs ) [EOL] [EOL] def write_register ( self , address , value ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] self . _client . write_register ( address , value , ** self . _kwargs ) [EOL] [EOL] def write_registers ( self , address , values ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] self . _client . write_registers ( address , values , ** self . _kwargs ) [EOL] [EOL] [EOL] class ModbusRegister : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hub , name , register , register_type , unit_of_measurement , count , scale , offset , data_type , precision ) : [EOL] [docstring] [EOL] self . _hub = hub [EOL] self . _name = name [EOL] self . _register = int ( register ) [EOL] self . _register_type = register_type [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . _count = int ( count ) [EOL] self . _scale = scale [EOL] self . _offset = offset [EOL] self . _precision = precision [EOL] self . _data_type = data_type [EOL] self . _value = None [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return ( self . _name + [string] + str ( self . value ) + [string] + self . _unit_of_measurement ) [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] self . update ( ) [EOL] return self . _value [EOL] [EOL] @ value . setter def value ( self , new_value ) : [EOL] [docstring] [EOL] if self . _register_type != REGISTER_TYPE_HOLDING : [EOL] raise TypeError ( [string] ) [EOL] [EOL] self . _hub . write_register ( self . _register , new_value ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _name , [string] : str ( self . value ) , [string] : self . _unit_of_measurement } [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . _register_type == REGISTER_TYPE_INPUT : [EOL] result = self . _hub . read_input_registers ( self . _register , self . _count ) [EOL] else : [EOL] result = self . _hub . read_holding_registers ( self . _register , self . _count ) [EOL] val = [number] [EOL] [EOL] try : [EOL] registers = result . registers [EOL] except AttributeError : [EOL] _LOGGER . error ( [string] , self . _register ) [EOL] return [EOL] if self . _data_type == DATA_TYPE_FLOAT : [EOL] byte_string = [string] . join ( [ x . to_bytes ( [number] , byteorder = [string] ) for x in registers ] ) [EOL] val = struct . unpack ( [string] , byte_string ) [ [number] ] [EOL] elif self . _data_type == DATA_TYPE_INT : [EOL] for _ , res in enumerate ( registers ) : [EOL] val += twos_comp ( res , [number] ) [EOL] self . _value = format ( self . _scale * val + self . _offset , [string] . format ( self . _precision ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from duco . const import ( DUCO_REG_ADDR_NODE_ID_OFFSET ) [EOL] [EOL] [EOL] def verify_value_in_range ( value , range_start , range_step , range_stop ) : [EOL] [docstring] [EOL] if value not in range ( range_start , range_stop + range_step , range_step ) : [EOL] raise ValueError ( [string] . format ( range_start , range_stop , range_step ) ) [EOL] [EOL] [EOL] def to_register_addr ( node_id , param_id ) : [EOL] [docstring] [EOL] return node_id * DUCO_REG_ADDR_NODE_ID_OFFSET + param_id [EOL] [EOL] [EOL] def twos_comp ( val , bits ) : [EOL] [docstring] [EOL] if ( val & ( [number] << ( bits - [number] ) ) ) != [number] : [comment] [EOL] val = val - ( [number] << bits ) [comment] [EOL] return val [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from enum import IntEnum , unique [EOL] from duco . const import ( DUCO_MODULE_TYPE_MASTER , DUCO_MODULE_TYPE_VALVE_SENSORLESS , DUCO_MODULE_TYPE_VALVE_CO2 , DUCO_MODULE_TYPE_VALVE_RH , DUCO_MODULE_TYPE_USER_CONTROLLER , DUCO_MODULE_TYPE_ROOM_SENSOR_CO2 , DUCO_MODULE_TYPE_ROOM_SENSOR_RH , DUCO_MODULE_TYPE_CTRL_WINDOW_VENT , DUCO_MODULE_TYPE_ROOM_SWITCH , DUCO_MODULE_TYPE_ACTUATOR_PRINT , DUCO_ZONE_STATUS_AUTO , DUCO_ZONE_STATUS_HIGH_10MIN , DUCO_ZONE_STATUS_HIGH_20MIN , DUCO_ZONE_STATUS_HIGH_30MIN , DUCO_ZONE_STATUS_MANUAL_LOW , DUCO_ZONE_STATUS_MANUAL_MEDIUM , DUCO_ZONE_STATUS_MANUAL_HIGH , DUCO_ZONE_STATUS_AWAY , DUCO_ZONE_STATUS_ERROR , DUCO_ACTION_NODE_VISIBILITY_OFF , DUCO_ACTION_NODE_VISIBILITY_ON , DUCO_ACTION_ZONE_TO_MANUAL_1 , DUCO_ACTION_ZONE_TO_MANUAL_2 , DUCO_ACTION_ZONE_TO_MANUAL_3 , DUCO_ACTION_ZONE_TO_AUTO , DUCO_ACTION_AWAY ) [EOL] [EOL] [EOL] @ unique class ModuleType ( IntEnum ) : [EOL] [docstring] [EOL] [EOL] MASTER = DUCO_MODULE_TYPE_MASTER [EOL] VALVE_SENSORLESS = DUCO_MODULE_TYPE_VALVE_SENSORLESS [EOL] VALVE_CO2 = DUCO_MODULE_TYPE_VALVE_CO2 [EOL] VALVE_RH = DUCO_MODULE_TYPE_VALVE_RH [EOL] USER_CONTROLLER = DUCO_MODULE_TYPE_USER_CONTROLLER [EOL] ROOM_SENSOR_CO2 = DUCO_MODULE_TYPE_ROOM_SENSOR_CO2 [EOL] ROOM_SENSOR_RH = DUCO_MODULE_TYPE_ROOM_SENSOR_RH [EOL] CTRL_WINDOW_VENT = DUCO_MODULE_TYPE_CTRL_WINDOW_VENT [EOL] ROOM_SWITCH = DUCO_MODULE_TYPE_ROOM_SWITCH [EOL] ACTUATOR_PRINT = DUCO_MODULE_TYPE_ACTUATOR_PRINT [EOL] [EOL] @ classmethod def supported ( cls , value ) : [EOL] [docstring] [EOL] return any ( value == item . value for item in cls ) [EOL] [EOL] [EOL] @ unique class ZoneStatus ( IntEnum ) : [EOL] [docstring] [EOL] [EOL] AUTO = DUCO_ZONE_STATUS_AUTO [EOL] HIGH_10MIN = DUCO_ZONE_STATUS_HIGH_10MIN [EOL] HIGH_20MIN = DUCO_ZONE_STATUS_HIGH_20MIN [EOL] HIGH_30MIN = DUCO_ZONE_STATUS_HIGH_30MIN [EOL] MANUAL_LOW = DUCO_ZONE_STATUS_MANUAL_LOW [EOL] MANUAL_MEDIUM = DUCO_ZONE_STATUS_MANUAL_MEDIUM [EOL] MANUAL_HIGH = DUCO_ZONE_STATUS_MANUAL_HIGH [EOL] AWAY = DUCO_ZONE_STATUS_AWAY [EOL] ERROR = DUCO_ZONE_STATUS_ERROR [EOL] [EOL] [EOL] @ unique class ZoneAction ( IntEnum ) : [EOL] [docstring] [EOL] [EOL] NODE_VISIBILITY_OFF = DUCO_ACTION_NODE_VISIBILITY_OFF [EOL] NODE_VISIBILITY_ON = DUCO_ACTION_NODE_VISIBILITY_ON [EOL] ZONE_TO_MANUAL_1 = DUCO_ACTION_ZONE_TO_MANUAL_1 [EOL] ZONE_TO_MANUAL_2 = DUCO_ACTION_ZONE_TO_MANUAL_2 [EOL] ZONE_TO_MANUAL_3 = DUCO_ACTION_ZONE_TO_MANUAL_3 [EOL] ZONE_TO_AUTO = DUCO_ACTION_ZONE_TO_AUTO [EOL] AWAY = DUCO_ACTION_AWAY [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0