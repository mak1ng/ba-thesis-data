[comment] [EOL] from typing import List , Any [EOL] import lab1 [EOL] import typing [EOL] import os [EOL] from collections import Counter [EOL] from lab1 import processor [EOL] [EOL] def ex1 ( ) : [comment] [EOL] resource_path = [string] [EOL] result = [ ] [EOL] for filename in os . listdir ( resource_path ) : [EOL] sp = processor . StatuteProcessor ( resource_path + [string] + filename ) [EOL] result . append ( sp . get_external_references ( ) ) [EOL] return Counter ( processor . shp . flatten ( result ) ) [EOL] [EOL] def ex2 ( ) : [EOL] resource_path = [string] [EOL] result = [ ] [EOL] for filename in os . listdir ( resource_path ) : [EOL] print ( filename ) [EOL] sp = processor . StatuteProcessor ( resource_path + [string] + filename ) [EOL] references = sp . get_internal_references ( ) . most_common ( [number] ) [EOL] result . append ( ( filename , references ) ) [EOL] return result [EOL] [EOL] def ex3 ( ) : [comment] [EOL] resource_path = [string] [EOL] count = [number] [EOL] for filename in os . listdir ( resource_path ) : [EOL] sp = processor . StatuteProcessor ( resource_path + [string] + filename ) [EOL] count += sp . get_ustawa_count ( ) [EOL] return count [EOL] [EOL] [comment] [EOL] ex1 ( ) . most_common ( ) [EOL] [EOL] [comment] [EOL] ex2 ( ) [EOL] [EOL] [comment] [EOL] ex3 ( ) [EOL] [EOL] [comment] [EOL] resource_path = [string] [EOL] filename = [string] [EOL] sp = processor . StatuteProcessor ( resource_path + [string] + filename ) [EOL] title = sp . get_statue_title ( ) [EOL] references = sp . get_internal_references ( ) [EOL] references . most_common ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $lab1.processor.StatuteProcessor$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $lab1.processor.StatuteProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $lab1.processor.StatuteProcessor$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $lab1.processor.StatuteProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $lab1.processor.StatuteProcessor$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $lab1.processor.StatuteProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $lab1.processor.StatuteProcessor$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $lab1.processor.StatuteProcessor$ 0 0 0 0 0 $typing.Any$ 0 $lab1.processor.StatuteProcessor$ 0 0 0 0 0 $typing.Any$ 0 0 0 0
[comment] [EOL] from typing import List , Tuple , Match , Optional , Any [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from typing import List , Tuple , Optional , Match , Any [EOL] from collections import Counter [EOL] from lab1 import patterns as pts [EOL] from lab1 import shapers as shp [EOL] from lab1 import splitters as splt [EOL] [EOL] [comment] [EOL] class StatuteProcessor ( ) : [EOL] def __init__ ( self , statue_path ) : [EOL] self . statue_path = statue_path [EOL] self . statue_lines = self . read_statue_lines ( ) [EOL] self . statue = self . read_statue ( ) [EOL] [EOL] def read_statue_lines ( self ) : [EOL] with open ( self . statue_path , [string] ) as document : [EOL] return document . readlines ( ) [EOL] [EOL] def read_statue ( self ) : [EOL] with open ( self . statue_path , [string] ) as document : [EOL] return document . read ( ) [EOL] [EOL] def get_statue_title ( self ) : [EOL] dt = re . search ( pts . date_title ( ) , self . statue ) [EOL] if dt : [EOL] return [string] . join ( [ e for e in re . sub ( [string] , [string] , dt . group ( [number] ) ) . split ( [string] ) if e != [string] ] ) [EOL] return [string] [EOL] [EOL] def get_external_references ( self ) : [EOL] is_match , text_match , trimmed = splt . match_and_trim ( self . statue , pts . journal ( ) ) [EOL] references = [ ] [EOL] is_match = True [comment] [EOL] while (is_match) : [EOL] is_match , text_match , trimmed = splt . match_and_trim ( trimmed , pts . external_reference ( ) ) [EOL] if not is_match : [EOL] is_match , text_match , trimmed = splt . match_and_trim ( trimmed , pts . external_reference_ketless ( ) ) [EOL] if not is_match : [EOL] break [EOL] [EOL] text = splt . clean_external ( text_match ) [EOL] by_year = splt . split_year ( text ) [EOL] for year in by_year : [EOL] by_nr = splt . split_nr ( year [ [number] ] ) [EOL] for nr in by_nr : [EOL] pos = splt . split_pos ( nr [ [number] ] ) [EOL] y = year [ [number] ] [EOL] n = nr [ [number] ] [EOL] if not re . match ( [string] , y ) : [EOL] y = [string] [EOL] if not re . match ( [string] , n ) : [EOL] n = [string] [EOL] references . append ( ( y , n , pos ) ) [EOL] [EOL] return shp . flatten ( list ( map ( shp . flatten_references , references ) ) ) [EOL] [EOL] def get_internal_references ( self ) : [EOL] references = [ ] [EOL] sections = splt . split_section ( self . statue , len ( self . statue ) ) [EOL] for section_id , section_span in enumerate ( sections , [number] ) : [EOL] section_text = self . statue [ section_span [ [number] ] : section_span [ [number] ] ] [EOL] paragraphs = splt . split_paragraph ( section_text , len ( section_text ) ) [EOL] for paragraph_id , paragraph_span in enumerate ( paragraphs , [number] ) : [EOL] paragraph_text = section_text [ paragraph_span [ [number] ] : paragraph_span [ [number] ] ] [EOL] for i , p in enumerate ( pts . internal_pattern_order ( ) ) : [EOL] matches = re . findall ( p , paragraph_text ) [EOL] if matches : [EOL] tmp = [ ] [EOL] for m in matches : [EOL] if i == [number] : [EOL] tmp . append ( shp . internal_ref ( m [ [number] ] , m [ [number] ] , m [ [number] ] ) ) [EOL] if i == [number] : [EOL] tmp . append ( shp . internal_ref ( m [ [number] ] , paragraph_id , m [ [number] ] ) ) [EOL] if i == [number] : [EOL] tmp . append ( shp . internal_ref ( m [ [number] ] , m [ [number] ] , [string] ) ) [EOL] if i == [number] : [EOL] tmp . append ( shp . internal_ref ( section_id , m [ [number] ] , [string] ) ) [EOL] references . append ( tmp ) [EOL] paragraph_text = re . sub ( p , [string] , paragraph_text ) [EOL] [EOL] return Counter ( shp . flatten ( references ) ) [EOL] [EOL] def get_ustawa_count ( self ) : [EOL] base = [string] [EOL] wb = [string] [EOL] suffix = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] forms = [ wb + base + suf + wb for suf in suffix ] [EOL] count = [number] [EOL] for line in self . statue_lines : [EOL] count += sum ( len ( re . findall ( f , line . lower ( ) ) ) for f in forms ) [EOL] return count [EOL] [EOL] def test_any_pattern ( self , pattern ) : [EOL] x = re . search ( pattern , self . statue ) [EOL] return x [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from typing import List [EOL] [EOL] def journal ( ) : [EOL] return [string] [EOL] [EOL] def date_title ( ) : [EOL] return [string] [EOL] [EOL] def register ( ) : [EOL] base = [string] [EOL] title = [string] [EOL] ref = [string] [EOL] return base + title + ref [EOL] [EOL] def section ( ) : [EOL] return [string] [EOL] [EOL] def paragraph ( ) : [EOL] return [string] [EOL] [EOL] def point ( ) : [EOL] return [string] [EOL] [EOL] def external_reference ( ) : [EOL] return [string] [EOL] [EOL] def external_reference_ketless ( ) : [EOL] return [string] [EOL] [EOL] def internal_section_paragraph_point ( ) : [EOL] s = [string] [EOL] p = [string] [EOL] pt = [string] [EOL] return s + p + pt [EOL] [EOL] def internal_section_point ( ) : [EOL] return [string] [EOL] [EOL] def internal_section_paragraph ( ) : [EOL] return [string] [EOL] [EOL] def internal_paragraph ( ) : [EOL] return [string] [EOL] [EOL] def internal_pattern_order ( ) : [EOL] return [ internal_section_paragraph_point ( ) , internal_section_point ( ) , internal_section_paragraph ( ) , internal_paragraph ( ) ] [EOL] [EOL] def changed_statute ( ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Tuple , Match , Optional [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from lab1 import shapers [EOL] from lab1 import patterns [EOL] from typing import List , Tuple , Any [EOL] [EOL] def clean_external ( txt ) : [EOL] txt = txt . replace ( [string] , [string] ) [EOL] txt = re . sub ( [string] , [string] , txt ) [EOL] txt = txt . replace ( [string] , [string] ) [EOL] txt = re . sub ( [string] , [string] , txt ) [EOL] txt = re . sub ( [string] , [string] , txt ) [EOL] txt = re . sub ( [string] , [string] , txt ) [EOL] txt = re . sub ( [string] , [string] , txt ) [EOL] txt = txt . replace ( [string] , [string] ) [EOL] txt = re . sub ( [string] , [string] , txt ) [EOL] splitted = [ x for x in txt . split ( [string] ) if ( re . match ( [string] , x ) or x == [string] ) ] [EOL] txt = [string] . join ( splitted ) [EOL] return [string] + txt if re . match ( [string] , txt ) else txt [EOL] [EOL] def split_year ( txt ) : [EOL] r = [ x for x in re . split ( [string] , txt ) if len ( x ) > [number] ] [EOL] return shapers . pairs ( r ) [EOL] [EOL] def split_nr ( txt ) : [EOL] r = [ x for x in re . split ( [string] , txt ) if len ( x ) and x != [string] ] [EOL] return shapers . pairs ( r ) [EOL] [EOL] def split_pos ( txt ) : [EOL] txt = txt . replace ( [string] , [string] ) [EOL] return [ x . replace ( [string] , [string] ) for x in re . split ( [string] , txt ) if len ( x ) and x != [string] ] [EOL] [EOL] def match_and_trim ( txt , pattern ) : [EOL] match = re . search ( pattern , txt ) [EOL] return ( True , match . group ( [number] ) , txt [ match . span ( ) [ [number] ] : ] ) if match else ( False , [string] , txt ) [EOL] [EOL] def index_split_by ( txt , pattern , parent_size ) : [EOL] split = [ m . span ( ) for m in re . finditer ( pattern , txt ) ] [EOL] if not split : [EOL] return [ ( [number] , len ( txt ) ) ] [EOL] last_index = split [ len ( split ) - [number] ] [ [number] ] [EOL] result = [ ( split [ i ] [ [number] ] , split [ i + [number] ] [ [number] ] ) for i in range ( [number] , len ( split ) - [number] ) ] [EOL] result . append ( ( last_index , parent_size ) ) [EOL] return result [EOL] [EOL] def split_section ( txt , parent_size ) : [EOL] return index_split_by ( txt , patterns . section ( ) , parent_size ) [EOL] [EOL] def split_paragraph ( txt , parent_size ) : [EOL] return index_split_by ( txt , patterns . paragraph ( ) , parent_size ) [EOL] [EOL] def split_point ( txt , parent_size ) : [EOL] return index_split_by ( txt , patterns . point ( ) , parent_size )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.bool,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type , List , Tuple [EOL] import lab1 [EOL] import typing [EOL] import builtins [EOL] import itertools [EOL] from collections import namedtuple [EOL] from typing import List , Tuple [EOL] [EOL] def flatten ( listOfLists ) : [EOL] return list ( itertools . chain . from_iterable ( listOfLists ) ) [EOL] [EOL] def flatten_references ( ref ) : [EOL] year = ref [ [number] ] [EOL] nr = ref [ [number] ] [EOL] return [ ( year , nr , pos ) for pos in ref [ [number] ] ] [EOL] [EOL] def pairs ( list ) : [EOL] size = len ( list ) [EOL] return [ ( list [ i ] , list [ ( i + [number] ) % size ] ) for i in range ( [number] , len ( list ) , [number] ) ] [EOL] [EOL] internal_ref = namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[lab1.shapers.internal_ref]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0