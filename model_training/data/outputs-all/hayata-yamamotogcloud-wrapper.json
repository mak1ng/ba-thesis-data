	0
from typing import Optional , Union , Any [EOL] import google [EOL] import typing [EOL] import pathlib [EOL] import builtins [EOL] from pathlib import Path [EOL] from typing import Union , Optional [EOL] [EOL] from google . cloud . storage import Client , Blob [EOL] from google . oauth2 . service_account import Credentials [EOL] [EOL] [EOL] def _get_client ( project , credential = None ) : [EOL] [docstring] [EOL] if credential is None : [EOL] return Client ( project = project ) [EOL] [EOL] credential = Credentials . from_service_account_file ( filename = credential ) [EOL] return Client ( project = project , credentials = credential ) [EOL] [EOL] [EOL] def upload_from_filename ( filename , project , bucket , blob , credential = None , content_type = None ) : [EOL] [docstring] [EOL] client = _get_client ( project = project , credential = credential ) [EOL] [EOL] bkt = client . get_bucket ( bucket_name = bucket ) [EOL] [EOL] bl = bkt . blob ( blob_name = blob ) [EOL] bl . upload_from_filename ( filename = filename , content_type = content_type ) [EOL] [EOL] return bl . public_url [EOL] [EOL] [EOL] def download_from_blob ( filename , project , bucket , blob , credential = None ) : [EOL] [docstring] [EOL] client = _get_client ( project = project , credential = credential ) [EOL] bkt = client . bucket ( bucket_name = bucket ) [EOL] bkt . blob ( blob_name = blob ) . download_to_filename ( filename = filename ) [EOL] [EOL] [EOL] class CloudStorage : [EOL] def __init__ ( self , project , bucket , credential = None ) : [EOL] [docstring] [EOL] self . client = _get_client ( project , credential = credential ) [EOL] self . bucket = self . client . bucket ( bucket_name = bucket ) [EOL] [EOL] def bucket_exist ( self ) : [EOL] [docstring] [EOL] return self . bucket . exists ( ) [EOL] [EOL] def get_blob_list ( self ) : [EOL] [docstring] [EOL] return [ b for b in self . bucket . list_blobs ( ) ] [EOL] [EOL] def get_blob_url ( self , blob ) : [EOL] [docstring] [EOL] return self . bucket . blob ( blob_name = blob ) . public_url [EOL] [EOL] def upload_from_filename ( self , filename , blob , content_type = None ) : [EOL] [docstring] [EOL] bl = self . bucket . blob ( blob_name = blob ) [EOL] bl . upload_from_filename ( filename = filename , content_type = content_type , client = self . client ) [EOL] return bl . public_url [EOL] [EOL] def download_from_blob ( self , filename , blob ) : [EOL] [docstring] [EOL] self . bucket . blob ( blob_name = blob ) . download_to_filename ( filename = filename ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Union[builtins.str,pathlib.Path]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Union[builtins.str,pathlib.Path]]$ 0 $typing.Optional[typing.Union[builtins.str,pathlib.Path]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[builtins.str,pathlib.Path]$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Union[builtins.str,pathlib.Path]$ 0 $typing.Union[builtins.str,pathlib.Path]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0
from typing import Optional , Union , Any , NoReturn [EOL] import google [EOL] import typing [EOL] import pathlib [EOL] import builtins [EOL] from pathlib import Path [EOL] from typing import Optional , NoReturn , Union [EOL] [EOL] from google . cloud . texttospeech import TextToSpeechClient , enums , types [EOL] [EOL] [EOL] class TextToSpeech : [EOL] def __init__ ( self , credential = None ) : [EOL] if credential is None : [EOL] self . client = TextToSpeechClient ( ) [EOL] else : [EOL] self . client = TextToSpeechClient . from_service_account_file ( filename = credential ) [EOL] [EOL] def synthesize ( self , text , language = [string] , gender = [number] , encoding = enums . AudioEncoding . MP3 ) : [EOL] [docstring] [EOL] if gender == [number] : [EOL] ssml_gender = enums . SsmlVoiceGender . FEMALE [EOL] elif gender == [number] : [EOL] ssml_gender = enums . SsmlVoiceGender . MALE [EOL] else : [EOL] ssml_gender = enums . SsmlVoiceGender . NEUTRAL [EOL] [EOL] synthesis_data = types . SynthesisInput ( text = text ) [EOL] voice = types . VoiceSelectionParams ( language_code = language , ssml_gender = ssml_gender ) [EOL] audio_config = types . AudioConfig ( audio_encoding = encoding ) [EOL] [EOL] return self . client . synthesize_speech ( input_ = synthesis_data , voice = voice , audio_config = audio_config ) [EOL] [EOL] @ staticmethod def save ( response , filename ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as audio_file : [EOL] audio_file . write ( response . audio_content )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Union , Any [EOL] import google [EOL] import typing [EOL] import pathlib [EOL] import builtins [EOL] from pathlib import Path [EOL] from typing import Union , Optional [EOL] [EOL] from google . cloud import bigquery [EOL] from google . oauth2 . service_account import Credentials [EOL] [EOL] [EOL] def load_from_cloud_storage_uri ( source_uri , project , dataset , table , credential = None , auto_detect = True , skip_leading_rows = [number] ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] credentials = Credentials . from_service_account_file ( filename = credential ) [EOL] client = bigquery . Client ( project = project , credentials = credentials ) [EOL] dataset_ref = client . dataset ( dataset_id = dataset ) [EOL] [EOL] job_config = bigquery . LoadJobConfig ( ) [EOL] job_config . autodetect = auto_detect [EOL] job_config . skip_leading_rows = skip_leading_rows [EOL] [EOL] [comment] [EOL] load_job = client . load_table_from_uri ( source_uris = source_uri , destination = dataset_ref . table ( table ) , job_config = job_config ) [EOL] [EOL] return load_job . result ( ) [EOL] [EOL] [EOL] class BigQuery : [EOL] def __init__ ( self , project , dataset , credential = None ) : [EOL] [docstring] [EOL] credentials = Credentials . from_service_account_file ( filename = credential ) [EOL] self . client = bigquery . Client ( project = project , credentials = credentials ) [EOL] self . dataset_ref = self . client . dataset ( dataset_id = dataset ) [EOL] self . dataset = bigquery . Dataset ( dataset_ref = self . dataset_ref ) [EOL] [EOL] def create_table_from_gcs_uri ( self , table , uri , ** kwargs ) : [EOL] [docstring] [EOL] conf = bigquery . LoadJobConfig ( ** kwargs ) [EOL] [EOL] return self . client . load_table_from_uri ( source_uris = uri , destination = self . dataset_ref . table ( table ) , job_config = conf ) . result ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $google.cloud.bigquery.LoadJob$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Union[builtins.str,pathlib.Path]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.str,pathlib.Path]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $google.cloud.bigquery.LoadJob$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Optional , Mapping , Any , Tuple , List , Union , Sequence , Dict [EOL] import google [EOL] import typing [EOL] import pathlib [EOL] import builtins [EOL] import json [EOL] from pathlib import Path [EOL] from typing import Optional , Sequence , Tuple , Union , Dict , List , Mapping [EOL] [EOL] from google . api_core . retry import Retry [EOL] from google . cloud . language import LanguageServiceClient , types , enums [EOL] from google . protobuf . json_format import MessageToJson [EOL] [EOL] [EOL] class CloudLanguage : [EOL] def __init__ ( self , credentials = None ) : [EOL] if credentials is None : [EOL] self . client = LanguageServiceClient ( ) [EOL] else : [EOL] self . client = LanguageServiceClient . from_service_account_file ( filename = credentials ) [EOL] [EOL] def annotate_text_from_string ( self , content , encoding_type = enums . EncodingType . UTF32 , retry = None , timeout = None , metadata = None , language = [string] , document_type = enums . Document . Type . PLAIN_TEXT , syntax = True , entities = True , document_sentiment = True , entity_sentiment = True , classify = True ) : [EOL] [docstring] [EOL] [EOL] features = { [string] : syntax , [string] : entities , [string] : document_sentiment , [string] : entity_sentiment , [string] : classify } [EOL] [EOL] document = types . Document ( content = content , language = language , type = document_type ) [EOL] response = self . client . annotate_text ( document = document , features = features , encoding_type = encoding_type , retry = retry , timeout = timeout , metadata = metadata ) [EOL] return json . loads ( MessageToJson ( response ) ) [EOL] [EOL] @ staticmethod def parse ( response ) : [EOL] results = CloudLanguage . parse_sentences ( response ) [EOL] results . update ( CloudLanguage . parse_tokens ( response ) ) [EOL] results . update ( CloudLanguage . parse_document_sentiment ( response ) ) [EOL] results . update ( CloudLanguage . parse_entity ( response ) ) [EOL] results . update ( CloudLanguage . parse_categories ( response ) ) [EOL] results . update ( { [string] : response [ [string] ] } ) [EOL] return results [EOL] [EOL] @ staticmethod def parse_sentences ( response ) : [EOL] [EOL] results = { [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] } [EOL] for sentence in response [ [string] ] : [EOL] try : [EOL] results [ [string] ] . append ( sentence [ [string] ] [ [string] ] ) [EOL] except KeyError : [EOL] results [ [string] ] . append ( None ) [EOL] [EOL] results [ [string] ] . append ( sentence [ [string] ] [ [string] ] ) [EOL] results [ [string] ] . append ( sentence [ [string] ] [ [string] ] ) [EOL] results [ [string] ] . append ( sentence [ [string] ] [ [string] ] ) [EOL] [EOL] return results [EOL] [EOL] @ staticmethod def parse_tokens ( response ) : [EOL] results = { [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] } [EOL] [EOL] for token in response [ [string] ] : [EOL] try : [EOL] results [ [string] ] . append ( token [ [string] ] [ [string] ] ) [EOL] except KeyError : [EOL] results [ [string] ] . append ( None ) [EOL] [EOL] try : [EOL] results [ [string] ] . append ( token [ [string] ] [ [string] ] ) [EOL] except KeyError : [EOL] results [ [string] ] . append ( None ) [EOL] [EOL] results [ [string] ] . append ( token [ [string] ] [ [string] ] ) [EOL] results [ [string] ] . append ( token [ [string] ] [ [string] ] ) [EOL] results [ [string] ] . append ( token [ [string] ] [ [string] ] ) [EOL] results [ [string] ] . append ( token [ [string] ] [ [string] ] ) [EOL] results [ [string] ] . append ( token [ [string] ] ) [EOL] [EOL] return results [EOL] [EOL] @ staticmethod def parse_entity ( response ) : [EOL] [EOL] results = { [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] } [EOL] [EOL] for entity in response [ [string] ] : [EOL] results [ [string] ] . append ( entity [ [string] ] ) [EOL] results [ [string] ] . append ( entity [ [string] ] ) [EOL] results [ [string] ] . append ( entity [ [string] ] ) [EOL] for mention in entity [ [string] ] : [EOL] try : [EOL] results [ [string] ] . append ( mention [ [string] ] [ [string] ] ) [EOL] except KeyError : [EOL] results [ [string] ] . append ( None ) [EOL] [EOL] try : [EOL] results [ [string] ] . append ( mention [ [string] ] [ [string] ] ) [EOL] except KeyError : [EOL] results [ [string] ] . append ( None ) [EOL] [EOL] try : [EOL] results [ [string] ] . append ( mention [ [string] ] [ [string] ] ) [EOL] except KeyError : [EOL] results [ [string] ] . append ( None ) [EOL] [EOL] results [ [string] ] . append ( mention [ [string] ] [ [string] ] ) [EOL] results [ [string] ] . append ( mention [ [string] ] ) [EOL] [EOL] return results [EOL] [EOL] @ staticmethod def parse_document_sentiment ( response ) : [EOL] [EOL] results = { [string] : response [ [string] ] [ [string] ] , [string] : response [ [string] ] [ [string] ] } [EOL] return results [EOL] [EOL] @ staticmethod def parse_categories ( response ) : [EOL] results = { [string] : [ ] , [string] : [ ] } [EOL] for category in response [ [string] ] : [EOL] results [ [string] ] . append ( category [ [string] ] ) [EOL] results [ [string] ] . append ( category [ [string] ] ) [EOL] [EOL] return results	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[builtins.str,builtins.float]]]$ 0 $typing.Dict$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Mapping[builtins.str,typing.List[typing.Union[builtins.str,builtins.float]]]$ 0 $typing.Dict$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Mapping[builtins.str,typing.List[typing.Union[builtins.str,builtins.float]]]$ 0 $typing.Dict$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 $typing.Dict$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict$ 0 $typing.Dict$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$
from typing import Union , Any , List [EOL] import google [EOL] import os [EOL] import typing [EOL] import builtins [EOL] import io [EOL] import os [EOL] from typing import Union [EOL] [EOL] from google . api_core import exceptions [EOL] from google . cloud . speech import SpeechClient , enums , types [EOL] from google . oauth2 . service_account import Credentials [EOL] [EOL] [EOL] def parse_response ( response ) : [EOL] [docstring] [EOL] transcript = [ ] [EOL] confidence = [ ] [EOL] for result in response . results : [EOL] for alternative in result . alternatives : [EOL] transcript . append ( alternative . transcript ) [EOL] confidence . append ( alternative . confidence ) [EOL] return transcript , confidence [EOL] [EOL] [EOL] def recognize_audio_from_uri ( uri , credential = None , language_code = [string] , encoding = enums . RecognitionConfig . AudioEncoding . FLAC , sampling_rate_hertz = [number] , ) : [EOL] [docstring] [EOL] if credential is None : [EOL] client = SpeechClient ( ) [EOL] else : [EOL] credentials = Credentials . from_service_account_file ( filename = credential ) [EOL] client = SpeechClient ( credentials = credentials ) [EOL] [EOL] config = types . RecognitionConfig ( encoding = encoding , language_code = language_code , sample_rate_hertz = sampling_rate_hertz ) [EOL] audio = types . RecognitionAudio ( uri = uri ) [EOL] [EOL] try : [EOL] result = client . recognize ( config = config , audio = audio ) [EOL] except exceptions . InvalidArgument : [EOL] print ( [string] ) [EOL] operartion = client . long_running_recognize ( config = config , audio = audio ) [EOL] result = operartion . result ( ) [EOL] return result [EOL] [EOL] [EOL] def recognize_audio_from_file ( file , credential = None , language_code = [string] , encoding = enums . RecognitionConfig . AudioEncoding . FLAC , sampling_rate_hertz = [number] , ) : [EOL] [docstring] [EOL] if credential is None : [EOL] client = SpeechClient ( ) [EOL] else : [EOL] credentials = Credentials . from_service_account_file ( filename = credential ) [EOL] client = SpeechClient ( credentials = credentials ) [EOL] [EOL] config = types . RecognitionConfig ( encoding = encoding , language_code = language_code , sampling_rate_hertz = sampling_rate_hertz ) [EOL] with io . open ( file , [string] ) as audio : [EOL] content = audio . read ( ) [EOL] audio = types . RecognitionAudio ( content = content ) [EOL] [EOL] return client . recognize ( config , audio ) [EOL] [EOL] [EOL] class SpeechToText : [EOL] def __init__ ( self , credential = None ) : [EOL] [docstring] [EOL] if credential is None : [EOL] self . client = SpeechClient ( ) [EOL] else : [EOL] credentials = Credentials . from_service_account_file ( filename = credential ) [EOL] self . client = SpeechClient ( credentials = credentials ) [EOL] [EOL] def recognize_from_uri ( self , uri , encoding = enums . RecognitionConfig . AudioEncoding . FLAC , language_code = [string] , sampling_rate_hertz = [number] ) : [EOL] [docstring] [EOL] config = types . RecognitionConfig ( encoding = encoding , language_code = language_code , sampling_rate_hertz = sampling_rate_hertz ) [EOL] audio = types . RecognitionAudio ( uri = uri ) [EOL] [EOL] return self . client . recognize ( config , audio ) [EOL] [EOL] def recognize_from_file ( self , file , encoding = enums . RecognitionConfig . AudioEncoding . FLAC , language_code = [string] , sampling_rate_hertz = [number] ) : [EOL] [docstring] [EOL] config = types . RecognitionConfig ( encoding = encoding , language_code = language_code , sampling_rate_hertz = sampling_rate_hertz ) [EOL] with io . open ( file , [string] ) as audio : [EOL] content = audio . read ( ) [EOL] audio = types . RecognitionAudio ( content = content ) [EOL] return self . client . recognize ( config , audio ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0