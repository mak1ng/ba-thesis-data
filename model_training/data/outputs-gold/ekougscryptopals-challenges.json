[comment] [EOL] from typing import List , Any , Optional , Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import List , Optional [EOL] [EOL] from set1 . single_byte_xor_decipher import single_byte_decipher , NoPossibleKeyError [EOL] [EOL] [EOL] def detect_single_byte_cypher ( hex_phrases ) : [EOL] phrases_scores = [ ] [EOL] for hex_phrase in hex_phrases : [EOL] try : [EOL] decipher = single_byte_decipher ( hex_phrase ) [EOL] phrases_scores . append ( decipher ) [EOL] except NoPossibleKeyError : [EOL] continue [EOL] return list ( map ( lambda phrase_score : phrase_score [ [number] ] , sorted ( phrases_scores , key = lambda phrase_score : phrase_score [ [number] ] ) ) ) [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] import builtins [EOL] import binascii [EOL] from typing import List [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] FREQUENT_CHARS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] FREQUENT_CHARS_HEX = [ format ( ord ( char ) , [string] ) for char in FREQUENT_CHARS ] [EOL] [EOL] HEX_TO_BIN_DICT = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] BIN_TO_HEX_DICT = { } [EOL] for hex_str , bits in HEX_TO_BIN_DICT . items ( ) : [EOL] BIN_TO_HEX_DICT [ bits ] = hex_str [EOL] [EOL] [EOL] def convert_ascii_to_hex ( chars ) : [EOL] return str ( binascii . hexlify ( chars . encode ( [string] ) ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Callable [EOL] import typing [EOL] import builtins [EOL] from typing import Callable [EOL] [EOL] from set1 import convert_ascii_to_hex [EOL] from set1 . fixed_xor import fixed_xor [EOL] [EOL] [EOL] def xor_ascii_with_repeating_key ( ascii_phrase , hex_key ) : [EOL] return _xor_with_repeating_key ( ascii_phrase , hex_key , lambda phrase : len ( phrase ) * [number] , lambda hex_length_to_xor : int ( hex_length_to_xor / [number] ) , lambda phrase_portion : convert_ascii_to_hex ( phrase_portion ) ) [EOL] [EOL] [EOL] def xor_hex_with_repeating_key ( hex_phrase , hex_key ) : [EOL] return _xor_with_repeating_key ( hex_phrase , hex_key , lambda phrase : len ( phrase ) , lambda hex_length_to_xor : hex_length_to_xor ) [EOL] [EOL] [EOL] def _xor_with_repeating_key ( phrase , hex_key , remaining_phrase_len_fn , phrase_len_to_xor_fn , optional_conversion_fn = None ) : [EOL] xored_phrase_hex = [string] [EOL] key_length = len ( hex_key ) [EOL] [comment] [EOL] while phrase : [EOL] hex_length_to_xor = min ( [ remaining_phrase_len_fn ( phrase ) , key_length ] ) [EOL] char_length_to_xor = phrase_len_to_xor_fn ( hex_length_to_xor ) [EOL] converted_phrase = optional_conversion_fn ( phrase [ : char_length_to_xor ] ) if optional_conversion_fn else phrase [ : char_length_to_xor ] [EOL] xored_phrase_hex += fixed_xor ( converted_phrase , hex_key [ : hex_length_to_xor ] ) [EOL] phrase = phrase [ char_length_to_xor : ] if char_length_to_xor < len ( phrase ) else [string] [EOL] return xored_phrase_hex [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Dict , Tuple [EOL] import typing [EOL] import builtins [EOL] import sys [EOL] from typing import Tuple , Dict , List [EOL] [EOL] from set1 . fixed_xor import fixed_xor [EOL] from set1 . repeating_key_xor import xor_hex_with_repeating_key [EOL] [EOL] [EOL] def single_byte_decipher ( hex_str ) : [EOL] bytes_length = len ( hex_str ) / [number] [EOL] [EOL] encrypted_char_frequencies = _get_chars_occurrences ( hex_str ) [EOL] [EOL] min_score = sys . maxsize [EOL] potential_hex_key = [string] [EOL] for dec_key in range ( [number] ) : [EOL] hex_key = [string] . format ( dec_key ) [EOL] score = _get_chi2 ( encrypted_char_frequencies , bytes_length , dec_key ) [EOL] if min_score > score : [EOL] min_score = score [EOL] potential_hex_key = hex_key [EOL] [EOL] if not potential_hex_key : [EOL] raise NoPossibleKeyError ( ) [EOL] [EOL] return bytearray . fromhex ( xor_hex_with_repeating_key ( hex_str , potential_hex_key ) ) . decode ( ) , bytearray . fromhex ( potential_hex_key ) . decode ( ) , min_score [EOL] [EOL] [EOL] class NoPossibleKeyError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def _get_chars_occurrences ( hex_str ) : [EOL] [comment] [EOL] [comment] [EOL] chars_occurrences = { } [EOL] [EOL] [comment] [EOL] for char_hex_part_1 , char_hex_part_2 in zip ( hex_str [ [number] : : [number] ] , hex_str [ [number] : : [number] ] ) : [EOL] cur_char = int ( char_hex_part_1 + char_hex_part_2 , [number] ) [EOL] if cur_char not in chars_occurrences : [EOL] chars_occurrences [ cur_char ] = [number] [EOL] chars_occurrences [ cur_char ] += [number] [EOL] [EOL] [comment] [EOL] return chars_occurrences [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def _get_chi2 ( str_char_occurrences , str_len , key ) : [EOL] [comment] [EOL] if any ( ( c not in _printable_ascii_dec_encrypted_codes [ key ] for c in str_char_occurrences ) ) : [EOL] return sys . maxsize [EOL] [EOL] chi2 = [number] [EOL] [EOL] cur_letters_ascii_encrypted_dec_codes = _letters_ascii_encrypted_dec_codes [ key ] [EOL] cur_english_encrypt_freq = _english_encrypt_freq [ key ] [EOL] for i in cur_letters_ascii_encrypted_dec_codes : [EOL] observed = [number] [EOL] [comment] [EOL] for j in [ j for j in [ i , i + [number] ] if j in str_char_occurrences ] : [EOL] observed += str_char_occurrences [ j ] [EOL] [EOL] expected = str_len * cur_english_encrypt_freq [ i ] [EOL] difference = observed - expected [EOL] chi2 += difference * difference / expected [EOL] [EOL] for punct_encrypt_char in ( punct_encrypt_char for punct_encrypt_char in cur_english_encrypt_freq if punct_encrypt_char not in cur_letters_ascii_encrypted_dec_codes ) : [EOL] observed = str_char_occurrences [ punct_encrypt_char ] if punct_encrypt_char in str_char_occurrences else [number] [EOL] expected = str_len * cur_english_encrypt_freq [ punct_encrypt_char ] [EOL] difference = observed - expected [EOL] chi2 += difference * difference / expected [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] expected_other_chars = [number] * str_len [EOL] for char in ( char for char in str_char_occurrences if char not in _evaluated_freq_ascii_dec_encrypted_codes [ key ] ) : [EOL] observed = str_char_occurrences [ char ] [EOL] difference = observed - expected_other_chars [EOL] chi2 += difference * difference / expected_other_chars [EOL] [EOL] return chi2 [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] _english_char_frequencies = { [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] } [EOL] _letters_ascii_dec_codes = list ( range ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] _evaluated_freq_ascii_dec_codes = [ [number] , [number] , [number] ] [EOL] _evaluated_freq_ascii_dec_codes . extend ( _english_char_frequencies . keys ( ) ) [EOL] _evaluated_freq_ascii_dec_codes . extend ( list ( range ( [number] , [number] ) ) ) [EOL] [EOL] _printable_ascii_dec_codes = [ [number] , [number] , [number] ] [EOL] _printable_ascii_dec_codes . extend ( list ( range ( [number] , [number] ) ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] _english_encrypt_freq = [ ] [EOL] _letters_ascii_encrypted_dec_codes = [ ] [EOL] _evaluated_freq_ascii_dec_encrypted_codes = [ ] [EOL] _printable_ascii_dec_encrypted_codes = [ ] [EOL] for _dec_key in range ( [number] ) : [EOL] _hex_key = [string] . format ( _dec_key ) [EOL] _english_encrypt_freq . append ( { int ( fixed_xor ( [string] . format ( k ) , _hex_key ) , [number] ) : _english_char_frequencies [ k ] for k in _english_char_frequencies } ) [EOL] _letters_ascii_encrypted_dec_codes . append ( [ int ( fixed_xor ( [string] . format ( k ) , _hex_key ) , [number] ) for k in _letters_ascii_dec_codes ] ) [EOL] _evaluated_freq_ascii_dec_encrypted_codes . append ( [ int ( fixed_xor ( [string] . format ( k ) , _hex_key ) , [number] ) for k in _evaluated_freq_ascii_dec_codes ] ) [EOL] _printable_ascii_dec_encrypted_codes . append ( [ int ( fixed_xor ( [string] . format ( k ) , _hex_key ) , [number] ) for k in _printable_ascii_dec_codes ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[builtins.dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.dict]$ 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0
[comment] [EOL] from typing import Iterator , Dict [EOL] import typing [EOL] import builtins [EOL] from typing import Iterator [EOL] [EOL] from set1 import HEX_TO_BIN_DICT [EOL] [EOL] BITS_TO_BASE_64_DICT = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def hex_to_bytes_iterator ( hex_str ) : [EOL] while hex_str : [EOL] yield HEX_TO_BIN_DICT [ hex_str [ [number] ] ] + HEX_TO_BIN_DICT [ hex_str [ [number] ] ] [EOL] hex_str = hex_str [ [number] : ] [EOL] [EOL] [EOL] def hex_to_base64 ( hex_str ) : [EOL] [comment] [EOL] base64_translation = [string] [EOL] [EOL] bytes_iterator = hex_to_bytes_iterator ( hex_str ) [EOL] bits_buffer = next ( bytes_iterator , [string] ) [EOL] last_sextet_has_been_padded = False [EOL] nb_of_sextets = [number] [EOL] [EOL] while bits_buffer : [EOL] [comment] [EOL] nb_of_sextets += [number] [EOL] bits_buffer_length = len ( bits_buffer ) [EOL] if bits_buffer_length >= [number] : [EOL] bits_str_to_decode , bits_buffer = bits_buffer [ : [number] ] , bits_buffer [ [number] : ] [EOL] else : [EOL] [comment] [EOL] bits_str_to_decode , bits_buffer = bits_buffer + ( [string] * ( [number] - bits_buffer_length ) ) , [string] [EOL] last_sextet_has_been_padded = True [EOL] base64_translation += BITS_TO_BASE_64_DICT [ bits_str_to_decode ] [EOL] bits_buffer += next ( bytes_iterator , [string] ) [EOL] [EOL] [comment] [EOL] if last_sextet_has_been_padded : [EOL] [comment] [EOL] nb_of_translated_bytes = nb_of_sextets * [number] [EOL] [comment] [EOL] nb_of_bits_to_have_complete_bytes = nb_of_translated_bytes + [number] [EOL] while nb_of_bits_to_have_complete_bytes % [number] != [number] : [EOL] nb_of_bits_to_have_complete_bytes += [number] [EOL] nb_of_padding_zeros_to_have_complete_bytes_and_sextets = nb_of_bits_to_have_complete_bytes - nb_of_translated_bytes [EOL] nb_of_padding_equals = int ( nb_of_padding_zeros_to_have_complete_bytes_and_sextets / [number] ) [EOL] base64_translation += [string] * nb_of_padding_equals [EOL] [EOL] return base64_translation [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict [EOL] import typing [EOL] import builtins [EOL] from set1 import BIN_TO_HEX_DICT [EOL] from set1 . base64enc import hex_to_bytes_iterator [EOL] [EOL] XOR_results = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def fixed_xor ( hex_str_1 , hex_str_2 ) : [EOL] bits_str_it_1 , bits_str_it_2 = hex_to_bytes_iterator ( hex_str_1 ) , hex_to_bytes_iterator ( hex_str_2 ) [EOL] xor_hex_result = [string] [EOL] [EOL] bits_str_buff_1 , bits_str_buff_2 = next ( bits_str_it_1 , None ) , next ( bits_str_it_2 , None ) [EOL] while bits_str_buff_1 and bits_str_buff_2 : [EOL] xor_bits_result_buf = [string] [EOL] for bits_char_buff_1 , bits_char_buff_2 in zip ( bits_str_buff_1 , bits_str_buff_2 ) : [EOL] xor_bits_result_buf += XOR_results [ bits_char_buff_1 + bits_char_buff_2 ] [EOL] [comment] [EOL] xor_hex_result += BIN_TO_HEX_DICT [ xor_bits_result_buf [ : [number] ] ] + BIN_TO_HEX_DICT [ xor_bits_result_buf [ [number] : ] ] [EOL] bits_str_buff_1 , bits_str_buff_2 = next ( bits_str_it_1 , None ) , next ( bits_str_it_2 , None ) [EOL] [EOL] return xor_hex_result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Optional [EOL] import typing [EOL] import os [EOL] [EOL] from set1 . single_byte_xor_detection import detect_single_byte_cypher [EOL] [EOL] [EOL] def test_challenge_should_match ( ) : [EOL] [comment] [EOL] hex_phrases = _get_data_file_lines ( [string] ) [EOL] [EOL] [comment] [EOL] actual = detect_single_byte_cypher ( hex_phrases ) [EOL] [EOL] [comment] [EOL] assert actual == [string] [EOL] [EOL] [EOL] def _get_data_file_lines ( filename ) : [EOL] current_dir = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] with open ( f'{ current_dir } [string] { filename } [string] ' ) as f : [EOL] return [ hex_phrase . strip ( ) for hex_phrase in f . readlines ( ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import pytest [EOL] [EOL] from set1 . fixed_xor import fixed_xor [EOL] from set1 . single_byte_xor_decipher import single_byte_decipher , NoPossibleKeyError [EOL] [EOL] [EOL] def test_challenge_should_match ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] hex_cyphered_str = [string] [EOL] [EOL] [comment] [EOL] actual , _ , _ = single_byte_decipher ( hex_cyphered_str ) [EOL] [EOL] [comment] [EOL] assert actual == [string] [EOL] [EOL] [EOL] def test_on_a_longer_sample ( ) : [EOL] [comment] [EOL] hex_deciphered_str = [string] [string] [string] [string] [EOL] hex_cyphered_str = fixed_xor ( hex_deciphered_str , [string] * ( int ( len ( hex_deciphered_str ) / [number] ) ) ) [EOL] [EOL] [comment] [EOL] actual , key , _ = single_byte_decipher ( hex_cyphered_str ) [EOL] [EOL] [comment] [EOL] assert key == [string] [EOL] assert actual == [string] [string] [EOL] [EOL] [EOL] def test_if_no_possible_key_then_exception_is_raised ( ) : [EOL] [comment] [EOL] hex_cyphered_str = [string] [EOL] [EOL] [comment] [EOL] with pytest . raises ( NoPossibleKeyError ) : [EOL] [comment] [EOL] single_byte_decipher ( hex_cyphered_str ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] from set1 . vigenere_decryption import hamming_distance , decrypt_vigenere [EOL] [EOL] [EOL] def test_hamming_distance_for_equal_str_is_0 ( ) : [EOL] [comment] [EOL] str_1 = [string] [EOL] str_2 = [string] [EOL] [EOL] [comment] [EOL] actual = hamming_distance ( str_1 , str_2 ) [EOL] [EOL] [comment] [EOL] assert actual == [number] [EOL] [EOL] [EOL] def test_hamming_distance_jake_and_fire_is_6 ( ) : [EOL] [comment] [EOL] str_1 = [string] [EOL] str_2 = [string] [EOL] [EOL] [comment] [EOL] actual = hamming_distance ( str_1 , str_2 ) [EOL] [EOL] [comment] [EOL] assert actual == [number] [EOL] [EOL] [EOL] def test_hamming_distance_for_challenge_is_37_as_described ( ) : [EOL] [comment] [EOL] str_1 = [string] [EOL] str_2 = [string] [EOL] [EOL] [comment] [EOL] actual = hamming_distance ( str_1 , str_2 ) [EOL] [EOL] [comment] [EOL] assert actual == [number] [EOL] [EOL] [EOL] def test_challenge_should_match ( ) : [EOL] [comment] [EOL] current_dir = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] filename = f'{ current_dir } [string] ' [EOL] [EOL] [comment] [EOL] decrypted_text , key = decrypt_vigenere ( filename ) [EOL] [EOL] [comment] [EOL] assert key == [string] [EOL] assert decrypted_text [ : [number] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from set1 . base64enc import hex_to_base64 [EOL] [EOL] [EOL] def test_base64_encoding_padding_once ( ) : [EOL] [comment] [EOL] hex_str = [string] [EOL] [EOL] [comment] [EOL] actual = hex_to_base64 ( hex_str ) [EOL] [EOL] [comment] [EOL] assert actual == [string] [EOL] [EOL] [EOL] def test_base64_encoding_padding_twice ( ) : [EOL] [comment] [EOL] hex_str = [string] [EOL] [EOL] [comment] [EOL] actual = hex_to_base64 ( hex_str ) [EOL] [EOL] [comment] [EOL] assert actual == [string] [EOL] [EOL] [EOL] def test_challenge_should_match ( ) : [EOL] [comment] [EOL] hex_str = [string] [EOL] [EOL] [comment] [EOL] actual = hex_to_base64 ( hex_str ) [EOL] [EOL] [comment] [EOL] assert actual == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from set1 . fixed_xor import fixed_xor [EOL] [EOL] [EOL] def test_challenge_should_match ( ) : [EOL] [comment] [EOL] hex_str_1 = [string] [EOL] hex_str_2 = [string] [EOL] [EOL] [comment] [EOL] actual = fixed_xor ( hex_str_1 , hex_str_2 ) [EOL] [EOL] [comment] [EOL] assert actual == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from set1 import convert_ascii_to_hex [EOL] from set1 . repeating_key_xor import xor_ascii_with_repeating_key [EOL] [EOL] [EOL] def test_challenge_should_match ( ) : [EOL] [comment] [EOL] phrase = [string] [string] [EOL] key = [string] [EOL] [EOL] [comment] [EOL] actual = xor_ascii_with_repeating_key ( phrase , convert_ascii_to_hex ( key ) ) [EOL] [EOL] [comment] [EOL] assert actual == [string] [string] [EOL] [EOL] [EOL] def test_key_longer_than_input ( ) : [EOL] [comment] [EOL] phrase = [string] [EOL] key = [string] [string] [EOL] [EOL] [comment] [EOL] actual = xor_ascii_with_repeating_key ( phrase , convert_ascii_to_hex ( key ) ) [EOL] [EOL] [comment] [EOL] assert actual == [string] [EOL] [EOL] [EOL] def test_with_one_char ( ) : [EOL] [comment] [EOL] phrase = [string] [EOL] key = [string] [EOL] [EOL] [comment] [EOL] actual = xor_ascii_with_repeating_key ( phrase , convert_ascii_to_hex ( key ) ) [EOL] [EOL] [comment] [EOL] assert actual == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0