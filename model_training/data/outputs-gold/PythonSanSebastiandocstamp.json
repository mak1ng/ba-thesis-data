[docstring] [EOL] [EOL] from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import logging [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] import argparse [EOL] [EOL] from docstamp . inkscape import svg2pdf , svg2png [EOL] [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def create_argparser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , dest = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , dest = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , choices = [ [string] , [string] ] , action = [string] , dest = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , action = [string] , dest = [string] , default = [number] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] parser = create_argparser ( ) [EOL] [EOL] try : [EOL] args = parser . parse_args ( ) [EOL] except argparse . ArgumentError as exc : [EOL] log . exception ( [string] ) [EOL] parser . error ( str ( exc . message ) ) [EOL] exit ( - [number] ) [EOL] [EOL] input_file = args . input [EOL] output_file = args . output [EOL] file_type = args . file_type [EOL] dpi = args . dpi [EOL] [EOL] if file_type == [string] : [EOL] svg2png ( input_file , output_file , dpi = dpi ) [EOL] elif file_type == [string] : [EOL] svg2pdf ( input_file , output_file , dpi = dpi ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import scripts [EOL] import argparse [EOL] import typing [EOL] import logging [EOL] import os [EOL] import base64 [EOL] import argparse [EOL] import logging [EOL] from lxml import etree [EOL] [EOL] [EOL] FONT_TYPES = { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def create_argparser ( ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , dest = [string] , default = [string] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , dest = [string] , default = [ ] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , dest = [string] , default = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] def get_base64_encoding ( bin_filepath ) : [EOL] [docstring] [EOL] return base64 . b64encode ( open ( bin_filepath , [string] ) . read ( ) ) [EOL] [EOL] [EOL] def remove_ext ( filepath ) : [EOL] [docstring] [EOL] return os . path . basename ( filepath ) . split ( [string] ) [ [number] ] [EOL] [EOL] [EOL] def get_ext ( filepath ) : [EOL] [docstring] [EOL] return os . path . basename ( filepath ) . split ( [string] ) [ - [number] ] [EOL] [EOL] [EOL] class FontFace ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filepath , fonttype = None , name = None ) : [EOL] self . filepath = filepath [EOL] self . ftype = fonttype [EOL] self . given_name = name [EOL] [EOL] @ classmethod def from_file ( cls , filepath ) : [EOL] return cls ( filepath ) [EOL] [EOL] @ property def name ( self ) : [EOL] if self . given_name is None : [EOL] return remove_ext ( self . filepath ) [EOL] else : [EOL] return self . given_name [EOL] [EOL] @ property def base64 ( self ) : [EOL] return get_base64_encoding ( self . filepath ) [EOL] [EOL] @ property def fonttype ( self ) : [EOL] if self . ftype is None : [EOL] return FONT_TYPES [ get_ext ( self . filepath ) ] [EOL] else : [EOL] return self . ftype [EOL] [EOL] @ property def ext ( self ) : [EOL] return get_ext ( self . filepath ) [EOL] [EOL] @ property def css_text ( self ) : [EOL] css_text = [string] [EOL] css_text += [string] + self . name + [string] [EOL] css_text += [string] + self . ext + [string] [EOL] css_text += [string] + self . base64 + [string] [EOL] css_text += [string] + self . fonttype + [string] [EOL] return css_text [EOL] [EOL] [EOL] class FontFaceGroup ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . fontfaces = [ ] [EOL] [EOL] @ property def css_text ( self ) : [EOL] css_text = [string] [EOL] for ff in self . fontfaces : [EOL] css_text += ff . css_text [EOL] css_text += [string] [EOL] return css_text [EOL] [EOL] @ property def xml_elem ( self ) : [EOL] return etree . fromstring ( self . css_text ) [EOL] [EOL] def append ( self , font_face ) : [EOL] self . fontfaces . append ( font_face ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] log = logging . getLogger ( __file__ ) [EOL] [EOL] parser = create_argparser ( ) [EOL] try : [EOL] args = parser . parse_args ( ) [EOL] except argparse . ArgumentError as exc : [EOL] log . exception ( [string] ) [EOL] parser . error ( str ( exc . message ) ) [EOL] exit ( - [number] ) [EOL] [EOL] svg_filepath = args . svg_filepath [EOL] fonts = args . fonts [EOL] out_path = args . out_path [EOL] [EOL] [comment] [EOL] stdout = False [EOL] raw_write = False [EOL] if not svg_filepath : [EOL] raw_write = True [EOL] elif not os . path . exists ( svg_filepath ) : [EOL] log . error ( [string] . format ( svg_filepath ) ) [EOL] exit ( - [number] ) [EOL] [EOL] if not out_path : [EOL] raw_write = True [EOL] stdout = True [EOL] [EOL] [comment] [EOL] if not fonts : [EOL] log . error ( [string] ) [EOL] exit ( - [number] ) [EOL] [EOL] [comment] [EOL] fontfaces = FontFaceGroup ( ) [EOL] for font_path in fonts : [EOL] fontfaces . append ( FontFace ( font_path ) ) [EOL] [EOL] [comment] [EOL] if raw_write and stdout : [EOL] print ( fontfaces . css_text ) [EOL] exit ( [number] ) [EOL] [EOL] elif raw_write : [EOL] xtree = etree . ElementTree ( fontfaces . xml_elem ) [EOL] xtree . write ( out_path ) [EOL] exit ( [number] ) [EOL] [EOL] else : [EOL] with open ( svg_filepath , [string] ) as svgf : [EOL] tree = etree . parse ( svgf ) [EOL] [EOL] for element in tree . iter ( ) : [EOL] if element . tag . split ( [string] ) [ [number] ] == [string] : [EOL] break [EOL] element . insert ( [number] , fontfaces . xml_elem ) [EOL] tree . write ( out_path , encoding = [string] , pretty_print = True ) [EOL] exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $scripts.embed_font_to_svg.FontFaceGroup$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $scripts.embed_font_to_svg.FontFaceGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $scripts.embed_font_to_svg.FontFaceGroup$ 0 0 0 0 0 0 0 0 0 0 0 $scripts.embed_font_to_svg.FontFaceGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $scripts.embed_font_to_svg.FontFaceGroup$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 $scripts.embed_font_to_svg.FontFaceGroup$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $scripts.embed_font_to_svg.FontFaceGroup$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Tuple [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import os [EOL] import logging [EOL] [EOL] from docstamp . commands import call_command , which , check_command [EOL] import svgutils . transform as sg [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def replace_chars_for_svg_code ( svg_content ) : [EOL] [docstring] [EOL] result = svg_content [EOL] svg_char = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] for c , entity in svg_char : [EOL] result = result . replace ( c , entity ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def _check_svg_file ( svg_file ) : [EOL] [docstring] [EOL] if isinstance ( svg_file , str ) : [EOL] try : [EOL] svg = sg . fromfile ( svg_file ) [EOL] except Exception as exc : [EOL] raise Exception ( [string] . format ( svg_file ) ) from exc [EOL] else : [EOL] return svg [EOL] [EOL] if isinstance ( svg_file , sg . SVGFigure ) : [EOL] return svg_file [EOL] [EOL] raise ValueError ( [string] . format ( type ( svg_file ) ) ) [EOL] [EOL] [EOL] def merge_svg_files ( svg_file1 , svg_file2 , x_coord , y_coord , scale = [number] ) : [EOL] [docstring] [EOL] svg1 = _check_svg_file ( svg_file1 ) [EOL] svg2 = _check_svg_file ( svg_file2 ) [EOL] [EOL] svg2_root = svg2 . getroot ( ) [EOL] svg1 . append ( [ svg2_root ] ) [EOL] [EOL] svg2_root . moveto ( x_coord , y_coord , scale = scale ) [EOL] [EOL] return svg1 [EOL] [EOL] [EOL] def rsvg_export ( input_file , output_file , dpi = [number] , rsvg_binpath = None ) : [EOL] [docstring] [EOL] if not os . path . exists ( input_file ) : [EOL] log . error ( [string] . format ( input_file ) ) [EOL] raise IOError ( ( [number] , [string] , input_file ) ) [EOL] [EOL] if rsvg_binpath is None : [EOL] rsvg_binpath = which ( [string] ) [EOL] check_command ( rsvg_binpath ) [EOL] [EOL] args_strings = [ ] [EOL] args_strings += [ [string] ] [EOL] args_strings += [ [string] . format ( output_file ) ] [EOL] args_strings += [ [string] . format ( dpi ) ] [EOL] args_strings += [ [string] . format ( dpi ) ] [EOL] args_strings += [ input_file ] [EOL] [EOL] return call_command ( rsvg_binpath , args_strings ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] from xml . sax . saxutils import escape , unescape [EOL] [EOL] from . file_utils import replace_file_content [EOL] [EOL] xml_escape_table = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] xml_unescape_table = { v : k for k , v in xml_escape_table . items ( ) } [EOL] [EOL] [EOL] def xml_escape ( text ) : [EOL] [docstring] [EOL] return escape ( text , xml_escape_table ) [EOL] [EOL] [EOL] def xml_unescape ( text ) : [EOL] [docstring] [EOL] return unescape ( text , xml_unescape_table ) [EOL] [EOL] [EOL] def change_xml_encoding ( filepath , src_enc , dst_enc = [string] ) : [EOL] [docstring] [EOL] enc_attr = [string] [EOL] replace_file_content ( filepath , enc_attr . format ( src_enc ) , enc_attr . format ( dst_enc ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import csv [EOL] import codecs [EOL] [EOL] try : [EOL] from cStringIO import StringIO [EOL] except : [EOL] from io import StringIO [EOL] [EOL] [EOL] class UnicodeWriter : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , f , dialect = csv . excel , encoding = [string] , ** kwds ) : [EOL] [comment] [EOL] self . queue = StringIO ( ) [EOL] self . writer = csv . writer ( self . queue , dialect = dialect , ** kwds ) [EOL] self . stream = f [EOL] self . encoder = codecs . getincrementalencoder ( encoding ) ( ) [EOL] [EOL] def writerow ( self , row ) : [EOL] self . writer . writerow ( [ s . encode ( [string] ) for s in row ] ) [EOL] [comment] [EOL] data = self . queue . getvalue ( ) [EOL] data = data . decode ( [string] ) [EOL] [comment] [EOL] data = self . encoder . encode ( data ) [EOL] [comment] [EOL] self . stream . write ( data ) [EOL] [comment] [EOL] self . queue . truncate ( [number] ) [EOL] [EOL] def writerows ( self , rows ) : [EOL] for row in rows : [EOL] self . writerow ( row ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , Type [EOL] import docstamp [EOL] import typing [EOL] import logging [EOL] import jinja2 [EOL] import os [EOL] import shutil [EOL] import logging [EOL] [EOL] from jinja2 import Environment , FileSystemLoader [EOL] [EOL] from . inkscape import svg2pdf , svg2png [EOL] from . pdflatex import tex2pdf , xetex2pdf [EOL] from . file_utils import get_tempfile , write_to_file [EOL] from . svg_utils import replace_chars_for_svg_code [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_environment_for ( file_path ) : [EOL] [docstring] [EOL] work_dir = os . path . dirname ( os . path . abspath ( file_path ) ) [EOL] [EOL] if not os . path . exists ( work_dir ) : [EOL] raise IOError ( [string] . format ( file_path ) ) [EOL] [EOL] try : [EOL] jinja_env = Environment ( loader = FileSystemLoader ( work_dir ) ) [EOL] except : [EOL] raise [EOL] else : [EOL] return jinja_env [EOL] [EOL] [EOL] def get_doctype_by_extension ( extension ) : [EOL] if [string] in extension : [EOL] doc_type = TextDocument [EOL] elif [string] in extension : [EOL] doc_type = SVGDocument [EOL] elif [string] in extension : [EOL] doc_type = LateXDocument [EOL] else : [EOL] raise ValueError ( [string] . format ( extension ) ) [EOL] [EOL] return doc_type [EOL] [EOL] [EOL] def get_doctype_by_command ( command ) : [EOL] if not command : [EOL] doc_type = TextDocument [EOL] elif command == [string] : [EOL] doc_type = SVGDocument [EOL] elif command == [string] : [EOL] doc_type = PDFLateXDocument [EOL] elif command == [string] : [EOL] doc_type = XeLateXDocument [EOL] else : [EOL] raise ValueError ( [string] . format ( command ) ) [EOL] [EOL] return doc_type [EOL] [EOL] [EOL] class TextDocument ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , template_file_path , doc_contents = None ) : [EOL] if not os . path . exists ( template_file_path ) : [EOL] raise IOError ( [string] . format ( template_file_path ) ) [EOL] [EOL] self . _setup_template_file ( template_file_path ) [EOL] [EOL] if doc_contents is not None : [EOL] self . file_content_ = self . fill ( doc_contents ) [EOL] [EOL] def _setup_template_file ( self , template_file_path ) : [EOL] [docstring] [EOL] try : [EOL] template_file = template_file_path [EOL] template_env = get_environment_for ( template_file_path ) [EOL] template = template_env . get_template ( os . path . basename ( template_file ) ) [EOL] except : [EOL] raise [EOL] else : [EOL] self . _template_file = template_file [EOL] self . _template_env = template_env [EOL] self . template = template [EOL] [EOL] def fill ( self , doc_contents ) : [EOL] [docstring] [EOL] try : [EOL] filled_doc = self . template . render ( ** doc_contents ) [EOL] except : [EOL] log . exception ( [string] [string] . format ( doc_contents ) ) [EOL] raise [EOL] else : [EOL] self . file_content_ = filled_doc [EOL] return filled_doc [EOL] [EOL] def save_content ( self , file_path , encoding = [string] ) : [EOL] [docstring] [EOL] if self . file_content_ is None : [EOL] msg = [string] [EOL] log . exception ( msg ) [EOL] raise ValueError ( msg ) [EOL] [EOL] try : [EOL] write_to_file ( file_path , content = self . file_content_ , encoding = encoding ) [EOL] except Exception as exc : [EOL] msg = [string] . format ( self . __class__ ) [EOL] log . exception ( msg ) [EOL] raise Exception ( msg ) from exc [EOL] [EOL] def render ( self , file_path , ** kwargs ) : [EOL] [docstring] [EOL] return self . save_content ( file_path ) [EOL] [EOL] @ classmethod def from_template_file ( cls , template_file_path , command = None ) : [EOL] [docstring] [EOL] [comment] [EOL] ext = os . path . basename ( template_file_path ) . split ( [string] ) [ - [number] ] [EOL] [EOL] try : [EOL] doc_type = get_doctype_by_command ( command ) [EOL] except ValueError : [EOL] doc_type = get_doctype_by_extension ( ext ) [EOL] except : [EOL] raise [EOL] else : [EOL] return doc_type ( template_file_path ) [EOL] [EOL] [EOL] class SVGDocument ( TextDocument ) : [EOL] [docstring] [EOL] _template_file = [string] [EOL] [EOL] def fill ( self , doc_contents ) : [EOL] [docstring] [EOL] for key , content in doc_contents . items ( ) : [EOL] doc_contents [ key ] = replace_chars_for_svg_code ( content ) [EOL] [EOL] return super ( SVGDocument , self ) . fill ( doc_contents = doc_contents ) [EOL] [EOL] def render ( self , file_path , ** kwargs ) : [EOL] [docstring] [EOL] temp = get_tempfile ( suffix = [string] ) [EOL] self . save_content ( temp . name ) [EOL] [EOL] file_type = kwargs . get ( [string] , [string] ) [EOL] dpi = kwargs . get ( [string] , [number] ) [EOL] support_unicode = kwargs . get ( [string] , False ) [EOL] try : [EOL] if file_type == [string] : [EOL] shutil . copyfile ( temp . name , file_path ) [EOL] elif file_type == [string] : [EOL] svg2png ( temp . name , file_path , dpi = dpi ) [EOL] elif file_type == [string] : [EOL] svg2pdf ( temp . name , file_path , dpi = dpi , support_unicode = support_unicode ) [EOL] except : [EOL] log . exception ( [string] . format ( file_path , file_type ) ) [EOL] raise [EOL] [EOL] [EOL] class LateXDocument ( TextDocument ) : [EOL] [docstring] [EOL] [EOL] _render_function = staticmethod ( tex2pdf ) [EOL] [EOL] def render ( self , file_path , ** kwargs ) : [EOL] [docstring] [EOL] temp = get_tempfile ( suffix = [string] ) [EOL] self . save_content ( temp . name ) [EOL] [EOL] try : [EOL] self . _render_function ( temp . name , file_path , output_format = [string] ) [EOL] except : [EOL] log . exception ( [string] . format ( file_path ) ) [EOL] raise [EOL] [EOL] [EOL] class PDFLateXDocument ( LateXDocument ) : [EOL] pass [EOL] [EOL] [EOL] class XeLateXDocument ( LateXDocument ) : [EOL] _render_function = staticmethod ( xetex2pdf ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.staticmethod$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.staticmethod$ 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def create_vcard3_str ( name , surname , displayname , email = [string] , org = [string] , title = [string] , url = [string] , note = [string] ) : [EOL] [docstring] [EOL] vcard = [ ] [EOL] vcard += [ [string] ] [EOL] vcard += [ [string] ] [EOL] [EOL] if name and surname : [EOL] name = name . strip ( ) [EOL] vcard += [ [string] . format ( name , surname ) ] [EOL] [EOL] if not displayname : [EOL] displayname = [string] . format ( name , surname ) [EOL] [EOL] vcard += [ [string] . format ( displayname ) ] [EOL] [EOL] if email : [EOL] vcard += [ [string] . format ( email ) ] [EOL] [EOL] if org : [EOL] vcard += [ [string] . format ( org ) ] [EOL] [EOL] if title : [EOL] vcard += [ [string] . format ( title ) ] [EOL] [EOL] if url : [EOL] vcard += [ [string] . format ( url ) ] [EOL] [EOL] if note : [EOL] vcard += [ [string] . format ( note ) ] [EOL] [EOL] vcard += [ [string] ] [EOL] [EOL] return [string] . join ( [ field . strip ( ) for field in vcard ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import qrcode [EOL] import qrcode . image . svg [EOL] [EOL] from docstamp . file_utils import replace_file_content [EOL] [EOL] [EOL] def save_into_qrcode ( text , out_filepath , color = [string] , box_size = [number] , pixel_size = [number] ) : [EOL] [docstring] [EOL] try : [EOL] qr = qrcode . QRCode ( version = [number] , error_correction = qrcode . constants . ERROR_CORRECT_L , box_size = box_size , border = [number] , ) [EOL] qr . add_data ( text ) [EOL] qr . make ( fit = True ) [EOL] except Exception as exc : [EOL] raise Exception ( [string] [string] . format ( text ) ) from exc [EOL] else : [EOL] img = qr . make_image ( image_factory = qrcode . image . svg . SvgPathImage ) [EOL] [EOL] _ = _qrcode_to_file ( img , out_filepath ) [EOL] [EOL] if color : [EOL] replace_file_content ( out_filepath , [string] , [string] . format ( color ) ) [EOL] [EOL] [EOL] def _qrcode_to_file ( qrcode , out_filepath ) : [EOL] [docstring] [EOL] try : [EOL] qrcode . save ( out_filepath ) [EOL] except Exception as exc : [EOL] raise IOError ( [string] . format ( out_filepath ) ) from exc [EOL] else : [EOL] return qrcode [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from PyPDF2 import PdfFileMerger , PdfFileReader [EOL] [EOL] from docstamp . commands import call_command [EOL] [EOL] [EOL] def merge_pdfs ( pdf_filepaths , out_filepath ) : [EOL] [docstring] [EOL] merger = PdfFileMerger ( ) [EOL] for pdf in pdf_filepaths : [EOL] merger . append ( PdfFileReader ( open ( pdf , [string] ) ) ) [EOL] [EOL] merger . write ( out_filepath ) [EOL] [EOL] return out_filepath [EOL] [EOL] [EOL] def pdf_to_cmyk ( input_file , output_file ) : [EOL] [docstring] [EOL] cmd_args = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] . format ( output_file , input_file ) , ] [EOL] call_command ( [string] , cmd_args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] __version__ = [string] [comment] [EOL]	0 0 $builtins.str$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , Dict [EOL] import docstamp [EOL] import typing [EOL] import os [EOL] import base64 [EOL] from lxml import etree [EOL] [EOL] from . file_utils import get_extension [EOL] [EOL] FONT_TYPES = { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def get_base64_encoding ( bin_filepath ) : [EOL] [docstring] [EOL] return base64 . b64encode ( open ( bin_filepath , [string] ) . read ( ) ) [EOL] [EOL] [EOL] def remove_ext ( filepath ) : [EOL] [docstring] [EOL] return os . path . basename ( filepath ) . split ( [string] ) [ [number] ] [EOL] [EOL] [EOL] class FontFace ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filepath , fonttype = None , name = None ) : [EOL] self . filepath = filepath [EOL] self . ftype = fonttype [EOL] self . given_name = name [EOL] [EOL] @ classmethod def from_file ( cls , filepath ) : [EOL] return cls ( filepath ) [EOL] [EOL] @ property def name ( self ) : [EOL] if self . given_name is None : [EOL] return remove_ext ( self . filepath ) [EOL] else : [EOL] return self . given_name [EOL] [EOL] @ property def base64 ( self ) : [EOL] return get_base64_encoding ( self . filepath ) [EOL] [EOL] @ property def fonttype ( self ) : [EOL] if self . ftype is None : [EOL] return FONT_TYPES [ get_extension ( self . filepath ) ] [EOL] else : [EOL] return self . ftype [EOL] [EOL] @ property def ext ( self ) : [EOL] return get_extension ( self . filepath ) [EOL] [EOL] @ property def css_text ( self ) : [EOL] css_text = [string] [EOL] css_text += [string] + self . name + [string] [EOL] css_text += [string] + self . ext + [string] [EOL] css_text += [string] + self . base64 + [string] [EOL] css_text += [string] + self . fonttype + [string] [EOL] return css_text [EOL] [EOL] [EOL] class FontFaceGroup ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . fontfaces = [ ] [EOL] [EOL] @ property def css_text ( self ) : [EOL] css_text = [string] [EOL] for ff in self . fontfaces : [EOL] css_text += ff . css_text [EOL] css_text += [string] [EOL] return css_text [EOL] [EOL] @ property def xml_elem ( self ) : [EOL] return etree . fromstring ( self . css_text ) [EOL] [EOL] def append ( self , font_face ) : [EOL] self . fontfaces . append ( font_face ) [EOL] [EOL] [EOL] def _embed_font_to_svg ( filepath , font_files ) : [EOL] [docstring] [EOL] with open ( filepath , [string] ) as svgf : [EOL] tree = etree . parse ( svgf ) [EOL] [EOL] if not font_files : [EOL] return tree [EOL] [EOL] fontfaces = FontFaceGroup ( ) [EOL] for font_file in font_files : [EOL] fontfaces . append ( FontFace ( font_file ) ) [EOL] [EOL] for element in tree . iter ( ) : [EOL] if element . tag . split ( [string] ) [ [number] ] == [string] : [EOL] break [EOL] [EOL] element . insert ( [number] , fontfaces . xml_elem ) [EOL] [EOL] return tree [EOL] [EOL] [EOL] def embed_font_to_svg ( filepath , outfile , font_files ) : [EOL] [docstring] [EOL] tree = _embed_font_to_svg ( filepath , font_files ) [EOL] tree . write ( outfile , encoding = [string] , pretty_print = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] import re [EOL] import logging [EOL] from sys import platform as _platform [EOL] [EOL] from docstamp . commands import which , is_exe [EOL] [EOL] LOGGING_LVL = logging . INFO [EOL] logging . basicConfig ( level = LOGGING_LVL ) [EOL] [EOL] [EOL] def find_file_match ( folder_path , regex = [string] ) : [EOL] [docstring] [EOL] outlist = [ ] [EOL] for root , dirs , files in os . walk ( folder_path ) : [EOL] outlist . extend ( [ os . path . join ( root , f ) for f in files if re . match ( regex , f ) ] ) [EOL] [EOL] return outlist [EOL] [EOL] [EOL] def get_system_path ( ) : [EOL] if _platform == [string] or _platform == [string] : [EOL] return os . environ [ [string] ] [EOL] elif _platform == [string] : [EOL] return os . environ [ [string] ] [EOL] elif _platform == [string] : [EOL] [comment] [EOL] return os . environ [ [string] ] [EOL] [EOL] [EOL] def get_other_program_folders ( ) : [EOL] if _platform == [string] or _platform == [string] : [EOL] return [ [string] ] [EOL] elif _platform == [string] : [EOL] return [ [string] , os . path . join ( os . environ [ [string] ] , [string] ) ] [EOL] elif _platform == [string] : [EOL] [comment] [EOL] return [ [string] ] [EOL] [EOL] [EOL] def get_temp_dir ( ) : [EOL] if _platform == [string] or _platform == [string] : [EOL] return [string] [EOL] elif _platform == [string] : [EOL] return [string] [EOL] elif _platform == [string] : [EOL] [comment] [EOL] return None [EOL] [EOL] [EOL] def find_in_other_programs_folders ( app_name ) : [EOL] app_name_regex = [string] + app_name + [string] [EOL] other_folders = get_other_program_folders ( ) [EOL] [EOL] for folder in other_folders : [EOL] abin_file = find_program ( folder , app_name_regex ) [EOL] if abin_file is not None : [EOL] return abin_file [EOL] [EOL] return None [EOL] [EOL] [EOL] def find_program ( root_dir , exec_name ) : [EOL] file_matches = find_file_match ( root_dir , exec_name ) [EOL] for f in file_matches : [EOL] if is_exe ( f ) : [EOL] return f [EOL] return None [EOL] [EOL] [EOL] def ask_for_path_of ( app_name ) : [EOL] bin_path = None [EOL] while bin_path is not None : [EOL] bin_path = input ( [string] . format ( app_name ) ) [EOL] [EOL] if not os . path . exists ( bin_path ) : [EOL] print ( [string] . format ( bin_path ) ) [EOL] bin_path = None [EOL] continue [EOL] [EOL] if not is_exe ( bin_path ) : [EOL] print ( [string] . format ( bin_path ) ) [EOL] bin_path = None [EOL] continue [EOL] [EOL] return bin_path [EOL] [EOL] [EOL] def proactive_search_of ( app_name ) : [EOL] if _platform == [string] : [EOL] bin_name = app_name + [string] [EOL] else : [EOL] bin_name = app_name [EOL] [EOL] bin_path = which ( app_name ) [EOL] if bin_path is not None and is_exe ( bin_path ) : [EOL] return bin_path [EOL] [EOL] bin_path = find_in_other_programs_folders ( bin_name ) [EOL] if bin_path is not None : [EOL] return bin_path [EOL] [EOL] return ask_for_path_of ( bin_name ) [EOL] [EOL] [EOL] def get_inkscape_binpath ( ) : [EOL] bin_name = [string] [EOL] if _platform == [string] : [EOL] bin_name = [string] [EOL] [EOL] if [string] not in globals ( ) : [EOL] global INKSCAPE_BINPATH [EOL] INKSCAPE_BINPATH = proactive_search_of ( bin_name ) [EOL] [EOL] return INKSCAPE_BINPATH [EOL] [EOL] [EOL] def get_lyx_binpath ( ) : [EOL] if [string] not in globals ( ) : [EOL] global LYX_BINPATH [EOL] LYX_BINPATH = proactive_search_of ( [string] ) [EOL] return LYX_BINPATH [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import os [EOL] import logging [EOL] [EOL] from docstamp . config import get_inkscape_binpath [EOL] from docstamp . commands import call_command [EOL] from docstamp . svg_utils import rsvg_export [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def call_inkscape ( args_strings , inkscape_binpath = None ) : [EOL] [docstring] [EOL] log . debug ( [string] ) [EOL] [EOL] if inkscape_binpath is None : [EOL] inkscape_binpath = get_inkscape_binpath ( ) [EOL] [EOL] if inkscape_binpath is None or not os . path . exists ( inkscape_binpath ) : [EOL] raise IOError ( [string] ) [EOL] [EOL] return call_command ( inkscape_binpath , args_strings ) [EOL] [EOL] [EOL] def inkscape_export ( input_file , output_file , export_flag = [string] , dpi = [number] , inkscape_binpath = None ) : [EOL] [docstring] [EOL] if not os . path . exists ( input_file ) : [EOL] log . error ( [string] . format ( input_file ) ) [EOL] raise IOError ( ( [number] , [string] , input_file ) ) [EOL] [EOL] if [string] not in export_flag : [EOL] export_flag += [string] [EOL] [EOL] arg_strings = [ ] [EOL] arg_strings += [ [string] ] [EOL] arg_strings += [ [string] ] [EOL] arg_strings += [ [string] . format ( export_flag , output_file ) ] [EOL] arg_strings += [ [string] . format ( dpi ) ] [EOL] arg_strings += [ [string] . format ( input_file ) ] [EOL] [EOL] return call_inkscape ( arg_strings , inkscape_binpath = inkscape_binpath ) [EOL] [EOL] [EOL] def svg2pdf ( svg_file_path , pdf_file_path , dpi = [number] , command_binpath = None , support_unicode = False ) : [EOL] [docstring] [EOL] [EOL] if support_unicode : [EOL] return rsvg_export ( svg_file_path , pdf_file_path , dpi = dpi , rsvg_binpath = command_binpath ) [EOL] [EOL] return inkscape_export ( svg_file_path , pdf_file_path , export_flag = [string] , dpi = dpi , inkscape_binpath = command_binpath ) [EOL] [EOL] [EOL] def svg2png ( svg_file_path , png_file_path , dpi = [number] , inkscape_binpath = None ) : [EOL] [docstring] [EOL] return inkscape_export ( svg_file_path , png_file_path , export_flag = [string] , dpi = dpi , inkscape_binpath = inkscape_binpath ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pickle [EOL] [EOL] [EOL] class Enum ( set ) : [EOL] def __getattr__ ( self , name ) : [EOL] if name in self : [EOL] return name [EOL] raise AttributeError [EOL] [EOL] [EOL] class ItemSet ( object ) : [EOL] [EOL] def __iter__ ( self ) : [EOL] return self . items . __iter__ ( ) [EOL] [EOL] def __next__ ( self ) : [EOL] return self . items . __next__ ( ) [EOL] [EOL] def next ( self ) : [EOL] return self . items . next ( ) [EOL] [EOL] def __getitem__ ( self , item ) : [EOL] if hasattr ( self . items , [string] ) : [EOL] return self . items [ item ] [EOL] else : [EOL] raise AttributeError ( [string] ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . items ) [EOL] [EOL] def save ( self , file_path ) : [EOL] with open ( file_path , [string] ) : [EOL] pickle . dump ( self . __dict__ , file_path , pickle . HIGHEST_PROTOCOL ) [EOL] [EOL] def load_from_pickle ( self , file_path ) : [EOL] with open ( file_path , [string] ) : [EOL] adict = pickle . load ( file_path ) [EOL] pickle . dump ( self . __dict__ , file_path , pickle . HIGHEST_PROTOCOL ) [EOL] self . __dict__ . update ( adict ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import os [EOL] import sys [EOL] import shutil [EOL] import logging [EOL] import subprocess [EOL] from subprocess import CalledProcessError [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def simple_call ( cmd_args ) : [EOL] return subprocess . call ( [string] . join ( cmd_args ) , shell = True ) [EOL] [EOL] [EOL] def is_exe ( fpath ) : [EOL] [docstring] [EOL] return os . path . isfile ( fpath ) and os . access ( fpath , os . X_OK ) [EOL] [EOL] [EOL] def which ( cmd_name ) : [EOL] [docstring] [EOL] if sys . version_info > ( [number] , [number] ) : [EOL] return which_py3 ( cmd_name ) [EOL] else : [EOL] [comment] [EOL] return which_py2 ( cmd_name ) [EOL] [EOL] [EOL] def which_py3 ( cmd_name ) : [EOL] return shutil . which ( cmd_name ) [EOL] [EOL] [EOL] def which_py2 ( cmd_name ) : [EOL] fpath , fname = os . path . split ( cmd_name ) [EOL] if fpath : [EOL] if is_exe ( cmd_name ) : [EOL] return cmd_name [EOL] else : [EOL] for path in os . environ [ [string] ] . split ( os . pathsep ) : [EOL] path = path . strip ( [string] ) [EOL] exe_file = os . path . join ( path , cmd_name ) [EOL] if is_exe ( exe_file ) : [EOL] return exe_file [EOL] [EOL] return None [EOL] [EOL] [EOL] def check_command ( cmd_name ) : [EOL] [docstring] [EOL] if which ( cmd_name ) is None : [EOL] raise FileNotFoundError ( [string] . format ( cmd_name ) ) [EOL] [EOL] [EOL] def call_command ( cmd_name , args_strings ) : [EOL] [docstring] [EOL] if not os . path . isabs ( cmd_name ) : [EOL] cmd_fullpath = which ( cmd_name ) [EOL] else : [EOL] cmd_fullpath = cmd_name [EOL] [EOL] try : [EOL] cmd_line = [ cmd_fullpath ] + args_strings [EOL] log . debug ( [string] . format ( [string] . join ( cmd_line ) ) ) [EOL] [comment] [EOL] retval = subprocess . call ( [string] . join ( cmd_line ) , shell = True ) [EOL] except CalledProcessError as ce : [EOL] log . exception ( [string] [string] . format ( cmd_line , ce . returncode ) ) [EOL] raise [EOL] else : [EOL] return retval [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import os [EOL] import shutil [EOL] import logging [EOL] [EOL] from docstamp . commands import simple_call , check_command [EOL] from docstamp . file_utils import remove_ext , cleanup [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def tex2pdf ( tex_file , output_file = None , output_format = [string] ) : [EOL] [docstring] [EOL] if not os . path . exists ( tex_file ) : [EOL] raise IOError ( [string] . format ( tex_file ) ) [EOL] [EOL] if output_format != [string] and output_format != [string] : [EOL] raise ValueError ( [string] . format ( output_format ) ) [EOL] [EOL] cmd_name = [string] [EOL] check_command ( cmd_name ) [EOL] [EOL] args_strings = [ cmd_name ] [EOL] if output_file is not None : [EOL] args_strings += [ [string] . format ( os . path . abspath ( os . path . dirname ( output_file ) ) ) ] [EOL] [EOL] result_dir = os . path . dirname ( output_file ) if output_file else os . path . dirname ( tex_file ) [EOL] [EOL] args_strings += [ [string] . format ( output_format ) ] [EOL] args_strings += [ [string] + tex_file + [string] ] [EOL] [EOL] log . debug ( [string] . format ( cmd_name , args_strings ) ) [EOL] ret = simple_call ( args_strings ) [EOL] [EOL] result_file = os . path . join ( result_dir , remove_ext ( os . path . basename ( tex_file ) ) + [string] + output_format ) [EOL] if os . path . exists ( result_file ) : [EOL] shutil . move ( result_file , output_file ) [EOL] else : [EOL] raise IOError ( [string] ) [EOL] [EOL] log . debug ( [string] . format ( result_dir ) ) [EOL] cleanup ( result_dir , [string] ) [EOL] cleanup ( result_dir , [string] ) [EOL] [EOL] return ret [EOL] [EOL] [EOL] def xetex2pdf ( tex_file , output_file = None , output_format = [string] ) : [EOL] [docstring] [EOL] if not os . path . exists ( tex_file ) : [EOL] raise IOError ( [string] . format ( tex_file ) ) [EOL] [EOL] if output_format != [string] and output_format != [string] : [EOL] raise ValueError ( [string] . format ( output_format ) ) [EOL] [EOL] cmd_name = [string] [EOL] check_command ( cmd_name ) [EOL] [EOL] args_strings = [ cmd_name ] [EOL] if output_file is not None : [EOL] args_strings += [ [string] . format ( os . path . abspath ( os . path . dirname ( output_file ) ) ) ] [EOL] [EOL] if output_format == [string] : [EOL] args_strings += [ [string] ] [EOL] [EOL] result_dir = os . path . dirname ( output_file ) if output_file else os . path . dirname ( tex_file ) [EOL] args_strings += [ [string] + tex_file + [string] ] [EOL] [EOL] log . debug ( [string] . format ( cmd_name , args_strings ) ) [EOL] ret = simple_call ( args_strings ) [EOL] [EOL] result_file = os . path . join ( result_dir , remove_ext ( os . path . basename ( tex_file ) ) + [string] ) [EOL] if os . path . exists ( result_file ) : [EOL] shutil . move ( result_file , output_file ) [EOL] else : [EOL] raise IOError ( [string] ) [EOL] [EOL] log . debug ( [string] . format ( result_dir ) ) [EOL] cleanup ( result_dir , [string] ) [EOL] cleanup ( result_dir , [string] ) [EOL] return ret [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Callable , Any [EOL] import docstamp [EOL] import typing [EOL] import sys [EOL] [EOL] from . unicode_csv import UnicodeWriter [EOL] [EOL] if sys . version_info [ [number] ] >= [number] : [EOL] raw_input = input [EOL] [EOL] [EOL] class GoogleData : [EOL] [EOL] def getCSV ( self ) : [EOL] [docstring] [EOL] import getpass [EOL] import gspread [EOL] [EOL] user = raw_input ( [string] ) [EOL] password = getpass . getpass ( prompt = [string] ) [EOL] name = raw_input ( [string] ) [EOL] sheet = raw_input ( [string] ) [EOL] [EOL] cl = gspread . login ( user , password ) [EOL] sh = cl . open ( name ) [EOL] [EOL] if not ( sheet . strip ( ) ) : [EOL] ws = sh . sheet1 [EOL] sheet = [string] [EOL] else : [EOL] ws = sh . worksheet ( sheet ) [EOL] [EOL] filename = name + [string] + sheet + [string] [EOL] with open ( filename , [string] ) as f : [EOL] writer = UnicodeWriter ( f ) [EOL] writer . writerows ( ws . get_all_values ( ) ) [EOL] [EOL] return filename [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $docstamp.unicode_csv.UnicodeWriter$ 0 0 0 0 0 0 $docstamp.unicode_csv.UnicodeWriter$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Dict , Literal [EOL] import typing_extensions [EOL] import typing [EOL] import json [EOL] [EOL] [EOL] def translate_key_values ( adict , translations , default = [string] ) : [EOL] [docstring] [EOL] for src_key , dst_key in translations : [EOL] adict [ dst_key ] = adict . pop ( src_key , default ) [EOL] return adict [EOL] [EOL] [EOL] def json_to_dict ( json_str ) : [EOL] [docstring] [EOL] return json . JSONDecoder ( ) . decode ( json_str ) [EOL] [EOL] [EOL] class JSONMixin ( object ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def from_json_str ( cls , json_str ) : [EOL] [docstring] [EOL] dct = json_to_dict ( json_str ) [EOL] return cls ( ** dct ) [EOL] [EOL] def to_json_str ( self ) : [EOL] [docstring] [EOL] adict = dict ( vars ( self ) , sort_keys = True ) [EOL] adict [ [string] ] = self . __class__ . __name__ [EOL] return json . dumps ( adict ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . to_json_str ( ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . to_json_str ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import logging [EOL] import io [EOL] import typing [EOL] import csv [EOL] import os [EOL] import tempfile [EOL] import logging [EOL] from glob import glob [EOL] [EOL] from docstamp . config import get_temp_dir [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_extension ( filepath , check_if_exists = False ) : [EOL] [docstring] [EOL] if check_if_exists : [EOL] if not os . path . exists ( filepath ) : [EOL] err = [string] + filepath [EOL] log . error ( err ) [EOL] raise IOError ( err ) [EOL] [EOL] try : [EOL] rest , ext = os . path . splitext ( filepath ) [EOL] except : [EOL] raise [EOL] else : [EOL] return ext [EOL] [EOL] [EOL] def add_extension_if_needed ( filepath , ext , check_if_exists = False ) : [EOL] [docstring] [EOL] if not filepath . endswith ( ext ) : [EOL] filepath += ext [EOL] [EOL] if check_if_exists : [EOL] if not os . path . exists ( filepath ) : [EOL] err = [string] + filepath [EOL] log . error ( err ) [EOL] raise IOError ( err ) [EOL] [EOL] return filepath [EOL] [EOL] [EOL] def remove_ext ( filepath ) : [EOL] [docstring] [EOL] return filepath [ : filepath . rindex ( get_extension ( filepath ) ) ] [EOL] [EOL] [EOL] def get_tempfile ( suffix = [string] , dirpath = None ) : [EOL] [docstring] [EOL] if dirpath is None : [EOL] dirpath = get_temp_dir ( ) [EOL] [EOL] return tempfile . NamedTemporaryFile ( suffix = suffix , dir = dirpath ) [EOL] [EOL] [EOL] def cleanup ( workdir , extension ) : [EOL] [docstring] [EOL] [ os . remove ( f ) for f in glob ( os . path . join ( workdir , [string] + extension ) ) ] [EOL] [EOL] [EOL] def mkdir ( dirpath ) : [EOL] [docstring] [EOL] if not os . path . exists ( dirpath ) : [EOL] os . mkdir ( dirpath ) [EOL] [EOL] [EOL] def csv_to_json ( csv_filepath , json_filepath , fieldnames , ignore_first_line = True ) : [EOL] [docstring] [EOL] import csv [EOL] import json [EOL] [EOL] csvfile = open ( csv_filepath , [string] ) [EOL] jsonfile = open ( json_filepath , [string] ) [EOL] [EOL] reader = csv . DictReader ( csvfile , fieldnames ) [EOL] rows = [ ] [EOL] if ignore_first_line : [EOL] next ( reader ) [EOL] [EOL] for row in reader : [EOL] rows . append ( row ) [EOL] [EOL] json . dump ( rows , jsonfile ) [EOL] jsonfile . close ( ) [EOL] csvfile . close ( ) [EOL] [EOL] [EOL] def write_to_file ( file_path , content , encoding = None ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with open ( file_path , [string] ) as f : [EOL] f . write ( content . encode ( encoding ) ) [EOL] except : [EOL] log . exception ( [string] . format ( file_path ) ) [EOL] raise [EOL] [EOL] [EOL] def replace_file_content ( filepath , old , new , max = [number] ) : [EOL] [docstring] [EOL] with open ( filepath , [string] ) as f : [EOL] content = f . read ( ) [EOL] [EOL] content = content . replace ( old , new , max ) [EOL] with open ( filepath , [string] ) as f : [EOL] f . write ( content ) [EOL] [EOL] [EOL] def cleanup_docstamp_output ( output_dir = [string] ) : [EOL] [docstring] [EOL] suffixes = [ [string] , [string] , [string] ] [EOL] files = [ f for suf in suffixes for f in glob ( os . path . join ( output_dir , [string] . format ( suf ) ) ) ] [EOL] [ os . remove ( file ) for file in files ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , Pattern , List , Literal [EOL] import click [EOL] import typing_extensions [EOL] import typing [EOL] import csv [EOL] [docstring] [EOL] import re [EOL] import json [EOL] import logging [EOL] from csv import DictReader [EOL] [EOL] import click [EOL] [EOL] from docstamp . model import json_to_dict [EOL] [EOL] [comment] [EOL] CONTEXT_SETTINGS = dict ( help_option_names = [ [string] , [string] ] ) [EOL] UNKNOWN_OPTIONS = dict ( allow_extra_args = True , ignore_unknown_options = True ) [EOL] [EOL] [comment] [EOL] DirPath = click . Path ( file_okay = False , resolve_path = True ) [EOL] ExistingDirPath = click . Path ( exists = True , file_okay = False , resolve_path = True ) [EOL] ExistingFilePath = click . Path ( exists = True , dir_okay = False , resolve_path = True ) [EOL] UnexistingFilePath = click . Path ( dir_okay = False , resolve_path = True ) [EOL] [EOL] [EOL] [comment] [EOL] def check_not_none ( ctx , param , value ) : [EOL] if value is None : [EOL] raise click . BadParameter ( [string] . format ( value ) ) [EOL] return value [EOL] [EOL] [EOL] [comment] [EOL] class RegularExpression ( click . ParamType ) : [EOL] name = [string] [EOL] [EOL] def convert ( self , value , param , ctx ) : [EOL] try : [EOL] rex = re . compile ( value , re . IGNORECASE ) [EOL] except ValueError : [EOL] self . fail ( [string] % value , param , ctx ) [EOL] else : [EOL] return rex [EOL] [EOL] [EOL] [comment] [EOL] def echo_list ( alist ) : [EOL] for i in alist : [EOL] click . echo ( i ) [EOL] [EOL] [EOL] def get_items_from_csv ( csv_filepath ) : [EOL] [comment] [EOL] [comment] [EOL] items = { } [EOL] with open ( str ( csv_filepath ) , [string] ) as csvfile : [EOL] [EOL] reader = DictReader ( csvfile ) [EOL] [EOL] for idx , row in enumerate ( reader ) : [EOL] item = json_to_dict ( json . dumps ( row ) ) [EOL] if any ( [ item [ i ] != [string] for i in item ] ) : [EOL] items [ idx ] = item [EOL] [EOL] return items , reader . fieldnames [EOL] [EOL] [EOL] def verbose_switch ( verbose = False ) : [EOL] if verbose : [EOL] log_level = logging . DEBUG [EOL] else : [EOL] log_level = logging . INFO [EOL] [EOL] logging . getLogger ( ) . setLevel ( log_level ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.types.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.types.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.types.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.types.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import click [EOL] [EOL] import os [EOL] import math [EOL] import logging [EOL] [EOL] from docstamp . file_utils import get_extension [EOL] from docstamp . template import TextDocument [EOL] from docstamp . config import LOGGING_LVL [EOL] [EOL] from docstamp . cli . utils import ( CONTEXT_SETTINGS , verbose_switch , get_items_from_csv , ExistingFilePath , DirPath ) [EOL] [EOL] ACCEPTED_DOCS = [string] [EOL] [EOL] [EOL] [comment] [EOL] @ click . group ( context_settings = CONTEXT_SETTINGS ) def cli ( ) : [EOL] pass [EOL] [EOL] [EOL] @ cli . command ( context_settings = CONTEXT_SETTINGS ) @ click . option ( [string] , [string] , type = ExistingFilePath , required = False , help = [string] [string] [string] ) @ click . option ( [string] , [string] , type = ExistingFilePath , required = True , help = [string] [string] [string] + ACCEPTED_DOCS ) @ click . option ( [string] , [string] , type = str , multiple = True , help = [string] [string] [string] ) @ click . option ( [string] , [string] , type = DirPath , default = [string] , show_default = True , help = [string] ) @ click . option ( [string] , [string] , type = str , help = [string] ) @ click . option ( [string] , [string] , type = click . Choice ( [ [string] , [string] , [string] ] ) , default = [string] , show_default = True , help = [string] ) @ click . option ( [string] , [string] , type = click . Choice ( [ [string] , [string] , [string] ] ) , default = [string] , show_default = True , help = [string] [string] ) @ click . option ( [string] , default = [ ] , help = [string] [string] [string] ) @ click . option ( [string] , type = int , default = [number] , help = [string] ) @ click . option ( [string] , [string] , is_flag = True , help = [string] ) @ click . option ( [string] , [string] , is_flag = True , default = False , help = [string] ) def create ( input , template , field , outdir , prefix , otype , command , index , dpi , verbose , unicode_support ) : [EOL] [docstring] [EOL] logging . basicConfig ( level = LOGGING_LVL ) [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] verbose_switch ( verbose ) [EOL] [EOL] input_file = input [EOL] fields = field [EOL] [EOL] [comment] [EOL] log . debug ( [string] . format ( input_file ) ) [EOL] items , fieldnames = get_items_from_csv ( input_file ) [EOL] [EOL] [comment] [EOL] if len ( items ) == [number] : [EOL] click . echo ( [string] ) [EOL] exit ( - [number] ) [EOL] [EOL] if not fields : [EOL] [comment] [EOL] n_zeros = int ( math . floor ( math . log10 ( len ( items ) ) ) + [number] ) [EOL] else : [EOL] [comment] [EOL] for field_name in fields : [EOL] if field_name not in fieldnames : [EOL] raise ValueError ( [string] [string] . format ( field_name ) ) [EOL] [EOL] [comment] [EOL] if index : [EOL] myitems = { int ( idx ) : items [ int ( idx ) ] for idx in index } [EOL] items = myitems [EOL] log . debug ( [string] [string] . format ( index ) ) [EOL] [EOL] [comment] [EOL] if not os . path . exists ( outdir ) : [EOL] os . mkdir ( outdir ) [EOL] [EOL] [comment] [EOL] log . debug ( [string] . format ( template ) ) [EOL] template_doc = TextDocument . from_template_file ( template , command ) [EOL] log . debug ( [string] . format ( type ( template_doc ) ) ) [EOL] [EOL] [comment] [EOL] for idx in items : [EOL] item = items [ idx ] [EOL] [EOL] if not len ( fields ) : [EOL] file_name = str ( idx ) . zfill ( n_zeros ) [EOL] else : [EOL] field_values = [ ] [EOL] try : [EOL] for field_name in fields : [EOL] field_values . append ( item [ field_name ] . replace ( [string] , [string] ) ) [EOL] except : [EOL] log . exception ( [string] [string] . format ( field_name , item ) ) [EOL] exit ( - [number] ) [EOL] else : [EOL] file_name = [string] . join ( field_values ) [EOL] [EOL] log . debug ( [string] . format ( file_name , idx ) ) [EOL] try : [EOL] template_doc . fill ( item ) [EOL] except : [EOL] log . exception ( [string] . format ( idx ) ) [EOL] continue [EOL] [EOL] [comment] [EOL] file_extension = get_extension ( template ) [EOL] if prefix is None : [EOL] basename = os . path . basename ( template ) . replace ( file_extension , [string] ) [EOL] [EOL] file_name = basename + [string] + file_name [EOL] file_path = os . path . join ( outdir , file_name + [string] + otype ) [EOL] [EOL] kwargs = { [string] : otype , [string] : dpi , [string] : unicode_support } [EOL] [EOL] log . debug ( [string] . format ( file_path ) ) [EOL] try : [EOL] template_doc . render ( file_path , ** kwargs ) [EOL] except : [EOL] log . exception ( [string] . format ( file_path , item ) ) [EOL] exit ( - [number] ) [EOL] else : [EOL] log . debug ( [string] . format ( file_path ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . cli import cli [EOL]	0 0 0 0 0 0