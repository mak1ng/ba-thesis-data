from typing import Tuple , Mapping , List , NoReturn , Type , Callable , ClassVar , Any , Optional [EOL] import builtins [EOL] import typing [EOL] import src [EOL] from __future__ import annotations [EOL] import ast [EOL] from dateutil import parser as datetime_parser [EOL] import math [EOL] from typing import ( Mapping , Callable , List , Tuple , Any , NoReturn , Type , ClassVar , Optional , ) [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] class Filter : [EOL] _filters = { } [EOL] [EOL] @ classmethod def compile_filters ( cls , filter_string , filter_delimiter = None ) : [EOL] parts = filter_string . split ( filter_delimiter or [string] ) [EOL] target = parts [ [number] ] [EOL] _filters = parts [ [number] : ] if len ( target ) > [number] else None [EOL] filters = [ ] [EOL] if _filters is not None : [EOL] for _filter in _filters : [EOL] if _filter != [string] : [EOL] try : [EOL] _func , _args = _filter . split ( [string] , maxsplit = [number] ) [EOL] args = ast . literal_eval ( f" [string] { _args } [string] " ) [EOL] func = cls . _filters [ _func ] [EOL] filters . append ( ( func , args ) ) [EOL] except KeyError : [EOL] raise SyntaxError ( f' [string] { _func } [string] ' ) [EOL] except AttributeError : [EOL] raise SyntaxError ( [string] ) [EOL] except ValueError : [EOL] [comment] [EOL] filters . append ( ( cls . _filters [ _filter ] , [ ] ) ) [EOL] else : [EOL] raise SyntaxError ( [string] ) [EOL] return Filter ( target , filters ) [EOL] [EOL] @ classmethod def register ( cls , func ) : [EOL] cls . _filters [ func . __qualname__ ] = func [EOL] return func [EOL] [EOL] def __init__ ( self , target , filters ) : [EOL] self . _target = target [EOL] self . _filters = filters [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self ) [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { repr ( self . _target ) } [string] " + f" [string] { self . _filters } [string] " [EOL] [EOL] def __call__ ( self , context ) : [EOL] value = context [ self . _target ] [EOL] for func , args in self . _filters : [EOL] value = func ( value , * args ) [EOL] return value [EOL] [EOL] [EOL] [comment] [EOL] class Link : [EOL] @ Filter . register def as_name ( val , target ) : [EOL] return f" [string] { val } [string] { target } [string] " [EOL] [EOL] @ Filter . register def as_target ( val , name ) : [EOL] return f" [string] { name } [string] { val } [string] " [EOL] [EOL] [EOL] @ Filter . register def get_mul ( val , target ) : [EOL] return [ d [ target if isinstance ( d , dict ) else int ( target ) ] for d in val if target in d ] [EOL] [EOL] [EOL] @ Filter . register def get ( val , target ) : [EOL] return val [ target if isinstance ( val , dict ) else int ( target ) ] [EOL] [EOL] [EOL] @ Filter . register def ul ( vals ) : [EOL] return [string] . join ( f" [string] { val }" for val in vals ) [EOL] [EOL] [EOL] @ Filter . register def ol ( vals ) : [EOL] return [string] . join ( f"{ i + [number] } [string] { val }" for i , val in enumerate ( vals ) ) [EOL] [EOL] [EOL] @ Filter . register def bold ( val ) : [EOL] return f" [string] { val } [string] " [EOL] [EOL] [EOL] @ Filter . register def italic ( val ) : [EOL] return f" [string] { val } [string] " [EOL] [EOL] [EOL] @ Filter . register def strikethrough ( val ) : [EOL] return f" [string] { val } [string] " [EOL] [EOL] [EOL] @ Filter . register def heading ( val , level = [number] ) : [EOL] return ( [string] * int ( level ) ) + f" [string] { val }" [EOL] [EOL] [EOL] @ Filter . register def tabularize ( vals , row_format ) : [EOL] from src . parsing import parse [EOL] from src . walking import walk [EOL] [EOL] columns = [ parse ( f" [string] { column } [string] " , filter_delimiter = [string] ) for column in row_format . split ( [string] ) ] [EOL] headings = [ column . children [ [number] ] . func . _target for column in columns ] [EOL] [EOL] if len ( vals ) == [number] : [EOL] return [string] [EOL] [EOL] def row ( coll , fill = [string] ) : [EOL] return [string] + [string] . join ( fill + str ( val ) + fill for val in coll ) + [string] [EOL] [EOL] if isinstance ( vals , dict ) and all ( isinstance ( val , dict ) for val in vals . values ( ) ) : [EOL] vals = sorted ( [ { headings [ [number] ] : key , ** val } for key , val in vals . items ( ) ] , key = lambda x : x [ headings [ [number] ] ] , ) [EOL] headings = headings [EOL] [EOL] table = row ( headings ) + row ( ( [string] * len ( heading ) for heading in headings ) , fill = [string] ) [EOL] for entry in vals : [EOL] new_row = row ( walk ( column , entry , fail_default = [string] ) . strip ( ) . replace ( [string] , [string] ) for column in columns ) [EOL] table += new_row [EOL] return table [EOL] [EOL] [EOL] @ Filter . register def date ( val , output_format = [string] ) : [EOL] return datetime_parser . parse ( val ) . strftime ( output_format ) [EOL] [EOL] [EOL] @ Filter . register def frmt ( val , output_format ) : [EOL] return f" [string] { output_format } [string] " . format ( val ) [EOL] [EOL] [EOL] @ Filter . register def render_bool ( val ) : [EOL] return [ [string] , [string] ] [ bool ( val ) ] [EOL] [EOL] [EOL] @ Filter . register def adjust ( val , adjustment , precision = [number] ) : [EOL] if adjustment == [string] : [EOL] return math . ceil ( float ( val ) ) [EOL] elif adjustment == [string] : [EOL] return math . floor ( float ( val ) ) [EOL] elif adjustment == [string] : [EOL] return round ( float ( val ) , int ( precision ) ) [EOL] else : [EOL] raise SyntaxError ( f' [string] { adjustment } [string] ' ) [EOL] [EOL] [EOL] escape_sequences = { [string] : [string] } [EOL] [EOL] [EOL] @ Filter . register def join ( vals , delim , escape = None ) : [EOL] if escape and delim in Filter . escape_sequences : [EOL] delim = escape_sequences [ delim ] [EOL] return delim . join ( vals ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $Filter$ 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Mapping[builtins.str,typing.Any]$ 0 $Filter$ 0 0 0 0 0 0 0 0 0 $Filter$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import argparse [EOL] import typing [EOL] import src [EOL] import argparse [EOL] import json [EOL] import dill as pickle [EOL] [EOL] from src . parsing import parse [EOL] from src . walking import walk [EOL] [EOL] [EOL] def _compile ( args ) : [EOL] ast = parse ( args . file . read ( ) ) [EOL] print ( ast . pp ( ) ) [EOL] out_path = args . file . name [ : : - [number] ] . split ( [string] , maxsplit = [number] ) [ [number] ] [ : : - [number] ] + [string] [EOL] with open ( out_path , [string] ) as f : [EOL] pickle . dump ( ast , f ) [EOL] [EOL] [EOL] def _apply ( args ) : [EOL] data = json . load ( args . data ) [EOL] ast = pickle . load ( args . template ) [EOL] res = walk ( ast , data ) [EOL] args . output . write ( res ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( prog = [string] ) [EOL] subparsers = parser . add_subparsers ( help = [string] ) [EOL] [EOL] compile_parser = subparsers . add_parser ( [string] , aliases = [ [string] ] , help = [string] ) [EOL] compile_parser . add_argument ( [string] , type = argparse . FileType ( mode = [string] , encoding = [string] ) , help = [string] , ) [EOL] compile_parser . set_defaults ( func = _compile ) [EOL] [EOL] apply_parser = subparsers . add_parser ( [string] , aliases = [ [string] ] , help = [string] ) [EOL] apply_parser . add_argument ( [string] , type = argparse . FileType ( mode = [string] , encoding = [string] ) , help = [string] , ) [EOL] apply_parser . add_argument ( [string] , type = argparse . FileType ( mode = [string] ) , help = [string] ) [EOL] apply_parser . add_argument ( [string] , type = argparse . FileType ( mode = [string] , encoding = [string] ) , help = [string] ) [EOL] apply_parser . set_defaults ( func = _apply ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] args . func ( args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse._SubParsersAction$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 $argparse._SubParsersAction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 $argparse._SubParsersAction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0
from typing import Tuple , Dict , Any , Optional [EOL] import builtins [EOL] import typing [EOL] import src [EOL] from __future__ import annotations [EOL] from typing import Optional [EOL] [EOL] from src . parsing import Types , Node , Context [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] def walk ( root , context , * , fail_default = None ) : [EOL] try : [EOL] output = [string] [EOL] last_conditional = None [EOL] for node in root . children : [EOL] if node . type is Types . TEXT : [EOL] output += node . contents [EOL] elif node . type is Types . STAT : [EOL] output += str ( node . func ( context ) ) [EOL] elif node . type is Types . CONTEXT_INJECT : [EOL] names , values = node . func ( context ) [EOL] _context = dict ( context . items ( ) , ** { name : value for name , value in zip ( names , values ) } ) [EOL] output += walk ( node , _context ) [EOL] elif node . type is Types . ITERATE : [EOL] names , iterable = node . func ( context ) [EOL] for vals in iterable : [EOL] _context = dict ( context . items ( ) , ** { names [ i ] : val for i , val in enumerate ( vals ) } ) [EOL] output += walk ( node , _context ) [EOL] elif node . type is Types . CONDITIONAL : [EOL] last_conditional = node . func ( context ) [EOL] if last_conditional : [EOL] output += walk ( node , context ) [EOL] elif node . type is Types . ALTERNATE_CONDITIONAL : [EOL] res = node . func ( context ) [EOL] if not last_conditional and res : [EOL] output += walk ( node , context ) [EOL] last_conditional = res [EOL] elif node . type is Types . ALTERNATIVE : [EOL] if not last_conditional : [EOL] output += walk ( node , context ) [EOL] return output [EOL] except : [EOL] if fail_default is None : [EOL] raise [EOL] else : [EOL] return fail_default [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0