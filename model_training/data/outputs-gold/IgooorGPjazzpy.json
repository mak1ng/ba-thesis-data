import jazzpy [EOL] [docstring] [EOL] from jazzpy import JazzPy [EOL] [EOL] if __name__ == [string] : [EOL] game = JazzPy ( ) [EOL] game . play ( ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.main.JazzPy$ 0 0 0 0 0 $jazzpy.main.JazzPy$ 0 0 0 0 0 0
[docstring] [EOL] from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] , url = [string] , author = [string] , author_email = [string] , description = [string] , packages = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , long_description = open ( [string] ) . read ( ) , zip_safe = False , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from . main import JazzPy [comment] [EOL]	0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pygame [EOL] import jazzpy [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] [EOL] import pygame [EOL] from jazzpy . levels . diamondus . diamondus_level_one import DiamondusLevelOne [EOL] from jazzpy . scenes . manager import SceneManager [EOL] from jazzpy . scenes . play_scene import PlayScene [EOL] from jazzpy . settings . general import DEBUG [EOL] from jazzpy . settings . general import PROJECT_ROOT_DIR [EOL] from jazzpy . settings . general import SCREEN_CAPTION [EOL] from jazzpy . settings . general import VIDEO_OPTIONS [EOL] [EOL] [EOL] class JazzPy : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] pygame . init ( ) [EOL] pygame . mixer . init ( ) [EOL] [EOL] [comment] [EOL] self . screen = self . _load_screen ( ) [EOL] self . scene_manager = self . _load_scene_manager ( ) [EOL] [EOL] self . clock = pygame . time . Clock ( ) [EOL] self . is_gameover = False [EOL] [EOL] @ classmethod def _load_screen ( cls ) : [EOL] [docstring] [EOL] screen_flags = pygame . FULLSCREEN [EOL] [EOL] if DEBUG : [EOL] screen_flags = [number] [EOL] [EOL] screen = pygame . display . set_mode ( ( VIDEO_OPTIONS [ [string] ] , VIDEO_OPTIONS [ [string] ] ) , screen_flags ) [EOL] [EOL] [comment] [EOL] pygame . display . set_caption ( SCREEN_CAPTION ) [EOL] [EOL] return screen [EOL] [EOL] @ classmethod def _load_scene_manager ( cls ) : [EOL] [docstring] [EOL] level_spritesheet_file = os . path . join ( PROJECT_ROOT_DIR , [string] ) [EOL] level_platforms_file = os . path . join ( PROJECT_ROOT_DIR , [string] ) [EOL] level_music_file = os . path . join ( PROJECT_ROOT_DIR , [string] ) [EOL] [EOL] diamondus_level_one = DiamondusLevelOne ( spritesheet_file = level_spritesheet_file , spritesheet_matrix_dimensions = ( [number] , [number] ) , level_platforms_file = level_platforms_file , level_music_file = level_music_file , platforms_width = [number] , platforms_height = [number] , ) [EOL] [EOL] diamondus_one_scene = PlayScene ( diamondus_level_one ) [EOL] [EOL] [comment] [EOL] scene_manager = SceneManager ( initial_scene = diamondus_one_scene ) [EOL] [EOL] return scene_manager [EOL] [EOL] def _before_gameover_hook ( self ) : [EOL] [docstring] [EOL] self . is_gameover = True [EOL] [EOL] pygame . quit ( ) [EOL] [EOL] def _check_for_gameover ( self ) : [EOL] [docstring] [EOL] if pygame . event . get ( pygame . QUIT ) : [EOL] self . _before_gameover_hook ( ) [EOL] [EOL] if self . scene_manager . current_scene_captured_quit_event ( ) : [EOL] self . _before_gameover_hook ( ) [EOL] [EOL] def _wait_for_next_frame ( self ) : [EOL] [docstring] [EOL] self . clock . tick ( VIDEO_OPTIONS [ [string] ] ) [EOL] [EOL] [comment] [EOL] [EOL] def _update_state ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . screen . fill ( ( [number] , [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] self . scene_manager . update_current_scene ( ) [EOL] [EOL] [comment] [EOL] pygame . display . flip ( ) [EOL] [EOL] def play ( self ) : [EOL] [docstring] [EOL] while not self . is_gameover : [EOL] [EOL] [comment] [EOL] self . _wait_for_next_frame ( ) [EOL] [EOL] [comment] [EOL] self . _update_state ( ) [EOL] [EOL] [comment] [EOL] self . _check_for_gameover ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $pygame.Surface$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $jazzpy.scenes.manager.SceneManager$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.levels.diamondus.diamondus_level_one.DiamondusLevelOne$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.scenes.play_scene.PlayScene$ 0 0 0 $jazzpy.levels.diamondus.diamondus_level_one.DiamondusLevelOne$ 0 0 0 0 0 $jazzpy.scenes.manager.SceneManager$ 0 0 0 0 0 $jazzpy.scenes.play_scene.PlayScene$ 0 0 0 0 $jazzpy.scenes.manager.SceneManager$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Tuple , Dict , Union , Any [EOL] import jazzpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import os [EOL] [EOL] import pygame [EOL] from jazzpy . interfaces . observable import ObservableMixin [EOL] from jazzpy . settings . general import PROJECT_ROOT_DIR [EOL] from jazzpy . settings . jazz import DEFAULT_POSITION_SPRITE [EOL] from jazzpy . settings . jazz import FALLING_SPRITE_1 [EOL] from jazzpy . settings . jazz import JAZZ_DIMENSIONS [EOL] from jazzpy . settings . jazz import JAZZ_OBSERVABLE_ID [EOL] from jazzpy . settings . jazz import JUMPING_SPRITE_1 [EOL] from jazzpy . settings . jazz import RUNNING_SPRITES [EOL] from jazzpy . settings . jazz import SHOOTING_SPRITE_1 [EOL] from jazzpy . settings . jazz import WALKING_SPRITE_1 [EOL] from jazzpy . settings . jazz import WALKING_SPRITE_2 [EOL] from jazzpy . settings . jazz import WALKING_SPRITE_3 [EOL] from jazzpy . settings . jazz import WALKING_SPRITE_4 [EOL] from jazzpy . settings . physics import ACCELERATION_X [EOL] from jazzpy . settings . physics import GRAVITY_SPEED [EOL] from jazzpy . settings . physics import INITIAL_JUMP_Y_SPEED [EOL] from jazzpy . settings . physics import INITIAL_SHOOTING_DELAY [EOL] from jazzpy . settings . physics import MAX_SPEED_X [EOL] from jazzpy . sprites . misc . bullet import Bullet [EOL] from jazzpy . sprites . misc . hud import Hud [EOL] from jazzpy . support . spritesheet import SpriteSheet [EOL] [EOL] [EOL] class Jazz ( pygame . sprite . Sprite , ObservableMixin ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , level_x , level_y , hud ) : [EOL] [docstring] [EOL] [comment] [EOL] super ( pygame . sprite . Sprite , self ) . __init__ ( ) [EOL] super ( ObservableMixin , self ) . __init__ ( ) [EOL] [EOL] [comment] [EOL] self . sprite_sheet = SpriteSheet ( os . path . join ( PROJECT_ROOT_DIR , [string] ) ) [EOL] [EOL] [comment] [EOL] self . add_observer ( hud ) [EOL] [EOL] [comment] [EOL] self . speed_x , self . speed_y = [number] , [number] [EOL] self . accerelation_x , self . acceleration_y = [number] , [number] [EOL] [EOL] [comment] [EOL] self . image = self . sprite_sheet . get_image ( DEFAULT_POSITION_SPRITE , dimensions = JAZZ_DIMENSIONS ) [EOL] [EOL] [comment] [EOL] self . rect = self . image . get_rect ( topleft = ( level_x , level_y ) ) [EOL] [EOL] [comment] [EOL] self . bullets = pygame . sprite . Group ( ) [EOL] [EOL] [comment] [EOL] self . is_running = False [EOL] self . is_jumping = False [EOL] self . is_falling = False [EOL] self . is_on_floor = False [EOL] self . is_shooting = False [EOL] self . direction = [string] [EOL] self . current_running_sprite = [number] [EOL] [EOL] [comment] [EOL] self . health = [number] [EOL] self . current_weapon = [string] [EOL] self . lives = [number] [EOL] self . player_score = [number] [EOL] [EOL] [comment] [EOL] self . oldtime = [number] [EOL] [EOL] def _get_running_sprite ( self ) : [EOL] [docstring] [EOL] [EOL] tpl_sprite = RUNNING_SPRITES [ self . current_running_sprite ] [EOL] [EOL] self . current_running_sprite += [number] [EOL] self . current_running_sprite = ( [number] if self . current_running_sprite > [number] else self . current_running_sprite ) [EOL] [EOL] return tpl_sprite [EOL] [EOL] def _change_sprite ( self , dimensions = JAZZ_DIMENSIONS ) : [EOL] [docstring] [EOL] if [number] < abs ( self . speed_x ) < [number] : [EOL] self . image = self . sprite_sheet . get_image ( WALKING_SPRITE_1 , dimensions = dimensions ) [EOL] [EOL] if [number] <= abs ( self . speed_x ) < [number] : [EOL] self . image = self . sprite_sheet . get_image ( WALKING_SPRITE_2 , dimensions = dimensions ) [EOL] [EOL] if [number] <= abs ( self . speed_x ) < [number] : [EOL] self . image = self . sprite_sheet . get_image ( WALKING_SPRITE_3 , dimensions = dimensions ) [EOL] [EOL] if [number] <= abs ( self . speed_x ) < [number] : [EOL] self . image = self . sprite_sheet . get_image ( WALKING_SPRITE_4 , dimensions = dimensions ) [EOL] [EOL] if abs ( self . speed_x ) >= [number] : [EOL] [comment] [EOL] self . image = self . sprite_sheet . get_image ( self . _get_running_sprite ( ) , dimensions = dimensions ) [EOL] [EOL] if self . speed_x == [number] : [EOL] self . image = self . sprite_sheet . get_image ( DEFAULT_POSITION_SPRITE , dimensions = dimensions ) [EOL] [EOL] if self . is_jumping : [EOL] self . image = self . sprite_sheet . get_image ( JUMPING_SPRITE_1 , dimensions = dimensions ) [EOL] [EOL] if self . is_falling : [EOL] self . image = self . sprite_sheet . get_image ( FALLING_SPRITE_1 , dimensions = dimensions ) [EOL] [EOL] if self . is_shooting and not self . is_falling and not self . is_jumping and not self . is_running : [EOL] self . image = self . sprite_sheet . get_image ( SHOOTING_SPRITE_1 , dimensions = dimensions ) [EOL] [EOL] [comment] [EOL] if self . direction == [string] : [EOL] self . image = pygame . transform . flip ( self . image , True , False ) [EOL] [EOL] def _platform_collision_callback ( self , speed_x , speed_y , platform_sprite ) : [EOL] [docstring] [EOL] [comment] [EOL] if speed_x > [number] : [EOL] [comment] [EOL] self . rect . right = platform_sprite . rect . left [EOL] self . is_running = False [EOL] self . speed_x = [number] [EOL] [EOL] if speed_x < [number] : [EOL] self . rect . left = platform_sprite . rect . right [EOL] self . is_running = False [EOL] self . speed_x = [number] [EOL] [EOL] if speed_y > [number] : [EOL] self . rect . bottom = platform_sprite . rect . top [EOL] self . is_on_floor = True [EOL] self . is_jumping = False [EOL] self . is_falling = False [EOL] self . speed_y = [number] [EOL] [EOL] if speed_y < [number] : [EOL] [comment] [EOL] self . is_jumping = False [EOL] self . rect . top = platform_sprite . rect . bottom [EOL] self . is_falling = True [EOL] [EOL] def _enemy_collision_callback ( self , enemy_sprite ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def _detect_collision ( self , sprite_collision_candidates , candidate_type , is_x_axis ) : [EOL] [docstring] [EOL] [comment] [EOL] collision_sprites = pygame . sprite . spritecollide ( self , sprite_collision_candidates , dokill = False , collided = pygame . sprite . collide_rect ) [EOL] [EOL] for collision_sprite in collision_sprites : [EOL] [comment] [EOL] if candidate_type == [string] and collision_sprite . is_collidable : [EOL] [EOL] if is_x_axis : [EOL] self . _platform_collision_callback ( self . speed_x , [number] , collision_sprite ) [EOL] else : [EOL] self . _platform_collision_callback ( [number] , self . speed_y , collision_sprite ) [EOL] [EOL] [comment] [EOL] self . _change_sprite ( ) [EOL] [EOL] def _move_x_axis ( self , left , right ) : [EOL] [docstring] [EOL] [comment] [EOL] if right : [EOL] self . is_running = True [EOL] self . direction = [string] [EOL] self . speed_x += ACCELERATION_X [EOL] [EOL] if self . speed_x > MAX_SPEED_X : [EOL] self . speed_x = MAX_SPEED_X [EOL] [EOL] elif left : [EOL] self . is_running = True [EOL] self . direction = [string] [EOL] self . speed_x -= ACCELERATION_X [EOL] [EOL] if abs ( self . speed_x ) > MAX_SPEED_X : [EOL] self . speed_x = - MAX_SPEED_X [EOL] [EOL] elif not ( left or right ) : [EOL] if self . speed_x > [number] : [EOL] self . speed_x -= [number] * ACCELERATION_X [EOL] self . speed_x = [number] if self . speed_x < [number] else self . speed_x [EOL] [EOL] if self . speed_x < [number] : [EOL] self . speed_x += [number] * ACCELERATION_X [EOL] self . speed_x = [number] if self . speed_x > [number] else self . speed_x [EOL] [EOL] if self . speed_x == [number] : [EOL] self . is_running = False [EOL] [EOL] self . rect . right += self . speed_x [EOL] [EOL] def _move_y_axis ( self , alt ) : [EOL] [docstring] [EOL] if alt and self . is_on_floor : [EOL] self . is_jumping = True [EOL] self . speed_y = - INITIAL_JUMP_Y_SPEED [comment] [EOL] [EOL] [comment] [EOL] if not self . is_on_floor : [EOL] self . speed_y += GRAVITY_SPEED [comment] [EOL] [EOL] self . is_on_floor = False [EOL] [EOL] if self . speed_y > [number] : [EOL] self . is_falling = True [EOL] [EOL] self . rect . bottom += self . speed_y [EOL] [EOL] def _change_shooting_state ( self , space ) : [EOL] [docstring] [EOL] self . is_shooting = bool ( space ) [EOL] [EOL] if self . is_shooting : [EOL] [EOL] newtime = pygame . time . get_ticks ( ) [EOL] [EOL] if self . oldtime == [number] or newtime - self . oldtime > INITIAL_SHOOTING_DELAY : [EOL] [EOL] if newtime - self . oldtime < [number] : [EOL] if self . direction == [string] : [EOL] bullet = Bullet ( self . rect . midright [ [number] ] , self . rect . midright [ [number] ] + [number] , self . direction ) [EOL] [EOL] else : [EOL] bullet = Bullet ( self . rect . midleft [ [number] ] , self . rect . midleft [ [number] ] + [number] , self . direction ) [EOL] [EOL] self . bullets . add ( bullet ) [EOL] [EOL] self . oldtime = pygame . time . get_ticks ( ) [EOL] [EOL] def update ( self , pressed_keys , platforms ) : [EOL] [docstring] [EOL] left , right , alt , space = pressed_keys [EOL] [EOL] self . _move_x_axis ( left , right ) [EOL] self . _detect_collision ( platforms , [string] , is_x_axis = True ) [EOL] [EOL] self . _move_y_axis ( alt ) [EOL] self . _detect_collision ( platforms , [string] , is_x_axis = False ) [EOL] [EOL] self . _change_shooting_state ( space ) [EOL] [EOL] [comment] [EOL] observable_state = { [string] : self . lives , [string] : [number] , [string] : self . current_weapon , [string] : self . health , [string] : self . player_score , } [EOL] [EOL] self . _notify_observers ( observable_state = observable_state , observable_id = JAZZ_OBSERVABLE_ID ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $jazzpy.sprites.misc.hud.Hud$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.support.spritesheet.SpriteSheet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.sprites.misc.hud.Hud$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.support.spritesheet.SpriteSheet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.sprites.misc.bullet.Bullet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.sprites.misc.bullet.Bullet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.sprites.misc.bullet.Bullet$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0
	0
	0
[docstring] [EOL] import pygame [EOL] [EOL] [EOL] class Platform ( pygame . sprite . Sprite ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , level_x , level_y , image , is_collidable = True , * groups ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( * groups ) [EOL] [EOL] self . image = image [EOL] self . is_collidable = is_collidable [EOL] self . rect = pygame . Rect ( level_x , level_y , image . get_width ( ) , image . get_height ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import jazzpy [EOL] [docstring] [EOL] import os [EOL] [EOL] import pygame [EOL] from jazzpy . settings . bullet import BLASTER_SPRITE [EOL] from jazzpy . settings . bullet import BULLET_SPEED [EOL] from jazzpy . settings . bullet import EXPLOSION_SPRITES [EOL] from jazzpy . settings . general import PROJECT_ROOT_DIR [EOL] from jazzpy . support . spritesheet import SpriteSheet [EOL] [EOL] [EOL] class Bullet ( pygame . sprite . Sprite ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , level_x , level_y , direction ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] [comment] [EOL] self . sprite_sheet = SpriteSheet ( os . path . join ( PROJECT_ROOT_DIR , [string] ) ) [EOL] self . direction = direction [EOL] self . x , self . y = level_x , level_y [EOL] self . has_hit = False [EOL] [EOL] [comment] [EOL] self . image = self . sprite_sheet . get_image ( BLASTER_SPRITE ) [EOL] self . rect = self . image . get_rect ( center = ( self . x , self . y ) ) [EOL] [EOL] if self . direction == [string] : [EOL] self . speed = BULLET_SPEED [EOL] else : [EOL] self . speed = - BULLET_SPEED [EOL] [EOL] def update ( self , platforms ) : [EOL] [docstring] [EOL] if self . direction == [string] : [EOL] self . rect . right += BULLET_SPEED [EOL] else : [EOL] self . rect . left -= BULLET_SPEED [EOL] [EOL] self . collide ( self . speed , [number] , platforms ) [EOL] [EOL] def collide ( self , speed_x , speed_y , platforms ) : [EOL] [docstring] [EOL] for platform in platforms : [EOL] [EOL] if pygame . sprite . collide_rect ( self , platform ) and platform . is_collidable : [EOL] [EOL] if speed_x > [number] : [EOL] [EOL] self . rect . right = platform . rect . left [EOL] self . has_hit = True [EOL] [EOL] if speed_x < [number] : [EOL] [EOL] self . rect . left = platform . rect . right [EOL] self . has_hit = True [EOL] [EOL] self . _change_sprite ( ) [EOL] [EOL] def _change_sprite ( self ) : [EOL] [docstring] [EOL] self . image = self . sprite_sheet . get_image ( EXPLOSION_SPRITES [ [number] ] ) [EOL] self . rect = self . rect . move ( - [number] , - [number] ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.support.spritesheet.SpriteSheet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.support.spritesheet.SpriteSheet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , Any [EOL] import pygame [EOL] import jazzpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import os [EOL] from typing import Dict [EOL] from typing import Tuple [EOL] [EOL] import pygame [EOL] from jazzpy . interfaces . observable import ObserverMixin [EOL] from jazzpy . settings . general import PROJECT_ROOT_DIR [EOL] from jazzpy . settings . general import VIDEO_OPTIONS [EOL] from jazzpy . settings . hud import DEFAULT_SPRITESHEET_GOLDEN_NUMBER_DIMENSIONS [EOL] from jazzpy . settings . hud import GOLDEN_NUMBERS_ON_SCREEN_DIMENSIONS [EOL] from jazzpy . settings . hud import HUD_HEIGHT [EOL] from jazzpy . settings . hud import HUD_SPRITESHEET_POSITION [EOL] from jazzpy . settings . jazz import JAZZ_OBSERVABLE_ID [EOL] from jazzpy . support . spritesheet import SpriteSheet [EOL] [EOL] [EOL] class Hud ( pygame . sprite . Sprite , ObserverMixin ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] [comment] [EOL] self . sprite_sheet = SpriteSheet ( os . path . join ( PROJECT_ROOT_DIR , [string] ) ) [EOL] [EOL] self . golden_numbers_spritesheet = SpriteSheet ( os . path . join ( PROJECT_ROOT_DIR , [string] ) , spritesheet_matrix_dimensions = ( [number] , [number] ) , default_sprite_width = DEFAULT_SPRITESHEET_GOLDEN_NUMBER_DIMENSIONS [ [string] ] , default_sprite_height = DEFAULT_SPRITESHEET_GOLDEN_NUMBER_DIMENSIONS [ [string] ] , ) [EOL] [EOL] self . image = self . sprite_sheet . get_image ( HUD_SPRITESHEET_POSITION , dimensions = ( VIDEO_OPTIONS [ [string] ] , HUD_HEIGHT ) ) [EOL] [EOL] @ classmethod def get_position ( cls ) : [EOL] return [number] , VIDEO_OPTIONS [ [string] ] - HUD_HEIGHT [EOL] [EOL] def _get_golden_number_image ( self , number , width = None , height = None ) : [EOL] if width is None : [EOL] width = GOLDEN_NUMBERS_ON_SCREEN_DIMENSIONS [ [string] ] [EOL] [EOL] if height is None : [EOL] height = GOLDEN_NUMBERS_ON_SCREEN_DIMENSIONS [ [string] ] [EOL] [EOL] golden_number_image_surface = self . golden_numbers_spritesheet . get_image_by_row_and_col ( [number] , number , dimensions = ( width , height ) ) [EOL] [EOL] return golden_number_image_surface [EOL] [EOL] def update ( self , observable_state , observable_id ) : [EOL] [docstring] [EOL] if observable_id == JAZZ_OBSERVABLE_ID : [EOL] jazz_lives = observable_state . get ( [string] ) [EOL] self . image . blit ( self . _get_golden_number_image ( jazz_lives ) , dest = ( [number] , [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.support.spritesheet.SpriteSheet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.support.spritesheet.SpriteSheet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.support.spritesheet.SpriteSheet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pygame.Surface$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Optional , Tuple [EOL] import jazzpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from abc import ABC [EOL] from abc import abstractmethod [EOL] from typing import List [EOL] from typing import Optional [EOL] from typing import Tuple [EOL] [EOL] from jazzpy . exceptions . levels import CorruptedLevelFile [EOL] from jazzpy . exceptions . levels import MissingJazzInitialPositionOnLevelfile [EOL] from jazzpy . settings . levels import DEFAULT_SPRITESHEET_JAZZ_CHARCODE [EOL] from jazzpy . settings . levels import DEFAULT_SPRITESHEET_LEVELS_CHARCODE_LENGTH [EOL] from jazzpy . settings . levels import DEFAULT_SPRITESHEET_NO_PLATFORM_CHARCODE [EOL] from jazzpy . sprites . platforms . platforms import Platform [EOL] from jazzpy . support . spritesheet import SpriteSheet [EOL] [EOL] [EOL] class Level ( ABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , spritesheet_file , level_platforms_file , level_music_file , platforms_width , platforms_height , spritesheet_matrix_dimensions = None , ) : [EOL] [docstring] [EOL] self . sprite_sheet = SpriteSheet ( spritesheet_file , spritesheet_matrix_dimensions = spritesheet_matrix_dimensions ) [EOL] self . level_platforms_file = level_platforms_file [EOL] self . level_music_file = level_music_file [EOL] self . platforms_width = platforms_width [EOL] self . platforms_height = platforms_height [EOL] self . jazz_initial_x = - [number] [EOL] self . jazz_initial_y = - [number] [EOL] self . jazz_level_char_code = DEFAULT_SPRITESHEET_JAZZ_CHARCODE [EOL] self . no_platform_level_char_code = DEFAULT_SPRITESHEET_NO_PLATFORM_CHARCODE [EOL] [EOL] [comment] [EOL] self . total_level_width = [number] [EOL] self . total_level_height = [number] [EOL] self . platforms = [ ] [EOL] [EOL] def build ( self ) : [EOL] [docstring] [EOL] line_number = [number] [EOL] [EOL] with open ( self . level_platforms_file ) as fileobj : [EOL] level_x = [number] [EOL] level_y = [number] [EOL] [EOL] for line in fileobj : [EOL] [comment] [EOL] line_number += [number] [EOL] line = line . strip ( [string] ) [EOL] [EOL] for i in range ( [number] , len ( line ) , DEFAULT_SPRITESHEET_LEVELS_CHARCODE_LENGTH ) : [EOL] [EOL] level_char_code = line [ i : i + DEFAULT_SPRITESHEET_LEVELS_CHARCODE_LENGTH ] [comment] [EOL] [EOL] if len ( level_char_code ) != DEFAULT_SPRITESHEET_LEVELS_CHARCODE_LENGTH : [EOL] raise CorruptedLevelFile ( f" [string] { line_number } [string] " ) [EOL] [EOL] platform = self . level_char_code_to_platform ( level_char_code , level_x , level_y ) [EOL] [EOL] if platform is not None : [EOL] self . platforms . append ( platform ) [EOL] [EOL] level_x += self . platforms_width [EOL] [EOL] [comment] [EOL] self . total_level_width = level_x [EOL] [EOL] [comment] [EOL] level_x = [number] [EOL] level_y += self . platforms_height [EOL] [EOL] [comment] [EOL] self . total_level_height = level_y [EOL] [EOL] if self . jazz_initial_x == - [number] or self . jazz_initial_y == - [number] : [EOL] raise MissingJazzInitialPositionOnLevelfile ( [string] ) [EOL] [EOL] @ abstractmethod def level_char_code_to_platform ( self , level_char_code , level_x , level_y ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $jazzpy.support.spritesheet.SpriteSheet$ 0 0 0 $builtins.str$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[jazzpy.sprites.platforms.platforms.Platform]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Optional[jazzpy.sprites.platforms.platforms.Platform]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Optional[jazzpy.sprites.platforms.platforms.Platform]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[jazzpy.sprites.platforms.platforms.Platform]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[jazzpy.sprites.platforms.platforms.Platform]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Union , Any , Literal , Optional , Dict , Tuple [EOL] import typing_extensions [EOL] import jazzpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Dict [EOL] from typing import Optional [EOL] [EOL] from jazzpy . levels . level import Level [EOL] from jazzpy . sprites . platforms . platforms import Platform [EOL] [EOL] [EOL] class DiamondusLevelOne ( Level ) : [EOL] [docstring] [EOL] [EOL] def _get_level_char_code_info ( self , level_char_code ) : [EOL] [docstring] [EOL] [comment] [EOL] spritesheet_to_use = self . sprite_sheet if level_char_code [ [number] ] == [string] else self . sprite_sheet [EOL] is_platform_collidable = True if level_char_code [ [number] ] == [string] else False [EOL] [EOL] spritesheet_row = int ( level_char_code [ [number] : [number] ] ) [EOL] spritesheet_col = int ( level_char_code [ [number] : [number] ] ) [EOL] [EOL] return { [string] : spritesheet_to_use , [string] : is_platform_collidable , [string] : spritesheet_row , [string] : spritesheet_col , } [EOL] [EOL] def level_char_code_to_platform ( self , level_char_code , level_x , level_y ) : [EOL] [docstring] [EOL] if level_char_code == self . no_platform_level_char_code : [EOL] return None [EOL] [EOL] [comment] [EOL] if level_char_code == self . jazz_level_char_code : [EOL] self . jazz_initial_x , self . jazz_initial_y = level_x , level_y [EOL] [EOL] return None [EOL] [EOL] platform_dimensions = ( self . platforms_width , self . platforms_height ) [EOL] level_char_code_info = self . _get_level_char_code_info ( level_char_code ) [EOL] [EOL] if level_char_code_info : [EOL] image = self . sprite_sheet . get_image_by_row_and_col ( spritesheet_row = level_char_code_info [ [string] ] , spritesheet_col = level_char_code_info [ [string] ] , dimensions = platform_dimensions , ) [EOL] [EOL] return Platform ( level_x , level_y , image , is_collidable = level_char_code_info [ [string] ] , ) [EOL] [EOL] return None [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $jazzpy.support.spritesheet.SpriteSheet$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.support.spritesheet.SpriteSheet$ 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Optional[jazzpy.sprites.platforms.platforms.Platform]$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] [EOL] DEBUG = True [EOL] [EOL] SCREEN_CAPTION = [string] [EOL] [EOL] VIDEO_OPTIONS = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] PROJECT_ROOT_DIR = os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] BLASTER_SPRITE = ( [number] , [number] , [number] , [number] ) [EOL] TOASTER_SPRITE = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] EXPLOSION_SPRITES = ( ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ) [EOL] [EOL] BULLET_SPEED = [number] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0
from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] DEFAULT_SPRITESHEET_LEVELS_CHARCODE_LENGTH = [number] [EOL] [EOL] DEFAULT_SPRITESHEET_JAZZ_CHARCODE = [string] [EOL] DEFAULT_SPRITESHEET_NO_PLATFORM_CHARCODE = [string] [EOL] [EOL] DEFAULT_SPRITESHEET_TILE_DIMENSIONS = { [string] : [number] , [string] : [number] } [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Tuple , Literal [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] JAZZ_DIMENSIONS = ( [number] , [number] ) [EOL] [EOL] DEFAULT_POSITION_SPRITE = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] WALKING_SPRITE_1 = ( [number] , [number] , [number] , [number] ) [EOL] WALKING_SPRITE_2 = ( [number] , [number] , [number] , [number] ) [EOL] WALKING_SPRITE_3 = ( [number] , [number] , [number] , [number] ) [EOL] WALKING_SPRITE_4 = ( [number] , [number] , [number] , [number] ) [EOL] WALKING_SPRITE_5 = ( [number] , [number] , [number] , [number] ) [EOL] WALKING_SPRITE_6 = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] RUNNING_SRITE_1 = ( [number] , [number] , [number] , [number] ) [EOL] RUNNING_SRITE_2 = ( [number] , [number] , [number] , [number] ) [EOL] RUNNING_SRITE_3 = ( [number] , [number] , [number] , [number] ) [EOL] RUNNING_SRITE_4 = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] RUNNING_SPRITES = ( RUNNING_SRITE_1 , RUNNING_SRITE_2 , RUNNING_SRITE_3 , RUNNING_SRITE_4 ) [EOL] [EOL] BUMP_SPRITE = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] SHOOTING_SPRITE_1 = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] LOOKING_DOWN_SPRITE_1 = ( [number] , [number] , [number] , [number] ) [EOL] LOOKING_UP_SPRITE_1 = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] JUMPING_SPRITE_1 = ( [number] , [number] , [number] , [number] ) [EOL] FALLING_SPRITE_1 = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] HURT_SPRITE_1 = ( [number] , [number] , [number] , [number] ) [EOL] HURT_SPRITE_2 = ( [number] , [number] , [number] , [number] ) [EOL] HURT_SPRITE_3 = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] JAZZ_OBSERVABLE_ID = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] BLITTING_X_EXTENSION = [number] [EOL] BLITTING_Y_EXTENSION = [number] [EOL]	0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
	0
[docstring] [EOL] MAX_SPEED_X = [number] [EOL] [EOL] ACCELERATION_X = [number] [EOL] [EOL] INITIAL_JUMP_Y_SPEED = [number] [comment] [EOL] [EOL] GRAVITY_SPEED = [number] [EOL] [EOL] INITIAL_SHOOTING_DELAY = [number] [EOL]	0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.int$ 0 0 0
from typing import Tuple , Dict [EOL] import typing [EOL] [docstring] [EOL] HUD_WIDTH = [number] [EOL] [EOL] HUD_HEIGHT = [number] [EOL] [EOL] HUD_SPRITESHEET_POSITION = ( [number] , [number] , [number] , [number] ) [comment] [EOL] [EOL] SILVER_ALPHANUMERIC_SPRITE_POSITION = ( [number] , [number] , [number] , [number] ) [EOL] GOLDEN_NUMERIC_SPRITE_POSITION = ( [number] , [number] , [number] , [number] ) [EOL] ALPHANUMERIC_CHARACTER_WIDTH_HEIGHT = ( [number] , [number] ) [comment] [EOL] [EOL] DEFAULT_SPRITESHEET_GOLDEN_NUMBER_DIMENSIONS = { [string] : [number] , [string] : [number] } [EOL] GOLDEN_NUMBERS_ON_SCREEN_DIMENSIONS = { [string] : [number] , [string] : [number] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import pygame [EOL] import jazzpy [EOL] import typing [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] import pygame [EOL] from jazzpy . scenes . abstract_scene import Scene [EOL] from jazzpy . settings . general import VIDEO_OPTIONS [EOL] from jazzpy . settings . hud import HUD_HEIGHT [EOL] from jazzpy . settings . scenes import BLITTING_X_EXTENSION [EOL] from jazzpy . settings . scenes import BLITTING_Y_EXTENSION [EOL] from jazzpy . sprites . jazz . jazz import Jazz [EOL] from jazzpy . sprites . misc . hud import Hud [EOL] from jazzpy . support . camera import Camera [EOL] [EOL] [EOL] class PlayScene ( Scene ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , level ) : [EOL] [docstring] [EOL] super ( PlayScene , self ) . __init__ ( ) [EOL] [EOL] [comment] [EOL] self . level = level [EOL] self . level . build ( ) [EOL] [EOL] [comment] [EOL] self . hud = Hud ( ) [EOL] [EOL] [comment] [EOL] self . jazz = Jazz ( level . jazz_initial_x , level . jazz_initial_y , self . hud ) [EOL] [EOL] [comment] [EOL] self . camera = Camera ( VIDEO_OPTIONS [ [string] ] , VIDEO_OPTIONS [ [string] ] - HUD_HEIGHT , self . level . total_level_width , self . level . total_level_height , ) [EOL] [EOL] self . has_captured_quit_event = False [EOL] [EOL] [comment] [EOL] pygame . mixer . music . load ( self . level . level_music_file ) [EOL] pygame . mixer . music . play ( - [number] ) [comment] [EOL] [EOL] def _get_pressed_keys ( self ) : [EOL] [docstring] [EOL] pressed_states = pygame . key . get_pressed ( ) [EOL] [EOL] [comment] [EOL] pressed_keys = [ pressed_states [ key ] for key in ( pygame . K_LEFT , pygame . K_RIGHT , pygame . K_LALT , pygame . K_SPACE , ) ] [EOL] [EOL] return pressed_keys [EOL] [EOL] def _filter_sprites_out_of_screen ( self , sprites_list , x_extension = [number] , y_extension = [number] ) : [EOL] [docstring] [EOL] closest_x = self . jazz . rect . left - int ( self . camera . screen_width / [number] ) - x_extension [EOL] farthest_x = self . jazz . rect . right + int ( self . camera . screen_width / [number] ) + x_extension [EOL] [EOL] closest_y = self . jazz . rect . top - int ( self . camera . screen_height / [number] ) - y_extension [EOL] farthest_y = self . jazz . rect . bottom + int ( self . camera . screen_height / [number] ) + y_extension [EOL] [EOL] [comment] [EOL] if closest_x < [number] : [EOL] closest_x = [number] [EOL] [EOL] if closest_y < [number] : [EOL] closest_y = [number] [EOL] [EOL] screen_sprites = [ ] [EOL] [EOL] for sprite in sprites_list : [EOL] [EOL] within_x = closest_x <= sprite . rect . x <= farthest_x [EOL] within_y = closest_y <= sprite . rect . y <= farthest_y [EOL] [EOL] if within_x and within_y : [EOL] screen_sprites . append ( sprite ) [EOL] [EOL] return screen_sprites [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] events = self . _get_all_events ( ) [EOL] [EOL] for event in events : [EOL] if event . type == pygame . KEYDOWN and event . key == pygame . K_ESCAPE : [EOL] [EOL] self . has_captured_quit_event = True [EOL] return [EOL] [EOL] pressed_keys = self . _get_pressed_keys ( ) [EOL] screen_platforms = self . _filter_sprites_out_of_screen ( self . level . platforms ) [EOL] [EOL] self . jazz . update ( pressed_keys , screen_platforms ) [EOL] self . jazz . bullets . update ( screen_platforms ) [EOL] [EOL] def render ( self ) : [EOL] [docstring] [EOL] screen = pygame . display . get_surface ( ) [EOL] [EOL] [comment] [EOL] self . camera . compute_offset ( self . jazz ) [EOL] [EOL] screen_platforms = self . _filter_sprites_out_of_screen ( self . level . platforms , BLITTING_X_EXTENSION , BLITTING_Y_EXTENSION ) [EOL] screen_bullets = self . _filter_sprites_out_of_screen ( self . jazz . bullets . sprites ( ) , BLITTING_X_EXTENSION , BLITTING_Y_EXTENSION ) [EOL] [EOL] [comment] [EOL] for platform in screen_platforms : [EOL] screen . blit ( platform . image , self . camera . apply_offset ( platform ) ) [EOL] [EOL] for bullet in screen_bullets : [EOL] screen . blit ( bullet . image , self . camera . apply_offset ( bullet ) ) [EOL] [EOL] if bullet . has_hit : [EOL] screen . blit ( bullet . image , self . camera . apply_offset ( bullet ) ) [EOL] bullet . kill ( ) [comment] [EOL] [EOL] [comment] [EOL] screen . blit ( self . jazz . image , self . camera . apply_offset ( self . jazz ) ) [EOL] screen . blit ( self . hud . image , dest = ( [number] , VIDEO_OPTIONS [ [string] ] - HUD_HEIGHT ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.sprites.misc.hud.Hud$ 0 0 0 0 0 0 0 0 0 0 $jazzpy.sprites.jazz.jazz.Jazz$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $jazzpy.sprites.misc.hud.Hud$ 0 0 0 0 0 0 0 $jazzpy.support.camera.Camera$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pygame.event.EventType]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pygame.event.EventType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import pygame [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from abc import ABC [EOL] from abc import abstractmethod [EOL] from typing import List [EOL] [EOL] import pygame [EOL] [EOL] [EOL] class Scene ( ABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . has_captured_quit_event = False [EOL] [EOL] @ abstractmethod def update ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ abstractmethod def render ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ abstractmethod def _get_pressed_keys ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def _get_all_events ( self ) : [EOL] [docstring] [EOL] return pygame . event . get ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pygame.event.EventType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class SceneManager : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , initial_scene ) : [EOL] [docstring] [EOL] self . current_scene = initial_scene [EOL] [EOL] def update_current_scene ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . current_scene . update ( ) [EOL] [EOL] [comment] [EOL] self . current_scene . render ( ) [EOL] [EOL] def current_scene_captured_quit_event ( self ) : [EOL] [docstring] [EOL] return self . current_scene . has_captured_quit_event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Any [EOL] import pygame [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Tuple [EOL] [EOL] import pygame [EOL] from jazzpy . exceptions . spritesheets import SpritesheetImpossibleMatrixColumnRequired [EOL] from jazzpy . exceptions . spritesheets import SpritesheetImpossibleMatrixRowRequired [EOL] from jazzpy . exceptions . spritesheets import SpritesheetMatrixDimensionsNotConfigured [EOL] from jazzpy . settings . levels import DEFAULT_SPRITESHEET_TILE_DIMENSIONS [EOL] [EOL] [EOL] class SpriteSheet : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file_name , spritesheet_matrix_dimensions = None , default_sprite_width = DEFAULT_SPRITESHEET_TILE_DIMENSIONS [ [string] ] , default_sprite_height = DEFAULT_SPRITESHEET_TILE_DIMENSIONS [ [string] ] , ) : [EOL] [docstring] [EOL] [comment] [EOL] self . sprite_sheet = pygame . image . load ( file_name ) . convert_alpha ( ) [EOL] self . default_sprite_width = default_sprite_width [EOL] self . default_sprite_height = default_sprite_height [EOL] self . spritesheet_matrix_dimensions = spritesheet_matrix_dimensions [EOL] [EOL] def _compute_spritesheet_location ( self , spritesheet_row , spritesheet_col ) : [EOL] [docstring] [EOL] if self . spritesheet_matrix_dimensions is None : [EOL] raise SpritesheetMatrixDimensionsNotConfigured ( [string] ) [EOL] [EOL] if not isinstance ( spritesheet_row , int ) : [EOL] raise SpritesheetImpossibleMatrixRowRequired ( f" [string] { spritesheet_row } [string] " ) [EOL] [EOL] if not isinstance ( spritesheet_col , int ) : [EOL] raise SpritesheetImpossibleMatrixColumnRequired ( f" [string] { spritesheet_col } [string] " ) [EOL] [EOL] if spritesheet_row < [number] or spritesheet_row > self . spritesheet_matrix_dimensions [ [number] ] : [EOL] raise SpritesheetImpossibleMatrixRowRequired ( f" [string] { spritesheet_row } [string] { self . spritesheet_matrix_dimensions }" ) [EOL] [EOL] if spritesheet_col < [number] or spritesheet_col > self . spritesheet_matrix_dimensions [ [number] ] : [EOL] raise SpritesheetImpossibleMatrixColumnRequired ( f" [string] { spritesheet_col } [string] { self . spritesheet_matrix_dimensions }" ) [EOL] [EOL] spritesheet_x = spritesheet_col * self . default_sprite_width [EOL] spritesheet_y = spritesheet_row * self . default_sprite_height [EOL] [EOL] return spritesheet_x , spritesheet_y [EOL] [EOL] def get_image ( self , spritesheet_locations , dimensions = None ) : [EOL] [docstring] [EOL] [comment] [EOL] spritesheet_x , spritesheet_y , sprite_width , sprite_height = spritesheet_locations [EOL] [EOL] if dimensions : [EOL] [comment] [EOL] image_width , image_height = dimensions [EOL] else : [EOL] [comment] [EOL] image_width , image_height = sprite_width , sprite_height [EOL] [EOL] [comment] [EOL] image = pygame . Surface ( ( sprite_width , sprite_height ) , pygame . SRCALPHA ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] image . blit ( self . sprite_sheet , dest = ( [number] , [number] ) , area = ( spritesheet_x , spritesheet_y , sprite_width , sprite_height ) , ) [EOL] [EOL] [comment] [EOL] if image_width > sprite_width and image_height > sprite_height : [EOL] return pygame . transform . scale ( image , ( image_width , image_height ) ) [EOL] [EOL] return image [EOL] [EOL] def get_image_by_row_and_col ( self , spritesheet_row , spritesheet_col , dimensions = None ) : [EOL] [docstring] [EOL] [comment] [EOL] spritesheet_x , spritesheet_y = self . _compute_spritesheet_location ( spritesheet_row , spritesheet_col ) [EOL] [EOL] return self . get_image ( ( spritesheet_x , spritesheet_y , self . default_sprite_width , self . default_sprite_height ) , dimensions , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $pygame.Surface$ 0 0 0 $typing.Tuple$ 0 $typing.Tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple$ 0 0 0 $typing.Tuple$ 0 0 0 0 0 0 0 0 $typing.Tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pygame.Surface$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple$ 0 0 0
import pygame [EOL] import builtins [EOL] [docstring] [EOL] import pygame [EOL] [EOL] [EOL] class Camera : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , screen_width , screen_height , level_width , level_height ) : [EOL] [docstring] [EOL] [comment] [EOL] self . offset_x = [number] [EOL] self . offset_y = [number] [EOL] self . screen_width = screen_width [EOL] self . screen_height = screen_height [EOL] self . level_width = level_width [EOL] self . level_height = level_height [EOL] [EOL] def apply_offset ( self , target ) : [EOL] [docstring] [EOL] return target . rect . move ( self . offset_x , self . offset_y ) [EOL] [EOL] def compute_offset ( self , center_target ) : [EOL] [docstring] [EOL] [comment] [EOL] self . offset_x = - ( center_target . rect . x - int ( self . screen_width / [number] ) ) [EOL] self . offset_y = - ( center_target . rect . y - int ( self . screen_height / [number] ) ) [EOL] [EOL] [comment] [EOL] self . offset_x = min ( [number] , self . offset_x ) [comment] [EOL] self . offset_x = max ( - ( self . level_width - self . screen_width ) , self . offset_x ) [comment] [EOL] self . offset_y = max ( - ( self . level_height - self . screen_height ) , self . offset_y ) [comment] [EOL] self . offset_y = min ( [number] , self . offset_y ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $pygame.Rect$ 0 0 0 $pygame.sprite.Sprite$ 0 0 0 0 0 0 $pygame.sprite.Sprite$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pygame.sprite.Sprite$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $pygame.sprite.Sprite$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $pygame.sprite.Sprite$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
	0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import abc [EOL] from typing import Dict [EOL] [EOL] [EOL] class ObserverMixin : [EOL] [comment] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def update ( self , observable_state , observable_id ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class ObservableMixin : [EOL] [comment] [EOL] def __init__ ( self ) : [EOL] self . _observers = set ( ) [EOL] [EOL] def add_observer ( self , observer ) : [EOL] [docstring] [EOL] self . _observers . add ( observer ) [EOL] [EOL] def _notify_observers ( self , observable_state , observable_id ) : [EOL] [docstring] [EOL] for observer in self . _observers : [EOL] observer . update ( observable_state , observable_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $ObserverMixin$ 0 0 0 0 0 0 0 0 0 0 0 $ObserverMixin$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $builtins.str$ 0 0
	0
[docstring] [EOL] [EOL] [EOL] class SpritesheetImpossibleMatrixRowRequired ( BaseException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class SpritesheetImpossibleMatrixColumnRequired ( BaseException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class SpritesheetMatrixDimensionsNotConfigured ( BaseException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class CorruptedLevelFile ( BaseException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class MissingJazzInitialPositionOnLevelfile ( BaseException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] def pytest_assertrepr_compare ( config , op , left , right ) : [EOL] [docstring] [EOL] if op in ( [string] , [string] ) : [EOL] return [ [string] . format ( left , op , right ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
import unittest [EOL] import jazzpy [EOL] [docstring] [EOL] [EOL] from unittest import mock [EOL] [EOL] from jazzpy . levels . diamondus . diamondus_level_one import DiamondusLevelOne [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_parse_level ( mocked_SpriteSheet , mocked_level_char_code_to_platform ) : [EOL] [docstring] [EOL] [comment] [EOL] mocked_img = mock . MagicMock ( ) [EOL] mocked_sheet = mock . MagicMock ( ) [EOL] mocked_SpriteSheet . return_value = mocked_sheet [EOL] [EOL] [comment] [EOL] mocked_level_char_code_to_platform . return_value = mocked_img [EOL] [EOL] [comment] [EOL] level = DiamondusLevelOne ( [string] , [string] , [string] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] level . jazz_initial_x = [number] [EOL] level . jazz_initial_y = [number] [EOL] [EOL] level . build ( ) [EOL] [EOL] [comment] [EOL] mocked_level_char_code_to_platform . assert_has_calls ( [ mock . call ( [string] , [number] , [number] ) , mock . call ( [string] , [number] , [number] ) , mock . call ( [string] , [number] , [number] ) , mock . call ( [string] , [number] , [number] ) , mock . call ( [string] , [number] , [number] ) , mock . call ( [string] , [number] , [number] ) , mock . call ( [string] , [number] , [number] ) , mock . call ( [string] , [number] , [number] ) , mock . call ( [string] , [number] , [number] ) , ] ) [EOL] [EOL] assert level . total_level_width == [number] * [number] [EOL] assert level . total_level_height == [number] * [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] from unittest import mock [EOL] [EOL] import pygame [EOL] import pytest [EOL] from jazzpy . exceptions . spritesheets import SpritesheetImpossibleMatrixColumnRequired [EOL] from jazzpy . exceptions . spritesheets import SpritesheetImpossibleMatrixRowRequired [EOL] from jazzpy . spritesheets . spritesheet import SpriteSheet [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_should_get_pygame_surface_image_with_no_extra_dimensions ( mocked_image_load , mocked_surface , mocked_scale ) : [EOL] [comment] [EOL] mocked_sheet = mock . MagicMock ( ) [EOL] mocked_image_load . return_value . convert_alpha . return_value = mocked_sheet [EOL] [EOL] mocked_image = mock . MagicMock ( ) [EOL] mocked_surface . return_value = mocked_image [EOL] [EOL] [comment] [EOL] sprite_sheet = SpriteSheet ( [string] ) [EOL] sprite_sheet . get_image ( ( [number] , [number] , [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] mocked_surface . assert_called_once_with ( ( [number] , [number] ) , pygame . SRCALPHA ) [EOL] mocked_image . blit . assert_called_once_with ( mocked_sheet , dest = ( [number] , [number] ) , area = ( [number] , [number] , [number] , [number] ) ) [EOL] mocked_scale . assert_not_called ( ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_should_get_pygame_surface_image_with_extra_dimensions ( mocked_image_load , mocked_surface , mocked_scale ) : [EOL] [comment] [EOL] mocked_sheet = mock . MagicMock ( ) [EOL] mocked_image_load . return_value . convert_alpha . return_value = mocked_sheet [EOL] [EOL] mocked_image = mock . MagicMock ( ) [EOL] mocked_surface . return_value = mocked_image [EOL] [EOL] [comment] [EOL] sprite_sheet = SpriteSheet ( [string] ) [EOL] sprite_sheet . get_image ( ( [number] , [number] , [number] , [number] ) , dimensions = ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] mocked_surface . assert_called_once_with ( ( [number] , [number] ) , pygame . SRCALPHA ) [EOL] mocked_image . blit . assert_called_once_with ( mocked_sheet , dest = ( [number] , [number] ) , area = ( [number] , [number] , [number] , [number] ) ) [EOL] mocked_scale . assert_called_once_with ( mocked_image , ( [number] , [number] ) ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_should_compute_the_right_spritesheet_x_and_y ( mocked_image_load ) : [EOL] sprite_sheet = SpriteSheet ( [string] , ( [number] , [number] ) , default_sprite_height = [number] , default_sprite_width = [number] ) [EOL] expected_x , expected_y = [number] , [number] [EOL] [EOL] [comment] [EOL] x , y = sprite_sheet . _compute_spritesheet_location ( spritesheet_row = [number] , spritesheet_col = [number] ) [EOL] [EOL] assert x == expected_x [EOL] assert y == expected_y [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_should_compute_the_right_spritesheet_x_and_y_impossible_row ( mocked_image_load ) : [EOL] sprite_sheet = SpriteSheet ( [string] , ( [number] , [number] ) , default_sprite_height = [number] , default_sprite_width = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( SpritesheetImpossibleMatrixRowRequired ) : [EOL] sprite_sheet . _compute_spritesheet_location ( spritesheet_row = - [number] , spritesheet_col = [number] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_should_compute_the_right_spritesheet_x_and_y_impossible_row_too_big ( mocked_image_load ) : [EOL] sprite_sheet = SpriteSheet ( [string] , ( [number] , [number] ) , default_sprite_height = [number] , default_sprite_width = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( SpritesheetImpossibleMatrixRowRequired ) : [EOL] sprite_sheet . _compute_spritesheet_location ( spritesheet_row = [number] , spritesheet_col = [number] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_should_compute_the_right_spritesheet_x_and_y_impossible_row_type ( mocked_image_load ) : [EOL] sprite_sheet = SpriteSheet ( [string] , ( [number] , [number] ) , default_sprite_height = [number] , default_sprite_width = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( SpritesheetImpossibleMatrixRowRequired ) : [EOL] sprite_sheet . _compute_spritesheet_location ( spritesheet_row = [string] , spritesheet_col = [number] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_should_compute_the_right_spritesheet_x_and_y_impossible_col ( mocked_image_load ) : [EOL] sprite_sheet = SpriteSheet ( [string] , ( [number] , [number] ) , default_sprite_height = [number] , default_sprite_width = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( SpritesheetImpossibleMatrixColumnRequired ) : [EOL] sprite_sheet . _compute_spritesheet_location ( spritesheet_row = [number] , spritesheet_col = - [number] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_should_compute_the_right_spritesheet_x_and_y_impossible_col_too_big ( mocked_image_load ) : [EOL] sprite_sheet = SpriteSheet ( [string] , ( [number] , [number] ) , default_sprite_height = [number] , default_sprite_width = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( SpritesheetImpossibleMatrixColumnRequired ) : [EOL] sprite_sheet . _compute_spritesheet_location ( spritesheet_row = [number] , spritesheet_col = [number] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_should_compute_the_right_spritesheet_x_and_y_impossible_col_type ( mocked_image_load ) : [EOL] sprite_sheet = SpriteSheet ( [string] , ( [number] , [number] ) , default_sprite_height = [number] , default_sprite_width = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( SpritesheetImpossibleMatrixColumnRequired ) : [EOL] sprite_sheet . _compute_spritesheet_location ( spritesheet_row = [number] , spritesheet_col = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0