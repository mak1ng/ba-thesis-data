[comment] [EOL] [EOL] import SMSShell [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . parsers [EOL] [EOL] [EOL] def test_abstract_parse ( ) : [EOL] [docstring] [EOL] abs = SMSShell . parsers . AbstractParser ( ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . parse ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . transmitters [EOL] import SMSShell . models [EOL] [EOL] [EOL] def test_abstract_init ( ) : [EOL] [docstring] [EOL] abs = SMSShell . transmitters . AbstractTransmitter ( ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . start ( ) [EOL] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . stop ( ) [EOL] [EOL] def test_abstract_transmit ( ) : [EOL] [docstring] [EOL] abs = SMSShell . transmitters . AbstractTransmitter ( ) [EOL] message = SMSShell . models . Message ( [string] , [string] ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . transmit ( message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . metrics . none [EOL] [EOL] [EOL] def test_start ( ) : [EOL] [docstring] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] assert metrics . start ( ) [EOL] [EOL] def test_stop ( ) : [EOL] [docstring] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] assert metrics . start ( ) [EOL] assert metrics . stop ( ) [EOL] [EOL] def test_metrics ( ) : [EOL] [docstring] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] assert metrics . start ( ) [EOL] assert metrics . counter ( [string] ) [EOL] assert metrics . gauge ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . transmitters . stdout [EOL] [EOL] [EOL] def test_init ( ) : [EOL] transmitter = SMSShell . transmitters . stdout . Transmitter ( ) [EOL] assert transmitter . start ( ) [EOL] assert transmitter . stop ( ) [EOL] [EOL] def test_simple_transmit ( capsys ) : [EOL] [docstring] [EOL] transmitter = SMSShell . transmitters . stdout . Transmitter ( ) [EOL] transmitter . start ( ) [EOL] message = SMSShell . models . Message ( [string] , [string] ) [EOL] transmitter . transmit ( message ) [EOL] transmitter . stop ( ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import configparser [EOL] import logging [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . config [EOL] import SMSShell . commands . role [EOL] [EOL] [EOL] def test_init ( ) : [EOL] [docstring] [EOL] com = SMSShell . commands . role . Role ( logging . getLogger ( ) , object ( ) , dict ( ) , object ( ) ) [EOL] [EOL] def test_main ( ) : [EOL] [docstring] [EOL] shell = SMSShell . shell . Shell ( SMSShell . config . MyConfigParser ( ) , object ( ) ) [EOL] assert isinstance ( shell . exec ( [string] , [string] ) , str ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import configparser [EOL] import logging [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . config [EOL] import SMSShell . exceptions [EOL] import SMSShell . commands . desc [EOL] [EOL] [EOL] def test_init ( ) : [EOL] [docstring] [EOL] com = SMSShell . commands . desc . Desc ( logging . getLogger ( ) , object ( ) , dict ( ) , object ( ) ) [EOL] [EOL] def test_main ( ) : [EOL] [docstring] [EOL] shell = SMSShell . shell . Shell ( SMSShell . config . MyConfigParser ( ) , object ( ) ) [EOL] [EOL] with pytest . raises ( SMSShell . exceptions . BadCommandCall ) : [EOL] shell . exec ( [string] , [string] ) [EOL] [EOL] assert isinstance ( shell . exec ( [string] , [string] ) , str ) [EOL] [EOL] def test_command_not_available ( ) : [EOL] [docstring] [EOL] shell = SMSShell . shell . Shell ( SMSShell . config . MyConfigParser ( ) , object ( ) ) [EOL] assert isinstance ( shell . exec ( [string] , [string] ) , str ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import SMSShell [EOL] import typing [EOL] import json [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . parsers . json [EOL] import SMSShell . models . message [EOL] [EOL] [EOL] def test_parse_good_json_and_good_message ( ) : [EOL] [docstring] [EOL] parser = SMSShell . parsers . json . Parser ( ) [EOL] message = parser . parse ( [string] ) [EOL] assert isinstance ( message , SMSShell . models . message . Message ) [EOL] [EOL] def test_parse_good_json_and_bad_message ( ) : [EOL] [docstring] [EOL] parser = SMSShell . parsers . json . Parser ( ) [EOL] with pytest . raises ( SMSShell . parsers . BadMessageFormatException ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] with pytest . raises ( SMSShell . parsers . BadMessageFormatException ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] with pytest . raises ( SMSShell . parsers . BadMessageFormatException ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] with pytest . raises ( SMSShell . parsers . BadMessageFormatException ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] def test_parse_good_json_and_partial_message ( ) : [EOL] [docstring] [EOL] parser = SMSShell . parsers . json . Parser ( ) [EOL] with pytest . raises ( SMSShell . parsers . BadMessageFormatException ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] with pytest . raises ( SMSShell . parsers . BadMessageFormatException ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] def test_parse_bad_json ( ) : [EOL] [docstring] [EOL] parser = SMSShell . parsers . json . Parser ( ) [EOL] with pytest . raises ( SMSShell . parsers . DecodeException ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] with pytest . raises ( SMSShell . parsers . DecodeException ) : [EOL] parser . parse ( None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Literal [EOL] import SMSShell [EOL] import typing_extensions [EOL] import typing [EOL] import configparser [EOL] import configparser [EOL] import pytest [EOL] import os [EOL] [EOL] import SMSShell [EOL] import SMSShell . transmitters . python_gammu [EOL] [EOL] [EOL] def test_init ( ) : [EOL] transmitter = SMSShell . transmitters . python_gammu . Transmitter ( ) [EOL] [EOL] def test_without_gammurc ( ) : [EOL] transmitter = SMSShell . transmitters . python_gammu . Transmitter ( ) [EOL] assert not transmitter . start ( ) [EOL] [EOL] def test_without_bad_configuration ( ) : [EOL] config = dict ( umask = [string] ) [EOL] transmitter = SMSShell . transmitters . python_gammu . Transmitter ( config = config ) [EOL] assert not transmitter . start ( ) [EOL] [EOL] def test_without_read_right ( ) : [EOL] config = dict ( umask = [string] , smsdrc_configuration = [string] ) [EOL] transmitter = SMSShell . transmitters . python_gammu . Transmitter ( config = config ) [EOL] assert not transmitter . start ( ) [EOL] [EOL] def test_simple_transmit ( ) : [EOL] [docstring] [EOL] smsdrc = configparser . ConfigParser ( ) [EOL] smsdrc [ [string] ] = dict ( Device = [string] ) [EOL] smsdrc [ [string] ] = dict ( Service = [string] ) [EOL] with open ( [string] , [string] ) as w : [EOL] smsdrc . write ( w ) [EOL] config = dict ( umask = [string] , smsdrc_configuration = os . path . join ( os . getcwd ( ) , [string] ) ) [EOL] transmitter = SMSShell . transmitters . python_gammu . Transmitter ( config = config ) [EOL] transmitter . start ( ) [EOL] message = SMSShell . models . Message ( [string] , [string] ) [EOL] transmitter . transmit ( message ) [EOL] transmitter . stop ( ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import configparser [EOL] import SMSShell [EOL] import configparser [EOL] import pytest [EOL] import os [EOL] [EOL] import SMSShell [EOL] [EOL] [EOL] def test_loading ( ) : [EOL] [docstring] [EOL] program = SMSShell . SMSShell ( ) [EOL] status , msg = program . load ( [string] ) [EOL] assert status [EOL] [EOL] def test_loading_without_config ( ) : [EOL] [docstring] [EOL] program = SMSShell . SMSShell ( ) [EOL] status , msg = program . load ( None ) [EOL] [EOL] assert not status [EOL] [EOL] def test_start_standalone_mode ( ) : [EOL] [docstring] [EOL] writer = configparser . ConfigParser ( ) [EOL] writer [ [string] ] = dict ( ) [EOL] writer [ [string] ] [ [string] ] = [string] [EOL] [EOL] with open ( [string] , [string] ) as configfile : [EOL] writer . write ( configfile ) [EOL] [EOL] program = SMSShell . SMSShell ( ) [EOL] status , msg = program . load ( [string] ) [EOL] assert status [EOL] os . unlink ( [string] ) [EOL] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] program . start ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict [EOL] import typing [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] [EOL] iteration = [number] [EOL] if [string] not in sys . argv : [EOL] if len ( sys . argv ) > [number] : [EOL] text = [string] . join ( sys . argv [ [number] : ] ) [EOL] else : [EOL] text = input ( ) [EOL] else : [EOL] iteration = [number] [EOL] [EOL] while iteration > [number] : [EOL] if [string] in sys . argv : [EOL] text = input ( ) [EOL] [EOL] env = dict ( SMS_MESSAGES = [string] , DECODED_PARTS = [string] , SMS_1_NUMBER = [string] , SMS_1_CLASS = [string] , SMS_1_TEXT = text , ) [EOL] [EOL] print ( [string] + text + [string] ) [EOL] for key in env : [EOL] os . environ [ key ] = env [ key ] [EOL] [EOL] subprocess . check_output ( [ [string] , [string] ] ) [EOL] iteration -= [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import SMSShell [EOL] import typing [EOL] import datetime [EOL] import pytest [EOL] import time [EOL] [EOL] import SMSShell [EOL] import SMSShell . models . session [EOL] from SMSShell . models . session import SessionStates , BadStateTransitionException [EOL] [EOL] def test_session ( ) : [EOL] [docstring] [EOL] s = SMSShell . models . session . Session ( [string] , [number] ) [EOL] assert s . subject == [string] [EOL] assert s . state == SessionStates . STATE_GUEST [EOL] assert s . ttl == [number] [EOL] assert [string] in str ( s ) [EOL] assert [string] in repr ( s ) [EOL] [EOL] assert s . access_at <= datetime . datetime . today ( ) [EOL] [EOL] def test_session_good_state_transition ( ) : [EOL] [docstring] [EOL] s = SMSShell . models . session . Session ( [string] ) [EOL] s . state = SessionStates . STATE_LOGININPROGRESS [EOL] [EOL] def test_session_bad_state_transition ( ) : [EOL] [docstring] [EOL] s = SMSShell . models . session . Session ( [string] ) [EOL] s . state = SessionStates . STATE_USER [EOL] with pytest . raises ( BadStateTransitionException ) : [EOL] s . state = SessionStates . STATE_LOGININPROGRESS [EOL] [EOL] with pytest . raises ( BadStateTransitionException ) : [EOL] s . state = [number] [EOL] [EOL] with pytest . raises ( BadStateTransitionException ) : [EOL] s . forceState ( [number] ) [EOL] [EOL] def test_session_ttl ( ) : [EOL] [docstring] [EOL] s = SMSShell . models . session . Session ( [string] , [number] ) [EOL] assert s . isValid ( ) [EOL] time . sleep ( [number] ) [EOL] assert not s . isValid ( ) [EOL] [EOL] def test_session_storage_access ( ) : [EOL] [docstring] [EOL] s = SMSShell . models . session . Session ( [string] ) [EOL] s . set ( [string] , [string] ) [EOL] assert s . get ( [string] ) == [string] [EOL] [EOL] def test_session_storage_isolation ( ) : [EOL] [docstring] [EOL] s = SMSShell . models . session . Session ( [string] ) [EOL] s . setStoragePrefix ( [string] ) [EOL] s . set ( [string] , [string] ) [EOL] s . setStoragePrefix ( [string] ) [EOL] s . set ( [string] , [string] ) [EOL] s . setStoragePrefix ( [string] ) [EOL] [EOL] assert s . get ( [string] ) is None [EOL] s . setStoragePrefix ( [string] ) [EOL] assert s . get ( [string] ) == [string] [EOL] s . setStoragePrefix ( [string] ) [EOL] assert s . get ( [string] ) == [string] [EOL] [EOL] def test_session_secure_wrapper ( ) : [EOL] [docstring] [EOL] s = SMSShell . models . session . Session ( [string] ) [EOL] sw = s . getSecureSession ( ) [EOL] [EOL] sw . set ( [string] , [string] ) [EOL] assert sw . get ( [string] ) == [string] [EOL] [EOL] def test_session_secure_wrapper_isolation ( ) : [EOL] [docstring] [EOL] s = SMSShell . models . session . Session ( [string] ) [EOL] sw = s . getSecureSession ( ) [EOL] [EOL] with pytest . raises ( AttributeError ) : [EOL] sw . setStoragePrefix ( [string] ) [EOL] [EOL] with pytest . raises ( AttributeError ) : [EOL] sw . forceState ( SessionStates . STATE_LOGININPROGRESS ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import SMSShell [EOL] import typing [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . metrics [EOL] [EOL] [EOL] def test_abstract_init ( ) : [EOL] [docstring] [EOL] abs = SMSShell . metrics . AbstractMetricsHelper ( ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . start ( ) [EOL] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . stop ( ) [EOL] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . counter ( [string] ) [EOL] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . gauge ( [string] ) [EOL] [EOL] def test_abstract_name_normalizer ( ) : [EOL] [docstring] [EOL] abs = SMSShell . metrics . AbstractMetricsHelper ( ) [EOL] name = abs . normalizeName ( [string] ) [EOL] assert abs . SEPARATOR in name [EOL] assert abs . PREFIX in name [EOL] assert abs . normalizeName ( [string] ) == abs . SEPARATOR . join ( [ abs . PREFIX , [string] ] ) [EOL] [EOL] abs_with_underscore = SMSShell . metrics . AbstractMetricsHelper ( ) [EOL] abs_with_underscore . SEPARATOR = [string] [EOL] name2 = abs_with_underscore . normalizeName ( [string] ) [EOL] assert abs_with_underscore . SEPARATOR in name2 [EOL] assert [string] not in name2 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Dict [EOL] import subprocess [EOL] import typing [EOL] import json [EOL] import os [EOL] import shlex [EOL] import subprocess [EOL] [EOL] [EOL] [comment] [EOL] def test_cmdline_help ( ) : [EOL] [docstring] [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert [string] in stdout . decode ( ) [EOL] [EOL] def test_cmdline_version ( ) : [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert [string] in stdout . decode ( ) [EOL] [EOL] def test_cmdline_with_env_input ( ) : [EOL] env = dict ( SMS_MESSAGES = [string] , DECODED_PARTS = [string] , SMS_1_NUMBER = [string] , SMS_1_CLASS = [string] , SMS_1_TEXT = [string] , ) [EOL] [comment] [EOL] for key in env : [EOL] os . environ [ key ] = env [ key ] [EOL] [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] if isinstance ( stdout , bytes ) : [EOL] stdout = stdout . decode ( ) [EOL] obj = json . loads ( stdout ) [EOL] assert result . returncode == [number] [EOL] assert [string] in obj and obj [ [string] ] == [string] [EOL] [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert os . path . exists ( [string] ) [EOL] os . unlink ( [string] ) [EOL] [EOL] def test_cmdline_with_bad_file_input ( ) : [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert result . returncode != [number] [EOL] [EOL] def test_cmdline_with_file_input ( ) : [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] if isinstance ( stdout , bytes ) : [EOL] stdout = stdout . decode ( ) [EOL] obj = json . loads ( stdout ) [EOL] assert result . returncode == [number] [EOL] assert [string] in obj and obj [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import tests [EOL] import SMSShell [EOL] import argparse [EOL] import logging [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . commands [EOL] [EOL] [EOL] def test_abstract_init ( ) : [EOL] [docstring] [EOL] abs = SMSShell . commands . AbstractCommand ( logging . getLogger ( ) , object ( ) , object ( ) , object ( ) ) [EOL] [EOL] assert abs . name == [string] [EOL] [EOL] def test_abstract_not_implemented ( ) : [EOL] abs = SMSShell . commands . AbstractCommand ( logging . getLogger ( ) , object ( ) , object ( ) , object ( ) ) [EOL] [EOL] with pytest . raises ( SMSShell . commands . CommandBadImplemented ) : [EOL] abs . description ( [ ] ) [EOL] with pytest . raises ( SMSShell . commands . CommandBadImplemented ) : [EOL] abs . usage ( [ ] ) [EOL] with pytest . raises ( SMSShell . commands . CommandBadImplemented ) : [EOL] abs . main ( [ ] ) [EOL] [EOL] def test_abstract_bad_input_state_type ( ) : [EOL] [EOL] class Bad ( SMSShell . commands . AbstractCommand ) : [EOL] def inputStates ( self ) : [EOL] return dict ( ) [EOL] [EOL] com = Bad ( logging . getLogger ( ) , object ( ) , object ( ) , object ( ) ) [EOL] with pytest . raises ( SMSShell . commands . CommandBadImplemented ) : [EOL] com . _inputStates ( ) [EOL] [EOL] [EOL] def test_abstract_bad_input_state_value ( ) : [EOL] [EOL] class Bad ( SMSShell . commands . AbstractCommand ) : [EOL] def inputStates ( self ) : [EOL] return [ [string] ] [EOL] [EOL] com = Bad ( logging . getLogger ( ) , object ( ) , object ( ) , object ( ) ) [EOL] with pytest . raises ( SMSShell . commands . CommandBadImplemented ) : [EOL] com . _inputStates ( ) [EOL] [EOL] [EOL] def test_abstract_bad_arg_parser_type ( ) : [EOL] [EOL] class Bad ( SMSShell . commands . AbstractCommand ) : [EOL] def argsParser ( self ) : [EOL] return [string] [EOL] [EOL] com = Bad ( logging . getLogger ( ) , object ( ) , object ( ) , object ( ) ) [EOL] with pytest . raises ( SMSShell . commands . CommandBadImplemented ) : [EOL] com . _argsParser ( ) [EOL] [EOL] def test_abstract_bad_arg_parser_init ( ) : [EOL] [EOL] class Bad ( SMSShell . commands . AbstractCommand ) : [EOL] def argsParser ( self ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] com = Bad ( logging . getLogger ( ) , object ( ) , object ( ) , object ( ) ) [EOL] with pytest . raises ( SMSShell . commands . CommandBadImplemented ) : [EOL] com . _argsParser ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Dict , Pattern , List , Literal [EOL] import typing_extensions [EOL] import typing [EOL] import os [EOL] import pytest [EOL] import re [EOL] import sys [EOL] [EOL] import SMSShell [EOL] import SMSShell . utils [EOL] [EOL] def getBackupSample ( file ) : [EOL] return os . path . join ( [string] , file ) [EOL] [EOL] @ pytest . yield_fixture def environSetup ( ) : [EOL] [docstring] [EOL] regex = re . compile ( [string] ) [EOL] keys_to_remove = [ ] [EOL] for key in os . environ : [EOL] if regex . match ( key ) : [EOL] keys_to_remove . append ( key ) [EOL] for key in keys_to_remove : [EOL] del os . environ [ key ] [EOL] yield True [EOL] [EOL] [EOL] def test_env_sms_decoding_with_good_single_message ( environSetup ) : [EOL] [docstring] [EOL] env = dict ( SMS_MESSAGES = [string] , DECODED_PARTS = [string] , SMS_1_NUMBER = [string] , SMS_1_CLASS = [string] , SMS_1_TEXT = [string] , ) [EOL] for key in env : [EOL] os . environ [ key ] = env [ key ] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromEnv ( ) [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert [string] in content [EOL] assert len ( content [ [string] ] ) == [number] [EOL] [EOL] [EOL] def test_env_sms_decoding_with_good_multipart_message ( environSetup ) : [EOL] [docstring] [EOL] env = dict ( SMS_MESSAGES = [string] , DECODED_PARTS = [string] , DECODED_0_TEXT = [string] , SMS_1_NUMBER = [string] , SMS_1_CLASS = [string] , SMS_1_TEXT = [string] , SMS_2_NUMBER = [string] , SMS_2_CLASS = [string] , SMS_2_TEXT = [string] , ) [EOL] for key in env : [EOL] os . environ [ key ] = env [ key ] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromEnv ( ) [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert [string] in content [EOL] assert len ( content [ [string] ] ) == [number] [EOL] [EOL] [EOL] def test_env_sms_decoding_with_empty_values ( environSetup ) : [EOL] [docstring] [EOL] env = dict ( SMS_MESSAGES = [string] , DECODED_PARTS = [string] , ) [EOL] for key in env : [EOL] os . environ [ key ] = env [ key ] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromEnv ( ) [EOL] assert content [ [string] ] == None [EOL] assert [string] in content [EOL] assert len ( content [ [string] ] ) >= [number] [EOL] [EOL] [EOL] def test_env_sms_decoding_with_different_common_values ( environSetup ) : [EOL] [docstring] [EOL] env = dict ( SMS_MESSAGES = [string] , DECODED_PARTS = [string] , DECODED_0_TEXT = [string] , SMS_1_NUMBER = [string] , SMS_1_CLASS = [string] , SMS_1_TEXT = [string] , SMS_2_NUMBER = [string] , SMS_2_CLASS = [string] , SMS_2_TEXT = [string] , ) [EOL] for key in env : [EOL] os . environ [ key ] = env [ key ] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromEnv ( ) [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert [string] in content [EOL] assert len ( content [ [string] ] ) >= [number] [EOL] [EOL] [EOL] def test_env_sms_decoding_with_different_decoded_parts ( environSetup ) : [EOL] [docstring] [EOL] env = dict ( SMS_MESSAGES = [string] , DECODED_PARTS = [string] , DECODED_0_TEXT = [string] , SMS_1_NUMBER = [string] , SMS_1_CLASS = [string] , SMS_1_TEXT = [string] , SMS_2_NUMBER = [string] , SMS_2_CLASS = [string] , SMS_2_TEXT = [string] , ) [EOL] for key in env : [EOL] os . environ [ key ] = env [ key ] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromEnv ( ) [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert [string] in content [EOL] assert len ( content [ [string] ] ) >= [number] [EOL] [EOL] [EOL] def test_env_mms_decoding ( environSetup ) : [EOL] [docstring] [EOL] env = dict ( DECODED_1_MMS_SENDER = [string] , SMS_MESSAGES = [string] , DECODED_PARTS = [string] , DECODED_1_MMS_SIZE = [string] , DECODED_1_MMS_TITLE = [string] , DECODED_1_MMS_ADDRESS = [string] , SMS_1_NUMBER = [string] , SMS_1_CLASS = [string] , ) [EOL] for key in env : [EOL] os . environ [ key ] = env [ key ] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromEnv ( ) [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] [EOL] def test_backupfile_simple_sms_decoding ( ) : [EOL] [docstring] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromBackupFilePath ( getBackupSample ( [string] ) ) [EOL] assert isinstance ( content , dict ) [EOL] assert len ( content [ [string] ] ) == [number] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] [EOL] def test_backupfile_unicode_sms_decoding ( ) : [EOL] [docstring] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromBackupFilePath ( getBackupSample ( [string] ) ) [EOL] assert isinstance ( content , dict ) [EOL] assert len ( content [ [string] ] ) == [number] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] [EOL] def test_backupfile_smiley_sms_decoding ( ) : [EOL] [docstring] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromBackupFilePath ( getBackupSample ( [string] ) ) [EOL] assert isinstance ( content , dict ) [EOL] assert len ( content [ [string] ] ) == [number] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert len ( content [ [string] ] ) == [number] [EOL] [EOL] def test_backupfile_mms_decoding ( ) : [EOL] [docstring] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromBackupFilePath ( getBackupSample ( [string] ) ) [EOL] assert isinstance ( content , dict ) [EOL] assert len ( content [ [string] ] ) == [number] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == content [ [string] ] [EOL] [EOL] def test_backupfile_status_report_sms_decoding ( ) : [EOL] [docstring] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromBackupFilePath ( getBackupSample ( [string] ) ) [EOL] assert isinstance ( content , dict ) [EOL] assert len ( content [ [string] ] ) == [number] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] assert content [ [string] ] == [string] [EOL] [EOL] def test_backupfile_missing_file ( ) : [EOL] [docstring] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromBackupFilePath ( getBackupSample ( [string] ) ) [EOL] assert isinstance ( content , dict ) [EOL] assert content [ [string] ] [EOL] [EOL] def test_backupfile_unreadable_file ( ) : [EOL] [docstring] [EOL] content = SMSShell . utils . GammuSMSParser . decodeFromBackupFilePath ( getBackupSample ( [string] ) ) [EOL] assert isinstance ( content , dict ) [EOL] assert content [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import SMSShell [EOL] import socket [EOL] import typing [EOL] import queue [EOL] import subprocess [EOL] import json [EOL] import os [EOL] import pytest [EOL] import queue [EOL] import shlex [EOL] import socket [EOL] import stat [EOL] import subprocess [EOL] import threading [EOL] [EOL] import SMSShell [EOL] import SMSShell . receivers . unix [EOL] [EOL] def test_start ( ) : [EOL] [docstring] [EOL] unix = [string] [EOL] receiver = SMSShell . receivers . unix . Receiver ( config = dict ( path = unix , umask = [string] ) ) [EOL] assert receiver . start ( ) [EOL] assert os . path . exists ( unix ) [EOL] assert stat . S_ISSOCK ( os . stat ( unix ) . st_mode ) [EOL] [EOL] assert receiver . stop ( ) [EOL] assert not os . path . exists ( unix ) [EOL] [EOL] def test_start_with_existing_socket ( ) : [EOL] [docstring] [EOL] unix = [string] [EOL] receiver = SMSShell . receivers . unix . Receiver ( config = dict ( path = unix , umask = [string] ) ) [EOL] [EOL] [comment] [EOL] server_socket = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM ) [EOL] server_socket . bind ( unix ) [EOL] server_socket . close ( ) [EOL] assert os . path . exists ( unix ) [EOL] assert stat . S_ISSOCK ( os . stat ( unix ) . st_mode ) [EOL] [EOL] assert receiver . start ( ) [EOL] assert os . path . exists ( unix ) [EOL] assert stat . S_ISSOCK ( os . stat ( unix ) . st_mode ) [EOL] [EOL] assert receiver . stop ( ) [EOL] assert not os . path . exists ( unix ) [EOL] [EOL] def test_init_with_bad_config ( ) : [EOL] [docstring] [EOL] unix = [string] [EOL] receiver = SMSShell . receivers . unix . Receiver ( config = dict ( path = unix , umask = [string] , listen_queue = [string] ) ) [EOL] assert isinstance ( receiver , SMSShell . receivers . unix . Receiver ) [EOL] [EOL] def test_bad_start_because_path_already_exists ( ) : [EOL] [docstring] [EOL] unix = [string] [EOL] receiver = SMSShell . receivers . unix . Receiver ( config = dict ( path = unix ) ) [EOL] [comment] [EOL] os . mkdir ( unix ) [EOL] assert os . path . exists ( unix ) [EOL] assert os . path . isdir ( unix ) [EOL] [comment] [EOL] assert not receiver . start ( ) [EOL] [comment] [EOL] os . rmdir ( unix ) [EOL] assert not os . path . exists ( unix ) [EOL] [EOL] def test_bad_start_because_path_not_writable ( ) : [EOL] [docstring] [EOL] unix = [string] [EOL] receiver = SMSShell . receivers . unix . Receiver ( config = dict ( path = unix ) ) [EOL] assert not receiver . start ( ) [EOL] [EOL] def test_bad_stop_because_path_already_deleted ( ) : [EOL] [docstring] [EOL] unix = [string] [EOL] receiver = SMSShell . receivers . unix . Receiver ( config = dict ( path = unix ) ) [EOL] assert receiver . start ( ) [EOL] [comment] [EOL] os . unlink ( unix ) [EOL] assert not receiver . stop ( ) [EOL] [EOL] def test_simple_read_from_socket ( ) : [EOL] [docstring] [EOL] m_unix = [string] [EOL] m_data = [string] [EOL] m_channel = queue . Queue ( ) [EOL] [EOL] def writeToSocket ( channel , unix , data ) : [EOL] p = subprocess . Popen ( shlex . split ( [string] . format ( unix ) ) , stdin = subprocess . PIPE , stdout = subprocess . PIPE ) [EOL] ( stdout , stderr ) = p . communicate ( input = data . encode ( ) ) [EOL] channel . put ( ( stdout , stderr , p . returncode ) ) [EOL] [EOL] [comment] [EOL] receiver = SMSShell . receivers . unix . Receiver ( config = dict ( path = m_unix ) ) [EOL] assert receiver . start ( ) [EOL] assert os . path . exists ( m_unix ) [EOL] assert stat . S_ISSOCK ( os . stat ( m_unix ) . st_mode ) [EOL] [comment] [EOL] threading . Thread ( target = writeToSocket , args = ( m_channel , m_unix , m_data ) ) . start ( ) [EOL] [EOL] [comment] [EOL] client_context = next ( receiver . read ( ) ) [EOL] with client_context as client_context_data : [EOL] [comment] [EOL] assert m_data in client_context_data [EOL] [EOL] [comment] [EOL] stdout , stderr , returncode = m_channel . get ( ) [EOL] assert returncode == [number] [EOL] [EOL] assert receiver . stop ( ) [EOL] assert not os . path . exists ( m_unix ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . smsshell [EOL] [EOL] [EOL] def test_loading ( ) : [EOL] [docstring] [EOL] program = SMSShell . smsshell . SMSShell ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import SMSShell [EOL] import typing [EOL] import os [EOL] import pytest [EOL] import stat [EOL] import threading [EOL] [EOL] import SMSShell [EOL] import SMSShell . receivers . fifo [EOL] [EOL] [EOL] def test_init ( ) : [EOL] [docstring] [EOL] fifo = [string] [EOL] receiver = SMSShell . receivers . fifo . Receiver ( config = dict ( path = fifo ) ) [EOL] assert receiver . start ( ) [EOL] assert os . path . exists ( fifo ) [EOL] assert stat . S_ISFIFO ( os . stat ( fifo ) . st_mode ) [EOL] [EOL] assert receiver . stop ( ) [EOL] assert not os . path . exists ( fifo ) [EOL] [EOL] def test_bad_start_because_path_already_exists ( ) : [EOL] [docstring] [EOL] fifo = [string] [EOL] receiver = SMSShell . receivers . fifo . Receiver ( config = dict ( path = fifo ) ) [EOL] [comment] [EOL] os . mkdir ( fifo ) [EOL] assert os . path . exists ( fifo ) [EOL] assert os . path . isdir ( fifo ) [EOL] [comment] [EOL] assert not receiver . start ( ) [EOL] [comment] [EOL] os . rmdir ( fifo ) [EOL] assert not os . path . exists ( fifo ) [EOL] [EOL] def test_bad_start_because_path_not_writable ( ) : [EOL] [docstring] [EOL] fifo = [string] [EOL] receiver = SMSShell . receivers . fifo . Receiver ( config = dict ( path = fifo ) ) [EOL] assert not receiver . start ( ) [EOL] [EOL] def test_good_start_on_previous_fifo ( ) : [EOL] [docstring] [EOL] fifo = [string] [EOL] receiver = SMSShell . receivers . fifo . Receiver ( config = dict ( path = fifo ) ) [EOL] assert receiver . start ( ) [EOL] assert receiver . start ( ) [EOL] [EOL] def test_bad_stop_because_path_already_deleted ( ) : [EOL] [docstring] [EOL] fifo = [string] [EOL] receiver = SMSShell . receivers . fifo . Receiver ( config = dict ( path = fifo ) ) [EOL] assert receiver . start ( ) [EOL] [comment] [EOL] os . unlink ( fifo ) [EOL] assert not receiver . stop ( ) [EOL] [EOL] def test_simple_read_from_fifo ( ) : [EOL] [docstring] [EOL] fifo = [string] [EOL] data = [string] [EOL] [EOL] def writeToFifo ( data ) : [EOL] [comment] [EOL] with open ( fifo , [string] ) as path : [EOL] path . write ( data ) [EOL] [EOL] [comment] [EOL] receiver = SMSShell . receivers . fifo . Receiver ( config = dict ( path = fifo ) ) [EOL] assert receiver . start ( ) [EOL] assert os . path . exists ( fifo ) [EOL] assert stat . S_ISFIFO ( os . stat ( fifo ) . st_mode ) [EOL] [comment] [EOL] threading . Thread ( target = writeToFifo , args = ( data , ) ) . start ( ) [EOL] [EOL] [comment] [EOL] client_context = next ( receiver . read ( ) ) [EOL] with client_context as client_context_data : [EOL] [comment] [EOL] assert data in client_context_data [EOL] [EOL] assert receiver . stop ( ) [EOL] assert not os . path . exists ( fifo ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . filters [EOL] import SMSShell . exceptions [EOL] [EOL] [EOL] def test_abstract_init ( ) : [EOL] [docstring] [EOL] abs = SMSShell . filters . AbstractFilter ( ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs ( [string] ) [EOL] [EOL] def test_bad_filter_class ( ) : [EOL] class V ( ) : [EOL] def __call__ ( self , data ) : [EOL] assert data == [string] [EOL] [EOL] chain = SMSShell . filters . FilterChain ( ) [EOL] with pytest . raises ( SMSShell . exceptions . ShellInitException ) : [EOL] chain . addLinksFromDict ( { [string] : [ V ( ) ] } ) [EOL] [EOL] def test_message_filter ( ) : [EOL] m = SMSShell . models . message . Message ( [string] , [string] ) [EOL] [EOL] class V ( SMSShell . filters . AbstractFilter ) : [EOL] def __call__ ( self , data ) : [EOL] assert data == [string] [EOL] [EOL] chain = SMSShell . filters . FilterChain ( ) [EOL] chain . addLinksFromDict ( { [string] : [ V ( ) ] } ) [EOL] assert chain . callChainOnObject ( m ) [EOL] [EOL] def test_message_filter_on_missing_field ( ) : [EOL] m = SMSShell . models . message . Message ( [string] , [string] ) [EOL] [EOL] class V ( SMSShell . filters . AbstractFilter ) : [EOL] def __call__ ( self , data ) : [EOL] pass [EOL] [EOL] chain = SMSShell . filters . FilterChain ( ) [EOL] chain . addLinksFromDict ( { [string] : [ V ( ) ] } ) [EOL] with pytest . raises ( SMSShell . filters . FilterException ) : [EOL] chain . callChainOnObject ( m ) [EOL] [EOL] [comment] [EOL] [EOL] def test_lowercase_load ( ) : [EOL] [docstring] [EOL] val = SMSShell . filters . LowerCase ( [number] ) [EOL] assert isinstance ( val , SMSShell . filters . AbstractFilter ) [EOL] [EOL] SMSShell . filters . LowerCase ( [string] ) [EOL] [EOL] with pytest . raises ( SMSShell . exceptions . ShellInitException ) : [EOL] SMSShell . filters . LowerCase ( [string] ) [EOL] [EOL] def test_lowercase_filtering ( ) : [EOL] [docstring] [EOL] val = SMSShell . filters . LowerCase ( [number] ) [EOL] assert val ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import configparser [EOL] import logging [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . config [EOL] import SMSShell . commands . help [EOL] [EOL] [EOL] def test_init ( ) : [EOL] [docstring] [EOL] com = SMSShell . commands . help . Help ( logging . getLogger ( ) , object ( ) , dict ( ) , object ( ) ) [EOL] [EOL] def test_main ( ) : [EOL] [docstring] [EOL] shell = SMSShell . shell . Shell ( SMSShell . config . MyConfigParser ( ) , object ( ) ) [EOL] assert isinstance ( shell . exec ( [string] , [string] ) , str ) [EOL] assert isinstance ( shell . exec ( [string] , [string] ) , str ) [EOL] [EOL] def test_command_not_available ( ) : [EOL] [docstring] [EOL] shell = SMSShell . shell . Shell ( SMSShell . config . MyConfigParser ( ) , object ( ) ) [EOL] assert isinstance ( shell . exec ( [string] , [string] ) , str ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . receivers [EOL] [EOL] [EOL] def test_abstract_receiver_init ( ) : [EOL] [docstring] [EOL] abs = SMSShell . receivers . AbstractReceiver ( ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . start ( ) [EOL] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . stop ( ) [EOL] [EOL] def test_abstract_receiver_read ( ) : [EOL] [docstring] [EOL] abs = SMSShell . receivers . AbstractReceiver ( ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . read ( ) [EOL] [EOL] def test_abstract_context_init ( ) : [EOL] [docstring] [EOL] abs = SMSShell . receivers . AbstractClientRequest ( [string] ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . enter ( ) [EOL] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs . exit ( ) [EOL] [EOL] def test_abstract_context_bad_usage ( ) : [EOL] [docstring] [EOL] abs = SMSShell . receivers . AbstractClientRequest ( [string] ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] abs . getRequestData ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import configparser [EOL] import SMSShell [EOL] import typing [EOL] import configparser [EOL] import pytest [EOL] import os [EOL] [EOL] import SMSShell [EOL] import SMSShell . config [EOL] [EOL] [EOL] def test_loading ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] [EOL] def test_with_bad_file_path ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert not conf . load ( [string] ) [ [number] ] [EOL] assert not conf . isLoaded ( ) [EOL] [EOL] def test_with_bad_file_content ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] with open ( [string] , [string] ) as configfile : [EOL] configfile . write ( [string] ) [EOL] assert not conf . load ( [string] ) [ [number] ] [EOL] assert not conf . isLoaded ( ) [EOL] os . unlink ( [string] ) [EOL] [EOL] def test_with_bad_log_level ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] [EOL] writer = configparser . ConfigParser ( ) [EOL] writer [ conf . MAIN_SECTION ] = dict ( ) [EOL] writer [ conf . MAIN_SECTION ] [ [string] ] = [string] [EOL] [EOL] with open ( [string] , [string] ) as configfile : [EOL] writer . write ( configfile ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] os . unlink ( [string] ) [EOL] [EOL] assert conf . getLogLevel ( default = [string] ) == [string] [EOL] [EOL] def test_with_bad_uid_mapping ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] [EOL] writer = configparser . ConfigParser ( ) [EOL] writer [ conf . MAIN_SECTION ] = dict ( ) [EOL] writer [ conf . MAIN_SECTION ] [ [string] ] = [string] [EOL] [EOL] with open ( [string] , [string] ) as configfile : [EOL] writer . write ( configfile ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] os . unlink ( [string] ) [EOL] [EOL] assert conf . getUid ( ) is None [EOL] [EOL] def test_with_bad_gid_mapping ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] [EOL] writer = configparser . ConfigParser ( ) [EOL] writer [ conf . MAIN_SECTION ] = dict ( ) [EOL] writer [ conf . MAIN_SECTION ] [ [string] ] = [string] [EOL] [EOL] with open ( [string] , [string] ) as configfile : [EOL] writer . write ( configfile ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] os . unlink ( [string] ) [EOL] [EOL] assert conf . getGid ( ) is None [EOL] [EOL] def test_getter ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] [EOL] assert conf . getLogLevel ( [string] ) != [string] [EOL] [EOL] uid = conf . getUid ( ) [EOL] assert isinstance ( uid , int ) or uid is None [EOL] [EOL] gid = conf . getGid ( ) [EOL] assert isinstance ( gid , int ) or gid is None [EOL] [EOL] assert isinstance ( conf . getMode ( ) , str ) [EOL] [EOL] c_mode = conf . getModeConfig ( conf . getMode ( ) ) [EOL] assert isinstance ( c_mode , dict ) or c_mode is None [EOL] [EOL] assert not conf . getSectionOrEmpty ( [string] ) [EOL] [EOL] assert conf . getSectionOrEmpty ( [string] ) [EOL] [EOL] def test_with_classes_chain_loading ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] [EOL] writer = configparser . ConfigParser ( ) [EOL] writer [ [string] ] = dict ( ) [EOL] writer [ [string] ] [ [string] ] = [string] [EOL] [EOL] with open ( [string] , [string] ) as configfile : [EOL] writer . write ( configfile ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] os . unlink ( [string] ) [EOL] [EOL] class module : [EOL] [EOL] class F1 : [EOL] pass [EOL] [EOL] class F2 : [EOL] def __init__ ( self , value ) : [EOL] self . value = value [EOL] [EOL] class F3 : [EOL] def __init__ ( self , value1 , value2 ) : [EOL] self . values = ( value1 , value2 ) [EOL] [EOL] spec = conf . getClassesChainFromConfig ( [string] , [string] , module ) [EOL] assert [string] in spec [EOL] assert isinstance ( spec [ [string] ] [ [number] ] , module . F1 ) [EOL] assert isinstance ( spec [ [string] ] [ [number] ] , module . F2 ) [EOL] assert spec [ [string] ] [ [number] ] . value == [string] [EOL] assert isinstance ( spec [ [string] ] [ [number] ] , module . F3 ) [EOL] assert spec [ [string] ] [ [number] ] . values == ( [string] , [string] ) [EOL] [EOL] def test_with_classes_chain_missing_filter_class ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] [EOL] writer = configparser . ConfigParser ( ) [EOL] writer [ [string] ] = dict ( ) [EOL] writer [ [string] ] [ [string] ] = [string] [EOL] [EOL] with open ( [string] , [string] ) as configfile : [EOL] writer . write ( configfile ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] os . unlink ( [string] ) [EOL] [EOL] class module : [EOL] [EOL] class F1 : [EOL] pass [EOL] [EOL] spec = conf . getClassesChainFromConfig ( [string] , [string] , module ) [EOL] assert [string] in spec [EOL] assert len ( spec [ [string] ] ) == [number] [EOL] assert isinstance ( spec [ [string] ] [ [number] ] , module . F1 ) [EOL] [EOL] def test_with_classes_chain_bad_filter_config ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] [EOL] writer = configparser . ConfigParser ( ) [EOL] writer [ [string] ] = dict ( ) [EOL] writer [ [string] ] [ [string] ] = [string] [EOL] [EOL] with open ( [string] , [string] ) as configfile : [EOL] writer . write ( configfile ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] os . unlink ( [string] ) [EOL] [EOL] class module : [EOL] [EOL] class F1 : [EOL] pass [EOL] [EOL] with pytest . raises ( SMSShell . exceptions . ShellInitException ) : [EOL] spec = conf . getClassesChainFromConfig ( [string] , [string] , module ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import subprocess [EOL] import typing [EOL] import shlex [EOL] import subprocess [EOL] [EOL] [EOL] [comment] [EOL] def test_cmdline_help ( ) : [EOL] [docstring] [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert [string] in stdout . decode ( ) [EOL] [EOL] def test_cmdline_version ( ) : [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert [string] in stdout . decode ( ) [EOL] [EOL] def test_cmdline_without_config_file ( ) : [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert result . returncode == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . validators [EOL] import SMSShell . models . message [EOL] [EOL] [EOL] def test_abstract_init ( ) : [EOL] [docstring] [EOL] abs = SMSShell . validators . AbstractValidator ( ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] abs ( [string] ) [EOL] [EOL] def test_bad_validator_class ( ) : [EOL] class V ( ) : [EOL] def __call__ ( self , data ) : [EOL] assert data == [string] [EOL] [EOL] chain = SMSShell . validators . ValidatorChain ( ) [EOL] with pytest . raises ( SMSShell . exceptions . ShellInitException ) : [EOL] chain . addLinksFromDict ( { [string] : [ V ( ) ] } ) [EOL] [EOL] def test_message_validation ( ) : [EOL] m = SMSShell . models . message . Message ( [string] , [string] ) [EOL] [EOL] class V ( SMSShell . validators . AbstractValidator ) : [EOL] def __call__ ( self , data ) : [EOL] assert data == [string] [EOL] [EOL] chain = SMSShell . validators . ValidatorChain ( ) [EOL] chain . addLinksFromDict ( { [string] : [ V ( ) ] } ) [EOL] assert chain . callChainOnObject ( m ) [EOL] [EOL] def test_message_validator_on_missing_field ( ) : [EOL] m = SMSShell . models . message . Message ( [string] , [string] ) [EOL] [EOL] class V ( SMSShell . validators . AbstractValidator ) : [EOL] def __call__ ( self , data ) : [EOL] pass [EOL] [EOL] chain = SMSShell . validators . ValidatorChain ( ) [EOL] chain . addLinksFromDict ( { [string] : [ V ( ) ] } ) [EOL] with pytest . raises ( SMSShell . validators . ValidationException ) : [EOL] chain . callChainOnObject ( m ) [EOL] [EOL] [comment] [EOL] [EOL] def test_regexp_load ( ) : [EOL] [docstring] [EOL] val = SMSShell . validators . Regexp ( [string] ) [EOL] assert isinstance ( val , SMSShell . validators . AbstractValidator ) [EOL] [EOL] def test_regexp_data_valid ( ) : [EOL] [docstring] [EOL] val = SMSShell . validators . Regexp ( [string] ) [EOL] assert val ( [string] ) [EOL] [EOL] def test_regexp_data_invalid ( ) : [EOL] [docstring] [EOL] val = SMSShell . validators . Regexp ( [string] ) [EOL] with pytest . raises ( SMSShell . validators . ValidationException ) : [EOL] val ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import SMSShell [EOL] import typing [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . config [EOL] import SMSShell . shell [EOL] import SMSShell . models . session [EOL] import SMSShell . metrics . none [EOL] import SMSShell . commands [EOL] import SMSShell . exceptions [EOL] [EOL] [EOL] def test_loading ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] [EOL] shell = SMSShell . shell . Shell ( conf , metrics ) [EOL] session = SMSShell . models . session . Session ( [string] ) [EOL] [EOL] def test_loading_all_commands ( ) : [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] [EOL] shell = SMSShell . shell . Shell ( conf , metrics ) [EOL] session = SMSShell . models . session . Session ( [string] ) [EOL] [EOL] assert shell . getAvailableCommands ( session ) [EOL] shell . flushCommandCache ( ) [EOL] [EOL] def test_exec_command_help ( ) : [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] [EOL] shell = SMSShell . shell . Shell ( conf , metrics ) [EOL] [EOL] assert shell . exec ( [string] , [string] ) [EOL] assert shell . exec ( [string] , [string] ) [EOL] [EOL] def test_exec_usage_on_all_commands ( ) : [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] [EOL] shell = SMSShell . shell . Shell ( conf , metrics ) [EOL] [EOL] commands = shell . exec ( [string] , [string] ) [EOL] for c in commands . split ( ) : [EOL] assert shell . exec ( [string] , [string] + c ) [EOL] assert shell . exec ( [string] , [string] + c ) [EOL] [EOL] def test_exec_command_not_found ( ) : [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] [EOL] shell = SMSShell . shell . Shell ( conf , metrics ) [EOL] [EOL] with pytest . raises ( SMSShell . commands . CommandNotFoundException ) : [EOL] shell . exec ( [string] , [string] ) [EOL] [EOL] def test_exec_with_bad_syntax ( ) : [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] [EOL] shell = SMSShell . shell . Shell ( conf , metrics ) [EOL] [EOL] with pytest . raises ( SMSShell . exceptions . ShellException ) : [EOL] shell . exec ( [string] , [string] ) [EOL] [EOL] with pytest . raises ( SMSShell . exceptions . ShellException ) : [EOL] shell . exec ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def test_secure_wrapper ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] [EOL] shell = SMSShell . shell . Shell ( conf , metrics ) [EOL] sw = shell . getSecureShell ( ) [EOL] sw . flushCommandCache ( ) [EOL] [EOL] def test_secure_wrapper_isolation ( ) : [EOL] [docstring] [EOL] conf = SMSShell . config . MyConfigParser ( ) [EOL] assert conf . load ( [string] ) [ [number] ] [EOL] assert conf . isLoaded ( ) [EOL] [EOL] metrics = SMSShell . metrics . none . MetricsHelper ( ) [EOL] [EOL] shell = SMSShell . shell . Shell ( conf , metrics ) [EOL] sw = shell . getSecureShell ( ) [EOL] [EOL] with pytest . raises ( SMSShell . exceptions . ShellException ) : [EOL] sw . exec ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import queue [EOL] import SMSShell [EOL] import subprocess [EOL] import typing [EOL] import queue [EOL] import os [EOL] import shlex [EOL] import stat [EOL] import subprocess [EOL] import threading [EOL] [EOL] import SMSShell . receivers . fifo [EOL] import SMSShell . receivers . unix [EOL] [EOL] [EOL] [comment] [EOL] def test_cmdline_help ( ) : [EOL] [docstring] [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert [string] in stdout . decode ( ) [EOL] [EOL] def test_cmdline_version ( ) : [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert [string] in stdout . decode ( ) [EOL] [EOL] def test_cmdline_without_arguments ( ) : [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert result . returncode == [number] [EOL] [EOL] def test_cmdline_without_input_argument_arguments ( ) : [EOL] [docstring] [EOL] result = subprocess . Popen ( shlex . split ( [string] ) , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( ) [EOL] assert result . returncode == [number] [EOL] [EOL] def test_cmdline_write_fifo ( ) : [EOL] [docstring] [EOL] m_fifo = [string] [EOL] m_data = [string] [EOL] m_channel = queue . Queue ( ) [EOL] [EOL] def writeToFifo ( channel , fifo , data ) : [EOL] p = subprocess . Popen ( shlex . split ( [string] . format ( fifo ) ) , stdin = subprocess . PIPE , stdout = subprocess . PIPE ) [EOL] ( stdout , stderr ) = p . communicate ( input = data . encode ( ) ) [EOL] channel . put ( ( stdout , stderr , p . returncode ) ) [EOL] [EOL] [comment] [EOL] receiver = SMSShell . receivers . fifo . Receiver ( config = dict ( path = m_fifo ) ) [EOL] assert receiver . start ( ) [EOL] assert os . path . exists ( m_fifo ) [EOL] assert stat . S_ISFIFO ( os . stat ( m_fifo ) . st_mode ) [EOL] [EOL] [comment] [EOL] threading . Thread ( target = writeToFifo , args = ( m_channel , m_fifo , m_data ) ) . start ( ) [EOL] [EOL] client_context = next ( receiver . read ( ) ) [EOL] with client_context as client_context_data : [EOL] [comment] [EOL] assert m_data in client_context_data [EOL] [EOL] [comment] [EOL] stdout , stderr , returncode = m_channel . get ( ) [EOL] assert returncode == [number] [EOL] [comment] [EOL] assert receiver . stop ( ) [EOL] assert not os . path . exists ( m_fifo ) [EOL] [EOL] def test_cmdline_write_fifo_with_os_error ( ) : [EOL] [docstring] [EOL] m_fifo = [string] [EOL] m_data = [string] [EOL] result = subprocess . Popen ( shlex . split ( [string] . format ( m_fifo ) ) , stdin = subprocess . PIPE , stdout = subprocess . PIPE ) [EOL] stdout , stderr = result . communicate ( input = m_data . encode ( ) ) [EOL] assert result . returncode == [number] [EOL] [EOL] def test_cmdline_write_unix ( ) : [EOL] [docstring] [EOL] m_unix = [string] [EOL] m_data = [string] [EOL] m_channel = queue . Queue ( ) [EOL] [EOL] def writeToUnix ( queue , unix , data ) : [EOL] p = subprocess . Popen ( shlex . split ( [string] . format ( unix ) ) , stdin = subprocess . PIPE , stdout = subprocess . PIPE ) [EOL] [EOL] ( stdout , stderr ) = p . communicate ( input = data . encode ( ) ) [EOL] queue . put ( ( stdout , stderr , p . returncode ) ) [EOL] [EOL] [comment] [EOL] receiver = SMSShell . receivers . unix . Receiver ( config = dict ( path = m_unix ) ) [EOL] assert receiver . start ( ) [EOL] assert os . path . exists ( m_unix ) [EOL] assert stat . S_ISSOCK ( os . stat ( m_unix ) . st_mode ) [EOL] [EOL] [comment] [EOL] threading . Thread ( target = writeToUnix , args = ( m_channel , m_unix , m_data ) ) . start ( ) [EOL] [EOL] [comment] [EOL] client_context = next ( receiver . read ( ) ) [EOL] with client_context as client_context_data : [EOL] [comment] [EOL] assert m_data in client_context_data [EOL] [EOL] [comment] [EOL] stdout , stderr , returncode = m_channel . get ( ) [EOL] assert returncode == [number] [EOL] [comment] [EOL] assert receiver . stop ( ) [EOL] assert not os . path . exists ( m_unix ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . utils [EOL] [EOL] [EOL] def test_user_to_uid ( ) : [EOL] [docstring] [EOL] assert SMSShell . utils . userToUid ( [string] ) == [number] [EOL] assert SMSShell . utils . userToUid ( [string] ) == [number] [EOL] [EOL] with pytest . raises ( KeyError ) : [EOL] SMSShell . utils . userToUid ( [string] ) [EOL] [EOL] def test_group_to_gid ( ) : [EOL] [docstring] [EOL] assert SMSShell . utils . groupToGid ( [string] ) == [number] [EOL] assert SMSShell . utils . groupToGid ( [string] ) == [number] [EOL] [EOL] with pytest . raises ( KeyError ) : [EOL] SMSShell . utils . groupToGid ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict [EOL] import typing [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] [EOL] env1 = dict ( SMS_MESSAGES = [string] , DECODED_PARTS = [string] , SMS_1_NUMBER = [string] , SMS_1_CLASS = [string] , SMS_1_TEXT = [string] , ) [EOL] [EOL] env2 = dict ( SMS_2_CLASS = [string] , SMS_MESSAGES = [string] , DECODED_PARTS = [string] , SMS_3_NUMBER = [string] , SMS_3_TEXT = [string] , SMS_2_TEXT = [string] , SMS_2_NUMBER = [string] , SMS_3_CLASS = [string] , DECODED_0_TEXT = [string] , SMS_1_NUMBER = [string] , SMS_1_CLASS = [string] , SMS_1_TEXT = [string] ) [EOL] [EOL] env = env2 [EOL] [EOL] for key in env : [EOL] os . environ [ key ] = env [ key ] [EOL] [EOL] subprocess . call ( [ [string] ] , stdout = sys . stdout ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . models . message [EOL] [EOL] [EOL] def test_message ( ) : [EOL] [docstring] [EOL] m = SMSShell . models . message . Message ( [string] , [string] ) [EOL] assert m . number == [string] [EOL] assert m . content == [string] [EOL] assert isinstance ( m . asString ( ) , str ) [EOL] assert [string] in str ( m ) [EOL] assert [string] in repr ( m ) [EOL] [EOL] def test_message_attribute ( ) : [EOL] m = SMSShell . models . message . Message ( [string] , [string] , attributes = { [string] : [number] } ) [EOL] assert m . attribute ( [string] ) == [number] [EOL] [EOL] assert [string] in m . attributes [EOL] [EOL] def test_message_missing_attribute ( ) : [EOL] m = SMSShell . models . message . Message ( [string] , [string] , attributes = { [string] : [number] } ) [EOL] [EOL] with pytest . raises ( AttributeError ) : [EOL] m . attribute ( [string] ) [EOL] [EOL] assert m . attribute ( [string] , [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import SMSShell [EOL] import pytest [EOL] [EOL] import SMSShell [EOL] import SMSShell . metrics . prometheus [EOL] [EOL] [EOL] def test_run ( ) : [EOL] [docstring] [EOL] metrics = SMSShell . metrics . prometheus . MetricsHelper ( ) [EOL] assert metrics . start ( ) [EOL] assert metrics . stop ( ) [EOL] [EOL] def test_init_bad_configuration ( ) : [EOL] [docstring] [EOL] metrics = SMSShell . metrics . prometheus . MetricsHelper ( config = dict ( listen_port = [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , Optional , List , Iterator , Union , Literal [EOL] import typing_extensions [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import configparser [EOL] import logging [EOL] import re [EOL] [EOL] [comment] [EOL] from . utils import userToUid , groupToGid [EOL] from . exceptions import ShellInitException [EOL] from . import validators [EOL] from . import filters [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class MyConfigParser ( configparser . ConfigParser ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] LOGLEVEL_MAP = [ [string] , [string] , [string] , [string] ] [EOL] MODE_MAP = [ [string] , [string] ] [EOL] MAIN_SECTION = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] configparser . ConfigParser . __init__ ( self ) [EOL] [EOL] [comment] [EOL] self . __is_config_loaded = False [EOL] [EOL] def load ( self , path ) : [EOL] [docstring] [EOL] assert path is not None [EOL] msg = [string] [EOL] try : [EOL] if path in self . read ( path ) : [EOL] self . __is_config_loaded = True [EOL] except configparser . Error as ex : [EOL] msg = [string] . format ( str ( ex ) ) [EOL] return self . __is_config_loaded , msg [EOL] [EOL] def isLoaded ( self ) : [EOL] [docstring] [EOL] return self . __is_config_loaded [EOL] [EOL] def getLogLevel ( self , section = MAIN_SECTION , item = [string] , default = [string] ) : [EOL] [docstring] [EOL] return self . __getValueInArray ( section , item , self . LOGLEVEL_MAP , default ) [EOL] [EOL] def getUid ( self , section = MAIN_SECTION , item = [string] , default = None ) : [EOL] [docstring] [EOL] user = self . get ( section , item , fallback = None ) [EOL] if not user : [EOL] return default [EOL] try : [EOL] return userToUid ( user ) [EOL] except KeyError : [EOL] g_logger . error ( ( [string] [string] ) , user , section , item ) [EOL] return default [EOL] [EOL] def getGid ( self , section = MAIN_SECTION , item = [string] , default = None ) : [EOL] [docstring] [EOL] group = self . get ( section , item , fallback = None ) [EOL] if not group : [EOL] return default [EOL] try : [EOL] return groupToGid ( group ) [EOL] except KeyError : [EOL] g_logger . error ( ( [string] [string] ) , group , section , item ) [EOL] return default [EOL] [EOL] def getMode ( self ) : [EOL] [docstring] [EOL] return self . __getValueInArray ( self . MAIN_SECTION , [string] , self . MODE_MAP , [string] ) [EOL] [EOL] def getModeConfig ( self , key , fallback = None ) : [EOL] [docstring] [EOL] return self . get ( self . getMode ( ) . lower ( ) , key , fallback = fallback ) [EOL] [EOL] def getSectionOrEmpty ( self , name ) : [EOL] [docstring] [EOL] if self . has_section ( name ) : [EOL] return dict ( self . items ( name ) ) [EOL] return dict ( ) [EOL] [EOL] def getValidatorsFromConfig ( self , key ) : [EOL] [docstring] [EOL] return self . getClassesChainFromConfig ( self . getMode ( ) . lower ( ) , key , validators , base_class = validators . AbstractValidator ) [EOL] [EOL] def getFiltersFromConfig ( self , key ) : [EOL] [docstring] [EOL] return self . getClassesChainFromConfig ( self . getMode ( ) . lower ( ) , key , filters , base_class = filters . AbstractFilter ) [EOL] [EOL] def getClassesChainFromConfig ( self , section , key , module , base_class = None ) : [EOL] [docstring] [EOL] classes_config = dict ( ) [EOL] raw_config = self . get ( section , key , fallback = [string] ) [EOL] fields_spec = filter ( lambda x : x , raw_config . split ( [string] ) ) [EOL] [EOL] [comment] [EOL] for spec in fields_spec : [EOL] try : [EOL] field , field_classes = spec . split ( [string] , [number] ) [EOL] except ValueError as ex : [EOL] g_logger . error ( [string] , spec , str ( ex ) ) [EOL] continue [EOL] [EOL] [comment] [EOL] if field in classes_config : [EOL] g_logger . error ( ( [string] + [string] + [string] ) , field ) [EOL] continue [EOL] [EOL] classes_config [ field ] = [ ] [EOL] classes_parts_splitted = re . split ( [string] , field_classes ) [EOL] classes_parts = [ ] [EOL] i = [number] [EOL] [comment] [EOL] while i < len ( classes_parts_splitted ) : [EOL] if i == [number] : [EOL] classes_parts . append ( classes_parts_splitted [ i ] ) [EOL] else : [EOL] classes_parts . append ( [string] . join ( classes_parts_splitted [ i : ( i + [number] ) ] ) ) [EOL] i += [number] [EOL] i += [number] [EOL] [EOL] [comment] [EOL] for field_classes_spec in classes_parts : [EOL] class_name , class_args_raw = field_classes_spec . split ( [string] , [number] ) [EOL] [EOL] real_class_name = class_name [ [number] ] . upper ( ) + class_name [ [number] : ] [EOL] if not hasattr ( module , real_class_name ) : [EOL] g_logger . error ( ( [string] + [string] ) , class_name , field ) [EOL] continue [EOL] class_args = filter ( lambda x : x , class_args_raw . split ( [string] ) ) [EOL] _class = getattr ( module , real_class_name ) [EOL] try : [EOL] _instance = _class ( * class_args ) [EOL] if base_class and not isinstance ( _instance , base_class ) : [EOL] raise Exception ( ( [string] + [string] ) . format ( real_class_name , base_class ) ) [EOL] except Exception as ex : [EOL] raise ShellInitException ( ( [string] + [string] ) . format ( _class . __name__ . lower ( ) , field , ex . __class__ , str ( ex ) ) ) [EOL] [EOL] classes_config [ field ] . append ( _instance ) [EOL] g_logger . debug ( [string] , len ( classes_config [ field ] ) , field ) [EOL] return classes_config [EOL] [EOL] def __getValueInArray ( self , section , key , array , default = None ) : [EOL] [docstring] [EOL] val = self . get ( section , key , fallback = default ) [EOL] if val not in array : [EOL] g_logger . error ( [string] , key , val , array ) [EOL] return default [EOL] return val [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import SMSShell [EOL] import typing [EOL] import logging [EOL] import _importlib_modulespec [EOL] [docstring] [EOL] [EOL] __author__ = [string] [EOL] __license__ = [string] [EOL] __version__ = [string] [EOL] __maintainer__ = [string] [EOL] __email__ = [string] [EOL] [EOL] [comment] [EOL] import importlib [EOL] import logging [EOL] import logging . handlers [EOL] import os [EOL] import signal [EOL] import sys [EOL] [EOL] [comment] [EOL] from . config import MyConfigParser [EOL] from . validators import ValidationException , ValidatorChain [EOL] from . filters import FilterException , FilterChain [EOL] from . models import Message , SessionStates [EOL] from . receivers import AbstractReceiver [EOL] from . parsers import AbstractParser [EOL] from . transmitters import AbstractTransmitter [EOL] from . metrics import AbstractMetricsHelper [EOL] from . shell import Shell [EOL] from . exceptions import SMSShellException , SMSException , ShellException , ShellInitException [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class SMSShell ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , daemon = False , log_level = None ) : [EOL] [docstring] [EOL] [comment] [EOL] self . cp = MyConfigParser ( ) [EOL] self . __daemon = daemon [EOL] [EOL] self . __pid_path = None [EOL] [EOL] [comment] [EOL] self . __log_level = log_level [EOL] [EOL] [comment] [EOL] self . __stop_callbacks = [ ] [EOL] [EOL] [comment] [EOL] self . __metrics = None [EOL] [EOL] def load ( self , config_file ) : [EOL] [docstring] [EOL] if config_file is None : [EOL] return False , [string] [EOL] if not os . path . isfile ( config_file ) : [EOL] return False , [string] . format ( config_file ) [EOL] if not os . access ( config_file , os . R_OK ) : [EOL] return False , ( [string] [string] ) . format ( config_file ) [EOL] [EOL] status , msg = self . cp . load ( config_file ) [EOL] if status : [EOL] self . setLogLevel ( self . __log_level or self . cp . getLogLevel ( ) ) [EOL] self . setLogTarget ( self . cp . get ( self . cp . MAIN_SECTION , [string] , fallback = [string] ) ) [EOL] return status , msg [EOL] [EOL] def start ( self , pid_path = None ) : [EOL] [docstring] [EOL] [comment] [EOL] os . umask ( [number] ) [EOL] [EOL] [comment] [EOL] signal . signal ( signal . SIGTERM , self . __sigTERM_handler ) [EOL] signal . signal ( signal . SIGINT , self . __sigTERM_handler ) [EOL] [EOL] [comment] [EOL] if not self . cp . isLoaded ( ) : [EOL] return False [EOL] [EOL] g_logger . info ( [string] + __version__ ) [EOL] [EOL] [comment] [EOL] if self . __daemon : [EOL] g_logger . debug ( [string] ) [EOL] if self . __daemonize ( ) : [EOL] g_logger . info ( [string] ) [EOL] else : [EOL] g_logger . fatal ( [string] ) [EOL] raise Exception ( [string] ) [EOL] [EOL] [comment] [EOL] if pid_path is None : [EOL] pid_path = self . cp . get ( self . cp . MAIN_SECTION , [string] , fallback = [string] ) [EOL] self . __pid_path = pid_path [EOL] [EOL] [comment] [EOL] if os . path . isfile ( self . __pid_path ) : [EOL] with open ( self . __pid_path , [string] ) as pid_file : [EOL] current_pid = pid_file . read ( ) [EOL] if os . path . isdir ( [string] . format ( current_pid ) ) : [EOL] with open ( [string] . format ( current_pid ) ) as cmdline : [EOL] current_cmdline_parts = cmdline . read ( ) . split ( [string] ) [EOL] [EOL] if current_cmdline_parts : [EOL] current_cmdline = current_cmdline_parts [ [number] ] [EOL] raise ShellInitException ( [string] + [string] . format ( current_cmdline ) ) [EOL] [EOL] [comment] [EOL] try : [EOL] g_logger . debug ( [string] , self . __pid_path ) [EOL] with open ( self . __pid_path , [string] ) as pid_file : [EOL] pid_file . write ( str ( os . getpid ( ) ) ) [EOL] except IOError : [EOL] g_logger . error ( [string] , self . __pid_path ) [EOL] [EOL] [comment] [EOL] self . __downgrade ( ) [EOL] [EOL] [comment] [EOL] try : [EOL] metrics = self . importAndLoadModule ( [string] + self . cp . get ( [string] , [string] , fallback = [string] ) , [string] , AbstractMetricsHelper , [string] ) [EOL] except ShellInitException as ex : [EOL] g_logger . fatal ( [string] , str ( ex ) ) [EOL] self . stop ( ) [EOL] return False [EOL] [EOL] if not metrics . start ( ) : [EOL] g_logger . fatal ( [string] ) [EOL] self . stop ( ) [EOL] return False [EOL] self . __metrics = metrics [EOL] self . __stop_callbacks . append ( metrics . stop ) [EOL] [EOL] [comment] [EOL] if self . cp . getMode ( ) == [string] : [EOL] [comment] [EOL] self . stop ( ) [EOL] raise NotImplementedError ( [string] ) [EOL] else : [EOL] self . runDaemonMode ( ) [EOL] [EOL] [comment] [EOL] self . stop ( ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def importAndLoadModule ( self , module_path , class_name , abstract_class = None , config_section = None ) : [EOL] [docstring] [EOL] try : [EOL] mod = importlib . import_module ( module_path , package = [string] ) [EOL] except ImportError as ex : [EOL] raise ShellInitException ( ( [string] [string] ) . format ( module_path , str ( ex ) ) ) [EOL] try : [comment] [EOL] _class = getattr ( mod , class_name ) [EOL] _class_args = dict ( metrics = self . __metrics ) [EOL] [comment] [EOL] if config_section and config_section in self . cp : [EOL] _class_args [ [string] ] = self . cp [ config_section ] [EOL] inst = _class ( ** _class_args ) [EOL] except AttributeError as ex : [EOL] raise ShellInitException ( [string] . format ( module_path , str ( ex ) ) ) [EOL] [EOL] [comment] [EOL] if abstract_class and not isinstance ( inst , abstract_class ) : [EOL] raise ShellInitException ( ( [string] [string] ) . format ( module_path ) ) [EOL] return inst [EOL] [EOL] def getTokensStoreFromConfig ( self ) : [EOL] [docstring] [EOL] tokens_store = dict ( ) [EOL] raw_tokens = self . cp . getModeConfig ( [string] ) [EOL] if not raw_tokens : [EOL] return tokens_store [EOL] for raw_token in raw_tokens . split ( [string] ) : [EOL] [comment] [EOL] try : [EOL] state , token = raw_token . split ( [string] ) [EOL] except ValueError as ex : [EOL] g_logger . error ( [string] + [string] ) [EOL] continue [EOL] [EOL] [comment] [EOL] try : [EOL] real_state = SessionStates [ state ] [EOL] except KeyError : [EOL] g_logger . error ( [string] + [string] + [string] , str ( state ) ) [EOL] continue [EOL] g_logger . debug ( [string] , len ( token ) , str ( real_state ) ) [EOL] if token not in tokens_store : [EOL] tokens_store [ token ] = [ ] [EOL] if real_state in tokens_store [ token ] : [EOL] g_logger . warning ( [string] , str ( real_state ) ) [EOL] else : [EOL] tokens_store [ token ] . append ( real_state ) [EOL] return tokens_store [EOL] [EOL] @ staticmethod def extractRoleFromMessageAndStore ( tokens_store , message ) : [EOL] [docstring] [EOL] try : [EOL] auth_attr = message . attribute ( [string] ) [EOL] except KeyError : [EOL] return None [EOL] [EOL] assert isinstance ( auth_attr , dict ) [EOL] if [string] not in auth_attr or [string] not in auth_attr : [EOL] g_logger . warning ( [string] ) [EOL] return None [EOL] [EOL] if auth_attr [ [string] ] not in tokens_store : [EOL] g_logger . error ( [string] , len ( auth_attr [ [string] ] ) ) [EOL] return None [EOL] [EOL] reachable_states = tokens_store [ auth_attr [ [string] ] ] [EOL] try : [EOL] needed_state = SessionStates [ auth_attr [ [string] ] ] [EOL] except KeyError : [EOL] g_logger . error ( [string] + [string] + [string] , str ( auth_attr [ [string] ] ) ) [EOL] return None [EOL] if needed_state in reachable_states : [EOL] return needed_state [EOL] return None [EOL] [EOL] def runDaemonMode ( self ) : [EOL] [docstring] [EOL] shell = Shell ( self . cp , self . __metrics ) [EOL] [EOL] [comment] [EOL] try : [EOL] parser = self . importAndLoadModule ( [string] + self . cp . get ( [string] , [string] , fallback = [string] ) , [string] , AbstractParser , [string] ) [EOL] recv = self . importAndLoadModule ( [string] + self . cp . get ( [string] , [string] , fallback = [string] ) , [string] , AbstractReceiver , [string] ) [EOL] transm = self . importAndLoadModule ( [string] + self . cp . get ( [string] , [string] , fallback = [string] ) , [string] , AbstractTransmitter , [string] ) [EOL] except ShellInitException as ex : [EOL] g_logger . fatal ( [string] , str ( ex ) ) [EOL] return False [EOL] [EOL] if not recv . start ( ) : [EOL] g_logger . fatal ( [string] ) [EOL] return False [EOL] [comment] [EOL] self . __stop_callbacks . append ( recv . stop ) [EOL] [EOL] if not transm . start ( ) : [EOL] g_logger . fatal ( [string] ) [EOL] return False [EOL] self . __stop_callbacks . append ( transm . stop ) [EOL] [EOL] g_logger . debug ( [string] ) [EOL] tokens_store = self . getTokensStoreFromConfig ( ) [EOL] g_logger . info ( [string] , len ( tokens_store ) ) [EOL] [EOL] [comment] [EOL] g_logger . debug ( [string] ) [EOL] self . __metrics . counter ( [string] , labels = [ [string] ] , description = [string] ) [EOL] self . __metrics . counter ( [string] , labels = [ [string] ] , description = [string] ) [EOL] [EOL] [comment] [EOL] try : [EOL] g_logger . debug ( [string] ) [EOL] input_validators_chain = ValidatorChain ( ) [EOL] input_validators_chain . addLinksFromDict ( self . cp . getValidatorsFromConfig ( [string] ) ) [EOL] input_filters_chain = FilterChain ( ) [EOL] input_filters_chain . addLinksFromDict ( self . cp . getFiltersFromConfig ( [string] ) ) [EOL] g_logger . debug ( [string] ) [EOL] output_validators_chain = ValidatorChain ( ) [EOL] output_validators_chain . addLinksFromDict ( self . cp . getValidatorsFromConfig ( [string] ) ) [EOL] except ShellInitException as ex : [EOL] raise ex [EOL] g_logger . fatal ( [string] , str ( ex ) ) [EOL] return False [EOL] [EOL] [comment] [EOL] for client_context in recv . read ( ) : [EOL] with client_context as client_context_data : [EOL] [comment] [EOL] try : [EOL] msg = parser . parse ( client_context_data ) [EOL] client_context . appendTreatmentChain ( [string] ) [EOL] except SMSException as ex : [EOL] self . __metrics . counter ( [string] , labels = dict ( status = [string] ) ) [EOL] g_logger . error ( [string] , str ( ex ) ) [EOL] continue [EOL] [EOL] [comment] [EOL] try : [EOL] input_validators_chain . callChainOnObject ( msg ) [EOL] input_filters_chain . callChainOnObject ( msg ) [EOL] except ( ValidationException , FilterException ) as ex : [EOL] self . __metrics . counter ( [string] , labels = dict ( status = [string] ) ) [EOL] g_logger . error ( ( [string] + [string] ) , str ( ex ) ) [EOL] continue [EOL] self . __metrics . counter ( [string] , labels = dict ( status = [string] ) ) [EOL] client_context . appendTreatmentChain ( [string] ) [EOL] [EOL] [comment] [EOL] as_role = SMSShell . extractRoleFromMessageAndStore ( tokens_store , msg ) [EOL] [EOL] [comment] [EOL] try : [EOL] response_content = shell . exec ( msg . number , msg . asString ( ) , as_role = as_role ) [EOL] client_context . appendTreatmentChain ( [string] ) [EOL] except ShellException as ex : [EOL] g_logger . error ( [string] , ex . args [ [number] ] ) [EOL] if len ( ex . args ) > [number] and ex . args [ [number] ] : [EOL] ex_message = ex . args [ [number] ] [EOL] else : [EOL] ex_message = str ( ex ) [EOL] response_content = [string] . format ( ex_message ) [EOL] [EOL] [comment] [EOL] [EOL] answer = Message ( msg . number , response_content ) [EOL] client_context . addResponseData ( output = answer . asString ( ) ) [EOL] [EOL] if not msg . attribute ( [string] , True ) : [EOL] self . __metrics . counter ( [string] , labels = dict ( status = [string] ) ) [EOL] continue [EOL] [EOL] [comment] [EOL] try : [EOL] output_validators_chain . callChainOnObject ( answer ) [EOL] except ValidationException as ex : [EOL] self . __metrics . counter ( [string] , labels = dict ( status = [string] ) ) [EOL] g_logger . error ( [string] ) [EOL] continue [EOL] client_context . appendTreatmentChain ( [string] ) [EOL] [EOL] [comment] [EOL] try : [EOL] transm . transmit ( answer ) [EOL] except SMSException as ex : [EOL] self . __metrics . counter ( [string] , labels = dict ( status = [string] ) ) [EOL] g_logger . error ( [string] , str ( ex ) ) [EOL] continue [EOL] self . __metrics . counter ( [string] , labels = dict ( status = [string] ) ) [EOL] client_context . appendTreatmentChain ( [string] ) [EOL] [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] for cb_stop in self . __stop_callbacks : [EOL] try : [EOL] cb_stop ( ) [EOL] except NotImplementedError as ex : [EOL] g_logger . warning ( [string] , cb_stop . __self__ . __class__ , str ( ex ) ) [EOL] [comment] [EOL] try : [EOL] g_logger . debug ( [string] , self . __pid_path ) [EOL] os . remove ( self . __pid_path ) [EOL] except OSError as ex : [EOL] g_logger . error ( [string] , str ( ex ) ) [EOL] [EOL] g_logger . info ( [string] ) [EOL] [EOL] [comment] [EOL] logging . shutdown ( ) [EOL] [EOL] return [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __sigTERM_handler ( self , signum , frame ) : [EOL] [docstring] [EOL] g_logger . debug ( [string] , signum ) [EOL] sys . exit ( self . stop ( ) ) [EOL] [EOL] def __downgrade ( self ) : [EOL] [docstring] [EOL] gid = self . cp . getGid ( ) [EOL] if gid is not None : [EOL] if os . getgid ( ) == gid : [EOL] g_logger . debug ( ( [string] [string] ) , gid ) [EOL] else : [EOL] g_logger . debug ( [string] , gid ) [EOL] try : [EOL] os . setgid ( gid ) [EOL] except PermissionError : [EOL] g_logger . fatal ( [string] , gid ) [EOL] raise SMSShellException ( [string] + [string] ) [EOL] [EOL] uid = self . cp . getUid ( ) [EOL] if uid is not None : [EOL] if os . getuid ( ) == uid : [EOL] g_logger . debug ( ( [string] [string] ) , uid ) [EOL] else : [EOL] g_logger . debug ( [string] , uid ) [EOL] try : [EOL] os . setuid ( uid ) [EOL] except PermissionError : [EOL] g_logger . fatal ( [string] ) [EOL] raise SMSShellException ( [string] + [string] ) [EOL] [EOL] @ staticmethod def __daemonize ( ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pid = os . fork ( ) [EOL] except OSError as ex : [EOL] return ( ex . errno , ex . strerror ) [EOL] [EOL] if pid == [number] : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] os . setsid ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pid = os . fork ( ) [comment] [EOL] except OSError as ex : [EOL] return ( ex . errno , ex . strerror ) [EOL] [EOL] if pid == [number] : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] os . chdir ( [string] ) [EOL] else : [EOL] [comment] [EOL] os . _exit ( [number] ) [comment] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] os . _exit ( [number] ) [comment] [EOL] return True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ staticmethod def setLogLevel ( value ) : [EOL] [docstring] [EOL] try : [EOL] g_logger . setLevel ( value ) [EOL] g_logger . info ( [string] , value ) [EOL] return True [EOL] except AttributeError : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def setLogTarget ( self , target ) : [EOL] [docstring] [EOL] [comment] [EOL] if target == [string] : [EOL] default_format = [string] [EOL] [comment] [EOL] else : [EOL] default_format = [string] [EOL] formatter = logging . Formatter ( self . cp . get ( self . cp . MAIN_SECTION , [string] , fallback = default_format ) ) [EOL] [EOL] if target == [string] : [EOL] facility = logging . handlers . SysLogHandler . LOG_DAEMON [EOL] hdlr = logging . handlers . SysLogHandler ( [string] , facility = facility ) [EOL] elif target == [string] : [EOL] hdlr = logging . StreamHandler ( sys . stdout ) [EOL] elif target == [string] : [EOL] hdlr = logging . StreamHandler ( sys . stderr ) [EOL] else : [EOL] [comment] [EOL] try : [EOL] with open ( target , [string] ) : [EOL] pass [EOL] hdlr = logging . handlers . RotatingFileHandler ( target ) [EOL] except IOError : [EOL] g_logger . error ( [string] , target ) [EOL] return False [EOL] [EOL] [comment] [EOL] for handler in g_logger . handlers : [EOL] try : [EOL] g_logger . removeHandler ( handler ) [EOL] except ( ValueError , KeyError ) : [EOL] g_logger . error ( [string] , str ( type ( handler ) ) ) [EOL] [EOL] hdlr . setFormatter ( formatter ) [EOL] g_logger . addHandler ( hdlr ) [EOL] [comment] [EOL] g_logger . info ( [string] , target ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SMSShell.config.MyConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SMSShell.models.session.SessionStates$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $SMSShell.models.session.SessionStates$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $SMSShell.models.session.SessionStates$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $SMSShell.models.session.SessionStates$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $SMSShell.models.session.SessionStates$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $SMSShell.models.session.SessionStates$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $SMSShell.models.session.SessionStates$ 0 $typing.Any$ 0 0 0 $SMSShell.models.session.SessionStates$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SMSShell.shell.Shell$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $SMSShell.validators.ValidatorChain$ 0 0 0 0 0 $SMSShell.validators.ValidatorChain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $SMSShell.filters.FilterChain$ 0 0 0 0 0 $SMSShell.filters.FilterChain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $SMSShell.validators.ValidatorChain$ 0 0 0 0 0 $SMSShell.validators.ValidatorChain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SMSShell.validators.ValidatorChain$ 0 0 0 $typing.Any$ 0 0 $SMSShell.filters.FilterChain$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $SMSShell.shell.Shell$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $SMSShell.models.message.Message$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $SMSShell.models.message.Message$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SMSShell.validators.ValidatorChain$ 0 0 0 $SMSShell.models.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $SMSShell.models.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $logging.handlers.RotatingFileHandler$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $logging.handlers.RotatingFileHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.handlers.RotatingFileHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.handlers.RotatingFileHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.handlers.RotatingFileHandler$ 0 0 0 $logging.Formatter$ 0 0 $logging.Logger$ 0 0 0 $logging.handlers.RotatingFileHandler$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from . exceptions import ShellInitException [EOL] [EOL] [EOL] class Chain ( object ) : [EOL] [docstring] [EOL] [EOL] ABSTRACT_CLASS = object [EOL] EXCEPTION = Exception [EOL] ASSIGN_RETURN = False [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . __field_links = dict ( ) [EOL] [EOL] def addFieldLink ( self , field , link ) : [EOL] [docstring] [EOL] if ( self . __class__ . ABSTRACT_CLASS and not isinstance ( link , self . __class__ . ABSTRACT_CLASS ) ) : [EOL] raise ShellInitException ( [string] . format ( repr ( link ) , self . __class__ . ABSTRACT_CLASS . __name__ . lower ( ) ) ) [EOL] [EOL] if field not in self . __field_links : [EOL] self . __field_links [ field ] = [ ] [EOL] self . __field_links [ field ] . append ( link ) [EOL] [EOL] def addLinksFromDict ( self , field_links_map ) : [EOL] [docstring] [EOL] for field , links in field_links_map . items ( ) : [EOL] for l in links : [EOL] self . addFieldLink ( field , l ) [EOL] [EOL] def callChainOnObject ( self , obj ) : [EOL] [docstring] [EOL] for field , links in self . __field_links . items ( ) : [EOL] if not hasattr ( obj , field ) : [EOL] raise self . __class__ . EXCEPTION ( ( [string] + [string] ) . format ( field ) ) [EOL] for l in links : [EOL] r = l ( getattr ( obj , field ) ) [EOL] if self . __class__ . ASSIGN_RETURN : [EOL] setattr ( obj , field , r ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.object]$ 0 0 0 $typing.Type[builtins.Exception]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] class SMSShellException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] class ShellInitException ( SMSShellException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class SMSException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class ShellException ( Exception ) : [EOL] [docstring] [EOL] def __init__ ( self , message , short = [string] ) : [EOL] super ( ) . __init__ ( message , short ) [EOL] [EOL] class BadCommandCall ( ShellException ) : [EOL] [docstring] [EOL] def __init__ ( self , message , short = [string] ) : [EOL] super ( ) . __init__ ( message , short ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type , List [EOL] import SMSShell [EOL] import inspect [EOL] import typing [EOL] import logging [EOL] import _importlib_modulespec [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import argparse [EOL] import importlib [EOL] import importlib . util [EOL] import inspect [EOL] import logging [EOL] import re [EOL] import os [EOL] import shlex [EOL] [EOL] [comment] [EOL] from . exceptions import ShellException , BadCommandCall [EOL] from . models import Session , SessionStates [EOL] from . commands import ( AbstractCommand , CommandForbidden , CommandNotFoundException , CommandBadImplemented , CommandBadConfiguredException , CommandException ) [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class Shell ( object ) : [EOL] [docstring] [EOL] WORD_REGEX_PATTERN = re . compile ( [string] ) [EOL] [EOL] def __init__ ( self , configparser , metrics ) : [EOL] [docstring] [EOL] self . configparser = configparser [EOL] self . __metrics = metrics [EOL] self . __sessions = dict ( ) [EOL] self . __commands = dict ( ) [EOL] [EOL] def exec ( self , subject , cmdline , as_role = None ) : [EOL] [docstring] [EOL] try : [EOL] argv = shlex . split ( cmdline ) [EOL] except ValueError as ex : [EOL] raise ShellException ( [string] + str ( ex ) , [string] + str ( ex ) . lower ( ) . strip ( ) ) [EOL] if not argv : [EOL] raise ShellException ( [string] , [string] ) [EOL] [EOL] cmd = argv [ [number] ] [EOL] if not cmd : [EOL] raise ShellException ( [string] ) [EOL] [EOL] if not subject : [EOL] raise ShellException ( [string] ) [EOL] [EOL] g_logger . info ( [string] , subject , cmd , str ( argv [ [number] : ] ) ) [EOL] if as_role is not None : [EOL] assert isinstance ( as_role , SessionStates ) [EOL] sess = Session ( subject , time_to_live = [number] ) [EOL] sess . forceState ( as_role ) [EOL] g_logger . info ( [string] , subject , cmd , as_role . name ) [EOL] else : [EOL] sess = self . __getSessionForSubject ( subject ) [EOL] return self . __call ( sess , cmd , argv [ [number] : ] ) . strip ( ) [EOL] [EOL] def flushCommandCache ( self ) : [EOL] [docstring] [EOL] self . __commands = dict ( ) [EOL] [EOL] def getCommand ( self , session , name ) : [EOL] [docstring] [EOL] com = self . __getCommand ( name ) [EOL] if not Shell . hasSessionAccessToCommand ( session , com ) : [EOL] raise CommandForbidden ( [string] ) [EOL] return com [EOL] [EOL] def __getCommand ( self , name ) : [EOL] [docstring] [EOL] if name not in self . __commands : [EOL] self . __loadCommand ( name ) [EOL] return self . __commands [ name ] [EOL] [EOL] def __loadCommand ( self , name ) : [EOL] [docstring] [EOL] g_logger . debug ( [string] , name ) [EOL] try : [EOL] mod = importlib . import_module ( [string] + name , package = [string] ) [EOL] if importlib . util . find_spec ( [string] + name , package = [string] ) is not None : [EOL] importlib . reload ( mod ) [EOL] except ImportError : [EOL] raise CommandNotFoundException ( ( [string] + [string] ) . format ( name ) ) [EOL] [EOL] cls_name = Shell . toCamelCase ( name ) [EOL] try : [comment] [EOL] class_obj = getattr ( mod , cls_name ) [EOL] cmd = class_obj ( g_logger . getChild ( [string] + name ) , self . getSecureShell ( ) , self . configparser . getSectionOrEmpty ( [string] + name ) , self . __metrics ) [EOL] except AttributeError as ex : [EOL] raise CommandBadImplemented ( [string] . format ( name , str ( ex ) ) ) [EOL] [EOL] [comment] [EOL] if not isinstance ( cmd , AbstractCommand ) : [EOL] raise CommandBadImplemented ( [string] + [string] . format ( name ) ) [EOL] [EOL] [comment] [EOL] if not cmd . checkConfig ( ) : [EOL] raise CommandBadConfiguredException ( ( [string] [string] [string] ) . format ( name ) ) [EOL] else : [EOL] g_logger . debug ( [string] , name ) [EOL] [EOL] [comment] [EOL] self . __commands [ name ] = cmd [EOL] [EOL] def getAvailableCommands ( self , session ) : [EOL] [docstring] [EOL] all_commands = [ ] [EOL] self . loadAllCommands ( ) [EOL] for key in self . __commands : [EOL] if Shell . hasSessionAccessToCommand ( session , self . __commands [ key ] ) : [EOL] all_commands . append ( key ) [EOL] return all_commands [EOL] [EOL] def loadAllCommands ( self ) : [EOL] [docstring] [EOL] for com in os . listdir ( os . path . dirname ( __file__ ) + [string] ) : [EOL] if not com . startswith ( [string] ) and com . endswith ( [string] ) : [EOL] try : [EOL] self . __getCommand ( os . path . splitext ( com ) [ [number] ] ) [EOL] [comment] [EOL] except CommandException as ex : [EOL] g_logger . error ( str ( ex ) ) [EOL] [EOL] def __call ( self , session , cmd_name , argv ) : [EOL] [docstring] [EOL] com = self . __getCommand ( cmd_name ) [EOL] [comment] [EOL] session . setStoragePrefix ( cmd_name ) [EOL] [comment] [EOL] if not Shell . hasSessionAccessToCommand ( session , com ) : [EOL] raise CommandForbidden ( [string] ) [EOL] [EOL] [comment] [EOL] args = [ argv ] [EOL] parser = com . _argsParser ( ) [EOL] if parser : [EOL] try : [EOL] args . append ( parser . parse_args ( argv ) ) [EOL] except argparse . ArgumentError as ex : [EOL] raise BadCommandCall ( [string] . format ( str ( ex ) ) ) [EOL] [EOL] [comment] [EOL] sig = inspect . signature ( com . main ) [EOL] if len ( sig . parameters ) != len ( args ) : [EOL] raise CommandBadImplemented ( ( [string] [string] ) . format ( cmd_name , len ( args ) ) ) [EOL] [EOL] [comment] [EOL] session . access ( ) [EOL] com . session = session . getSecureSession ( ) [EOL] result = com . main ( * args ) [EOL] com . session = None [EOL] [EOL] [comment] [EOL] if not isinstance ( result , str ) : [EOL] raise CommandBadImplemented ( ( [string] [string] ) . format ( cmd_name ) ) [EOL] return result [EOL] [EOL] @ staticmethod def hasSessionAccessToCommand ( session , command ) : [EOL] [docstring] [EOL] states = command . _inputStates ( ) [EOL] if states and session . state not in command . _inputStates ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def __getSessionForSubject ( self , key ) : [EOL] [docstring] [EOL] if key in self . __sessions : [EOL] sess = self . __sessions [ key ] [EOL] if sess . isValid ( ) : [EOL] g_logger . debug ( [string] ) [EOL] return sess [EOL] [EOL] self . __sessions [ key ] = Session ( key ) [EOL] self . __sessions [ key ] . ttl = self . configparser . getModeConfig ( [string] , fallback = [number] ) [EOL] g_logger . debug ( [string] , key , self . __sessions [ key ] . ttl ) [EOL] return self . __sessions [ key ] [EOL] [EOL] [EOL] def getSecureShell ( self ) : [EOL] [docstring] [EOL] class ShellWrapper ( object ) : [EOL] [docstring] [EOL] ALLOWED_ATTRIBUTES = [ [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , shell ) : [EOL] [docstring] [EOL] self . __shell = shell [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] [docstring] [EOL] if name in ShellWrapper . ALLOWED_ATTRIBUTES : [EOL] return getattr ( self . __shell , name ) [EOL] raise ShellException ( [string] . format ( name ) ) [EOL] [EOL] return ShellWrapper ( self ) [EOL] [EOL] @ classmethod def toCamelCase ( cls , string ) : [EOL] [docstring] [EOL] words = [string] . join ( cls . WORD_REGEX_PATTERN . split ( string ) ) [EOL] return [string] . join ( x for x in words . title ( ) if not x . isspace ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $_importlib_modulespec.ModuleType$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $inspect.Signature$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $inspect.Signature$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Type , List [EOL] import SMSShell [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import re [EOL] [EOL] [comment] [EOL] from . exceptions import ShellInitException [EOL] from . chain import Chain [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class FilterException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class AbstractFilter ( object ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , data ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [EOL] class FilterChain ( Chain ) : [EOL] [docstring] [EOL] [EOL] ABSTRACT_CLASS = AbstractFilter [EOL] EXCEPTION = FilterException [EOL] ASSIGN_RETURN = True [EOL] [EOL] [EOL] class LowerCase ( AbstractFilter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , length , start = [number] ) : [EOL] try : [EOL] self . length = int ( length ) [EOL] self . start = int ( start ) [EOL] except ValueError as ex : [EOL] raise ShellInitException ( str ( ex ) ) [EOL] [EOL] def __call__ ( self , data ) : [EOL] return data [ self . start : self . length ] . lower ( ) + data [ ( self . start + self . length ) : ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[SMSShell.filters.AbstractFilter]$ 0 0 0 $typing.Type[SMSShell.filters.FilterException]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class AbstractModule ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config = None , metrics = None ) : [EOL] [docstring] [EOL] if not config : [EOL] config = dict ( ) [EOL] self . config = config [EOL] self . metrics = metrics [EOL] self . init ( ) [EOL] [EOL] def getConfig ( self , key , fallback = None ) : [EOL] [docstring] [EOL] if key in self . config : [EOL] return self . config [ key ] [EOL] return fallback [EOL] [EOL] def init ( self ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from . smsshell import SMSShell [EOL] from . smsshell import __version__ as version [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type , List [EOL] import SMSShell [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import re [EOL] [EOL] [comment] [EOL] from . chain import Chain [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class ValidationException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class AbstractValidator ( object ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , data ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [EOL] class ValidatorChain ( Chain ) : [EOL] [docstring] [EOL] [EOL] ABSTRACT_CLASS = AbstractValidator [EOL] EXCEPTION = ValidationException [EOL] [EOL] [EOL] class Regexp ( AbstractValidator ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , regex , flags = [number] , message = [string] ) : [EOL] if isinstance ( regex , str ) : [EOL] regex = re . compile ( regex , flags ) [EOL] self . regex = regex [EOL] self . message = message [EOL] [EOL] def __call__ ( self , data ) : [EOL] match = self . regex . match ( data or [string] ) [EOL] if not match : [EOL] raise ValidationException ( self . message ) [EOL] return data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[SMSShell.validators.AbstractValidator]$ 0 0 0 $typing.Type[SMSShell.validators.ValidationException]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type , Optional , List [EOL] import SMSShell [EOL] import typing [EOL] [docstring] [EOL] [EOL] import datetime [EOL] import os [EOL] import time [EOL] [EOL] try : [EOL] import gammu [EOL] except ImportError : [EOL] gammu = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class GammuSMSParser ( object ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] BACKUPFILE_SMS_TYPE_MAPPING = dict ( { [string] : [string] , [string] : [string] , [string] : [string] , } ) [EOL] BACKUPFILE_SMS_FIELD_MAPPING = dict ( { [string] : [string] , [string] : [string] , } ) [EOL] [EOL] ERROR_DUPLICATE_VALUE = [string] [EOL] ERROR_NO_CONTENT = [string] [EOL] ERROR_INCONSISTENCY = [string] [EOL] ERROR_BACKUP_FILE = [string] [EOL] ERROR_PYTHON = [string] [EOL] ERROR_IMPLEMENTATION = [string] [EOL] [EOL] @ staticmethod def createEmptyMessage ( ) : [EOL] [comment] [EOL] return dict ( type = None , timestamp = None , sms_text = None , sms_class = None , sms_number = None , sms_type = None , mms_address = None , mms_title = None , mms_number = None , errors = [ ] , ) [EOL] [EOL] @ staticmethod def appendError ( message , error_type , error_message ) : [EOL] message [ [string] ] . append ( ( error_type , error_message ) ) [EOL] [EOL] @ staticmethod def setUniqueValueInMessage ( message , key , value ) : [EOL] [docstring] [EOL] if message [ key ] is None : [EOL] message [ key ] = value [EOL] else : [EOL] [comment] [EOL] if message [ key ] != value : [EOL] GammuSMSParser . appendError ( message , GammuSMSParser . ERROR_DUPLICATE_VALUE , [string] . format ( key ) ) [EOL] [EOL] @ classmethod def decodeFromEnv ( cls ) : [EOL] [docstring] [EOL] message = cls . createEmptyMessage ( ) [EOL] [comment] [EOL] sms_parts = int ( os . getenv ( [string] , [number] ) ) [EOL] sms_text = [string] [EOL] if sms_parts > [number] : [EOL] message [ [string] ] = [string] [EOL] for i in range ( [number] , sms_parts + [number] ) : [EOL] sms_text += os . getenv ( [string] . format ( i ) , [string] ) [EOL] [EOL] [comment] [EOL] sms_class = os . getenv ( [string] . format ( i ) , None ) [EOL] if sms_class : [EOL] cls . setUniqueValueInMessage ( message , [string] , sms_class ) [EOL] [EOL] [comment] [EOL] sms_number = os . getenv ( [string] . format ( i ) , None ) [EOL] if sms_number : [EOL] cls . setUniqueValueInMessage ( message , [string] , sms_number ) [EOL] [EOL] [comment] [EOL] decoded_parts = int ( os . getenv ( [string] , [number] ) ) [EOL] decoded_text = [string] [EOL] if decoded_parts > [number] : [EOL] for i in range ( [number] , decoded_parts ) : [EOL] decoded_text += os . getenv ( [string] . format ( i ) , [string] ) [EOL] [EOL] [comment] [EOL] sender = os . getenv ( [string] . format ( i + [number] ) , None ) [EOL] if sender : [EOL] message [ [string] ] = [string] [EOL] sender_parts = sender . split ( [string] ) [EOL] if len ( sender_parts ) > [number] : [EOL] GammuSMSParser . setUniqueValueInMessage ( message , [string] , sender_parts [ [number] ] ) [EOL] message [ [string] ] = os . getenv ( [string] . format ( i + [number] ) , [string] ) [EOL] message [ [string] ] = os . getenv ( [string] . format ( i + [number] ) , [string] ) [EOL] [EOL] if sms_parts == [number] and decoded_parts == [number] : [EOL] cls . appendError ( message , cls . ERROR_NO_CONTENT , [string] ) [EOL] [EOL] if decoded_parts > [number] : [EOL] message [ [string] ] = decoded_text [EOL] if decoded_text != sms_text : [EOL] cls . appendError ( message , cls . ERROR_INCONSISTENCY , [string] ) [EOL] else : [EOL] message [ [string] ] = sms_text [EOL] return message [EOL] [EOL] @ classmethod def decodeFromBackupFilePath ( cls , backup_file_path ) : [EOL] [docstring] [EOL] message = cls . createEmptyMessage ( ) [EOL] [EOL] [comment] [EOL] if not os . path . exists ( backup_file_path ) or not os . path . isfile ( backup_file_path ) : [EOL] cls . appendError ( message , cls . ERROR_BACKUP_FILE , [string] . format ( backup_file_path ) ) [EOL] return message [EOL] if not os . access ( backup_file_path , os . R_OK ) : [EOL] cls . appendError ( message , cls . ERROR_BACKUP_FILE , [string] . format ( backup_file_path ) ) [EOL] return message [EOL] if not gammu : [EOL] cls . appendError ( message , cls . ERROR_PYTHON , [string] ) [EOL] return message [EOL] [EOL] backup = gammu . ReadSMSBackup ( backup_file_path ) [EOL] [EOL] [comment] [EOL] backup_messages = [ [ backup_message ] for backup_message in backup ] [EOL] raw_messages = gammu . LinkSMS ( backup_messages ) [EOL] [EOL] if not raw_messages : [EOL] cls . appendError ( message , cls . ERROR_NO_CONTENT , [string] ) [EOL] return message [EOL] [EOL] if len ( raw_messages ) > [number] : [EOL] cls . appendError ( message , cls . ERROR_IMPLEMENTATION , [string] ) [EOL] [EOL] for raw_message in raw_messages : [EOL] decoded_message = gammu . DecodeSMS ( raw_message ) [EOL] part = raw_message [ [number] ] [EOL] [EOL] [comment] [EOL] for backup_key , message_key in cls . BACKUPFILE_SMS_FIELD_MAPPING . items ( ) : [EOL] if backup_key in part and part [ backup_key ] : [EOL] cls . setUniqueValueInMessage ( message , message_key , part [ backup_key ] ) [EOL] [EOL] if [string] in part and part [ [string] ] in cls . BACKUPFILE_SMS_TYPE_MAPPING : [EOL] cls . setUniqueValueInMessage ( message , [string] , cls . BACKUPFILE_SMS_TYPE_MAPPING [ part [ [string] ] ] ) [EOL] [EOL] if [string] in part and isinstance ( part [ [string] ] , datetime . datetime ) : [EOL] message [ [string] ] = time . mktime ( part [ [string] ] . timetuple ( ) ) [EOL] [EOL] [comment] [EOL] if decoded_message is None : [EOL] [comment] [EOL] [comment] [EOL] message [ [string] ] = part [ [string] ] [EOL] message [ [string] ] = [string] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] for entry in decoded_message [ [string] ] : [EOL] [comment] [EOL] if [string] in entry and entry [ [string] ] : [EOL] entry_id = entry [ [string] ] [EOL] [comment] [EOL] if entry_id in [ [string] ] : [EOL] if not message [ [string] ] : [EOL] message [ [string] ] = [string] [EOL] [comment] [EOL] elif entry_id in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] if not message [ [string] ] : [EOL] message [ [string] ] = [string] [EOL] [EOL] [comment] [EOL] if entry [ [string] ] : [EOL] message [ [string] ] = ( message [ [string] ] or [string] ) + entry [ [string] ] [EOL] [comment] [EOL] if entry [ [string] ] : [EOL] mms_infos = entry [ [string] ] [EOL] message [ [string] ] = mms_infos [ [string] ] or [string] [EOL] message [ [string] ] = mms_infos [ [string] ] or [string] [EOL] [comment] [EOL] sender_parts = ( mms_infos [ [string] ] or [string] ) . split ( [string] ) [EOL] if len ( sender_parts ) > [number] : [EOL] message [ [string] ] = sender_parts [ [number] ] [EOL] [EOL] [comment] [EOL] break [EOL] [EOL] return message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import grp [EOL] import pwd [EOL] [EOL] [comment] [EOL] from . gammusmsdparser import GammuSMSParser [EOL] [EOL] [EOL] def userToUid ( user ) : [EOL] [docstring] [EOL] try : [EOL] return int ( user , [number] ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] return pwd . getpwnam ( user ) . pw_uid [EOL] [EOL] def groupToGid ( group ) : [EOL] [docstring] [EOL] try : [EOL] return int ( group , [number] ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] return grp . getgrnam ( group ) . gr_gid [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import argparse [EOL] import logging [EOL] [EOL] [comment] [EOL] from . . exceptions import ShellException , BadCommandCall [EOL] from . . models import SessionStates [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class CommandException ( ShellException ) : [EOL] [docstring] [EOL] def __init__ ( self , message , short = [string] ) : [EOL] super ( ) . __init__ ( message , short ) [EOL] [EOL] [EOL] class CommandNotFoundException ( CommandException ) : [EOL] [docstring] [EOL] def __init__ ( self , message , short = [string] ) : [EOL] super ( ) . __init__ ( message , short ) [EOL] [EOL] [EOL] class CommandBadImplemented ( CommandException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class CommandForbidden ( CommandException ) : [EOL] [docstring] [EOL] def __init__ ( self , message , short = [string] ) : [EOL] super ( ) . __init__ ( message , short ) [EOL] [EOL] [EOL] class CommandBadConfiguredException ( CommandException ) : [EOL] [docstring] [EOL] def __init__ ( self , message , short = [string] ) : [EOL] super ( ) . __init__ ( message , short ) [EOL] [EOL] [EOL] class AbstractCommand ( object ) : [EOL] [docstring] [EOL] [EOL] class ArgParser ( argparse . ArgumentParser ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] kwargs [ [string] ] = False [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def error ( self , message ) : [EOL] [docstring] [EOL] raise BadCommandCall ( message ) [EOL] [EOL] def __init__ ( self , logger , shell , config , metrics ) : [EOL] [docstring] [EOL] self . __session = None [EOL] [EOL] assert isinstance ( logger , logging . Logger ) [EOL] self . log = logger [EOL] self . shell = shell [EOL] self . config = config [EOL] self . metrics = metrics [EOL] self . session = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . __class__ . __name__ . lower ( ) [EOL] [EOL] @ property def session ( self ) : [EOL] [docstring] [EOL] assert self . __session is not None [EOL] return self . __session [EOL] [EOL] @ session . setter def session ( self , sess ) : [EOL] [docstring] [EOL] self . __session = sess [EOL] return self [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def argsParser ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def checkConfig ( self ) : [EOL] [docstring] [EOL] assert self [EOL] return True [EOL] [EOL] def createArgsParser ( self ) : [EOL] [docstring] [EOL] return AbstractCommand . ArgParser ( description = self . description ( [ ] ) , prog = self . name ) [EOL] [EOL] def description ( self , argv ) : [EOL] [docstring] [EOL] raise CommandBadImplemented ( str ( self . __class__ ) + [string] ) [EOL] [EOL] def inputStates ( self ) : [EOL] [docstring] [EOL] return [ ] [EOL] [EOL] def main ( self , argv ) : [EOL] [docstring] [EOL] raise CommandBadImplemented ( str ( self . __class__ ) + [string] ) [EOL] [EOL] def usage ( self , argv ) : [EOL] [docstring] [EOL] parser = self . _argsParser ( ) [EOL] if parser : [EOL] parser . parse_known_args ( argv ) [EOL] return parser . format_usage ( ) [EOL] raise CommandBadImplemented ( str ( self . __class__ ) + [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def _inputStates ( self ) : [EOL] [docstring] [EOL] states = self . inputStates ( ) [EOL] if not isinstance ( states , list ) : [EOL] raise CommandBadImplemented ( str ( self . __class__ ) + [string] [string] ) [EOL] for state in states : [EOL] if not isinstance ( state , SessionStates ) : [EOL] raise CommandBadImplemented ( str ( self . __class__ ) + [string] [string] ) [EOL] return states [EOL] [EOL] def _argsParser ( self ) : [EOL] [docstring] [EOL] try : [EOL] parser = self . argsParser ( ) [EOL] except BaseException as ex : [EOL] raise CommandBadImplemented ( str ( self . __class__ ) + [string] . format ( ex ) ) [EOL] if parser : [EOL] if not isinstance ( parser , AbstractCommand . ArgParser ) : [EOL] raise CommandBadImplemented ( str ( self . __class__ ) + [string] + [string] ) [EOL] if parser . add_help : [EOL] raise CommandBadImplemented ( str ( self . __class__ ) + [string] [string] ) [EOL] return parser [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from . import AbstractCommand , CommandException [EOL] [EOL] [EOL] class Desc ( AbstractCommand ) : [EOL] [docstring] [EOL] [EOL] def argsParser ( self ) : [EOL] parser = self . createArgsParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , default = [ ] , help = [string] ) [EOL] return parser [EOL] [EOL] def usage ( self , argv ) : [EOL] return [string] [EOL] [EOL] def description ( self , argv ) : [EOL] return [string] [EOL] [EOL] def main ( self , argv , pargs ) : [EOL] try : [EOL] return self . shell . getCommand ( self . session , pargs . command ) . description ( pargs . command_argv ) [EOL] except CommandException as ex : [EOL] self . log . error ( [string] , str ( ex ) ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from . import AbstractCommand [EOL] [EOL] [EOL] class Role ( AbstractCommand ) : [EOL] [docstring] [EOL] [EOL] def usage ( self , argv ) : [EOL] return [string] [EOL] [EOL] def description ( self , argv ) : [EOL] return [string] [EOL] [EOL] def main ( self , argv ) : [EOL] state_name = str ( self . session . state . name ) [EOL] return [string] . join ( state_name . split ( [string] ) [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from . import AbstractCommand [EOL] [EOL] [EOL] class Flush ( AbstractCommand ) : [EOL] [docstring] [EOL] [EOL] def usage ( self , argv ) : [EOL] return [string] [EOL] [EOL] def description ( self , argv ) : [EOL] return [string] [EOL] [EOL] def main ( self , argv ) : [EOL] self . shell . flushCommandCache ( ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from . import AbstractCommand [EOL] [EOL] [EOL] class Whoami ( AbstractCommand ) : [EOL] [docstring] [EOL] [EOL] def usage ( self , argv ) : [EOL] return [string] [EOL] [EOL] def description ( self , argv ) : [EOL] return [string] [EOL] [EOL] def main ( self , argv ) : [EOL] return self . session . subject [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from . import AbstractCommand , CommandException [EOL] [EOL] [EOL] class Help ( AbstractCommand ) : [EOL] [docstring] [EOL] [EOL] def usage ( self , argv ) : [EOL] return [string] [EOL] [EOL] def description ( self , argv ) : [EOL] return [string] [EOL] [EOL] def main ( self , argv ) : [EOL] [comment] [EOL] if argv : [EOL] try : [EOL] return self . shell . getCommand ( self . session , argv [ [number] ] ) . usage ( argv [ [number] : ] ) [EOL] except CommandException as ex : [EOL] self . log . error ( [string] + str ( ex ) ) [EOL] return [string] [EOL] [comment] [EOL] else : [EOL] return [string] . join ( self . shell . getAvailableCommands ( self . session ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] import os [EOL] [EOL] [comment] [EOL] from . import AbstractTransmitter [EOL] from . . models import Message [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class Transmitter ( AbstractTransmitter ) : [EOL] [docstring] [EOL] [EOL] def init ( self ) : [EOL] [docstring] [EOL] self . __smsd = None [EOL] self . __default_umask = [number] [EOL] [EOL] [comment] [EOL] self . __config = self . getConfig ( [string] , fallback = [string] ) [EOL] [EOL] [comment] [EOL] self . __path = self . getConfig ( [string] , fallback = [string] ) [EOL] [EOL] [comment] [EOL] umask = self . getConfig ( [string] , fallback = [string] . format ( self . __default_umask ) ) [EOL] try : [EOL] self . __umask = int ( umask , [number] ) [EOL] except ValueError : [EOL] g_logger . error ( [string] , umask , self . __default_umask ) [EOL] self . __umask = self . __default_umask [EOL] [EOL] def start ( self ) : [EOL] try : [EOL] import gammu . smsd [EOL] except ImportError as ex : [EOL] g_logger . critical ( [string] , str ( ex ) ) [EOL] return False [EOL] [EOL] [comment] [EOL] if not os . path . isfile ( self . __config ) : [EOL] g_logger . critical ( [string] , self . __config ) [EOL] return False [EOL] elif not os . access ( self . __config , os . R_OK ) : [EOL] g_logger . critical ( [string] , self . __config ) [EOL] return False [EOL] [EOL] g_logger . debug ( [string] ) [EOL] try : [EOL] self . __smsd = gammu . smsd . SMSD ( self . __config ) [EOL] except gammu . GSMError as ex : [EOL] g_logger . critical ( [string] , str ( ex ) ) [EOL] return False [EOL] g_logger . info ( [string] ) [EOL] [EOL] return True [EOL] [EOL] def stop ( self ) : [EOL] self . __smsd = None [EOL] return True [EOL] [EOL] def transmit ( self , answer ) : [EOL] assert isinstance ( answer , Message ) [EOL] assert self . __smsd [EOL] [EOL] message = { [string] : answer . asString ( ) , [string] : { [string] : [number] } , [string] : answer . number , } [EOL] [EOL] [comment] [EOL] old_umask = os . umask ( self . __umask ) [EOL] self . __smsd . InjectSMS ( [ message ] ) [EOL] os . umask ( old_umask ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from . . abstract import AbstractModule [EOL] from . . models import Message [EOL] [EOL] [EOL] class AbstractTransmitter ( AbstractModule ) : [EOL] [docstring] [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def transmit ( self , answer ) : [EOL] [docstring] [EOL] assert isinstance ( answer , Message ) [EOL] raise NotImplementedError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] import sys [EOL] [EOL] [comment] [EOL] from . import AbstractTransmitter [EOL] from . . models import Message [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class Transmitter ( AbstractTransmitter ) : [EOL] [docstring] [EOL] [EOL] def start ( self ) : [EOL] return True [EOL] [EOL] def stop ( self ) : [EOL] return True [EOL] [EOL] def transmit ( self , answer ) : [EOL] assert isinstance ( answer , Message ) [EOL] sys . stdout . write ( [string] . format ( answer . number , answer . asString ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import datetime [EOL] from enum import IntEnum , unique [EOL] import logging [EOL] [EOL] [comment] [EOL] from . . exceptions import ShellException [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class SessionException ( ShellException ) : [EOL] [docstring] [EOL] def __init__ ( self , message , short = [string] ) : [EOL] super ( ) . __init__ ( message , short ) [EOL] [EOL] [EOL] class BadStateTransitionException ( SessionException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] @ unique class SessionStates ( IntEnum ) : [EOL] [docstring] [EOL] STATE_GUEST = [number] [EOL] STATE_LOGININPROGRESS = [number] [EOL] STATE_USER = [number] [EOL] STATE_ADMIN = [number] [EOL] [EOL] [EOL] class Session ( object ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] STATE_TRANSITION_MAP = { [string] : [ [string] , [string] , ] , [string] : [ [string] , [string] , ] , [string] : [ [string] , ] } [EOL] [EOL] def __init__ ( self , subject , time_to_live = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] self . __subject = None [EOL] self . __ttl = None [EOL] self . __prefix = [string] [EOL] self . __state = None [EOL] self . __created_at = datetime . datetime . today ( ) [EOL] self . __storage = dict ( ) [EOL] [EOL] [comment] [EOL] self . subject = subject [EOL] self . ttl = time_to_live [EOL] self . forceState ( SessionStates . STATE_GUEST ) [EOL] self . access ( ) [EOL] [EOL] [EOL] @ property def subject ( self ) : [EOL] [docstring] [EOL] assert self . __subject is not None [EOL] return self . __subject [EOL] [EOL] @ subject . setter def subject ( self , sub ) : [EOL] [docstring] [EOL] self . __subject = sub [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] assert self . __state is not None [EOL] return self . __state [EOL] [EOL] @ state . setter def state ( self , new_state ) : [EOL] [docstring] [EOL] if not isinstance ( new_state , SessionStates ) : [EOL] raise BadStateTransitionException ( [string] + [string] . format ( str ( new_state ) ) ) [EOL] current = self . state . name [EOL] assert current in Session . STATE_TRANSITION_MAP [EOL] [EOL] allowed = Session . STATE_TRANSITION_MAP [ current ] [EOL] if new_state . name not in allowed : [EOL] raise BadStateTransitionException ( [string] + [string] . format ( current , new_state . name ) ) [EOL] [EOL] self . __state = new_state [EOL] [EOL] def forceState ( self , new_state ) : [EOL] [docstring] [EOL] if not isinstance ( new_state , SessionStates ) : [EOL] raise BadStateTransitionException ( [string] + [string] . format ( str ( new_state ) ) ) [EOL] self . __state = new_state [EOL] [EOL] @ property def created_at ( self ) : [EOL] [docstring] [EOL] return self . __created_at [EOL] [EOL] @ property def ttl ( self ) : [EOL] [docstring] [EOL] assert self . __ttl is not None [EOL] return int ( self . __ttl . seconds ) [EOL] [EOL] @ ttl . setter def ttl ( self , seconds ) : [EOL] [docstring] [EOL] self . __ttl = datetime . timedelta ( seconds = int ( seconds ) ) [EOL] [EOL] @ property def access_at ( self ) : [EOL] [docstring] [EOL] assert self . __access_at is not None [EOL] return self . __access_at [EOL] [EOL] def access ( self ) : [EOL] [docstring] [EOL] self . __access_at = datetime . datetime . today ( ) [EOL] return self [EOL] [EOL] def isValid ( self ) : [EOL] [docstring] [EOL] if ( datetime . datetime . today ( ) - self . access_at ) . seconds >= self . ttl : [EOL] g_logger . debug ( [string] , self . subject ) [EOL] return False [EOL] return True [EOL] [EOL] def setStoragePrefix ( self , prefix ) : [EOL] [docstring] [EOL] self . __prefix = prefix [EOL] [EOL] def get ( self , key , fallback = None ) : [EOL] [docstring] [EOL] fullkey = self . __prefix + key [EOL] if fullkey in self . __storage : [EOL] return self . __storage [ fullkey ] [EOL] return fallback [EOL] [EOL] def set ( self , key , value ) : [EOL] [docstring] [EOL] fullkey = self . __prefix + key [EOL] self . __storage [ fullkey ] = value [EOL] return self [EOL] [EOL] def getSecureSession ( self ) : [EOL] [docstring] [EOL] [EOL] class SessionWrapper ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , session ) : [EOL] [docstring] [EOL] self . __session = session [EOL] self . subject = session . subject [EOL] self . state = session . state [EOL] [EOL] def get ( self , * args , ** kw ) : [EOL] [docstring] [EOL] return self . __session . get ( * args , ** kw ) [EOL] [EOL] def set ( self , * args , ** kw ) : [EOL] [docstring] [EOL] return self . __session . set ( * args , ** kw ) [EOL] [EOL] return SessionWrapper ( self ) [EOL] [EOL] [comment] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] content = ( [string] + str ( self . subject ) + [string] + [string] + str ( self . created_at ) + [string] + str ( self . ttl ) + [string] ) [EOL] return content [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return [string] + str ( self . subject ) + [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class Message ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , number , content , attributes = None ) : [EOL] [docstring] [EOL] self . __number = None [EOL] self . __content = None [EOL] self . __attributes = dict ( ) [EOL] [comment] [EOL] if attributes is not None : [EOL] assert isinstance ( attributes , dict ) [EOL] self . attributes = attributes [EOL] self . number = number [EOL] self . content = content [EOL] [EOL] @ property def number ( self ) : [EOL] [docstring] [EOL] assert self . __number is not None [EOL] return self . __number [EOL] [EOL] @ number . setter def number ( self , send ) : [EOL] [docstring] [EOL] self . __number = send [EOL] [EOL] @ property def content ( self ) : [EOL] [docstring] [EOL] assert self . __content is not None [EOL] return self . __content [EOL] [EOL] @ content . setter def content ( self , cont ) : [EOL] [docstring] [EOL] self . __content = cont [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] [docstring] [EOL] return self . attribute ( name ) [EOL] [EOL] def attribute ( self , key , fallback = AttributeError ) : [EOL] [docstring] [EOL] assert self . __attributes is not None [EOL] assert isinstance ( self . __attributes , dict ) [EOL] if key not in self . __attributes : [EOL] if issubclass ( fallback . __class__ , Exception . __class__ ) : [EOL] raise fallback ( key ) [EOL] return fallback [EOL] return self . __attributes [ key ] [EOL] [EOL] @ property def attributes ( self ) : [EOL] [docstring] [EOL] assert self . __attributes is not None [EOL] assert isinstance ( self . __attributes , dict ) [EOL] return self . __attributes [EOL] [EOL] @ attributes . setter def attributes ( self , keys ) : [EOL] [docstring] [EOL] self . __attributes . update ( keys ) [EOL] [EOL] def asString ( self ) : [EOL] [docstring] [EOL] assert isinstance ( self . content , str ) [EOL] return self . content [EOL] [EOL] [comment] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] content = ( [string] + str ( self . number ) + [string] + [string] + str ( self . content ) ) [EOL] return content [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return [string] + str ( self . number ) + [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from . message import Message [EOL] from . session import ( Session , SessionStates , BadStateTransitionException , SessionException ) [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from . . abstract import AbstractModule [EOL] [EOL] [EOL] class AbstractMetricsHelper ( AbstractModule ) : [EOL] [docstring] [EOL] PREFIX = [string] [EOL] SEPARATOR = [string] [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def normalizeName ( self , name ) : [EOL] [docstring] [EOL] path = name . replace ( [string] , self . SEPARATOR ) [EOL] if path [ [number] : len ( self . PREFIX ) ] != self . PREFIX : [EOL] return self . SEPARATOR . join ( [ self . PREFIX , path ] ) [EOL] return path [EOL] [EOL] def counter ( self , name , * args , ** kwargs ) : [EOL] [docstring] [EOL] return self . _counter ( self . normalizeName ( name ) , * args , ** kwargs ) [EOL] [EOL] def _counter ( self , name , value = [number] , description = None , labels = None ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def gauge ( self , name , * args , ** kwargs ) : [EOL] [docstring] [EOL] return self . _gauge ( self . normalizeName ( name ) , * args , ** kwargs ) [EOL] [EOL] def _gauge ( self , name , value = None , set = None , callback = None , description = None , labels = None ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] import prometheus_client [EOL] [EOL] [comment] [EOL] from . import AbstractMetricsHelper [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class MetricsHelper ( AbstractMetricsHelper ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] SEPARATOR = [string] [EOL] [EOL] def init ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . __port = int ( self . getConfig ( [string] , fallback = [number] ) ) [EOL] except ValueError : [EOL] self . __port = [number] [EOL] g_logger . error ( ( [string] [string] ) ) [EOL] self . __address = self . getConfig ( [string] , fallback = [string] ) [EOL] [comment] [EOL] self . __counters = dict ( ) [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] g_logger . info ( [string] , self . __address , self . __port ) [EOL] prometheus_client . start_http_server ( self . __port , self . __address ) [EOL] return True [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def _counter ( self , name , value = [number] , description = None , labels = None ) : [EOL] [docstring] [EOL] if name not in self . __counters : [EOL] [comment] [EOL] if not description : [EOL] g_logger . error ( ( [string] [string] ) , name ) [EOL] return self [EOL] [comment] [EOL] if isinstance ( labels , dict ) : [EOL] _labels = labels . keys ( ) [EOL] elif isinstance ( labels , list ) : [EOL] _labels = labels [EOL] else : [EOL] g_logger . error ( ( [string] [string] ) , name ) [EOL] return self [EOL] [comment] [EOL] self . __counters [ name ] = prometheus_client . Counter ( name , description , _labels ) [EOL] if isinstance ( labels , list ) : [EOL] [comment] [EOL] return [EOL] counter = self . __counters [ name ] [EOL] assert counter [EOL] [EOL] if not isinstance ( labels , dict ) : [EOL] g_logger . error ( ( [string] [string] ) , name ) [EOL] return self [EOL] [EOL] if value > [number] : [EOL] try : [EOL] if labels : [EOL] counter . labels ( ** labels ) . inc ( value ) [EOL] else : [EOL] counter . inc ( value ) [EOL] except ValueError as ex : [EOL] g_logger . error ( [string] , str ( ex ) ) [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] [EOL] [comment] [EOL] from . import AbstractMetricsHelper [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class MetricsHelper ( AbstractMetricsHelper ) : [EOL] [docstring] [EOL] [EOL] def init ( self ) : [EOL] [docstring] [EOL] g_logger . info ( [string] ) [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def _counter ( self , name , value = [number] , description = None , labels = None ) : [EOL] [docstring] [EOL] return self [EOL] [EOL] def _gauge ( self , name , value = None , set = None , callback = None , description = None , labels = None ) : [EOL] [docstring] [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] import json [EOL] [EOL] [comment] [EOL] from . import DecodeException , BadMessageFormatException [EOL] from . . models import Message [EOL] from . import AbstractParser [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class Parser ( AbstractParser ) : [EOL] [docstring] [EOL] [EOL] def parse ( self , raw ) : [EOL] [docstring] [EOL] try : [EOL] obj = json . loads ( raw ) [EOL] except ValueError as ex : [EOL] g_logger . debug ( [string] , str ( ex ) ) [EOL] raise DecodeException ( [string] ) [EOL] except TypeError as ex : [EOL] g_logger . debug ( [string] , str ( ex ) ) [EOL] raise DecodeException ( [string] ) [EOL] [EOL] if [string] not in obj : [EOL] raise BadMessageFormatException ( [string] ) [EOL] number = obj [ [string] ] [EOL] if number is None or not number : [EOL] raise BadMessageFormatException ( [string] ) [EOL] [EOL] if [string] not in obj : [EOL] raise BadMessageFormatException ( [string] ) [EOL] content = obj [ [string] ] [EOL] if content is None or not content : [EOL] raise BadMessageFormatException ( [string] ) [EOL] [EOL] extra_datas = dict ( filter ( lambda x : x [ [number] ] not in [ [string] , [string] ] , obj . items ( ) ) ) [EOL] [EOL] return Message ( number , content , attributes = extra_datas ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from . . abstract import AbstractModule [EOL] from . . exceptions import SMSException [EOL] [EOL] [EOL] class ParserException ( SMSException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class DecodeException ( ParserException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class BadMessageFormatException ( ParserException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class AbstractParser ( AbstractModule ) : [EOL] [docstring] [EOL] [EOL] def parse ( self , raw ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] import os [EOL] import stat [EOL] [EOL] [comment] [EOL] from . import AbstractReceiver , AbstractClientRequest [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class ClientRequest ( AbstractClientRequest ) : [EOL] [docstring] [EOL] [EOL] def enter ( self ) : [EOL] pass [EOL] [EOL] def exit ( self ) : [EOL] pass [EOL] [EOL] [EOL] class Receiver ( AbstractReceiver ) : [EOL] [docstring] [EOL] [EOL] def init ( self ) : [EOL] [docstring] [EOL] self . __path = self . getConfig ( [string] , fallback = [string] ) [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] directory = os . path . dirname ( self . __path ) [EOL] [comment] [EOL] if not ( os . path . isdir ( directory ) and os . access ( directory , os . X_OK ) ) : [EOL] g_logger . fatal ( [string] ) [EOL] return False [EOL] [comment] [EOL] if os . path . exists ( self . __path ) : [EOL] if not stat . S_ISFIFO ( os . stat ( self . __path ) . st_mode ) : [EOL] g_logger . fatal ( [string] ) [EOL] return False [EOL] g_logger . debug ( [string] ) [EOL] elif not os . path . exists ( self . __path ) : [EOL] [comment] [EOL] if not os . access ( directory , os . X_OK | os . W_OK ) : [EOL] g_logger . fatal ( [string] , self . __path ) [EOL] return False [EOL] g_logger . debug ( [string] , self . __path ) [EOL] os . mkfifo ( self . __path , mode = [number] ) [EOL] return self [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] try : [EOL] os . unlink ( self . __path ) [EOL] except OSError : [EOL] g_logger . error ( [string] ) [EOL] return False [EOL] return True [EOL] [EOL] def read ( self ) : [EOL] [docstring] [EOL] g_logger . info ( [string] , self . __path ) [EOL] while True : [EOL] with open ( self . __path ) as fifo : [EOL] yield ClientRequest ( request_data = fifo . read ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import SMSShell [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import json [EOL] import logging [EOL] import os [EOL] import selectors [EOL] import socket [EOL] import stat [EOL] [EOL] [comment] [EOL] from . import AbstractReceiver , AbstractClientRequest [EOL] from . . utils import groupToGid [EOL] [EOL] [comment] [EOL] g_logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class ClientRequest ( AbstractClientRequest ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , receiver , client_socket , ** kwargs ) : [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] self . __receiver = receiver [EOL] self . __client_socket = client_socket [EOL] [EOL] def enter ( self ) : [EOL] pass [EOL] [EOL] def exit ( self ) : [EOL] [docstring] [EOL] assert self . __client_socket [EOL] response_data = self . popResponseData ( ) [EOL] response_data [ [string] ] = self . getTreatmentChain ( ) [EOL] self . __receiver . writeToClient ( self . __client_socket , json . dumps ( response_data ) ) [EOL] [EOL] [EOL] class Receiver ( AbstractReceiver ) : [EOL] [docstring] [EOL] [EOL] def init ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] self . __current_peers = dict ( ) [EOL] [EOL] [comment] [EOL] self . __socket_selector = selectors . DefaultSelector ( ) [EOL] self . __server_socket = None [EOL] self . __default_umask = [number] [EOL] [EOL] [comment] [EOL] self . __path = self . getConfig ( [string] , fallback = [string] ) [EOL] self . __umask = self . getConfig ( [string] , fallback = [string] . format ( self . __default_umask ) ) [EOL] self . __group = self . getConfig ( [string] ) [EOL] try : [EOL] self . __listen_queue = int ( self . getConfig ( [string] , fallback = [number] ) ) [EOL] except ValueError : [EOL] self . __listen_queue = [number] [EOL] g_logger . error ( ( [string] [string] ) ) [EOL] [EOL] def writeToClient ( self , client_socket , data ) : [EOL] [docstring] [EOL] if not isinstance ( data , bytes ) : [EOL] data = data . encode ( ) [EOL] [EOL] try : [EOL] client_socket . send ( data ) [EOL] except ConnectionError as ex : [EOL] g_logger . warning ( [string] , client_socket . fileno ( ) , str ( ex ) ) [EOL] self . __closeConnection ( client_socket ) [EOL] [EOL] def __onAccept ( self , server_socket , mask ) : [EOL] [docstring] [EOL] client_socket , addr = server_socket . accept ( ) [EOL] [comment] [EOL] client_socket . setblocking ( [number] ) [EOL] [comment] [EOL] assert client_socket . fileno ( ) not in self . __current_peers [EOL] self . __current_peers [ client_socket . fileno ( ) ] = dict ( sock = client_socket ) [EOL] [EOL] [comment] [EOL] self . __socket_selector . register ( fileobj = client_socket , events = selectors . EVENT_READ , data = self . __onRead ) [EOL] g_logger . info ( [string] , client_socket . fileno ( ) ) [EOL] [EOL] def __onRead ( self , client_socket , mask ) : [EOL] [docstring] [EOL] try : [EOL] request_data = client_socket . recv ( [number] ) [EOL] except ConnectionError as ex : [EOL] g_logger . warning ( [string] , client_socket . fileno ( ) , str ( ex ) ) [EOL] self . __closeConnection ( client_socket ) [EOL] return None [EOL] [EOL] [comment] [EOL] if not request_data : [EOL] self . __closeConnection ( client_socket ) [EOL] return None [EOL] [EOL] [comment] [EOL] [comment] [EOL] g_logger . info ( [string] , len ( request_data ) , client_socket . fileno ( ) ) [EOL] g_logger . debug ( [string] , client_socket . fileno ( ) , request_data ) [EOL] [comment] [EOL] raw_request_data_length = len ( request_data ) [EOL] if not isinstance ( request_data , str ) : [EOL] request_data = request_data . decode ( ) [EOL] [EOL] [comment] [EOL] request = ClientRequest ( receiver = self , client_socket = client_socket , request_data = request_data ) [EOL] [comment] [EOL] [comment] [EOL] g_logger . debug ( [string] , client_socket . fileno ( ) , raw_request_data_length ) [EOL] request . addResponseData ( received_length = raw_request_data_length ) [EOL] request . appendTreatmentChain ( [string] ) [EOL] [EOL] return request [EOL] [EOL] def __closeConnection ( self , client_socket ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] del self . __current_peers [ client_socket . fileno ( ) ] [EOL] self . __socket_selector . unregister ( client_socket ) [EOL] g_logger . info ( [string] , client_socket . fileno ( ) ) [EOL] client_socket . close ( ) [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] directory = os . path . dirname ( self . __path ) [EOL] [comment] [EOL] if not ( os . path . isdir ( directory ) and os . access ( directory , os . X_OK ) ) : [EOL] g_logger . fatal ( [string] ) [EOL] return False [EOL] [comment] [EOL] if os . path . exists ( self . __path ) : [EOL] [comment] [EOL] if stat . S_ISSOCK ( os . stat ( self . __path ) . st_mode ) : [EOL] g_logger . debug ( [string] ) [EOL] try : [EOL] os . unlink ( self . __path ) [EOL] except OSError : [EOL] if os . path . exists ( self . __path ) : [EOL] g_logger . fatal ( [string] ) [EOL] return False [EOL] else : [EOL] g_logger . fatal ( [string] + [string] ) [EOL] return False [EOL] [EOL] [comment] [EOL] if not os . access ( directory , os . X_OK | os . W_OK ) : [EOL] g_logger . fatal ( [string] , self . __path ) [EOL] return False [EOL] g_logger . debug ( [string] ) [EOL] [EOL] [comment] [EOL] self . __server_socket = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM ) [EOL] g_logger . debug ( [string] ) [EOL] self . __server_socket . setblocking ( [number] ) [EOL] [EOL] [comment] [EOL] try : [EOL] umask = int ( self . __umask , [number] ) [EOL] except ValueError : [EOL] g_logger . error ( [string] , self . __umask , self . __default_umask ) [EOL] umask = self . __default_umask [EOL] g_logger . debug ( [string] , self . __path , oct ( umask ) ) [EOL] [EOL] [comment] [EOL] old_umask = os . umask ( umask ) [EOL] self . __server_socket . bind ( self . __path ) [EOL] os . umask ( old_umask ) [EOL] [EOL] [comment] [EOL] if self . __group : [EOL] try : [EOL] os . chown ( self . __path , - [number] , groupToGid ( self . __group ) ) [EOL] g_logger . info ( [string] , self . __group ) [EOL] except KeyError : [EOL] g_logger . error ( [string] , self . __group ) [EOL] except PermissionError : [EOL] g_logger . error ( [string] + [string] , self . __group ) [EOL] [EOL] [comment] [EOL] g_logger . debug ( [string] , self . __listen_queue ) [EOL] self . __server_socket . listen ( self . __listen_queue ) [EOL] g_logger . info ( [string] , self . __path , self . __server_socket . fileno ( ) ) [EOL] [EOL] [comment] [EOL] self . __socket_selector . register ( fileobj = self . __server_socket , events = selectors . EVENT_READ , data = self . __onAccept ) [EOL] return True [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] g_logger . info ( [string] ) [EOL] g_logger . debug ( [string] ) [EOL] for peer in self . __current_peers . values ( ) : [EOL] peer [ [string] ] . close ( ) [EOL] g_logger . debug ( [string] ) [EOL] self . __server_socket . close ( ) [EOL] self . __socket_selector . close ( ) [EOL] g_logger . debug ( [string] ) [EOL] try : [EOL] os . unlink ( self . __path ) [EOL] except OSError : [EOL] g_logger . error ( [string] ) [EOL] return False [EOL] return True [EOL] [EOL] def read ( self ) : [EOL] [docstring] [EOL] g_logger . info ( [string] , self . __path ) [EOL] while True : [EOL] [comment] [EOL] events = self . __socket_selector . select ( ) [EOL] [EOL] [comment] [EOL] for key , mask in events : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] callback = key . data [EOL] socket_data = callback ( key . fileobj , mask ) [EOL] [comment] [EOL] [comment] [EOL] if callback == self . __onRead and socket_data is not None : [EOL] yield socket_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $SMSShell.receivers.unix.ClientRequest$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $SMSShell.receivers.unix.ClientRequest$ 0 0 0 0 0 $builtins.int$ 0 0 $SMSShell.receivers.unix.ClientRequest$ 0 0 0 0 0 0 0 0 $SMSShell.receivers.unix.ClientRequest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import time [EOL] [EOL] [comment] [EOL] from . . abstract import AbstractModule [EOL] [EOL] [EOL] class AbstractReceiver ( AbstractModule ) : [EOL] [docstring] [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def read ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [EOL] class AbstractClientRequest ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , request_data ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] self . __treatment_chain = [ ] [EOL] self . __response_data = dict ( ) [EOL] self . __request_data = request_data [EOL] self . __is_in_context = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def appendTreatmentChain ( self , state_name ) : [EOL] [docstring] [EOL] self . __treatment_chain . append ( ( state_name , time . time ( ) ) ) [EOL] [EOL] def getTreatmentChain ( self ) : [EOL] [docstring] [EOL] return self . __treatment_chain [EOL] [EOL] def addResponseData ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . __response_data . update ( kwargs ) [EOL] [EOL] def popResponseData ( self ) : [EOL] [docstring] [EOL] final = self . __response_data [EOL] self . __response_data = dict ( ) [EOL] return final [EOL] [EOL] def getRequestData ( self ) : [EOL] [docstring] [EOL] if not self . __is_in_context : [EOL] raise RuntimeError ( [string] + [string] ) [EOL] return self . __request_data [EOL] [EOL] def enter ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def exit ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __enter__ ( self ) : [EOL] self . __is_in_context = True [EOL] self . enter ( ) [EOL] return self . getRequestData ( ) [EOL] [EOL] def __exit__ ( self , _type , value , traceback ) : [EOL] self . __is_in_context = False [EOL] self . exit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0