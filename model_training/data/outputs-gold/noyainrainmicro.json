from typing import List [EOL] import typing [EOL] from setuptools import find_packages , setup [EOL] [EOL] with open ( [string] ) as f : [EOL] long_description = f . read ( ) [EOL] with open ( [string] ) as f : [EOL] requirements = f . read ( ) . splitlines ( ) [EOL] [EOL] setup ( name = [string] , version = [string] , url = [string] , maintainer = [string] , maintainer_email = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , classifiers = [ [string] , [string] ] , packages = find_packages ( ) , package_data = { [string] : [ [string] ] } , install_requires = requirements ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0
from typing import List , Dict , Union [EOL] import typing [EOL] import os [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] [EOL] import micro [EOL] [EOL] extensions = [ [string] , [string] ] [EOL] source_suffix = [ [string] , [string] ] [EOL] source_parsers = { [string] : [string] } [EOL] [EOL] project = [string] [EOL] copyright = [string] [EOL] version = release = [string] [EOL] [EOL] html_theme_options = { [string] : [string] , [string] : True , [string] : [string] } [EOL] html_favicon = [string] [EOL] html_static_path = [ [string] ] [EOL] html_sidebars = { [string] : [ [string] , [string] , [string] ] } [EOL] html_show_sourcelink = False [EOL] [EOL] autodoc_member_order = [string] [EOL] [EOL] [comment] [EOL] try : [EOL] os . symlink ( micro . DOC_PATH , [string] ) [EOL] except FileExistsError : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Callable , Iterator , Any , Dict , List , Tuple , Type [EOL] import typing [EOL] import argparse [EOL] import hello [EOL] [docstring] [EOL] [EOL] import sys [EOL] [EOL] from micro import Application , Collection , Editable , Event , Object , Settings , WithContent , error [EOL] from micro . core import context [EOL] from micro . jsonredis import RedisList [EOL] from micro . server import CollectionEndpoint , Server [EOL] from micro . util import Expect , make_command_line_parser , randstr , setup_logging [EOL] [EOL] class Hello ( Application ) : [EOL] [docstring] [EOL] [EOL] class Greetings ( Collection ) : [EOL] [docstring] [EOL] [EOL] async def create ( self , text , resource ) : [EOL] [docstring] [EOL] if not context . user . get ( ) : [EOL] raise error . PermissionError ( ) [EOL] attrs = await WithContent . process_attrs ( { [string] : text , [string] : resource } , app = self . app ) [EOL] if not ( attrs [ [string] ] or attrs [ [string] ] ) : [EOL] raise error . ValueError ( [string] ) [EOL] [EOL] greeting = Greeting ( id = [string] . format ( randstr ( ) ) , app = self . app , authors = [ self . app . user . id ] , text = attrs [ [string] ] , resource = attrs [ [string] ] ) [EOL] self . r . oset ( greeting . id , greeting ) [EOL] self . r . lpush ( self . ids . key , greeting . id ) [EOL] self . app . activity . publish ( Event . create ( [string] , None , detail = { [string] : greeting } , app = self . app ) ) [EOL] return greeting [EOL] [EOL] def __init__ ( self , redis_url = [string] , email = [string] , smtp_url = [string] , render_email_auth_message = None , * , files_path = [string] , video_service_keys = { } ) : [EOL] super ( ) . __init__ ( redis_url = redis_url , email = email , smtp_url = smtp_url , render_email_auth_message = render_email_auth_message , files_path = files_path , video_service_keys = video_service_keys ) [EOL] self . types . update ( { [string] : Greeting } ) [EOL] self . greetings = Hello . Greetings ( RedisList ( [string] , self . r . r ) , app = self ) [EOL] [EOL] def create_settings ( self ) : [EOL] [comment] [EOL] return Settings ( id = [string] , app = self , authors = [ ] , title = [string] , icon = None , icon_small = None , icon_large = None , provider_name = None , provider_url = None , provider_description = { } , feedback_url = None , staff = [ ] , push_vapid_private_key = None , push_vapid_public_key = None , v = [number] ) [EOL] [EOL] class Greeting ( Object , Editable , WithContent ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] def __init__ ( self , * , id , app , authors , text , resource ) : [EOL] super ( ) . __init__ ( id , app ) [EOL] Editable . __init__ ( self , authors ) [EOL] WithContent . __init__ ( self , text = text , resource = resource ) [EOL] [EOL] async def do_edit ( self , ** attrs ) : [EOL] attrs = await WithContent . pre_edit ( self , attrs ) [EOL] if not ( attrs . get ( [string] , self . text ) or attrs . get ( [string] , self . resource ) ) : [EOL] raise error . ValueError ( [string] ) [EOL] WithContent . do_edit ( attrs ) [EOL] [EOL] def json ( self , restricted = False , include = False , * , rewrite = None ) : [EOL] return { ** super ( ) . json ( restricted = restricted , include = include , rewrite = rewrite ) , ** Editable . json ( self , restricted = restricted , include = include , rewrite = rewrite ) , ** WithContent . json ( self , restricted = restricted , include = include , rewrite = rewrite ) } [EOL] [EOL] def make_server ( * , port = [number] , url = None , debug = False , redis_url = [string] , smtp_url = [string] , files_path = [string] , video_service_keys = { } , client_map_service_key = None ) : [EOL] [docstring] [EOL] app = Hello ( redis_url = redis_url , smtp_url = smtp_url , files_path = files_path , video_service_keys = video_service_keys ) [EOL] handlers = [ ( [string] , _GreetingsEndpoint , { [string] : lambda * args : app . greetings } ) ] [EOL] return Server ( app , handlers , port = port , url = url , debug = debug , client_config = { [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : client_map_service_key } ) [EOL] [EOL] class _GreetingsEndpoint ( CollectionEndpoint ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] async def post ( self ) : [EOL] text = self . get_arg ( [string] , Expect . opt ( Expect . str ) ) [EOL] resource = self . get_arg ( [string] , Expect . opt ( Expect . str ) ) [EOL] if resource is not None : [EOL] resource = self . server . rewrite ( resource , reverse = True ) [EOL] greeting = await self . app . greetings . create ( text , resource ) [EOL] self . write ( greeting . json ( restricted = True , include = True , rewrite = self . server . rewrite ) ) [EOL] [EOL] def main ( args ) : [EOL] [docstring] [EOL] args = make_command_line_parser ( ) . parse_args ( args [ [number] : ] ) [EOL] if [string] in args : [EOL] values = iter ( args . video_service_keys ) [EOL] args . video_service_keys = dict ( zip ( values , values ) ) [EOL] setup_logging ( args . debug if [string] in args else False ) [EOL] make_server ( ** vars ( args ) ) . run ( ) [EOL] return [number] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hello.hello.Greeting$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $hello.hello.Greeting$ 0 0 0 $hello.hello.Greeting$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hello.hello.Greeting$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hello.hello.Greeting$ 0 0 0 0 0 0 0 0 0 0 0 $hello.hello.Greeting$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hello.hello.Hello.Greetings$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] [comment] [EOL] from micro . micro import ( Application , Object , Gone , Editable , Trashable , Collection , Orderable , User , Settings , Activity , Event , AuthRequest , Location , ValueError , InputError , AuthenticationError , CommunicationError , EmailError , WithContent ) [EOL] [EOL] DOC_PATH = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Optional , Any , Union [EOL] import typing [EOL] import urllib [EOL] import tornado [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import errno [EOL] import json [EOL] from json import JSONDecodeError [EOL] from os import strerror [EOL] from typing import Dict , Union , cast [EOL] from urllib . parse import SplitResult , urlencode , urlsplit [EOL] from warnings import catch_warnings [EOL] [EOL] from tornado . httpclient import AsyncHTTPClient , HTTPRequest , HTTPResponse [EOL] from tornado . simple_httpclient import HTTPStreamClosedError , HTTPTimeoutError [EOL] [EOL] class WebAPIError ( Exception ) : [EOL] [docstring] [EOL] [EOL] @ property def error ( self ) : [EOL] [docstring] [EOL] return self . args [ [number] ] [comment] [EOL] [EOL] @ property def status ( self ) : [EOL] [docstring] [EOL] return self . args [ [number] ] [comment] [EOL] [EOL] def __str__ ( self ) : [EOL] return self . args [ [number] ] [comment] [EOL] [EOL] class CommunicationError ( Exception ) : [EOL] [docstring] [EOL] [EOL] async def fetch ( request , raise_error = True , ** kwargs ) : [EOL] [docstring] [EOL] url , method = ( ( request , kwargs . get ( [string] , [string] ) ) if isinstance ( request , str ) else [EOL] ( request . url , request . method ) ) [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] with catch_warnings ( record = True ) : [EOL] response = await AsyncHTTPClient ( ) . fetch ( request , raise_error = raise_error , ** kwargs ) [EOL] if response . code == [number] : [EOL] assert response . error is not None [EOL] raise response . error [EOL] return response [EOL] except HTTPStreamClosedError as e : [EOL] raise CommunicationError ( f'{ strerror ( errno . ESHUTDOWN ) } [string] { method } [string] { url }' ) from e [EOL] except HTTPTimeoutError as e : [EOL] raise CommunicationError ( f'{ strerror ( errno . ETIMEDOUT ) } [string] { method } [string] { url }' ) from e [EOL] except OSError as e : [EOL] raise CommunicationError ( [string] . format ( e , method , url ) ) from e [EOL] [EOL] class WebAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , url , * , query = { } , headers = { } ) : [EOL] urlparts = urlsplit ( url ) [EOL] if not ( urlparts . scheme in { [string] , [string] } and urlparts . netloc and not any ( [ urlparts . query , urlparts . fragment ] ) ) : [EOL] raise ValueError ( [string] . format ( url ) ) [EOL] self . url = url [EOL] self . query = query [EOL] self . headers = headers [EOL] self . _urlparts = urlparts [EOL] [EOL] async def call ( self , method , url , * , args = None , query = { } ) : [EOL] [docstring] [EOL] if not method . strip ( ) : [EOL] raise ValueError ( [string] ) [EOL] urlparts = urlsplit ( url ) [EOL] if any ( [ urlparts . scheme , urlparts . netloc , urlparts . query , urlparts . fragment ] ) : [EOL] raise ValueError ( [string] . format ( url ) ) [EOL] [EOL] query = dict ( list ( self . query . items ( ) ) + list ( query . items ( ) ) ) [EOL] url = SplitResult ( self . _urlparts . scheme , self . _urlparts . netloc , self . _urlparts . path + urlparts . path , urlencode ( query ) , [string] ) . geturl ( ) [EOL] body = None if args is None else json . dumps ( args ) [EOL] [EOL] response = await fetch ( url , raise_error = False , method = method , headers = self . headers , body = body ) [EOL] try : [EOL] result = cast ( object , json . loads ( response . body . decode ( ) ) ) [EOL] if not isinstance ( result , dict ) : [EOL] raise TypeError ( ) [EOL] except ( UnicodeDecodeError , JSONDecodeError , TypeError ) as e : [EOL] raise CommunicationError ( [string] . format ( method , url ) ) from e [EOL] [EOL] if not [number] <= response . code < [number] : [EOL] raise WebAPIError ( [string] . format ( response . code , method , url ) , result , response . code ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.httpclient.HTTPResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.SplitResult$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $urllib.parse.SplitResult$ 0 0 0 $urllib.parse.SplitResult$ 0 0 0 $urllib.parse.SplitResult$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $urllib.parse.SplitResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.SplitResult$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 $tornado.httpclient.HTTPResponse$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $tornado.httpclient.HTTPResponse$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $tornado.httpclient.HTTPResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.httpclient.HTTPResponse$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.object$ 0 $tornado.httpclient.HTTPResponse$ 0 0 0 0 0 $builtins.object$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] MESSAGE_TEMPLATES = { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Callable , Optional , Type [EOL] import typing [EOL] import micro [EOL] import contextvars [EOL] [docstring] [EOL] [EOL] from contextvars import ContextVar [EOL] import typing [EOL] from typing import Callable , Optional [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] from micro import User [EOL] [EOL] RewriteFunc = Callable [ [ str ] , str ] [EOL] [EOL] class context : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] user = ContextVar ( [string] , default = None ) [EOL] client = ContextVar ( [string] , default = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import micro [EOL] import tornado [EOL] import builtins [EOL] import os [EOL] from tempfile import mkdtemp [EOL] [EOL] from tornado . testing import AsyncTestCase , AsyncHTTPTestCase , gen_test [EOL] from tornado . web import Application , RequestHandler [EOL] [EOL] from micro . error import CommunicationError [EOL] from micro . resource import ( Analyzer , BrokenResourceError , Files , ForbiddenResourceError , Image , NoResourceError , Resource ) [EOL] [EOL] class AnalyzerTestCase ( AsyncHTTPTestCase ) : [EOL] def get_app ( self ) : [EOL] return Application ( [ ( [string] , CodeEndpoint ) ] , static_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] [EOL] @ gen_test async def test_analyze_blob ( self ) : [EOL] analyzer = Analyzer ( ) [EOL] resource = await analyzer . analyze ( self . get_url ( [string] ) ) [EOL] self . assertIsInstance ( resource , Resource ) [EOL] self . assertRegex ( resource . url , [string] ) [EOL] self . assertEqual ( resource . content_type , [string] ) [EOL] self . assertIsNone ( resource . description ) [EOL] self . assertIsNone ( resource . image ) [EOL] [EOL] @ gen_test async def test_analyze_image ( self ) : [EOL] analyzer = Analyzer ( ) [EOL] image = await analyzer . analyze ( self . get_url ( [string] ) ) [EOL] self . assertIsInstance ( image , Image ) [EOL] self . assertEqual ( image . content_type , [string] ) [EOL] self . assertIsNone ( image . description ) [EOL] self . assertIsNone ( image . image ) [EOL] [EOL] @ gen_test async def test_analyze_webpage ( self ) : [EOL] analyzer = Analyzer ( ) [EOL] webpage = await analyzer . analyze ( self . get_url ( [string] ) ) [EOL] self . assertIsInstance ( webpage , Resource ) [EOL] self . assertEqual ( webpage . content_type , [string] ) [EOL] self . assertEqual ( webpage . description , [string] ) [EOL] assert isinstance ( webpage . image , Image ) [EOL] self . assertRegex ( webpage . image . url , [string] ) [EOL] [EOL] @ gen_test async def test_analyze_file ( self ) : [EOL] files = Files ( mkdtemp ( ) ) [EOL] url = await files . write ( [string] , [string] ) [EOL] analyzer = Analyzer ( files = files ) [EOL] resource = await analyzer . analyze ( url ) [EOL] self . assertEqual ( resource . url , url ) [EOL] self . assertEqual ( resource . content_type , [string] ) [EOL] [EOL] @ gen_test async def test_analyze_no_resource ( self ) : [EOL] analyzer = Analyzer ( ) [EOL] with self . assertRaises ( NoResourceError ) : [EOL] await analyzer . analyze ( self . get_url ( [string] ) ) [EOL] [EOL] @ gen_test async def test_analyze_forbidden_resource ( self ) : [EOL] analyzer = Analyzer ( ) [EOL] with self . assertRaises ( ForbiddenResourceError ) : [EOL] await analyzer . analyze ( self . get_url ( [string] ) ) [EOL] [EOL] @ gen_test async def test_analyze_resource_loop ( self ) : [EOL] analyzer = Analyzer ( ) [EOL] with self . assertRaises ( BrokenResourceError ) : [EOL] await analyzer . analyze ( self . get_url ( [string] ) ) [EOL] [EOL] @ gen_test async def test_analyze_error_response ( self ) : [EOL] analyzer = Analyzer ( ) [EOL] with self . assertRaises ( CommunicationError ) : [EOL] await analyzer . analyze ( self . get_url ( [string] ) ) [EOL] [EOL] @ gen_test async def test_analyze_no_host ( self ) : [EOL] analyzer = Analyzer ( ) [EOL] with self . assertRaises ( CommunicationError ) : [EOL] await analyzer . analyze ( [string] ) [EOL] [EOL] class FilesTest ( AsyncTestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . files = Files ( mkdtemp ( ) ) [EOL] [EOL] @ gen_test async def test_read ( self ) : [EOL] url = await self . files . write ( [string] , [string] ) [EOL] data , content_type = await self . files . read ( url ) [EOL] self . assertEqual ( data , [string] ) [EOL] self . assertEqual ( content_type , [string] ) [EOL] [EOL] @ gen_test async def test_read_no ( self ) : [EOL] with self . assertRaises ( LookupError ) : [EOL] await self . files . read ( [string] ) [EOL] [EOL] @ gen_test async def test_garbage_collect ( self ) : [EOL] urls = [ await self . files . write ( data , [string] ) for data in ( [string] , [string] , [string] , [string] ) ] [EOL] n = await self . files . garbage_collect ( urls [ : [number] ] ) [EOL] self . assertEqual ( n , [number] ) [EOL] data , _ = await self . files . read ( urls [ [number] ] ) [EOL] self . assertEqual ( data , [string] ) [EOL] data , _ = await self . files . read ( urls [ [number] ] ) [EOL] self . assertEqual ( data , [string] ) [EOL] with self . assertRaises ( LookupError ) : [EOL] await self . files . read ( urls [ [number] ] ) [EOL] with self . assertRaises ( LookupError ) : [EOL] await self . files . read ( urls [ [number] ] ) [EOL] [EOL] class CodeEndpoint ( RequestHandler ) : [EOL] [comment] [EOL] [EOL] def get ( self , code ) : [EOL] [comment] [EOL] self . set_status ( int ( code ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 $micro.resource.Resource$ 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 $micro.resource.Resource$ 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 $micro.resource.Resource$ 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $micro.resource.Files$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $micro.resource.Files$ 0 0 0 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 $micro.resource.Files$ 0 $micro.resource.Files$ 0 0 $micro.resource.Resource$ 0 0 $micro.resource.Analyzer$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $micro.resource.Resource$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $micro.resource.Resource$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $micro.resource.Analyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $micro.resource.Files$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] from pathlib import Path [EOL] [EOL] RES_PATH = Path ( __file__ ) . parent / [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import pathlib [EOL] from unittest import TestCase [EOL] [EOL] from micro . tests import RES_PATH [EOL] from micro . util import look_up_files , version [EOL] [EOL] class LookUpFilesTest ( TestCase ) : [EOL] def test_call ( self ) : [EOL] files = look_up_files ( [ [string] , [string] , [string] , [string] ] , top = RES_PATH ) [EOL] result = [ RES_PATH / [string] , RES_PATH / [string] , RES_PATH / [string] ] [EOL] self . assertEqual ( files , result ) [EOL] [EOL] def test_call_no_file ( self ) : [EOL] with self . assertRaisesRegex ( ValueError , [string] ) : [EOL] look_up_files ( [ [string] ] , top = RES_PATH ) [EOL] [EOL] class VersionTest ( TestCase ) : [EOL] @ version ( [number] ) def echo ( self , a ) : [EOL] return ( [number] , self , a ) [EOL] [EOL] @ echo . version ( [number] ) def echo ( self , b , a ) : [EOL] [comment] [EOL] return ( [number] , self , b , a ) [EOL] [EOL] def test_call ( self ) : [EOL] result = self . echo ( [string] ) [EOL] self . assertEqual ( result , ( [number] , self , [string] ) ) [EOL] [EOL] def test_call_v_1 ( self ) : [EOL] result = self . echo ( [string] , v = [number] ) [EOL] self . assertEqual ( result , ( [number] , self , [string] ) ) [EOL] [EOL] def test_call_v_2 ( self ) : [EOL] result = self . echo ( [string] , [string] , v = [number] ) [EOL] self . assertEqual ( result , ( [number] , self , [string] , [string] ) ) [EOL] [EOL] def test_call_v_unknown ( self ) : [EOL] with self . assertRaises ( NotImplementedError ) : [EOL] self . echo ( [string] , v = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0