from typing import List , Any [EOL] import typing [EOL] import json [EOL] import unittest [EOL] import sys [EOL] [EOL] def create_list_of_peaks_From_json ( path , name ) : [EOL] with open ( path , [string] ) as json_data : [EOL] data = json . load ( json_data ) [EOL] numbers = data [ name ] . split ( ) [EOL] numbers_as_ints = [ int ( i ) for i in numbers ] [EOL] return numbers_as_ints [EOL] [EOL] def calculate_summit_order ( peaks ) : [EOL] first = peaks [ [number] ] [EOL] peaks = peaks [ [number] : ] [EOL] return build_summit_order ( peaks , [ first ] ) [EOL] [EOL] def calculate_summit_order_dynamic ( peaks ) : [EOL] summits = [ [ n ] for n in peaks ] [EOL] for j in range ( [number] , len ( peaks ) ) : [EOL] for i in range ( j ) : [EOL] if peaks [ j ] > peaks [ i ] and len ( summits [ j ] ) < len ( summits [ i ] ) + [number] : [EOL] summits [ j ] = summits [ i ] + [ peaks [ j ] ] [EOL] return max ( summits , key = len ) [EOL] [EOL] def build_summit_order ( peaks , summits ) : [EOL] if len ( peaks ) == [number] : [EOL] return summits [EOL] else : [EOL] last_summit = summits [ len ( summits ) - [number] ] [EOL] result = find_next_biggest_number ( last_summit , peaks ) [EOL] if result . number != None : [EOL] summits . append ( result . number ) [EOL] return build_summit_order ( peaks [ result . index + [number] : ] , summits ) [EOL] [EOL] def find_next_biggest_number ( current_number , numbers ) : [EOL] smallest_diff_index = [number] [EOL] smallest_diff = find_max_diff ( current_number , numbers ) [EOL] for index , item in enumerate ( numbers ) : [EOL] diff = item - current_number [EOL] if diff == [number] : [EOL] return NumberAndIndex ( index , item ) [EOL] elif diff > [number] and diff < smallest_diff : [EOL] smallest_diff = diff [EOL] smallest_diff_index = index [EOL] else : [EOL] pass [EOL] if smallest_diff_index == [number] : [EOL] return NumberAndIndex ( [number] , None ) [EOL] return NumberAndIndex ( smallest_diff_index , numbers [ smallest_diff_index ] ) [EOL] [EOL] def find_max_diff ( current_number , numbers ) : [EOL] max_diff = [number] [EOL] for n in numbers : [EOL] if n - current_number > max_diff : [EOL] max_diff = n - current_number [EOL] return max_diff [EOL] [EOL] class NumberAndIndex : [EOL] [EOL] def __init__ ( self , index , number ) : [EOL] self . index = index [EOL] self . number = number [EOL] [EOL] class SummitTests ( unittest . TestCase ) : [EOL] [EOL] def test_find_next_biggest_number_1 ( self ) : [EOL] numbers = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] result = find_next_biggest_number ( [number] , numbers ) [EOL] self . assertEqual ( result . index , [number] ) [EOL] self . assertEqual ( result . number , [number] ) [EOL] [EOL] def test_find_max_diff_1 ( self ) : [EOL] numbers = [ [number] , [number] , [number] ] [EOL] result = find_max_diff ( [number] , numbers ) [EOL] self . assertEqual ( result , [number] ) [EOL] [EOL] def test_find_max_diff_2 ( self ) : [EOL] numbers = [ [number] ] [EOL] result = find_max_diff ( [number] , numbers ) [EOL] self . assertEqual ( result , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) > [number] : [EOL] path = sys . argv [ [number] ] [EOL] data_name = sys . argv [ [number] ] [EOL] peaks = create_list_of_peaks_From_json ( path , data_name ) [EOL] [comment] [EOL] result = calculate_summit_order_dynamic ( peaks ) [EOL] print ( result ) [EOL] else : [EOL] unittest . main ( argv = None )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] from typing import List , Dict [EOL] [EOL] def fibonacci ( n ) : [EOL] if n == [number] : [EOL] return [number] [EOL] elif n == [number] : [EOL] return [number] [EOL] else : [EOL] return fibonacci ( n - [number] ) + fibonacci ( n - [number] ) [EOL] [EOL] solved = dict ( ) [EOL] solved [ [number] ] = [number] [EOL] solved [ [number] ] = [number] [EOL] [EOL] [EOL] def fibonacci_dynamic ( n ) : [EOL] if n in solved : [EOL] return solved [ n ] [EOL] else : [EOL] solved [ n ] = fibonacci_dynamic ( n - [number] ) + fibonacci_dynamic ( n - [number] ) [EOL] return solved [ n ] [EOL] [EOL] print ( fibonacci_dynamic ( [number] ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple [EOL] import typing [EOL] import unittest [EOL] import fibo [EOL] [EOL] class FiboTests ( unittest . TestCase ) : [EOL] [EOL] testdata = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] [EOL] def test_with_fibonacci ( self ) : [EOL] for data in FiboTests . testdata : [EOL] self . assertEqual ( fibo . fibonacci ( data [ [number] ] ) , data [ [number] ] ) [EOL] [EOL] def test_with_fibonacci_dynamic ( self ) : [EOL] for data in FiboTests . testdata : [EOL] self . assertEqual ( fibo . fibonacci_dynamic ( data [ [number] ] ) , data [ [number] ] ) [EOL] [EOL] def test_with_fibonacci_dynamic_func ( self ) : [EOL] self . calculate_with_func ( fibo . fibonacci_dynamic ) [EOL] [EOL] def test_with_fibonacci_func ( self ) : [EOL] self . calculate_with_func ( fibo . fibonacci ) [EOL] [EOL] def calculate_with_func ( self , fibo_func ) : [EOL] for data in FiboTests . testdata : [EOL] self . assertEqual ( fibo_func ( data [ [number] ] ) , data [ [number] ] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple , Any [EOL] import typing [EOL] def create_lists_from_input ( path ) : [EOL] rows = list ( ) [EOL] with open ( path , [string] ) as raw_input : [EOL] for row in raw_input : [EOL] numbers_as_ints = [ int ( i ) for i in row . split ( ) ] [EOL] rows . append ( numbers_as_ints ) [EOL] return rows [EOL] [EOL] def find_consecutive_distance ( row ) : [EOL] total_distance = [number] [EOL] sep = [number] [EOL] done_pairs = list ( ) [EOL] for i in range ( [number] , len ( row ) ) : [EOL] for j in range ( i + [number] , len ( row ) ) : [EOL] pair = ( min ( i , j ) , max ( i , j ) ) [EOL] if abs ( row [ i ] - row [ j ] ) == [number] and pair not in done_pairs : [EOL] distance = j - i [EOL] total_distance += distance [EOL] done_pairs . append ( pair ) [EOL] return total_distance [EOL] [EOL] if __name__ == [string] : [EOL] rows = create_lists_from_input ( [string] ) [EOL] for row in rows [ [number] : ] : [EOL] print ( find_consecutive_distance ( row ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import cribbage [EOL] import unittest [EOL] from cribbage import Hand , Card , Suit , Rank [EOL] from typing import List [EOL] [EOL] class CribbageTests ( unittest . TestCase ) : [EOL] [EOL] def hand_1_nobs ( self ) : [EOL] return self . create_hand ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def hand_0_nobs ( self ) : [EOL] return self . create_hand ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def hand_no_flush ( self ) : [EOL] return self . create_hand ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def hand_flush_4_cards ( self ) : [EOL] return self . create_hand ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def hand_flush_5_cards ( self ) : [EOL] return self . create_hand ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def create_hand ( self , input_hand ) : [EOL] cards = list ( ) [EOL] for chars in input_hand : [EOL] cards . append ( Card . create_card_from_chars ( chars ) ) [EOL] return Hand ( cards ) [EOL] [EOL] def test_nobs ( self ) : [EOL] self . assertEqual ( [number] , self . hand_1_nobs ( ) . nobs ( ) ) [EOL] self . assertEqual ( [number] , self . hand_0_nobs ( ) . nobs ( ) ) [EOL] [EOL] [EOL] def test_flush ( self ) : [EOL] self . assertEqual ( [number] , self . hand_no_flush ( ) . flush ( ) ) [EOL] self . assertEqual ( [number] , self . hand_flush_4_cards ( ) . flush ( ) ) [EOL] self . assertEqual ( [number] , self . hand_flush_5_cards ( ) . flush ( ) ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cribbage.Hand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cribbage.Hand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cribbage.Hand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cribbage.Hand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cribbage.Hand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cribbage.Card]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cribbage.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cribbage.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] class PowerOperations : [EOL] [EOL] @ staticmethod def sum_digits ( number ) : [EOL] sum = [number] [EOL] for char in str ( number ) : [EOL] sum = sum + int ( char ) [EOL] return sum [EOL] [EOL] @ staticmethod def sum_digits_exponent ( base , power ) : [EOL] number = pow ( base , power ) [EOL] return PowerOperations . sum_digits ( number ) [EOL] [EOL] class PowerOperationsTests ( unittest . TestCase ) : [EOL] [EOL] def test_sum_digits ( self ) : [EOL] self . simple_assert_harness ( [number] , [number] ) [EOL] self . simple_assert_harness ( [number] , [number] ) [EOL] self . simple_assert_harness ( [number] , [number] ) [EOL] [EOL] def test_sum_exponent ( self ) : [EOL] self . exponent_sum_assert_harness ( [number] , [number] , [number] ) [EOL] self . exponent_sum_assert_harness ( [number] , [number] , [number] ) [EOL] [EOL] def simple_assert_harness ( self , number , expected_total ) : [EOL] actual_total = PowerOperations . sum_digits ( number ) [EOL] self . assertEqual ( expected_total , actual_total ) [EOL] [EOL] def exponent_sum_assert_harness ( self , base , exponent , expected_total ) : [EOL] actual_total = PowerOperations . sum_digits_exponent ( base , exponent ) [EOL] self . assertEqual ( expected_total , actual_total ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import challenge331 [EOL] def add ( num1 , num2 ) : [EOL] return num1 + num2 [EOL] [EOL] def subtract ( num1 , num2 ) : [EOL] total = num1 [EOL] if num2 > [number] : [EOL] for i in range ( num2 ) : [EOL] total = add ( total , - [number] ) [EOL] else : [EOL] for i in range ( [number] , num2 , - [number] ) : [EOL] total = add ( total , [number] ) [EOL] return total [EOL] [EOL] def multiply ( num1 , num2 ) : [EOL] total = [number] [EOL] if num2 > [number] : [EOL] for i in range ( num2 ) : [EOL] total = add ( total , num1 ) [EOL] else : [EOL] for i in range ( [number] , num2 , - [number] ) : [EOL] total = subtract ( total , num1 ) [EOL] return total [EOL] [EOL] def absolute_value ( num ) : [EOL] if num < [number] : [EOL] return multiply ( num , - [number] ) [EOL] else : [EOL] return num [EOL] [EOL] def calculate_sign ( num1 , num2 ) : [EOL] sign = [number] [EOL] if num1 > [number] and num2 > [number] : [EOL] sign = [number] [EOL] elif num1 < [number] and num2 < [number] : [EOL] sign = [number] [EOL] else : [EOL] sign = - [number] [EOL] return sign [EOL] [EOL] def divide ( num1 , num2 ) : [EOL] sign = calculate_sign ( num1 , num2 ) [EOL] num1 = absolute_value ( num1 ) [EOL] num2 = absolute_value ( num2 ) [EOL] if num2 == [number] : [EOL] return [string] [EOL] else : [EOL] count = [number] [EOL] while num1 > [number] : [EOL] num1 = subtract ( num1 , num2 ) [EOL] count = add ( count , [number] ) [EOL] if num1 == [number] : [EOL] return count * sign [EOL] else : [EOL] return [string] [EOL] [EOL] def exponent ( base , power ) : [EOL] if power < [number] : [EOL] return [string] [EOL] else : [EOL] total = [number] [EOL] for i in range ( [number] , power ) : [EOL] total = multiply ( total , base ) [EOL] return total [EOL] [EOL] class WholeNumber : [EOL] [EOL] def __init__ ( self , value ) : [EOL] if type ( value ) is int : [EOL] self . value = value [EOL] else : [EOL] raise TypeError ( f" [string] { type ( value ) } [string] " ) [EOL] [EOL] def __add__ ( self , other_whole_number ) : [EOL] return add ( self . value , other_whole_number . value ) [EOL] [EOL] def __sub__ ( self , other_whole_number ) : [EOL] return subtract ( self . value , other_whole_number . value ) [EOL] [EOL] def __mul__ ( self , other_whole_number ) : [EOL] return multiply ( self . value , other_whole_number . value ) [EOL] [EOL] def __div__ ( self , other_whole_number ) : [EOL] return divide ( self . value , other_whole_number . value ) [EOL] [EOL] def __pow__ ( self , other_whole_number ) : [EOL] return exponent ( self . value , other_whole_number . value ) [EOL] [EOL] import unittest [EOL] class CalculatorTests ( unittest . TestCase ) : [EOL] [EOL] def test_add ( self ) : [EOL] self . assertEqual ( add ( [number] , [number] ) , [number] ) [EOL] self . assertEqual ( add ( - [number] , [number] ) , [number] ) [EOL] [EOL] def test_multiply ( self ) : [EOL] self . assertEqual ( multiply ( [number] , [number] ) , [number] ) [EOL] self . assertEqual ( multiply ( [number] , - [number] ) , - [number] ) [EOL] self . assertEqual ( multiply ( - [number] , [number] ) , - [number] ) [EOL] self . assertEqual ( multiply ( - [number] , - [number] ) , [number] ) [EOL] [EOL] def test_abosulute_value ( self ) : [EOL] self . assertEqual ( absolute_value ( [number] ) , [number] ) [EOL] self . assertEqual ( absolute_value ( - [number] ) , [number] ) [EOL] [EOL] def test_subtract ( self ) : [EOL] self . assertEqual ( subtract ( [number] , [number] ) , [number] ) [EOL] self . assertEqual ( subtract ( [number] , - [number] ) , [number] ) [EOL] self . assertEqual ( subtract ( - [number] , [number] ) , - [number] ) [EOL] self . assertEqual ( subtract ( - [number] , - [number] ) , - [number] ) [EOL] [EOL] def test_divide ( self ) : [EOL] self . assertEqual ( divide ( [number] , [number] ) , [number] ) [EOL] self . assertEqual ( divide ( [number] , [number] ) , [string] ) [EOL] self . assertEqual ( divide ( [number] , - [number] ) , - [number] ) [EOL] self . assertEqual ( divide ( - [number] , [number] ) , - [number] ) [EOL] self . assertEqual ( divide ( [number] , [number] ) , [string] ) [EOL] [EOL] def test_exponent ( self ) : [EOL] self . assertEqual ( exponent ( [number] , [number] ) , [number] ) [EOL] self . assertEqual ( exponent ( - [number] , [number] ) , - [number] ) [EOL] self . assertEqual ( exponent ( - [number] , [number] ) , - [number] ) [EOL] self . assertEqual ( exponent ( - [number] , [number] ) , - [number] ) [EOL] self . assertEqual ( exponent ( [number] , [number] ) , [number] ) [EOL] self . assertEqual ( exponent ( [number] , [number] ) , [number] ) [EOL] self . assertEqual ( exponent ( [number] , [number] ) , [number] ) [EOL] self . assertEqual ( exponent ( [number] , - [number] ) , [string] ) [EOL] [EOL] class WholeNumberTests ( unittest . TestCase ) : [EOL] [EOL] def test_operator_overloading ( self ) : [EOL] num1 = WholeNumber ( [number] ) [EOL] num2 = WholeNumber ( [number] ) [EOL] self . assertEqual ( num1 + num2 , [number] ) [EOL] self . assertEqual ( num1 - num2 , [number] ) [EOL] self . assertEqual ( num1 * num2 , [number] ) [EOL] self . assertEqual ( num1 / num2 , [number] ) [EOL] self . assertEqual ( num1 ** num2 , [number] ) [EOL] [EOL] def test_abs1 ( self ) : [EOL] self . assertEqual ( abs ( - [number] ) , [number] ) [EOL] [EOL] def test_abs2 ( self ) : [EOL] self . assertEqual ( abs ( [number] ) , [number] ) [EOL] [EOL] def test_divide1 ( self ) : [EOL] result = divide ( [number] , [number] ) [EOL] self . assertEqual ( result , [number] ) [EOL] [EOL] def test_divide2 ( self ) : [EOL] result = divide ( [number] , - [number] ) [EOL] self . assertEqual ( result , - [number] ) [EOL] [EOL] def test_divide3 ( self ) : [EOL] result = divide ( - [number] , [number] ) [EOL] self . assertEqual ( result , - [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $challenge331.calculator.WholeNumber$ 0 0 0 0 0 0 $challenge331.calculator.WholeNumber$ 0 0 0 0 0 0 0 0 0 0 $challenge331.calculator.WholeNumber$ 0 $challenge331.calculator.WholeNumber$ 0 0 0 0 0 0 0 0 $challenge331.calculator.WholeNumber$ 0 $challenge331.calculator.WholeNumber$ 0 0 0 0 0 0 0 0 $challenge331.calculator.WholeNumber$ 0 $challenge331.calculator.WholeNumber$ 0 0 0 0 0 0 0 0 $challenge331.calculator.WholeNumber$ 0 $challenge331.calculator.WholeNumber$ 0 0 0 0 0 0 0 0 $challenge331.calculator.WholeNumber$ 0 $challenge331.calculator.WholeNumber$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Pattern , List , Any , Match [EOL] import typing [EOL] import challenge333 [EOL] import re [EOL] import unittest [EOL] import sys [EOL] [EOL] class Packet : [EOL] [EOL] def __init__ ( self , message_id , packet_id , packet_count , text ) : [EOL] self . message_id = int ( message_id ) [EOL] self . packet_id = int ( packet_id ) [EOL] self . packet_count = int ( packet_count ) [EOL] self . text = text [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . message_id } [string] { self . packet_id } [string] { self . packet_count } [string] { self . text }" [EOL] [EOL] @ staticmethod def create_from_text ( text ) : [EOL] pattern = re . compile ( [string] ) [EOL] matches = re . match ( pattern , text ) [EOL] packet = Packet ( matches . groups ( ) [ [number] ] , matches . groups ( ) [ [number] ] , matches . groups ( ) [ [number] ] , matches . groups ( ) [ [number] ] ) [EOL] return packet [EOL] [EOL] class Message : [EOL] [EOL] def __init__ ( self , message_id , count ) : [EOL] self . message_id = message_id [EOL] self . count = count [EOL] self . packets = Message . create_list_of_size ( count ) [EOL] [EOL] def add_packet ( self , packet ) : [EOL] self . packets [ packet . packet_id ] = packet [EOL] [EOL] def __str__ ( self ) : [EOL] result = [string] [EOL] for p in self . packets : [EOL] result = result + str ( p ) + [string] [EOL] return result [EOL] [EOL] @ staticmethod def create_list_of_size ( count ) : [EOL] l = list ( ) [EOL] for i in range ( count ) : [EOL] l . append ( [number] ) [EOL] return l [EOL] [EOL] class Messages : [EOL] [EOL] def __init__ ( self , packets = None ) : [EOL] if packets == None : [EOL] self . packets_stream = list ( ) [EOL] else : [EOL] self . packets_stream = list ( ) [EOL] self . packets_stream . extend ( packets ) [EOL] self . messages = dict ( ) [EOL] [EOL] def recieve_packets ( self , incoming_packets ) : [EOL] self . packets_stream . extend ( incoming_packets ) [EOL] [EOL] def recieve_packet ( self , incoming_packet ) : [EOL] self . packets_stream . append ( incoming_packet ) [EOL] [EOL] def assemble ( self ) : [EOL] for p in self . packets_stream : [EOL] if p . message_id in self . messages : [EOL] self . messages [ p . message_id ] . add_packet ( p ) [EOL] else : [EOL] self . messages [ p . message_id ] = Message ( p . message_id , p . packet_count ) [EOL] self . messages [ p . message_id ] . add_packet ( p ) [EOL] [EOL] def get_all_messages ( self ) : [EOL] for m in self . messages . values ( ) : [EOL] yield m [EOL] [EOL] @ staticmethod def bootstrap_from_input_file ( path ) : [EOL] packets = list ( ) [EOL] with open ( path , [string] ) as f : [EOL] for line in f : [EOL] packet = Packet . create_from_text ( line ) [EOL] packets . append ( packet ) [EOL] return Messages ( packets ) [EOL] [EOL] class PacketAssemblerTests ( unittest . TestCase ) : [EOL] [EOL] def test_regex_parse_of_packet_text_representation ( self ) : [EOL] packet = Packet . create_from_text ( [string] ) [EOL] self . packet_assert ( packet , [number] , [number] , [number] , [string] ) [EOL] [EOL] def packet_assert ( self , packet , expected_mid , expected_pid , expected_count , expected_text ) : [EOL] self . assertEqual ( packet . message_id , expected_mid ) [EOL] self . assertEqual ( packet . packet_id , expected_pid ) [EOL] self . assertEqual ( packet . packet_count , expected_count ) [EOL] self . assertEqual ( packet . text , expected_text ) [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) == [number] and sys . argv [ [number] ] . lower ( ) == [string] : [EOL] unittest . main ( argv = [ [string] ] ) [EOL] else : [EOL] messages = Messages . bootstrap_from_input_file ( [string] ) [EOL] messages . assemble ( ) [EOL] for m in messages . get_all_messages ( ) : [EOL] print ( m ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 $challenge333.packets.Packet$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $challenge333.packets.Packet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Sequence , Tuple , Any [EOL] import typing [EOL] import builtins [EOL] from typing import List , Tuple , Sequence [EOL] import unittest [EOL] [EOL] def create_rental_tuples ( input_data_path ) : [EOL] [docstring] [EOL] rental_times = list ( ) [EOL] count = None [EOL] first = None [EOL] second = None [EOL] with open ( input_data_path , [string] ) as text : [EOL] for line_number , line in enumerate ( text ) : [EOL] if line_number == [number] : [EOL] count = int ( line ) [EOL] elif line_number == [number] : [EOL] first = line . split ( ) [EOL] elif line_number == [number] : [EOL] second = line . split ( ) [EOL] for i in range ( [number] , count ) : [EOL] rental_times . append ( ( int ( first [ i ] ) , int ( second [ i ] ) ) ) [EOL] return rental_times [EOL] [EOL] def by_earliest_end_date ( rental_times ) : [EOL] result = list ( ) [EOL] while len ( rental_times ) != [number] : [EOL] earliest_end_date = earliest_ending_time ( rental_times ) [EOL] result . append ( earliest_end_date ) [EOL] rental_times = remove_overlapping_times ( rental_times , earliest_end_date ) [EOL] return result [EOL] [EOL] def earliest_ending_time ( times ) : [EOL] return sorted ( times , key = lambda tup : tup [ [number] ] ) [ [number] ] [EOL] [EOL] def remove_overlapping_times ( all_times , key_time ) : [EOL] non_overlapping_times = list ( ) [EOL] for time in all_times : [EOL] if time [ [number] ] <= key_time [ [number] ] : [EOL] pass [EOL] else : [EOL] non_overlapping_times . append ( time ) [EOL] return non_overlapping_times [EOL] [EOL] def pretty_print_grid ( grid ) : [EOL] for row in grid : [EOL] print ( row ) [EOL] [EOL] class TimeSchedulingUnitTests ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . rental_times = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] self . challenge_rental_times = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] [EOL] def test_earliest_end_1 ( self ) : [EOL] result = earliest_ending_time ( self . rental_times ) [EOL] self . assertEqual ( ( [number] , [number] ) , result ) [EOL] [EOL] def test_remove_overlapping_1 ( self ) : [EOL] earliest_end = earliest_ending_time ( self . rental_times ) [EOL] result = remove_overlapping_times ( self . rental_times , earliest_end ) [EOL] self . assertListEqual ( [ ( [number] , [number] ) ] , result ) [EOL] [EOL] if __name__ == [string] : [EOL] rental_times = create_rental_tuples ( [string] ) [EOL] earliest_end_date_solution = by_earliest_end_date ( rental_times ) [EOL] print ( earliest_end_date_solution ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] import os [EOL] import unittest [EOL] [EOL] class Minefield ( object ) : [EOL] [EOL] def __init__ ( self , minefield_grid ) : [EOL] self . minefield = minefield_grid [EOL] [EOL] def create_minefield ( user_input ) : [EOL] minefield = list ( ) [EOL] rows = user_input . split ( [string] ) [EOL] rows = [ r . strip ( ) for r in rows if len ( r . strip ( ) ) > [number] ] [EOL] for row in rows : [EOL] chars = list ( ) [EOL] for char in row : [EOL] chars . append ( char ) [EOL] minefield . append ( chars ) [EOL] return minefield [EOL] [EOL] class MinefieldTests ( unittest . TestCase ) : [EOL] [EOL] def test_creation_from_hardcoded_input ( self ) : [EOL] sample_input = [string] [EOL] expected = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] actual = create_minefield ( sample_input ) [EOL] self . assertEqual ( expected , actual ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict [EOL] import typing [EOL] import builtins [EOL] from typing import Tuple , Dict [EOL] import unittest [EOL] [EOL] def first_repeating_character ( characters ) : [EOL] chars = { } [EOL] for index , char in enumerate ( characters ) : [EOL] if char in chars : [EOL] return ( index , char ) [EOL] else : [EOL] chars [ char ] = [number] [EOL] return ( None , None ) [EOL] [EOL] [EOL] class RepeatingCharacterTests ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_sample_input ( self ) : [EOL] result = first_repeating_character ( [string] ) [EOL] self . assert_helper ( result , [number] , [string] ) [EOL] [EOL] def test_challenge_input_1 ( self ) : [EOL] result = first_repeating_character ( [string] ) [EOL] self . assert_helper ( result , [number] , [string] ) [EOL] [EOL] def test_challenge_input_2 ( self ) : [EOL] result = first_repeating_character ( [string] ) [EOL] self . assert_helper ( result , [number] , [string] ) [EOL] [EOL] def test_challenge_input_3 ( self ) : [EOL] result = first_repeating_character ( [string] ) [EOL] self . assert_helper ( result , [number] , [string] ) [EOL] [EOL] def assert_helper ( self , result , expected_index , expected_char ) : [EOL] self . assertEqual ( result [ [number] ] , expected_index ) [EOL] self . assertEqual ( result [ [number] ] , expected_char ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] from typing import List , Tuple [EOL] [docstring] [EOL] [EOL] def number_from_text_file ( path ) : [EOL] with open ( path , [string] ) as file : [EOL] number_string = file . read ( ) [EOL] return int ( number_string ) [EOL] [EOL] def rows_of_numbers_from_text_file ( path ) : [EOL] result = list ( ) [EOL] with open ( path , [string] ) as file : [EOL] lines = file . readlines ( ) [EOL] for line in lines : [EOL] numbers = [ int ( n ) for n in line . split ( ) ] [EOL] result . append ( numbers ) [EOL] return result [EOL] [EOL] def lines_from_text_file ( path ) : [EOL] with open ( path , [string] ) as file : [EOL] return file . readlines ( ) [EOL] [EOL] def numbers_from_text_file ( path ) : [EOL] with open ( path , [string] ) as file : [EOL] string_numbers = file . read ( ) . split ( ) [EOL] numbers = [ int ( number . strip ( ) ) for number in string_numbers ] [EOL] return numbers [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any , Sequence , Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import Sequence , Dict , Tuple [EOL] import common [EOL] [EOL] class Cycle ( object ) : [EOL] [EOL] def __init__ ( self , count , previous_dupe ) : [EOL] self . count = count [EOL] self . previous_dupe = previous_dupe [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . count } [string] { self . previous_dupe }" [EOL] [EOL] def memory_cycles ( memory ) : [EOL] memory_banks = tuple ( memory ) [EOL] previous_states = { } [EOL] counter = [number] [EOL] while memory_banks not in previous_states : [EOL] previous_states [ memory_banks ] = counter [EOL] memory_banks = balance ( memory_banks ) [EOL] counter += [number] [EOL] return Cycle ( counter , counter - previous_states [ memory_banks ] ) [EOL] [EOL] def balance ( memory_banks ) : [EOL] mut_memory_banks = list ( memory_banks ) [EOL] index , max_value = max ( enumerate ( memory_banks ) , key = lambda p : p [ [number] ] ) [EOL] mut_memory_banks [ index ] = [number] [EOL] for i in range ( max_value ) : [EOL] j = ( i + index + [number] ) % len ( mut_memory_banks ) [EOL] mut_memory_banks [ j ] += [number] [EOL] return tuple ( mut_memory_banks ) [EOL] [EOL] if __name__ == [string] : [EOL] challenge_input = common . numbers_from_text_file ( [string] ) [EOL] print ( memory_cycles ( challenge_input ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Cycle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import List , Dict , Any , Callable , Sequence [EOL] import typing [EOL] import builtins [EOL] from typing import Sequence , Dict , Callable [EOL] import common [EOL] [EOL] def valid_passphrases ( passphrases , validate ) : [EOL] count = [number] [EOL] for passphrase in passphrases : [EOL] if validate ( passphrase ) : [EOL] count += [number] [EOL] return count [EOL] [EOL] def basic_validation ( passphrase ) : [EOL] return validate_transformed_words ( passphrase . split ( ) ) [EOL] [EOL] def anagram_validation ( passphrase ) : [EOL] words = passphrase . split ( ) [EOL] normalized_words = [ [string] . join ( sorted ( word ) ) for word in words ] [EOL] return validate_transformed_words ( normalized_words ) [EOL] [EOL] def validate_transformed_words ( words ) : [EOL] passphrase_words = { } [EOL] for word in words : [EOL] if word in passphrase_words : [EOL] return False [EOL] else : [EOL] passphrase_words [ word ] = [number] [EOL] return True [EOL] [EOL] if __name__ == [string] : [EOL] challenge_input = common . lines_from_text_file ( [string] ) [EOL] print ( f" [string] { valid_passphrases ( challenge_input , basic_validation ) }" ) [EOL] print ( f" [string] { valid_passphrases ( challenge_input , anagram_validation ) }" )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import List , Sequence , Callable , Any [EOL] import typing [EOL] import builtins [EOL] from typing import List , Callable , Sequence [EOL] import common [EOL] [EOL] def escape ( jump_instructions , jump_modify ) : [EOL] index = [number] [EOL] counter = [number] [EOL] while inside_bounds ( jump_instructions , index ) : [EOL] prev_index = index [EOL] index += jump_instructions [ index ] [EOL] counter += [number] [EOL] jump_instructions [ prev_index ] = jump_modify ( jump_instructions [ prev_index ] ) [EOL] return counter [EOL] [EOL] def part_one ( number ) : [EOL] return number + [number] [EOL] [EOL] def part_two ( number ) : [EOL] if number >= [number] : [EOL] return number - [number] [EOL] else : [EOL] return number + [number] [EOL] [EOL] def inside_bounds ( array , index ) : [EOL] if index >= [number] and index < len ( array ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] if __name__ == [string] : [EOL] numbers = common . numbers_from_text_file ( [string] ) [EOL] print ( escape ( numbers , part_one ) ) [EOL] numbers = common . numbers_from_text_file ( [string] ) [EOL] print ( escape ( numbers , part_two ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aoc2017 [EOL] import builtins [EOL] import common [EOL] [EOL] class IterableNumber ( object ) : [EOL] [EOL] def __init__ ( self , value ) : [EOL] self . value = str ( value ) [EOL] self . position = [number] [EOL] self . cycled = False [EOL] [EOL] def advance ( self ) : [EOL] if self . position + [number] == len ( self . value ) : [EOL] self . cycled = True [EOL] self . position = [number] [EOL] else : [EOL] self . position += [number] [EOL] [EOL] def get ( self , offset = [number] ) : [EOL] if self . position + offset < len ( self . value ) : [EOL] return int ( self . value [ self . position + offset ] ) [EOL] else : [EOL] return int ( self . value [ self . position + offset - len ( self . value ) ] ) [EOL] [EOL] def reset ( self ) : [EOL] self . position = [number] [EOL] [EOL] [EOL] def inverse_captcha ( offset , input_number ) : [EOL] sum = [number] [EOL] number = IterableNumber ( input_number ) [EOL] while number . cycled is False : [EOL] current = number . get ( ) [EOL] next = number . get ( offset ) [EOL] number . advance ( ) [EOL] if current == next : [EOL] sum += current [EOL] return sum [EOL] [EOL] if __name__ == [string] : [EOL] challenge_input = common . number_from_text_file ( [string] ) [EOL] print ( inverse_captcha ( [number] , challenge_input ) ) [EOL] offset = int ( len ( str ( challenge_input ) ) / [number] ) [EOL] print ( inverse_captcha ( offset , challenge_input ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0
from typing import List , Union , Tuple , Any [EOL] import typing [EOL] import pytest [EOL] import day01 , day02 , day03 , day04 , day05 , day06 , day07 [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) def test_day01_part1 ( sample_input , expected ) : [EOL] assert day01 . inverse_captcha ( [number] , sample_input ) == expected [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) def test_day01_part2 ( sample_input , expected ) : [EOL] amount = int ( len ( str ( sample_input ) ) / [number] ) [EOL] assert day01 . inverse_captcha ( amount , sample_input ) == expected [EOL] [EOL] def test_day02_part1 ( ) : [EOL] sample_data = [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] [EOL] actual = day02 . checksum ( sample_data , day02 . diff_checksum ) [EOL] assert actual == [number] [EOL] [EOL] def test_day02_part2 ( ) : [EOL] sample_data = [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] [EOL] actual = day02 . checksum ( sample_data , day02 . div_checksum ) [EOL] assert actual == [number] [EOL] [EOL] def test_day03_generate_spiral_sequence ( ) : [EOL] result = list ( ) [EOL] for i in day03 . generate_spiral_sequence ( [number] ) : [EOL] result . append ( i ) [EOL] assert result == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , True ) , ( [string] , False ) , ( [string] , True ) ] ) def test_day04_is_passphrase_valid ( input , expected ) : [EOL] assert day04 . basic_validation ( input ) == expected [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , True ) , ( [string] , False ) , ( [string] , True ) , ( [string] , True ) , ( [string] , False ) ] ) def test_day04_is_passphrase_valid_with_no_anagrams ( input , expected ) : [EOL] assert day04 . anagram_validation ( input ) == expected [EOL] [EOL] def test_day05_part1 ( ) : [EOL] sample_input = [ [number] , [number] , [number] , [number] , - [number] ] [EOL] assert day05 . escape ( sample_input , day05 . part_one ) == [number] [EOL] [EOL] def test_day05_part2 ( ) : [EOL] sample_input = [ [number] , [number] , [number] , [number] , - [number] ] [EOL] assert day05 . escape ( sample_input , day05 . part_two ) == [number] [EOL] [EOL] def test_day06_part1 ( ) : [EOL] sample_input = [ [number] , [number] , [number] , [number] ] [EOL] assert day06 . memory_cycles ( sample_input ) . count == [number] [EOL] [EOL] def test_day06_part2 ( ) : [EOL] sample_input = [ [number] , [number] , [number] , [number] ] [EOL] assert day06 . memory_cycles ( sample_input ) . previous_dupe == [number] [EOL] [EOL] def test_day07_create_with_children ( ) : [EOL] text = [string] [EOL] expected = day07 . Node ( [string] , [number] , ( [string] , [string] , [string] ) ) [EOL] assert day07 . Node . create ( text ) == expected [EOL] [EOL] def test_day07_create_without_children ( ) : [EOL] text = [string] [EOL] expected = day07 . Node ( [string] , [number] ) [EOL] assert day07 . Node . create ( text ) == expected [EOL] [EOL] def test_day07_total_sub_weight ( ) : [EOL] nodes = ( day07 . Node ( [string] , [number] , [ [string] , [string] , [string] ] ) , day07 . Node ( [string] , [number] ) , day07 . Node ( [string] , [number] ) , day07 . Node ( [string] , [number] ) ) [EOL] tree = day07 . Tree ( nodes ) [EOL] assert day07 . Tree . calculate_sub_weight ( tree . root_node ) == [number] [EOL] [EOL] def test_day07_total_sub_weight_one_node ( ) : [EOL] nodes = [ day07 . Node ( [string] , [number] ) ] [EOL] tree = day07 . Tree ( nodes ) [EOL] assert day07 . Tree . calculate_sub_weight ( tree . root_node ) == [number] [EOL] [EOL] def test_day07_total_sub_weight_one_node_one_child ( ) : [EOL] nodes = ( day07 . Node ( [string] , [number] , [ [string] ] ) , day07 . Node ( [string] , [number] ) ) [EOL] tree = day07 . Tree ( nodes ) [EOL] assert day07 . Tree . calculate_sub_weight ( tree . root_node ) == [number] [EOL] [EOL] def test_day07_total_sub_weight_three_levels_deep ( ) : [EOL] nodes = [ day07 . Node ( [string] , [number] , [ [string] , [string] , [string] ] ) , day07 . Node ( [string] , [number] ) , day07 . Node ( [string] , [number] ) , day07 . Node ( [string] , [number] , [ [string] , [string] ] ) , day07 . Node ( [string] , [number] ) , day07 . Node ( [string] , [number] ) ] [EOL] tree = day07 . Tree ( nodes ) [EOL] result = day07 . Tree . calculate_sub_weight ( tree . root_node ) [EOL] assert result == [number] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( day07 . Node ( [string] , [number] , None ) , None ) ] ) def test_day07_odd_weight_out ( input , expected ) : [EOL] assert expected == day07 . Tree . odd_child_node ( input ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] def generate_spiral_sequence ( num_terms ) : [EOL] current , counter = [number] , [number] [EOL] number_repeated = False [EOL] while counter < num_terms : [EOL] if number_repeated is False : [EOL] current += [number] [EOL] number_repeated = True [EOL] else : [EOL] number_repeated = False [EOL] counter += [number] [EOL] yield current [EOL] [EOL] class SpiralMemory ( object ) : [EOL] [EOL] def __init__ ( self , capacity ) : [EOL] self . capacity = capacity [EOL] self . matrix = list ( list ( ) ) [EOL] self . memory_matrix = self . create ( ) [EOL] [EOL] def create ( self ) : [EOL] counter = [number] [EOL] current_position = [ [number] ] [ [number] ] [EOL] for i in generate_spiral_sequence ( self . capacity ) : [EOL] if counter % [number] == [number] : [EOL] self . matrix . append ( ) [EOL] elif counter % [number] == [number] : [EOL] pass [EOL] elif counter % [number] == [number] : [EOL] pass [EOL] else : [EOL] pass [EOL] [EOL] @ classmethod def closest_odd_square ( cls , n ) : [EOL] for i in range ( [number] , n * n , [number] ) : [EOL] odd_square = i * i [EOL] if odd_square > n : [EOL] return f" [string] { ( i - [number] ) } [string] { ( i - [number] ) * ( i - [number] ) }" [EOL] [EOL] def manhattan_path ( x_pos , y_pos ) : [EOL] return abs ( x_pos ) + abs ( y_pos ) [EOL] [EOL] if __name__ == [string] : [EOL] result = SpiralMemory . closest_odd_square ( [number] ) [EOL] print ( result )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import Tuple [EOL] [EOL] def climb_staircase ( n , climb_set ) : [EOL] return [number] [EOL] [EOL] def test_climb_staircase_with_provider_answer ( ) : [EOL] assert [number] == climb_staircase ( [number] , ( [number] , [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0