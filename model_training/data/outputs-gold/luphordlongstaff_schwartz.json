[comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import longstaff_schwartz [EOL] [docstring] [EOL] [EOL] import unittest [EOL] import numpy as np [EOL] from numpy . polynomial import Polynomial [EOL] [EOL] from longstaff_schwartz . regression_basis import PolynomialRegressionBasis [EOL] [EOL] [EOL] class TestRegressionBasis ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_polynomial_components ( self ) : [EOL] [docstring] [EOL] for n in range ( [number] ) : [EOL] regr = PolynomialRegressionBasis ( n ) [EOL] self . assertEqual ( len ( regr . basis_functions ) , n + [number] ) [EOL] [EOL] def test_np_polynomial_api_compatibility ( self ) : [EOL] x = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] y = np . array ( [ [number] , - [number] , - [number] , - [number] , - [number] , - [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] p = Polynomial . fit ( x , y , [number] ) [EOL] r = PolynomialRegressionBasis ( [number] ) . fit ( x , y ) [EOL] self . assertTrue ( np . allclose ( p ( x ) , r ( x ) ) ) [EOL] px , py = p . linspace ( ) [EOL] rx , ry = r . linspace ( ) [EOL] self . assertTrue ( np . allclose ( px , rx ) ) [EOL] self . assertTrue ( np . allclose ( py , ry ) ) [EOL] px , py = p . linspace ( [number] , [ - [number] , [number] ] ) [EOL] rx , ry = r . linspace ( [number] , [ - [number] , [number] ] ) [EOL] self . assertTrue ( np . allclose ( px , rx ) ) [EOL] self . assertTrue ( np . allclose ( py , ry ) ) [EOL] coef = p . convert ( domain = [ - [number] , [number] ] ) . coef [EOL] self . assertTrue ( np . allclose ( coef , r . beta ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $longstaff_schwartz.regression_basis.PolynomialRegressionBasis$ 0 0 0 0 0 0 0 0 0 0 0 0 $longstaff_schwartz.regression_basis.PolynomialRegressionBasis$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import longstaff_schwartz [EOL] import unittest [EOL] [EOL] [EOL] class TestDemo ( unittest . TestCase ) : [EOL] def test_readme_demo ( self ) : [EOL] [docstring] [EOL] from longstaff_schwartz . algorithm import longstaff_schwartz [EOL] from longstaff_schwartz . stochastic_process import GeometricBrownianMotion [EOL] import numpy as np [EOL] [EOL] [comment] [EOL] t = np . linspace ( [number] , [number] , [number] ) [comment] [EOL] r = [number] [comment] [EOL] sigma = [number] [comment] [EOL] n = [number] [comment] [EOL] [EOL] [comment] [EOL] gbm = GeometricBrownianMotion ( mu = r , sigma = sigma ) [EOL] rnd = np . random . RandomState ( [number] ) [EOL] x = gbm . simulate ( t , n , rnd ) [comment] [EOL] [EOL] [comment] [EOL] strike = [number] [EOL] [EOL] def put_payoff ( spot ) : [EOL] return np . maximum ( strike - spot , [number] ) [EOL] [EOL] [comment] [EOL] def constant_rate_df ( t_from , t_to ) : [EOL] return np . exp ( - r * ( t_to - t_from ) ) [EOL] [EOL] [comment] [EOL] def fit_quadratic ( x , y ) : [EOL] return np . polynomial . Polynomial . fit ( x , y , [number] , rcond = None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def itm ( payoff , spot ) : [EOL] return payoff > [number] [EOL] [EOL] [comment] [EOL] npv_american = longstaff_schwartz ( x , t , constant_rate_df , fit_quadratic , put_payoff , itm ) [EOL] [EOL] [comment] [EOL] npv_european = constant_rate_df ( t [ [number] ] , t [ - [number] ] ) * put_payoff ( x [ - [number] ] ) . mean ( ) [EOL] [EOL] [comment] [EOL] assert np . round ( npv_american , [number] ) == [number] [EOL] assert np . round ( npv_european , [number] ) == [number] [EOL] assert npv_american > npv_european [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $longstaff_schwartz.algorithm.longstaff_schwartz.stochastic_process.GeometricBrownianMotion$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $longstaff_schwartz.algorithm.longstaff_schwartz.stochastic_process.GeometricBrownianMotion$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0
from typing import List , Any [EOL] import typing [EOL] import longstaff_schwartz [EOL] import unittest [EOL] [EOL] import numpy as np [EOL] [EOL] from longstaff_schwartz . binomial import BinomialModel , create_binomial_model , call_payoff , european_call_price , european_put_price , american_call_price , american_put_price , american_put_exercise_barrier , american_put_exercise_barrier_fitted [EOL] [EOL] [EOL] class TestBinomial ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_european_call_price_decrease_with_strike ( self ) : [EOL] mdl = create_binomial_model ( [number] , [number] , [number] , [number] , n = [number] ) [EOL] last = None [EOL] for s in range ( [number] , [number] ) : [EOL] current = european_call_price ( mdl , s ) [EOL] if last is not None : [EOL] self . assertLess ( current , last ) [EOL] last = current [EOL] [EOL] def test_thayer_watkins_example ( self ) : [EOL] [docstring] [EOL] u = [number] + [number] [EOL] d = [number] - [number] [EOL] r = np . log ( [number] + [number] ) [comment] [EOL] S0 = [number] [EOL] T = [number] [EOL] n = [number] [EOL] strike = [number] [EOL] mdl = BinomialModel ( u , d , r , S0 , T , n ) [EOL] npv = european_call_price ( mdl , strike ) [EOL] self . assertEqual ( [number] , np . round ( npv , [number] ) ) [EOL] [EOL] def test_cox_ross_rubinstein_example ( self ) : [EOL] [docstring] [EOL] S0 = [number] [EOL] n = [number] [EOL] T = [number] [EOL] strike = [number] [EOL] u = [number] [EOL] d = [number] [EOL] r = np . log ( [number] ) [EOL] mdl = BinomialModel ( u , d , r , S0 , T , n ) [EOL] npv = european_call_price ( mdl , strike ) [EOL] self . assertEqual ( [number] , np . round ( npv , [number] ) ) [comment] [EOL] expected_payoff = np . array ( [ [number] , [number] , [number] - [number] , [number] - [number] ] ) [EOL] payoff = call_payoff ( strike ) ( mdl . ST ) [EOL] self . assertTrue ( np . allclose ( expected_payoff , payoff ) ) [EOL] self . assertTrue ( np . allclose ( [number] , mdl . q ) ) [EOL] [EOL] def test_put_call_parity ( self ) : [EOL] expected = [ ] [EOL] actual = [ ] [EOL] for sigma in [ [number] , [number] , [number] ] : [EOL] for r in [ - [number] , [number] , [number] , [number] ] : [EOL] for S0 in [ [number] , [number] , [number] ] : [EOL] mdl = create_binomial_model ( [number] , [number] , [number] , [number] , n = [number] ) [EOL] for strike in [ [number] , [number] , [number] , [number] , [number] ] : [EOL] expected . append ( mdl . S0 - strike * np . exp ( - mdl . r * mdl . T ) ) [EOL] actual . append ( european_call_price ( mdl , strike ) - european_put_price ( mdl , strike ) ) [EOL] self . assertTrue ( np . allclose ( expected , actual ) ) [EOL] [EOL] def test_american_european_call_equality ( self ) : [EOL] european = [ ] [EOL] american = [ ] [EOL] for sigma in [ [number] , [number] , [number] ] : [EOL] for r in [ - [number] , [number] , [number] , [number] ] : [EOL] for S0 in [ [number] , [number] , [number] ] : [EOL] mdl = create_binomial_model ( [number] , [number] , [number] , [number] , n = [number] ) [EOL] for strike in [ [number] , [number] , [number] , [number] , [number] ] : [EOL] european . append ( european_call_price ( mdl , strike ) ) [EOL] american . append ( american_call_price ( mdl , strike ) ) [EOL] self . assertTrue ( np . allclose ( european , american ) ) [EOL] [EOL] def test_american_european_put_difference ( self ) : [EOL] european = [ ] [EOL] american = [ ] [EOL] for sigma in [ [number] , [number] , [number] ] : [EOL] for r in [ - [number] , [number] , [number] , [number] ] : [EOL] for S0 in [ [number] , [number] , [number] ] : [EOL] mdl = create_binomial_model ( [number] , [number] , [number] , [number] , n = [number] ) [EOL] for strike in [ [number] , [number] , [number] , [number] , [number] ] : [EOL] european . append ( european_put_price ( mdl , strike ) ) [EOL] american . append ( american_put_price ( mdl , strike ) ) [EOL] aamerican = np . array ( american ) [EOL] aeuropean = np . array ( european ) [EOL] self . assertTrue ( ( aamerican > aeuropean ) . all ( ) ) [EOL] [comment] [EOL] self . assertGreater ( ( aamerican - aeuropean ) . max ( ) , [number] ) [EOL] [EOL] def test_ucsd_example ( self ) : [EOL] [docstring] [EOL] S0 = [number] [EOL] n = [number] [EOL] T = [number] [EOL] strike = [number] [EOL] sigma = [number] [EOL] r = [number] [EOL] mdl = create_binomial_model ( sigma , r , S0 , T , n ) [EOL] npv = american_put_price ( mdl , strike ) [EOL] self . assertAlmostEqual ( [number] , npv ) [EOL] [EOL] def test_deep_itm_american_out ( self ) : [EOL] [docstring] [EOL] S0 = [number] [EOL] n = [number] [EOL] T = [number] [EOL] strike = [number] [EOL] sigma = [number] [EOL] r = [number] [EOL] mdl = create_binomial_model ( sigma , r , S0 , T , n ) [EOL] npv = american_put_price ( mdl , strike ) [EOL] self . assertAlmostEqual ( strike - S0 , npv ) [EOL] [EOL] def test_american_exercise_barrier ( self ) : [EOL] [docstring] [EOL] S0 = [number] [EOL] n = [number] [EOL] T = [number] [EOL] strike = [number] [EOL] sigma = [number] [EOL] r = [number] [EOL] mdl = create_binomial_model ( sigma , r , S0 , T , n ) [EOL] exercise_barrier = american_put_exercise_barrier ( mdl , strike ) [EOL] last_even = np . nan [EOL] last_odd = np . nan [EOL] for i , s in enumerate ( exercise_barrier ) : [EOL] if i % [number] == [number] : [EOL] if not np . isnan ( last_even ) : [EOL] self . assertGreaterEqual ( s , last_even ) [EOL] last_even = s [EOL] elif i % [number] == [number] : [EOL] if not np . isnan ( last_odd ) : [EOL] self . assertGreaterEqual ( s , last_odd ) [EOL] last_odd = s [EOL] [EOL] def test_american_exercise_barrier_fitted ( self ) : [EOL] [docstring] [EOL] S0 = [number] [EOL] n = [number] [EOL] T = [number] [EOL] strike = [number] [EOL] sigma = [number] [EOL] r = [number] [EOL] mdl = create_binomial_model ( sigma , r , S0 , T , n ) [EOL] barrier = american_put_exercise_barrier_fitted ( mdl , strike , [number] ) [EOL] barrier = barrier . convert ( domain = [ - [number] , [number] ] ) [EOL] self . assertGreater ( barrier . coef [ [number] ] , [number] ) [EOL] self . assertLessEqual ( barrier . coef [ [number] ] , [number] ) [EOL] self . assertGreater ( barrier . coef [ [number] ] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $longstaff_schwartz.binomial.BinomialModel$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $longstaff_schwartz.binomial.BinomialModel$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $longstaff_schwartz.binomial.BinomialModel$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $longstaff_schwartz.binomial.BinomialModel$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $longstaff_schwartz.binomial.BinomialModel$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $longstaff_schwartz.binomial.BinomialModel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.float$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import longstaff_schwartz [EOL] [docstring] [EOL] [EOL] import unittest [EOL] [EOL] import numpy as np [EOL] from numpy . random import RandomState [EOL] from scipy . stats import kstest [EOL] [EOL] from longstaff_schwartz . stochastic_process import BrownianMotion , GeometricBrownianMotion [EOL] [EOL] [EOL] class TestRegressionBasis ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] mu = [number] [EOL] sigma = [number] [EOL] self . bm = BrownianMotion ( mu = mu , sigma = sigma ) [EOL] self . gbm = GeometricBrownianMotion ( mu = mu , sigma = sigma ) [EOL] self . rnd = RandomState ( [number] ) [EOL] [EOL] def test_brownian_motion_distribution ( self ) : [EOL] [docstring] [EOL] t = np . linspace ( [number] , [number] , [number] ) [EOL] n = [number] [EOL] x = self . bm . simulate ( t , n , self . rnd ) [EOL] self . assertEqual ( ( t . size , n ) , x . shape ) [EOL] self . assertEqual ( n , x [ - [number] , : ] . size ) [EOL] terminal_dist = self . bm . distribution ( t [ - [number] ] ) [EOL] test_result = kstest ( x [ - [number] , : ] , terminal_dist . cdf ) [EOL] self . assertGreater ( test_result . pvalue , [number] ) [EOL] [EOL] def test_geometric_brownian_motion_distribution ( self ) : [EOL] [docstring] [EOL] t = np . linspace ( [number] , [number] , [number] ) [EOL] n = [number] [EOL] x = self . gbm . simulate ( t , n , self . rnd ) [EOL] self . assertEqual ( ( t . size , n ) , x . shape ) [EOL] self . assertEqual ( n , x [ - [number] , : ] . size ) [EOL] terminal_dist = self . gbm . distribution ( t [ - [number] ] ) [EOL] test_result = kstest ( x [ - [number] , : ] , terminal_dist . cdf ) [EOL] print ( test_result ) [EOL] self . assertGreater ( test_result . pvalue , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 $longstaff_schwartz.stochastic_process.BrownianMotion$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $longstaff_schwartz.stochastic_process.GeometricBrownianMotion$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import click [EOL] import typing [EOL] import longstaff_schwartz [EOL] [docstring] [EOL] [EOL] [EOL] import unittest [EOL] from click . testing import CliRunner [EOL] [EOL] import numpy as np [EOL] from numpy . polynomial import Polynomial [EOL] from numpy . random import RandomState [EOL] [EOL] from longstaff_schwartz import cli [EOL] from longstaff_schwartz . algorithm import longstaff_schwartz_american_option_quadratic , ls_american_option_quadratic_iter , longstaff_schwartz [EOL] from longstaff_schwartz . stochastic_process import GeometricBrownianMotion [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] X = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) . T [EOL] t = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] r = [number] [EOL] strike = [number] [EOL] coef2 = np . array ( [ - [number] , [number] , - [number] ] ) [comment] [EOL] coef1 = np . array ( [ [number] , - [number] , [number] ] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def american_put_payoff ( spot ) : [EOL] return np . maximum ( strike - spot , [number] ) [EOL] [EOL] [EOL] def constant_rate_df ( t_from , t_to ) : [EOL] return np . exp ( - r * ( t_to - t_from ) ) [EOL] [EOL] [EOL] def fit_quadratic ( x , y ) : [EOL] return Polynomial . fit ( x , y , [number] ) [EOL] [EOL] [EOL] def itm ( payoff , spot ) : [EOL] return payoff > [number] [EOL] [EOL] [EOL] class TestLongstaff_schwartz ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_command_line_interface ( self ) : [EOL] [docstring] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli . main ) [EOL] assert result . exit_code == [number] [EOL] help_result = runner . invoke ( cli . main , [ [string] ] ) [EOL] assert help_result . exit_code == [number] [EOL] assert [string] in help_result . output [EOL] [EOL] def test_longstaff_schwartz_paper_example ( self ) : [EOL] [docstring] [EOL] value = longstaff_schwartz_american_option_quadratic ( X , t , r , strike ) [EOL] self . assertEqual ( [number] , np . round ( value , [number] ) ) [EOL] df = np . exp ( - r * ( t [ - [number] ] - t [ [number] ] ) ) [EOL] european_value = np . maximum ( strike - X [ - [number] , : ] , [number] ) . mean ( ) * df [EOL] self . assertEqual ( [number] , np . round ( european_value , [number] ) ) [EOL] [EOL] def test_longstaff_schwartz_paper_example_intermediate_values ( self ) : [EOL] intermediate = list ( ls_american_option_quadratic_iter ( X , t , r , strike ) ) [EOL] cashflow , x , fitted , continuation , exercise , ex_idx = intermediate [ [number] ] [EOL] fitted_coef2 = np . round ( fitted . convert ( domain = [ - [number] , [number] ] ) . coef , [number] ) [EOL] self . assertTrue ( np . allclose ( coef2 , fitted_coef2 ) ) [EOL] cashflow , x , fitted , continuation , exercise , ex_idx = intermediate [ [number] ] [EOL] fitted_coef1 = np . round ( fitted . convert ( domain = [ - [number] , [number] ] ) . coef , [number] ) [EOL] self . assertTrue ( np . allclose ( coef1 , fitted_coef1 ) ) [EOL] [EOL] def test_longstaff_schwartz_paper_example_for_general_algorithm ( self ) : [EOL] [docstring] [EOL] value = longstaff_schwartz ( X , t , constant_rate_df , fit_quadratic , american_put_payoff , itm ) [EOL] self . assertEqual ( [number] , np . round ( value , [number] ) ) [EOL] df = np . exp ( - r * ( t [ - [number] ] - t [ [number] ] ) ) [EOL] european_value = american_put_payoff ( X [ - [number] , : ] ) . mean ( ) * df [EOL] self . assertEqual ( [number] , np . round ( european_value , [number] ) ) [EOL] [EOL] def test_general_against_specific_algorithm ( self ) : [EOL] [docstring] [EOL] gbm = GeometricBrownianMotion ( mu = r , sigma = [number] ) [EOL] rnd = RandomState ( [number] ) [EOL] t = np . linspace ( [number] , [number] , [number] ) [EOL] n = [number] [EOL] x = gbm . simulate ( t , n , rnd ) [EOL] general = longstaff_schwartz ( x , t , constant_rate_df , fit_quadratic , american_put_payoff , itm ) [EOL] specific = longstaff_schwartz_american_option_quadratic ( x , t , r , strike ) [EOL] self . assertAlmostEqual ( general , specific ) [EOL] allpathregr = longstaff_schwartz ( x , t , constant_rate_df , fit_quadratic , american_put_payoff ) [EOL] self . assertNotAlmostEqual ( general , allpathregr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.testing.CliRunner$ 0 0 0 0 0 $click.testing.Result$ 0 $click.testing.CliRunner$ 0 0 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 $click.testing.Result$ 0 $click.testing.CliRunner$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $longstaff_schwartz.stochastic_process.GeometricBrownianMotion$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $longstaff_schwartz.stochastic_process.GeometricBrownianMotion$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] __author__ = [string] [EOL] __email__ = [string] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import scipy [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] import numpy as np [EOL] from scipy . stats . distributions import norm , lognorm , rv_frozen [EOL] [EOL] [EOL] class BrownianMotion : [EOL] [docstring] [EOL] def __init__ ( self , mu = [number] , sigma = [number] ) : [EOL] self . mu = mu [EOL] self . sigma = sigma [EOL] [EOL] def simulate ( self , t , n , rnd ) : [EOL] assert t . ndim == [number] , [string] [EOL] assert t . size > [number] , [string] [EOL] dt = np . concatenate ( ( t [ [number] : [number] ] , np . diff ( t ) ) ) [EOL] assert ( dt >= [number] ) . all ( ) , [string] [EOL] [comment] [EOL] W = rnd . normal ( size = ( n , t . size ) ) [EOL] W_drift = ( W * np . sqrt ( dt ) * self . sigma + self . mu * dt ) . T [EOL] return np . cumsum ( W_drift , axis = [number] ) [EOL] [EOL] def distribution ( self , t ) : [EOL] return norm ( self . mu * t , self . sigma * np . sqrt ( t ) ) [EOL] [EOL] [EOL] class GeometricBrownianMotion : [EOL] [docstring] [EOL] def __init__ ( self , mu = [number] , sigma = [number] ) : [EOL] self . mu = mu [EOL] self . sigma = sigma [EOL] [EOL] def simulate ( self , t , n , rnd ) : [EOL] assert t . ndim == [number] , [string] [EOL] assert t . size > [number] , [string] [EOL] dt = np . concatenate ( ( t [ [number] : [number] ] , np . diff ( t ) ) ) [EOL] assert ( dt >= [number] ) . all ( ) , [string] [EOL] [comment] [EOL] dW = ( rnd . normal ( size = ( t . size , n ) ) . T * np . sqrt ( dt ) ) . T [EOL] W = np . cumsum ( dW , axis = [number] ) [EOL] return np . exp ( self . sigma * W . T + ( self . mu - self . sigma ** [number] / [number] ) * t ) . T [EOL] [EOL] def distribution ( self , t ) : [EOL] mu_t = ( self . mu - self . sigma ** [number] / [number] ) * t [EOL] sigma_t = self . sigma * np . sqrt ( t ) [EOL] return lognorm ( scale = np . exp ( mu_t ) , s = sigma_t ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $scipy.stats.distributions.rv_frozen$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] from numpy . polynomial import Polynomial [EOL] [EOL] [EOL] def longstaff_schwartz_iter ( X , t , df , fit , exercise_payoff , itm_select = None ) : [EOL] [comment] [EOL] cashflow = exercise_payoff ( X [ - [number] , : ] ) [EOL] [comment] [EOL] for i in reversed ( range ( [number] , X . shape [ [number] ] - [number] ) ) : [EOL] [comment] [EOL] cashflow = cashflow * df ( t [ i ] , t [ i + [number] ] ) [EOL] x = X [ i , : ] [EOL] [comment] [EOL] exercise = exercise_payoff ( x ) [EOL] [comment] [EOL] [comment] [EOL] itm = itm_select ( exercise , x ) \ [EOL] if itm_select \ [EOL] else np . full ( x . shape , True ) [EOL] [comment] [EOL] fitted = fit ( x [ itm ] , cashflow [ itm ] ) [EOL] [comment] [EOL] continuation = fitted ( x ) [EOL] [comment] [EOL] ex_idx = itm & ( exercise > continuation ) [EOL] [comment] [EOL] cashflow [ ex_idx ] = exercise [ ex_idx ] [EOL] [EOL] yield cashflow , x , fitted , continuation , exercise , ex_idx [EOL] [EOL] [EOL] def longstaff_schwartz ( X , t , df , fit , exercise_payoff , itm_select = None ) : [EOL] for cashflow , * _ in longstaff_schwartz_iter ( X , t , df , fit , exercise_payoff , itm_select ) : [EOL] pass [EOL] return cashflow . mean ( axis = [number] ) * df ( t [ [number] ] , t [ [number] ] ) [EOL] [EOL] [EOL] def ls_american_option_quadratic_iter ( X , t , r , strike ) : [EOL] [comment] [EOL] cashflow = np . maximum ( strike - X [ - [number] , : ] , [number] ) [EOL] [comment] [EOL] for i in reversed ( range ( [number] , X . shape [ [number] ] - [number] ) ) : [EOL] [comment] [EOL] df = np . exp ( - r * ( t [ i + [number] ] - t [ i ] ) ) [EOL] [comment] [EOL] cashflow = cashflow * df [EOL] x = X [ i , : ] [EOL] [comment] [EOL] exercise = np . maximum ( strike - x , [number] ) [EOL] [comment] [EOL] itm = exercise > [number] [EOL] [comment] [EOL] fitted = Polynomial . fit ( x [ itm ] , cashflow [ itm ] , [number] ) [EOL] [comment] [EOL] continuation = fitted ( x ) [EOL] [comment] [EOL] ex_idx = itm & ( exercise > continuation ) [EOL] [comment] [EOL] cashflow [ ex_idx ] = exercise [ ex_idx ] [EOL] [EOL] yield cashflow , x , fitted , continuation , exercise , ex_idx [EOL] [EOL] [EOL] def longstaff_schwartz_american_option_quadratic ( X , t , r , strike ) : [EOL] for cashflow , * _ in ls_american_option_quadratic_iter ( X , t , r , strike ) : [EOL] pass [EOL] return cashflow . mean ( axis = [number] ) * np . exp ( - r * ( t [ [number] ] - t [ [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import numpy as np [EOL] from numpy . polynomial import Polynomial [EOL] [EOL] [EOL] class BinomialModel : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , u , d , r , S0 , T , n ) : [EOL] self . u = u [EOL] self . d = d [EOL] self . r = r [EOL] self . S0 = S0 [EOL] self . T = T [EOL] self . n = n [EOL] self . ST = np . array ( list ( self . terminal ( ) ) , dtype = [string] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return type ( self ) . __name__ + [string] . format_map ( vars ( self ) ) [EOL] [EOL] @ property def dt ( self ) : [EOL] return self . T / self . n [EOL] [EOL] @ property def q ( self ) : [EOL] return ( np . exp ( self . r * self . dt ) - self . d ) / ( self . u - self . d ) [EOL] [EOL] def terminal ( self ) : [EOL] S0 , u , d , n = self . S0 , self . u , self . d , self . n [EOL] for ups in range ( n + [number] ) : [EOL] yield S0 * u ** ups * d ** ( n - ups ) [EOL] [EOL] def evaluate ( self , payoff ) : [EOL] v = payoff ( self . ST ) [EOL] q = self . q [EOL] while len ( v ) > [number] : [EOL] v = v [ [number] : ] * q + v [ : - [number] ] * ( [number] - q ) [EOL] return v [ [number] ] * np . exp ( - self . r * self . T ) [EOL] [EOL] def evaluate_american_exercisable_iter ( self , payoff ) : [EOL] df = np . exp ( - self . r * self . dt ) [EOL] continuation = payoff ( self . ST ) [EOL] spot = self . ST [EOL] q = self . q [EOL] while len ( continuation ) > [number] : [EOL] continuation = df * ( continuation [ [number] : ] * q + continuation [ : - [number] ] * ( [number] - q ) ) [EOL] spot = df * ( spot [ [number] : ] * q + spot [ : - [number] ] * ( [number] - q ) ) [EOL] exercise = payoff ( spot ) [EOL] optimal = np . maximum ( continuation , exercise ) [EOL] yield continuation , spot , exercise , optimal [EOL] continuation = optimal [EOL] [EOL] def evaluate_american_exercisable ( self , payoff ) : [EOL] for _ , _ , _ , opt in self . evaluate_american_exercisable_iter ( payoff ) : [EOL] pass [EOL] return opt [ [number] ] [EOL] [EOL] [EOL] def create_binomial_model ( sigma , r , S0 , T , n = [number] ) : [EOL] u = np . exp ( sigma * np . sqrt ( T / n ) ) [EOL] return BinomialModel ( u , [number] / u , r , S0 , T , n ) [EOL] [EOL] [EOL] def call_payoff ( strike ) : [EOL] return lambda S : np . maximum ( S - strike , [number] ) [EOL] [EOL] [EOL] def put_payoff ( strike ) : [EOL] return lambda S : np . maximum ( strike - S , [number] ) [EOL] [EOL] [EOL] def european_call_price ( mdl , strike ) : [EOL] return mdl . evaluate ( call_payoff ( strike ) ) [EOL] [EOL] [EOL] def american_call_price ( mdl , strike ) : [EOL] return mdl . evaluate_american_exercisable ( call_payoff ( strike ) ) [EOL] [EOL] [EOL] def european_put_price ( mdl , strike ) : [EOL] return mdl . evaluate ( put_payoff ( strike ) ) [EOL] [EOL] [EOL] def american_put_price ( mdl , strike ) : [EOL] return mdl . evaluate_american_exercisable ( put_payoff ( strike ) ) [EOL] [EOL] [EOL] def american_put_exercise_barrier ( mdl , strike ) : [EOL] exercises = [ ] [EOL] payoff = put_payoff ( strike ) [EOL] for cnt , s , ex , opt in mdl . evaluate_american_exercisable_iter ( payoff ) : [EOL] ex_idx = ( ex >= cnt ) & ( ex > [number] ) [EOL] ex_spots = s [ ex_idx ] [EOL] exercises . append ( ex_spots . max ( ) if ex_idx . any ( ) else np . nan ) [EOL] exercises . reverse ( ) [EOL] return np . array ( exercises ) [EOL] [EOL] [EOL] def american_put_exercise_barrier_fitted ( mdl , strike , degree = [number] ) : [EOL] barrier = american_put_exercise_barrier ( mdl , strike ) [EOL] t = np . linspace ( [number] , mdl . T , mdl . n ) [EOL] ex_exists = ~ np . isnan ( barrier ) [EOL] return Polynomial . fit ( t [ ex_exists ] , barrier [ ex_exists ] , degree ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] import sys [EOL] import click [EOL] [EOL] [EOL] @ click . command ( ) def main ( args = None ) : [EOL] [docstring] [EOL] click . echo ( [string] ) [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] from numpy . linalg import lstsq [EOL] [EOL] [EOL] class RegressionBasis : [EOL] def __init__ ( self , basis_functions ) : [EOL] self . basis_functions = basis_functions [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . join ( str ( f ) for f in self . basis_functions ) [EOL] [EOL] def apply ( self , x ) : [EOL] for f in self . basis_functions : [EOL] yield f ( x ) [EOL] [EOL] def __call__ ( self , x ) : [EOL] assert x . ndim == [number] [EOL] x = x . reshape ( ( x . shape [ [number] ] , [number] ) ) [EOL] return np . concatenate ( tuple ( self . apply ( x ) ) , axis = [number] ) [EOL] [EOL] def fit ( self , x , y ) : [EOL] beta , * _ = lstsq ( self ( x ) , y , rcond = None ) [EOL] return FittedFunction ( self , beta , ( x . min ( ) , x . max ( ) ) ) [EOL] [EOL] [EOL] class FittedFunction : [EOL] def __init__ ( self , basis , beta , domain ) : [EOL] self . basis = basis [EOL] self . beta = beta [EOL] self . domain = domain [EOL] [EOL] def __call__ ( self , x ) : [EOL] return self . basis ( x ) @ self . beta [EOL] [EOL] def linspace ( self , n = [number] , domain = None ) : [EOL] domain = domain or self . domain [EOL] x = np . linspace ( domain [ [number] ] , domain [ [number] ] , n ) [EOL] return x , self ( x ) [EOL] [EOL] [EOL] class PolynomialRegressionFunction : [EOL] def __init__ ( self , exponent ) : [EOL] self . exponent = exponent [EOL] [EOL] def __str__ ( self ) : [EOL] return f' [string] { self . exponent }' [EOL] [EOL] def __call__ ( self , x ) : [EOL] return x ** self . exponent [EOL] [EOL] [EOL] class PolynomialRegressionBasis ( RegressionBasis ) : [EOL] def __init__ ( self , degree ) : [EOL] super ( ) . __init__ ( [ PolynomialRegressionFunction ( i ) for i in range ( degree + [number] ) ] ) [EOL] self . degree = degree [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0