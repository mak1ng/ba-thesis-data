[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from typing import Dict , List , Tuple , Union [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] from setuptools import setup , find_packages [EOL] [EOL] [EOL] here = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] requirements = [ [string] , ] [EOL] [EOL] tests_require = ( [string] , [string] , [string] , ) [EOL] extras_require = { [string] : [ [string] ] , [string] : tests_require , } [EOL] [EOL] [EOL] def read ( fname ) : [EOL] [docstring] [EOL] return open ( os . path . join ( here , fname ) ) . read ( ) [EOL] [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = ( read ( [string] ) + [string] + read ( [string] ) ) , keywords = [string] , url = [string] , author = [string] , author_email = [string] , license = [string] , python_requires = [string] , classifiers = [ [string] , [string] , [string] , [string] [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , package_dir = { [string] : [string] } , packages = find_packages ( [string] ) , install_requires = requirements , tests_require = tests_require , test_suite = [string] , include_package_data = True , zip_safe = False , extras_require = extras_require , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]]]$ 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import signal [EOL] [EOL] [EOL] def block_signals ( ) : [EOL] [docstring] [EOL] def sighandler ( signum , _ ) : [EOL] [docstring] [EOL] print ( f' [string] { signum } [string] ' ) [EOL] [EOL] for sgn in [ x for x in dir ( signal ) if x . startswith ( [string] ) ] : [EOL] try : [EOL] signum = getattr ( signal , sgn ) [EOL] signal . signal ( signum , sighandler ) [EOL] except ( ValueError , RuntimeError , OSError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import socket [EOL] [docstring] [EOL] [EOL] import socket [EOL] import sys [EOL] import os [EOL] from time import sleep [EOL] [EOL] SOCKET_ADDRESS = [string] [EOL] [EOL] SLEEP = [number] [EOL] [EOL] if len ( sys . argv ) >= [number] : [EOL] SOCKET_ADDRESS = sys . argv [ [number] ] [EOL] [EOL] if len ( sys . argv ) >= [number] : [EOL] SLEEP = int ( sys . argv [ [number] ] ) [EOL] [EOL] [comment] [EOL] try : [EOL] os . unlink ( SOCKET_ADDRESS ) [EOL] except OSError : [EOL] if os . path . exists ( SOCKET_ADDRESS ) : [EOL] raise [EOL] [EOL] [comment] [EOL] SOCK = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM ) [EOL] [EOL] [comment] [EOL] print ( f' [string] { SOCKET_ADDRESS }' ) [EOL] SOCK . bind ( SOCKET_ADDRESS ) [EOL] sleep ( SLEEP ) [EOL] [EOL] [comment] [EOL] SOCK . listen ( [number] ) [EOL] [EOL] while True : [EOL] [comment] [EOL] print ( [string] ) [EOL] CONNECTION , CLIENT_ADDRESS = SOCK . accept ( ) [EOL] try : [EOL] print ( [string] , CLIENT_ADDRESS ) [EOL] [EOL] [comment] [EOL] while True : [EOL] RECEIVED_DATA = CONNECTION . recv ( [number] ) [EOL] print ( f' [string] { RECEIVED_DATA !r}' ) [EOL] if RECEIVED_DATA : [EOL] print ( [string] ) [EOL] CONNECTION . sendall ( RECEIVED_DATA ) [EOL] else : [EOL] print ( [string] , CLIENT_ADDRESS ) [EOL] break [EOL] [EOL] finally : [EOL] [comment] [EOL] CONNECTION . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $socket.socket$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import os [EOL] import sys [EOL] import time [EOL] [EOL] import daemon [EOL] [EOL] sys . path . append ( os . getcwd ( ) ) [comment] [EOL] [EOL] from tests . signals import block_signals [comment] [EOL] [EOL] [EOL] with daemon . DaemonContext ( initgroups = False ) : [EOL] block_signals ( ) [EOL] while True : [EOL] print ( [string] ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import sys [EOL] from os import path [EOL] from subprocess import check_output [EOL] [EOL] [EOL] TEST_PATH = path . abspath ( path . dirname ( __file__ ) ) [EOL] [EOL] TEST_SERVER_PATH = path . join ( TEST_PATH , [string] ) [EOL] TEST_SOCKET_SERVER_PATH = path . join ( TEST_PATH , [string] ) [EOL] SAMPLE_DAEMON_PATH = path . join ( TEST_PATH , [string] ) [EOL] [EOL] HTTP_SERVER_CMD = f"{ sys . executable } [string] " [EOL] [EOL] [EOL] def ps_aux ( ) : [EOL] [docstring] [EOL] return str ( check_output ( ( [string] , [string] , [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Type , List [EOL] import http [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import ast [EOL] import sys [EOL] import os [EOL] import time [EOL] from http . server import HTTPServer , BaseHTTPRequestHandler [EOL] from urllib . parse import parse_qs [EOL] [EOL] sys . path . append ( os . getcwd ( ) ) [comment] [EOL] [EOL] [comment] [EOL] from tests . signals import block_signals [EOL] [comment] [EOL] [EOL] [EOL] class SlowServerHandler ( BaseHTTPRequestHandler ) : [EOL] [docstring] [EOL] [EOL] timeout = [number] [EOL] endtime = None [EOL] [EOL] def do_GET ( self ) : [comment] [EOL] [docstring] [EOL] self . send_response ( [number] ) [EOL] self . send_header ( [string] , [string] ) [EOL] self . end_headers ( ) [EOL] self . wfile . write ( [string] ) [EOL] [EOL] def do_HEAD ( self ) : [comment] [EOL] [docstring] [EOL] self . timeout_status ( ) [EOL] self . end_headers ( ) [EOL] [EOL] def timeout_status ( self ) : [EOL] [docstring] [EOL] if self . count_timeout ( ) : [EOL] self . send_response ( [number] ) [EOL] else : [EOL] self . send_response ( [number] ) [EOL] [EOL] def count_timeout ( self ) : [comment] [EOL] [docstring] [EOL] if SlowServerHandler . endtime is None : [EOL] SlowServerHandler . endtime = time . time ( ) + SlowServerHandler . timeout [EOL] return time . time ( ) >= SlowServerHandler . endtime [EOL] [EOL] [EOL] class SlowGetServerHandler ( SlowServerHandler ) : [EOL] [docstring] [EOL] [EOL] def do_GET ( self ) : [comment] [EOL] [docstring] [EOL] self . timeout_status ( ) [EOL] self . send_header ( [string] , [string] ) [EOL] self . end_headers ( ) [EOL] self . wfile . write ( [string] ) [EOL] [EOL] def do_HEAD ( self ) : [comment] [EOL] [docstring] [EOL] self . send_response ( [number] ) [EOL] self . end_headers ( ) [EOL] [EOL] [EOL] class SlowPostServerHandler ( SlowServerHandler ) : [EOL] [docstring] [EOL] [EOL] def do_POST ( self ) : [comment] [EOL] [docstring] [EOL] self . timeout_status ( ) [EOL] self . end_headers ( ) [EOL] self . wfile . write ( [string] ) [EOL] [EOL] def do_HEAD ( self ) : [comment] [EOL] [docstring] [EOL] self . send_response ( [number] ) [EOL] self . end_headers ( ) [EOL] [EOL] [EOL] class SlowPostKeyServerHandler ( SlowServerHandler ) : [EOL] [docstring] [EOL] [EOL] def do_POST ( self ) : [comment] [EOL] [docstring] [EOL] content_len = int ( self . headers . get ( [string] ) ) [EOL] post_body = self . rfile . read ( content_len ) [EOL] form = parse_qs ( post_body ) [EOL] if form . get ( [string] ) == [ [string] ] : [EOL] self . timeout_status ( ) [EOL] else : [EOL] self . send_response ( [number] ) [EOL] self . end_headers ( ) [EOL] self . wfile . write ( [string] ) [EOL] [EOL] def do_HEAD ( self ) : [comment] [EOL] [docstring] [EOL] self . send_response ( [number] ) [EOL] self . end_headers ( ) [EOL] [EOL] [EOL] HANDLERS = { [string] : SlowServerHandler , [string] : SlowGetServerHandler , [string] : SlowPostServerHandler , [string] : SlowPostKeyServerHandler , } [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] HOST , PORT , IMMORTAL , METHOD = [string] , [string] , [string] , [string] [EOL] if len ( sys . argv ) >= [number] : [EOL] HOST , PORT = sys . argv [ [number] ] . split ( [string] ) [EOL] [EOL] if len ( sys . argv ) >= [number] : [EOL] IMMORTAL = sys . argv [ [number] ] [EOL] [EOL] if len ( sys . argv ) == [number] : [EOL] METHOD = sys . argv [ [number] ] [EOL] [EOL] if ast . literal_eval ( IMMORTAL ) : [EOL] block_signals ( ) [EOL] [EOL] server = HTTPServer ( ( HOST , int ( PORT ) ) , HANDLERS [ METHOD ] ) [EOL] print ( f" [string] { HOST } [string] { PORT } [string] " ) [EOL] server . serve_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Dict[builtins.bytes,typing.List[builtins.bytes]]$ 0 0 0 $builtins.bytes$ 0 0 0 $typing.Dict[builtins.bytes,typing.List[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import subprocess [EOL] [EOL] import pytest [EOL] [EOL] from mirakuru import OutputExecutor [EOL] from mirakuru . exceptions import TimeoutExpired [EOL] [EOL] [EOL] def test_executor_waits_for_process_output ( ) : [EOL] [docstring] [EOL] command = [string] [EOL] executor = OutputExecutor ( command , [string] , timeout = [number] ) . start ( ) [EOL] [EOL] assert executor . running ( ) is True [EOL] [comment] [EOL] assert executor . output ( ) . readline ( ) == [string] [EOL] executor . stop ( ) [EOL] [EOL] [comment] [EOL] assert [string] in repr ( executor ) [EOL] assert [string] in str ( executor ) [EOL] [EOL] [EOL] def test_executor_waits_for_process_err_output ( ) : [EOL] [docstring] [EOL] command = [string] [EOL] executor = OutputExecutor ( command , [string] , timeout = [number] , stdin = None , stderr = subprocess . PIPE ) . start ( ) [EOL] [EOL] assert executor . running ( ) is True [EOL] [comment] [EOL] assert executor . err_output ( ) . readline ( ) == [string] [EOL] executor . stop ( ) [EOL] [EOL] [comment] [EOL] assert [string] in repr ( executor ) [EOL] assert [string] in str ( executor ) [EOL] [EOL] [EOL] def test_executor_dont_start ( ) : [EOL] [docstring] [EOL] command = [string] [EOL] executor = OutputExecutor ( command , [string] , timeout = [number] ) [EOL] with pytest . raises ( TimeoutExpired ) : [EOL] executor . start ( ) [EOL] [EOL] assert executor . running ( ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] [EOL] import pytest [EOL] [EOL] from mirakuru import PidExecutor [EOL] from mirakuru import TimeoutExpired , AlreadyRunning [EOL] [EOL] [EOL] FILENAME = f" [string] { os . getpid ( ) }" [EOL] SLEEP = f' [string] { FILENAME } [string] ' [EOL] [EOL] [EOL] @ pytest . yield_fixture ( autouse = True ) def run_around_tests ( ) : [EOL] [docstring] [EOL] try : [EOL] os . remove ( FILENAME ) [EOL] except OSError : [EOL] pass [EOL] [EOL] yield [EOL] [EOL] try : [EOL] os . remove ( FILENAME ) [EOL] except OSError : [EOL] pass [EOL] [EOL] [EOL] def test_start_and_wait ( ) : [EOL] [docstring] [EOL] process = f' [string] { FILENAME } [string] ' [EOL] with PidExecutor ( process , FILENAME , timeout = [number] ) as executor : [EOL] assert executor . running ( ) is True [EOL] [EOL] [comment] [EOL] assert [string] in repr ( executor ) [EOL] assert process in str ( executor ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( None , [string] ) ) def test_empty_filename ( pid_file ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] PidExecutor ( SLEEP , pid_file ) [EOL] [EOL] [EOL] def test_if_file_created ( ) : [EOL] [docstring] [EOL] assert os . path . isfile ( FILENAME ) is False [EOL] executor = PidExecutor ( SLEEP , FILENAME ) [EOL] with executor : [EOL] assert os . path . isfile ( FILENAME ) is True [EOL] [EOL] [EOL] def test_timeout_error ( ) : [EOL] [docstring] [EOL] executor = PidExecutor ( SLEEP , FILENAME , timeout = [number] ) [EOL] [EOL] with pytest . raises ( TimeoutExpired ) : [EOL] executor . start ( ) [EOL] [EOL] assert executor . running ( ) is False [EOL] [EOL] [EOL] def test_fail_if_other_executor_running ( ) : [EOL] [docstring] [EOL] process = f' [string] { FILENAME } [string] ' [EOL] executor = PidExecutor ( process , FILENAME ) [EOL] executor2 = PidExecutor ( process , FILENAME ) [EOL] [EOL] with executor : [EOL] [EOL] assert executor . running ( ) is True [EOL] [EOL] with pytest . raises ( AlreadyRunning ) : [EOL] executor2 . start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import signal [EOL] import time [EOL] import sys [EOL] [EOL] import errno [EOL] [EOL] import os [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] from mirakuru import SimpleExecutor , HTTPExecutor [EOL] from mirakuru . compat import SIGKILL [EOL] from mirakuru . exceptions import ProcessFinishedWithError [EOL] [EOL] from tests import SAMPLE_DAEMON_PATH , ps_aux , TEST_SERVER_PATH [EOL] [EOL] SLEEP_300 = [string] [EOL] [EOL] [EOL] def test_custom_signal_kill ( ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( SLEEP_300 , sig_kill = signal . SIGQUIT ) [EOL] executor . start ( ) [EOL] assert executor . running ( ) is True [EOL] executor . kill ( ) [EOL] assert executor . running ( ) is False [EOL] [EOL] [EOL] def test_kill_custom_signal_kill ( ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( SLEEP_300 ) [EOL] executor . start ( ) [EOL] assert executor . running ( ) is True [EOL] executor . kill ( sig = signal . SIGQUIT ) [EOL] assert executor . running ( ) is False [EOL] [EOL] [EOL] def test_already_closed ( ) : [EOL] [docstring] [EOL] with pytest . raises ( ProcessFinishedWithError ) as excinfo : [EOL] with SimpleExecutor ( [string] ) as executor : [EOL] assert executor . running ( ) [EOL] os . killpg ( executor . process . pid , SIGKILL ) [EOL] [EOL] def process_stopped ( ) : [EOL] [docstring] [EOL] return executor . running ( ) is False [EOL] executor . wait_for ( process_stopped ) [EOL] assert executor . process [EOL] assert excinfo . value . exit_code == - [number] [EOL] assert not executor . process [EOL] [EOL] [EOL] def test_daemons_killing ( ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( ( [string] , SAMPLE_DAEMON_PATH ) , shell = True ) [EOL] executor . start ( ) [EOL] time . sleep ( [number] ) [EOL] assert executor . running ( ) is not True , [string] [EOL] [EOL] assert SAMPLE_DAEMON_PATH in ps_aux ( ) [EOL] executor . kill ( ) [EOL] assert SAMPLE_DAEMON_PATH not in ps_aux ( ) [EOL] [EOL] [EOL] def test_stopping_brutally ( ) : [EOL] [docstring] [EOL] host_port = [string] [EOL] cmd = f'{ sys . executable } [string] { TEST_SERVER_PATH } [string] { host_port } [string] ' [EOL] executor = HTTPExecutor ( cmd , f' [string] { host_port !s} [string] ' , timeout = [number] ) [EOL] executor . start ( ) [EOL] assert executor . running ( ) is True [EOL] [EOL] stop_at = time . time ( ) + [number] [EOL] executor . stop ( ) [EOL] assert executor . running ( ) is False [EOL] assert stop_at <= time . time ( ) , [string] [EOL] [EOL] [EOL] def test_stopping_children_of_stopped_process ( ) : [EOL] [docstring] [EOL] [comment] [EOL] def raise_os_error ( * _ , ** __ ) : [EOL] [EOL] os_error = OSError ( ) [EOL] os_error . errno = errno . ESRCH [EOL] raise os_error [EOL] [EOL] def processes_with_env_mock ( * _ , ** __ ) : [EOL] return [ [number] ] [EOL] [EOL] with patch ( [string] , new = processes_with_env_mock ) , patch ( [string] , new = raise_os_error ) : [EOL] executor = SimpleExecutor ( SLEEP_300 ) [EOL] executor . _kill_all_kids ( executor . _sig_stop ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] from mirakuru import TCPExecutor [EOL] from mirakuru import TimeoutExpired , AlreadyRunning [EOL] [EOL] from tests import HTTP_SERVER_CMD [EOL] [EOL] [EOL] PORT = [number] [EOL] [EOL] HTTP_SERVER = f'{ HTTP_SERVER_CMD } [string] { PORT }' [EOL] [EOL] [EOL] def test_start_and_wait ( ) : [EOL] [docstring] [EOL] command = [string] [EOL] executor = TCPExecutor ( command , [string] , port = [number] , timeout = [number] ) [EOL] executor . start ( ) [EOL] [EOL] assert executor . running ( ) is True [EOL] executor . stop ( ) [EOL] [EOL] [comment] [EOL] assert [string] in repr ( executor ) [EOL] assert command in str ( executor ) [EOL] [EOL] [EOL] def test_it_raises_error_on_timeout ( ) : [EOL] [docstring] [EOL] command = [string] [EOL] executor = TCPExecutor ( command , host = [string] , port = [number] , timeout = [number] ) [EOL] [EOL] with pytest . raises ( TimeoutExpired ) : [EOL] executor . start ( ) [EOL] [EOL] assert executor . running ( ) is False [EOL] [EOL] [EOL] def test_fail_if_other_executor_running ( ) : [EOL] [docstring] [EOL] executor = TCPExecutor ( HTTP_SERVER , host = [string] , port = PORT ) [EOL] executor2 = TCPExecutor ( HTTP_SERVER , host = [string] , port = PORT ) [EOL] [EOL] with executor : [EOL] [EOL] assert executor . running ( ) is True [EOL] [EOL] with pytest . raises ( AlreadyRunning ) : [EOL] executor2 . start ( ) [EOL] [EOL] with pytest . raises ( AlreadyRunning ) : [EOL] with executor2 : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import gc [EOL] import shlex [EOL] import signal [EOL] from subprocess import check_output [EOL] import uuid [EOL] from unittest import mock [EOL] [EOL] import pytest [EOL] [EOL] from mirakuru import Executor [EOL] from mirakuru . base import SimpleExecutor [EOL] from mirakuru . exceptions import ProcessExitedWithError , TimeoutExpired [EOL] [EOL] from tests import SAMPLE_DAEMON_PATH , ps_aux [EOL] [EOL] SLEEP_300 = [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( SLEEP_300 , SLEEP_300 . split ( ) ) ) def test_running_process ( command ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( command ) [EOL] executor . start ( ) [EOL] assert executor . running ( ) is True [EOL] executor . stop ( ) [EOL] assert executor . running ( ) is False [EOL] [EOL] [comment] [EOL] assert [string] in repr ( executor ) [EOL] assert SLEEP_300 in str ( executor ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( SLEEP_300 , SLEEP_300 . split ( ) ) ) def test_command ( command ) : [EOL] [docstring] [EOL] [EOL] executor = SimpleExecutor ( command ) [EOL] assert executor . command == SLEEP_300 [EOL] assert executor . command_parts == SLEEP_300 . split ( ) [EOL] [EOL] [EOL] def test_custom_signal_stop ( ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( SLEEP_300 , sig_stop = signal . SIGQUIT ) [EOL] executor . start ( ) [EOL] assert executor . running ( ) is True [EOL] executor . stop ( ) [EOL] assert executor . running ( ) is False [EOL] [EOL] [EOL] def test_stop_custom_signal_stop ( ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( SLEEP_300 ) [EOL] executor . start ( ) [EOL] assert executor . running ( ) is True [EOL] executor . stop ( sig = signal . SIGQUIT ) [EOL] assert executor . running ( ) is False [EOL] [EOL] [EOL] def test_stop_custom_exit_signal_stop ( ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( [string] , shell = True ) [EOL] executor . start ( ) [EOL] [comment] [EOL] executor . stop ( sig = signal . SIGQUIT , exp_sig = [number] ) [EOL] assert executor . running ( ) is False [EOL] [EOL] [EOL] def test_stop_custom_exit_signal_context ( ) : [EOL] [docstring] [EOL] with SimpleExecutor ( [string] , exp_sig = [number] , shell = True ) as executor : [EOL] executor . stop ( sig = signal . SIGQUIT ) [EOL] assert executor . running ( ) is False [EOL] [EOL] [EOL] def test_running_context ( ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( SLEEP_300 ) [EOL] with executor : [EOL] assert executor . running ( ) is True [EOL] [EOL] assert executor . running ( ) is False [EOL] [EOL] [EOL] def test_executor_in_context_only ( ) : [EOL] [docstring] [EOL] with SimpleExecutor ( SLEEP_300 ) as executor : [EOL] assert executor . running ( ) is True [EOL] [EOL] [EOL] def test_context_stopped ( ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( SLEEP_300 ) [EOL] with executor : [EOL] assert executor . running ( ) is True [EOL] with executor . stopped ( ) : [EOL] assert executor . running ( ) is False [EOL] assert executor . running ( ) is True [EOL] [EOL] assert executor . running ( ) is False [EOL] [EOL] [EOL] ECHO_FOOBAR = [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ECHO_FOOBAR , shlex . split ( ECHO_FOOBAR ) ) ) def test_process_output ( command ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( command ) [EOL] executor . start ( ) [EOL] [EOL] assert executor . output ( ) . read ( ) == [string] [EOL] executor . stop ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ECHO_FOOBAR , shlex . split ( ECHO_FOOBAR ) ) ) def test_process_output_shell ( command ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( command , shell = True ) [EOL] executor . start ( ) [EOL] [EOL] assert executor . output ( ) . read ( ) . strip ( ) == [string] [EOL] executor . stop ( ) [EOL] [EOL] [EOL] def test_start_check_executor ( ) : [EOL] [docstring] [EOL] executor = Executor ( SLEEP_300 ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] executor . pre_start_check ( ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] executor . after_start_check ( ) [EOL] [EOL] [EOL] def test_stopping_not_yet_running_executor ( ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( SLEEP_300 ) [EOL] executor . stop ( ) [EOL] executor . start ( ) [EOL] assert executor . running ( ) is True [EOL] executor . stop ( ) [EOL] [EOL] [EOL] def test_forgotten_stop ( ) : [EOL] [docstring] [EOL] mark = str ( uuid . uuid1 ( ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] marked_command = f' [string] { mark !s}' [EOL] executor = SimpleExecutor ( marked_command , shell = True ) [EOL] executor . start ( ) [EOL] assert executor . running ( ) is True [EOL] assert mark in ps_aux ( ) , [string] [EOL] del executor [EOL] gc . collect ( ) [comment] [EOL] assert mark not in ps_aux ( ) , [string] [EOL] [EOL] [EOL] def test_executor_raises_if_process_exits_with_error ( ) : [EOL] [docstring] [EOL] error_code = [number] [EOL] failing_executor = Executor ( [ [string] , [string] , f' [string] { error_code !s}' ] , timeout = [number] ) [EOL] failing_executor . pre_start_check = mock . Mock ( return_value = False ) [EOL] [comment] [EOL] failing_executor . after_start_check = mock . Mock ( return_value = False ) [EOL] [EOL] with pytest . raises ( ProcessExitedWithError ) as exc : [EOL] failing_executor . start ( ) [EOL] [EOL] assert exc . value . exit_code == [number] [EOL] error_msg = f' [string] { error_code !s}' [EOL] assert error_msg in str ( exc . value ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert failing_executor . pre_start_check . called is True [comment] [EOL] [EOL] [EOL] def test_executor_ignores_processes_exiting_with_0 ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] executor = Executor ( [ [string] , [string] , [string] ] , timeout = [number] ) [EOL] executor . pre_start_check = mock . Mock ( return_value = False ) [comment] [EOL] executor . after_start_check = mock . Mock ( return_value = False ) [comment] [EOL] [EOL] with pytest . raises ( TimeoutExpired ) : [EOL] [comment] [EOL] executor . start ( ) [EOL] [EOL] [comment] [EOL] assert executor . pre_start_check . called is True [comment] [EOL] assert executor . after_start_check . called is True [comment] [EOL] [EOL] [EOL] def test_executor_methods_returning_self ( ) : [EOL] [docstring] [EOL] executor = SimpleExecutor ( SLEEP_300 ) . start ( ) . stop ( ) . kill ( ) . stop ( ) [EOL] assert not executor . running ( ) [EOL] [EOL] [comment] [EOL] with SimpleExecutor ( SLEEP_300 ) as executor : [EOL] assert executor . running ( ) [EOL] [EOL] with SimpleExecutor ( SLEEP_300 ) . start ( ) . stopped ( ) as executor : [EOL] assert not executor . running ( ) [EOL] [EOL] assert SimpleExecutor ( SLEEP_300 ) . start ( ) . stop ( ) . output [EOL] [EOL] [EOL] def test_mirakuru_cleanup ( ) : [EOL] [docstring] [EOL] cmd = f''' [string] { SAMPLE_DAEMON_PATH } [string] ''' [EOL] check_output ( shlex . split ( cmd . replace ( [string] , [string] ) ) ) [EOL] assert SAMPLE_DAEMON_PATH not in ps_aux ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import http [EOL] import functools [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import sys [EOL] import socket [EOL] from functools import partial [EOL] from http . client import HTTPConnection , OK [EOL] from typing import Dict , Any [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] from mirakuru import HTTPExecutor , TCPExecutor [EOL] from mirakuru import TimeoutExpired , AlreadyRunning [EOL] from tests import TEST_SERVER_PATH , HTTP_SERVER_CMD [EOL] [EOL] HOST = [string] [EOL] PORT = [number] [EOL] [EOL] HTTP_NORMAL_CMD = f'{ HTTP_SERVER_CMD } [string] { PORT }' [EOL] HTTP_SLOW_CMD = f'{ sys . executable } [string] { TEST_SERVER_PATH } [string] { HOST } [string] { PORT }' [EOL] [EOL] [EOL] slow_server_executor = partial ( HTTPExecutor , HTTP_SLOW_CMD , f' [string] { HOST } [string] { PORT } [string] ' , ) [EOL] [EOL] [EOL] def connect_to_server ( ) : [EOL] [docstring] [EOL] conn = HTTPConnection ( HOST , PORT ) [EOL] conn . request ( [string] , [string] ) [EOL] assert conn . getresponse ( ) . status == OK [EOL] conn . close ( ) [EOL] [EOL] [EOL] def test_executor_starts_and_waits ( ) : [EOL] [docstring] [EOL] command = f' [string] { HTTP_NORMAL_CMD } [string] ' [EOL] [EOL] executor = HTTPExecutor ( command , f' [string] { HOST } [string] { PORT } [string] ' , timeout = [number] ) [EOL] executor . start ( ) [EOL] assert executor . running ( ) is True [EOL] [EOL] connect_to_server ( ) [EOL] [EOL] executor . stop ( ) [EOL] [EOL] [comment] [EOL] assert [string] in repr ( executor ) [EOL] assert command in str ( executor ) [EOL] [EOL] [EOL] def test_shell_started_server_stops ( ) : [EOL] [docstring] [EOL] executor = HTTPExecutor ( HTTP_NORMAL_CMD , f' [string] { HOST } [string] { PORT } [string] ' , timeout = [number] , shell = True ) [EOL] [EOL] with pytest . raises ( socket . error ) : [EOL] connect_to_server ( ) [EOL] [EOL] with executor : [EOL] assert executor . running ( ) is True [EOL] connect_to_server ( ) [EOL] [EOL] assert executor . running ( ) is False [EOL] [EOL] with pytest . raises ( socket . error ) : [EOL] connect_to_server ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) def test_slow_method_server_starting ( method ) : [EOL] [docstring] [EOL] [EOL] http_method_slow_cmd = ( f'{ sys . executable } [string] { TEST_SERVER_PATH } [string] { HOST } [string] { PORT } [string] { method }' ) [EOL] with HTTPExecutor ( http_method_slow_cmd , f' [string] { HOST } [string] { PORT } [string] ' , method = method , timeout = [number] ) as executor : [EOL] assert executor . running ( ) is True [EOL] connect_to_server ( ) [EOL] [EOL] [EOL] def test_slow_post_payload_server_starting ( ) : [EOL] [docstring] [EOL] [EOL] http_method_slow_cmd = ( f'{ sys . executable } [string] { TEST_SERVER_PATH } [string] { HOST } [string] { PORT } [string] ' ) [EOL] with HTTPExecutor ( http_method_slow_cmd , f' [string] { HOST } [string] { PORT } [string] ' , method = [string] , timeout = [number] , payload = { [string] : [string] } ) as executor : [EOL] assert executor . running ( ) is True [EOL] connect_to_server ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) def test_slow_method_server_timed_out ( method ) : [EOL] [docstring] [EOL] [EOL] http_method_slow_cmd = ( f'{ sys . executable } [string] { TEST_SERVER_PATH } [string] { HOST } [string] { PORT } [string] { method }' ) [EOL] executor = HTTPExecutor ( http_method_slow_cmd , f' [string] { HOST } [string] { PORT } [string] ' , method = method , timeout = [number] ) [EOL] [EOL] with pytest . raises ( TimeoutExpired ) as exc : [EOL] executor . start ( ) [EOL] [EOL] assert executor . running ( ) is False [EOL] assert [string] in str ( exc . value ) [EOL] [EOL] [EOL] def test_fail_if_other_running ( ) : [EOL] [docstring] [EOL] executor = HTTPExecutor ( HTTP_NORMAL_CMD , f' [string] { HOST } [string] { PORT } [string] ' , ) [EOL] executor2 = HTTPExecutor ( HTTP_NORMAL_CMD , f' [string] { HOST } [string] { PORT } [string] ' , ) [EOL] [EOL] with executor : [EOL] [EOL] assert executor . running ( ) is True [EOL] [EOL] with pytest . raises ( AlreadyRunning ) : [EOL] executor2 . start ( ) [EOL] [EOL] with pytest . raises ( AlreadyRunning ) as exc : [EOL] with executor2 : [EOL] pass [EOL] assert [string] in str ( exc . value ) [EOL] [EOL] [EOL] @ patch . object ( HTTPExecutor , [string] , PORT ) def test_default_port ( ) : [EOL] [docstring] [EOL] executor = HTTPExecutor ( HTTP_NORMAL_CMD , f' [string] { HOST } [string] ' ) [EOL] [EOL] assert executor . url . port is None [EOL] assert executor . port == PORT [EOL] [EOL] assert TCPExecutor . pre_start_check ( executor ) is False [EOL] executor . start ( ) [EOL] assert TCPExecutor . pre_start_check ( executor ) is True [EOL] executor . stop ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( None , True ) , ( [number] , True ) , ( [string] , False ) , ( [string] , False ) , ( [string] , False ) , ) ) def test_http_status_codes ( accepted_status , expected_timeout ) : [EOL] [docstring] [EOL] kwargs = { [string] : HTTP_NORMAL_CMD , [string] : f' [string] { HOST } [string] { PORT } [string] ' , [string] : [number] } [EOL] if accepted_status : [EOL] kwargs [ [string] ] = accepted_status [EOL] executor = HTTPExecutor ( ** kwargs ) [EOL] [EOL] if not expected_timeout : [EOL] executor . start ( ) [EOL] executor . stop ( ) [EOL] else : [EOL] with pytest . raises ( TimeoutExpired ) : [EOL] executor . start ( ) [EOL] executor . stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import sys [EOL] [EOL] import pytest [EOL] [EOL] from mirakuru import TimeoutExpired [EOL] from mirakuru . unixsocket import UnixSocketExecutor [EOL] from tests import TEST_SOCKET_SERVER_PATH [EOL] [EOL] SOCKET_PATH = [string] [EOL] [EOL] SOCKET_SERVER_CMD = f"{ sys . executable } [string] { TEST_SOCKET_SERVER_PATH } [string] { SOCKET_PATH }" [EOL] [EOL] [EOL] def test_start_and_wait ( ) : [EOL] [docstring] [EOL] executor = UnixSocketExecutor ( SOCKET_SERVER_CMD + [string] , socket_name = SOCKET_PATH , timeout = [number] ) [EOL] with executor : [EOL] assert executor . running ( ) is True [EOL] [EOL] [EOL] def test_start_and_timeout ( ) : [EOL] [docstring] [EOL] executor = UnixSocketExecutor ( SOCKET_SERVER_CMD + [string] , socket_name = SOCKET_PATH , timeout = [number] ) [EOL] [EOL] with pytest . raises ( TimeoutExpired ) : [EOL] executor . start ( ) [EOL] [EOL] assert executor . running ( ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Tuple , Any [EOL] import typing [EOL] import sys [EOL] import os [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = [string] [EOL] basename = [string] . join ( project . split ( [string] ) ) [EOL] author = [string] [EOL] copyright = [string] + author [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from mirakuru import __version__ [EOL] [EOL] [comment] [EOL] release = __version__ [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = basename + [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( [string] , basename + [string] , project + [string] , author , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( [string] , basename , project + [string] , [ author ] , [number] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( [string] , basename , project + [string] , author , basename , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_title = project [EOL] epub_author = author [EOL] epub_publisher = author [EOL] epub_copyright = [string] + author [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] autoclass_content = [string] [EOL] autodoc_default_flags = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] intersphinx_mapping = { [string] : ( [string] , None ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0