import os [EOL] from setuptools import setup [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . normpath ( os . path . join ( os . path . abspath ( __file__ ) , os . pardir ) ) ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = [string] , long_description_content_type = [string] , url = [string] , author = [string] , author_email = [string] , license = [string] , include_package_data = True , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] ] , keywords = [string] , packages = [ [string] , [string] , [string] , [string] ] , scripts = [ [string] , [string] ] , install_requires = [ [string] ] , dependency_links = [ ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
import builtins [EOL] from typing import List [EOL] import typing [EOL] import logging [EOL] from typing import List [EOL] from logging import LoggerAdapter , Logger [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class TaggedLogger ( LoggerAdapter ) : [EOL] tags = ... [EOL] [EOL] def __init__ ( self , logger , * args ) : [EOL] self . tags = [ str ( a ) for a in args ] [EOL] super ( ) . __init__ ( logger , None ) [EOL] [EOL] def process ( self , msg , kwargs ) : [EOL] [docstring] [EOL] if [string] not in kwargs : [EOL] kwargs [ [string] ] = { } [EOL] if [string] not in kwargs [ [string] ] : [EOL] kwargs [ [string] ] [ [string] ] = set ( ) [EOL] if isinstance ( kwargs [ [string] ] [ [string] ] , list ) : [EOL] kwargs [ [string] ] [ [string] ] = set ( kwargs [ [string] ] [ [string] ] ) [EOL] kwargs [ [string] ] [ [string] ] . update ( self . tags ) [EOL] return msg , kwargs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Dict , Any , List [EOL] import logging [EOL] import sync_models [EOL] import typing [EOL] import builtins [EOL] from typing import List , Any , Optional , Dict , Tuple [EOL] import socket [EOL] [EOL] from datetime import datetime [EOL] from logging import Handler , Logger , NOTSET , LogRecord [EOL] [EOL] import psycopg2 [EOL] from psycopg2 . extras import DictCursor [EOL] [EOL] from . sync_models import LogLogger , LogSource , LogHost , LogFunction , LogTag , LogEntry [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class DBLogHandler ( Handler ) : [EOL] [EOL] [comment] [EOL] db_config = None [EOL] [EOL] [comment] [EOL] src_cache = { } [EOL] func_cache = { } [EOL] logger_cache = { } [EOL] host_cache = { } [EOL] tag_cache = { } [EOL] [EOL] [comment] [EOL] logger_name = ... [EOL] [EOL] def __init__ ( self , name , db_name = None , db = None , db_user = None , db_password = None , db_host = [string] , db_port = [number] , level = NOTSET ) : [EOL] [docstring] [EOL] [EOL] if db is not None : [EOL] self . db = db [EOL] self . db_config = None [EOL] else : [EOL] if db_user is not None : [EOL] if db_password is not None : [EOL] self . db_config = f' [string] { db_user } [string] { db_password } [string] { db_host } [string] { db_port } [string] { db_name }' [EOL] else : [EOL] self . db_config = f' [string] { db_user } [string] { db_host } [string] { db_port } [string] { db_name }' [EOL] else : [EOL] self . db_config = f' [string] { db_host } [string] { db_port } [string] { db_name }' [EOL] self . db = psycopg2 . connect ( self . db_config , cursor_factory = DictCursor ) [EOL] [EOL] self . logger_name = name [EOL] self . createLock ( ) [EOL] super ( ) . __init__ ( level = level ) [EOL] [EOL] def emit ( self , record ) : [EOL] if self . db . closed and self . db_config is not None : [EOL] self . db = psycopg2 . connect ( self . db_config , cursor_factory = DictCursor ) [EOL] elif self . db . closed : [EOL] raise RuntimeWarning ( [string] ) [EOL] [EOL] cursor = self . db . cursor ( ) [EOL] [EOL] try : [EOL] src = self . src_cache . get ( record . pathname , None ) [EOL] if src is None : [EOL] src = LogSource . get_or_create ( cursor , path = record . pathname ) [EOL] self . src_cache [ record . pathname ] = src [EOL] [EOL] func_key = f'{ record . name } [string] { record . funcName } [string] { record . lineno } [string] { src . path }' [EOL] func = self . func_cache . get ( func_key , None ) [EOL] if func is None : [EOL] func = LogFunction . get_or_create ( cursor , name = f'{ record . name } [string] { record . funcName }' , line_number = record . lineno , source_id = src . pk , ) [EOL] self . func_cache [ func_key ] = func [EOL] [EOL] logger = self . logger_cache . get ( self . logger_name , None ) [EOL] if logger is None : [EOL] logger = LogLogger . get_or_create ( cursor , name = self . logger_name ) [EOL] self . logger_cache [ self . logger_name ] = logger [EOL] [EOL] host_key = socket . gethostname ( ) [EOL] host = self . host_cache . get ( host_key , None ) [EOL] if host is None : [EOL] host = LogHost . get_or_create ( cursor , name = host_key ) [EOL] self . host_cache [ host_key ] = host [EOL] [EOL] entry = LogEntry . create ( cursor , level = record . levelno , message = record . getMessage ( ) , pid = record . process , time = datetime . fromtimestamp ( record . created ) , function_id = func . pk , logger_id = logger . pk , hostname_id = host . pk ) [EOL] [EOL] tags_names = getattr ( record , [string] , set ( ) ) [EOL] tags = [ ] [EOL] for tag_name in tags_names : [EOL] if tag_name is None or tag_name == [string] : [EOL] continue [EOL] tag = self . tag_cache . get ( tag_name , None ) [EOL] if tag is None : [EOL] tag = LogTag . get_or_create ( cursor , name = tag_name ) [EOL] self . tag_cache [ tag_name ] = tag [EOL] [EOL] tags . append ( tag ) [EOL] [EOL] entry . add_tags ( cursor , tags ) [EOL] self . db . commit ( ) [EOL] [EOL] except Exception : [EOL] self . handleError ( record ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,sync_models.LogSource]$ 0 0 0 0 $typing.Dict[builtins.str,sync_models.LogFunction]$ 0 0 0 0 $typing.Dict[builtins.str,sync_models.LogLogger]$ 0 0 0 0 $typing.Dict[builtins.str,sync_models.LogHost]$ 0 0 0 0 $typing.Dict[builtins.str,sync_models.LogTag]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 $logging.LogRecord$ 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0
from dblogger . models . logger import BaseLogLogger [EOL] from . model import SyncModel [EOL] [EOL] [EOL] class LogLogger ( BaseLogLogger , SyncModel ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dblogger . models . source import BaseLogSource [EOL] from . model import SyncModel [EOL] [EOL] [EOL] class LogSource ( BaseLogSource , SyncModel ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dblogger . models . tag import BaseLogTag [EOL] from . model import SyncModel [EOL] [EOL] class LogTag ( BaseLogTag , SyncModel ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dblogger . models . host import BaseLogHost [EOL] from . model import SyncModel [EOL] [EOL] [EOL] class LogHost ( BaseLogHost , SyncModel ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import source [EOL] from typing import Any , Generator [EOL] [EOL] from dblogger . models . function import BaseLogFunction [EOL] from . model import SyncModel [EOL] from . source import LogSource [EOL] [EOL] [EOL] class LogFunction ( BaseLogFunction , SyncModel ) : [EOL] [EOL] def source ( self , db ) : [EOL] result = getattr ( self , [string] , LogSource . load ( db , pk = self . source_id ) ) [EOL] setattr ( self , [string] , result ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LogFunction.source.LogSource$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0
from typing import Optional , Tuple , Dict , Any , List , ValuesView [EOL] import typing [EOL] import builtins [EOL] from typing import List , Dict , Any , Tuple , Optional , ClassVar [EOL] [EOL] from dblogger . models . model import BaseModel [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SyncModel ( BaseModel ) : [EOL] [EOL] @ classmethod def make_where_statement ( cls , data , prefix = None ) : [EOL] where = [ ] [EOL] values = [ ] [EOL] for item in data . items ( ) : [EOL] key , value = item [EOL] key = key . replace ( [string] , [string] ) [EOL] if prefix is not None : [EOL] where . append ( f' [string] { prefix } [string] { key } [string] ' ) [EOL] else : [EOL] where . append ( f' [string] { key } [string] ' ) [EOL] values . append ( value ) [EOL] [EOL] where_clause = [string] . join ( where ) [EOL] return where_clause , values [EOL] [EOL] @ classmethod def load ( cls , db , ** kwargs ) : [EOL] pk = kwargs . pop ( [string] , None ) [EOL] ser = cls . serialize_data ( kwargs ) [EOL] if pk is not None : [EOL] ser [ [string] ] = pk [EOL] where_clause , values = SyncModel . make_where_statement ( ser ) [EOL] [EOL] db . execute ( f' [string] { cls . table } [string] { where_clause } [string] ' , values ) [EOL] data = db . fetchone ( ) [EOL] if data is None : [EOL] return None [EOL] return cls ( rowdata = data ) [EOL] [EOL] @ classmethod def load_all ( cls , db , ** kwargs ) : [EOL] ser = cls . serialize_data ( kwargs ) [EOL] where_clause , values = SyncModel . make_where_statement ( ser ) [EOL] [EOL] db . execute ( f' [string] { cls . table } [string] { where_clause } [string] ' , values ) [EOL] return [ cls ( rowdata = data ) for data in db . fetchall ( ) ] [EOL] [EOL] @ classmethod def create ( cls , db , ignore_conflicts = False , ** kwargs ) : [EOL] ser = cls . serialize_data ( kwargs ) [EOL] [EOL] value_list = [ f' [string] { v } [string] ' for v in ser . keys ( ) ] [EOL] values = ser . values ( ) [EOL] params = [string] . join ( [ f' [string] ' for _ in values ] ) [EOL] [EOL] sql = f''' [string] { cls . table } [string] { [string] . join ( value_list ) } [string] { params } [string] ''' [EOL] [EOL] if ignore_conflicts is True : [EOL] sql += [string] [EOL] [EOL] sql += [string] [EOL] db . execute ( sql , list ( values ) ) [EOL] data = db . fetchone ( ) [EOL] return cls ( rowdata = data ) [EOL] [EOL] @ classmethod def get_or_create ( cls , db , ** kwargs ) : [EOL] item = cls . load ( db , ** kwargs ) [EOL] if item is None : [EOL] item = cls . create ( db , ** kwargs ) [EOL] return item [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.List[typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.ValuesView[typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.ValuesView[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ValuesView[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.ValuesView[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0
from . function import BaseLogFunction [EOL] from . host import BaseLogHost [EOL] from . logger import BaseLogLogger [EOL] from . source import BaseLogSource [EOL] from . tag import BaseLogTag [EOL] from . entry import BaseLogEntry [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , Any [EOL] [EOL] from . model import BaseModel [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class BaseLogHost ( BaseModel ) : [EOL] table = [string] [EOL] [EOL] name = ... [EOL] [EOL] def deserialize ( self , rowdata ) : [EOL] self . name = rowdata . get ( [string] ) [EOL] [EOL] @ classmethod def serialize_data ( cls , data ) : [EOL] result = { } [EOL] [EOL] if [string] in data : [EOL] result [ [string] ] = data [ [string] ] [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0
from typing import Optional , ClassVar , Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] from typing import List , Dict , Any , Tuple , Optional , ClassVar [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class BaseModel : [EOL] table = [string] [EOL] [EOL] def __init__ ( self , rowdata = None , ** kwargs ) : [EOL] if rowdata is not None : [EOL] self . pk = rowdata . get ( [string] , None ) [EOL] self . deserialize ( rowdata ) [EOL] else : [EOL] self . deserialize ( kwargs ) [EOL] [EOL] def deserialize ( self , rowdata ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def serialize ( self ) : [EOL] return self . __class__ . serialize_data ( self . __dict__ ) [EOL] [EOL] @ classmethod def serialize_data ( cls , data ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , Any [EOL] [EOL] from . model import BaseModel [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class BaseLogFunction ( BaseModel ) : [EOL] table = [string] [EOL] [EOL] name = ... [EOL] line_number = ... [EOL] source_id = ... [EOL] [EOL] def deserialize ( self , rowdata ) : [EOL] self . name = rowdata . get ( [string] ) [EOL] self . line_number = rowdata . get ( [string] ) [EOL] self . source_id = rowdata . get ( [string] ) [EOL] [EOL] @ classmethod def serialize_data ( cls , data ) : [EOL] result = { } [EOL] [EOL] if [string] in data : [EOL] result [ [string] ] = data [ [string] ] [EOL] if [string] in data : [EOL] result [ [string] ] = data [ [string] ] [EOL] if [string] in data : [EOL] result [ [string] ] = data [ [string] ] [EOL] [EOL] return result [EOL] [EOL] @ property def source ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import asyncpg [EOL] import typing [EOL] import source [EOL] from typing import Any [EOL] from asyncpg import Connection [EOL] [EOL] from dblogger . models . function import BaseLogFunction [EOL] from . model import AsyncModel [EOL] from . source import LogSource [EOL] [EOL] [EOL] class LogFunction ( BaseLogFunction , AsyncModel ) : [EOL] [EOL] async def source ( self , db ) : [EOL] result = getattr ( self , [string] , await LogSource . load ( db , pk = self . source_id ) ) [EOL] setattr ( self , [string] , result ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dblogger . models . host import BaseLogHost [EOL] from . model import AsyncModel [EOL] [EOL] [EOL] class LogHost ( BaseLogHost , AsyncModel ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dblogger . models . logger import BaseLogLogger [EOL] from . model import AsyncModel [EOL] [EOL] [EOL] class LogLogger ( BaseLogLogger , AsyncModel ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dblogger . models . tag import BaseLogTag [EOL] from . model import AsyncModel [EOL] [EOL] class LogTag ( BaseLogTag , AsyncModel ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Tuple , Dict , Any , List , ValuesView [EOL] import asyncpg [EOL] import typing [EOL] import builtins [EOL] from typing import List , Dict , Any , Tuple , Optional , ClassVar [EOL] from asyncpg import Connection , Record [EOL] [EOL] from dblogger . models . model import BaseModel [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class AsyncModel ( BaseModel ) : [EOL] [EOL] @ classmethod def make_where_statement ( cls , data , prefix = None ) : [EOL] where = [ ] [EOL] values = [ ] [EOL] for idx , item in enumerate ( data . items ( ) ) : [EOL] key , value = item [EOL] key = key . replace ( [string] , [string] ) [EOL] if prefix is not None : [EOL] where . append ( f' [string] { prefix } [string] { key } [string] { idx + [number] }' ) [EOL] else : [EOL] where . append ( f' [string] { key } [string] { idx + [number] }' ) [EOL] values . append ( value ) [EOL] [EOL] where_clause = [string] . join ( where ) [EOL] return where_clause , values [EOL] [EOL] @ classmethod async def load ( cls , db , ** kwargs ) : [EOL] pk = kwargs . pop ( [string] , None ) [EOL] ser = cls . serialize_data ( kwargs ) [EOL] if pk is not None : [EOL] ser [ [string] ] = pk [EOL] where_clause , values = AsyncModel . make_where_statement ( ser ) [EOL] [EOL] data = await db . fetchrow ( f' [string] { cls . table } [string] { where_clause } [string] ' , * values ) [EOL] if data is None : [EOL] return None [EOL] return cls ( rowdata = data ) [EOL] [EOL] @ classmethod async def load_all ( cls , db , ** kwargs ) : [EOL] ser = cls . serialize_data ( kwargs ) [EOL] where_clause , values = AsyncModel . make_where_statement ( ser ) [EOL] [EOL] result = await db . fetch ( f' [string] { cls . table } [string] { where_clause } [string] ' , * values ) [EOL] return [ cls ( rowdata = data ) for data in result ] [EOL] [EOL] @ classmethod async def create ( cls , db , ignore_conflicts = False , ** kwargs ) : [EOL] ser = cls . serialize_data ( kwargs ) [EOL] [EOL] value_list = [ f' [string] { v } [string] ' for v in ser . keys ( ) ] [EOL] values = ser . values ( ) [EOL] params = [string] . join ( [ f' [string] { idx + [number] }' for idx , _ in enumerate ( values ) ] ) [EOL] [EOL] sql = f''' [string] { cls . table } [string] { [string] . join ( value_list ) } [string] { params } [string] ''' [EOL] [EOL] if ignore_conflicts is True : [EOL] sql += [string] [EOL] [EOL] sql += [string] [EOL] data = await db . fetchrow ( sql , * values ) [EOL] return cls ( rowdata = data ) [EOL] [EOL] @ classmethod async def get_or_create ( cls , db , ** kwargs ) : [EOL] item = await cls . load ( db , ** kwargs ) [EOL] if item is None : [EOL] item = await cls . create ( db , ** kwargs ) [EOL] return item [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.List[typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 $asyncpg.Connection$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 $asyncpg.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $asyncpg.Connection$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 $asyncpg.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $asyncpg.Connection$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.ValuesView[typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.ValuesView[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ValuesView[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 $asyncpg.Connection$ 0 0 0 $builtins.str$ 0 0 $typing.ValuesView[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $asyncpg.Connection$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $asyncpg.Connection$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $asyncpg.Connection$ 0 0 0 0 0 0 $typing.Any$ 0
from dblogger . models . source import BaseLogSource [EOL] from . model import AsyncModel [EOL] [EOL] [EOL] class LogSource ( BaseLogSource , AsyncModel ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . tag import LogTag [EOL] from . entry import LogEntry [EOL] from . model import AsyncModel [EOL] from . function import LogFunction [EOL] from . host import LogHost [EOL] from . logger import LogLogger [EOL] from . source import LogSource [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0