[comment] [EOL] from typing import Tuple , List , Dict , Iterator , Any , Set , Iterable [EOL] import typing [EOL] import doctest [EOL] import unittest [EOL] import subprocess [EOL] import builtins [EOL] import pathlib [EOL] [docstring] [EOL] import doctest [EOL] import runpy [EOL] import unittest [EOL] import sys [EOL] import time [EOL] from enum import Enum [EOL] import importlib [EOL] from pathlib import Path [EOL] from typing import Any , Iterator , Tuple , Iterable [EOL] import pytest [EOL] [EOL] DEBUG = False [comment] [EOL] [EOL] DOCTEST_EXCLUDE = { [string] } [EOL] [EOL] def package_module_iter ( packages ) : [EOL] [docstring] [EOL] def module_iter ( package , module_iter ) : [EOL] [docstring] [EOL] if DEBUG : [EOL] print ( f" [string] { package }" ) [EOL] for filename in module_iter : [EOL] if ( filename . stem . startswith ( [string] ) [EOL] and filename . stem . endswith ( [string] ) [EOL] and filename . suffix == [string] ) : [EOL] continue [EOL] if DEBUG : [EOL] print ( f" [string] { filename . name } [string] { filename . stem }" ) [EOL] yield filename [EOL] [EOL] for package in packages : [EOL] yield ( package , module_iter ( package , package . glob ( [string] ) ) ) [EOL] [EOL] def run ( pkg_mod_iter ) : [EOL] [docstring] [EOL] for package , module_iter in pkg_mod_iter : [EOL] print ( ) [EOL] print ( package . name ) [EOL] print ( [string] * len ( package . name ) ) [EOL] print ( ) [EOL] for module in module_iter : [EOL] if module . stem in DOCTEST_EXCLUDE : [EOL] print ( f" [string] { module }" ) [EOL] continue [EOL] status = runpy . run_path ( module , run_name = [string] ) [EOL] if status != [number] : [EOL] sys . exit ( f" [string] { module }" ) [EOL] import subprocess [EOL] [EOL] def run_doctest_suite ( pkg_mod_iter ) : [EOL] [docstring] [EOL] for package , module_iter in pkg_mod_iter : [EOL] print ( ) [EOL] print ( package . name ) [EOL] print ( [string] * len ( package . name ) ) [EOL] print ( ) [EOL] for module_path in module_iter : [EOL] if module_path . stem in DOCTEST_EXCLUDE : [EOL] print ( f" [string] { module_path }" ) [EOL] continue [EOL] result = subprocess . run ( [ [string] , [string] , [string] , str ( module_path ) ] ) [EOL] if result . returncode != [number] : [EOL] sys . exit ( f" [string] { result !r} [string] { module_path }" ) [EOL] [EOL] class PytestExit ( int , Enum ) : [EOL] Success = [number] [EOL] Failures = [number] [EOL] Interrupted = [number] [EOL] InternalError = [number] [EOL] CommandLineError = [number] [EOL] NoTests = [number] [EOL] [EOL] def run_pytest_suite ( pkg_mod_iter ) : [EOL] [docstring] [EOL] for package , module_iter in pkg_mod_iter : [EOL] print ( ) [EOL] print ( package . name ) [EOL] print ( [string] * len ( package . name ) ) [EOL] print ( ) [EOL] names = [ f"{ m . parent . name } [string] { m . name }" for m in (module_iter) ] [EOL] print ( names ) [EOL] status = pytest . main ( names ) [EOL] if status not in ( PytestExit . Success , PytestExit . NoTests ) : [EOL] sys . exit ( f" [string] { PytestExit ( status ) !r} [string] { names }" ) [EOL] [EOL] [EOL] def run_performance ( pkg_mod_iter ) : [EOL] [docstring] [EOL] for package , module_iter in pkg_mod_iter : [EOL] print ( ) [EOL] print ( package . name ) [EOL] print ( [string] * len ( package . name ) ) [EOL] print ( ) [EOL] for module in module_iter : [EOL] print ( module ) [EOL] try : [EOL] imported_module = __import__ ( f"{ package . name } [string] { module . stem }" , fromlist = [ module . stem , [string] ] ) [EOL] imported_module . performance ( ) [EOL] except AttributeError : [EOL] pass [comment] [EOL] [EOL] def master_test_suite ( pkg_mod_iter ) : [EOL] [docstring] [EOL] master_suite = unittest . TestSuite ( ) [EOL] for package , module_iter in pkg_mod_iter : [EOL] for module in module_iter : [EOL] print ( f"{ package . name } [string] { module . stem }" , file = sys . stderr ) [EOL] suite = doctest . DocTestSuite ( f"{ package . name } [string] { module . stem }" ) [EOL] print ( [string] , suite , file = sys . stderr ) [EOL] master_suite . addTests ( suite ) [EOL] runner = unittest . TextTestRunner ( verbosity = [number] ) [EOL] runner . run ( master_suite ) [EOL] [EOL] def chap_key ( name ) : [EOL] _ , _ , n = name . stem . partition ( [string] ) [EOL] return int ( n ) [EOL] [EOL] if __name__ == [string] : [EOL] content = sorted ( Path . cwd ( ) . glob ( [string] ) , key = chap_key ) [EOL] if DEBUG : [EOL] print ( content , file = sys . stderr ) [EOL] run_doctest_suite ( package_module_iter ( content ) ) [EOL] run_pytest_suite ( package_module_iter ( content ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from asciitree import LeftAligned [EOL] from asciitree . drawing import BOX_HEAVY [EOL] [EOL] rendering = LeftAligned ( ) [EOL] rendering . draw . gfx = BOX_HEAVY [EOL] [EOL] simple = { [string] : { [string] : { [string] : { } } , [string] : { [string] : { } } , [string] : { } } } [EOL] print ( rendering ( simple ) ) [EOL] [EOL] package = { [string] : { [string] : { } , [string] : { [string] : { [string] : { } } , [string] : { } } , [string] : { [string] : { } } , } } [EOL] print ( rendering ( package ) ) [EOL] [EOL] cpx = { [string] : { [string] : { [string] : { } } , [string] : { [string] : { } } , [string] : { [string] : { } } , [string] : { [string] : { } } } } [EOL] print ( rendering ( cpx ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]]]]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]]]$ 0 0 0
[comment] [EOL] from typing import Type , Dict , Any [EOL] import typing [EOL] import Chapter_9 [EOL] import builtins [EOL] [docstring] [EOL] from typing import Any , Type [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import sys [EOL] [EOL] [comment] [EOL] class UglyClass1 : [EOL] [EOL] def __init__ ( self ) : [EOL] self . logger = logging . getLogger ( self . __class__ . __qualname__ ) [EOL] self . logger . info ( [string] ) [EOL] [EOL] def method ( self , * args ) : [EOL] self . logger . info ( [string] , args ) [EOL] return [number] [EOL] [EOL] [EOL] [comment] [EOL] class UglyClass2 : [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . logger . info ( [string] ) [EOL] [EOL] def method ( self , * args ) : [EOL] self . logger . info ( [string] , args ) [EOL] return [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def logged ( class_ ) : [EOL] class_ . logger = logging . getLogger ( class_ . __qualname__ ) [EOL] return class_ [EOL] [EOL] [EOL] @ logged class SomeClass : [EOL] [EOL] def __init__ ( self ) : [EOL] self . logger . info ( [string] ) [comment] [EOL] [EOL] def method ( self , * args ) : [EOL] self . logger . info ( [string] , args ) [comment] [EOL] return [number] [EOL] [EOL] [EOL] [comment] [EOL] class LoggedInstance : [EOL] logger = ... [EOL] [EOL] def __new__ ( cls ) : [EOL] instance = super ( ) . __new__ ( cls ) [EOL] instance . logger = logging . getLogger ( cls . __qualname__ ) [EOL] return instance [EOL] [EOL] [EOL] class SomeClass2 ( LoggedInstance ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . logger . info ( [string] ) [EOL] [EOL] def method ( self , * args ) : [EOL] self . logger . info ( [string] , args ) [EOL] return [number] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class LoggedClassMeta ( type ) : [EOL] [EOL] def __new__ ( cls , name , bases , namespace , ** kwds ) : [EOL] result = type . __new__ ( cls , name , bases , dict ( namespace ) ) [EOL] result . logger = logging . getLogger ( result . __qualname__ ) [EOL] return result [EOL] [EOL] [EOL] class LoggedClass ( metaclass = LoggedClassMeta ) : [EOL] logger = ... [EOL] pass [EOL] [EOL] [EOL] class SomeClass3 ( LoggedClass ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . logger . info ( [string] ) [EOL] [EOL] def method ( self , * args ) : [EOL] self . logger . info ( [string] , args ) [EOL] return [number] [EOL] [EOL] [EOL] class LoggedWithHook : [EOL] def __init_subclass__ ( cls , name = None ) : [EOL] cls . logger = logging . getLogger ( name or cls . __qualname__ ) [EOL] [EOL] [EOL] class SomeClass4 ( LoggedWithHook ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . logger . info ( [string] ) [EOL] [EOL] def method ( self , * args ) : [EOL] self . logger . info ( [string] , args ) [EOL] return [number] [EOL] [EOL] class SomeClass4s ( LoggedWithHook , name = [string] ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . logger . info ( [string] ) [EOL] [EOL] def method ( self , * args ) : [EOL] self . logger . info ( [string] , args ) [EOL] return [number] [EOL] [EOL] [EOL] test_logged_class = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] from typing import Type , Dict , Union , Any [EOL] import typing [EOL] import Chapter_3 [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Any , cast , Callable [EOL] from enum import Enum [EOL] import sys [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Card : [EOL] insure = False [EOL] [EOL] def __init__ ( self , rank , suit , hard , soft ) : [EOL] self . rank = rank [EOL] self . suit = suit [EOL] self . hard = hard [EOL] self . soft = soft [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . suit !r} [string] { self . rank !r} [string] " [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . rank }{ self . suit }" [EOL] [EOL] [EOL] class NumberCard ( Card ) : [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] super ( ) . __init__ ( str ( rank ) , suit , rank , rank ) [EOL] [EOL] [EOL] class AceCard ( Card ) : [EOL] insure = True [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] super ( ) . __init__ ( [string] , suit , [number] , [number] ) [EOL] [EOL] [EOL] class FaceCard ( Card ) : [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] rank_str = { [number] : [string] , [number] : [string] , [number] : [string] } [ rank ] [EOL] super ( ) . __init__ ( rank_str , suit , [number] , [number] ) [EOL] [EOL] [EOL] class Suit ( str , Enum ) : [EOL] Club = [string] [EOL] Diamond = [string] [EOL] Heart = [string] [EOL] Spade = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] test_card = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Card2 : [EOL] insure = False [EOL] [EOL] def __init__ ( self , rank , suit , hard , soft ) : [EOL] self . rank = rank [EOL] self . suit = suit [EOL] self . hard = hard [EOL] self . soft = soft [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . suit !r} [string] { self . rank !r} [string] " [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . rank }{ self . suit }" [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . suit == cast ( Card2 , other ) . suit [EOL] and self . rank == cast ( Card2 , other ) . rank ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return ( hash ( self . suit ) + [number] * hash ( self . rank ) ) % sys . hash_info . modulus [EOL] [EOL] def __format__ ( self , format_spec ) : [EOL] if format_spec == [string] : [EOL] return str ( self ) [EOL] rs = ( format_spec . replace ( [string] , self . rank ) . replace ( [string] , self . suit ) . replace ( [string] , [string] ) ) [EOL] return rs [EOL] [EOL] def __bytes__ ( self ) : [EOL] class_code = self . __class__ . __name__ [ [number] ] [EOL] rank_number_str = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } . get ( self . rank , self . rank ) [EOL] string = f" [string] { [string] . join ( [ class_code , rank_number_str , self . suit ] ) } [string] " [EOL] return bytes ( string , encoding = [string] ) [EOL] [EOL] [EOL] class NumberCard2 ( Card2 ) : [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] super ( ) . __init__ ( str ( rank ) , suit , rank , rank ) [EOL] [EOL] [EOL] class AceCard2 ( Card2 ) : [EOL] insure = True [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] super ( ) . __init__ ( [string] , suit , [number] , [number] ) [EOL] [EOL] [EOL] class FaceCard2 ( Card2 ) : [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] rank_str = { [number] : [string] , [number] : [string] , [number] : [string] } [ rank ] [EOL] super ( ) . __init__ ( rank_str , suit , [number] , [number] ) [EOL] [EOL] [EOL] def card2 ( rank , suit ) : [EOL] class_ = { [number] : AceCard2 , [number] : FaceCard2 , [number] : FaceCard2 , [number] : FaceCard2 } . get ( rank , NumberCard2 ) [EOL] return class_ ( rank , suit ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] test_card2 = [string] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Card3 : [EOL] insure = False [EOL] [EOL] def __init__ ( self , rank , suit , hard , soft ) : [EOL] self . rank = rank [EOL] self . suit = suit [EOL] self . hard = hard [EOL] self . soft = soft [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . suit !r} [string] { self . rank !r} [string] " [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . rank }{ self . suit }" [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . suit == cast ( Card3 , other ) . suit [EOL] and self . rank == cast ( Card3 , other ) . rank ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class AceCard3 ( Card3 ) : [EOL] insure = True [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] super ( ) . __init__ ( [string] , suit , [number] , [number] ) [EOL] [EOL] [EOL] class NumberCard3 ( Card3 ) : [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] super ( ) . __init__ ( str ( rank ) , suit , rank , rank ) [EOL] [EOL] [EOL] class FaceCard3 ( Card3 ) : [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] rank_str = { [number] : [string] , [number] : [string] , [number] : [string] } [ rank ] [EOL] super ( ) . __init__ ( rank_str , suit , [number] , [number] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] test_card3 = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $Chapter_3.ch03_ex1.Suit$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $Chapter_3.ch03_ex1.Suit$ 0 $Chapter_3.ch03_ex1.Suit$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $"Suit"$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $"Suit"$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $Chapter_3.ch03_ex1.Suit$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $Chapter_3.ch03_ex1.Suit$ 0 $Chapter_3.ch03_ex1.Suit$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $"Suit"$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $"Suit"$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 $Card2$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $Chapter_3.ch03_ex1.Suit$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $Chapter_3.ch03_ex1.Suit$ 0 $Chapter_3.ch03_ex1.Suit$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $"Suit"$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $"Suit"$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $"Suit"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import Chapter_3 [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import sys [EOL] import random [EOL] from typing import cast , Iterable , Any , Callable [EOL] from Chapter_3 . ch03_ex1 import Suit , Card2 , card2 [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Hand : [EOL] [EOL] def __init__ ( self , dealer_card , * cards ) : [EOL] self . dealer_card = dealer_card [EOL] self . cards = list ( cards ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . join ( map ( str , self . cards ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] cards_text = [string] . join ( map ( repr , self . cards ) ) [EOL] return f"{ self . __class__ . __name__ } [string] { self . dealer_card !r} [string] { cards_text } [string] " [EOL] [EOL] def __format__ ( self , spec ) : [EOL] if spec == [string] : [EOL] return str ( self ) [EOL] return [string] . join ( f"{ c :{ spec }}" for c in self . cards ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , int ) : [EOL] return self . total ( ) == other [EOL] try : [EOL] return ( self . cards == cast ( Hand , other ) . cards [EOL] and self . dealer_card == cast ( Hand , other ) . dealer_card ) [EOL] except AttributeError : [EOL] return NotImplemented [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if isinstance ( other , int ) : [EOL] return self . total ( ) < other [EOL] try : [EOL] return self . total ( ) < cast ( Hand , other ) . total ( ) [EOL] except AttributeError : [EOL] return NotImplemented [EOL] [EOL] def __le__ ( self , other ) : [EOL] if isinstance ( other , int ) : [EOL] return self . total ( ) <= other [EOL] try : [EOL] return self . total ( ) <= cast ( Hand , other ) . total ( ) [EOL] except AttributeError : [EOL] return NotImplemented [EOL] [EOL] [comment] [EOL] [EOL] def total ( self ) : [EOL] delta_soft = max ( c . soft - c . hard for c in self . cards ) [EOL] hard = sum ( c . hard for c in self . cards ) [EOL] if hard + delta_soft <= [number] : [EOL] return hard + delta_soft [EOL] return hard [EOL] [EOL] [EOL] class FrozenHand ( Hand ) : [EOL] [EOL] def __init__ ( self , * args , ** kw ) : [EOL] if len ( args ) == [number] and isinstance ( args [ [number] ] , Hand ) : [EOL] [comment] [EOL] other = cast ( Hand , args [ [number] ] ) [EOL] self . dealer_card = other . dealer_card [EOL] self . cards = other . cards [EOL] else : [EOL] [comment] [EOL] super ( ) . __init__ ( * args , ** kw ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return sum ( hash ( c ) for c in self . cards ) % sys . hash_info . modulus [EOL] [EOL] [EOL] class Deck ( list ) : [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( card2 ( r + [number] , s ) for r in range ( [number] ) for s in cast ( Iterable [ Suit ] , Suit ) ) [EOL] random . shuffle ( self ) [EOL] [EOL] [EOL] test_frozen_hand = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Chapter_3.ch03_ex1.Card2$ 0 0 0 0 0 0 0 0 $Chapter_3.ch03_ex1.Card2$ 0 $Chapter_3.ch03_ex1.Card2$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Chapter_3.ch03_ex3.Hand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Chapter_3.ch03_ex3.Hand$ 0 0 0 0 0 0 0 $Chapter_3.ch03_ex3.Hand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , List , Optional , Dict , Callable , Any , Set [EOL] import http [EOL] import typing [EOL] import builtins [EOL] import flask [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from flask import Flask , jsonify , request , url_for , Blueprint , current_app , json , abort [EOL] from http import HTTPStatus [EOL] from typing import Dict , Any , Tuple , Callable , Set [EOL] from pathlib import Path [EOL] import secrets [EOL] import random [EOL] [EOL] from functools import wraps [EOL] from typing import Callable , Set [EOL] [EOL] VALID_API_KEYS = set ( ) [EOL] [EOL] [EOL] def init_app ( app ) : [EOL] global VALID_API_KEYS [EOL] if app . env == [string] : [EOL] VALID_API_KEYS = { [string] , [string] , [string] } [EOL] else : [EOL] app . logger . info ( [string] ) [EOL] raw_lines = ( Path ( app . config [ [string] ] ) . read_text ( ) . splitlines ( ) ) [EOL] VALID_API_KEYS = set ( filter ( None , raw_lines ) ) [EOL] [EOL] [EOL] def valid_api_key ( view_function ) : [EOL] [EOL] @ wraps ( view_function ) def confirming_view_function ( * args , ** kw ) : [EOL] api_key = request . headers . get ( [string] ) [EOL] if api_key not in VALID_API_KEYS : [EOL] current_app . logger . error ( f" [string] { api_key !r}" ) [EOL] abort ( HTTPStatus . UNAUTHORIZED ) [EOL] return view_function ( * args , ** kw ) [EOL] [EOL] return confirming_view_function [EOL] [EOL] [EOL] def api_key_in ( valid_values ) : [EOL] [EOL] def concrete_decorator ( view_function ) : [EOL] [EOL] @ wraps ( view_function ) def confirming_view_function ( * args , ** kw ) : [EOL] api_key = request . headers . get ( [string] ) [EOL] if api_key not in valid_values : [EOL] current_app . logger . error ( f" [string] { api_key !r}" ) [EOL] abort ( HTTPStatus . UNAUTHORIZED ) [EOL] return view_function ( * args , ** kw ) [EOL] [EOL] return confirming_view_function [EOL] [EOL] return concrete_decorator [EOL] [EOL] [EOL] SESSIONS = { } [EOL] [EOL] roll = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] @ roll . route ( [string] ) def openapi ( ) : [EOL] source_path = next ( Path . cwd ( ) . glob ( [string] ) ) [EOL] return jsonify ( json . loads ( source_path . read_text ( ) ) ) [EOL] [EOL] [EOL] @ roll . route ( [string] , methods = [ [string] ] ) @ valid_api_key def create_roll ( ) : [EOL] body = request . get_json ( force = True ) [EOL] if set ( body . keys ( ) ) != { [string] } : [EOL] raise BadRequest ( f" [string] { body !r}" ) [EOL] try : [EOL] n_dice = int ( body [ [string] ] ) [EOL] except ValueError as ex : [EOL] raise BadRequest ( f" [string] { body !r}" ) [EOL] [EOL] roll = [ random . randint ( [number] , [number] ) for _ in range ( n_dice ) ] [EOL] identifier = secrets . token_urlsafe ( [number] ) [EOL] SESSIONS [ identifier ] = roll [EOL] current_app . logger . info ( f" [string] { roll !r} [string] { identifier !r}" ) [EOL] [EOL] headers = { [string] : url_for ( [string] , identifier = identifier ) } [EOL] return jsonify ( roll = roll , identifier = identifier , status = [string] ) , HTTPStatus . CREATED , headers [EOL] [EOL] [EOL] @ roll . route ( [string] , methods = [ [string] ] ) @ valid_api_key def get_roll ( identifier ) : [EOL] if identifier not in SESSIONS : [EOL] abort ( HTTPStatus . NOT_FOUND ) [EOL] [EOL] return jsonify ( roll = SESSIONS [ identifier ] , identifier = identifier , status = [string] ) , HTTPStatus . OK [EOL] [EOL] [EOL] @ roll . route ( [string] , methods = [ [string] ] ) @ valid_api_key def patch_roll ( identifier ) : [EOL] if identifier not in SESSIONS : [EOL] raise BadRequest ( f" [string] { identifier !r}" ) [EOL] body = request . get_json ( force = True ) [EOL] if set ( body . keys ( ) ) != { [string] } : [EOL] raise BadRequest ( f" [string] { body !r}" ) [EOL] try : [EOL] keep_positions = [ int ( d ) for d in body [ [string] ] ] [EOL] except ValueError as ex : [EOL] raise BadRequest ( f" [string] { body !r}" ) [EOL] [EOL] roll = SESSIONS [ identifier ] [EOL] for i in range ( len ( roll ) ) : [EOL] if i not in keep_positions : [EOL] roll [ i ] = random . randint ( [number] , [number] ) [EOL] SESSIONS [ identifier ] = roll [EOL] [EOL] return jsonify ( roll = SESSIONS [ identifier ] , identifier = identifier , status = [string] ) , HTTPStatus . OK [EOL] [EOL] [EOL] class BadRequest ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def make_app ( ) : [EOL] app = Flask ( __name__ ) [EOL] app . config [ [string] ] = [string] [EOL] app . config [ [string] ] = [string] [EOL] [EOL] @ app . errorhandler ( BadRequest ) def error_message ( ex ) : [EOL] current_app . logger . error ( f"{ ex . args }" ) [EOL] return jsonify ( status = [string] , message = ex . args ) , HTTPStatus . BAD_REQUEST [EOL] [EOL] init_app ( app ) [EOL] app . register_blueprint ( roll ) [EOL] [EOL] return app [EOL] [EOL] [EOL] test_get_openapi_spec = [string] [EOL] [EOL] test_get_bad_post_roll = [string] [EOL] [EOL] test_get_good_post_roll = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,http.HTTPStatus,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[builtins.str,typing.Any],http.HTTPStatus]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[builtins.str,typing.Any],http.HTTPStatus]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[builtins.str,typing.Any],http.HTTPStatus]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , List , Union , Dict , Any [EOL] import typing [EOL] import builtins [EOL] import flask [EOL] import Chapter_13 [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from dataclasses import dataclass , asdict , astuple [EOL] from typing import List , Dict , Any , Tuple , NamedTuple [EOL] import random [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Domino : [EOL] v_0 = ... [EOL] v_1 = ... [EOL] [EOL] @ property def double ( self ) : [EOL] return self . v_0 == self . v_1 [EOL] [EOL] def __repr__ ( self ) : [EOL] if self . double : [EOL] return f" [string] { self . v_0 } [string] " [EOL] else : [EOL] return f" [string] { self . v_0 } [string] { self . v_1 } [string] " [EOL] [EOL] [EOL] class Boneyard : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , limit = [number] ) : [EOL] self . _dominoes = [ Domino ( x , y ) for x in range ( [number] , limit + [number] ) for y in range ( [number] , x + [number] ) ] [EOL] random . shuffle ( self . _dominoes ) [EOL] [EOL] def deal ( self , tiles = [number] , hands = [number] ) : [EOL] if tiles * hands > len ( self . _dominoes ) : [EOL] raise ValueError ( f" [string] { tiles } [string] { hands }" ) [EOL] return [ self . _dominoes [ h : h + tiles ] for h in range ( [number] , tiles * hands , tiles ) ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Tuple [EOL] [EOL] from flask import Flask , jsonify , abort [EOL] from http import HTTPStatus [EOL] [EOL] [comment] [EOL] [EOL] app = Flask ( __name__ ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def dominoes ( n ) : [EOL] try : [EOL] hand_size = int ( n ) [EOL] except ValueError : [EOL] abort ( HTTPStatus . BAD_REQUEST ) [EOL] [EOL] if app . env == [string] : [EOL] random . seed ( [number] ) [EOL] b = Boneyard ( limit = [number] ) [EOL] hand_0 = b . deal ( hand_size ) [ [number] ] [EOL] app . logger . info ( [string] , hand_0 ) [EOL] [EOL] return jsonify ( status = [string] , dominoes = [ astuple ( d ) for d in hand_0 ] ) , HTTPStatus . OK [EOL] [EOL] [EOL] @ app . route ( [string] ) def hands ( h , c ) : [EOL] if h == [number] or c == [number] : [EOL] return jsonify ( status = [string] , error = [ f" [string] { h !r} [string] { c !r} [string] " ] ) , HTTPStatus . BAD_REQUEST [EOL] [EOL] if app . env == [string] : [EOL] random . seed ( [number] ) [EOL] b = Boneyard ( limit = [number] ) [EOL] try : [EOL] hand_list = b . deal ( c , h ) [EOL] except ValueError as ex : [EOL] return jsonify ( status = [string] , error = ex . args ) , HTTPStatus . BAD_REQUEST [EOL] app . logger . info ( [string] , hand_list ) [EOL] [EOL] return jsonify ( status = [string] , dominoes = [ [ astuple ( d ) for d in hand ] for hand in hand_list ] ) , HTTPStatus . OK [EOL] [EOL] [EOL] OPENAPI_SPEC = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { } , } [EOL] [EOL] [EOL] @ app . route ( [string] ) def openapi ( ) : [EOL] [docstring] [EOL] [comment] [EOL] return jsonify ( OPENAPI_SPEC ) [EOL] [EOL] [EOL] test_openapi_spec = [string] [EOL] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $typing.Tuple[typing.Dict[builtins.str,typing.Any],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $typing.Tuple[typing.Dict[builtins.str,typing.Any],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Iterator [EOL] import typing [EOL] import builtins [EOL] import Chapter_13 [EOL] [docstring] [EOL] [EOL] from typing import Tuple , Iterator [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class DealerRule : [EOL] pass [EOL] [EOL] [EOL] class Hit17 ( DealerRule ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class Stand17 ( DealerRule ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class SplitRule : [EOL] pass [EOL] [EOL] [EOL] class ReSplit ( SplitRule ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class NoReSplit ( SplitRule ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class NoReSplitAces ( SplitRule ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class Table : [EOL] [EOL] def __init__ ( self , decks , limit , dealer , split , payout ) : [EOL] self . decks = decks [EOL] self . limit = limit [EOL] self . dealer = dealer [EOL] self . split = split [EOL] self . payout = payout [EOL] [EOL] def as_tuple ( self ) : [EOL] return ( self . decks , self . limit , self . dealer . __class__ . __name__ , self . split . __class__ . __name__ , self . payout , ) [EOL] [EOL] [EOL] class PlayerStrategy : [EOL] pass [EOL] [EOL] [EOL] class SomeStrategy ( PlayerStrategy ) : [EOL] pass [EOL] [EOL] [EOL] class AnotherStrategy ( PlayerStrategy ) : [EOL] pass [EOL] [EOL] [EOL] class BettingStrategy : [EOL] [EOL] def bet ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def record_win ( self ) : [EOL] pass [EOL] [EOL] def record_loss ( self ) : [EOL] pass [EOL] [EOL] [EOL] class Flat ( BettingStrategy ) : [EOL] pass [EOL] [EOL] [EOL] class Martingale ( BettingStrategy ) : [EOL] pass [EOL] [EOL] [EOL] class OneThreeTwoSix ( BettingStrategy ) : [EOL] pass [EOL] [EOL] [EOL] class Player : [EOL] [EOL] def __init__ ( self , play , betting , rounds , stake ) : [EOL] self . play = play [EOL] self . betting = betting [EOL] self . max_rounds = rounds [EOL] self . init_stake = float ( stake ) [EOL] [EOL] def reset ( self ) : [EOL] self . rounds = self . max_rounds [EOL] self . stake = self . init_stake [EOL] [EOL] def as_tuple ( self ) : [EOL] return ( self . play . __class__ . __name__ , self . betting . __class__ . __name__ , self . max_rounds , self . init_stake , self . rounds , self . stake , ) [EOL] [EOL] [EOL] [comment] [EOL] import random [EOL] [EOL] [EOL] class Simulate : [EOL] [EOL] def __init__ ( self , table , player , samples ) : [EOL] [docstring] [EOL] self . table = table [EOL] self . player = player [EOL] self . samples = samples [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] x , y = self . table . payout [EOL] blackjack_payout = x / y [EOL] for count in range ( self . samples ) : [EOL] self . player . reset ( ) [EOL] while self . player . stake > [number] and self . player . rounds > [number] : [EOL] self . player . rounds -= [number] [EOL] [EOL] outcome = random . random ( ) [EOL] if outcome < [number] : [EOL] self . player . stake -= [number] [EOL] elif [number] <= outcome < [number] : [EOL] self . player . stake += [number] [EOL] elif [number] <= outcome < [number] : [EOL] [comment] [EOL] pass [EOL] else : [EOL] [comment] [EOL] self . player . stake += blackjack_payout [EOL] [EOL] yield self . table . as_tuple ( ) + self . player . as_tuple ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $Chapter_13.simulation_model.DealerRule$ 0 $Chapter_13.simulation_model.SplitRule$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $Chapter_13.simulation_model.DealerRule$ 0 $Chapter_13.simulation_model.DealerRule$ 0 0 0 $Chapter_13.simulation_model.SplitRule$ 0 $Chapter_13.simulation_model.SplitRule$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Chapter_13.simulation_model.PlayerStrategy$ 0 $Chapter_13.simulation_model.BettingStrategy$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $Chapter_13.simulation_model.PlayerStrategy$ 0 $Chapter_13.simulation_model.PlayerStrategy$ 0 0 0 $Chapter_13.simulation_model.BettingStrategy$ 0 $Chapter_13.simulation_model.BettingStrategy$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Chapter_13.simulation_model.Table$ 0 $Chapter_13.simulation_model.Player$ 0 $builtins.int$ 0 0 0 0 0 0 0 $Chapter_13.simulation_model.Table$ 0 $Chapter_13.simulation_model.Table$ 0 0 0 $Chapter_13.simulation_model.Player$ 0 $Chapter_13.simulation_model.Player$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Iterator[typing.Tuple]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Tuple , List , Optional , Union , Dict , Callable , Any , Iterable [EOL] import http [EOL] import wsgiref [EOL] import typing [EOL] import _typeshed [EOL] import builtins [EOL] import Chapter_13 [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Dict , Tuple , List , Any , Optional , Iterable , TYPE_CHECKING [EOL] [EOL] if TYPE_CHECKING : [EOL] from wsgiref . types import WSGIApplication , WSGIEnvironment , StartResponse [EOL] [EOL] import random [EOL] from Chapter_13 . ch13_ex1 import ( Wheel , Zero , DoubleZero , American , European , Response , json_get , ) [EOL] [EOL] [EOL] import sys [EOL] import wsgiref . util [EOL] import json [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Wheel2 ( Wheel ) : [EOL] [EOL] def __call__ ( self , environ , start_response ) : [EOL] winner = self . spin ( ) [EOL] status = [string] [EOL] headers = [ ( [string] , [string] ) ] [EOL] start_response ( status , headers ) [EOL] return [ json . dumps ( winner ) . encode ( [string] ) ] [EOL] [EOL] [EOL] class American2 ( DoubleZero , Wheel2 ) : [EOL] pass [EOL] [EOL] [EOL] class European2 ( Zero , Wheel2 ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] import sys [EOL] [EOL] [EOL] class Wheel3 : [EOL] [EOL] def __init__ ( self ) : [EOL] self . am = American2 ( ) [EOL] self . eu = European2 ( ) [EOL] [EOL] def __call__ ( self , environ , start_response ) : [EOL] request = wsgiref . util . shift_path_info ( environ ) [comment] [EOL] print ( [string] , request , file = sys . stderr ) [comment] [EOL] if request and request . lower ( ) . startswith ( [string] ) : [comment] [EOL] response = self . eu ( environ , start_response ) [EOL] else : [EOL] response = self . am ( environ , start_response ) [EOL] return response [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from collections import defaultdict [EOL] [EOL] [EOL] class Table : [EOL] [EOL] def __init__ ( self , stake = [number] ) : [EOL] self . bets = defaultdict ( int ) [EOL] self . stake = stake [EOL] [EOL] def place_bet ( self , name , amount ) : [EOL] self . bets [ name ] += amount [EOL] [EOL] def clear_bets ( self , name ) : [EOL] self . bets = defaultdict ( int ) [EOL] [EOL] def resolve ( self , spin ) : [EOL] [docstring] [EOL] details = [ ] [EOL] while self . bets : [EOL] bet , amount = self . bets . popitem ( ) [EOL] if bet in spin : [EOL] x , y = spin [ bet ] [EOL] self . stake += int ( amount * x / y ) [EOL] details . append ( ( bet , amount , [string] ) ) [EOL] else : [EOL] self . stake -= amount [EOL] details . append ( ( bet , amount , [string] ) ) [EOL] return details [EOL] [EOL] [EOL] [comment] [EOL] class WSGI : [EOL] [EOL] def __call__ ( self , environ , start_response ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class RESTException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Roulette ( WSGI ) : [EOL] [EOL] def __init__ ( self , wheel ) : [EOL] self . table = Table ( [number] ) [EOL] self . rounds = [number] [EOL] self . wheel = wheel [EOL] [EOL] def __call__ ( self , environ , start_response ) : [EOL] [comment] [EOL] app = wsgiref . util . shift_path_info ( environ ) [EOL] try : [EOL] if app and app . lower ( ) == [string] : [EOL] return self . player_app ( environ , start_response ) [EOL] elif app and app . lower ( ) == [string] : [EOL] return self . bet_app ( environ , start_response ) [EOL] elif app and app . lower ( ) == [string] : [EOL] return self . wheel_app ( environ , start_response ) [EOL] else : [EOL] raise RESTException ( [string] , [string] . format_map ( environ ) , ) [EOL] except RESTException as e : [EOL] status = e . args [ [number] ] [EOL] headers = [ ( [string] , [string] ) ] [EOL] start_response ( status , headers , sys . exc_info ( ) ) [EOL] return [ repr ( e . args ) . encode ( [string] ) ] [EOL] [EOL] def player_app ( self , environ , start_response ) : [EOL] if environ [ [string] ] == [string] : [EOL] details = dict ( stake = self . table . stake , rounds = self . rounds ) [EOL] status = [string] [EOL] headers = [ ( [string] , [string] ) ] [EOL] start_response ( status , headers ) [EOL] return [ json . dumps ( details ) . encode ( [string] ) ] [EOL] else : [EOL] raise RESTException ( [string] , [string] . format_map ( environ ) , ) [EOL] [EOL] def bet_app ( self , environ , start_response ) : [EOL] if environ [ [string] ] == [string] : [EOL] details = dict ( self . table . bets ) [EOL] elif environ [ [string] ] == [string] : [EOL] size = int ( environ [ [string] ] ) [EOL] raw = environ [ [string] ] . read ( size ) . decode ( [string] ) [EOL] try : [EOL] data = json . loads ( raw ) [EOL] if isinstance ( data , dict ) : [EOL] data = [ data ] [EOL] for detail in data : [EOL] self . table . place_bet ( detail [ [string] ] , int ( detail [ [string] ] ) ) [EOL] except Exception as e : [EOL] [comment] [EOL] raise RESTException ( f" [string] " , [string] ) [EOL] details = dict ( self . table . bets ) [EOL] else : [EOL] raise RESTException ( [string] , [string] . format_map ( environ ) , ) [EOL] status = [string] [EOL] headers = [ ( [string] , [string] ) ] [EOL] start_response ( status , headers ) [EOL] return [ json . dumps ( details ) . encode ( [string] ) ] [EOL] [EOL] def wheel_app ( self , environ , start_response ) : [EOL] if environ [ [string] ] == [string] : [EOL] size = environ [ [string] ] [EOL] if size != [string] : [EOL] raw = environ [ [string] ] . read ( int ( size ) ) [EOL] raise RESTException ( [string] , f" [string] { raw !r} [string] " ) [EOL] spin = self . wheel . spin ( ) [EOL] payout = self . table . resolve ( spin ) [EOL] self . rounds += [number] [EOL] details = dict ( spin = spin , payout = payout , stake = self . table . stake , rounds = self . rounds ) [EOL] status = [string] [EOL] headers = [ ( [string] , [string] ) ] [EOL] start_response ( status , headers ) [EOL] return [ json . dumps ( details ) . encode ( [string] ) ] [EOL] else : [EOL] raise RESTException ( [string] , [string] . format_map ( environ ) , ) [EOL] [EOL] [EOL] test_table = [string] [EOL] [EOL] [comment] [EOL] def roulette_server_3 ( count = [number] ) : [EOL] from wsgiref . simple_server import make_server [EOL] from wsgiref . validate import validator [EOL] [EOL] wheel = American ( seed = [number] ) [EOL] roulette = Roulette ( wheel ) [EOL] debug = validator ( roulette ) [EOL] httpd = make_server ( [string] , [number] , debug ) [EOL] if count is None : [EOL] httpd . serve_forever ( ) [EOL] else : [EOL] for c in range ( count ) : [EOL] httpd . handle_request ( ) [EOL] [EOL] [EOL] [comment] [EOL] import http . client [EOL] import json [EOL] [EOL] [EOL] def roulette_client ( method = [string] , path = [string] , data = None ) : [EOL] rest = http . client . HTTPConnection ( [string] , [number] ) [EOL] if data : [EOL] header = { [string] : [string] } [EOL] params = json . dumps ( data ) . encode ( [string] ) [EOL] rest . request ( method , path , params , header ) [EOL] else : [EOL] rest . request ( method , path ) [EOL] response = rest . getresponse ( ) [EOL] raw = response . read ( ) . decode ( [string] ) [EOL] try : [EOL] document = json . loads ( raw ) [EOL] except json . decoder . JSONDecodeError as ex : [EOL] document = raw [EOL] return Response ( response . status , dict ( response . getheaders ( ) ) , document ) [EOL] [EOL] [EOL] def server_3 ( ) : [EOL] import concurrent . futures [EOL] import time [EOL] [EOL] with concurrent . futures . ProcessPoolExecutor ( ) as executor : [EOL] executor . submit ( roulette_server_3 , [number] ) [EOL] time . sleep ( [number] ) [comment] [EOL] r1 = roulette_client ( [string] , [string] ) [EOL] print ( r1 ) [EOL] r2 = roulette_client ( [string] , [string] , { [string] : [string] , [string] : [string] } ) [EOL] print ( r2 ) [EOL] r3 = roulette_client ( [string] , [string] ) [EOL] print ( r3 ) [EOL] r4 = roulette_client ( [string] , [string] ) [EOL] print ( r4 ) [EOL] assert r1 . status == [number] and r1 . content == { [string] : [number] , [string] : [number] } [EOL] assert r2 . status == [number] and r2 . content == { [string] : [number] } [EOL] assert r3 . status == [number] and r3 . content == { [string] : [number] } [EOL] assert ( r4 . status == [number] [EOL] and r4 . content == { [string] : { [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] } , [string] : [ [ [string] , [number] , [string] ] ] , [string] : [number] , [string] : [number] } ) , f"{ r4 !r}" [EOL] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL] server_3 ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $"StartResponse"$ 0 $builtins.str$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $Chapter_13.ch13_e1_ex3.American2$ 0 0 0 0 0 0 0 $Chapter_13.ch13_e1_ex3.European2$ 0 0 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $Chapter_13.ch13_e1_ex3.Table$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $"StartResponse"$ 0 $typing.Any$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $"StartResponse"$ 0 $builtins.str$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 0 $typing.Any$ 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $"StartResponse"$ 0 $builtins.str$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 $"WSGIEnvironment"$ 0 $"StartResponse"$ 0 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 0 $typing.Any$ 0 $"WSGIEnvironment"$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Tuple[builtins.str,builtins.int,builtins.str]],builtins.int]]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.str]]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $"StartResponse"$ 0 $builtins.str$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Tuple[builtins.str,builtins.int,builtins.str]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"WSGIEnvironment"$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Chapter_13.ch13_ex1.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [docstring] [EOL] [EOL] import pytest [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] pytest . main ( [ [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] import unittest [EOL] [EOL] [comment] [EOL] from Chapter_19 . tests import test_all [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] unittest . main ( test_all , verbosity = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [EOL] import Chapter_19 [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] import unittest [EOL] from Chapter_19 import some_algorithm [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class TestSomeAlgorithm ( unittest . TestCase ) : [EOL] [EOL] def test_import_should_see_value ( self ) : [EOL] x = some_algorithm . SomeAlgorithm ( ) [EOL] assert [number] ** [number] == x . value ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( exit = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Chapter_19.some_algorithm.abstraction.AbstractSomeAlgorithm$ 0 0 0 0 0 0 0 0 0 0 0 0 $Chapter_19.some_algorithm.abstraction.AbstractSomeAlgorithm$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from . abstraction import AbstractSomeAlgorithm [EOL] [EOL] [EOL] class Implementation_Short ( AbstractSomeAlgorithm ) : [EOL] [docstring] [EOL] [EOL] def value ( self ) : [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from . abstraction import AbstractSomeAlgorithm [EOL] [EOL] [EOL] class Implementation_Long ( AbstractSomeAlgorithm ) : [EOL] [docstring] [EOL] [EOL] def value ( self ) : [EOL] return [number] ** [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] [EOL] class AbstractSomeAlgorithm : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type [EOL] import typing [EOL] import Chapter_19 [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import sys [EOL] [EOL] from typing import Type [EOL] [EOL] from Chapter_19 . some_algorithm . abstraction import AbstractSomeAlgorithm [EOL] [EOL] SomeAlgorithm = ... [EOL] [EOL] if sys . platform . endswith ( [string] ) : [EOL] [comment] [EOL] from Chapter_19 . some_algorithm . short_version import * [EOL] [EOL] SomeAlgorithm = Implementation_Short [EOL] else : [EOL] [comment] [EOL] from Chapter_19 . some_algorithm . long_version import * [EOL] [EOL] SomeAlgorithm = Implementation_Long [EOL] [EOL] [comment] [EOL] [EOL] print ( f"{ __name__ } [string] { SomeAlgorithm . __module__ } [string] { SomeAlgorithm . __doc__ }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Chapter_19.some_algorithm.abstraction.AbstractSomeAlgorithm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Chapter_19.some_algorithm.abstraction.AbstractSomeAlgorithm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Chapter_19.some_algorithm.abstraction.AbstractSomeAlgorithm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Chapter_19.some_algorithm.abstraction.AbstractSomeAlgorithm]$ 0 0 0 0 0 $typing.Type[Chapter_19.some_algorithm.abstraction.AbstractSomeAlgorithm]$ 0 0 0 0 0
	0
[comment] [EOL] from typing import Dict , Optional , Iterator , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from dataclasses import dataclass [EOL] from enum import Enum [EOL] from typing import Iterator , cast , Iterable , Optional [EOL] [EOL] [EOL] @ dataclass class RTD : [EOL] rate = ... [EOL] time = ... [EOL] distance = ... [EOL] [EOL] def compute ( self ) : [EOL] if ( self . distance is None and self . rate is not None and self . time is not None ) : [EOL] self . distance = self . rate * self . time [EOL] elif ( self . rate is None and self . distance is not None and self . time is not None ) : [EOL] self . rate = self . distance / self . time [EOL] elif ( self . time is None and self . distance is not None and self . rate is not None ) : [EOL] self . time = self . distance / self . rate [EOL] return self [EOL] [EOL] [EOL] test_rtd = [string] [EOL] [EOL] [EOL] class Suit ( str , Enum ) : [EOL] Club = [string] [EOL] Diamond = [string] [EOL] Heart = [string] [EOL] Spade = [string] [EOL] [EOL] [EOL] @ dataclass ( frozen = True , order = True ) class Card : [EOL] rank = ... [EOL] suit = ... [EOL] [EOL] @ property def points ( self ) : [EOL] return self . rank [EOL] [EOL] [EOL] class Ace ( Card ) : [EOL] [EOL] @ property def points ( self ) : [EOL] return [number] [EOL] [EOL] [EOL] class Face ( Card ) : [EOL] [EOL] @ property def points ( self ) : [EOL] return [number] [EOL] [EOL] [EOL] def deck ( ) : [EOL] for rank in range ( [number] , [number] ) : [EOL] for suit in cast ( Iterable [ Suit ] , Suit ) : [EOL] if rank == [number] : [EOL] yield Ace ( rank , suit ) [EOL] elif rank >= [number] : [EOL] yield Face ( rank , suit ) [EOL] else : [EOL] yield Card ( rank , suit ) [EOL] [EOL] [EOL] test_dataclass = [string] [EOL] [EOL] test_hand = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $"RTD"$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Tuple , Union , Dict , Callable , Any [EOL] import typing [EOL] import builtins [EOL] import Chapter_4 [EOL] [docstring] [EOL] from enum import Enum [EOL] import random [EOL] from typing import Any , cast , NamedTuple , Callable , Iterable , Union [EOL] from dataclasses import dataclass [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Suit ( str , Enum ) : [EOL] Club = [string] [EOL] Diamond = [string] [EOL] Heart = [string] [EOL] Spade = [string] [EOL] [EOL] [EOL] class BlackJackCard : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] __slots__ = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , rank , suit , hard , soft ) : [EOL] self . rank = rank [EOL] self . suit = suit [EOL] self . hard = hard [EOL] self . soft = soft [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . rank } [string] { self . suit !r} [string] { self . hard } [string] { self . soft }" [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . rank }{ self . suit }" [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __lt__ ( self , other ) : [EOL] [comment] [EOL] if not issubclass ( other . __class__ , BlackJackCard ) : [EOL] return NotImplemented [EOL] return self . rank < cast ( BlackJackCard , other ) . rank [EOL] [EOL] def __le__ ( self , other ) : [EOL] [comment] [EOL] try : [EOL] return self . rank <= cast ( BlackJackCard , other ) . rank [EOL] except AttributeError : [EOL] return NotImplemented [EOL] [EOL] def __eq__ ( self , other ) : [EOL] try : [EOL] return self . rank == cast ( BlackJackCard , other ) . rank and self . suit == cast ( BlackJackCard , other ) . suit [EOL] except AttributeError : [EOL] return NotImplemented [EOL] [EOL] [EOL] class Ace21Card ( BlackJackCard ) : [EOL] __slots__ = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] super ( ) . __init__ ( [string] , suit , [number] , [number] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . suit !r} [string] " [EOL] [EOL] [EOL] class Face21Card ( BlackJackCard ) : [EOL] __slots__ = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] rank_str = { [number] : [string] , [number] : [string] , [number] : [string] } [ rank ] [EOL] super ( ) . __init__ ( rank_str , suit , [number] , [number] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] rank_num = { [string] : [number] , [string] : [number] , [string] : [number] } [ self . rank ] [EOL] return f"{ self . __class__ . __name__ } [string] { rank_num } [string] { self . suit !r} [string] " [EOL] [EOL] [EOL] class Number21Card ( BlackJackCard ) : [EOL] __slots__ = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] super ( ) . __init__ ( str ( rank ) , suit , rank , rank ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . rank } [string] { self . suit !r} [string] " [EOL] [EOL] [EOL] def card21 ( rank , suit ) : [EOL] if rank == [number] : [EOL] return Ace21Card ( rank , suit ) [EOL] elif [number] <= rank < [number] : [EOL] return Number21Card ( rank , suit ) [EOL] elif [number] <= rank < [number] : [EOL] return Face21Card ( rank , suit ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def compare ( a , b ) : [EOL] print ( f"{ a } [string] { b } [string] { a == b } [string] { a } [string] { b } [string] { a < b } [string] { a } [string] { b } [string] { a <= b }" ) [EOL] print ( f"{ a } [string] { b } [string] { a != b } [string] { a } [string] { b } [string] { a > b } [string] { a } [string] { b } [string] { a >= b }" ) [EOL] [EOL] [EOL] test_comparisons_21 = [string] [EOL] [EOL] [EOL] class Deck ( list ) : [EOL] [EOL] def __init__ ( self , decks = [number] , factory = card21 ) : [EOL] super ( ) . __init__ ( ) [EOL] for i in range ( decks ) : [EOL] self . extend ( factory ( r + [number] , s ) for r in range ( [number] ) for s in cast ( Iterable [ Suit ] , Suit ) ) [EOL] random . shuffle ( self ) [EOL] burn = random . randint ( [number] , [number] ) [EOL] for i in range ( burn ) : [EOL] self . pop ( ) [EOL] [EOL] [EOL] class AceCard2 ( NamedTuple ) : [EOL] rank = ... [EOL] suit = ... [EOL] hard = [number] [EOL] soft = [number] [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . rank }{ self . suit }" [EOL] [EOL] [EOL] class FaceCard2 ( NamedTuple ) : [EOL] rank = ... [EOL] suit = ... [EOL] hard = [number] [EOL] soft = [number] [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . rank }{ self . suit }" [EOL] [EOL] [EOL] class NumberCard2 ( NamedTuple ) : [EOL] rank = ... [EOL] suit = ... [EOL] hard = ... [EOL] soft = ... [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . rank }{ self . suit }" [EOL] [EOL] [EOL] def card2 ( rank , suit ) : [EOL] [docstring] [EOL] if rank == [number] : [EOL] return AceCard2 ( [string] , suit ) [EOL] elif [number] <= rank < [number] : [EOL] return NumberCard2 ( str ( rank ) , suit , rank , rank ) [EOL] elif [number] <= rank < [number] : [EOL] rank_str = { [number] : [string] , [number] : [string] , [number] : [string] } [ rank ] [EOL] return FaceCard2 ( rank_str , suit ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] test_comparisons_2 = [string] [EOL] [EOL] [EOL] @ dataclass ( eq = True , order = True , frozen = True ) class AceCard3 : [EOL] rank = ... [EOL] suit = ... [EOL] hard = [number] [EOL] soft = [number] [EOL] [EOL] [EOL] @ dataclass ( eq = True , order = True , frozen = True ) class FaceCard3 : [EOL] rank = ... [EOL] suit = ... [EOL] hard = [number] [EOL] soft = [number] [EOL] [EOL] [EOL] @ dataclass ( eq = True , order = True , frozen = True ) class NumberCard3 : [EOL] rank = ... [EOL] suit = ... [EOL] hard = ... [EOL] soft = ... [EOL] [EOL] [EOL] def card3 ( rank , suit ) : [EOL] if rank == [number] : [EOL] return AceCard3 ( [string] , suit ) [EOL] elif [number] <= rank < [number] : [EOL] return NumberCard3 ( str ( rank ) , suit , rank , rank ) [EOL] elif [number] <= rank < [number] : [EOL] rank_str = { [number] : [string] , [number] : [string] , [number] : [string] } [ rank ] [EOL] return FaceCard3 ( rank_str , suit ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] test_comparisons_3 = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $Chapter_4.ch04_ex1.Suit$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $Chapter_4.ch04_ex1.Suit$ 0 $Chapter_4.ch04_ex1.Suit$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $Suit$ 0 0 0 0 0 0 0 0 0 0 0 $Suit$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $Suit$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $Suit$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $Suit$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $Suit$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BlackJackCard$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $typing.Callable[[builtins.int,Suit],BlackJackCard]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Callable[[builtins.int,Suit],BlackJackCard]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Suit$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Suit$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Suit$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[AceCard2,FaceCard2,NumberCard2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Suit$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Suit$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Suit$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Union[AceCard3,FaceCard3,NumberCard3]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Dict , Any [EOL] import Chapter_10 [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import datetime [EOL] from typing import List , Optional , Dict , Any [EOL] from dataclasses import dataclass [EOL] from pathlib import Path [EOL] from Chapter_10 . ch10_ex2 import Suit , Card , AceCard , FaceCard [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] deck = [ AceCard ( [string] , Suit . Clubs ) , Card ( [string] , Suit . Hearts ) , FaceCard ( [string] , Suit . Diamonds ) ] [EOL] [EOL] import yaml [EOL] [EOL] [EOL] def card_representer ( dumper , card ) : [EOL] return dumper . represent_scalar ( [string] , f"{ card . rank !s}{ card . suit . value !s}" ) [EOL] [EOL] [EOL] def acecard_representer ( dumper , card ) : [EOL] return dumper . represent_scalar ( [string] , f"{ card . rank !s}{ card . suit . value !s}" ) [EOL] [EOL] [EOL] def facecard_representer ( dumper , card ) : [EOL] return dumper . represent_scalar ( [string] , f"{ card . rank !s}{ card . suit . value !s}" ) [EOL] [EOL] [EOL] def card_constructor ( loader , node ) : [EOL] value = loader . construct_scalar ( node ) [EOL] rank , suit = value [ : - [number] ] , value [ - [number] ] [EOL] return Card ( rank , Suit ( suit ) ) [EOL] [EOL] [EOL] def acecard_constructor ( loader , node ) : [EOL] value = loader . construct_scalar ( node ) [EOL] rank , suit = value [ : - [number] ] , value [ - [number] ] [EOL] return AceCard ( rank , Suit ( suit ) ) [EOL] [EOL] [EOL] def facecard_constructor ( loader , node ) : [EOL] value = loader . construct_scalar ( node ) [EOL] rank , suit = value [ : - [number] ] , value [ - [number] ] [EOL] return FaceCard ( rank , Suit ( suit ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] yaml . add_representer ( Card , card_representer ) [EOL] yaml . add_representer ( AceCard , acecard_representer ) [EOL] yaml . add_representer ( FaceCard , facecard_representer ) [EOL] yaml . add_constructor ( [string] , card_constructor ) [EOL] yaml . add_constructor ( [string] , acecard_constructor ) [EOL] yaml . add_constructor ( [string] , facecard_constructor ) [EOL] [EOL] test_yaml_dump_load = [string] [EOL] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Chapter_10.ch10_ex2.Card$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Chapter_10.ch10_ex2.Card$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Chapter_10.ch10_ex2.Card$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any [EOL] import Chapter_10 [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import datetime [EOL] from typing import List , Optional , Dict , Any [EOL] from dataclasses import dataclass [EOL] from pathlib import Path [EOL] [EOL] from Chapter_10 . ch10_ex1 import Post , Blog , travel , rst_render [EOL] from Chapter_10 . ch10_ex2 import FaceCard , AceCard , Card , Suit [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import pickle [EOL] from pathlib import Path [EOL] [EOL] test_pickle = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging , sys [EOL] [EOL] audit_log = logging . getLogger ( [string] ) [EOL] [EOL] class Hand_bad : [EOL] [EOL] def __init__ ( self , dealer_card , * cards ) : [EOL] self . dealer_card = dealer_card [EOL] self . cards = list ( cards ) [EOL] for c in self . cards : [EOL] audit_log . info ( [string] , c ) [EOL] [EOL] def append ( self , card ) : [EOL] self . cards . append ( card ) [EOL] audit_log . info ( [string] , card ) [EOL] [EOL] def __str__ ( self ) : [EOL] cards = [string] . join ( map ( str , self . cards ) ) [EOL] return f"{ self . dealer_card } [string] { cards }" [EOL] [EOL] [EOL] test_audit = [string] [EOL] [EOL] [EOL] class Hand2 : [EOL] [EOL] def __init__ ( self , dealer_card , * cards ) : [EOL] self . dealer_card = dealer_card [EOL] self . cards = list ( cards ) [EOL] for c in self . cards : [EOL] audit_log . info ( [string] , c ) [EOL] [EOL] def append ( self , card ) : [EOL] self . cards . append ( card ) [EOL] audit_log . info ( [string] , card ) [EOL] [EOL] def __str__ ( self ) : [EOL] cards = [string] . join ( map ( str , self . cards ) ) [EOL] return f"{ self . dealer_card } [string] { cards }" [EOL] [EOL] def __getstate__ ( self ) : [EOL] return vars ( self ) [EOL] [EOL] def __setstate__ ( self , state ) : [EOL] [comment] [EOL] self . __dict__ . update ( state ) [EOL] for c in self . cards : [EOL] audit_log . info ( [string] , c ) [EOL] [EOL] test_audit_2 = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] [EOL] [EOL] class RestrictedUnpickler ( pickle . Unpickler ) : [EOL] [EOL] def find_class ( self , module , name ) : [EOL] if module == [string] : [EOL] if name not in ( [string] , [string] ) : [EOL] return getattr ( builtins , name ) [EOL] elif module in ( [string] , [string] , [string] ) : [EOL] [comment] [EOL] return globals ( ) [ name ] [EOL] [comment] [EOL] elif module in ( [string] , ) : [EOL] return globals ( ) [ name ] [EOL] raise pickle . UnpicklingError ( f" [string] { module } [string] { name } [string] " ) [EOL] [EOL] [EOL] test_audit_3 = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Chapter_10.ch10_ex2.Card$ 0 0 0 0 0 0 0 0 0 $Chapter_10.ch10_ex2.Card$ 0 0 $logging.Logger$ 0 0 0 0 0 $Chapter_10.ch10_ex2.Card$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Chapter_10.ch10_ex2.Card$ 0 0 0 0 0 0 0 0 0 $Chapter_10.ch10_ex2.Card$ 0 0 $logging.Logger$ 0 0 0 0 0 $Chapter_10.ch10_ex2.Card$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type , List , Dict , Any [EOL] import Chapter_10 [EOL] import typing [EOL] import builtins [EOL] import yaml [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import datetime [EOL] from typing import List , Optional , Dict , Any [EOL] from dataclasses import dataclass [EOL] from pathlib import Path [EOL] from Chapter_10 . ch10_ex2 import Suit , Card , AceCard , FaceCard [EOL] from Chapter_10 . ch10_ex2b import facecard_representer , acecard_representer , card_representer [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import yaml [EOL] [EOL] [EOL] class Card2 ( yaml . YAMLObject ) : [EOL] yaml_tag = [string] [EOL] yaml_loader = yaml . SafeLoader [EOL] [EOL] def __init__ ( self , rank , suit , hard = None , soft = None ) : [EOL] self . rank = rank [EOL] self . suit = suit [EOL] self . hard = hard or int ( rank ) [EOL] self . soft = soft or int ( rank ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self ) [EOL] [EOL] [EOL] class AceCard2 ( Card2 ) : [EOL] yaml_tag = [string] [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] super ( ) . __init__ ( rank , suit , [number] , [number] ) [EOL] [EOL] [EOL] class FaceCard2 ( Card2 ) : [EOL] yaml_tag = [string] [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] super ( ) . __init__ ( rank , suit , [number] , [number] ) [EOL] [EOL] [EOL] deck2 = [ AceCard2 ( [string] , [string] ) , Card2 ( [string] , [string] ) , FaceCard2 ( [string] , [string] ) ] [EOL] [EOL] test_yaml_dump_safe_load = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[yaml.loader.SafeLoader]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Chapter_10.ch10_ex2c.Card2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import datetime [EOL] from typing import List , Optional , Dict , Any [EOL] from dataclasses import dataclass [EOL] from pathlib import Path [EOL] [EOL] from Chapter_10 . ch10_ex1 import Post , Blog , travel , rst_render [EOL] from Chapter_10 . ch10_ex2 import Suit , Card , FaceCard , AceCard [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import yaml [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] test_yaml = [string] [EOL] [EOL] with ( Path . cwd ( ) / [string] / [string] ) . open ( [string] , encoding = [string] ) as target : [EOL] yaml . dump ( travel , target ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] deck = [ AceCard ( [string] , Suit . Clubs ) , Card ( [string] , Suit . Hearts ) , FaceCard ( [string] , Suit . Diamonds ) ] [EOL] [EOL] test_yaml_dump = [string] [EOL] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Union , Optional , DefaultDict , Dict , Any [EOL] import typing [EOL] import Chapter_10 [EOL] import string [EOL] import builtins [EOL] import jinja2 [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from typing import List , Optional , Dict , Any , DefaultDict , Union , Type [EOL] from pathlib import Path [EOL] import datetime [EOL] from dataclasses import dataclass [EOL] [EOL] [comment] [EOL] [comment] [EOL] JSON = Union [ Dict [ str , Any ] , List [ Any ] , int , str , float , bool , Type [ None ] ] [EOL] [EOL] @ dataclass class Post : [EOL] date = ... [EOL] title = ... [EOL] rst_text = ... [EOL] tags = ... [EOL] [EOL] def as_dict ( self ) : [EOL] return dict ( date = str ( self . date ) , title = self . title , underline = [string] * len ( self . title ) , rst_text = self . rst_text , tag_text = [string] . join ( self . tags ) , ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from collections import defaultdict [EOL] [EOL] class Blog_x ( list ) : [EOL] [EOL] def __init__ ( self , title , posts = None ) : [EOL] self . title = title [EOL] super ( ) . __init__ ( posts if posts is not None else [ ] ) [EOL] [EOL] def by_tag ( self ) : [EOL] tag_index = defaultdict ( list ) [EOL] for post in self : [EOL] for tag in post . tags : [EOL] tag_index [ tag ] . append ( post . as_dict ( ) ) [EOL] return tag_index [EOL] [EOL] def as_dict ( self ) : [EOL] return dict ( title = self . title , entries = [ p . as_dict ( ) for p in self ] ) [EOL] [EOL] [EOL] [comment] [EOL] travel_x = Blog_x ( [string] ) [EOL] travel_x . append ( Post ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) ) [EOL] travel_x . append ( Post ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import json [EOL] [EOL] test_json_1 = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def blogx_encode ( object ) : [EOL] if isinstance ( object , datetime . datetime ) : [EOL] return dict ( __class__ = [string] , __args__ = [ ] , __kw__ = dict ( year = object . year , month = object . month , day = object . day , hour = object . hour , minute = object . minute , second = object . second , ) , ) [EOL] elif isinstance ( object , Post ) : [EOL] return dict ( __class__ = [string] , __args__ = [ ] , __kw__ = dict ( date = object . date , title = object . title , rst_text = object . rst_text , tags = object . tags , ) , ) [EOL] elif isinstance ( object , Blog_x ) : [EOL] [comment] [EOL] return dict ( __class__ = [string] , __args__ = [ ] , __kw__ = dict ( title = object . title , entries = tuple ( object ) ) , ) [EOL] else : [EOL] return object [EOL] [EOL] def blogx_decode ( some_dict ) : [EOL] if set ( some_dict . keys ( ) ) == set ( [ [string] , [string] , [string] ] ) : [EOL] class_ = eval ( some_dict [ [string] ] ) [EOL] return class_ ( * some_dict [ [string] ] , ** some_dict [ [string] ] ) [EOL] else : [EOL] return some_dict [EOL] [EOL] test_json_2 = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import datetime [EOL] from collections import defaultdict [EOL] [EOL] [EOL] class Blog : [EOL] [EOL] def __init__ ( self , title , posts = None ) : [EOL] self . title = title [EOL] self . entries = posts if posts is not None else [ ] [EOL] [EOL] @ property def underline ( self ) : [EOL] return [string] * len ( self . title ) [EOL] [EOL] def append ( self , post ) : [EOL] self . entries . append ( post ) [EOL] [EOL] def by_tag ( self ) : [EOL] tag_index = defaultdict ( list ) [EOL] for post in self . entries : [EOL] for tag in post . tags : [EOL] tag_index [ tag ] . append ( post . as_dict ( ) ) [EOL] return tag_index [EOL] [EOL] def as_dict ( self ) : [EOL] return dict ( title = self . title , underline = self . underline , entries = [ p . as_dict ( ) for p in self . entries ] , ) [EOL] [EOL] [EOL] [comment] [EOL] travel = Blog ( [string] ) [EOL] travel . append ( Post ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) ) [EOL] travel . append ( Post ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) ) [EOL] [EOL] [EOL] def blog_encode ( object ) : [EOL] if isinstance ( object , datetime . datetime ) : [EOL] return dict ( __class__ = [string] , __args__ = [ ] , __kw__ = dict ( year = object . year , month = object . month , day = object . day , hour = object . hour , minute = object . minute , second = object . second , ) , ) [EOL] elif isinstance ( object , Post ) : [EOL] return dict ( __class__ = [string] , __args__ = [ ] , __kw__ = dict ( date = object . date , title = object . title , rst_text = object . rst_text , tags = object . tags , ) , ) [EOL] elif isinstance ( object , Blog ) : [EOL] return dict ( __class__ = [string] , __args__ = [ object . title , object . entries ] , __kw__ = { } ) [EOL] else : [EOL] return object [EOL] [EOL] [EOL] def blog_decode ( some_dict ) : [EOL] if set ( some_dict . keys ( ) ) == { [string] , [string] , [string] } : [EOL] class_ = eval ( some_dict [ [string] ] ) [EOL] return class_ ( * some_dict [ [string] ] , ** some_dict [ [string] ] ) [EOL] else : [EOL] return some_dict [EOL] [EOL] [EOL] test_json_3 = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import string [EOL] [EOL] [comment] [EOL] def rst_render ( blog ) : [EOL] post = string . Template ( [string] ) [EOL] [EOL] [comment] [EOL] print ( f"{ blog . title } [string] { blog . underline } [string] " ) [EOL] for p in blog . entries : [EOL] print ( post . substitute ( ** p . as_dict ( ) ) ) [EOL] [EOL] tag_index = blog . by_tag ( ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( ) [EOL] for tag in tag_index : [EOL] print ( f" [string] { tag }" ) [EOL] print ( ) [EOL] for post_dict in tag_index [ tag ] : [EOL] print ( f" [string] { post_dict [ [string] ] } [string] " ) [EOL] print ( ) [EOL] [EOL] test_string_template_render = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from jinja2 import Template [EOL] [EOL] blog_template = Template ( [string] ) [EOL] [EOL] test_jinja_temple_render = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Post_J ( Post ) : [EOL] [docstring] [EOL] @ property def _json ( self ) : [EOL] return dict ( __class__ = self . __class__ . __name__ , __kw__ = dict ( date = self . date , title = self . title , rst_text = self . rst_text , tags = self . tags ) , __args__ = [ ] , ) [EOL] [EOL] class Blog_J ( Blog ) : [EOL] [docstring] [EOL] [EOL] @ property def _json ( self ) : [EOL] return dict ( __class__ = self . __class__ . __name__ , __kw__ = { } , __args__ = [ self . title , self . entries ] , ) [EOL] [EOL] def blog_j_encode ( object ) : [EOL] if isinstance ( object , datetime . datetime ) : [EOL] return dict ( __class__ = [string] , __args__ = [ ] , __kw__ = dict ( year = object . year , month = object . month , day = object . day , hour = object . hour , minute = object . minute , second = object . second , ) , ) [EOL] else : [EOL] try : [EOL] encoding = object . _json [EOL] except AttributeError : [EOL] encoding = json . JSONEncoder ( ) . default ( object ) [EOL] return encoding [EOL] [EOL] [EOL] travel3 = Blog_J ( [string] ) [EOL] travel3 . append ( Post_J ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) ) [EOL] travel3 . append ( Post_J ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) ) [EOL] [EOL] test_json_4 = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def blog_j2_encode ( object ) : [EOL] if isinstance ( object , datetime . datetime ) : [EOL] return dict ( __class__ = [string] , __args__ = [ object . strftime ( [string] ) , [string] ] , __kw__ = { } , ) [EOL] else : [EOL] try : [EOL] encoding = object . _json [EOL] except AttributeError : [EOL] encoding = json . JSONEncoder ( ) . default ( object ) [EOL] return encoding [EOL] [EOL] [EOL] test_json_5 = [string] [EOL] [EOL] with ( Path . cwd ( ) / [string] / [string] ) . open ( [string] , encoding = [string] ) as target : [EOL] json . dump ( travel3 , target , separators = ( [string] , [string] ) , default = blog_j2_encode ) [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[Post]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.List[Post]]$ 0 $typing.Optional[typing.List[Post]]$ 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[Post]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[typing.List[Post]]$ 0 $typing.Optional[typing.List[Post]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Post$ 0 0 0 0 0 0 0 0 0 $Post$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Template$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import List , Optional , DefaultDict , Dict , Any , Generator [EOL] import Chapter_10 [EOL] import typing [EOL] import xml [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import datetime [EOL] from dataclasses import dataclass , field , asdict [EOL] from typing import List , DefaultDict , Dict , Any [EOL] from collections import defaultdict [EOL] import io [EOL] from Chapter_10 . ch10_ex1 import travel , rst_render [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from dataclasses import dataclass , field , asdict [EOL] @ dataclass class Post_X : [EOL] date = ... [EOL] title = ... [EOL] rst_text = ... [EOL] tags = ... [EOL] underline = field ( init = False ) [EOL] tag_text = field ( init = False ) [EOL] [EOL] def __post_init__ ( self ) : [EOL] self . underline = [string] * len ( self . title ) [EOL] self . tag_text = [string] . join ( self . tags ) [EOL] [EOL] def as_dict ( self ) : [EOL] return asdict ( self ) [EOL] [EOL] def xml ( self ) : [EOL] tags = [string] . join ( f" [string] { t } [string] " for t in self . tags ) [EOL] return f""" [string] { self . title } [string] { self . date } [string] { tags } [string] { self . rst_text } [string] """ [EOL] [EOL] [EOL] from dataclasses import dataclass , field , asdict [EOL] [EOL] @ dataclass class Blog_X : [EOL] title = ... [EOL] entries = field ( default_factory = list ) [EOL] underline = field ( init = False ) [EOL] [EOL] def __post_init__ ( self ) : [EOL] self . underline = [string] * len ( self . title ) [EOL] [EOL] def append ( self , post ) : [EOL] self . entries . append ( post ) [EOL] [EOL] def by_tag ( self ) : [EOL] tag_index = defaultdict ( list ) [EOL] for post in self . entries : [EOL] for tag in post . tags : [EOL] tag_index [ tag ] . append ( asdict ( post ) ) [EOL] return tag_index [EOL] [EOL] def as_dict ( self ) : [EOL] return asdict ( self ) [EOL] [EOL] def xml ( self ) : [EOL] children = [string] . join ( c . xml ( ) for c in self . entries ) [EOL] return f""" [string] { self . title } [string] { children } [string] """ [EOL] [EOL] [EOL] travel4 = Blog_X ( [string] ) [EOL] travel4 . append ( Post_X ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) ) [EOL] travel4 . append ( Post_X ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) ) [EOL] [EOL] test_xml_out_1 = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import xml . etree . ElementTree as XML [EOL] from typing import cast [EOL] [EOL] class Blog_E ( Blog_X ) : [EOL] [EOL] def xmlelt ( self ) : [EOL] blog = XML . Element ( [string] ) [EOL] title = XML . SubElement ( blog , [string] ) [EOL] title . text = self . title [EOL] title . tail = [string] [EOL] entities = XML . SubElement ( blog , [string] ) [EOL] entities . extend ( cast ( [string] , c ) . xmlelt ( ) for c in self . entries ) [EOL] blog . tail = [string] [EOL] return blog [EOL] [EOL] [EOL] class Post_E ( Post_X ) : [EOL] [EOL] def xmlelt ( self ) : [EOL] post = XML . Element ( [string] ) [EOL] title = XML . SubElement ( post , [string] ) [EOL] title . text = self . title [EOL] date = XML . SubElement ( post , [string] ) [EOL] date . text = str ( self . date ) [EOL] tags = XML . SubElement ( post , [string] ) [EOL] for t in self . tags : [EOL] tag = XML . SubElement ( tags , [string] ) [EOL] tag . text = t [EOL] text = XML . SubElement ( post , [string] ) [EOL] text . text = self . rst_text [EOL] post . tail = [string] [EOL] return post [EOL] [EOL] [EOL] travel5 = Blog_E ( [string] ) [EOL] travel5 . append ( Post_E ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) ) [EOL] travel5 . append ( Post_E ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) ) [EOL] [EOL] test_xml_out_2 = [string] [EOL] [EOL] def build_blog ( document ) : [EOL] xml_blog = document . getroot ( ) [EOL] blog = Blog_X ( xml_blog . findtext ( [string] ) ) [EOL] for xml_post in xml_blog . findall ( [string] ) : [EOL] optional_tag_iter = ( t . text for t in xml_post . findall ( [string] ) ) [EOL] tags = list ( filter ( None , optional_tag_iter ) ) [EOL] post = Post_X ( date = datetime . datetime . strptime ( xml_post . findtext ( [string] ) , [string] ) , title = xml_post . findtext ( [string] ) , tags = tags , rst_text = xml_post . findtext ( [string] ) , ) [EOL] blog . append ( post ) [EOL] return blog [EOL] [EOL] test_xml_in = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $xml.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import unittest [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] from Chapter_12 . ch12_ex4 import Base , Blog , Post , Tag , assoc_post_tag [EOL] import datetime [EOL] [EOL] [EOL] import sqlalchemy . exc [EOL] from sqlalchemy import create_engine [EOL] [EOL] [EOL] def build_test_db ( name = [string] ) : [EOL] [docstring] [EOL] engine = create_engine ( name , echo = True ) [EOL] Base . metadata . drop_all ( engine ) [EOL] Base . metadata . create_all ( engine ) [EOL] return engine [EOL] [EOL] [EOL] [comment] [EOL] [EOL] from sqlalchemy . orm import sessionmaker , Session [EOL] [EOL] [EOL] class Test_Blog_Queries ( unittest . TestCase ) : [EOL] [EOL] Session = ... [EOL] session = ... [EOL] [EOL] @ staticmethod def setUpClass ( ) : [EOL] engine = build_test_db ( ) [EOL] Test_Blog_Queries . Session = sessionmaker ( bind = engine ) [EOL] session = Test_Blog_Queries . Session ( ) [EOL] [EOL] tag_rr = Tag ( phrase = [string] ) [EOL] session . add ( tag_rr ) [EOL] tag_w42 = Tag ( phrase = [string] ) [EOL] session . add ( tag_w42 ) [EOL] tag_icw = Tag ( phrase = [string] ) [EOL] session . add ( tag_icw ) [EOL] tag_mis = Tag ( phrase = [string] ) [EOL] session . add ( tag_mis ) [EOL] [EOL] blog1 = Blog ( title = [string] ) [EOL] session . add ( blog1 ) [EOL] b1p1 = Post ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , blog = blog1 , tags = [ tag_rr , tag_w42 , tag_icw ] , ) [EOL] session . add ( b1p1 ) [EOL] b1p2 = Post ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , blog = blog1 , tags = [ tag_rr , tag_w42 , tag_mis ] , ) [EOL] session . add ( b1p2 ) [EOL] [EOL] blog2 = Blog ( title = [string] ) [EOL] session . add ( blog2 ) [EOL] session . commit ( ) [EOL] [EOL] def setUp ( self ) : [EOL] self . session = Test_Blog_Queries . Session ( ) [EOL] [EOL] def test_query_eqTitle_should_return1Blog ( self ) : [EOL] [docstring] [EOL] results = self . session . query ( Blog ) . filter ( Blog . title == [string] ) . all ( ) [EOL] self . assertEqual ( [number] , len ( results ) ) [EOL] self . assertEqual ( [number] , len ( results [ [number] ] . entries ) ) [EOL] [EOL] def test_query_likeTitle_should_return2Blog ( self ) : [EOL] [docstring] [EOL] results = self . session . query ( Blog ) . filter ( Blog . title . like ( [string] ) ) . all ( ) [EOL] self . assertEqual ( [number] , len ( results ) ) [EOL] [EOL] def test_query_eqW42_tag_should_return2Post ( self ) : [EOL] results = self . session . query ( Post ) . join ( assoc_post_tag ) . join ( Tag ) . filter ( Tag . phrase == [string] ) . all ( ) [EOL] self . assertEqual ( [number] , len ( results ) ) [EOL] [EOL] def test_query_eqICW_tag_should_return1Post ( self ) : [EOL] results = self . session . query ( Post ) . join ( assoc_post_tag ) . join ( Tag ) . filter ( Tag . phrase == [string] ) . all ( ) [EOL] [comment] [EOL] self . assertEqual ( [number] , len ( results ) ) [EOL] self . assertEqual ( [string] , results [ [number] ] . title ) [EOL] self . assertEqual ( [string] , results [ [number] ] . blog . title ) [EOL] self . assertEqual ( set ( [ [string] , [string] , [string] ] ) , set ( t . phrase for t in results [ [number] ] . tags ) , ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def suite8 ( ) : [EOL] s = unittest . TestSuite ( ) [EOL] s . addTests ( unittest . defaultTestLoader . loadTestsFromTestCase ( Test_Blog_Queries ) ) [EOL] return s [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] t = unittest . TextTestRunner ( ) [EOL] t . run ( suite8 ( ) ) [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $Test_Blog_Queries.Session$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import timeit [EOL] [EOL] def performance ( ) : [EOL] list_time = timeit . timeit ( [string] , [string] ) [EOL] set_time = timeit . timeit ( [string] , [string] ) [EOL] print ( f" [string] { list_time : [string] } [string] { set_time : [string] }" ) [EOL] [EOL] [comment] [EOL] [EOL] list_2_time = timeit . timeit ( [string] , [string] ) [EOL] dict_time = timeit . timeit ( [string] , [string] ) [EOL] print ( f" [string] { list_2_time : [string] } [string] { dict_time : [string] }" ) [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( verbose = False ) [EOL] [EOL] performance ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , Dict , Iterator , Any , TypeVar , Iterable [EOL] import typing [EOL] import builtins [EOL] import Chapter_7 [EOL] [docstring] [EOL] from typing import List , cast , Any , Optional , Iterable , overload , Union , Iterator [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import math [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import collections . abc [EOL] import weakref [EOL] from abc import ABCMeta , abstractmethod [EOL] from typing import TypeVar , Any [EOL] [EOL] [EOL] class Comparable ( metaclass = ABCMeta ) : [EOL] [EOL] @ abstractmethod def __lt__ ( self , other ) : [EOL] ... [EOL] [EOL] def __ge__ ( self , other ) : [EOL] ... [EOL] [EOL] [EOL] [comment] [EOL] NodeItem = TypeVar ( [string] , bound = Comparable ) [EOL] [EOL] [EOL] class TreeNode : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , item , less = None , more = None , parent = None , ) : [EOL] self . item = item [EOL] self . less = less [EOL] self . more = more [EOL] if parent : [EOL] [comment] [EOL] self . parent = parent [EOL] [EOL] @ property def parent ( self ) : [EOL] return self . parent_ref ( ) [EOL] [EOL] @ parent . setter def parent ( self , value ) : [EOL] self . parent_ref = weakref . ref ( value ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . item !r} [string] { self . less !r} [string] { self . more !r} [string] " [EOL] [EOL] def find ( self , item ) : [EOL] if self . item is None : [comment] [EOL] if self . more : [EOL] return self . more . find ( item ) [EOL] elif self . item == item : [EOL] return self [EOL] elif self . item > item and self . less : [EOL] return self . less . find ( item ) [EOL] elif self . item < item and self . more : [EOL] return self . more . find ( item ) [EOL] raise KeyError [EOL] [EOL] def __iter__ ( self ) : [EOL] if self . less : [EOL] yield from self . less [EOL] if self . item : [EOL] yield self . item [EOL] if self . more : [EOL] yield from self . more [EOL] [EOL] def add ( self , item ) : [EOL] if self . item is None : [comment] [EOL] if self . more : [EOL] self . more . add ( item ) [EOL] else : [EOL] self . more = TreeNode ( item , parent = self ) [EOL] elif self . item >= item : [EOL] if self . less : [EOL] self . less . add ( item ) [EOL] else : [EOL] self . less = TreeNode ( item , parent = self ) [EOL] elif self . item < item : [EOL] if self . more : [EOL] self . more . add ( item ) [EOL] else : [EOL] self . more = TreeNode ( item , parent = self ) [EOL] [EOL] def remove ( self , item ) : [EOL] [comment] [EOL] if self . item is None or item > self . item : [EOL] if self . more : [EOL] self . more . remove ( item ) [EOL] else : [EOL] raise KeyError [EOL] elif item < self . item : [EOL] if self . less : [EOL] self . less . remove ( item ) [EOL] else : [EOL] raise KeyError [EOL] else : [comment] [EOL] if self . less and self . more : [comment] [EOL] successor = self . more . _least ( ) [EOL] self . item = successor . item [EOL] if successor . item : [EOL] successor . remove ( successor . item ) [EOL] elif self . less : [comment] [EOL] self . _replace ( self . less ) [EOL] elif self . more : [comment] [EOL] self . _replace ( self . more ) [EOL] else : [comment] [EOL] self . _replace ( None ) [EOL] [EOL] def _least ( self ) : [EOL] if self . less is None : [EOL] return self [EOL] return self . less . _least ( ) [EOL] [EOL] def _replace ( self , new = None ) : [EOL] if self . parent : [EOL] if self == self . parent . less : [EOL] self . parent . less = new [EOL] else : [EOL] self . parent . more = new [EOL] if new is not None : [EOL] new . parent = self . parent [EOL] [EOL] [EOL] class Tree ( collections . abc . MutableSet ) : [EOL] [EOL] def __init__ ( self , source = None ) : [EOL] self . root = TreeNode ( None ) [EOL] self . size = [number] [EOL] if source : [EOL] for item in source : [EOL] self . root . add ( item ) [EOL] self . size += [number] [EOL] [EOL] def add ( self , item ) : [EOL] self . root . add ( item ) [EOL] self . size += [number] [EOL] [EOL] def discard ( self , item ) : [EOL] if self . root . more : [EOL] try : [EOL] self . root . more . remove ( item ) [EOL] self . size -= [number] [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] pass [EOL] [EOL] def __contains__ ( self , item ) : [EOL] if self . root . more : [EOL] self . root . more . find ( cast ( Comparable , item ) ) [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] def __iter__ ( self ) : [EOL] if self . root . more : [EOL] for item in iter ( self . root . more ) : [EOL] yield item [EOL] [comment] [EOL] [EOL] def __len__ ( self ) : [EOL] return self . size [EOL] [EOL] [EOL] test_tree = [string] [EOL] [EOL] test_tree_256_randomized_insert_delete = [string] [EOL] [EOL] test_tree_merge = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( verbose = False ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[Comparable]$ 0 0 0 0 0 0 0 $Chapter_7.ch07_ex3.TreeNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[Comparable]$ 0 0 0 0 0 $typing.Iterable[Comparable]$ 0 0 0 0 $Chapter_7.ch07_ex3.TreeNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Comparable$ 0 0 0 0 0 0 0 0 0 $Comparable$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Comparable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Comparable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[Comparable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Union , Optional , Dict , Any , Iterable [EOL] import typing [EOL] import builtins [EOL] import Chapter_7 [EOL] [docstring] [EOL] from typing import List , cast , Any , Optional , Iterable , overload , Union , Iterator [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import math [EOL] [EOL] [EOL] def mean ( outcomes ) : [EOL] return sum ( outcomes ) / len ( outcomes ) [EOL] [EOL] [EOL] def stdev ( outcomes ) : [EOL] n = float ( len ( outcomes ) ) [EOL] return math . sqrt ( n * sum ( x ** [number] for x in outcomes ) - sum ( outcomes ) ** [number] ) / n [EOL] [EOL] [EOL] test_stats = [string] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class StatsList ( list ) : [EOL] [EOL] def __init__ ( self , iterable ) : [EOL] super ( ) . __init__ ( cast ( Iterable [ Any ] , iterable ) ) [EOL] [EOL] @ property def mean ( self ) : [EOL] return sum ( self ) / len ( self ) [EOL] [EOL] @ property def stdev ( self ) : [EOL] n = len ( self ) [EOL] return math . sqrt ( n * sum ( x ** [number] for x in self ) - sum ( self ) ** [number] ) / n [EOL] [EOL] [EOL] test_lazy_stats_list = [string] [EOL] [EOL] import random [EOL] [EOL] [EOL] def data_gen ( ) : [EOL] return random . randint ( [number] , [number] ) + random . randint ( [number] , [number] ) [EOL] [EOL] [EOL] def demo_statslist ( ) : [EOL] [docstring] [EOL] random . seed ( [number] ) [EOL] data = [ data_gen ( ) for _ in range ( [number] ) ] [EOL] stats = StatsList ( data ) [EOL] print ( f" [string] { stats . mean : [string] }" ) [EOL] print ( f" [string] { stats . stdev : [string] }" ) [EOL] [EOL] [EOL] class Explore ( list ) : [EOL] [EOL] [comment] [EOL] def __getitem__ ( self , index ) : [EOL] print ( index , index . indices ( len ( self ) ) ) [EOL] return super ( ) . __getitem__ ( index ) [EOL] [EOL] [EOL] test_explore = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class StatsList2 ( list ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , iterable ) : [EOL] self . sum0 = [number] [comment] [EOL] self . sum1 = [number] [comment] [EOL] self . sum2 = [number] [comment] [EOL] super ( ) . __init__ ( cast ( Iterable [ Any ] , iterable ) ) [EOL] for x in self : [EOL] self . _new ( x ) [EOL] [EOL] def _new ( self , value ) : [EOL] self . sum0 += [number] [EOL] self . sum1 += value [EOL] self . sum2 += value * value [EOL] [EOL] def _rmv ( self , value ) : [EOL] self . sum0 -= [number] [EOL] self . sum1 -= value [EOL] self . sum2 -= value * value [EOL] [EOL] def insert ( self , index , value ) : [EOL] super ( ) . insert ( index , value ) [EOL] self . _new ( value ) [EOL] [EOL] def pop ( self , index = [number] ) : [EOL] value = super ( ) . pop ( index ) [EOL] self . _rmv ( value ) [EOL] return value [EOL] [EOL] def append ( self , value ) : [EOL] super ( ) . append ( value ) [EOL] self . _new ( value ) [EOL] [EOL] def extend ( self , sequence ) : [EOL] super ( ) . extend ( sequence ) [EOL] for value in sequence : [EOL] self . _new ( value ) [EOL] [EOL] def remove ( self , value ) : [EOL] super ( ) . remove ( value ) [EOL] self . _rmv ( value ) [EOL] [EOL] def __iadd__ ( self , sequence ) : [EOL] for v in sequence : [EOL] self . append ( v ) [EOL] return self [EOL] [EOL] def __add__ ( self , sequence ) : [EOL] generic = super ( ) . __add__ ( cast ( StatsList2 , sequence ) ) [EOL] result = StatsList2 ( generic ) [EOL] return result [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ property def mean ( self ) : [EOL] return self . sum1 / self . sum0 [EOL] [EOL] @ property def stdev ( self ) : [EOL] return math . sqrt ( self . sum0 * self . sum2 - self . sum1 * self . sum1 ) / self . sum0 [EOL] [EOL] @ overload def __setitem__ ( self , index , value ) : [EOL] ... [EOL] [EOL] @ overload def __setitem__ ( self , index , value ) : [EOL] ... [EOL] [EOL] def __setitem__ ( self , index , value ) : [EOL] if isinstance ( index , slice ) : [EOL] start , stop , step = index . indices ( len ( self ) ) [EOL] olds = [ self [ i ] for i in range ( start , stop , step ) ] [EOL] super ( ) . __setitem__ ( index , value ) [EOL] for x in olds : [EOL] self . _rmv ( x ) [EOL] for x in value : [EOL] self . _new ( x ) [EOL] else : [EOL] old = self [ index ] [EOL] super ( ) . __setitem__ ( index , value ) [EOL] self . _rmv ( old ) [EOL] self . _new ( value ) [EOL] [EOL] def __delitem__ ( self , index ) : [EOL] [comment] [EOL] if isinstance ( index , slice ) : [EOL] start , stop , step = index . indices ( len ( self ) ) [EOL] olds = [ self [ i ] for i in range ( start , stop , step ) ] [EOL] super ( ) . __delitem__ ( index ) [EOL] for x in olds : [EOL] self . _rmv ( x ) [EOL] else : [EOL] old = self [ index ] [EOL] super ( ) . __delitem__ ( index ) [EOL] self . _rmv ( old ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] test_eager_stats_list = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class StatsList3 : [EOL] [EOL] def __init__ ( self ) : [EOL] self . _list = list ( ) [EOL] self . sum0 = [number] [comment] [EOL] self . sum1 = [number] [comment] [EOL] self . sum2 = [number] [comment] [EOL] [EOL] def append ( self , value ) : [EOL] self . _list . append ( value ) [EOL] self . sum0 += [number] [EOL] self . sum1 += value [EOL] self . sum2 += value * value [EOL] [EOL] [comment] [EOL] [EOL] def __getitem__ ( self , index ) : [EOL] return self . _list . __getitem__ ( index ) [EOL] [EOL] @ property def mean ( self ) : [EOL] return self . sum1 / self . sum0 [EOL] [EOL] @ property def stdev ( self ) : [EOL] return math . sqrt ( self . sum0 * self . sum2 - self . sum1 * self . sum1 ) / self . sum0 [EOL] [EOL] [EOL] test_wrapper_stats_list = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] import math [EOL] from collections import Counter [EOL] [EOL] [EOL] class StatsCounter ( Counter ) : [EOL] [EOL] @ property def mean ( self ) : [EOL] sum0 = sum ( v for k , v in self . items ( ) ) [EOL] sum1 = sum ( k * v for k , v in self . items ( ) ) [EOL] return sum1 / sum0 [EOL] [EOL] @ property def stdev ( self ) : [EOL] sum0 = sum ( v for k , v in self . items ( ) ) [EOL] sum1 = sum ( k * v for k , v in self . items ( ) ) [EOL] sum2 = sum ( k * k * v for k , v in self . items ( ) ) [EOL] return math . sqrt ( sum0 * sum2 - sum1 * sum1 ) / sum0 [EOL] [EOL] @ property def median ( self ) : [EOL] all = list ( sorted ( self . elements ( ) ) ) [EOL] return all [ len ( all ) // [number] ] [EOL] [EOL] @ property def median2 ( self ) : [EOL] mid = sum ( self . values ( ) ) // [number] [EOL] low = [number] [EOL] for k , v in sorted ( self . items ( ) ) : [EOL] if low <= mid < low + v : [EOL] return k [EOL] low += v [EOL] return None [EOL] [EOL] [EOL] test_stats_counter = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.Iterable[builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Iterable[builtins.float]]$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.Iterable[builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Iterable[builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $None$ 0 0 0 $typing.Iterable[builtins.float]$ 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.float]$ 0 0 0 0 0 $typing.Iterable[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $"StatsList2"$ 0 0 0 $typing.Iterable[builtins.float]$ 0 0 0 0 0 0 $typing.Iterable[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"StatsList2"$ 0 0 0 $typing.Iterable[builtins.float]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.float]$ 0 0 0 $Chapter_7.ch07_ex2.StatsList2$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $Chapter_7.ch07_ex2.StatsList2$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Type , List , Union , Optional , DefaultDict , Dict , Any , Iterator [EOL] import typing [EOL] import builtins [EOL] import Chapter_15 [EOL] [docstring] [EOL] from typing import ( NamedTuple , List , Type , Optional , Iterator , Tuple , DefaultDict , Union , cast , Any , ) [EOL] import random [EOL] from collections import defaultdict [EOL] [EOL] [comment] [EOL] [EOL] from typing import NamedTuple [EOL] [EOL] [EOL] class Domino_1 ( NamedTuple ) : [EOL] v1 = ... [EOL] v2 = ... [EOL] [EOL] @ property def double ( self ) : [EOL] return self . v1 == self . v2 [EOL] [EOL] @ property def score ( self ) : [EOL] return self . v1 + self . v2 [EOL] [EOL] [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] @ dataclass ( frozen = True , eq = True , order = True ) class Domino_2 : [EOL] v1 = ... [EOL] v2 = ... [EOL] [EOL] @ property def double ( self ) : [EOL] return self . v1 == self . v2 [EOL] [EOL] @ property def score ( self ) : [EOL] return self . v1 + self . v2 [EOL] [EOL] [EOL] Domino = Union [ Domino_1 , Domino_2 ] [EOL] [EOL] [EOL] def builder ( v1 , v2 ) : [EOL] return Domino_2 ( v1 , v2 ) [EOL] [EOL] [EOL] test_dominoe_classes = [string] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Hand ( list ) : [EOL] [EOL] def __init__ ( self , * args ) : [EOL] super ( ) . __init__ ( cast ( Tuple [ Any ] , args ) ) [EOL] [EOL] def score ( self ) : [EOL] return sum ( d . score for d in self ) [EOL] [EOL] def rank ( self ) : [EOL] self . sort ( key = lambda d : d . score , reverse = True ) [EOL] [EOL] def doubles ( self ) : [EOL] return [ d for d in self if d . double ] [EOL] [EOL] def highest_double ( self ) : [EOL] descending = sorted ( self . doubles ( ) , key = lambda d : d . v1 , reverse = True ) [EOL] if descending : [EOL] return descending [ [number] ] [EOL] return None [EOL] [EOL] [EOL] class DominoBoneYard : [EOL] [EOL] domino_class = Domino_1 [EOL] [EOL] hand_class = Hand [EOL] [EOL] hand_size = [number] [EOL] [EOL] def __init__ ( self , limit = [number] ) : [EOL] self . _dominoes = [ self . domino_class ( x , y ) for x in range ( limit + [number] ) for y in range ( x + [number] ) ] [EOL] random . shuffle ( self . _dominoes ) [EOL] [EOL] def draw ( self , n = [number] ) : [EOL] deal , remainder = self . _dominoes [ : n ] , self . _dominoes [ n : ] [EOL] if len ( deal ) != n : [EOL] return None [EOL] self . _dominoes = remainder [EOL] return deal [EOL] [EOL] def hand_iter ( self , players = [number] ) : [EOL] hands = [ self . draw ( self . hand_size ) for _ in range ( players ) ] [EOL] if not all ( hands ) : [EOL] raise ValueError ( f" [string] { self . hand_size } [string] { players } [string] " ) [EOL] yield from ( self . hand_class ( * h ) for h in hands if h is not None ) [EOL] [EOL] [EOL] test_dby = [string] [EOL] [EOL] test_dby_exception = [string] [EOL] [EOL] [EOL] class Hand_X1 ( Hand ) : [EOL] [EOL] def __init__ ( self , * args ) : [EOL] super ( ) . __init__ ( * args ) [EOL] self . end = defaultdict ( list ) [EOL] for d in self : [EOL] self . end [ d . v1 ] . append ( d ) [EOL] self . end [ d . v2 ] . append ( d ) [EOL] [EOL] def matches ( self , spots ) : [EOL] return self . end . get ( spots , [ ] ) [EOL] [EOL] [EOL] test_dby_3 = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $Domino$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $Domino$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Domino$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Domino_1]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Domino_1]$ 0 0 0 0 0 $typing.List[Chapter_15.ch15_ex2.Domino_1]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Chapter_15.ch15_ex2.Domino_1]$ 0 0 0 $typing.List[Chapter_15.ch15_ex2.Domino_1]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Domino]$ 0 0 0 0 $typing.Type[Hand]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[Domino]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Domino]$ 0 0 0 0 $typing.Optional[typing.List[Domino]]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[Chapter_15.ch15_ex2.Domino_1,Chapter_15.ch15_ex2.Domino_2]]$ 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Union[Chapter_15.ch15_ex2.Domino_1,Chapter_15.ch15_ex2.Domino_2]]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Union[Chapter_15.ch15_ex2.Domino_1,Chapter_15.ch15_ex2.Domino_2]]$ 0 0 0 0 0 0 0 0 $typing.Iterator[Hand]$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Optional[typing.List[Domino]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Optional[typing.List[Domino]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[typing.List[Domino]]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.int,typing.List[Domino_1]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.int,typing.List[Domino_1]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.int,typing.List[Domino_1]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Domino_1]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] import numbers [EOL] import decimal [EOL] import collections . abc [EOL] [EOL] test_membership = [string] [EOL] [EOL] test_iterator = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] def combinations ( n , k ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] assert k <= n [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def fact ( a ) : [EOL] if a == [number] : return [number] [EOL] return a * fact ( a - [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return fact ( n ) // ( fact ( k ) * fact ( n - k ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] from pytest import * [EOL] from ch20_ex1 import * [EOL] [EOL] def test_card_factory ( ) : [EOL] c_3h = card ( [number] , Suit . Heart ) [EOL] assert str ( c_3h ) == [string] [EOL] c_1h = card ( [number] , Suit . Heart ) [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Dict , Optional [EOL] import typing [EOL] import Chapter_20 [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from enum import Enum [EOL] from typing import Optional [EOL] [EOL] [EOL] class Suit ( str , Enum ) : [EOL] [docstring] [EOL] Club = [string] [EOL] Diamond = [string] [EOL] Heart = [string] [EOL] Spade = [string] [EOL] [EOL] [EOL] class Card : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , rank , suit , hard , soft = None ) : [EOL] [docstring] [EOL] self . rank = rank [EOL] self . suit = suit [EOL] self . hard = hard [EOL] self . soft = soft if soft is not None else hard [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . rank }{ self . suit }" [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . rank } [string] { self . suit } [string] " [EOL] [EOL] [EOL] class FaceCard ( Card ) : [EOL] [docstring] [EOL] rank_str = { [number] : [string] , [number] : [string] , [number] : [string] } [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . rank_str [ self . rank ] }{ self . suit }" [EOL] [EOL] [EOL] class AceCard ( Card ) : [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . suit }" [EOL] [EOL] [EOL] def card ( rank , suit ) : [EOL] [docstring] [EOL] if rank == [number] : [EOL] return AceCard ( rank , suit , [number] , [number] ) [EOL] elif [number] <= rank < [number] : [EOL] return Card ( rank , suit , rank ) [EOL] elif [number] <= rank < [number] : [EOL] return FaceCard ( rank , suit , [number] ) [EOL] else : [EOL] raise TypeError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $Chapter_20.src.ch20_ex1.Suit$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $Chapter_20.src.ch20_ex1.Suit$ 0 $Chapter_20.src.ch20_ex1.Suit$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Card$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Tuple , Dict , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Tuple [EOL] [EOL] [EOL] class Card : [EOL] [EOL] def __init__ ( self , rank , suit ) : [EOL] self . suit = suit [EOL] self . rank = rank [EOL] self . hard , self . soft = self . _points ( ) [EOL] [EOL] def _points ( self ) : [EOL] return int ( self . rank ) , int ( self . rank ) [EOL] [EOL] [EOL] class AceCard ( Card ) : [EOL] [EOL] def _points ( self ) : [EOL] return [number] , [number] [EOL] [EOL] [EOL] class FaceCard ( Card ) : [EOL] [EOL] def _points ( self ) : [EOL] return [number] , [number] [EOL] [EOL] [EOL] test_card = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] from typing import Tuple , List , Optional , Dict , Any , Generator [EOL] import typing [EOL] import builtins [EOL] import argparse [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] from collections import ChainMap [EOL] from typing import Optional , cast , Dict , Any , List , Type [EOL] from pathlib import Path [EOL] import yaml [EOL] import sys [EOL] import os [EOL] import argparse [EOL] [EOL] from Chapter_18 . ch18_ex1 import get_options_1 [EOL] [EOL] [EOL] def nint ( x ) : [EOL] if x is None : [EOL] return x [EOL] return int ( x ) [EOL] [EOL] [EOL] def get_options_2 ( argv = sys . argv [ [number] : ] ) : [EOL] [docstring] [EOL] [comment] [EOL] config_locations = ( Path . cwd ( ) , Path . home ( ) , Path . cwd ( ) / [string] , Path ( __file__ ) / [string] , ) [EOL] [EOL] candidate_paths = ( dir / [string] for dir in config_locations ) [EOL] config_paths = ( path for path in candidate_paths if path . exists ( ) ) [EOL] files_values = [ yaml . load ( str ( path ) ) for path in config_paths ] [EOL] [EOL] [comment] [EOL] env_settings = [ ( [string] , nint ( os . environ . get ( [string] , None ) ) ) , ( [string] , nint ( os . environ . get ( [string] , None ) ) ) , ( [string] , nint ( os . environ . get ( [string] , None ) ) ) , ] [EOL] env_values = { k : v for k , v in env_settings if v is not None } [EOL] [EOL] [comment] [EOL] defaults = argparse . Namespace ( ** ChainMap ( env_values , * files_values ) ) [EOL] [EOL] [comment] [EOL] return get_options_1 ( argv , defaults ) [EOL] [EOL] [EOL] test_env_override = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] import sys [EOL] print ( sys . argv ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import sqlite3 [EOL] import decimal [EOL] [EOL] [EOL] def adapt_currency ( value ) : [EOL] return str ( value ) [EOL] [EOL] [EOL] sqlite3 . register_adapter ( decimal . Decimal , adapt_currency ) [EOL] [EOL] [EOL] def convert_currency ( bytes ) : [EOL] return decimal . Decimal ( bytes . decode ( ) ) [EOL] [EOL] [EOL] sqlite3 . register_converter ( [string] , convert_currency ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] decimal_cleanup = [string] [EOL] [EOL] decimal_ddl = [string] [EOL] insert_budget = [string] [EOL] query_budget = [string] [EOL] [EOL] test_decimal = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type , Dict , Tuple , Any [EOL] import Chapter_16 [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Type [EOL] import logging [EOL] import sys [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def log_to ( * names ) : [EOL] if len ( names ) == [number] : [EOL] names = ( [string] , ) [EOL] [EOL] def concrete_log_to ( cls ) : [EOL] for log_name in names : [EOL] setattr ( cls , log_name , logging . getLogger ( f"{ log_name } [string] { cls . __qualname__ }" ) ) [EOL] return cls [EOL] [EOL] return concrete_log_to [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ log_to ( [string] , [string] ) class Player : [EOL] def __init__ ( self , bet , strategy , stake ) : [EOL] self . audit . info ( f" [string] { stake : [string] }" ) [EOL] self . verbose . info ( f" [string] { bet : [string] } [string] { strategy : [string] } [string] { stake : [string] }" ) [EOL] [EOL] [comment] [EOL] [EOL] @ log_to ( [string] ) class Table : [EOL] def add_player ( self , player ) : [EOL] self . security . info ( f" [string] { player }" ) [EOL] [EOL] [comment] [EOL] [EOL] logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG , style = [string] ) [EOL] [EOL] print ( [string] ) [EOL] p3 = Player ( [string] , [string] , [number] ) [EOL] t = Table ( ) [EOL] t . add_player ( p3 ) [EOL] [EOL] logging . shutdown ( ) [EOL] [EOL] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Type , Dict , Any [EOL] import logging [EOL] import typing [EOL] import Chapter_16 [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Type [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Player : [EOL] [EOL] def __init__ ( self , bet , strategy , stake ) : [EOL] self . logger = logging . getLogger ( self . __class__ . __qualname__ ) [EOL] self . logger . debug ( [string] , bet , strategy , stake ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def logged ( cls ) : [EOL] cls . logger = logging . getLogger ( cls . __qualname__ ) [EOL] return cls [EOL] [EOL] [EOL] import logging [EOL] import sys [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] logging . addLevelName ( [number] , [string] ) [EOL] VERBOSE = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class Player_2 : [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , bet , strategy , stake ) : [EOL] self . logger . debug ( [string] , bet , strategy , stake ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class LoggedClassMeta ( type ) : [EOL] [EOL] def __new__ ( cls , name , bases , namespace , ** kwds ) : [EOL] result = type . __new__ ( cls , name , bases , dict ( namespace ) ) [EOL] result . logger = logging . getLogger ( result . __qualname__ ) [EOL] return result [EOL] [EOL] [EOL] class LoggedClass ( metaclass = LoggedClassMeta ) : [EOL] logger = ... [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Player_3 ( LoggedClass ) : [EOL] [EOL] def __init__ ( self , bet , strategy , stake ) : [EOL] self . logger . debug ( [string] , bet , strategy , stake ) [EOL] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL] [EOL] [comment] [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . info ( [string] ) [EOL] p2 = Player_2 ( [string] , [string] , [number] ) [EOL] logger . info ( [string] ) [EOL] p3 = Player_3 ( [string] , [string] , [number] ) [EOL] [EOL] [comment] [EOL] logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG ) [EOL] [EOL] loggerc = logging . getLogger ( [string] ) [EOL] loggerc . info ( [string] ) [EOL] pc = Player ( [string] , [string] , [number] ) [EOL] loggerc . info ( [string] ) [EOL] pc2 = Player_2 ( [string] , [string] , [number] ) [EOL] loggerc . info ( [string] ) [EOL] pc3 = Player_3 ( [string] , [string] , [number] ) [EOL] [EOL] logging . shutdown ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type , Dict , Callable , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Callable , Dict [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] IntExp = Callable [ [ int , int ] , int ] [EOL] [EOL] class Power1 : [EOL] [EOL] def __call__ ( self , x , n ) : [EOL] p = [number] [EOL] for i in range ( n ) : [EOL] p *= x [EOL] return p [EOL] [EOL] pow1 = Power1 ( ) [EOL] [EOL] test_power1 = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from collections . abc import Callable as CallableClass [EOL] class Power2 ( CallableClass ) : [comment] [EOL] [EOL] def __call_ ( self , x , n ) : [EOL] p = [number] [EOL] for i in range ( n ) : [EOL] p *= x [EOL] return p [EOL] [EOL] test_power2 = [string] [EOL] [EOL] [comment] [EOL] class Power3 : [EOL] [EOL] def __call_ ( self , x , n ) : [EOL] p = [number] [EOL] for i in range ( n ) : [EOL] p *= x [EOL] return p [EOL] [EOL] [comment] [EOL] [comment] [EOL] pow3 = Power3 ( ) [EOL] [EOL] test_power3 = [string] [EOL] [EOL] class Power4 : [EOL] [EOL] def __call__ ( self , x , n ) : [EOL] if n == [number] : [EOL] return [number] [EOL] elif n % [number] == [number] : [EOL] return self . __call__ ( x , n - [number] ) * x [EOL] else : [comment] [EOL] t = self . __call__ ( x , n // [number] ) [EOL] return t * t [EOL] [EOL] pow4 = Power4 ( ) [EOL] [EOL] test_power4 = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Power4i : [EOL] [EOL] def __call__ ( self , x , n ) : [EOL] p = [number] [EOL] while n != [number] : [EOL] if n % [number] == [number] : [EOL] p *= x [EOL] n -= [number] [EOL] else : [comment] [EOL] t = self . __call__ ( x , n // [number] ) [EOL] p *= t [EOL] p *= t [EOL] n = [number] [EOL] return p [EOL] [EOL] pow4i = Power4i ( ) [EOL] [EOL] test_power4i = [string] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Power5 : [EOL] [EOL] def __init__ ( self ) : [EOL] self . memo = { } [EOL] [EOL] def __call__ ( self , x , n ) : [EOL] if ( x , n ) not in self . memo : [EOL] if n == [number] : [EOL] self . memo [ x , n ] = [number] [EOL] elif n % [number] == [number] : [EOL] self . memo [ x , n ] = self . __call__ ( x , n - [number] ) * x [EOL] elif n % [number] == [number] : [EOL] t = self . __call__ ( x , n // [number] ) [EOL] self . memo [ x , n ] = t * t [EOL] else : [EOL] raise Exception ( [string] ) [EOL] return self . memo [ x , n ] [EOL] [EOL] pow5 = Power5 ( ) [EOL] [EOL] test_power5 = [string] [EOL] [EOL] [comment] [EOL] from functools import lru_cache [EOL] [EOL] @ lru_cache ( ) def pow6 ( x , n ) : [EOL] if n == [number] : [EOL] return [number] [EOL] elif n % [number] == [number] : [EOL] return pow6 ( x , n - [number] ) * x [EOL] else : [comment] [EOL] t = pow6 ( x , n // [number] ) [EOL] return t * t [EOL] [EOL] test_power6 = [string] [EOL] [EOL] [EOL] def performance ( ) : [EOL] [docstring] [EOL] import timeit [EOL] [EOL] iterative = timeit . timeit ( [string] , [string] , number = [number] , ) [comment] [EOL] print ( [string] , iterative ) [EOL] [EOL] recursive = timeit . timeit ( [string] , [string] , number = [number] , ) [EOL] print ( [string] , recursive ) [EOL] [EOL] memoized = timeit . timeit ( [string] , [string] , number = [number] , ) [EOL] print ( [string] , memoized ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class BettingStrategy : [EOL] [EOL] def __init__ ( self ) : [EOL] self . _win = [number] [EOL] self . _loss = [number] [EOL] [EOL] @ property def win ( self ) : [EOL] return self . _win [EOL] [EOL] @ win . setter def win ( self , value ) : [EOL] self . _win = value [EOL] self . stage = [number] [EOL] [EOL] @ property def loss ( self ) : [EOL] return self . _loss [EOL] [EOL] @ loss . setter def loss ( self , value ) : [EOL] self . _loss = value [EOL] [EOL] def __call__ ( self ) : [EOL] return [number] [EOL] [EOL] test_flat_betting_strategy = [string] [EOL] [EOL] [comment] [EOL] class BettingMartingale ( BettingStrategy ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . _win = [number] [EOL] self . _loss = [number] [EOL] self . stage = [number] [EOL] [EOL] @ property def win ( self ) : [EOL] return self . _win [EOL] [EOL] @ win . setter def win ( self , value ) : [EOL] self . _win = value [EOL] self . stage = [number] [EOL] [EOL] @ property def loss ( self ) : [EOL] return self . _loss [EOL] [EOL] @ loss . setter def loss ( self , value ) : [EOL] self . _loss = value [EOL] self . stage *= [number] [EOL] [EOL] def __call__ ( self ) : [EOL] return self . stage [EOL] [EOL] test_martingale_betting_strategy = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class BettingMartingale2 ( BettingStrategy ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . win = [number] [EOL] self . loss = [number] [EOL] self . stage = [number] [EOL] [EOL] def __setattr__ ( self , name , value ) : [EOL] if name == [string] : [EOL] self . stage = [number] [EOL] elif name == [string] : [EOL] self . stage *= [number] [EOL] super ( ) . __setattr__ ( name , value ) [EOL] [EOL] def __call__ ( self ) : [EOL] return self . stage [EOL] [EOL] test_martingale2_betting_strategy = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( verbose = False ) [EOL] [EOL] [comment] [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] def F ( n ) : [EOL] if n in ( [number] , [number] ) : [EOL] return [number] [EOL] else : [EOL] return F ( n - [number] ) + F ( n - [number] ) [EOL] [EOL] test_F_8 = [string] [EOL] [EOL] def demo ( ) : [EOL] print ( [string] , F ( [number] ) ) [EOL] print ( [string] , F ( [number] / [number] ) ) [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] test_list = [string] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] import timeit [EOL] [EOL] method_time = timeit . timeit ( [string] , [string] , ) [EOL] [EOL] function_time = timeit . timeit ( [string] , [string] , ) [EOL] [EOL] if __name__ == [string] : [EOL] print ( f" [string] { method_time : [string] }" ) [EOL] print ( f" [string] { function_time : [string] }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0
[comment] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def factorial ( n ) : [EOL] [docstring] [EOL] if n == [number] : [EOL] return [number] [EOL] return n * factorial ( n - [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Dict , List , Generator , Any [EOL] import Chapter_11 [EOL] import typing [EOL] import shelve [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Dict , Any , Optional [EOL] from collections import defaultdict [EOL] import datetime [EOL] from pathlib import Path [EOL] from dataclasses import dataclass , asdict , field [EOL] import shelve [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ dataclass class Post : [EOL] date = ... [EOL] title = ... [EOL] rst_text = ... [EOL] tags = ... [EOL] [EOL] [EOL] @ dataclass class Blog : [EOL] [EOL] title = ... [EOL] entries = field ( default_factory = list ) [EOL] underline = field ( init = False ) [EOL] [EOL] [comment] [EOL] _id = field ( default = [string] , init = False , compare = False ) [EOL] [EOL] def __post_init__ ( self ) : [EOL] self . underline = [string] * len ( self . title ) [EOL] [EOL] def append ( self , post ) : [EOL] self . entries . append ( post ) [EOL] [EOL] def by_tag ( self ) : [EOL] tag_index = defaultdict ( list ) [EOL] for post in self . entries : [EOL] for tag in post . tags : [EOL] tag_index [ tag ] . append ( asdict ( post ) ) [EOL] return tag_index [EOL] [EOL] test_blog = [string] [EOL] [EOL] test_query = [string] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] b1 = Blog ( title = [string] ) [EOL] p1 = Post ( date = datetime . datetime ( [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] ] , ) [EOL] b1 . append ( p1 ) [EOL] [EOL] [comment] [EOL] import shelve [EOL] [EOL] shelf = shelve . open ( str ( Path . cwd ( ) / [string] / [string] ) ) [EOL] db_id = [number] [EOL] [EOL] [comment] [EOL] db_id += [number] [EOL] b1 . _id = f" [string] { db_id }" [EOL] shelf [ b1 . _id ] = b1 [EOL] print ( f" [string] { shelf [ b1 . _id ] . _id } [string] { shelf [ b1 . _id ] . title }" ) [EOL] [EOL] [comment] [EOL] results = ( shelf [ k ] for k in shelf . keys ( ) if k . startswith ( [string] ) and shelf [ k ] . title == [string] ) [EOL] for r0 in results : [EOL] print ( f" [string] { r0 . _id } [string] { r0 . title }" ) [EOL] for p in r0 . entries : [EOL] print ( f" [string] { p }" ) [EOL] print ( f" [string] { r0 . by_tag ( ) }" ) [EOL] [EOL] shelf . close ( ) [EOL] [EOL] [EOL] [comment] [EOL] if __name__ == [string] : [EOL] [EOL] p2 = Post ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) [EOL] [EOL] p3 = Post ( date = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , title = [string] , rst_text = [string] , tags = [ [string] , [string] , [string] ] , ) [EOL] [EOL] shelf = shelve . open ( str ( Path . cwd ( ) / [string] / [string] ) ) [EOL] [EOL] [comment] [EOL] blog_id = [number] [EOL] key = f" [string] { blog_id }" [EOL] the_blog = shelf [ key ] [EOL] [EOL] [comment] [EOL] the_blog . append ( p2 ) [EOL] the_blog . append ( p3 ) [EOL] [EOL] [comment] [EOL] shelf [ key ] = the_blog [EOL] [EOL] [comment] [EOL] print ( [string] , list ( shelf . keys ( ) ) ) [EOL] [EOL] shelf . close ( ) [EOL] [EOL] [EOL] __test__ = { name : value for name , value in locals ( ) . items ( ) if name . startswith ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( verbose = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[Post]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Post$ 0 0 0 0 0 0 0 0 0 $Post$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0