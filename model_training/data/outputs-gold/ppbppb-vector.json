[comment] [EOL] from setuptools import setup [EOL] [EOL] [EOL] def requirements ( section = None ) : [EOL] [docstring] [EOL] if section is None : [EOL] filename = [string] [EOL] else : [EOL] filename = f" [string] { section } [string] " [EOL] [EOL] with open ( filename ) as file : [EOL] return [ line . strip ( ) for line in file ] [EOL] [EOL] [EOL] [comment] [EOL] setup ( setup_requires = requirements ( ) + [ [string] ] , install_requires = requirements ( ) , tests_require = requirements ( [string] ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Type [EOL] import ppb_vector [EOL] import typing [EOL] import builtins [EOL] from typing import Type , Union [EOL] [EOL] from hypothesis import assume , event , example , given , note [EOL] [EOL] from ppb_vector import Vector [EOL] from utils import floats , lengths , vectors [EOL] [EOL] [EOL] @ given ( x = vectors ( ) , max_length = lengths ( ) ) def test_truncate_length ( x , max_length ) : [EOL] assert x . truncate ( max_length ) . length <= ( [number] + [number] ) * max_length [EOL] [EOL] [EOL] @ given ( x = vectors ( ) , max_length = lengths ( max_value = [number] ) ) def test_truncate_invariant ( x , max_length ) : [EOL] assume ( x . length <= max_length ) [EOL] assert x . truncate ( max_length ) == x [EOL] [EOL] [EOL] @ given ( x = vectors ( max_magnitude = [number] ) , max_length = floats ( ) ) @ example ( x = Vector ( [number] , [number] ) , max_length = [number] , ) def test_truncate_equivalent_to_scale ( x , max_length ) : [EOL] [docstring] [EOL] assume ( max_length <= x . length ) [EOL] note ( f" [string] { x . length }" ) [EOL] if max_length > [number] : [EOL] note ( f" [string] { x . length / max_length } [string] " ) [EOL] [EOL] scale = ... [EOL] truncate = ... [EOL] [EOL] try : [EOL] truncate = x . truncate ( max_length ) [EOL] except Exception as e : [EOL] truncate = type ( e ) [EOL] [EOL] try : [EOL] scale = x . scale_to ( max_length ) [EOL] except Exception as e : [EOL] event ( f" [string] { type ( e ) . __name__ } [string] " ) [EOL] scale = type ( e ) [EOL] [EOL] if isinstance ( scale , Vector ) and x . length == max_length : [EOL] [comment] [EOL] assert isinstance ( truncate , Vector ) [EOL] assert scale . isclose ( truncate , abs_tol = [number] , rel_tol = [number] ) [EOL] [EOL] else : [EOL] assert scale == truncate [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import sys [EOL] import weakref [EOL] [EOL] import pytest [comment] [EOL] from hypothesis import given [EOL] [EOL] from ppb_vector import Vector [EOL] from utils import floats , vectors [EOL] [EOL] [EOL] class DummyVector : [EOL] [docstring] [EOL] [EOL] x = ... [EOL] y = ... [EOL] [EOL] def __init__ ( self , x , y ) : [EOL] self . x = float ( x ) [EOL] self . y = float ( y ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( sys . implementation . name != [string] , reason = [string] ) @ given ( x = floats ( ) , y = floats ( ) ) def test_object_size ( x , y ) : [EOL] [docstring] [EOL] from pympler . asizeof import asizeof as sizeof [comment] [EOL] [EOL] assert sizeof ( Vector ( x , y ) ) < sizeof ( DummyVector ( x , y ) ) / [number] [EOL] [EOL] [EOL] @ given ( v = vectors ( ) ) def test_weak_ref ( v ) : [EOL] [docstring] [EOL] assert weakref . ref ( v ) is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import ppb_vector [EOL] import builtins [EOL] from hypothesis import given [EOL] [EOL] from ppb_vector import Vector [EOL] from utils import floats , vectors [EOL] [EOL] [EOL] @ given ( x = floats ( ) , y = floats ( ) ) def test_class_member_access ( x , y ) : [EOL] v = Vector ( x , y ) [EOL] assert v . x == x [EOL] assert v . y == y [EOL] [EOL] [EOL] @ given ( v = vectors ( ) ) def test_index_access ( v ) : [EOL] assert v [ [number] ] == v . x [EOL] assert v [ [number] ] == v . y [EOL] [EOL] [EOL] @ given ( v = vectors ( ) ) def test_key_access ( v ) : [EOL] assert v [ [string] ] == v . x [EOL] assert v [ [string] ] == v . y [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import ppb_vector [EOL] import typing [EOL] import pickle [EOL] [EOL] from hypothesis import given [EOL] [EOL] from ppb_vector import Vector [EOL] from utils import vector_likes , vectors [EOL] [EOL] [EOL] @ given ( v = vectors ( ) ) def test_ctor_vector_like ( v ) : [EOL] for v_like in vector_likes ( v ) : [EOL] vector = Vector ( v_like ) [EOL] assert vector == v == v_like [EOL] [EOL] [EOL] @ given ( v = vectors ( ) ) def test_ctor_noncopy_same ( v ) : [EOL] assert Vector ( v ) is v [EOL] [EOL] [EOL] @ given ( v = vectors ( ) ) def test_ctor_pickle ( v ) : [EOL] [docstring] [EOL] w = pickle . loads ( pickle . dumps ( v ) ) [EOL] [EOL] assert v == w [EOL] assert isinstance ( w , Vector ) [EOL] [EOL] [EOL] @ given ( v = vectors ( ) ) def test_ctor_copy ( v ) : [EOL] [docstring] [EOL] from copy import copy , deepcopy [EOL] assert v == copy ( v ) == deepcopy ( v ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import ppb_vector [EOL] import typing [EOL] import pyperf [comment] [EOL] [EOL] from ppb_vector import Vector [EOL] from utils import * [EOL] [EOL] r = pyperf . Runner ( ) [EOL] x = Vector ( [number] , [number] ) [EOL] y = Vector ( [number] , [number] ) [EOL] scalar = [number] [EOL] [EOL] for f in BINARY_OPS | BINARY_SCALAR_OPS | BOOL_OPS : [comment] [EOL] r . bench_func ( f . __name__ , f , x , y ) [EOL] [EOL] for f in UNARY_OPS | UNARY_SCALAR_OPS : [comment] [EOL] r . bench_func ( f . __name__ , f , x ) [EOL] [EOL] for f in SCALAR_OPS : [comment] [EOL] r . bench_func ( f . __name__ , f , x , scalar ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $ppb_vector.Vector$ 0 0 0 0 0 0 0 0 $ppb_vector.Vector$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $ppb_vector.Vector$ 0 $ppb_vector.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $ppb_vector.Vector$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $ppb_vector.Vector$ 0 $builtins.int$ 0 0 0
from typing import List , Tuple [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from ppb_vector import Vector [EOL] [EOL] [EOL] data = [ ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) ) , ( ( [number] , [number] ) , ( [number] , - [number] ) , ( - [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , - [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) ) , ( ( [number] , [number] ) , ( - [number] , [number] ) , ( [number] , - [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , - [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , [number] ) ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , data , ids = [ f"{ x } [string] { y }" for x , y , expected in data ] ) def test_multiples_values ( x , y , expected ) : [EOL] assert ( Vector ( x ) - y ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import ppb_vector [EOL] import builtins [EOL] from hypothesis import given [EOL] [EOL] from ppb_vector import Vector [EOL] from utils import floats , vectors [EOL] [EOL] [EOL] @ given ( v = vectors ( ) , x = floats ( ) ) def test_update_x ( v , x ) : [EOL] assert v . update ( x = x ) == ( x , v . y ) [EOL] [EOL] [EOL] @ given ( v = vectors ( ) , y = floats ( ) ) def test_update_y ( v , y ) : [EOL] assert v . update ( y = y ) == ( v . x , y ) [EOL] [EOL] [EOL] @ given ( v = vectors ( ) , x = floats ( ) , y = floats ( ) ) def test_update_xy ( v , x , y ) : [EOL] assert v . update ( x = x , y = y ) == ( x , y ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple [EOL] import ppb_vector [EOL] import typing [EOL] import pytest [comment] [EOL] from hypothesis import given [EOL] [EOL] from ppb_vector import Vector [EOL] from utils import vector_likes , vectors [EOL] [EOL] [EOL] data = [ ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( - [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , data , ids = [ f"{ x } [string] { y }" for x , y , _ in data ] ) def test_multiples_values ( x , y , expected ) : [EOL] assert ( Vector ( x ) + y ) == expected [EOL] [EOL] [EOL] @ given ( x = vectors ( ) , y = vectors ( ) ) def test_addition_reverse ( x , y ) : [EOL] for y_like in vector_likes ( y ) : [EOL] assert y_like + x == x + y [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0