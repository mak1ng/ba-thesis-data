from energuide import logger [EOL] [EOL] [EOL] def test_unwrap_exception_message ( ) : [EOL] try : [EOL] try : [EOL] raise ZeroDivisionError ( [string] ) [EOL] except ZeroDivisionError as exc : [EOL] raise ValueError ( [string] ) from exc [EOL] except ValueError as exc : [EOL] assert logger . unwrap_exception_message ( exc , [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import py [EOL] import energuide [EOL] import py . _path . local [EOL] import pytest [EOL] from energuide import element [EOL] from energuide . exceptions import ElementGetValueError [EOL] [EOL] [EOL] @ pytest . fixture def fragment ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def fragment_file_path ( fragment , tmpdir ) : [EOL] file = tmpdir . join ( [string] ) [EOL] file . write_text ( [string] , encoding = [string] ) [EOL] file . write_text ( fragment , encoding = [string] ) [EOL] return str ( file ) [EOL] [EOL] [EOL] @ pytest . fixture def fragment_node ( fragment ) : [EOL] return element . Element . from_string ( fragment ) [EOL] [EOL] [EOL] def test_from_string ( fragment ) : [EOL] output = element . Element . from_string ( fragment ) [EOL] assert isinstance ( output , element . Element ) [EOL] assert output . tag == [string] [EOL] [EOL] [EOL] def test_findtext ( fragment_node ) : [EOL] assert fragment_node . findtext ( [string] ) == [string] [EOL] assert fragment_node . findtext ( [string] ) is None [EOL] [EOL] [EOL] def test_get_text ( fragment_node ) : [EOL] assert fragment_node . get_text ( [string] ) == [string] [EOL] [EOL] [EOL] def test_get_text_raises_when_not_found ( fragment_node ) : [EOL] with pytest . raises ( ElementGetValueError ) : [EOL] fragment_node . get_text ( [string] ) [EOL] [EOL] [EOL] def test_attrib ( fragment_node ) : [EOL] bar_node = fragment_node . find ( [string] ) [EOL] assert bar_node [EOL] assert bar_node . attrib [ [string] ] == [string] [EOL] assert [string] not in bar_node . attrib [EOL] [EOL] [EOL] def test_xpath_returns_elements ( fragment_node ) : [EOL] output = fragment_node . xpath ( [string] ) [EOL] assert len ( output ) == [number] [EOL] assert all ( [ isinstance ( bar_node , element . Element ) for bar_node in output ] ) [EOL] assert output [ [number] ] . attrib [ [string] ] == [string] [EOL] [EOL] [EOL] def test_parse ( fragment_file_path ) : [EOL] with open ( fragment_file_path ) as xml_file : [EOL] node = element . Element . parse ( xml_file ) [EOL] assert node . tag == [string] [EOL] [EOL] [EOL] def test_iter ( fragment_node ) : [EOL] child_nodes = [ child for child in fragment_node ] [EOL] assert len ( child_nodes ) == [number] [EOL] assert all ( [ isinstance ( child , element . Element ) for child in child_nodes ] ) [EOL] assert all ( [ child . tag == [string] for child in child_nodes ] ) [EOL] [EOL] [EOL] def test_find ( fragment_node ) : [EOL] bar_node = fragment_node . find ( [string] ) [EOL] assert bar_node [EOL] assert bar_node . tag == [string] [EOL] assert bar_node . attrib [ [string] ] == [string] [EOL] [EOL] [EOL] def test_find_returns_none ( fragment_node ) : [EOL] assert fragment_node . find ( [string] ) is None [EOL] [EOL] [EOL] def test_to_string ( fragment_node ) : [EOL] bar_node = fragment_node . find ( [string] ) [EOL] assert bar_node [EOL] assert bar_node . to_string ( ) == [string] [EOL] [EOL] [EOL] def test_tag ( fragment_node ) : [EOL] assert fragment_node . tag == [string] [EOL] [EOL] [EOL] def test_new ( ) : [EOL] output = element . Element . new ( [string] ) [EOL] assert output . tag == [string] [EOL] [EOL] [EOL] def test_from_malformed_string ( ) : [EOL] with pytest . raises ( element . MalformedXmlError ) : [EOL] element . Element . from_string ( [string] ) [EOL] [EOL] [EOL] def test_insert_node ( ) : [EOL] root = element . Element . new ( [string] ) [EOL] child1 = element . Element . new ( [string] ) [EOL] child2 = element . Element . new ( [string] ) [EOL] root . insert ( [number] , child1 ) [EOL] root . insert ( [number] , child2 ) [EOL] assert len ( root . xpath ( [string] ) ) == [number] [EOL] [EOL] [EOL] def test_get_int ( fragment_node ) : [EOL] result = fragment_node . get ( [string] , int ) [EOL] assert result == [number] [EOL] assert isinstance ( result , int ) [EOL] [EOL] [EOL] def test_get_float ( fragment_node ) : [EOL] result = fragment_node . get ( [string] , float ) [EOL] assert result == [number] [EOL] assert isinstance ( result , float ) [EOL] [EOL] [EOL] def test_get_str ( fragment_node ) : [EOL] result = fragment_node . get ( [string] , str ) [EOL] assert result == [string] [EOL] assert isinstance ( result , str ) [EOL] [EOL] [EOL] def test_get_raises_when_not_found ( fragment_node ) : [EOL] with pytest . raises ( ElementGetValueError ) : [EOL] fragment_node . get ( [string] , int ) [EOL] [EOL] [EOL] def test_get_raises_when_cant_cast ( fragment_node ) : [EOL] with pytest . raises ( ElementGetValueError ) : [EOL] fragment_node . get ( [string] , int ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Generator [EOL] import builtins [EOL] import _pytest [EOL] import pymongo [EOL] import hashlib [EOL] import flask [EOL] import energuide [EOL] import typing [EOL] from http import HTTPStatus [EOL] import hashlib [EOL] import typing [EOL] import _pytest [EOL] import pymongo [EOL] import pytest [EOL] from flask import testing [EOL] from energuide import flask_app [EOL] from energuide import database [EOL] [EOL] [EOL] flask_app . App . testing = True [EOL] [EOL] [EOL] @ pytest . fixture def sample_salt ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def sample_secret_key ( monkeypatch ) : [EOL] monkeypatch . setitem ( flask_app . App . config , [string] , [string] ) [EOL] return flask_app . App . config [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture def sample_signature ( sample_salt , sample_secret_key ) : [EOL] hasher = hashlib . new ( [string] ) [EOL] hasher . update ( ( sample_salt + sample_secret_key ) . encode ( ) ) [EOL] return hasher . hexdigest ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def test_client ( monkeypatch , database_name ) : [EOL] monkeypatch . setattr ( flask_app , [string] , database_name ) [EOL] return flask_app . App . test_client ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def thread_runner ( ) : [EOL] yield flask_app . ThreadRunner [EOL] flask_app . ThreadRunner . join ( ) [EOL] [EOL] [EOL] @ pytest . fixture def busy_thread_runner ( thread_runner ) : [EOL] stay_asleep = True [EOL] [EOL] def sleeper ( ) : [EOL] while stay_asleep : [EOL] pass [EOL] [EOL] thread_runner . start_new_thread ( sleeper ) [EOL] yield thread_runner [EOL] stay_asleep = False [EOL] [EOL] [EOL] @ pytest . fixture def fake_db_coords ( monkeypatch ) : [EOL] def connection_string ( self ) : [EOL] prefix = f'{ self . username } [string] { self . password } [string] ' if self . username and self . password else [string] [EOL] return f'{ prefix }{ self . host } [string] { self . port }' [EOL] [EOL] connection_string_propery = property ( connection_string ) [EOL] [EOL] monkeypatch . setattr ( database . DatabaseCoordinates , [string] , connection_string_propery ) [EOL] yield [EOL] [EOL] [EOL] def test_threadrunner ( thread_runner ) : [EOL] stay_asleep = True [EOL] [EOL] def sleeper ( ) : [EOL] while stay_asleep : [EOL] pass [EOL] [EOL] thread_runner . start_new_thread ( sleeper ) [EOL] assert thread_runner . is_thread_running ( ) [EOL] stay_asleep = False [EOL] thread_runner . join ( ) [EOL] assert not thread_runner . is_thread_running ( ) [EOL] [EOL] [EOL] def test_frontend ( test_client ) : [EOL] assert test_client . get ( [string] ) . status_code == HTTPStatus . OK [EOL] [EOL] [EOL] def test_alive ( test_client ) : [EOL] get_return = test_client . get ( [string] ) [EOL] assert [string] in get_return . data [EOL] [EOL] [EOL] def test_robots ( test_client ) : [EOL] get_return = test_client . get ( [string] ) [EOL] assert get_return . status_code == HTTPStatus . NOT_FOUND [EOL] [EOL] [EOL] @ pytest . mark . timeout ( [number] ) @ pytest . mark . usefixtures ( [string] , [string] ) def test_run_tl ( test_client , thread_runner , mongo_client , database_name , collection , sample_salt , sample_signature ) : [EOL] [EOL] post_return = test_client . post ( [string] , data = dict ( salt = sample_salt , signature = sample_signature ) ) [EOL] assert post_return . status_code == HTTPStatus . OK [EOL] thread_runner . join ( ) [EOL] assert mongo_client [ database_name ] [ collection ] . count ( ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . timeout ( [number] ) @ pytest . mark . usefixtures ( [string] , [string] ) def test_run_tl_busy ( test_client , sample_salt , sample_signature ) : [EOL] [EOL] test_client . post ( [string] , data = dict ( salt = sample_salt , signature = sample_signature ) ) [EOL] post_return = test_client . post ( [string] , data = dict ( salt = sample_salt , signature = sample_signature ) ) [EOL] assert post_return . status_code == HTTPStatus . TOO_MANY_REQUESTS [EOL] [EOL] [EOL] def test_run_tl_no_salt ( test_client , energuide_zip_fixture , sample_signature ) : [EOL] post_return = test_client . post ( [string] , data = dict ( filename = energuide_zip_fixture , signature = sample_signature ) ) [EOL] assert post_return . status_code == HTTPStatus . BAD_REQUEST [EOL] assert [string] in post_return . data [EOL] [EOL] [EOL] def test_run_tl_no_signature ( test_client , energuide_zip_fixture , sample_salt ) : [EOL] post_return = test_client . post ( [string] , data = dict ( filename = energuide_zip_fixture , salt = sample_salt ) ) [EOL] assert post_return . status_code == HTTPStatus . BAD_REQUEST [EOL] assert [string] in post_return . data [EOL] [EOL] [EOL] def test_run_tl_bad_signature ( test_client , energuide_zip_fixture , sample_salt ) : [EOL] post_return = test_client . post ( [string] , data = dict ( filename = energuide_zip_fixture , salt = sample_salt , signature = [string] ) ) [EOL] assert post_return . status_code == HTTPStatus . BAD_REQUEST [EOL] assert [string] in post_return . data [EOL] [EOL] [EOL] def test_status_idle ( test_client ) : [EOL] status = test_client . get ( [string] ) [EOL] assert status . status_code == HTTPStatus . OK [EOL] assert status . data == [string] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_status_busy ( test_client ) : [EOL] status = test_client . get ( [string] ) [EOL] assert status . status_code == HTTPStatus . OK [EOL] assert status . data == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.testing.FlaskClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from energuide import bilingual [EOL] [EOL] [EOL] def test_translation ( ) : [EOL] output = bilingual . Bilingual ( english = [string] , french = [string] ) [EOL] assert output . english == [string] [EOL] assert output . french == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict , List [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import copy [EOL] import datetime [EOL] import typing [EOL] import pytest [EOL] from energuide import bilingual [EOL] from energuide import dwelling [EOL] from energuide . embedded import area [EOL] from energuide . embedded import ceiling [EOL] from energuide . embedded import code [EOL] from energuide . embedded import distance [EOL] from energuide . embedded import floor [EOL] from energuide . embedded import heating [EOL] from energuide . embedded import insulation [EOL] from energuide . embedded import wall [EOL] from energuide . embedded import door [EOL] from energuide . embedded import window [EOL] from energuide . embedded import water_heating [EOL] from energuide . embedded import ventilation [EOL] from energuide . embedded import heated_floor_area [EOL] from energuide . embedded import basement [EOL] from energuide . embedded import upgrade [EOL] from energuide . exceptions import InvalidInputDataError [EOL] from energuide . exceptions import InvalidGroupSizeError [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ pytest . fixture def ceiling_input ( ) : [EOL] doc = [string] [EOL] return [ doc ] [EOL] [EOL] [EOL] @ pytest . fixture def floor_input ( ) : [EOL] doc = [string] [EOL] return [ doc ] [EOL] [EOL] [EOL] @ pytest . fixture def wall_input ( ) : [EOL] doc = [string] [EOL] return [ doc ] [EOL] [EOL] [EOL] @ pytest . fixture def door_input ( ) : [EOL] doc = [string] [EOL] return [ doc ] [EOL] [EOL] [EOL] @ pytest . fixture def window_input ( ) : [EOL] doc = [string] [EOL] return [ doc ] [EOL] [EOL] [EOL] @ pytest . fixture def heated_floor_area_input ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def heating_cooling_input ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def ventilation_input ( ) : [EOL] doc = [string] [EOL] return [ doc ] [EOL] [EOL] [EOL] @ pytest . fixture def water_heating_input ( ) : [EOL] doc = [string] [EOL] return doc [EOL] [EOL] [EOL] @ pytest . fixture def basement_input ( ) : [EOL] doc = [string] [EOL] return [ doc ] [EOL] [EOL] [EOL] @ pytest . fixture def crawlspace_input ( ) : [EOL] doc = [string] [EOL] return [ doc ] [EOL] [EOL] [EOL] @ pytest . fixture def slab_input ( ) : [EOL] doc = [string] [EOL] return [ doc ] [EOL] [EOL] [EOL] @ pytest . fixture def raw_codes ( ) : [EOL] return { [string] : [ [string] , [string] , ] , [string] : [ [string] , [string] , ] } [EOL] [EOL] [EOL] @ pytest . fixture def upgrades_input ( ) : [EOL] return [ [string] , [string] , [string] , ] [EOL] [EOL] [EOL] @ pytest . fixture def sample_input_d ( ceiling_input , floor_input , wall_input , door_input , window_input , heated_floor_area_input , heating_cooling_input , ventilation_input , water_heating_input , basement_input , crawlspace_input , slab_input , upgrades_input , raw_codes ) : [EOL] [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : ceiling_input , [string] : floor_input , [string] : wall_input , [string] : door_input , [string] : window_input , [string] : heating_cooling_input , [string] : heated_floor_area_input , [string] : ventilation_input , [string] : water_heating_input , [string] : basement_input , [string] : crawlspace_input , [string] : slab_input , [string] : raw_codes , [string] : [string] , [string] : upgrades_input , } [EOL] [EOL] [EOL] @ pytest . fixture def sample_input_e ( sample_input_d ) : [EOL] output = copy . deepcopy ( sample_input_d ) [EOL] output [ [string] ] = [string] [EOL] return output [EOL] [EOL] [EOL] @ pytest . fixture def sample_input_missing ( sample_input_d ) : [EOL] output = copy . deepcopy ( sample_input_d ) [EOL] output [ [string] ] = None [EOL] output [ [string] ] = None [EOL] output [ [string] ] = None [EOL] output [ [string] ] = None [EOL] output [ [string] ] = None [EOL] return output [EOL] [EOL] [EOL] @ pytest . fixture def sample_parsed_d ( sample_input_d ) : [EOL] return dwelling . ParsedDwellingDataRow . from_row ( sample_input_d ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_parsed_e ( sample_input_e ) : [EOL] return dwelling . ParsedDwellingDataRow . from_row ( sample_input_e ) [EOL] [EOL] [EOL] class TestEvaluationType : [EOL] [EOL] def test_from_code ( self ) : [EOL] code = dwelling . EvaluationType . PRE_RETROFIT . value [EOL] output = dwelling . EvaluationType . from_code ( code ) [EOL] assert output == dwelling . EvaluationType . PRE_RETROFIT [EOL] [EOL] [EOL] class TestRegion : [EOL] [EOL] def test_from_name ( self ) : [EOL] data = [ [string] , [string] , [string] , ] [EOL] output = [ dwelling . Region . from_data ( row ) for row in data ] [EOL] [EOL] assert output == [ dwelling . Region . ONTARIO , dwelling . Region . BRITISH_COLUMBIA , dwelling . Region . NOVA_SCOTIA , ] [EOL] [EOL] def test_from_unknown_name ( self ) : [EOL] assert dwelling . Region . from_data ( [string] ) == dwelling . Region . UNKNOWN [EOL] [EOL] def test_from_code ( self ) : [EOL] data = [ [string] , [string] , [string] , ] [EOL] output = [ dwelling . Region . from_data ( row ) for row in data ] [EOL] assert output == [ dwelling . Region . ONTARIO , dwelling . Region . BRITISH_COLUMBIA , dwelling . Region . NOVA_SCOTIA , ] [EOL] [EOL] def test_from_unknown_code ( self ) : [EOL] assert dwelling . Region . from_data ( [string] ) == dwelling . Region . UNKNOWN [EOL] [EOL] [EOL] class TestParsedDwellingDataRow : [EOL] [EOL] def test_from_row ( self , sample_input_d ) : [EOL] output = dwelling . ParsedDwellingDataRow . from_row ( sample_input_d ) [EOL] [EOL] wall_code = code . WallCode ( identifier = [string] , label = [string] , tags = { code . WallCodeTag . STRUCTURE_TYPE : bilingual . Bilingual ( english = [string] , french = [string] , ) , code . WallCodeTag . COMPONENT_TYPE_SIZE : bilingual . Bilingual ( english = [string] , french = [string] , ) } , ) [EOL] [EOL] window_code = code . WindowCode ( identifier = [string] , label = [string] , tags = { code . WindowCodeTag . GLAZING_TYPE : bilingual . Bilingual ( english = [string] , french = [string] , ) , code . WindowCodeTag . COATING_TINTS : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . FILL_TYPE : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . SPACER_TYPE : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . CODE_TYPE : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . FRAME_MATERIAL : bilingual . Bilingual ( english = [string] , french = [string] ) , } ) [EOL] [EOL] assert output == dwelling . ParsedDwellingDataRow ( eval_id = [number] , eval_type = dwelling . EvaluationType . PRE_RETROFIT , entry_date = datetime . date ( [number] , [number] , [number] ) , creation_date = datetime . datetime ( [number] , [number] , [number] , [number] ) , modification_date = datetime . datetime ( [number] , [number] , [number] , [number] ) , year_built = [number] , city = [string] , region = dwelling . Region . ONTARIO , forward_sortation_area = [string] , ers_rating = [number] , file_id = [string] , ceilings = [ ceiling . Ceiling ( label = [string] , ceiling_type = bilingual . Bilingual ( english = [string] , french = [string] ) , nominal_insulation = insulation . Insulation ( [number] ) , effective_insulation = insulation . Insulation ( [number] ) , ceiling_area = area . Area ( [number] ) , ceiling_length = distance . Distance ( [number] ) , ) ] , floors = [ floor . Floor ( label = [string] , nominal_insulation = insulation . Insulation ( [number] ) , effective_insulation = insulation . Insulation ( [number] ) , floor_area = area . Area ( [number] ) , floor_length = distance . Distance ( [number] ) , ) ] , walls = [ wall . Wall ( label = [string] , wall_code = wall_code , nominal_insulation = insulation . Insulation ( [number] ) , effective_insulation = insulation . Insulation ( [number] ) , perimeter = distance . Distance ( [number] ) , height = distance . Distance ( [number] ) , ) ] , doors = [ door . Door ( label = [string] , door_type = bilingual . Bilingual ( english = [string] , french = [string] ) , door_insulation = insulation . Insulation ( [number] ) , height = distance . Distance ( [number] ) , width = distance . Distance ( [number] ) , ) ] , windows = [ window . Window ( label = [string] , window_code = window_code , window_insulation = insulation . Insulation ( [number] ) , width = distance . Distance ( [number] ) , height = distance . Distance ( [number] ) , ) ] , heated_floor = heated_floor_area . HeatedFloorArea ( area_above_grade = area . Area ( [number] ) , area_below_grade = area . Area ( [number] ) , ) , ventilations = [ ventilation . Ventilation ( ventilation_type = ventilation . VentilationType . NOT_ENERGY_STAR_NOT_INSTITUTE_CERTIFIED , air_flow_rate = [number] , efficiency = [number] , ) ] , water_heatings = [ water_heating . WaterHeating ( water_heater_type = water_heating . WaterHeaterType . ELECTRICITY_CONVENTIONAL_TANK , tank_volume = [number] , efficiency_ef = [number] , efficiency_percentage = None , drain_water_heat_recovery_efficiency_percentage = None , ) ] , heating_system = heating . Heating ( heating_type = heating . HeatingType . FURNACE , energy_source = heating . EnergySource . NATURAL_GAS , equipment_type = bilingual . Bilingual ( english = [string] , french = [string] ) , label = [string] , output_size = [number] , efficiency = [number] , steady_state = [string] , ) , foundations = [ basement . Basement ( foundation_type = basement . FoundationType . BASEMENT , label = [string] , configuration_type = [string] , walls = [ basement . BasementWall ( wall_type = basement . WallType . INTERIOR , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , composite_percentage = [number] , wall_area = area . Area ( [number] ) ) ] , floors = [ basement . BasementFloor ( floor_type = basement . FloorType . SLAB , rectangular = False , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , length = None , width = None , perimeter = distance . Distance ( distance_metres = [number] ) , floor_area = area . Area ( [number] ) ) ] , header = basement . BasementHeader ( nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , height = distance . Distance ( distance_metres = [number] ) , perimeter = distance . Distance ( distance_metres = [number] ) ) , ) , basement . Basement ( foundation_type = basement . FoundationType . CRAWLSPACE , label = [string] , configuration_type = [string] , walls = [ basement . BasementWall ( wall_type = basement . WallType . NOT_APPLICABLE , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , composite_percentage = [number] , wall_area = area . Area ( [number] ) ) ] , floors = [ basement . BasementFloor ( floor_type = basement . FloorType . SLAB , rectangular = True , nominal_insulation = None , effective_insulation = None , width = distance . Distance ( distance_metres = [number] ) , length = distance . Distance ( distance_metres = [number] ) , perimeter = distance . Distance ( distance_metres = [number] ) , floor_area = area . Area ( [number] ) ) , basement . BasementFloor ( floor_type = basement . FloorType . FLOOR_ABOVE_CRAWLSPACE , rectangular = True , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , width = distance . Distance ( distance_metres = [number] ) , length = distance . Distance ( distance_metres = [number] ) , perimeter = distance . Distance ( distance_metres = [number] ) , floor_area = area . Area ( [number] ) ) ] , header = None , ) , basement . Basement ( foundation_type = basement . FoundationType . SLAB , label = [string] , configuration_type = [string] , walls = [ ] , floors = [ basement . BasementFloor ( floor_type = basement . FloorType . SLAB , rectangular = True , nominal_insulation = None , effective_insulation = None , width = distance . Distance ( distance_metres = [number] ) , length = distance . Distance ( distance_metres = [number] ) , perimeter = distance . Distance ( distance_metres = [number] ) , floor_area = area . Area ( [number] ) ) ] , header = None , ) , ] , energy_upgrades = [ upgrade . Upgrade ( upgrade_type = [string] , cost = [number] , priority = [number] , ) , upgrade . Upgrade ( upgrade_type = [string] , cost = [number] , priority = [number] , ) , upgrade . Upgrade ( upgrade_type = [string] , cost = [number] , priority = [number] , ) , ] ) [EOL] [EOL] def test_null_fields_are_accepted ( self , sample_input_missing ) : [EOL] output = dwelling . ParsedDwellingDataRow . from_row ( sample_input_missing ) [EOL] [EOL] assert output . modification_date == output . ers_rating == output . heating_system == output . heated_floor == None [EOL] [EOL] def test_bad_postal_code ( self , sample_input_d ) : [EOL] sample_input_d [ [string] ] = [string] [EOL] with pytest . raises ( InvalidInputDataError ) : [EOL] dwelling . ParsedDwellingDataRow . from_row ( sample_input_d ) [EOL] [EOL] def test_from_bad_row ( self ) : [EOL] input_data = { [string] : [number] } [EOL] with pytest . raises ( InvalidInputDataError ) as ex : [EOL] dwelling . ParsedDwellingDataRow . from_row ( input_data ) [EOL] assert [string] in ex . exconly ( ) [EOL] assert [string] not in ex . exconly ( ) [EOL] [EOL] def test_missing_ers ( self , sample_input_d ) : [EOL] sample_input_d [ [string] ] = [string] [EOL] output = dwelling . ParsedDwellingDataRow . from_row ( sample_input_d ) [EOL] assert output . ers_rating is None [EOL] [EOL] [EOL] class TestDwellingEvaluation : [EOL] [EOL] def test_eval_type ( self , sample_parsed_d ) : [EOL] output = dwelling . Evaluation . from_data ( sample_parsed_d ) [EOL] assert output . evaluation_type == dwelling . EvaluationType . PRE_RETROFIT [EOL] [EOL] def test_entry_date ( self , sample_parsed_d ) : [EOL] output = dwelling . Evaluation . from_data ( sample_parsed_d ) [EOL] assert output . entry_date == datetime . date ( [number] , [number] , [number] ) [EOL] [EOL] def test_creation_date ( self , sample_parsed_d ) : [EOL] output = dwelling . Evaluation . from_data ( sample_parsed_d ) [EOL] assert output . creation_date == datetime . datetime ( [number] , [number] , [number] , [number] ) [EOL] [EOL] def test_modification_date ( self , sample_parsed_d ) : [EOL] output = dwelling . Evaluation . from_data ( sample_parsed_d ) [EOL] assert output . modification_date == datetime . datetime ( [number] , [number] , [number] , [number] ) [EOL] [EOL] def test_to_dict ( self , sample_parsed_d ) : [EOL] output = dwelling . Evaluation . from_data ( sample_parsed_d ) . to_dict ( ) [EOL] assert output [ [string] ] == dwelling . EvaluationType . PRE_RETROFIT . value [EOL] [EOL] [EOL] class TestDwelling : [EOL] [EOL] @ pytest . fixture def sample ( self , sample_input_d , sample_input_e , ) : [EOL] return [ sample_input_d , sample_input_e ] . copy ( ) [EOL] [EOL] def test_house_id ( self , sample ) : [EOL] output = dwelling . Dwelling . from_group ( sample ) [EOL] assert output . house_id == [number] [EOL] [EOL] def test_year_built ( self , sample ) : [EOL] output = dwelling . Dwelling . from_group ( sample ) [EOL] assert output . year_built == [number] [EOL] [EOL] def test_address_data ( self , sample ) : [EOL] output = dwelling . Dwelling . from_group ( sample ) [EOL] assert output . city == [string] [EOL] assert output . region == dwelling . Region . ONTARIO [EOL] assert output . forward_sortation_area == [string] [EOL] [EOL] def test_single_pre_evaluation ( self , sample_input_d ) : [EOL] output = dwelling . Dwelling . from_group ( [ sample_input_d ] ) [EOL] assert len ( output . evaluations ) == [number] [EOL] [EOL] def test_single_post_evaluation ( self , sample_input_e ) : [EOL] with pytest . raises ( InvalidInputDataError ) : [EOL] dwelling . Dwelling . from_group ( [ sample_input_e ] ) [EOL] [EOL] def test_evaluations ( self , sample ) : [EOL] output = dwelling . Dwelling . from_group ( sample ) [EOL] assert len ( output . evaluations ) == [number] [EOL] [EOL] def test_no_data ( self ) : [EOL] data = [ ] [EOL] with pytest . raises ( InvalidGroupSizeError ) : [EOL] dwelling . Dwelling . from_group ( data ) [EOL] [EOL] def test_to_dict ( self , sample ) : [EOL] output = dwelling . Dwelling . from_group ( sample ) . to_dict ( ) [EOL] assert output [ [string] ] == [number] [EOL] assert len ( output [ [string] ] ) == [number] [EOL] assert [string] not in output [EOL] assert output [ [string] ] == dwelling . Region . ONTARIO . value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Union , List [EOL] import typing [EOL] from energuide import element [EOL] from energuide import validator [EOL] [EOL] [EOL] def test_validates_xml ( ) : [EOL] raw_xml = [string] [EOL] doc = element . Element . from_string ( raw_xml ) [EOL] data = { [string] : doc } [EOL] checker = validator . DwellingValidator ( { [string] : { [string] : [string] , [string] : True } } ) [EOL] assert checker . validate ( data ) [EOL] [EOL] [EOL] def test_string_fails_validation ( ) : [EOL] raw_xml = [string] [EOL] data = { [string] : raw_xml } [EOL] checker = validator . DwellingValidator ( { [string] : { [string] : [string] , [string] : True } } ) [EOL] assert not checker . validate ( data ) [EOL] [EOL] [EOL] def test_coerce_to_xml ( ) : [EOL] raw_xml = [string] [EOL] data = { [string] : raw_xml } [EOL] checker = validator . DwellingValidator ( { [string] : { [string] : [string] , [string] : True , [string] : [string] } } ) [EOL] assert checker . validate ( data ) [EOL] assert isinstance ( checker . document [ [string] ] , element . Element ) [EOL] [EOL] [EOL] def test_embedded_xml ( ) : [EOL] raw_xml = [string] [EOL] data = { [string] : [ raw_xml , raw_xml ] } [EOL] schema = { [string] : { [string] : [string] , [string] : True , [string] : { [string] : [string] , [string] : [string] } } } [EOL] checker = validator . DwellingValidator ( schema ) [EOL] assert checker . validate ( data ) [EOL] assert isinstance ( checker . document [ [string] ] , list ) [EOL] assert len ( checker . document [ [string] ] ) == [number] [EOL] assert isinstance ( checker . document [ [string] ] [ [number] ] , element . Element ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from energuide . embedded import insulation [EOL] [EOL] [EOL] def test_insulation ( ) : [EOL] output = insulation . Insulation ( [number] ) [EOL] assert output . rsi == [number] [EOL] assert output . r_value == pytest . approx ( [number] ) [EOL] [EOL] [EOL] def test_from_r_value ( ) : [EOL] output = insulation . Insulation . from_r_value ( [number] ) [EOL] assert output . rsi == pytest . approx ( [number] ) [EOL] assert output . r_value == pytest . approx ( [number] ) [EOL] [EOL] [EOL] def test_equality ( ) : [EOL] version1 = insulation . Insulation ( [number] ) [EOL] version2 = insulation . Insulation ( [number] ) [EOL] [EOL] assert version1 == version2 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import pytest [EOL] from energuide import element [EOL] from energuide . embedded import water_heating [EOL] from energuide . exceptions import InvalidEmbeddedDataTypeError [EOL] [EOL] [EOL] @ pytest . fixture def sample_ef ( ) : [EOL] data = [string] + [string] [EOL] return element . Element . from_string ( data ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_percentage ( ) : [EOL] data = [string] + [string] [EOL] return element . Element . from_string ( data ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_drain_water_heat_recovery ( ) : [EOL] data = [string] + [string] + [string] [EOL] return element . Element . from_string ( data ) [EOL] [EOL] [EOL] BAD_XML_DATA = [ [string] + [string] , [string] + [string] , [string] + [string] , [string] + [string] ] [EOL] [EOL] [EOL] def test_from_data_ef ( sample_ef ) : [EOL] output = water_heating . WaterHeating . from_data ( sample_ef ) [ [number] ] [EOL] assert output . water_heater_type == water_heating . WaterHeaterType . ELECTRICITY_CONVENTIONAL_TANK [EOL] assert output . efficiency_ef == [number] [EOL] [EOL] [EOL] def test_from_data_percentage ( sample_percentage ) : [EOL] output = water_heating . WaterHeating . from_data ( sample_percentage ) [ [number] ] [EOL] assert output . water_heater_type == water_heating . WaterHeaterType . ELECTRICITY_CONVENTIONAL_TANK [EOL] assert output . efficiency_percentage == [number] [EOL] [EOL] [EOL] def test_drain_water_heat_recovery ( sample_drain_water_heat_recovery ) : [EOL] output = water_heating . WaterHeating . from_data ( sample_drain_water_heat_recovery ) [ [number] ] [EOL] assert output . drain_water_heat_recovery_efficiency_percentage == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , BAD_XML_DATA ) def test_bad_data ( bad_xml ) : [EOL] water_heating_node = element . Element . from_string ( bad_xml ) [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as excinfo : [EOL] water_heating . WaterHeating . from_data ( water_heating_node ) [EOL] [EOL] assert excinfo . value . data_class == water_heating . WaterHeating [EOL] [EOL] [EOL] def test_to_dict ( sample_ef ) : [EOL] output = water_heating . WaterHeating . from_data ( sample_ef ) [ [number] ] . to_dict ( ) [EOL] assert output == { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : None , [string] : None , } [EOL] [EOL] [EOL] def test_properties ( sample_ef ) : [EOL] output = water_heating . WaterHeating . from_data ( sample_ef ) [ [number] ] [EOL] assert output . tank_volume_gallon == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import typing [EOL] import pytest [EOL] from energuide import bilingual [EOL] from energuide import element [EOL] from energuide . embedded import code [EOL] from energuide . exceptions import InvalidEmbeddedDataTypeError [EOL] [EOL] [EOL] @ pytest . fixture def raw_wall_code ( ) : [EOL] data = [string] [EOL] return element . Element . from_string ( data ) [EOL] [EOL] [EOL] BAD_WALL_CODE_XML = [ [string] , ] [EOL] [EOL] [EOL] BAD_WINDOW_CODE_XML = [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture def wall_code ( ) : [EOL] return code . WallCode ( identifier = [string] , label = [string] , tags = { code . WallCodeTag . STRUCTURE_TYPE : bilingual . Bilingual ( english = [string] , french = [string] , ) , code . WallCodeTag . COMPONENT_TYPE_SIZE : bilingual . Bilingual ( english = [string] , french = [string] , ) } , ) [EOL] [EOL] [EOL] @ pytest . fixture def raw_window_code ( ) : [EOL] data = [string] [EOL] return element . Element . from_string ( data ) [EOL] [EOL] [EOL] @ pytest . fixture def window_code ( ) : [EOL] return code . WindowCode ( identifier = [string] , label = [string] , tags = { code . WindowCodeTag . GLAZING_TYPE : bilingual . Bilingual ( english = [string] , french = [string] , ) , code . WindowCodeTag . COATING_TINTS : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . FILL_TYPE : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . SPACER_TYPE : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . CODE_TYPE : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . FRAME_MATERIAL : bilingual . Bilingual ( english = [string] , french = [string] ) , } ) [EOL] [EOL] [EOL] @ pytest . fixture def raw_codes ( raw_wall_code , raw_window_code ) : [EOL] return { [string] : [ raw_wall_code ] , [string] : [ raw_window_code ] , } [EOL] [EOL] [EOL] def test_wall_code_from_data ( raw_wall_code , wall_code ) : [EOL] output = code . WallCode . from_data ( raw_wall_code ) [EOL] assert output == wall_code [EOL] [EOL] [EOL] def test_window_code_from_data ( raw_window_code , window_code ) : [EOL] output = code . WindowCode . from_data ( raw_window_code ) [EOL] assert output == window_code [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , BAD_WALL_CODE_XML ) def test_bad_wall_code ( bad_xml ) : [EOL] code_node = element . Element . from_string ( bad_xml ) [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as excinfo : [EOL] code . WallCode . from_data ( code_node ) [EOL] [EOL] assert excinfo . value . data_class == code . WallCode [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , BAD_WINDOW_CODE_XML ) def test_bad_window_code ( bad_xml ) : [EOL] code_node = element . Element . from_string ( bad_xml ) [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as excinfo : [EOL] code . WindowCode . from_data ( code_node ) [EOL] [EOL] assert excinfo . value . data_class == code . WindowCode [EOL] [EOL] [EOL] def test_code_from_data ( raw_wall_code , raw_window_code , wall_code , window_code ) : [EOL] output = code . Codes . from_data ( { [string] : [ raw_wall_code ] , [string] : [ raw_window_code ] } ) [EOL] assert output == code . Codes ( wall = { wall_code . identifier : wall_code } , window = { window_code . identifier : window_code } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.code.WallCode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.code.WindowCode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[energuide.element.Element]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import pytest [EOL] from energuide import bilingual [EOL] from energuide import element [EOL] from energuide . embedded import door [EOL] from energuide . embedded import distance [EOL] from energuide . embedded import insulation [EOL] from energuide . exceptions import InvalidEmbeddedDataTypeError [EOL] [EOL] [EOL] @ pytest . fixture def sample_raw ( ) : [EOL] doc = [string] [EOL] return element . Element . from_string ( doc ) [EOL] [EOL] [EOL] BAD_DATA_XML = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] @ pytest . fixture def sample ( ) : [EOL] return door . Door ( label = [string] , door_type = bilingual . Bilingual ( english = [string] , french = [string] ) , door_insulation = insulation . Insulation ( [number] ) , height = distance . Distance ( [number] ) , width = distance . Distance ( [number] ) , ) [EOL] [EOL] [EOL] def test_from_data ( sample_raw , sample ) : [EOL] output = door . Door . from_data ( sample_raw ) [EOL] assert output == sample [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , BAD_DATA_XML ) def test_bad_data ( bad_xml ) : [EOL] door_node = element . Element . from_string ( bad_xml ) [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as excinfo : [EOL] door . Door . from_data ( door_node ) [EOL] [EOL] assert excinfo . value . data_class == door . Door [EOL] [EOL] [EOL] def test_to_dict ( sample ) : [EOL] output = sample . to_dict ( ) [EOL] assert output == { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] def test_properties ( sample_raw ) : [EOL] output = door . Door . from_data ( sample_raw ) [EOL] assert output . u_factor == [number] [EOL] assert output . u_factor_imperial == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.door.Door$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import typing [EOL] import pytest [EOL] from energuide import bilingual [EOL] from energuide import element [EOL] from energuide . embedded import code [EOL] from energuide . embedded import distance [EOL] from energuide . embedded import insulation [EOL] from energuide . embedded import wall [EOL] from energuide . exceptions import InvalidEmbeddedDataTypeError [EOL] [EOL] [EOL] @ pytest . fixture def raw_sample ( ) : [EOL] doc = [string] [EOL] return element . Element . from_string ( doc ) [EOL] [EOL] BAD_XML_DATA = [ [string] , [string] , [string] ] [EOL] [EOL] @ pytest . fixture def sample_wall_code ( ) : [EOL] return { [string] : code . WallCode ( identifier = [string] , label = [string] , tags = { code . WallCodeTag . STRUCTURE_TYPE : bilingual . Bilingual ( english = [string] , french = [string] , ) , code . WallCodeTag . COMPONENT_TYPE_SIZE : bilingual . Bilingual ( english = [string] , french = [string] , ) } , ) } [EOL] [EOL] [EOL] @ pytest . fixture def sample ( sample_wall_code ) : [EOL] return wall . Wall ( label = [string] , wall_code = sample_wall_code [ [string] ] , nominal_insulation = insulation . Insulation ( [number] ) , effective_insulation = insulation . Insulation ( [number] ) , perimeter = distance . Distance ( [number] ) , height = distance . Distance ( [number] ) , ) [EOL] [EOL] [EOL] def test_from_data ( raw_sample , sample_wall_code , sample ) : [EOL] output = wall . Wall . from_data ( raw_sample , sample_wall_code ) [EOL] assert output == sample [EOL] [EOL] [EOL] def test_from_data_missing_codes ( ) : [EOL] doc = [string] [EOL] sample = element . Element . from_string ( doc ) [EOL] output = wall . Wall . from_data ( sample , { } ) [EOL] assert output . label == [string] [EOL] assert output . wall_code is None [EOL] assert output . to_dict ( ) [ [string] ] is None [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , BAD_XML_DATA ) def test_bad_data ( bad_xml ) : [EOL] wall_node = element . Element . from_string ( bad_xml ) [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as excinfo : [EOL] wall . Wall . from_data ( wall_node , { } ) [EOL] [EOL] assert excinfo . value . data_class == wall . Wall [EOL] [EOL] [EOL] def test_to_dict ( sample ) : [EOL] output = sample . to_dict ( ) [EOL] assert output == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,energuide.embedded.code.WallCode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.wall.Wall$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from energuide . embedded import distance [EOL] [EOL] [EOL] def test_distance ( ) : [EOL] output = distance . Distance ( [number] ) [EOL] assert output . metres == [number] [EOL] assert output . feet == pytest . approx ( [number] ) [EOL] [EOL] [EOL] def test_from_square_feet ( ) : [EOL] output = distance . Distance . from_feet ( [number] ) [EOL] assert output . metres == pytest . approx ( [number] ) [EOL] assert output . feet == pytest . approx ( [number] ) [EOL] [EOL] [EOL] def test_equality ( ) : [EOL] version1 = distance . Distance ( [number] ) [EOL] version2 = distance . Distance ( [number] ) [EOL] [EOL] assert version1 == version2 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import typing [EOL] import pytest [EOL] from energuide import bilingual [EOL] from energuide import element [EOL] from energuide . embedded import code [EOL] from energuide . embedded import distance [EOL] from energuide . embedded import insulation [EOL] from energuide . embedded import window [EOL] from energuide . exceptions import InvalidEmbeddedDataTypeError [EOL] [EOL] [EOL] @ pytest . fixture def raw_sample ( ) : [EOL] doc = [string] [EOL] return element . Element . from_string ( doc ) [EOL] [EOL] [EOL] BAD_XML_DATA = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] @ pytest . fixture def sample_window_code ( ) : [EOL] return { [string] : code . WindowCode ( identifier = [string] , label = [string] , tags = { code . WindowCodeTag . GLAZING_TYPE : bilingual . Bilingual ( english = [string] , french = [string] , ) , code . WindowCodeTag . COATING_TINTS : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . FILL_TYPE : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . SPACER_TYPE : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . CODE_TYPE : bilingual . Bilingual ( english = [string] , french = [string] ) , code . WindowCodeTag . FRAME_MATERIAL : bilingual . Bilingual ( english = [string] , french = [string] ) , } ) } [EOL] [EOL] [EOL] @ pytest . fixture def sample ( sample_window_code ) : [EOL] return window . Window ( label = [string] , window_code = sample_window_code [ [string] ] , window_insulation = insulation . Insulation ( [number] ) , width = distance . Distance ( [number] ) , height = distance . Distance ( [number] ) , ) [EOL] [EOL] [EOL] def test_from_data ( raw_sample , sample_window_code , sample ) : [EOL] output = window . Window . from_data ( raw_sample , sample_window_code ) [EOL] assert output == sample [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , BAD_XML_DATA ) def test_bad_data ( bad_xml ) : [EOL] window_node = element . Element . from_string ( bad_xml ) [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as excinfo : [EOL] window . Window . from_data ( window_node , { } ) [EOL] [EOL] assert excinfo . value . data_class == window . Window [EOL] [EOL] [EOL] def test_from_data_missing_codes ( ) : [EOL] doc = [string] [EOL] sample = element . Element . from_string ( doc ) [EOL] output = window . Window . from_data ( sample , { } ) [EOL] assert output . label == [string] [EOL] assert output . window_code is None [EOL] assert output . to_dict ( ) [ [string] ] is None [EOL] [EOL] [EOL] def test_to_dict ( sample ) : [EOL] output = sample . to_dict ( ) [EOL] assert output == { [string] : [string] , [string] : [number] , [string] : pytest . approx ( [number] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : pytest . approx ( [number] ) , [string] : pytest . approx ( [number] ) , [string] : [number] , [string] : pytest . approx ( [number] ) , [string] : [number] , [string] : pytest . approx ( [number] ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,energuide.embedded.code.WindowCode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.window.Window$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import typing [EOL] import pytest [EOL] from energuide import bilingual [EOL] from energuide import element [EOL] from energuide . exceptions import InvalidEmbeddedDataTypeError [EOL] from energuide . embedded import heating [EOL] [EOL] [EOL] def sample_node ( heating_type = [string] , equipment_node = None , specification_node = None ) : [EOL] specification_node = sample_specifications ( ) if not specification_node else specification_node [EOL] equipment_node = sample_equipment ( ) if not equipment_node else equipment_node [EOL] heating_node = sample_heating_node ( heating_type ) [EOL] [EOL] data = [string] [EOL] node = element . Element . from_string ( data ) [EOL] type1_node = node . xpath ( [string] ) [ [number] ] [EOL] type1_node . insert ( [number] , heating_node ) [EOL] [EOL] heating_node . insert ( [number] , specification_node ) [EOL] heating_node . insert ( [number] , equipment_node ) [EOL] return node [EOL] [EOL] [EOL] def sample_heating_node ( node_name ) : [EOL] node = element . Element . new ( node_name ) [EOL] [EOL] equip_info_str = [string] [EOL] equip_info_node = element . Element . from_string ( equip_info_str ) [EOL] node . insert ( [number] , equip_info_node ) [EOL] return node [EOL] [EOL] [EOL] def sample_specifications ( efficiency = [number] , is_steady_state = False , capacity = [number] , capacity_units = [string] ) : [EOL] data = f""" [string] { efficiency } [string] { [string] if is_steady_state else [string] } [string] { capacity } [string] { capacity_units } [string] """ [EOL] return element . Element . from_string ( data ) [EOL] [EOL] [EOL] def sample_equipment ( energy_source_code = [number] , equipment_type_english = [string] , equipment_type_french = [string] ) : [EOL] data = f""" [string] { energy_source_code } [string] { equipment_type_english } [string] { equipment_type_french } [string] """ [EOL] return element . Element . from_string ( data ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_raw ( ) : [EOL] return sample_node ( ) [EOL] [EOL] [EOL] @ pytest . fixture def sample ( ) : [EOL] return heating . Heating ( heating_type = heating . HeatingType . FURNACE , energy_source = heating . EnergySource . NATURAL_GAS , equipment_type = bilingual . Bilingual ( english = [string] , french = [string] ) , label = [string] , output_size = [number] , efficiency = [number] , steady_state = [string] ) [EOL] [EOL] [EOL] def test_from_data ( sample_raw , sample ) : [EOL] output = heating . Heating . from_data ( sample_raw ) [EOL] assert output == sample [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_converts_btu ( unit ) : [EOL] specification_node = sample_specifications ( capacity = [number] , capacity_units = unit ) [EOL] node = sample_node ( specification_node = specification_node ) [EOL] output = heating . Heating . from_data ( node ) [EOL] assert output . output_size == [number] [EOL] [EOL] [EOL] def test_output_size_unknown_units ( ) : [EOL] specification_node = sample_specifications ( capacity_units = [string] ) [EOL] node = sample_node ( specification_node = specification_node ) [EOL] [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as ex : [EOL] heating . Heating . from_data ( node ) [EOL] assert ex . value . data_class == heating . Heating [EOL] [EOL] [EOL] def test_unknown_heating_type ( ) : [EOL] node = sample_node ( heating_type = [string] ) [EOL] [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as ex : [EOL] heating . Heating . from_data ( node ) [EOL] assert ex . value . data_class == heating . Heating [EOL] [EOL] [EOL] def test_boiler ( ) : [EOL] node = sample_node ( heating_type = [string] ) [EOL] output = heating . Heating . from_data ( node ) [EOL] assert output . heating_type == heating . HeatingType . BOILER [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] ] ) def test_wood_energy_source ( energy_code ) : [EOL] equipment_node = sample_equipment ( energy_source_code = energy_code ) [EOL] node = sample_node ( equipment_node = equipment_node ) [EOL] output = heating . Heating . from_data ( node ) [EOL] assert output . energy_source == heating . EnergySource . WOOD [EOL] [EOL] [EOL] def test_unknown_energy_source_code ( ) : [EOL] equipment_node = sample_equipment ( energy_source_code = [number] ) [EOL] node = sample_node ( equipment_node = equipment_node ) [EOL] [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as ex : [EOL] heating . Heating . from_data ( node ) [EOL] assert ex . value . data_class == heating . Heating [EOL] [EOL] [EOL] def test_steady_state ( ) : [EOL] specification_node = sample_specifications ( is_steady_state = True ) [EOL] node = sample_node ( specification_node = specification_node ) [EOL] output = heating . Heating . from_data ( node ) [EOL] assert output . steady_state == [string] [EOL] [EOL] [EOL] def test_to_dict ( sample ) : [EOL] assert sample . to_dict ( ) == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.heating.Heating$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Callable , List [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import typing [EOL] import pytest [EOL] from energuide import element [EOL] from energuide . embedded import area [EOL] from energuide . embedded import basement [EOL] from energuide . embedded import distance [EOL] from energuide . embedded import insulation [EOL] from energuide . exceptions import InvalidEmbeddedDataTypeError [EOL] [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement_floors_raw ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def sample_crawlspace_floors_raw ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement_wall_raw ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def sample_crawlspace_wall_raw ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement_header_raw ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement_raw ( sample_basement_header_raw , sample_basement_wall_raw , sample_basement_floors_raw ) : [EOL] [EOL] return f""" [string] { sample_basement_floors_raw } [string] { sample_basement_wall_raw } [string] { sample_basement_header_raw } [string] """ [EOL] [EOL] [EOL] @ pytest . fixture def sample_crawlspace_raw ( sample_crawlspace_floors_raw , sample_crawlspace_wall_raw , sample_basement_header_raw ) : [EOL] [EOL] return f""" [string] { sample_crawlspace_floors_raw } [string] { sample_crawlspace_wall_raw } [string] { sample_basement_header_raw } [string] """ [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement_floors_element ( sample_basement_floors_raw ) : [EOL] return element . Element . from_string ( sample_basement_floors_raw ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_crawlspace_floors_element ( sample_crawlspace_floors_raw ) : [EOL] return element . Element . from_string ( sample_crawlspace_floors_raw ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement_wall_element ( sample_basement_wall_raw ) : [EOL] return element . Element . from_string ( sample_basement_wall_raw ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_crawlspace_wall_element ( sample_crawlspace_wall_raw ) : [EOL] return element . Element . from_string ( sample_crawlspace_wall_raw ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement_header_element ( sample_basement_header_raw ) : [EOL] return element . Element . from_string ( sample_basement_header_raw ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement_element ( sample_basement_raw ) : [EOL] return element . Element . from_string ( sample_basement_raw ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_crawlspace_element ( sample_crawlspace_raw ) : [EOL] return element . Element . from_string ( sample_crawlspace_raw ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_slab_element ( ) : [EOL] xml = [string] [EOL] return element . Element . from_string ( xml ) [EOL] [EOL] @ pytest . fixture def sample_basement_walls ( ) : [EOL] return [ basement . BasementWall ( wall_type = basement . WallType . INTERIOR , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , composite_percentage = [number] , wall_area = area . Area ( [number] ) ) , basement . BasementWall ( wall_type = basement . WallType . INTERIOR , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , composite_percentage = [number] , wall_area = area . Area ( [number] ) ) , basement . BasementWall ( wall_type = basement . WallType . EXTERIOR , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , composite_percentage = [number] , wall_area = area . Area ( [number] ) ) , basement . BasementWall ( wall_type = basement . WallType . PONY , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , composite_percentage = [number] , wall_area = area . Area ( [number] ) ) , ] [EOL] [EOL] [EOL] @ pytest . fixture def sample_crawlspace_walls ( ) : [EOL] return [ basement . BasementWall ( wall_type = basement . WallType . NOT_APPLICABLE , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , composite_percentage = [number] , wall_area = area . Area ( [number] ) ) ] [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement_floors ( ) : [EOL] return [ basement . BasementFloor ( floor_type = basement . FloorType . SLAB , rectangular = True , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , length = distance . Distance ( distance_metres = [number] ) , width = distance . Distance ( distance_metres = [number] ) , perimeter = distance . Distance ( distance_metres = [number] ) , floor_area = area . Area ( [number] ) ) ] [EOL] [EOL] [EOL] @ pytest . fixture def sample_crawlspace_floors ( ) : [EOL] return [ basement . BasementFloor ( floor_type = basement . FloorType . SLAB , rectangular = True , nominal_insulation = None , effective_insulation = None , width = distance . Distance ( distance_metres = [number] ) , length = distance . Distance ( distance_metres = [number] ) , perimeter = distance . Distance ( distance_metres = [number] ) , floor_area = area . Area ( [number] ) ) , basement . BasementFloor ( floor_type = basement . FloorType . FLOOR_ABOVE_CRAWLSPACE , rectangular = True , nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , width = distance . Distance ( distance_metres = [number] ) , length = distance . Distance ( distance_metres = [number] ) , perimeter = distance . Distance ( distance_metres = [number] ) , floor_area = area . Area ( [number] ) ) ] [EOL] [EOL] [EOL] @ pytest . fixture def sample_slab_floors ( ) : [EOL] return [ basement . BasementFloor ( floor_type = basement . FloorType . SLAB , rectangular = True , nominal_insulation = None , effective_insulation = None , width = distance . Distance ( distance_metres = [number] ) , length = distance . Distance ( distance_metres = [number] ) , perimeter = distance . Distance ( distance_metres = [number] ) , floor_area = area . Area ( [number] ) ) ] [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement_header ( ) : [EOL] return basement . BasementHeader ( nominal_insulation = insulation . Insulation ( rsi = [number] ) , effective_insulation = insulation . Insulation ( rsi = [number] ) , height = distance . Distance ( distance_metres = [number] ) , perimeter = distance . Distance ( distance_metres = [number] ) ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_basement ( sample_basement_floors , sample_basement_walls , sample_basement_header , ) : [EOL] [EOL] return basement . Basement ( foundation_type = basement . FoundationType . BASEMENT , label = [string] , configuration_type = [string] , walls = sample_basement_walls , floors = sample_basement_floors , header = sample_basement_header ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_crawlspace ( sample_crawlspace_floors , sample_crawlspace_walls , sample_basement_header , ) : [EOL] [EOL] return basement . Basement ( foundation_type = basement . FoundationType . CRAWLSPACE , label = [string] , configuration_type = [string] , walls = sample_crawlspace_walls , floors = sample_crawlspace_floors , header = sample_basement_header , ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_slab ( sample_slab_floors ) : [EOL] return basement . Basement ( foundation_type = basement . FoundationType . SLAB , label = [string] , configuration_type = [string] , walls = [ ] , floors = sample_slab_floors , header = None , ) [EOL] [EOL] [EOL] def test_basement_walls_from_data ( sample_basement_walls , sample_basement_wall_element ) : [EOL] [EOL] output = basement . BasementWall . from_basement ( sample_basement_wall_element , [number] ) [EOL] assert output == sample_basement_walls [EOL] [EOL] [EOL] def test_crawlspace_walls_from_data ( sample_crawlspace_walls , sample_crawlspace_wall_element ) : [EOL] [EOL] output = basement . BasementWall . from_crawlspace ( sample_crawlspace_wall_element , [number] ) [EOL] assert output == sample_crawlspace_walls [EOL] [EOL] [EOL] def test_basement_walls_to_dict ( sample_basement_wall_element ) : [EOL] output = [ wall . to_dict ( ) for wall in basement . BasementWall . from_basement ( sample_basement_wall_element , [number] ) ] [EOL] assert sorted ( output , key = lambda wall : wall [ [string] ] ) [ [number] ] == { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] def test_crawlspace_walls_to_dict ( sample_crawlspace_wall_element ) : [EOL] output = [ wall . to_dict ( ) for wall in basement . BasementWall . from_crawlspace ( sample_crawlspace_wall_element , [number] ) ] [EOL] assert sorted ( output , key = lambda wall : wall [ [string] ] ) [ [number] ] == { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] def test_basement_floors_from_data ( sample_basement_floors , sample_basement_floors_element ) : [EOL] [EOL] output = basement . BasementFloor . from_basement ( sample_basement_floors_element ) [EOL] assert output == sample_basement_floors [EOL] [EOL] [EOL] def test_crawlspace_floors_from_data ( sample_crawlspace_floors , sample_crawlspace_floors_element ) : [EOL] [EOL] output = basement . BasementFloor . from_crawlspace ( sample_crawlspace_floors_element ) [EOL] assert output == sample_crawlspace_floors [EOL] [EOL] [EOL] def test_basement_floors_to_dict ( sample_basement_floors_element ) : [EOL] output = [ basement . to_dict ( ) for basement in basement . BasementFloor . from_basement ( sample_basement_floors_element ) ] [EOL] assert output == [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } ] [EOL] [EOL] [EOL] def test_crawlspace_floors_to_dict ( sample_crawlspace_floors_element ) : [EOL] output = [ basement . to_dict ( ) for basement in basement . BasementFloor . from_crawlspace ( sample_crawlspace_floors_element ) ] [EOL] [EOL] assert sorted ( output , key = lambda basement : basement [ [string] ] ) [ [number] ] == { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] def test_basement_header_from_data ( sample_basement_header , sample_basement_header_element ) : [EOL] [EOL] output = basement . BasementHeader . from_data ( sample_basement_header_element ) [EOL] assert output == sample_basement_header [EOL] [EOL] [EOL] def test_basement_header_to_dict ( sample_basement_header_element ) : [EOL] output = basement . BasementHeader . from_data ( sample_basement_header_element ) . to_dict ( ) [EOL] assert output == { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] def test_basement_from_data ( sample_basement , sample_basement_element ) : [EOL] output = basement . Basement . from_data ( sample_basement_element ) [EOL] assert output == sample_basement [EOL] [EOL] [EOL] def test_crawlspace_from_data ( sample_crawlspace , sample_crawlspace_element ) : [EOL] output = basement . Basement . from_data ( sample_crawlspace_element ) [EOL] assert output == sample_crawlspace [EOL] [EOL] [EOL] def test_slab_from_data ( sample_slab , sample_slab_element ) : [EOL] [EOL] output = basement . Basement . from_data ( sample_slab_element ) [EOL] assert output == sample_slab [EOL] [EOL] [EOL] def test_slab_to_dict ( sample_slab_element ) : [EOL] output = basement . Basement . from_data ( sample_slab_element ) . to_dict ( ) [EOL] assert output == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } ] , [string] : None , } [EOL] [EOL] [EOL] def test_crawlspace_to_dict ( sample_crawlspace_element ) : [EOL] output = basement . Basement . from_data ( sample_crawlspace_element ) . to_dict ( ) [EOL] assert output == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } ] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , } [EOL] [EOL] [EOL] def test_basement_to_dict ( sample_basement_element ) : [EOL] output = basement . Basement . from_data ( sample_basement_element ) . to_dict ( ) [EOL] assert output == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } ] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , } [EOL] [EOL] [EOL] def bad_xml ( ) : [EOL] return [ ( [string] , basement . BasementFloor . from_basement , basement . BasementFloor , ) , ( [string] , basement . BasementFloor . from_crawlspace , basement . BasementFloor , ) , ( [string] , basement . BasementFloor . from_basement , basement . BasementFloor , ) , ( [string] , basement . BasementFloor . from_crawlspace , basement . BasementFloor , ) , ( [string] , lambda node : basement . BasementWall . from_crawlspace ( node , [number] ) , basement . BasementWall , ) , ( [string] , lambda node : basement . BasementWall . from_crawlspace ( node , [number] ) , basement . BasementWall , ) , ( [string] , lambda node : basement . BasementWall . from_crawlspace ( node , [number] ) , basement . BasementWall , ) , ( [string] , lambda node : basement . BasementWall . from_basement ( node , [number] ) , basement . BasementWall , ) , ( [string] , lambda node : basement . BasementWall . from_basement ( node , [number] ) , basement . BasementWall , ) , ( [string] , lambda node : basement . BasementWall . from_basement ( node , [number] ) , basement . BasementWall , ) , ( [string] , basement . BasementHeader . from_data , basement . BasementHeader , ) , ( [string] , basement . BasementHeader . from_data , basement . BasementHeader , ) , ( [string] , basement . Basement . from_data , basement . Basement , ) , ( [string] , basement . Basement . from_data , basement . Basement , ) , ( [string] , basement . Basement . from_data , basement . Basement , ) , ( [string] , basement . Basement . from_data , basement . Basement , ) ] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , bad_xml ( ) ) def test_bad_data ( bad_xml , parse_function , data_class ) : [EOL] node = element . Element . from_string ( bad_xml ) [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as excinfo : [EOL] parse_function ( node ) [EOL] [EOL] assert excinfo . value . data_class is data_class [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[energuide.embedded.basement.BasementWall]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[energuide.embedded.basement.BasementWall]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[energuide.embedded.basement.BasementFloor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[energuide.embedded.basement.BasementFloor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[energuide.embedded.basement.BasementFloor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.basement.BasementHeader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.basement.Basement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.basement.Basement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.basement.Basement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Callable[[energuide.element.Element],typing.Any],builtins.type]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Optional [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] [EOL] [EOL] class EnerguideError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidGroupSizeError ( EnerguideError ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidInputDataError ( EnerguideError ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidEmbeddedDataTypeError ( EnerguideError ) : [EOL] [EOL] def __init__ ( self , data_class , msg = None ) : [EOL] self . data_class = data_class [EOL] [EOL] if msg is not None : [EOL] super ( ) . __init__ ( msg ) [EOL] else : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] class ElementGetValueError ( EnerguideError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Type[typing.Any]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 $typing.Type[typing.Any]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import typing [EOL] [EOL] [EOL] class Bilingual ( typing . NamedTuple ) : [EOL] english = ... [EOL] french = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
	0
import builtins [EOL] class Distance : [EOL] _FEET_MULTIPLIER = [number] [EOL] [EOL] def __init__ ( self , distance_metres ) : [EOL] self . _distance = distance_metres [EOL] [EOL] @ property def metres ( self ) : [EOL] return self . _distance [EOL] [EOL] @ property def feet ( self ) : [EOL] return self . _distance * self . _FEET_MULTIPLIER [EOL] [EOL] @ classmethod def from_feet ( cls , distance_feet ) : [EOL] return cls ( distance_feet / cls . _FEET_MULTIPLIER ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , Distance ) and self . _distance == other . _distance [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . _distance } [string] ' [EOL]	0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Distance'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class Insulation : [EOL] _RSI_MULTIPLIER = [number] [EOL] [EOL] def __init__ ( self , rsi ) : [EOL] self . _rsi = rsi [EOL] [EOL] @ property def rsi ( self ) : [EOL] return self . _rsi [EOL] [EOL] @ property def r_value ( self ) : [EOL] return self . _rsi * self . _RSI_MULTIPLIER [EOL] [EOL] @ classmethod def from_r_value ( cls , r_value ) : [EOL] return cls ( r_value / cls . _RSI_MULTIPLIER ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , Insulation ) and self . _rsi == other . _rsi [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . _rsi } [string] ' [EOL]	0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Insulation'$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import builtins [EOL] import typing [EOL] import etl [EOL] class Area : [EOL] _FEET_SQUARED_MULTIPLIER = [number] ** [number] [EOL] [EOL] def __init__ ( self , area_metric ) : [EOL] self . _area_metric = float ( area_metric ) [EOL] [EOL] @ property def square_metres ( self ) : [EOL] return self . _area_metric [EOL] [EOL] @ property def square_feet ( self ) : [EOL] return self . _area_metric * self . _FEET_SQUARED_MULTIPLIER [EOL] [EOL] @ classmethod def from_square_feet ( cls , area_square_feet ) : [EOL] return cls ( area_square_feet / cls . _FEET_SQUARED_MULTIPLIER ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , Area ) and self . _area_metric == other . _area_metric [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . _area_metric } [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Area'$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import setuptools [EOL] [EOL] [EOL] setuptools . setup ( name = [string] , version = [string] , long_description = [string] , author = [string] , url = [string] , packages = setuptools . find_packages ( [string] ) , package_dir = { [string] : [string] } , classifiers = [ [string] , [string] , [string] , [string] , ] , entry_points = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import logging [EOL] import logging [EOL] [EOL] [EOL] def unwrap_exception_message ( exc , join = [string] ) : [EOL] if exc . __context__ : [EOL] if exc . args : [EOL] return f'{ exc }{ join }{ unwrap_exception_message ( exc . __context__ ) }' [EOL] return f'{ unwrap_exception_message ( exc . __context__ ) }' [EOL] return f'{ exc }' [EOL] [EOL] [EOL] def get_logger ( name ) : [EOL] logger = logging . getLogger ( name ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] if not logger . hasHandlers ( ) : [EOL] handler = logging . StreamHandler ( ) [EOL] formatter = logging . Formatter ( fmt = [string] , datefmt = [string] ) [EOL] handler . setFormatter ( formatter ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] return logger [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Dict , Any , Union , Optional , Iterator , Iterable [EOL] import builtins [EOL] import typing [EOL] import csv [EOL] import cerberus [EOL] import csv [EOL] import json [EOL] import typing [EOL] import sys [EOL] import zipfile [EOL] import cerberus [EOL] from tqdm import tqdm [EOL] from energuide import logger [EOL] from energuide import element [EOL] from energuide import snippets [EOL] from energuide . exceptions import InvalidInputDataError [EOL] from energuide . exceptions import EnerguideError [EOL] [EOL] [EOL] LOGGER = logger . get_logger ( __name__ ) [EOL] [EOL] [EOL] REQUIRED_FIELDS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] NULLABLE_FIELDS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] INPUT_SCHEMA = { field : { [string] : [string] , [string] : True } for field in REQUIRED_FIELDS } [EOL] for field in NULLABLE_FIELDS : [EOL] INPUT_SCHEMA [ field ] = { [string] : [string] , [string] : True , [string] : True } [EOL] [EOL] INPUT_SCHEMA [ [string] ] = { [string] : [string] , [string] : False , [string] : True } [EOL] INPUT_SCHEMA [ [string] ] = { [string] : [string] , [string] : True , [string] : True , [string] : { [string] : [string] } } [EOL] [EOL] [EOL] _WINDOWS_LONG_SIZE = ( [number] ** [number] ) - [number] [EOL] [EOL] [EOL] def _empty_to_none ( row ) : [EOL] for key , value in row . items ( ) : [EOL] if value == [string] : [EOL] row [ key ] = None [EOL] return row [EOL] [EOL] [EOL] def _validated ( row , validator ) : [EOL] if not validator . validate ( row ) : [EOL] error_keys = [string] . join ( validator . errors . keys ( ) ) [EOL] raise InvalidInputDataError ( f' [string] { error_keys } [string] { row . get ( [string] ) }' ) [EOL] return validator . document [EOL] [EOL] [EOL] def _truncate_postal_code ( row ) : [EOL] postal = row . get ( [string] ) [EOL] row [ [string] ] = postal [ [number] : [number] ] if postal else None [EOL] return row [EOL] [EOL] [EOL] def _safe_merge ( data , extra ) : [EOL] for key , value in extra . items ( ) : [EOL] assert key not in data [EOL] data [ key ] = value [EOL] return data [EOL] [EOL] [EOL] def _snip_upgrade_order ( row ) : [EOL] if row . get ( [string] ) : [EOL] xml = typing . cast ( str , row [ [string] ] ) [EOL] [EOL] doc = element . Element . from_string ( xml ) [EOL] upgrade_order = snippets . snip_energy_upgrade_order ( doc ) [EOL] _safe_merge ( row , upgrade_order . to_dict ( ) ) [EOL] else : [EOL] _safe_merge ( row , snippets . EnergyUpgradesSnippet . EMPTY_SNIPPET ) [EOL] [EOL] return row [EOL] [EOL] [EOL] def _drop_unwanted ( row ) : [EOL] row . pop ( [string] , None ) [EOL] return row [EOL] [EOL] [EOL] def _read_csv ( filepath , show_progress ) : [EOL] try : [EOL] csv . field_size_limit ( sys . maxsize ) [EOL] except OverflowError : [EOL] csv . field_size_limit ( _WINDOWS_LONG_SIZE ) [EOL] [EOL] with open ( filepath , [string] , encoding = [string] , newline = [string] ) as file : [EOL] total_lines = sum ( [number] for _ in file ) [EOL] [EOL] with tqdm ( open ( filepath , [string] , encoding = [string] , newline = [string] ) , total = total_lines , unit = [string] , disable = not show_progress ) as file : [EOL] csv_reader = csv . DictReader ( file ) [EOL] for row in csv_reader : [EOL] yield row [EOL] [EOL] [EOL] def extract_data ( input_path , show_progress = False ) : [EOL] validator = cerberus . Validator ( INPUT_SCHEMA , purge_unknown = True ) [EOL] rows = _read_csv ( input_path , show_progress ) [EOL] [EOL] for row in rows : [EOL] try : [EOL] patched = _empty_to_none ( row ) [EOL] filtered = _truncate_postal_code ( patched ) [EOL] ordered = _snip_upgrade_order ( filtered ) [EOL] validated_data = _validated ( ordered , validator ) [EOL] cleaned = _drop_unwanted ( validated_data ) [EOL] yield cleaned [EOL] except EnerguideError as ex : [EOL] LOGGER . error ( f" [string] { row . get ( [string] , [string] ) } [string] { ex }" ) [EOL] yield None [EOL] [EOL] [EOL] def write_data ( data , output_path ) : [EOL] records_written , records_failed = [number] , [number] [EOL] with zipfile . ZipFile ( output_path , mode = [string] , compression = zipfile . ZIP_DEFLATED ) as output_zip : [EOL] for blob in data : [EOL] if blob is None or not all ( ( blob . get ( [string] ) , blob . get ( [string] ) , blob . get ( [string] ) ) ) : [EOL] records_failed += [number] [EOL] else : [EOL] blob_id = blob . get ( [string] ) [EOL] eval_id = blob . get ( [string] ) [EOL] house_id = blob . get ( [string] ) [EOL] output_zip . writestr ( f'{ house_id } [string] { eval_id } [string] { blob_id }' , json . dumps ( blob ) ) [EOL] records_written += [number] [EOL] [EOL] return records_written , records_failed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Optional[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import typing [EOL] from energuide import element [EOL] [EOL] [EOL] class _EnergyUpgradesSnippet ( typing . NamedTuple ) : [EOL] upgrades = ... [EOL] [EOL] [EOL] class EnergyUpgradesSnippet ( _EnergyUpgradesSnippet ) : [EOL] [EOL] EMPTY_SNIPPET = { [string] : [ ] , } [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . upgrades , } [EOL] [EOL] [EOL] def snip_energy_upgrade_order ( energy_upgrades ) : [EOL] upgrades = energy_upgrades . xpath ( [string] ) [EOL] [EOL] return EnergyUpgradesSnippet ( upgrades = [ upgrade . to_string ( ) for upgrade in upgrades ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $EnergyUpgradesSnippet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import typing [EOL] import cerberus [EOL] from energuide import element [EOL] [EOL] [EOL] class DwellingValidator ( cerberus . Validator ) : [EOL] [EOL] def _validate_type_xml ( self , value ) : [comment] [EOL] return isinstance ( value , element . Element ) [EOL] [EOL] def _normalize_coerce_parse_xml ( self , value ) : [comment] [EOL] assert isinstance ( value , str ) , [string] [EOL] return element . Element . from_string ( value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
import builtins [EOL] import enum [EOL] from energuide . exceptions import InvalidInputDataError [EOL] [EOL] [EOL] @ enum . unique class EvaluationType ( enum . Enum ) : [EOL] PRE_RETROFIT = [string] [EOL] POST_RETROFIT = [string] [EOL] INCENTIVE_PROGRAM = [string] [EOL] [EOL] @ classmethod def from_code ( cls , code ) : [EOL] if code == cls . PRE_RETROFIT . value : [EOL] return EvaluationType . PRE_RETROFIT [EOL] elif code == cls . POST_RETROFIT . value : [EOL] return EvaluationType . POST_RETROFIT [EOL] elif code == cls . INCENTIVE_PROGRAM . value : [EOL] return EvaluationType . INCENTIVE_PROGRAM [EOL] raise InvalidInputDataError ( f' [string] { code }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $'EvaluationType'$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import List , Dict , Any , Optional , Iterator [EOL] import builtins [EOL] import typing [EOL] import itertools [EOL] import typing [EOL] from energuide . embedded import composite [EOL] from energuide . exceptions import InvalidEmbeddedDataTypeError [EOL] [EOL] [EOL] class _Wall ( typing . NamedTuple ) : [EOL] insulation = ... [EOL] heat_lost = ... [EOL] [EOL] [EOL] class Wall ( _Wall ) : [EOL] [EOL] @ classmethod def from_data ( cls , insulation , heat_lost ) : [EOL] [EOL] if insulation : [EOL] args = [ iter ( insulation . split ( [string] ) ) ] * [number] [EOL] groups = itertools . zip_longest ( fillvalue = [string] , * args ) [EOL] [EOL] try : [EOL] composite_insulation = [ composite . CompositeValue ( percentage = float ( percentage ) , value = float ( r_value ) , value_name = [string] , ) for percentage , r_value in groups ] [EOL] except ValueError as exc : [EOL] raise InvalidEmbeddedDataTypeError ( Wall , [string] ) from exc [EOL] [EOL] else : [EOL] composite_insulation = [ ] [EOL] [EOL] return Wall ( insulation = composite_insulation , heat_lost = heat_lost ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : [ insulation . to_dict ( ) for insulation in self . insulation ] , [string] : self . heat_lost , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[energuide.embedded.composite.CompositeValue]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Wall'$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.List[typing.Iterator[builtins.str]]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Iterator[builtins.str]]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.List[typing.Any]$ 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import re [EOL] [EOL] [EOL] class HouseType ( ) : [EOL] [EOL] @ classmethod def normalize ( cls , unclean_string ) : [EOL] lowercase = unclean_string . lower ( ) [EOL] alpha = re . sub ( [string] , [string] , lowercase ) [EOL] separated = re . sub ( [string] , [string] , alpha ) [EOL] [EOL] return separated . capitalize ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] [EOL] class _CompositeValue ( typing . NamedTuple ) : [EOL] percentage = ... [EOL] value = ... [EOL] value_name = ... [EOL] [EOL] class CompositeValue ( _CompositeValue ) : [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . percentage , self . value_name : self . value , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import energuide [EOL] import copy [EOL] import datetime [EOL] import typing [EOL] import pytest [EOL] from energuide import dwelling [EOL] from energuide . embedded import upgrade [EOL] from energuide . embedded import measurement [EOL] from energuide . embedded import composite [EOL] from energuide . embedded import walls [EOL] from energuide . embedded import region [EOL] from energuide . embedded import evaluation_type [EOL] from energuide . exceptions import InvalidInputDataError [EOL] from energuide . exceptions import InvalidGroupSizeError [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . fixture def upgrades_input ( ) : [EOL] return [ [string] , [string] , [string] , ] [EOL] [EOL] [EOL] @ pytest . fixture def sample_input_d ( upgrades_input ) : [EOL] [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : upgrades_input , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . fixture def sample_input_e ( sample_input_d ) : [EOL] output = copy . deepcopy ( sample_input_d ) [EOL] output [ [string] ] = [string] [EOL] output [ [string] ] = [string] [EOL] return output [EOL] [EOL] [EOL] @ pytest . fixture def sample_input_missing ( sample_input_d ) : [EOL] output = copy . deepcopy ( sample_input_d ) [EOL] output [ [string] ] = None [EOL] output [ [string] ] = None [EOL] output [ [string] ] = None [EOL] return output [EOL] [EOL] [EOL] @ pytest . fixture def sample_parsed_d ( sample_input_d ) : [EOL] return dwelling . ParsedDwellingDataRow . from_row ( sample_input_d ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_parsed_e ( sample_input_e ) : [EOL] return dwelling . ParsedDwellingDataRow . from_row ( sample_input_e ) [EOL] [EOL] [EOL] [EOL] class TestParsedDwellingDataRow : [EOL] [EOL] def test_from_row ( self , sample_input_d ) : [EOL] output = dwelling . ParsedDwellingDataRow . from_row ( sample_input_d ) [EOL] [EOL] assert output == dwelling . ParsedDwellingDataRow ( house_id = [number] , eval_id = [number] , file_id = [string] , eval_type = evaluation_type . EvaluationType . PRE_RETROFIT , entry_date = datetime . date ( [number] , [number] , [number] ) , creation_date = datetime . datetime ( [number] , [number] , [number] , [number] ) , modification_date = datetime . datetime ( [number] , [number] , [number] , [number] ) , year_built = [number] , city = [string] , region = region . Region . ONTARIO , forward_sortation_area = [string] , energy_upgrades = [ upgrade . Upgrade ( upgrade_type = [string] , cost = [number] , priority = [number] , ) , upgrade . Upgrade ( upgrade_type = [string] , cost = [number] , priority = [number] , ) , upgrade . Upgrade ( upgrade_type = [string] , cost = [number] , priority = [number] , ) , ] , house_type = [string] , heated_floor_area = [number] , egh_rating = measurement . Measurement ( measurement = [number] , upgrade = [number] , ) , ers_rating = measurement . Measurement ( measurement = [number] , upgrade = [number] , ) , greenhouse_gas_emissions = measurement . Measurement ( measurement = [number] , upgrade = [number] , ) , energy_intensity = measurement . Measurement ( measurement = [number] , upgrade = [number] , ) , walls = measurement . Measurement ( measurement = walls . Wall ( insulation = [ composite . CompositeValue ( percentage = [number] , value = [number] , value_name = [string] ) , composite . CompositeValue ( percentage = [number] , value = [number] , value_name = [string] ) , composite . CompositeValue ( percentage = [number] , value = [number] , value_name = [string] ) , ] , heat_lost = [number] ) , upgrade = walls . Wall ( insulation = [ composite . CompositeValue ( percentage = [number] , value = [number] , value_name = [string] ) , composite . CompositeValue ( percentage = [number] , value = [number] , value_name = [string] ) , composite . CompositeValue ( percentage = [number] , value = [number] , value_name = [string] ) , ] , heat_lost = [number] ) ) , design_heat_loss = measurement . Measurement ( measurement = [number] , upgrade = [number] , ) , ) [EOL] [EOL] def test_null_fields_are_accepted ( self , sample_input_missing ) : [EOL] output = dwelling . ParsedDwellingDataRow . from_row ( sample_input_missing ) [EOL] [EOL] assert output . modification_date is None [EOL] assert output . ers_rating == measurement . Measurement ( None , None ) [EOL] [EOL] def test_bad_postal_code ( self , sample_input_d ) : [EOL] sample_input_d [ [string] ] = [string] [EOL] with pytest . raises ( InvalidInputDataError ) : [EOL] dwelling . ParsedDwellingDataRow . from_row ( sample_input_d ) [EOL] [EOL] def test_from_bad_row ( self ) : [EOL] input_data = { [string] : [number] } [EOL] with pytest . raises ( InvalidInputDataError ) as ex : [EOL] dwelling . ParsedDwellingDataRow . from_row ( input_data ) [EOL] assert [string] in ex . exconly ( ) [EOL] assert [string] not in ex . exconly ( ) [EOL] [EOL] [EOL] class TestDwellingEvaluation : [EOL] [EOL] def test_eval_type ( self , sample_parsed_d ) : [EOL] output = dwelling . Evaluation . from_data ( sample_parsed_d ) [EOL] assert output . evaluation_type == evaluation_type . EvaluationType . PRE_RETROFIT [EOL] [EOL] def test_entry_date ( self , sample_parsed_d ) : [EOL] output = dwelling . Evaluation . from_data ( sample_parsed_d ) [EOL] assert output . entry_date == datetime . date ( [number] , [number] , [number] ) [EOL] [EOL] def test_creation_date ( self , sample_parsed_d ) : [EOL] output = dwelling . Evaluation . from_data ( sample_parsed_d ) [EOL] assert output . creation_date == datetime . datetime ( [number] , [number] , [number] , [number] ) [EOL] [EOL] def test_modification_date ( self , sample_parsed_d ) : [EOL] output = dwelling . Evaluation . from_data ( sample_parsed_d ) [EOL] assert output . modification_date == datetime . datetime ( [number] , [number] , [number] , [number] ) [EOL] [EOL] def test_to_dict ( self , sample_parsed_d ) : [EOL] output = dwelling . Evaluation . from_data ( sample_parsed_d ) . to_dict ( ) [EOL] assert output == { [string] : [string] , [string] : [number] , [string] : [string] , [string] : evaluation_type . EvaluationType . PRE_RETROFIT . value , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [number] , } , { [string] : [string] , [string] : [number] , [string] : [number] , } , { [string] : [string] , [string] : [number] , [string] : [number] , } , ] , [string] : [number] , [string] : { [string] : [number] , [string] : [number] , } , [string] : { [string] : [number] , [string] : [number] , } , [string] : { [string] : [number] , [string] : [number] , } , [string] : { [string] : [number] , [string] : [number] , } , [string] : { [string] : { [string] : [ { [string] : [number] , [string] : [number] , } , { [string] : [number] , [string] : [number] , } , { [string] : [number] , [string] : [number] , } , ] , [string] : [number] } , [string] : { [string] : [ { [string] : [number] , [string] : [number] , } , { [string] : [number] , [string] : [number] , } , { [string] : [number] , [string] : [number] , } , ] , [string] : [number] } } , [string] : { [string] : [number] , [string] : [number] , } } [EOL] [EOL] [EOL] class TestDwelling : [EOL] [EOL] @ pytest . fixture def sample ( self , sample_input_d , sample_input_e , ) : [EOL] return [ sample_input_d , sample_input_e ] . copy ( ) [EOL] [EOL] @ pytest . fixture def dummy_sample ( self , sample_input_d , sample_input_e , ) : [EOL] dummy_d = sample_input_e . copy ( ) [EOL] dummy_d [ [string] ] = [string] [EOL] [EOL] new_e = sample_input_e . copy ( ) [EOL] new_e [ [string] ] = [string] [EOL] [EOL] new_f = sample_input_e . copy ( ) [EOL] new_f [ [string] ] = [string] [EOL] new_f [ [string] ] = [string] [EOL] [EOL] return [ sample_input_d , sample_input_e , dummy_d , new_e , new_f ] . copy ( ) [EOL] [EOL] def test_house_id ( self , sample ) : [EOL] output = dwelling . Dwelling . from_group ( sample ) [EOL] assert output . house_id == [number] [EOL] [EOL] def test_year_built ( self , sample ) : [EOL] output = dwelling . Dwelling . from_group ( sample ) [EOL] assert output . year_built == [number] [EOL] [EOL] def test_address_data ( self , sample ) : [EOL] output = dwelling . Dwelling . from_group ( sample ) [EOL] assert output . city == [string] [EOL] assert output . region == region . Region . ONTARIO [EOL] assert output . forward_sortation_area == [string] [EOL] [EOL] def test_evaluations ( self , sample ) : [EOL] output = dwelling . Dwelling . from_group ( sample ) [EOL] assert len ( output . evaluations ) == [number] [EOL] [EOL] def test_no_data ( self ) : [EOL] data = [ ] [EOL] with pytest . raises ( InvalidGroupSizeError ) : [EOL] dwelling . Dwelling . from_group ( data ) [EOL] [EOL] def test_to_dict ( self , sample ) : [EOL] output = dwelling . Dwelling . from_group ( sample ) . to_dict ( ) [EOL] evaluations = output . pop ( [string] ) [EOL] [EOL] assert output == { [string] : [number] , [string] : [number] , [string] : [string] , [string] : region . Region . ONTARIO . value , [string] : [string] , } [EOL] [EOL] assert [string] not in output [EOL] assert len ( evaluations ) == [number] [EOL] [EOL] def test_filter_dummies ( self , dummy_sample ) : [EOL] output = dwelling . Dwelling . from_group ( dummy_sample ) [EOL] assert len ( output . evaluations ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $energuide.dwelling.ParsedDwellingDataRow$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import energuide [EOL] import os [EOL] import pytest [EOL] from energuide import element [EOL] from energuide import snippets [EOL] from energuide import validator [EOL] [EOL] [EOL] @ pytest . fixture def doc ( ) : [EOL] sample_filename = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] with open ( sample_filename , [string] ) as h2k : [EOL] doc = element . Element . parse ( h2k ) [EOL] return doc [EOL] [EOL] [EOL] def test_energy_snippet_to_dict ( doc ) : [EOL] output = snippets . snip_energy_upgrade_order ( doc ) . to_dict ( ) [EOL] assert len ( output ) == [number] [EOL] [EOL] [EOL] def test_upgrades_snippet ( doc ) : [EOL] output = snippets . snip_energy_upgrade_order ( doc ) [EOL] assert len ( output . upgrades ) == [number] [EOL] checker = validator . DwellingValidator ( { [string] : { [string] : [string] , [string] : True , [string] : { [string] : [string] , [string] : [string] } } } , allow_unknown = True ) [EOL] [EOL] document = { [string] : output . upgrades } [EOL] assert checker . validate ( document ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from energuide import logger [EOL] [EOL] [EOL] def test_unwrap_exception_message ( ) : [EOL] try : [EOL] try : [EOL] raise ZeroDivisionError ( [string] ) [EOL] except ZeroDivisionError as exc : [EOL] raise ValueError ( [string] ) from exc [EOL] except ValueError as exc : [EOL] assert logger . unwrap_exception_message ( exc , [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import pymongo [EOL] import typing [EOL] import energuide [EOL] import typing [EOL] import pymongo [EOL] import pytest [EOL] from energuide . embedded import region [EOL] from energuide import database [EOL] from energuide import dwelling [EOL] [EOL] [EOL] @ pytest . fixture def load_data ( ) : [EOL] return [ dwelling . Dwelling ( house_id = [number] , year_built = [number] , city = [string] , region = region . Region . ONTARIO , forward_sortation_area = [string] , evaluations = [ ] ) , dwelling . Dwelling ( house_id = [number] , year_built = [number] , city = [string] , region = region . Region . ONTARIO , forward_sortation_area = [string] , evaluations = [ ] ) , dwelling . Dwelling ( house_id = [number] , year_built = [number] , city = [string] , region = region . Region . ONTARIO , forward_sortation_area = [string] , evaluations = [ ] ) , ] [EOL] [EOL] [EOL] def test_load ( database_coordinates , mongo_client , database_name , collection , load_data ) : [EOL] database . load ( coords = database_coordinates , database_name = database_name , collection_name = collection , data = load_data , update = False ) [EOL] assert mongo_client [ database_name ] [ collection ] . count ( ) == [number] [EOL] [EOL] [EOL] def test_load_update ( database_coordinates , mongo_client , database_name , collection , load_data ) : [EOL] database . load ( coords = database_coordinates , database_name = database_name , collection_name = collection , data = load_data , update = False ) [EOL] [EOL] assert mongo_client [ database_name ] [ collection ] . count ( ) == [number] [EOL] load_data [ [number] ] = dwelling . Dwelling ( house_id = [number] , year_built = [number] , city = [string] , region = region . Region . ONTARIO , forward_sortation_area = [string] , evaluations = [ ] ) [EOL] load_data . append ( dwelling . Dwelling ( house_id = [number] , year_built = [number] , city = [string] , region = region . Region . ONTARIO , forward_sortation_area = [string] , evaluations = [ ] ) ) [EOL] [EOL] database . load ( coords = database_coordinates , database_name = database_name , collection_name = collection , data = load_data , update = True ) [EOL] assert mongo_client [ database_name ] [ collection ] . count ( ) == [number] [EOL] assert mongo_client [ database_name ] [ collection ] . find_one ( { [string] : [number] } ) [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[energuide.dwelling.Dwelling]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Mapping , List , Any , Dict , Union , Optional [EOL] import builtins [EOL] import _pytest [EOL] import py [EOL] import csv [EOL] import typing [EOL] import csv [EOL] import json [EOL] import os [EOL] import typing [EOL] import zipfile [EOL] import _pytest . fixtures [EOL] import py . _path . local [EOL] import pytest [EOL] from energuide import extractor [EOL] [EOL] [EOL] def _write_csv ( filepath , data ) : [EOL] with open ( filepath , [string] ) as file : [EOL] writer = csv . DictWriter ( file , fieldnames = list ( data . keys ( ) ) ) [EOL] writer . writeheader ( ) [EOL] writer . writerow ( dict ( data ) ) [EOL] [EOL] [EOL] @ pytest . fixture def base_data ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . fixture def extra_data ( ) : [EOL] data = base_data ( ) [EOL] data [ [string] ] = [string] [EOL] data [ [string] ] = [string] [EOL] return data [EOL] [EOL] [EOL] @ pytest . fixture def missing_data ( ) : [EOL] data = base_data ( ) [EOL] data . pop ( [string] ) [EOL] return data [EOL] [EOL] [EOL] @ pytest . fixture def nullable_data ( ) : [EOL] data = base_data ( ) [EOL] data [ [string] ] = None [EOL] return data [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ base_data ( ) , extra_data ( ) ] ) def valid_filepath ( tmpdir , request ) : [EOL] data_dict = typing . cast ( typing . Dict [ str , str ] , request . param ) [EOL] filepath = os . path . join ( tmpdir , [string] ) [EOL] _write_csv ( filepath , data_dict ) [EOL] return filepath [EOL] [EOL] [EOL] @ pytest . fixture def missing_filepath ( tmpdir , missing_data ) : [EOL] filepath = os . path . join ( tmpdir , [string] ) [EOL] _write_csv ( filepath , missing_data ) [EOL] return filepath [EOL] [EOL] [EOL] @ pytest . fixture def extra_filepath ( tmpdir , extra_data ) : [EOL] filepath = os . path . join ( tmpdir , [string] ) [EOL] _write_csv ( filepath , extra_data ) [EOL] return filepath [EOL] [EOL] [EOL] def test_extract_valid ( valid_filepath ) : [EOL] output = next ( extractor . extract_data ( valid_filepath ) ) [EOL] assert output [EOL] item = dict ( output ) [EOL] assert [string] in item [EOL] [EOL] [EOL] def test_purge_unknown ( extra_filepath ) : [EOL] output = next ( extractor . extract_data ( extra_filepath ) ) [EOL] assert output [EOL] item = dict ( output ) [EOL] assert [string] not in item [EOL] [EOL] [EOL] def test_extract_missing ( missing_filepath ) : [EOL] output = extractor . extract_data ( missing_filepath ) [EOL] result = [ x for x in output ] [EOL] assert result == [ None ] [EOL] [EOL] [EOL] def test_empty_to_none ( tmpdir , nullable_data ) : [EOL] filepath = os . path . join ( tmpdir , [string] ) [EOL] _write_csv ( filepath , nullable_data ) [EOL] output = extractor . extract_data ( filepath ) [EOL] row = next ( output ) [EOL] assert row [EOL] assert row [ [string] ] is None [EOL] [EOL] [EOL] def test_write_data ( tmpdir ) : [EOL] output_path = os . path . join ( tmpdir , [string] ) [EOL] [EOL] data = [ { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] [EOL] result = extractor . write_data ( data , output_path ) [EOL] assert result == ( [number] , [number] ) [EOL] [EOL] with zipfile . ZipFile ( output_path , [string] ) as output_file : [EOL] files = [ output_file . read ( [string] ) , output_file . read ( [string] ) ] [EOL] [EOL] assert [ json . loads ( file ) for file in files ] == data [EOL] [EOL] [EOL] def test_write_bad_data ( tmpdir ) : [EOL] output_path = os . path . join ( tmpdir , [string] ) [EOL] [EOL] data = [ { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [number] } , ] [EOL] [EOL] extractor . write_data ( data , output_path ) [EOL] [EOL] with zipfile . ZipFile ( output_path , [string] ) as output : [EOL] assert len ( output . namelist ( ) ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Optional [EOL] import builtins [EOL] import _pytest [EOL] import click [EOL] import py [EOL] import csv [EOL] import pymongo [EOL] import typing [EOL] import csv [EOL] import os [EOL] import typing [EOL] import zipfile [EOL] import py [EOL] import _pytest [EOL] from click import testing [comment] [EOL] import pymongo [EOL] import pytest [EOL] from energuide import cli [EOL] [EOL] [EOL] def data1 ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def data2 ( ) : [EOL] data = data1 ( ) [EOL] data [ [string] ] = [string] [EOL] data [ [string] ] = [string] [EOL] return data [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ data1 ( ) , data2 ( ) ] ) def data_dict ( request ) : [EOL] return request . param [EOL] [EOL] [EOL] @ pytest . fixture def valid_filepath ( tmpdir , data_dict ) : [EOL] filepath = os . path . join ( tmpdir , [string] ) [EOL] [EOL] with open ( filepath , [string] ) as file : [EOL] writer = csv . DictWriter ( file , fieldnames = list ( data_dict . keys ( ) ) ) [EOL] writer . writeheader ( ) [EOL] writer . writerow ( data_dict ) [EOL] [EOL] return filepath [EOL] [EOL] [EOL] @ pytest . fixture def invalid_filepath ( tmpdir ) : [EOL] filepath = f'{ tmpdir } [string] ' [EOL] data = { [string] : [string] , [string] : [string] } [EOL] with open ( filepath , [string] ) as file : [EOL] writer = csv . DictWriter ( file , fieldnames = list ( data . keys ( ) ) ) [EOL] writer . writeheader ( ) [EOL] writer . writerow ( data ) [EOL] [EOL] return filepath [EOL] [EOL] [EOL] def test_load_filename ( energuide_zip_fixture , database_name , collection , mongo_client ) : [EOL] runner = testing . CliRunner ( ) [EOL] result = runner . invoke ( cli . main , args = [ [string] , [string] , database_name , [string] , energuide_zip_fixture , ] ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] coll = mongo_client . get_database ( database_name ) . get_collection ( collection ) [EOL] assert coll . count ( ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_load_azure ( database_name , collection , mongo_client ) : [EOL] runner = testing . CliRunner ( ) [EOL] result = runner . invoke ( cli . main , args = [ [string] , [string] , database_name , [string] , ] ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] coll = mongo_client . get_database ( database_name ) . get_collection ( collection ) [EOL] assert coll . count ( ) == [number] [EOL] [EOL] [EOL] def test_load_update ( energuide_zip_fixture , database_name , collection , mongo_client ) : [EOL] runner = testing . CliRunner ( ) [EOL] result = runner . invoke ( cli . main , args = [ [string] , [string] , database_name , [string] , energuide_zip_fixture , [string] , ] ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] result = runner . invoke ( cli . main , args = [ [string] , [string] , database_name , [string] , energuide_zip_fixture , [string] , ] ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] coll = mongo_client . get_database ( database_name ) . get_collection ( collection ) [EOL] assert coll . count ( ) == [number] [EOL] [EOL] [EOL] def test_extract_valid ( valid_filepath , tmpdir ) : [EOL] outfile = os . path . join ( tmpdir , [string] ) [EOL] runner = testing . CliRunner ( ) [EOL] result = runner . invoke ( cli . main , args = [ [string] , [string] , valid_filepath , [string] , outfile ] ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] with zipfile . ZipFile ( outfile , [string] ) as output : [EOL] assert len ( output . namelist ( ) ) == [number] [EOL] [EOL] [EOL] def test_extract_invalid ( invalid_filepath , tmpdir ) : [EOL] outfile = f'{ tmpdir } [string] ' [EOL] runner = testing . CliRunner ( ) [EOL] result = runner . invoke ( cli . main , args = [ [string] , [string] , invalid_filepath , [string] , outfile ] ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] with zipfile . ZipFile ( outfile , [string] ) as output : [EOL] assert not output . namelist ( ) [EOL] [EOL] [EOL] def test_extract_missing ( tmpdir ) : [EOL] outfile = os . path . join ( tmpdir , [string] ) [EOL] infile = os . path . join ( tmpdir , [string] ) [EOL] runner = testing . CliRunner ( ) [EOL] result = runner . invoke ( cli . main , args = [ [string] , [string] , infile , [string] , outfile ] ) [EOL] [EOL] assert result . exit_code != [number] [EOL] assert not os . path . exists ( outfile ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , IO , Set [EOL] import builtins [EOL] import _pytest [EOL] import zipfile [EOL] import energuide [EOL] import typing [EOL] import time [EOL] import typing [EOL] import zipfile [EOL] import _pytest [EOL] import pytest [EOL] from azure . storage import blob [EOL] from energuide import transform [EOL] [EOL] [EOL] @ pytest . fixture def local_reader ( energuide_zip_fixture ) : [EOL] return transform . LocalExtractReader ( energuide_zip_fixture ) [EOL] [EOL] [EOL] @ pytest . fixture def azure_reader ( populated_azure_emulator ) : [EOL] return transform . AzureExtractReader ( populated_azure_emulator ) [EOL] [EOL] [EOL] def test_reader ( local_reader ) : [EOL] output = list ( local_reader . extracted_rows ( ) ) [EOL] output = sorted ( output , key = lambda row : row [ [string] ] ) [EOL] unique_builders = { row [ [string] ] for row in output } [EOL] assert len ( output ) == [number] [EOL] assert output [ [number] ] [ [string] ] == [string] [EOL] assert len ( unique_builders ) == [number] [EOL] [EOL] [EOL] def test_reader_sorted_by_house_id ( local_reader ) : [EOL] output = list ( local_reader . extracted_rows ( ) ) [EOL] [EOL] assert all ( typing . cast ( str , current_row . get ( [string] ) ) <= typing . cast ( str , next_row . get ( [string] ) ) for current_row , next_row in zip ( output , output [ [number] : ] ) ) [EOL] [EOL] [EOL] def test_reader_num_rows ( local_reader ) : [EOL] assert local_reader . num_rows ( ) == [number] [EOL] [EOL] [EOL] def test_azure_reader_extracted_rows ( azure_reader ) : [EOL] output = list ( azure_reader . extracted_rows ( ) ) [EOL] output = sorted ( output , key = lambda row : row [ [string] ] ) [EOL] unique_builders = { row [ [string] ] for row in output } [EOL] assert len ( output ) == [number] [EOL] assert output [ [number] ] [ [string] ] == [string] [EOL] assert len ( unique_builders ) == [number] [EOL] [EOL] [EOL] def touch_one_file_in_azure ( azure_emulator , energuide_zip_fixture ) : [EOL] file_z = zipfile . ZipFile ( energuide_zip_fixture ) [EOL] service = blob . BlockBlobService ( account_name = azure_emulator . account , account_key = azure_emulator . key , custom_domain = azure_emulator . domain ) [EOL] json_file = [ file_z . open ( zipinfo ) for zipinfo in file_z . infolist ( ) ] [ [number] ] [EOL] service . create_blob_from_bytes ( azure_emulator . container , json_file . name , json_file . read ( ) ) [EOL] [EOL] [EOL] def test_azure_reader_extracted_rows_new_data ( azure_reader , azure_emulator , energuide_zip_fixture ) : [EOL] time . sleep ( [number] ) [comment] [EOL] output = list ( azure_reader . extracted_rows ( ) ) [EOL] assert len ( output ) == [number] [EOL] [EOL] azure_reader . _new_file_list = None [EOL] touch_one_file_in_azure ( azure_emulator , energuide_zip_fixture ) [EOL] output = list ( azure_reader . extracted_rows ( ) ) [EOL] assert len ( output ) == [number] [EOL] [EOL] [EOL] def test_azure_reader_num_rows ( azure_reader ) : [EOL] assert azure_reader . num_rows ( ) == [number] [EOL] [EOL] [EOL] def test_azure_reader_num_rows_new_data ( azure_reader ) : [EOL] time . sleep ( [number] ) [comment] [EOL] azure_reader . num_rows ( ) [EOL] azure_reader . _new_file_list = None [EOL] assert azure_reader . num_rows ( ) == [number] [EOL] [EOL] [EOL] def test_azure_coordinates_from_env ( monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] coords = transform . AzureCoordinates . from_env ( ) [EOL] assert coords == transform . AzureCoordinates ( account = [string] , key = [string] , domain = [string] , container = [string] ) [EOL] [EOL] [EOL] def test_transform ( local_reader ) : [EOL] output = transform . transform ( local_reader ) [EOL] assert len ( list ( output ) ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.transform.LocalExtractReader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.transform.AzureExtractReader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Iterator , Iterable [EOL] import builtins [EOL] import _pytest [EOL] import zipfile [EOL] import py [EOL] import azure [EOL] import socket [EOL] import pymongo [EOL] import energuide [EOL] import typing [EOL] import os [EOL] import random [EOL] import socket [EOL] import typing [EOL] import zipfile [EOL] import py [EOL] import _pytest . monkeypatch [EOL] import pymongo [EOL] import pytest [EOL] from azure . storage import blob [EOL] from energuide import database [EOL] from energuide import extractor [EOL] from energuide import transform [EOL] [EOL] [EOL] def azure_emulator_is_running ( ) : [EOL] if [string] in os . environ : [EOL] return True [EOL] [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] try : [EOL] sock . bind ( ( [string] , [number] ) ) [EOL] except socket . error : [EOL] return True [EOL] else : [EOL] sock . close ( ) [EOL] return False [EOL] [EOL] [EOL] @ pytest . fixture def username ( ) : [EOL] return os . environ . get ( database . EnvVariables . username . value , database . EnvDefaults . username . value ) [EOL] [EOL] [EOL] @ pytest . fixture def password ( ) : [EOL] return os . environ . get ( database . EnvVariables . password . value , database . EnvDefaults . password . value ) [EOL] [EOL] [EOL] @ pytest . fixture def host ( ) : [EOL] return os . environ . get ( database . EnvVariables . host . value , database . EnvDefaults . host . value ) [EOL] [EOL] [EOL] @ pytest . fixture def port ( ) : [EOL] return int ( os . environ . get ( database . EnvVariables . port . value , database . EnvDefaults . port . value ) ) [EOL] [EOL] [EOL] @ pytest . fixture def production ( ) : [EOL] return bool ( os . environ . get ( database . EnvVariables . production . value , database . EnvDefaults . production . value ) ) [EOL] [EOL] [EOL] @ pytest . fixture def database_name ( database_coordinates ) : [EOL] db_name = os . environ . get ( database . EnvVariables . database . value , database . EnvDefaults . database . value ) [EOL] db_name = f'{ db_name } [string] { random . randint ( [number] , [number] ) }' [EOL] [EOL] yield db_name [EOL] [EOL] client = ... [EOL] with database . mongo_client ( database_coordinates ) as client : [EOL] client . drop_database ( db_name ) [EOL] [EOL] [EOL] @ pytest . fixture def collection ( ) : [EOL] return os . environ . get ( database . EnvVariables . collection . value , database . EnvDefaults . collection . value ) [EOL] [EOL] [EOL] @ pytest . fixture def database_coordinates ( username , password , host , port , production ) : [EOL] return database . DatabaseCoordinates ( username = username , password = password , host = host , port = port , production = production , ) [EOL] [EOL] [EOL] @ pytest . fixture def mongo_client ( database_coordinates ) : [EOL] client = ... [EOL] with database . mongo_client ( database_coordinates ) as client : [EOL] yield client [EOL] [EOL] @ pytest . fixture def energuide_fixture ( ) : [EOL] return os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def energuide_zip_fixture ( tmpdir , energuide_fixture ) : [EOL] outfile = os . path . join ( tmpdir , [string] ) [EOL] [EOL] data = extractor . extract_data ( energuide_fixture ) [EOL] extractor . write_data ( data , outfile ) [EOL] return outfile [EOL] [EOL] [EOL] def _get_blob_service ( coords ) : [EOL] return blob . BlockBlobService ( account_name = coords . account , account_key = coords . key , custom_domain = coords . domain ) [EOL] [EOL] [EOL] @ pytest . fixture def azure_coordinates ( monkeypatch ) : [EOL] if not azure_emulator_is_running ( ) : [EOL] pytest . skip ( [string] ) [EOL] [EOL] account = [string] [EOL] key = [string] [EOL] domain = [string] [EOL] container_name = [string] [EOL] monkeypatch . setenv ( [string] , account ) [EOL] monkeypatch . setenv ( [string] , key ) [EOL] monkeypatch . setenv ( [string] , domain ) [EOL] monkeypatch . setenv ( [string] , container_name ) [EOL] return transform . AzureCoordinates ( key = key , account = account , container = container_name , domain = domain ) [EOL] [EOL] [EOL] @ pytest . fixture def azure_emulator ( azure_coordinates ) : [EOL] service = _get_blob_service ( azure_coordinates ) [EOL] service . create_container ( azure_coordinates . container ) [EOL] yield azure_coordinates [EOL] service . delete_container ( azure_coordinates . container ) [EOL] [EOL] [EOL] @ pytest . fixture def populated_azure_emulator ( azure_emulator , energuide_zip_fixture ) : [EOL] [EOL] file_z = zipfile . ZipFile ( energuide_zip_fixture ) [EOL] service = _get_blob_service ( azure_emulator ) [EOL] [EOL] service . create_blob_from_text ( azure_emulator . container , [string] , [string] ) [EOL] for json_file in [ file_z . open ( zipinfo ) for zipinfo in file_z . infolist ( ) ] : [EOL] service . create_blob_from_bytes ( azure_emulator . container , json_file . name , json_file . read ( ) ) [EOL] [EOL] return azure_emulator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.database.DatabaseCoordinates$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[pymongo.MongoClient]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $azure.storage.blob.BlockBlobService$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.transform.AzureCoordinates$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[energuide.transform.AzureCoordinates]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.transform.AzureCoordinates$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] from energuide . embedded import measurement [EOL] [EOL] [EOL] def test_measurement_to_dict ( ) : [EOL] assert measurement . Measurement ( measurement = [number] , upgrade = [number] ) . to_dict ( ) == { [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] def test_seriealize_properties ( ) : [EOL] [EOL] class Test ( ) : [EOL] [EOL] def __init__ ( self , a ) : [EOL] self . a = a [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . a } [EOL] [EOL] assert measurement . Measurement ( measurement = Test ( [number] ) , upgrade = Test ( [number] ) ) . to_dict ( ) == { [string] : { [string] : [number] } , [string] : { [string] : [number] } , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from energuide . embedded import walls [EOL] from energuide . embedded import composite [EOL] from energuide . exceptions import InvalidEmbeddedDataTypeError [EOL] [EOL] [EOL] def test_from_data ( ) : [EOL] insulation = [string] [EOL] heat_lost = [number] [EOL] [EOL] wall = walls . Wall . from_data ( insulation , heat_lost ) [EOL] assert wall == walls . Wall ( insulation = [ composite . CompositeValue ( percentage = [number] , value = [number] , value_name = [string] ) , composite . CompositeValue ( percentage = [number] , value = [number] , value_name = [string] ) , ] , heat_lost = [number] ) [EOL] [EOL] [EOL] def test_to_dict ( ) : [EOL] wall = walls . Wall ( insulation = [ composite . CompositeValue ( percentage = [number] , value = [number] , value_name = [string] ) , composite . CompositeValue ( percentage = [number] , value = [number] , value_name = [string] ) , ] , heat_lost = [number] ) [EOL] [EOL] assert wall . to_dict ( ) == { [string] : [ { [string] : [number] , [string] : [number] , } , { [string] : [number] , [string] : [number] , } ] , [string] : [number] } [EOL] [EOL] [EOL] def test_wall_missing_accepted ( ) : [EOL] wall = walls . Wall . from_data ( None , None ) [EOL] assert wall . to_dict ( ) == { [string] : [ ] , [string] : None , } [EOL] [EOL] [EOL] def test_bad_insulation_string ( ) : [EOL] insulation = [string] [EOL] heat_lost = [number] [EOL] [EOL] with pytest . raises ( InvalidEmbeddedDataTypeError ) as excinfo : [EOL] walls . Wall . from_data ( insulation , heat_lost ) [EOL] [EOL] assert excinfo . value . data_class == walls . Wall [EOL] [EOL] [EOL] def test_incomplete_insulation_string ( ) : [EOL] insulation = [string] [EOL] heat_lost = [number] [EOL] [EOL] wall = walls . Wall . from_data ( insulation , heat_lost ) [EOL] [EOL] wall . insulation [ [number] ] . value == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import builtins [EOL] import typing [EOL] import nrcan_etl [EOL] import energuide [EOL] import _pytest [EOL] import pytest [EOL] from energuide . embedded import evaluation_type [EOL] [EOL] [EOL] class TestEvaluationType : [EOL] [EOL] codes = [ ( [string] , evaluation_type . EvaluationType . PRE_RETROFIT ) , ( [string] , evaluation_type . EvaluationType . POST_RETROFIT ) , ( [string] , evaluation_type . EvaluationType . INCENTIVE_PROGRAM ) , ] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , codes ) def test_from_code ( self , code , eval_type ) : [EOL] output = evaluation_type . EvaluationType . from_code ( code ) [EOL] assert output == eval_type [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $energuide.embedded.evaluation_type.EvaluationType$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $energuide.embedded.evaluation_type.EvaluationType$ 0
from typing import Any , List [EOL] import typing [EOL] from energuide . embedded import region [EOL] [EOL] [EOL] class TestRegion : [EOL] [EOL] def test_from_name ( self ) : [EOL] data = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] output = [ region . Region . from_data ( row ) for row in data ] [EOL] [EOL] assert output == [ region . Region . ONTARIO , region . Region . BRITISH_COLUMBIA , region . Region . NOVA_SCOTIA , region . Region . ALBERTA , region . Region . SASKATCHEWAN , region . Region . MANITOBA , region . Region . QUEBEC , region . Region . NEW_BRUNSWICK , region . Region . PRINCE_EDWARD_ISLAND , region . Region . NEWFOUNDLAND_AND_LABRADOR , region . Region . YUKON , region . Region . NORTHWEST_TERRITORIES , region . Region . NUNAVUT , ] [EOL] [EOL] def test_alternative_name ( self ) : [EOL] data = [ [string] , [string] , ] [EOL] [EOL] output = [ region . Region . from_data ( row ) for row in data ] [EOL] [EOL] assert output == [ region . Region . YUKON , region . Region . NORTHWEST_TERRITORIES , ] [EOL] [EOL] def test_from_unknown_name ( self ) : [EOL] assert region . Region . from_data ( [string] ) == region . Region . UNKNOWN [EOL] [EOL] [EOL] def test_fuzzy_names ( self ) : [EOL] data = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] output = [ region . Region . from_data ( row ) for row in data ] [EOL] [EOL] assert output == [ region . Region . QUEBEC , region . Region . ONTARIO , region . Region . ONTARIO , region . Region . QUEBEC , region . Region . YUKON , region . Region . QUEBEC , region . Region . MANITOBA , region . Region . ALBERTA ] [EOL] [EOL] def test_french_name ( self ) : [EOL] data = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] output = [ region . Region . from_data ( row ) for row in data ] [EOL] [EOL] assert output == [ region . Region . BRITISH_COLUMBIA , region . Region . NEWFOUNDLAND_AND_LABRADOR , region . Region . NEW_BRUNSWICK , region . Region . NOVA_SCOTIA , region . Region . NORTHWEST_TERRITORIES , region . Region . PRINCE_EDWARD_ISLAND , ] [EOL] [EOL] def test_from_code ( self ) : [EOL] data = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] output = [ region . Region . from_data ( row ) for row in data ] [EOL] assert output == [ region . Region . BRITISH_COLUMBIA , region . Region . ALBERTA , region . Region . SASKATCHEWAN , region . Region . MANITOBA , region . Region . ONTARIO , region . Region . QUEBEC , region . Region . NEW_BRUNSWICK , region . Region . PRINCE_EDWARD_ISLAND , region . Region . NOVA_SCOTIA , region . Region . NEWFOUNDLAND_AND_LABRADOR , region . Region . YUKON , region . Region . NORTHWEST_TERRITORIES , region . Region . NUNAVUT , ] [EOL] [EOL] def test_alternative_code ( self ) : [EOL] data = [ [string] , [string] , ] [EOL] output = [ region . Region . from_data ( row ) for row in data ] [EOL] assert output == [ region . Region . PRINCE_EDWARD_ISLAND , region . Region . NORTHWEST_TERRITORIES , ] [EOL] [EOL] def test_from_unknown_code ( self ) : [EOL] assert region . Region . from_data ( [string] ) == region . Region . UNKNOWN [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import energuide [EOL] import pytest [EOL] from energuide import element [EOL] from energuide . embedded import upgrade [EOL] [EOL] [EOL] @ pytest . fixture def sample_raw ( ) : [EOL] doc = [string] [EOL] return element . Element . from_string ( doc ) [EOL] [EOL] [EOL] @ pytest . fixture def sample ( ) : [EOL] return upgrade . Upgrade ( upgrade_type = [string] , cost = [number] , priority = [number] , ) [EOL] [EOL] [EOL] def test_from_data ( sample_raw , sample ) : [EOL] output = upgrade . Upgrade . from_data ( sample_raw ) [EOL] assert output == sample [EOL] [EOL] [EOL] def test_to_dict ( sample ) : [EOL] output = sample . to_dict ( ) [EOL] assert output == { [string] : [string] , [string] : [number] , [string] : [number] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.element.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $energuide.embedded.upgrade.Upgrade$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] import pytest [EOL] from energuide . embedded import house_type [EOL] [EOL] [EOL] def house_types ( ) : [EOL] return [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , house_types ( ) ) def test_normalize ( dirty , clean ) : [EOL] [EOL] assert house_type . HouseType . normalize ( dirty ) == clean [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , IO [EOL] import requests [EOL] import builtins [EOL] import typing [EOL] import hashlib [EOL] import os [EOL] import hashlib [EOL] import secrets [EOL] import typing [EOL] from http import HTTPStatus [EOL] import requests [EOL] import click [EOL] [EOL] [EOL] DEFAULT_ETL_SECRET_KEY = [string] [EOL] [EOL] DEFAULT_ENERGUIDE_ENDPOINT_ADDRESS = [string] [EOL] [EOL] [EOL] def _etl_secret_key ( ) : [EOL] return os . environ . get ( [string] , DEFAULT_ETL_SECRET_KEY ) [EOL] [EOL] [EOL] def _endpoint_address ( ) : [EOL] return os . environ . get ( [string] , DEFAULT_ENERGUIDE_ENDPOINT_ADDRESS ) [EOL] [EOL] [EOL] def post_stream ( stream , timestamp , url ) : [EOL] [EOL] data = stream . read ( ) [EOL] salt = secrets . token_hex ( [number] ) [EOL] [EOL] hasher = hashlib . new ( [string] ) [EOL] hasher . update ( ( salt + _etl_secret_key ( ) ) . encode ( ) ) [EOL] hasher . update ( data ) [EOL] signature = hasher . hexdigest ( ) [EOL] [EOL] try : [EOL] post_return = requests . post ( url = url , files = { [string] : data } , data = { [string] : salt , [string] : signature , [string] : timestamp } ) [EOL] return post_return . status_code [EOL] except requests . exceptions . ConnectionError : [EOL] return HTTPStatus . BAD_GATEWAY [EOL] [EOL] [EOL] def trigger_tl ( url ) : [EOL] salt = secrets . token_hex ( [number] ) [EOL] hasher = hashlib . new ( [string] ) [EOL] hasher . update ( ( salt + _etl_secret_key ( ) ) . encode ( ) ) [EOL] signature = hasher . hexdigest ( ) [EOL] data = dict ( salt = salt , signature = signature ) [EOL] try : [EOL] return requests . post ( url , data = data ) . status_code [EOL] except requests . exceptions . ConnectionError : [EOL] return HTTPStatus . BAD_GATEWAY [EOL] [EOL] [EOL] @ click . group ( ) def main ( ) : [EOL] pass [EOL] [EOL] [EOL] @ main . command ( ) @ click . argument ( [string] , type = click . File ( [string] ) ) @ click . argument ( [string] ) @ click . option ( [string] , default = _endpoint_address ( ) + [string] ) def upload ( stream , timestamp , url ) : [EOL] return_code = post_stream ( stream = stream , timestamp = timestamp , url = url ) [EOL] click . echo ( f" [string] { return_code }" ) [EOL] if return_code != HTTPStatus . OK : [EOL] exit ( return_code ) [EOL] [EOL] [EOL] @ main . command ( ) @ click . option ( [string] , default = _endpoint_address ( ) + [string] ) def run_tl ( url ) : [EOL] return_code = trigger_tl ( url ) [EOL] click . echo ( f" [string] { return_code }" ) [EOL] if return_code != HTTPStatus . OK : [EOL] exit ( return_code ) [EOL] [EOL] [EOL] @ main . command ( ) @ click . option ( [string] , default = _endpoint_address ( ) + [string] ) def status ( url ) : [EOL] try : [EOL] system_status = requests . get ( url ) . content . decode ( ) [EOL] except requests . exceptions . RequestException : [EOL] system_status = [string] [EOL] click . echo ( f" [string] { system_status }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import enum [EOL] import typing [EOL] from azure . storage import blob [EOL] [EOL] [EOL] class StorageCoordinates ( typing . NamedTuple ) : [EOL] account = ... [EOL] key = ... [EOL] container = ... [EOL] domain = ... [EOL] [EOL] [EOL] class EnvVariables ( enum . Enum ) : [EOL] account = [string] [EOL] key = [string] [EOL] container = [string] [EOL] domain = [string] [EOL] [EOL] [EOL] def upload_bytes_to_azure ( coords , data , filename ) : [EOL] azure_service = blob . BlockBlobService ( account_name = coords . account , account_key = coords . key , custom_domain = coords . domain ) [EOL] azure_service . create_blob_from_bytes ( coords . container , filename , data ) [EOL] return filename in [ blob . name for blob in azure_service . list_blobs ( coords . container ) ] [EOL] [EOL] [EOL] def download_bytes_from_azure ( coords , filename ) : [EOL] azure_service = blob . BlockBlobService ( account_name = coords . account , account_key = coords . key , custom_domain = coords . domain ) [EOL] return azure_service . get_blob_to_bytes ( coords . container , filename ) . content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Generator [EOL] import builtins [EOL] import azure [EOL] import typing [EOL] import extract_endpoint [EOL] import typing [EOL] import pytest [EOL] from azure . storage import blob [EOL] from azure . common import AzureMissingResourceHttpError [EOL] from extract_endpoint import azure_utils [EOL] [EOL] [EOL] @ pytest . fixture def sample_stream_content ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def sample_data ( sample_stream_content ) : [EOL] return sample_stream_content . encode ( ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_filename ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def put_file_in_azure ( azure_emulator_coords , azure_service , sample_stream_content ) : [EOL] [EOL] filename = [string] [EOL] azure_service . create_blob_from_text ( azure_emulator_coords . container , filename , sample_stream_content ) [EOL] yield filename [EOL] azure_service . delete_blob ( azure_emulator_coords . container , filename ) [EOL] [EOL] [EOL] def check_file_in_azure ( azure_service , azure_emulator_coords , filename , contents ) : [EOL] [EOL] assert filename in [ blob . name for blob in azure_service . list_blobs ( azure_emulator_coords . container ) ] [EOL] actual_blob = azure_service . get_blob_to_text ( azure_emulator_coords . container , filename ) [EOL] assert actual_blob . content == contents [EOL] [EOL] [EOL] def test_upload_bytes ( azure_emulator_coords , azure_service , sample_data , sample_stream_content , sample_filename ) : [EOL] [EOL] assert azure_utils . upload_bytes_to_azure ( azure_emulator_coords , sample_data , sample_filename ) [EOL] check_file_in_azure ( azure_service , azure_emulator_coords , sample_filename , sample_stream_content ) [EOL] [EOL] [EOL] def test_download_bytes ( azure_emulator_coords , put_file_in_azure , sample_stream_content ) : [EOL] [EOL] actual_contents = azure_utils . download_bytes_from_azure ( azure_emulator_coords , put_file_in_azure ) [EOL] assert actual_contents == sample_stream_content . encode ( ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_download_bytes_bad_filename ( azure_emulator_coords ) : [EOL] with pytest . raises ( AzureMissingResourceHttpError ) : [EOL] azure_utils . download_bytes_from_azure ( azure_emulator_coords , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import builtins [EOL] import _pytest [EOL] import zipfile [EOL] import py [EOL] import azure [EOL] import io [EOL] import typing [EOL] import extract_endpoint [EOL] import io [EOL] import datetime [EOL] import zipfile [EOL] import typing [EOL] import pytest [EOL] import _pytest [EOL] import py [EOL] from azure . storage import blob [EOL] from extract_endpoint import azure_utils [EOL] from extract_endpoint import endpoint [EOL] [EOL] [EOL] @ pytest . fixture ( ) def azure_emulator_coords ( ) : [EOL] return azure_utils . StorageCoordinates ( account = [string] , key = [string] , container = [string] , domain = [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture def azure_service ( azure_emulator_coords ) : [EOL] azure_service = blob . BlockBlobService ( account_name = azure_emulator_coords . account , account_key = azure_emulator_coords . key , custom_domain = azure_emulator_coords . domain ) [EOL] azure_service . create_container ( azure_emulator_coords . container ) [EOL] yield azure_service [EOL] azure_service . delete_container ( azure_emulator_coords . container ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_timestamp ( ) : [EOL] return datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) . strftime ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_filenames ( ) : [EOL] return ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_file_contents ( ) : [EOL] return ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_zipfile ( sample_filenames , sample_file_contents ) : [EOL] [EOL] file = io . BytesIO ( ) [EOL] file_z = zipfile . ZipFile ( file , [string] ) [EOL] for name , contents in zip ( sample_filenames , sample_file_contents ) : [EOL] file_z . writestr ( name , contents ) [EOL] file_z . close ( ) [EOL] file . seek ( [number] ) [EOL] return file [EOL] [EOL] [EOL] @ pytest . fixture def sample_secret_key ( monkeypatch ) : [EOL] monkeypatch . setitem ( endpoint . App . config , [string] , [string] ) [EOL] return endpoint . App . config [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture def sample_zipfile_fixture ( tmpdir , sample_filenames , sample_file_contents ) : [EOL] file = f'{ tmpdir } [string] ' [EOL] file_z = zipfile . ZipFile ( file , [string] ) [EOL] for name , contents in zip ( sample_filenames , sample_file_contents ) : [EOL] file_z . writestr ( name , contents ) [EOL] file_z . close ( ) [EOL] return file [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $extract_endpoint.azure_utils.StorageCoordinates$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $azure.storage.blob.BlockBlobService$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Tuple , Dict , Generator [EOL] import builtins [EOL] import _pytest [EOL] import azure [EOL] import io [EOL] import hashlib [EOL] import flask [EOL] import typing [EOL] import extract_endpoint [EOL] import io [EOL] import hashlib [EOL] from http import HTTPStatus [EOL] import typing [EOL] import pytest [EOL] import _pytest [EOL] from flask import testing [EOL] from azure . storage import blob [EOL] from extract_endpoint import azure_utils [EOL] from extract_endpoint import endpoint [EOL] [EOL] [EOL] endpoint . App . testing = True [EOL] [EOL] [EOL] @ pytest . fixture def test_client ( monkeypatch , azure_emulator_coords ) : [EOL] [EOL] monkeypatch . setitem ( endpoint . App . config , [string] , azure_emulator_coords ) [EOL] return endpoint . App . test_client ( ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_salt ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def sample_salt_signature ( sample_salt , sample_secret_key ) : [EOL] hasher = hashlib . new ( [string] ) [EOL] hasher . update ( ( sample_salt + sample_secret_key ) . encode ( ) ) [EOL] return hasher . hexdigest ( ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_zipfile_signature ( sample_salt , sample_secret_key , sample_zipfile ) : [EOL] hasher = hashlib . new ( [string] ) [EOL] hasher . update ( ( sample_salt + sample_secret_key ) . encode ( ) ) [EOL] hasher . update ( sample_zipfile . read ( ) ) [EOL] sample_zipfile . seek ( [number] ) [EOL] signature = hasher . hexdigest ( ) [EOL] return signature [EOL] [EOL] [EOL] @ pytest . fixture def sample_nonzipfile ( ) : [EOL] return io . BytesIO ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_nonzipfile_signature ( sample_salt , sample_secret_key , sample_nonzipfile ) : [EOL] hasher = hashlib . new ( [string] ) [EOL] hasher . update ( ( sample_salt + sample_secret_key ) . encode ( ) ) [EOL] hasher . update ( sample_nonzipfile . read ( ) ) [EOL] sample_nonzipfile . seek ( [number] ) [EOL] signature = hasher . hexdigest ( ) [EOL] return signature [EOL] [EOL] [EOL] @ pytest . fixture def upload_timestamp_file ( azure_emulator_coords , azure_service , sample_timestamp ) : [EOL] [EOL] azure_service . create_blob_from_text ( azure_emulator_coords . container , endpoint . TIMESTAMP_FILENAME , sample_timestamp ) [EOL] yield [EOL] azure_service . delete_blob ( azure_emulator_coords . container , endpoint . TIMESTAMP_FILENAME ) [EOL] [EOL] [EOL] @ pytest . fixture def mocked_tl_app ( monkeypatch , sample_secret_key ) : [EOL] def mock_send_to_tl ( data ) : [EOL] if [string] not in data : [EOL] return HTTPStatus . BAD_REQUEST [EOL] if [string] not in data : [EOL] return HTTPStatus . BAD_REQUEST [EOL] hasher = hashlib . new ( [string] ) [EOL] hasher . update ( ( data [ [string] ] + sample_secret_key ) . encode ( ) ) [EOL] actual_signature = hasher . hexdigest ( ) [EOL] if data [ [string] ] != actual_signature : [EOL] return HTTPStatus . BAD_REQUEST [EOL] return HTTPStatus . OK [EOL] monkeypatch . setattr ( endpoint , [string] , mock_send_to_tl ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def thread_runner ( ) : [EOL] yield endpoint . ThreadRunner [EOL] endpoint . ThreadRunner . join ( ) [EOL] [EOL] [EOL] @ pytest . fixture def busy_thread_runner ( thread_runner ) : [EOL] stay_asleep = True [EOL] [EOL] def sleeper ( ) : [EOL] while stay_asleep : [EOL] pass [EOL] [EOL] thread_runner . start_new_thread ( sleeper ) [EOL] yield thread_runner [EOL] stay_asleep = False [EOL] [EOL] [EOL] def test_threadrunner ( thread_runner ) : [EOL] stay_asleep = True [EOL] [EOL] def sleeper ( ) : [EOL] while stay_asleep : [EOL] pass [EOL] [EOL] thread_runner . start_new_thread ( sleeper ) [EOL] assert thread_runner . is_thread_running ( ) [EOL] stay_asleep = False [EOL] thread_runner . join ( ) [EOL] assert not thread_runner . is_thread_running ( ) [EOL] [EOL] [EOL] def check_file_in_azure ( azure_service , azure_emulator_coords , filename , contents ) : [EOL] [EOL] assert filename in [ blob . name for blob in azure_service . list_blobs ( azure_emulator_coords . container ) ] [EOL] actual_blob = azure_service . get_blob_to_text ( azure_emulator_coords . container , filename ) [EOL] assert actual_blob . content == contents [EOL] [EOL] [EOL] def test_run_tl_url ( monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] assert endpoint . _run_tl_url ( ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_run_tl ( sample_salt , sample_salt_signature ) : [EOL] return_val = endpoint . run_tl ( dict ( salt = sample_salt , signature = sample_salt_signature ) ) [EOL] assert return_val == HTTPStatus . OK [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_run_tl_no_data ( ) : [EOL] return_val = endpoint . run_tl ( ) [EOL] assert return_val == HTTPStatus . OK [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_run_tl_bad_data ( ) : [EOL] return_val = endpoint . run_tl ( dict ( salt = [string] , signature = [string] ) ) [EOL] assert return_val == HTTPStatus . BAD_REQUEST [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_run_tl_route ( test_client , sample_salt , sample_salt_signature ) : [EOL] return_val = test_client . post ( [string] , data = dict ( salt = sample_salt , signature = sample_salt_signature ) ) [EOL] assert return_val . status_code == HTTPStatus . OK [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] , [string] ) def test_run_tl_route_no_data ( test_client ) : [EOL] return_val = test_client . post ( [string] ) [EOL] assert return_val . status_code == HTTPStatus . BAD_REQUEST [EOL] [EOL] [EOL] def test_frontend ( test_client ) : [EOL] assert test_client . get ( [string] ) . status_code == HTTPStatus . OK [EOL] [EOL] [EOL] def test_alive ( test_client ) : [EOL] get_return = test_client . get ( [string] ) [EOL] assert [string] in get_return . data [EOL] [EOL] [EOL] def test_robots ( test_client ) : [EOL] get_return = test_client . get ( [string] ) [EOL] assert get_return . status_code == HTTPStatus . NOT_FOUND [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_timestamp ( test_client , sample_timestamp ) : [EOL] get_return = test_client . get ( [string] ) [EOL] assert get_return . data == sample_timestamp . encode ( ) [EOL] [EOL] [EOL] def test_timestamp_no_file ( test_client ) : [EOL] get_return = test_client . get ( [string] ) [EOL] assert get_return . status_code == HTTPStatus . BAD_GATEWAY [EOL] [EOL] [EOL] def test_upload_with_timestamp ( azure_service , azure_emulator_coords , sample_filenames , sample_file_contents , test_client , thread_runner , sample_timestamp , sample_salt , sample_zipfile_signature , sample_zipfile ) : [EOL] [EOL] post_return = test_client . post ( [string] , data = dict ( salt = sample_salt , signature = sample_zipfile_signature , timestamp = sample_timestamp , file = ( sample_zipfile , [string] ) ) ) [EOL] assert post_return . status_code == HTTPStatus . OK [EOL] thread_runner . join ( ) [EOL] check_file_in_azure ( azure_service , azure_emulator_coords , endpoint . TIMESTAMP_FILENAME , sample_timestamp ) [EOL] for name , contents in zip ( sample_filenames , sample_file_contents ) : [EOL] check_file_in_azure ( azure_service , azure_emulator_coords , name , contents ) [EOL] [EOL] [EOL] def test_upload_without_timestamp ( test_client , sample_salt , sample_zipfile_signature , sample_zipfile ) : [EOL] [EOL] post_return = test_client . post ( [string] , data = dict ( salt = sample_salt , signature = sample_zipfile_signature , file = ( sample_zipfile , [string] ) ) ) [EOL] assert post_return . status_code == HTTPStatus . BAD_REQUEST [EOL] [EOL] [EOL] def test_upload_no_key_in_env ( test_client , sample_timestamp , sample_salt , sample_zipfile_signature , sample_zipfile ) : [EOL] [EOL] endpoint . App . config [ [string] ] = endpoint . DEFAULT_ETL_SECRET_KEY [EOL] with pytest . raises ( ValueError ) : [EOL] test_client . post ( [string] , data = dict ( salt = sample_salt , signature = sample_zipfile_signature , timestamp = sample_timestamp , file = ( sample_zipfile , [string] ) ) ) [EOL] [EOL] [EOL] def test_upload_no_salt ( test_client , sample_timestamp , sample_zipfile_signature , sample_zipfile ) : [EOL] [EOL] post_return = test_client . post ( [string] , data = dict ( signature = sample_zipfile_signature , timestamp = sample_timestamp , file = ( sample_zipfile , [string] ) ) ) [EOL] assert post_return . status_code == HTTPStatus . BAD_REQUEST [EOL] [EOL] [EOL] def test_upload_wrong_salt ( test_client , sample_timestamp , sample_zipfile_signature , sample_zipfile ) : [EOL] [EOL] post_return = test_client . post ( [string] , data = dict ( salt = [string] , signature = sample_zipfile_signature , timestamp = sample_timestamp , file = ( sample_zipfile , [string] ) ) ) [EOL] assert post_return . status_code == HTTPStatus . BAD_REQUEST [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_upload_no_signature ( test_client , sample_timestamp , sample_salt , sample_zipfile ) : [EOL] [EOL] post_return = test_client . post ( [string] , data = dict ( salt = sample_salt , timestamp = sample_timestamp , file = ( sample_zipfile , [string] ) ) ) [EOL] assert post_return . status_code == HTTPStatus . BAD_REQUEST [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_upload_wrong_signature ( test_client , sample_timestamp , sample_salt , sample_zipfile ) : [EOL] [EOL] post_return = test_client . post ( [string] , data = dict ( salt = sample_salt , signature = [string] , timestamp = sample_timestamp , file = ( sample_zipfile , [string] ) ) ) [EOL] assert post_return . status_code == HTTPStatus . BAD_REQUEST [EOL] [EOL] [EOL] def test_upload_no_file ( test_client , sample_timestamp , sample_salt , sample_zipfile_signature ) : [EOL] [EOL] post_return = test_client . post ( [string] , data = dict ( salt = sample_salt , signature = sample_zipfile_signature , timestamp = sample_timestamp ) ) [EOL] assert post_return . status_code == HTTPStatus . BAD_REQUEST [EOL] [EOL] [EOL] def test_upload_with_non_zipfile ( test_client , sample_timestamp , sample_salt , sample_nonzipfile_signature , sample_nonzipfile ) : [EOL] [EOL] post_return = test_client . post ( [string] , data = dict ( salt = sample_salt , signature = sample_nonzipfile_signature , timestamp = sample_timestamp , file = ( sample_nonzipfile , [string] ) ) ) [EOL] assert post_return . status_code == HTTPStatus . BAD_REQUEST [EOL] assert [string] in post_return . data [EOL] [EOL] [EOL] def test_status_idle ( test_client ) : [EOL] status = test_client . get ( [string] ) [EOL] assert status . status_code == HTTPStatus . OK [EOL] assert [string] in status . data [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_status_busy ( test_client ) : [EOL] status = test_client . get ( [string] ) [EOL] assert status . status_code == HTTPStatus . OK [EOL] assert [string] in status . data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.testing.FlaskClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0