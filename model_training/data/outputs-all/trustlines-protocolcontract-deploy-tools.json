from setuptools import setup [EOL] [EOL] setup ( use_scm_version = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import builtins [EOL] import json [EOL] import os [EOL] from typing import Any , Dict , List [EOL] [EOL] from eth_utils import add_0x_prefix [EOL] from solc import compile_standard [EOL] from web3 import Web3 [EOL] from web3 . _utils . abi import get_constructor_abi [EOL] from web3 . _utils . contracts import encode_abi [EOL] [EOL] from . files import find_files [EOL] [EOL] DEFAULT_OUTPUT_SELECTION = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] ABI_OUTPUT_SELECTION = [ [string] , [string] ] [EOL] [EOL] DEFAULT_EVM_VERSION = [string] [EOL] [EOL] [EOL] def load_sources ( file_paths ) : [EOL] result = { } [EOL] for file_path in file_paths : [EOL] with open ( file_path ) as source_file : [EOL] result [ file_path ] = { [string] : source_file . read ( ) } [EOL] return result [EOL] [EOL] [EOL] def normalize_contract_data ( contract_data ) : [EOL] result = { } [EOL] [EOL] for key , value in contract_data . items ( ) : [EOL] if key == [string] : [EOL] evm_data = value [EOL] [EOL] if [string] in evm_data : [EOL] result [ [string] ] = add_0x_prefix ( evm_data [ [string] ] . get ( [string] , [string] ) ) [EOL] [EOL] if [string] in evm_data : [EOL] result [ [string] ] = add_0x_prefix ( evm_data [ [string] ] . get ( [string] , [string] ) ) [EOL] [EOL] elif key == [string] : [EOL] if value : [EOL] result [ key ] = json . loads ( value ) [EOL] [EOL] else : [EOL] result [ key ] = value [EOL] [EOL] return result [EOL] [EOL] [EOL] def normalize_compiled_contracts ( compiled_contracts , file_paths ) : [EOL] result = { } [EOL] [EOL] for source_path , file_contracts in compiled_contracts . items ( ) : [EOL] if source_path not in file_paths : [EOL] continue [EOL] [EOL] for contract_name , raw_contract_data in file_contracts . items ( ) : [EOL] contract_data = normalize_contract_data ( raw_contract_data ) [EOL] if contract_name not in result : [EOL] result [ contract_name ] = contract_data [EOL] else : [EOL] raise BaseException ( [string] ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def log_compilation_errors ( errors ) : [EOL] for error in errors : [EOL] if [string] in error : [EOL] print ( error [ [string] ] ) [EOL] else : [EOL] print ( error [ [string] ] ) [EOL] [EOL] [EOL] def compile_project ( contracts_path = None , * , file_paths = None , allow_paths = None , pattern = [string] , optimize = True , optimize_runs = [number] , only_abi = False , evm_version = DEFAULT_EVM_VERSION , ) : [EOL] [docstring] [EOL] [EOL] if file_paths is None : [EOL] file_paths = [ ] [EOL] [EOL] if allow_paths is None : [EOL] allow_paths = [ ] [EOL] [EOL] if contracts_path is None and not file_paths : [EOL] contracts_path = [string] [EOL] [EOL] if contracts_path is not None : [EOL] file_paths . extend ( find_files ( contracts_path , pattern = pattern ) ) [EOL] allow_paths . append ( contracts_path ) [EOL] [EOL] sources = load_sources ( file_paths ) [EOL] [EOL] if only_abi : [EOL] output_selection = ABI_OUTPUT_SELECTION [EOL] else : [EOL] output_selection = DEFAULT_OUTPUT_SELECTION [EOL] [EOL] std_input = { [string] : [string] , [string] : sources , [string] : { [string] : { [string] : { [string] : output_selection } } , [string] : evm_version , } , } [EOL] [EOL] if optimize : [EOL] std_input [ [string] ] [ [string] ] = { [string] : True , [string] : optimize_runs } [EOL] [EOL] compilation_result = compile_standard ( std_input , allow_paths = [string] . join ( os . path . abspath ( path ) for path in allow_paths ) ) [EOL] [EOL] if [string] in compilation_result : [EOL] log_compilation_errors ( compilation_result [ [string] ] ) [EOL] [EOL] compiled_contracts = normalize_compiled_contracts ( compilation_result [ [string] ] , file_paths ) [EOL] return compiled_contracts [EOL] [EOL] [EOL] def compile_contract ( name , * , contracts_path = [string] , file_extension = [string] , optimize = True ) : [EOL] filename = name + file_extension [EOL] file_paths = list ( find_files ( contracts_path , filename ) ) [EOL] [EOL] if len ( file_paths ) < [number] : [EOL] raise ValueError ( [string] . format ( filename ) ) [EOL] [EOL] if len ( file_paths ) > [number] : [EOL] raise ValueError ( [string] . format ( file_paths ) ) [EOL] [EOL] compiled_contracts = compile_project ( file_paths = file_paths , allow_paths = [ contracts_path ] , optimize = optimize ) [EOL] return compiled_contracts [ name ] [EOL] [EOL] [EOL] def build_initcode ( * , contract_bytecode , contract_abi = [ ] , constructor_args = [ ] ) : [EOL] constructor_abi = get_constructor_abi ( contract_abi ) [EOL] [EOL] [comment] [EOL] if constructor_abi : [EOL] return encode_abi ( web3 = Web3 ( ) , abi = constructor_abi , arguments = constructor_args , data = contract_bytecode , ) [EOL] else : [EOL] return contract_bytecode [EOL] [EOL] [EOL] class UnknownContractException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def filter_contracts ( contract_names , contract_assets_in ) : [EOL] if contract_names is None : [EOL] return contract_assets_in . copy ( ) [EOL] [EOL] output_dict = { } [EOL] try : [EOL] for contract_name in contract_names : [EOL] output_dict [ contract_name ] = contract_assets_in [ contract_name ] [EOL] except KeyError as e : [EOL] raise UnknownContractException ( * e . args ) from e [EOL] [EOL] return output_dict [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import io [EOL] import subprocess [EOL] import typing [EOL] import builtins [EOL] import web3 [EOL] [docstring] [EOL] import io [EOL] import os [EOL] import shutil [EOL] import subprocess [EOL] from pathlib import Path [EOL] [EOL] import eth_tester [EOL] import pytest [EOL] from web3 import Web3 [EOL] from web3 . contract import Contract [EOL] from web3 . providers . eth_tester import EthereumTesterProvider [EOL] [EOL] from deploy_tools import compile_project , deploy_compiled_contract [EOL] from deploy_tools . compile import DEFAULT_EVM_VERSION [EOL] [EOL] CONTRACTS_FOLDER_OPTION = [string] [EOL] CONTRACTS_FOLDER_OPTION_HELP = [string] [EOL] EVM_VERSION_OPTION = [string] [EOL] EVM_VERSION_OPTION_HELP = ( [string] [string] ) [EOL] [EOL] [EOL] def pytest_addoption ( parser ) : [EOL] parser . addoption ( CONTRACTS_FOLDER_OPTION , help = CONTRACTS_FOLDER_OPTION_HELP ) [EOL] parser . addini ( CONTRACTS_FOLDER_OPTION , CONTRACTS_FOLDER_OPTION_HELP ) [EOL] parser . addoption ( EVM_VERSION_OPTION , help = EVM_VERSION_OPTION_HELP , default = DEFAULT_EVM_VERSION ) [EOL] parser . addini ( EVM_VERSION_OPTION , EVM_VERSION_OPTION_HELP , default = DEFAULT_EVM_VERSION ) [EOL] [EOL] [EOL] def get_contracts_folder ( pytestconfig ) : [EOL] if pytestconfig . getoption ( CONTRACTS_FOLDER_OPTION , default = None ) : [EOL] return pytestconfig . getoption ( CONTRACTS_FOLDER_OPTION ) [EOL] return Path ( pytestconfig . rootdir ) / [string] [EOL] [EOL] [EOL] def get_evm_version ( pytestconfig ) : [EOL] return pytestconfig . getoption ( EVM_VERSION_OPTION ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def remove_click_options_environment_variables ( ) : [EOL] [docstring] [EOL] for env_var in list ( os . environ . keys ( ) ) : [EOL] if env_var . startswith ( ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) ) : [EOL] del os . environ [ env_var ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def contract_assets ( pytestconfig ) : [EOL] [docstring] [EOL] contracts_path = get_contracts_folder ( pytestconfig ) [EOL] evm_version = get_evm_version ( pytestconfig ) [EOL] return compile_project ( contracts_path = contracts_path , optimize = True , evm_version = evm_version ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def deploy_contract ( web3 , contract_assets ) : [EOL] [docstring] [EOL] [EOL] def deploy_contract_function ( contract_identifier , * , constructor_args = ( ) ) : [EOL] return deploy_compiled_contract ( abi = contract_assets [ contract_identifier ] [ [string] ] , bytecode = contract_assets [ contract_identifier ] [ [string] ] , web3 = web3 , constructor_args = constructor_args , ) [EOL] [EOL] return deploy_contract_function [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def chain ( ) : [EOL] [docstring] [EOL] return eth_tester . EthereumTester ( eth_tester . PyEVMBackend ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def web3 ( chain ) : [EOL] [docstring] [EOL] return Web3 ( EthereumTesterProvider ( chain ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def set_default_account ( web3 ) : [EOL] [docstring] [EOL] web3 . eth . defaultAccount = web3 . eth . accounts [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def default_account ( web3 ) : [EOL] [docstring] [EOL] return web3 . eth . defaultAccount [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def accounts ( web3 ) : [EOL] [docstring] [EOL] return web3 . eth . accounts [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def account_keys ( chain ) : [EOL] [docstring] [EOL] return chain . backend . account_keys [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def chain_cleanup ( chain ) : [EOL] [docstring] [EOL] snapshot = chain . take_snapshot ( ) [EOL] yield [EOL] chain . revert_to_snapshot ( snapshot ) [EOL] [EOL] [EOL] def _find_solc ( msgs ) : [EOL] solc = shutil . which ( [string] ) [EOL] if solc : [EOL] msgs . write ( [string] . format ( solc ) ) [EOL] else : [EOL] msgs . write ( [string] ) [EOL] return solc [EOL] [EOL] [EOL] def _get_solc_version ( msgs ) : [EOL] try : [EOL] process = subprocess . Popen ( [ [string] , [string] ] , stdout = subprocess . PIPE ) [EOL] except Exception as err : [EOL] msgs . write ( [string] . format ( err ) ) [EOL] return [EOL] [EOL] out , _ = process . communicate ( ) [EOL] [EOL] lines = out . decode ( [string] ) . splitlines ( ) [EOL] for line in lines : [EOL] if line . startswith ( [string] ) : [EOL] msgs . write ( [string] . format ( line [ len ( [string] ) : ] ) ) [EOL] break [EOL] else : [EOL] msgs . write ( [string] ) [EOL] [EOL] [EOL] def pytest_report_header ( config ) : [EOL] msgs = io . StringIO ( ) [EOL] solc = _find_solc ( msgs ) [EOL] [EOL] if solc : [EOL] _get_solc_version ( msgs ) [EOL] [EOL] return msgs . getvalue ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import hexbytes [EOL] import typing [EOL] import web3 [EOL] import builtins [EOL] import json [EOL] from typing import Dict [EOL] [EOL] import pkg_resources [EOL] from eth_keyfile import extract_key_from_keyfile [EOL] from hexbytes import HexBytes [EOL] from web3 import Web3 [EOL] from web3 . _utils . transactions import fill_nonce , fill_transaction_defaults [EOL] from web3 . contract import Contract [EOL] from web3 . eth import Account [EOL] from web3 . types import TxParams , TxReceipt [EOL] [EOL] [EOL] def deploy_compiled_contract ( * , abi , bytecode , web3 , constructor_args = ( ) , transaction_options = None , private_key = None , ) : [EOL] [docstring] [EOL] contract = web3 . eth . contract ( abi = abi , bytecode = bytecode ) [EOL] constuctor_call = contract . constructor ( * constructor_args ) [EOL] [EOL] receipt = send_function_call_transaction ( constuctor_call , web3 = web3 , transaction_options = transaction_options , private_key = private_key , ) [EOL] [EOL] address = receipt [ [string] ] [EOL] return contract ( address ) [EOL] [EOL] [EOL] def _set_from_address ( web3 , transaction_options ) : [EOL] [docstring] [EOL] if [string] not in transaction_options : [EOL] transaction_options [ [string] ] = web3 . eth . defaultAccount or web3 . eth . accounts [ [number] ] [EOL] [EOL] [EOL] def send_function_call_transaction ( function_call , * , web3 , transaction_options = None , private_key = None ) : [EOL] [docstring] [EOL] if transaction_options is None : [EOL] transaction_options = { } [EOL] [EOL] if private_key is not None : [EOL] signed_transaction = _build_and_sign_transaction ( function_call , web3 = web3 , transaction_options = transaction_options , private_key = private_key , ) [EOL] tx_hash = web3 . eth . sendRawTransaction ( signed_transaction . rawTransaction ) [EOL] [EOL] else : [EOL] _set_from_address ( web3 , transaction_options ) [EOL] [EOL] tx_hash = function_call . transact ( transaction_options ) [EOL] [EOL] return wait_for_successful_transaction_receipt ( web3 , tx_hash ) [EOL] [EOL] [EOL] def send_transaction ( * , web3 , transaction_options , private_key = None ) : [EOL] [docstring] [EOL] [EOL] if private_key is not None : [EOL] account = Account . from_key ( private_key ) [EOL] [EOL] if ( [string] in transaction_options [EOL] and transaction_options [ [string] ] != account . address ) : [EOL] raise ValueError ( [string] ) [EOL] transaction_options [ [string] ] = account . address [EOL] [EOL] transaction = fill_nonce ( web3 , transaction_options ) [EOL] transaction = fill_transaction_defaults ( web3 , transaction ) [EOL] signed_transaction = account . sign_transaction ( transaction ) [EOL] tx_hash = web3 . eth . sendRawTransaction ( signed_transaction . rawTransaction ) [EOL] [EOL] else : [EOL] _set_from_address ( web3 , transaction_options ) [EOL] tx_hash = web3 . eth . sendTransaction ( transaction_options ) [EOL] [EOL] receipt = wait_for_successful_transaction_receipt ( web3 , tx_hash ) [EOL] [EOL] return receipt [EOL] [EOL] [EOL] class TransactionFailed ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def wait_for_successful_transaction_receipt ( web3 , txid , timeout = [number] ) : [EOL] [docstring] [EOL] receipt = web3 . eth . waitForTransactionReceipt ( txid , timeout = timeout ) [EOL] status = receipt . get ( [string] , None ) [EOL] if status == [number] : [EOL] raise TransactionFailed [EOL] elif status == [number] : [EOL] return receipt [EOL] else : [EOL] raise ValueError ( f" [string] { status }" ) [EOL] [EOL] [EOL] def load_contracts_json ( package_name , filename = [string] ) : [EOL] resource_package = package_name [EOL] json_string = pkg_resources . resource_string ( resource_package , filename ) [EOL] return json . loads ( json_string ) [EOL] [EOL] [EOL] def decrypt_private_key ( keystore_path , password ) : [EOL] return extract_key_from_keyfile ( keystore_path , password . encode ( [string] ) ) [EOL] [EOL] [EOL] def build_transaction_options ( * , gas , gas_price , nonce , value = None ) : [EOL] [EOL] transaction_options = { } [EOL] [EOL] if gas is not None : [EOL] transaction_options [ [string] ] = gas [EOL] if gas_price is not None : [EOL] transaction_options [ [string] ] = gas_price [EOL] if nonce is not None : [EOL] transaction_options [ [string] ] = nonce [EOL] if value is not None : [EOL] transaction_options [ [string] ] = value [EOL] [EOL] return transaction_options [EOL] [EOL] [EOL] def increase_transaction_options_nonce ( transaction_options ) : [EOL] [docstring] [EOL] if [string] in transaction_options : [EOL] transaction_options [ [string] ] = transaction_options [ [string] ] + [number] [EOL] [EOL] [EOL] def _build_and_sign_transaction ( function_call , * , web3 , transaction_options , private_key ) : [EOL] account = Account . from_key ( private_key ) [EOL] [EOL] if [string] in transaction_options and transaction_options [ [string] ] != account . address : [EOL] raise ValueError ( [string] ) [EOL] transaction_options [ [string] ] = account . address [EOL] [EOL] transaction = fill_nonce ( web3 , function_call . buildTransaction ( transaction_options ) ) [EOL] [EOL] return account . sign_transaction ( transaction ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.types.TxReceipt$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict , Optional , Sequence [EOL] import typing [EOL] import web3 [EOL] import click [EOL] import builtins [EOL] import json [EOL] import re [EOL] from os import path [EOL] from pathlib import Path [EOL] from typing import Optional , Sequence [EOL] [EOL] import click [EOL] from eth_utils import encode_hex [EOL] from web3 import Account , EthereumTesterProvider , Web3 [EOL] from web3 . _utils . abi import get_abi_input_types , get_constructor_abi [EOL] [EOL] from . compile import ( DEFAULT_EVM_VERSION , UnknownContractException , build_initcode , compile_project , filter_contracts , ) [EOL] from . deploy import ( build_transaction_options , decrypt_private_key , deploy_compiled_contract , send_function_call_transaction , send_transaction , ) [EOL] from . files import ( InvalidAddressException , ensure_path_for_file_exists , load_json_asset , validate_and_format_address , write_minified_json_asset , write_pretty_json_asset , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] test_provider = EthereumTesterProvider ( ) [EOL] test_json_rpc = Web3 ( test_provider ) [EOL] [EOL] CONTRACTS_DIR_DEFAULT = [string] [EOL] KEYSTORE_FILE_SAVE_DEFAULT = [string] [EOL] [EOL] [EOL] def validate_address ( ctx , param , value ) : [EOL] try : [EOL] return validate_and_format_address ( value ) [EOL] except InvalidAddressException as e : [EOL] raise click . BadParameter ( f" [string] { value }" ) from e [EOL] [EOL] [EOL] jsonrpc_option = click . option ( [string] , help = [string] , default = [string] , show_default = True , metavar = [string] , envvar = [string] , ) [EOL] keystore_option = click . option ( [string] , help = [string] , type = click . Path ( exists = True , dir_okay = False ) , default = None , envvar = [string] , ) [EOL] gas_option = click . option ( [string] , help = [string] , type = int , default = None , envvar = [string] , ) [EOL] gas_price_option = click . option ( [string] , help = [string] , type = int , default = None , envvar = [string] , ) [EOL] nonce_option = click . option ( [string] , help = [string] , type = int , default = None ) [EOL] auto_nonce_option = click . option ( [string] , help = [string] , default = False , is_flag = True , envvar = [string] , ) [EOL] contracts_dir_option = click . option ( [string] , [string] , help = f" [string] { CONTRACTS_DIR_DEFAULT } [string] " , type = click . Path ( file_okay = False , exists = True ) , envvar = [string] , ) [EOL] optimize_option = click . option ( [string] , default = True , show_default = True , help = [string] , envvar = [string] , ) [EOL] optimize_runs_option = click . option ( [string] , default = [number] , type = int , show_default = True , help = [string] , envvar = [string] , ) [EOL] evm_version_option = click . option ( [string] , type = str , help = [string] [string] , default = DEFAULT_EVM_VERSION , show_default = True , envvar = [string] , ) [EOL] compiled_contracts_path_option = click . option ( [string] , [string] , help = [string] , type = click . Path ( file_okay = True , exists = True ) , envvar = [string] , ) [EOL] contract_address_option = click . option ( [string] , help = [string] , type = str , required = True , callback = validate_address , ) [EOL] keystore_file_save_option = click . option ( [string] , help = f" [string] " , type = click . Path ( resolve_path = True ) , default = KEYSTORE_FILE_SAVE_DEFAULT , show_default = True , ) [EOL] private_key_option = click . option ( [string] , help = [string] , type = str , default = None , ) [EOL] value_option = click . option ( [string] , help = [string] , type = int , default = None , ) [EOL] [EOL] [EOL] @ click . group ( ) def main ( ) : [EOL] pass [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ contracts_dir_option @ optimize_option @ optimize_runs_option @ evm_version_option @ click . option ( [string] , default = False , help = [string] , is_flag = True , ) @ click . option ( [string] , default = False , help = [string] , is_flag = True , ) @ click . option ( [string] , default = None , help = [string] , ) @ click . option ( [string] , [string] , type = click . Path ( dir_okay = False , writable = True , exists = False ) , help = [string] , show_default = True , default = [string] , ) def compile ( contracts_dir , optimize , optimize_runs , evm_version , only_abi , minimize , contract_names , output , ) : [EOL] if contract_names is not None : [EOL] contract_names = contract_names . split ( [string] ) [EOL] [EOL] ensure_path_for_file_exists ( output ) [EOL] [EOL] if contracts_dir is None : [EOL] contracts_dir = CONTRACTS_DIR_DEFAULT [EOL] verify_contracts_dir_exists ( contracts_dir ) [EOL] [EOL] try : [EOL] compiled_contracts = filter_contracts ( contract_names , compile_project ( contracts_dir , optimize = optimize , optimize_runs = optimize_runs , only_abi = only_abi , evm_version = evm_version , ) , ) [EOL] except UnknownContractException as e : [EOL] raise click . BadOptionUsage ( [string] , f" [string] { e . args [ [number] ] }" ) [EOL] if minimize : [EOL] write_minified_json_asset ( compiled_contracts , output ) [EOL] else : [EOL] write_pretty_json_asset ( compiled_contracts , output ) [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ click . argument ( [string] , type = str ) @ click . argument ( [string] , nargs = - [number] , type = str ) @ gas_option @ gas_price_option @ nonce_option @ auto_nonce_option @ keystore_option @ jsonrpc_option @ contracts_dir_option @ optimize_option @ evm_version_option @ compiled_contracts_path_option def deploy ( contract_name , args , gas , gas_price , nonce , auto_nonce , keystore , jsonrpc , contracts_dir , optimize , evm_version , compiled_contracts_path , ) : [EOL] [docstring] [EOL] web3 = connect_to_json_rpc ( jsonrpc ) [EOL] private_key = retrieve_private_key ( keystore ) [EOL] [EOL] nonce = get_nonce ( web3 = web3 , nonce = nonce , auto_nonce = auto_nonce , private_key = private_key ) [EOL] transaction_options = build_transaction_options ( gas = gas , gas_price = gas_price , nonce = nonce ) [EOL] [EOL] compiled_contracts = get_compiled_contracts ( contracts_dir = contracts_dir , optimize = optimize , evm_version = evm_version , compiled_contracts_path = compiled_contracts_path , ) [EOL] [EOL] if contract_name not in compiled_contracts : [EOL] raise click . BadArgumentUsage ( f" [string] { contract_name } [string] " ) [EOL] [EOL] abi = compiled_contracts [ contract_name ] [ [string] ] [EOL] bytecode = compiled_contracts [ contract_name ] [ [string] ] [EOL] [EOL] contract = deploy_compiled_contract ( abi = abi , bytecode = bytecode , constructor_args = parse_args_to_matching_types_for_constructor ( args , abi ) , web3 = web3 , transaction_options = transaction_options , private_key = private_key , ) [EOL] [EOL] click . echo ( contract . address ) [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ click . argument ( [string] , type = str ) @ click . argument ( [string] , nargs = - [number] , type = str ) @ contracts_dir_option @ optimize_option @ evm_version_option @ compiled_contracts_path_option def initcode ( contract_name , args , contracts_dir , optimize , evm_version , compiled_contracts_path , ) : [EOL] [docstring] [EOL] [EOL] compiled_contracts = get_compiled_contracts ( contracts_dir = contracts_dir , optimize = optimize , evm_version = evm_version , compiled_contracts_path = compiled_contracts_path , ) [EOL] [EOL] if contract_name not in compiled_contracts : [EOL] raise click . BadArgumentUsage ( f" [string] { contract_name } [string] " ) [EOL] [EOL] abi = compiled_contracts [ contract_name ] [ [string] ] [EOL] bytecode = compiled_contracts [ contract_name ] [ [string] ] [EOL] [EOL] arguments = parse_args_to_matching_types_for_constructor ( args , abi ) [EOL] initcode = build_initcode ( contract_abi = abi , contract_bytecode = bytecode , constructor_args = arguments ) [EOL] [EOL] click . echo ( initcode ) [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ click . argument ( [string] , type = str ) @ click . argument ( [string] , type = str ) @ click . argument ( [string] , nargs = - [number] , type = str ) @ gas_option @ gas_price_option @ nonce_option @ auto_nonce_option @ keystore_option @ jsonrpc_option @ contracts_dir_option @ compiled_contracts_path_option @ contract_address_option @ value_option def transact ( contract_name , function_name , args , gas , gas_price , nonce , auto_nonce , keystore , jsonrpc , contracts_dir , compiled_contracts_path , contract_address , value , ) : [EOL] [docstring] [EOL] web3 = connect_to_json_rpc ( jsonrpc ) [EOL] private_key = retrieve_private_key ( keystore ) [EOL] [EOL] nonce = get_nonce ( web3 = web3 , nonce = nonce , auto_nonce = auto_nonce , private_key = private_key ) [EOL] transaction_options = build_transaction_options ( gas = gas , gas_price = gas_price , nonce = nonce , value = value ) [EOL] [EOL] compiled_contracts = get_compiled_contracts ( contracts_dir = contracts_dir , compiled_contracts_path = compiled_contracts_path ) [EOL] [EOL] if contract_name not in compiled_contracts : [EOL] raise click . BadArgumentUsage ( f" [string] { contract_name } [string] " ) [EOL] [EOL] contract_abi = compiled_contracts [ contract_name ] [ [string] ] [EOL] contract = web3 . eth . contract ( abi = contract_abi , address = contract_address ) [EOL] function_abi = get_contract_matching_function ( contract_abi , function_name , args ) [EOL] parsed_arguments = parse_args_to_matching_types_for_function ( args , function_abi ) [EOL] function_call = contract . functions [ function_name ] ( * parsed_arguments ) [EOL] [EOL] receipt = send_function_call_transaction ( function_call , web3 = web3 , transaction_options = transaction_options , private_key = private_key , ) [EOL] [EOL] click . echo ( encode_hex ( receipt . transactionHash ) ) [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ click . argument ( [string] , type = str ) @ click . argument ( [string] , type = str ) @ click . argument ( [string] , nargs = - [number] , type = str ) @ jsonrpc_option @ contracts_dir_option @ compiled_contracts_path_option @ contract_address_option def call ( contract_name , function_name , args , jsonrpc , contracts_dir , contract_address , compiled_contracts_path , ) : [EOL] [docstring] [EOL] web3 = connect_to_json_rpc ( jsonrpc ) [EOL] [EOL] compiled_contracts = get_compiled_contracts ( contracts_dir = contracts_dir , compiled_contracts_path = compiled_contracts_path ) [EOL] [EOL] if contract_name not in compiled_contracts : [EOL] raise click . BadArgumentUsage ( f" [string] { contract_name } [string] " ) [EOL] [EOL] contract_abi = compiled_contracts [ contract_name ] [ [string] ] [EOL] contract = web3 . eth . contract ( abi = contract_abi , address = contract_address ) [EOL] function_abi = get_contract_matching_function ( contract_abi , function_name , args ) [EOL] parsed_arguments = parse_args_to_matching_types_for_function ( args , function_abi ) [EOL] result = contract . functions [ function_name ] ( * parsed_arguments ) . call ( ) [EOL] [EOL] click . echo ( result ) [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ keystore_file_save_option @ private_key_option def generate_keystore ( keystore_path , private_key ) : [EOL] if path . exists ( keystore_path ) : [EOL] raise click . BadOptionUsage ( [string] , f" [string] { keystore_path } [string] " ) [EOL] [EOL] if private_key : [EOL] account = Account . from_key ( private_key ) [EOL] else : [EOL] account = Account . create ( ) [EOL] [EOL] password = click . prompt ( [string] , type = str , hide_input = True , confirmation_prompt = True , ) [EOL] keystore = account . encrypt ( password = password ) [EOL] [EOL] with open ( keystore_path , [string] ) as file : [EOL] file . write ( json . dumps ( keystore ) ) [EOL] file . close ( ) [EOL] [EOL] click . echo ( f" [string] { account . address } [string] { keystore_path }" ) [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ click . argument ( [string] , type = int ) @ click . argument ( [string] , type = str ) @ jsonrpc_option @ gas_option @ gas_price_option @ nonce_option @ auto_nonce_option @ keystore_option def send_eth ( gas , gas_price , nonce , auto_nonce , keystore , jsonrpc , address , value , ) : [EOL] [docstring] [EOL] web3 = connect_to_json_rpc ( jsonrpc ) [EOL] private_key = retrieve_private_key ( keystore ) [EOL] [EOL] nonce = get_nonce ( web3 = web3 , nonce = nonce , auto_nonce = auto_nonce , private_key = private_key ) [EOL] transaction_options = build_transaction_options ( gas = gas , gas_price = gas_price , nonce = nonce , value = value ) [EOL] [EOL] transaction_options [ [string] ] = address [EOL] [EOL] receipt = send_transaction ( web3 = web3 , transaction_options = transaction_options , private_key = private_key ) [EOL] [EOL] click . echo ( encode_hex ( receipt [ [string] ] ) ) [EOL] [EOL] [EOL] def get_compiled_contracts ( * , contracts_dir , optimize = False , evm_version = DEFAULT_EVM_VERSION , compiled_contracts_path , ) : [EOL] if contracts_dir is not None and compiled_contracts_path is not None : [EOL] raise click . BadOptionUsage ( [string] , f" [string] " , ) [EOL] if compiled_contracts_path is not None : [EOL] return load_json_asset ( compiled_contracts_path ) [EOL] else : [EOL] if contracts_dir is None : [EOL] contracts_dir = CONTRACTS_DIR_DEFAULT [EOL] verify_contracts_dir_exists ( contracts_dir ) [EOL] return compile_project ( contracts_dir , optimize = optimize , evm_version = evm_version ) [EOL] [EOL] [EOL] def verify_contracts_dir_exists ( contracts_dir ) : [EOL] if not Path ( contracts_dir ) . is_dir ( ) : [EOL] raise click . BadOptionUsage ( [string] , f' [string] { contracts_dir } [string] ' ) [EOL] [EOL] [EOL] def connect_to_json_rpc ( jsonrpc ) : [EOL] if jsonrpc == [string] : [EOL] web3 = test_json_rpc [EOL] else : [EOL] web3 = Web3 ( Web3 . HTTPProvider ( jsonrpc , request_kwargs = { [string] : [number] } ) ) [EOL] return web3 [EOL] [EOL] [EOL] def retrieve_private_key ( keystore_path ) : [EOL] [docstring] [EOL] [EOL] private_key = None [EOL] [EOL] if keystore_path is not None : [EOL] password = click . prompt ( [string] , type = str , hide_input = True , default = [string] , ) [EOL] private_key = decrypt_private_key ( keystore_path , password ) [EOL] [EOL] return private_key [EOL] [EOL] [EOL] def get_nonce ( * , web3 , nonce , auto_nonce , private_key ) : [EOL] [docstring] [EOL] if auto_nonce and not private_key : [EOL] raise click . UsageError ( [string] ) [EOL] if nonce is not None and auto_nonce : [EOL] raise click . UsageError ( [string] ) [EOL] [EOL] if auto_nonce : [EOL] return web3 . eth . getTransactionCount ( Account . from_key ( private_key ) . address , block_identifier = [string] ) [EOL] else : [EOL] return nonce [EOL] [EOL] [EOL] def get_contract_matching_function ( contract_abi , function_name , args ) : [EOL] candidates = [ abi for abi in contract_abi if abi [ [string] ] == [string] [EOL] and abi [ [string] ] == function_name [EOL] and len ( abi [ [string] ] ) == len ( args ) ] [EOL] [EOL] if len ( candidates ) == [number] : [EOL] return candidates [ [number] ] [EOL] elif len ( candidates ) == [number] : [EOL] raise ValueError ( [string] ) [EOL] elif len ( candidates ) > [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def parse_args_to_matching_types_for_constructor ( args , contract_abi ) : [EOL] [docstring] [EOL] constructor_abi = get_constructor_abi ( contract_abi ) [EOL] if constructor_abi : [EOL] return parse_args_to_matching_types_for_function ( args , constructor_abi ) [EOL] return [ ] [EOL] [EOL] [EOL] def parse_args_to_matching_types_for_function ( args , function_abi ) : [EOL] types = get_abi_input_types ( function_abi ) [EOL] return [ parse_arg_to_matching_type ( arg , type ) for arg , type in zip ( args , types ) ] [EOL] [EOL] [EOL] def parse_arg_to_matching_type ( arg , type ) : [EOL] int_pattern = [string] [EOL] int_array_pattern = [string] [EOL] bool_pattern = [string] [EOL] bool_array_pattern = [string] [EOL] address_pattern = [string] [EOL] address_array_pattern = [string] [EOL] bytes_pattern = [string] [EOL] string_pattern = [string] [EOL] [docstring] [EOL] if re . match ( int_pattern , type ) : [EOL] return int ( arg ) [EOL] if re . match ( int_array_pattern , type ) : [EOL] return [ int ( _arg ) for _arg in arg . split ( [string] ) ] [EOL] if re . match ( bool_pattern , type ) : [EOL] if arg . lower ( ) == [string] : [EOL] return True [EOL] if arg . lower ( ) == [string] : [EOL] return False [EOL] raise ValueError ( f" [string] { arg }" ) [EOL] if re . match ( bool_array_pattern , type ) : [EOL] return [ parse_arg_to_matching_type ( _arg , [string] ) for _arg in arg . split ( [string] ) ] [EOL] if re . match ( address_pattern , type ) : [EOL] return Web3 . toChecksumAddress ( arg ) [EOL] if re . match ( address_array_pattern , type ) : [EOL] return [ Web3 . toChecksumAddress ( _arg ) for _arg in arg . split ( [string] ) ] [EOL] if re . match ( bytes_pattern , type ) or re . match ( string_pattern , type ) : [EOL] return arg [EOL] raise ValueError ( f" [string] { type } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.Web3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import _csv [EOL] import builtins [EOL] import csv [EOL] import fnmatch [EOL] import json [EOL] import os [EOL] from pathlib import Path [EOL] from typing import Dict [EOL] [EOL] from eth_utils import is_address , to_checksum_address [EOL] [EOL] [EOL] def find_files ( dir , pattern ) : [EOL] for dirpath , _ , filenames in os . walk ( dir ) : [EOL] for filename in filenames : [EOL] if fnmatch . fnmatch ( filename , pattern ) : [EOL] yield os . path . join ( dirpath , filename ) [EOL] [EOL] [EOL] def ensure_path_for_file_exists ( file_path ) : [EOL] Path ( file_path ) . parent . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] [EOL] def write_pretty_json_asset ( json_data , asset_path ) : [EOL] with open ( asset_path , [string] ) as file : [EOL] json . dump ( json_data , file , indent = [number] ) [EOL] [EOL] [EOL] def write_minified_json_asset ( json_data , compiled_contracts_asset_path ) : [EOL] with open ( compiled_contracts_asset_path , [string] ) as file : [EOL] json . dump ( json_data , file , separators = ( [string] , [string] ) ) [EOL] [EOL] [EOL] def load_json_asset ( asset_path ) : [EOL] with open ( asset_path , [string] ) as file : [EOL] return json . load ( file ) [EOL] [EOL] [EOL] def read_addresses_in_csv ( file_path ) : [EOL] with open ( file_path ) as f : [EOL] reader = csv . reader ( f ) [EOL] addresses = [ ] [EOL] for line in reader : [EOL] address = validate_and_format_address ( line [ [number] ] ) [EOL] addresses . append ( address ) [EOL] return addresses [EOL] [EOL] [EOL] def validate_and_format_address ( address ) : [EOL] [docstring] [EOL] if is_address ( address ) : [EOL] return to_checksum_address ( address ) [EOL] else : [EOL] raise InvalidAddressException ( ) [EOL] [EOL] [EOL] class InvalidAddressException ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . compile import compile_contract , compile_project [comment] [EOL] from . deploy import deploy_compiled_contract [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from eth_utils import is_hex [EOL] [EOL] from deploy_tools . compile import build_initcode [EOL] [EOL] [EOL] def test_build_initcode_no_constructor ( contract_assets ) : [EOL] contract_interface = contract_assets [ [string] ] [EOL] initcode = build_initcode ( contract_bytecode = contract_interface [ [string] ] ) [EOL] [EOL] assert is_hex ( initcode ) [EOL] [EOL] [EOL] def test_build_initcode_with_constructor ( contract_assets ) : [EOL] contract_interface = contract_assets [ [string] ] [EOL] initcode = build_initcode ( contract_bytecode = contract_interface [ [string] ] , contract_abi = contract_interface [ [string] ] , constructor_args = [ [number] ] , ) [EOL] [EOL] assert is_hex ( initcode ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import _csv [EOL] import builtins [EOL] import csv [EOL] [EOL] import pytest [EOL] from eth_utils import to_checksum_address [EOL] [EOL] from deploy_tools . files import InvalidAddressException , read_addresses_in_csv [EOL] [EOL] [EOL] @ pytest . fixture ( ) def address_list ( ) : [EOL] def create_address_string ( i ) : [EOL] return f" [string] { str ( i ) . rjust ( [number] , [string] ) }" [EOL] [EOL] return [ create_address_string ( i ) for i in range ( [number] ) ] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def address_list_csv_path ( tmp_path , address_list ) : [EOL] folder = tmp_path / [string] [EOL] folder . mkdir ( ) [EOL] file_path = folder / [string] [EOL] [EOL] with file_path . open ( [string] ) as f : [EOL] writer = csv . writer ( f ) [EOL] writer . writerows ( [ [ to_checksum_address ( address ) ] for address in address_list ] ) [EOL] [EOL] return file_path [EOL] [EOL] [EOL] @ pytest . fixture ( ) def incorrect_list_csv_path ( tmp_path , address_list ) : [EOL] folder = tmp_path / [string] [EOL] folder . mkdir ( ) [EOL] file_path = folder / [string] [EOL] incorrect_value = [string] [EOL] [EOL] with file_path . open ( [string] ) as f : [EOL] writer = csv . writer ( f ) [EOL] writer . writerows ( [ [ to_checksum_address ( address ) ] for address in address_list ] ) [EOL] writer . writerow ( incorrect_value ) [EOL] [EOL] return file_path [EOL] [EOL] [EOL] def test_read_addresses_in_csv ( address_list_csv_path , address_list ) : [EOL] addresses = read_addresses_in_csv ( address_list_csv_path ) [EOL] [EOL] assert addresses == address_list [EOL] [EOL] [EOL] def test_read_incorrect_addresses_in_csv ( incorrect_list_csv_path ) : [EOL] with pytest . raises ( InvalidAddressException ) : [EOL] read_addresses_in_csv ( incorrect_list_csv_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] [EOL] @ pytest . fixture ( ) def contract ( deploy_contract ) : [EOL] return deploy_contract ( [string] , constructor_args = ( [number] , ) ) [EOL] [EOL] [EOL] def test_call ( contract ) : [EOL] assert contract . functions . testFunction ( [number] ) . call ( ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import eth_utils [EOL] import pytest [EOL] from eth_utils import is_address [EOL] [EOL] from deploy_tools . compile import compile_project [EOL] from deploy_tools . deploy import ( TransactionFailed , deploy_compiled_contract , send_function_call_transaction , send_transaction , ) [EOL] from deploy_tools . plugin import get_contracts_folder [EOL] [EOL] [EOL] @ pytest . fixture ( ) def test_contract ( deploy_contract ) : [EOL] return deploy_contract ( [string] , constructor_args = ( [number] , ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def contract_assets_st_petersburg ( pytestconfig ) : [EOL] contracts_path = get_contracts_folder ( pytestconfig ) [EOL] evm_version = [string] [EOL] return compile_project ( contracts_path = contracts_path , optimize = True , evm_version = evm_version ) [EOL] [EOL] [EOL] def test_deploy_from_private_key ( web3 , contract_assets , account_keys ) : [EOL] contract_interface = contract_assets [ [string] ] [EOL] contract = deploy_compiled_contract ( abi = contract_interface [ [string] ] , bytecode = contract_interface [ [string] ] , web3 = web3 , constructor_args = ( [number] , ) , private_key = account_keys [ [number] ] , ) [EOL] [EOL] assert is_address ( contract . address ) [EOL] [EOL] [EOL] def test_deploy ( web3 , contract_assets ) : [EOL] contract_interface = contract_assets [ [string] ] [EOL] contract = deploy_compiled_contract ( abi = contract_interface [ [string] ] , bytecode = contract_interface [ [string] ] , web3 = web3 , constructor_args = ( [number] , ) , ) [EOL] [EOL] assert is_address ( contract . address ) [EOL] [EOL] [EOL] def test_deploy_st_petersburg ( web3 , contract_assets_st_petersburg ) : [EOL] contract_interface = contract_assets_st_petersburg [ [string] ] [EOL] contract = deploy_compiled_contract ( abi = contract_interface [ [string] ] , bytecode = contract_interface [ [string] ] , web3 = web3 , constructor_args = ( [number] , ) , ) [EOL] [EOL] assert is_address ( contract . address ) [EOL] [EOL] [EOL] def test_send_contract_call ( test_contract , web3 ) : [EOL] [EOL] function_call = test_contract . functions . set ( [number] ) [EOL] [EOL] receipt = send_function_call_transaction ( function_call , web3 = web3 ) [EOL] [EOL] assert receipt [ [string] ] [EOL] assert test_contract . functions . state ( ) . call ( ) == [number] [EOL] [EOL] [EOL] def test_send_contract_call_from_private_key ( test_contract , web3 , account_keys ) : [EOL] [EOL] function_call = test_contract . functions . set ( [number] ) [EOL] [EOL] receipt = send_function_call_transaction ( function_call , web3 = web3 , private_key = account_keys [ [number] ] ) [EOL] [EOL] assert receipt [ [string] ] [EOL] assert test_contract . functions . state ( ) . call ( ) == [number] [EOL] [EOL] [EOL] def test_send_contract_call_with_transaction_options ( test_contract , web3 , account_keys ) : [EOL] [EOL] function_call = test_contract . functions . set ( [number] ) [EOL] [EOL] transaction_options = { [string] : [number] , [string] : [number] } [EOL] [EOL] receipt = send_function_call_transaction ( function_call , web3 = web3 , transaction_options = transaction_options , private_key = account_keys [ [number] ] , ) [EOL] [EOL] transaction = web3 . eth . getTransaction ( receipt . transactionHash ) [EOL] [EOL] for key , value in transaction_options . items ( ) : [EOL] assert transaction [ key ] == value [EOL] [EOL] [EOL] def test_send_contract_call_set_nonce ( test_contract , web3 , account_keys ) : [EOL] [EOL] function_call = test_contract . functions . set ( [number] ) [EOL] nonce = [number] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( eth_utils . ValidationError ) : [EOL] send_function_call_transaction ( function_call , transaction_options = { [string] : nonce } , web3 = web3 , private_key = account_keys [ [number] ] , ) [EOL] [EOL] [EOL] def test_wait_for_successful_tx_receipt ( test_contract , web3 , account_keys ) : [EOL] [docstring] [EOL] function_call = test_contract . functions . failingFunction ( ) [EOL] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] [comment] [EOL] [comment] [EOL] send_function_call_transaction ( function_call , transaction_options = { [string] : [number] } , web3 = web3 , private_key = account_keys [ [number] ] , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_send_eth_default_account ( web3 , accounts , account_keys , use_private_key ) : [EOL] pre_balance_0 = web3 . eth . getBalance ( accounts [ [number] ] ) [EOL] pre_balance_1 = web3 . eth . getBalance ( accounts [ [number] ] ) [EOL] value = [number] [EOL] transaction_option = { [string] : value , [string] : accounts [ [number] ] , [string] : [number] } [EOL] send_transaction ( web3 = web3 , transaction_options = transaction_option , private_key = account_keys [ [number] ] if use_private_key else None , ) [EOL] [EOL] post_balance_0 = web3 . eth . getBalance ( accounts [ [number] ] ) [EOL] post_balance_1 = web3 . eth . getBalance ( accounts [ [number] ] ) [EOL] [EOL] assert post_balance_0 - pre_balance_0 == - value [EOL] assert post_balance_1 - pre_balance_1 == value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import json [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from click . testing import CliRunner [EOL] from eth_keyfile import create_keyfile_json [EOL] from eth_utils import is_0x_prefixed , is_address , is_hex [EOL] from eth_utils . exceptions import ValidationError [EOL] [EOL] from deploy_tools . cli import main , parse_arg_to_matching_type [EOL] [EOL] [EOL] @ pytest . fixture ( ) def keystores ( tmp_path , account_keys , key_password ) : [EOL] [docstring] [EOL] paths = [ ] [EOL] for i , private_key in enumerate ( account_keys [ : [number] ] ) : [EOL] file_path = tmp_path / f" [string] { i } [string] " [EOL] file_path . write_text ( json . dumps ( create_keyfile_json ( private_key . to_bytes ( ) , key_password . encode ( [string] ) ) ) ) [EOL] paths . append ( file_path ) [EOL] [EOL] return paths [EOL] [EOL] [EOL] @ pytest . fixture ( ) def test_contract_name ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def test_contract_address ( runner , test_contract_name ) : [EOL] result = runner . invoke ( main , f" [string] { test_contract_name } [string] " ) [EOL] assert result . exit_code == [number] [EOL] contract_address = result . output [ : - [number] ] [EOL] assert is_address ( contract_address ) [EOL] return contract_address [EOL] [EOL] [EOL] @ pytest . fixture ( ) def output_file ( tmp_path ) : [EOL] return tmp_path / [string] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def keystore_file_path ( tmp_path , keystores , key_password ) : [EOL] [docstring] [EOL] return keystores [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def key_password ( ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def runner ( ) : [EOL] return CliRunner ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def go_to_root_dir ( ) : [EOL] current_path = os . getcwd ( ) [EOL] os . chdir ( Path ( __file__ ) . parent . parent ) [EOL] yield [EOL] os . chdir ( current_path ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def compiled_contracts_path ( go_to_root_dir , runner ) : [EOL] compiled_contracts_path = [string] [EOL] result = runner . invoke ( main , f" [string] { compiled_contracts_path }" ) [EOL] assert result . exit_code == [number] [EOL] [EOL] with open ( compiled_contracts_path ) as f : [EOL] contract_assets = json . load ( f ) [EOL] assert [string] in contract_assets [EOL] [EOL] return compiled_contracts_path [EOL] [EOL] [EOL] @ pytest . fixture ( ) def keystore_file_save_path ( tmpdir ) : [EOL] return tmpdir . join ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def private_key ( account_keys ) : [EOL] return account_keys [ [number] ] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_default_compile ( runner ) : [EOL] result = runner . invoke ( main , [string] ) [EOL] assert result . exit_code == [number] [EOL] [EOL] with open ( [string] ) as f : [EOL] contract_assets = json . load ( f ) [EOL] assert [string] in contract_assets [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_minimize_compile ( runner ) : [EOL] result = runner . invoke ( main , [string] ) [EOL] assert result . exit_code == [number] [EOL] [EOL] with open ( [string] ) as f : [EOL] contract_assets = json . load ( f ) [EOL] assert [string] in contract_assets [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_contract_names_compile ( runner ) : [EOL] result = runner . invoke ( main , [string] ) [EOL] assert result . exit_code == [number] [EOL] [EOL] with open ( [string] ) as f : [EOL] contract_assets = json . load ( f ) [EOL] assert [string] not in contract_assets [EOL] assert [string] in contract_assets [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_contract_output_file ( runner , output_file ) : [EOL] result = runner . invoke ( main , f" [string] { output_file }" ) [EOL] assert result . exit_code == [number] [EOL] [EOL] with output_file . open ( ) as f : [EOL] contract_assets = json . load ( f ) [EOL] assert [string] in contract_assets [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_unknown_contract_names_compile ( runner ) : [EOL] result = runner . invoke ( main , [string] ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_deploy_simple_contract ( runner ) : [EOL] result = runner . invoke ( main , [string] ) [EOL] assert result . exit_code == [number] [EOL] assert is_address ( result . output [ : - [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_deploy_no_contracts_directory ( runner ) : [EOL] result = runner . invoke ( main , [string] ) [EOL] assert result . exit_code == [number] [EOL] assert [string] in result . output [ : - [number] ] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_deploy_contracts_dir_and_compiled_contracts ( runner , compiled_contracts_path ) : [EOL] result = runner . invoke ( main , f" [string] " f" [string] { compiled_contracts_path } [string] " , ) [EOL] assert result . exit_code == [number] [EOL] assert ( [string] in result . output [ : - [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_deploy_simple_contract_from_compiled_contracts ( runner , compiled_contracts_path ) : [EOL] result = runner . invoke ( main , f" [string] { compiled_contracts_path } [string] " , ) [EOL] assert result . exit_code == [number] [EOL] assert is_address ( result . output [ : - [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_deploy_contract_with_arguments ( runner ) : [EOL] result = runner . invoke ( main , [string] + [string] , ) [EOL] assert result . exit_code == [number] [EOL] assert is_address ( result . output [ : - [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_deploy_transaction_parameters ( runner ) : [EOL] result = runner . invoke ( main , [string] + [string] , ) [EOL] assert result . exit_code == [number] [EOL] assert is_address ( result . output [ : - [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_deploy_transaction_parameters_wrong_gas ( runner ) : [EOL] result = runner . invoke ( main , [string] + [string] , ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_deploy_transaction_parameters_wrong_gas_price ( runner ) : [EOL] result = runner . invoke ( main , [string] + [string] , ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_deploy_keystore ( runner , keystore_file_path , key_password ) : [EOL] result = runner . invoke ( main , f" [string] { keystore_file_path }" , input = key_password , ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_deploy_keystore_wrong_nonce ( runner , keystore_file_path , key_password ) : [EOL] result = runner . invoke ( main , f" [string] { keystore_file_path }" , input = key_password , ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_initcode_simple_contract ( runner ) : [EOL] result = runner . invoke ( main , f" [string] " ) [EOL] print ( result . output ) [EOL] assert result . exit_code == [number] [EOL] [EOL] transaction_hash = result . output . splitlines ( ) [ - [number] ] [EOL] [EOL] assert is_hex ( transaction_hash ) [EOL] assert is_0x_prefixed ( transaction_hash ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_initcode_with_constructor_argument ( runner , key_password ) : [EOL] result = runner . invoke ( main , f" [string] " , input = key_password ) [EOL] assert result . exit_code == [number] [EOL] [EOL] transaction_hash = result . output . splitlines ( ) [ - [number] ] [EOL] [EOL] assert is_hex ( transaction_hash ) [EOL] assert is_0x_prefixed ( transaction_hash ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_send_transaction_to_contract ( runner , test_contract_address , test_contract_name ) : [EOL] result = runner . invoke ( main , ( f" [string] { test_contract_address } [string] " f" [string] { test_contract_name } [string] " ) , ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] transaction_hash = result . output . splitlines ( ) [ - [number] ] [EOL] [EOL] assert is_hex ( transaction_hash ) [EOL] assert is_0x_prefixed ( transaction_hash ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_send_transaction_to_contract_from_compiled_contracts ( runner , test_contract_address , test_contract_name , compiled_contracts_path ) : [EOL] result = runner . invoke ( main , ( f" [string] { compiled_contracts_path } [string] " f" [string] { test_contract_address } [string] " f" [string] { test_contract_name } [string] " ) , ) [EOL] assert result . exit_code == [number] [EOL] [EOL] transaction_hash = result . output . splitlines ( ) [ - [number] ] [EOL] [EOL] assert is_hex ( transaction_hash ) [EOL] assert is_0x_prefixed ( transaction_hash ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_send_transaction_with_value_parameter ( runner , test_contract_address , test_contract_name ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] transaction_value = [number] [EOL] shared_command_string = ( f" [string] " f" [string] { test_contract_address } [string] { test_contract_name }" ) [EOL] [EOL] result_initial_balance_call = runner . invoke ( main , f" [string] { shared_command_string } [string] " ) [EOL] assert result_initial_balance_call . exit_code == [number] [EOL] assert result_initial_balance_call . output . strip ( ) == [string] [EOL] [EOL] result_pay_transaction = runner . invoke ( main , f" [string] { transaction_value } [string] { shared_command_string } [string] " ) [EOL] assert result_pay_transaction . exit_code == [number] [EOL] [EOL] result_final_balance_call = runner . invoke ( main , f" [string] { shared_command_string } [string] " ) [EOL] assert result_final_balance_call . exit_code == [number] [EOL] assert result_final_balance_call . output . strip ( ) == f"{ transaction_value }" [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_send_transaction_to_contract_with_array_address_arguments ( runner , compiled_contracts_path , test_contract_address , test_contract_name ) : [EOL] argument = f"{ test_contract_address } [string] { test_contract_address }" [EOL] result = runner . invoke ( main , ( f" [string] { compiled_contracts_path } [string] " f" [string] { test_contract_address } [string] " f" [string] { test_contract_name } [string] { argument }" ) , ) [EOL] assert result . exit_code == [number] [EOL] [EOL] transaction_hash = result . output . splitlines ( ) [ - [number] ] [EOL] [EOL] assert is_hex ( transaction_hash ) [EOL] assert is_0x_prefixed ( transaction_hash ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_send_transaction_to_contract_find_duplicated_function_by_argument_length ( runner , test_contract_address , test_contract_name ) : [EOL] result = runner . invoke ( main , ( f" [string] { test_contract_address } [string] " f" [string] { test_contract_name } [string] " ) , ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] transaction_hash = result . output . splitlines ( ) [ - [number] ] [EOL] [EOL] assert is_hex ( transaction_hash ) [EOL] assert is_0x_prefixed ( transaction_hash ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_send_transaction_to_contract_can_not_find_duplicated_function_same_argument_length ( runner , test_contract_address , test_contract_name ) : [EOL] result = runner . invoke ( main , ( f" [string] { test_contract_address } [string] " f" [string] { test_contract_name } [string] " ) , ) [EOL] [EOL] assert result . exit_code == [number] [EOL] assert type ( result . exception ) == ValueError [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_send_transaction_to_contract_non_existing_function ( runner , test_contract_address , test_contract_name ) : [EOL] result = runner . invoke ( main , ( f" [string] { test_contract_address } [string] " f" [string] { test_contract_name } [string] " ) , ) [EOL] [EOL] assert result . exit_code == [number] [EOL] assert type ( result . exception ) == ValueError [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_send_transaction_to_contract_wrong_address_format ( runner , test_contract_name ) : [EOL] result = runner . invoke ( main , ( f" [string] " f" [string] { test_contract_name } [string] " ) , ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_send_transaction_to_contract_insufficient_gas ( runner , test_contract_address , test_contract_name ) : [EOL] result = runner . invoke ( main , ( f" [string] { test_contract_address } [string] " f" [string] { test_contract_name } [string] " ) , ) [EOL] [EOL] assert result . exit_code == [number] [EOL] assert type ( result . exception ) == ValidationError [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_call_contract_function ( runner , test_contract_address , test_contract_name ) : [EOL] result = runner . invoke ( main , ( f" [string] { test_contract_address } [string] " f" [string] { test_contract_name } [string] " ) , ) [EOL] [EOL] assert result . exit_code == [number] [EOL] assert result . output . strip ( ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_call_contract_function_from_compiled_contracts ( runner , test_contract_address , test_contract_name , compiled_contracts_path ) : [EOL] result = runner . invoke ( main , ( f" [string] { compiled_contracts_path } [string] " f" [string] { test_contract_address } [string] " f" [string] { test_contract_name } [string] " ) , ) [EOL] [EOL] assert result . exit_code == [number] [EOL] assert result . output . strip ( ) == [string] [EOL] [EOL] [EOL] def test_generate_keystore_generate_new_private_key ( runner , keystore_file_save_path , key_password ) : [EOL] assert not keystore_file_save_path . exists ( ) [EOL] [EOL] result = runner . invoke ( main , ( f" [string] { keystore_file_save_path }" ) , input = f"{ key_password } [string] { key_password }" , ) [EOL] assert result . exit_code == [number] [EOL] assert keystore_file_save_path . exists ( ) [EOL] [EOL] [EOL] def test_generate_keystore_fail_existing_file ( runner , keystore_file_save_path , key_password ) : [EOL] keystore_file_save_path . ensure ( File = True ) [EOL] [EOL] assert keystore_file_save_path . exists ( ) [EOL] [EOL] result = runner . invoke ( main , ( f" [string] { keystore_file_save_path }" ) , input = f"{ key_password } [string] { key_password }" , ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [EOL] def test_generate_keystore_from_private_key ( runner , keystore_file_save_path , private_key , key_password ) : [EOL] result = runner . invoke ( main , ( f" [string] { keystore_file_save_path } [string] " f" [string] { private_key . to_hex ( ) }" ) , input = f"{ key_password } [string] { key_password }" , ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , [number] ) , ( [string] , [string] , [number] ) , ( [string] , [string] , [number] ) , ( [string] , [string] , [number] ) , ( [string] , [string] , [number] ) , ( [string] , [string] , [number] ) , ( [string] , [string] , [number] ) , ( [string] , [string] , [number] ) , ( [string] , [string] , [ [number] , [number] ] ) , ( [string] , [string] , [ [number] , [number] ] ) , ( [string] , [string] , [ [number] , [number] ] ) , ( [string] , [string] , [ [number] , [number] ] ) , ( [string] , [string] , [ [number] , [number] ] ) , ( [string] , [string] , [ [number] , [number] ] ) , ( [string] , [string] , [ [number] , [number] ] ) , ( [string] , [string] , [ [number] , [number] ] ) , ( [string] , [string] , [string] , ) , ( [string] , [string] , [ [string] , [string] , ] , ) , ( [string] , [string] , [string] ) , ] , ) def test_parse_argument_to_matching_type ( arg , type , expected_return ) : [EOL] assert parse_arg_to_matching_type ( arg , type ) == expected_return [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) ] ) def test_parse_argument_not_supported_yet ( arg , type ) : [EOL] with pytest . raises ( ValueError , match = [string] ) : [EOL] parse_arg_to_matching_type ( arg , type ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_send_eth ( runner , accounts ) : [EOL] result = runner . invoke ( main , ( f" [string] { accounts [ [number] ] }" ) ) [EOL] [EOL] assert result . exit_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0