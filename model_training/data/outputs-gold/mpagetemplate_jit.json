[comment] [EOL]	0 0
from typing import Any , Type , List [EOL] import template_jit [EOL] import ctypes [EOL] import typing [EOL] import ctypes [EOL] [EOL] from ctypes import pythonapi [EOL] [EOL] dllib = ctypes . CDLL ( None ) [EOL] dllib . dlsym . restype = ctypes . c_void_p [EOL] [EOL] [EOL] def pysym ( name ) : [EOL] [docstring] [EOL] result = dllib . dlsym ( pythonapi . _handle , name ) [EOL] if result is None : [EOL] raise RuntimeError ( f" [string] { name } [string] { result }" ) [EOL] return result [EOL] [EOL] [EOL] class CAPI : [EOL] [docstring] [EOL] _Py_Dealloc = pysym ( [string] ) [EOL] PyNumber_Add = pysym ( [string] ) [EOL] PyObject_RichCompare = pysym ( [string] ) [EOL] [EOL] [EOL] class JITFunction : [EOL] def __init__ ( self , num_args , encoded_func ) : [EOL] self . encoded_func = encoded_func [EOL] self . loaded_func = encoded_func . load ( ) [EOL] result_type = ctypes . c_uint64 [EOL] argument_types = [ ctypes . c_uint64 for _ in range ( num_args ) ] [EOL] self . function_type = ctypes . CFUNCTYPE ( result_type , * argument_types ) [EOL] self . function_pointer = self . function_type ( self . loaded_func . loader . code_address ) [EOL] [EOL] def __call__ ( self , * args ) : [EOL] addr = self . function_pointer ( * map ( id , args ) ) [EOL] box = ctypes . cast ( addr , ctypes . py_object ) [EOL] return box . value [EOL] [EOL] def format ( self ) : [EOL] return self . encoded_func . format ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ctypes.CDLL$ 0 0 0 0 0 0 0 0 $ctypes.CDLL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ctypes.CDLL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[template_jit.runtime.CAPI]$ 0 0 0 0 0 0 $typing.Type[template_jit.runtime.CAPI]$ 0 0 0 0 0 0 $typing.Type[template_jit.runtime.CAPI]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[ctypes.c_uint64]$ 0 0 0 0 0 $typing.List[typing.Type[ctypes.c_uint64]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[ctypes.c_uint64]$ 0 0 $typing.List[typing.Type[ctypes.c_uint64]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ctypes.py_object$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $ctypes.py_object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Type , Tuple , Set , Iterable , List , Iterator , Deque [EOL] import types [EOL] import builtins [EOL] import template_jit [EOL] import dis [EOL] import typing [EOL] import collections [EOL] import dis [EOL] import opcode [EOL] [EOL] from types import FunctionType [EOL] from typing import Iterable , Iterator , List , Tuple [EOL] [EOL] [EOL] Label = str [EOL] [EOL] [EOL] class Node : [EOL] pass [EOL] [EOL] [EOL] class EntryNode ( Node ) : [EOL] pass [EOL] [EOL] [EOL] class ExitNode ( Node ) : [EOL] pass [EOL] [EOL] [EOL] class BasicBlock ( Node ) : [EOL] def __init__ ( self , label , instructions ) : [EOL] if len ( instructions ) == [number] : [EOL] raise ValueError ( [string] ) [EOL] self . label = label [EOL] self . instructions = instructions [EOL] self . head = instructions [ [number] ] [EOL] self . terminator = instructions [ - [number] ] [EOL] [EOL] def __str__ ( self ) : [EOL] lines = [ f'{ self . label } [string] ' , ] [EOL] for instr in self . instructions : [EOL] if instr . arg is None : [EOL] line = [string] % ( instr . opname ) [EOL] elif instr . arg == instr . argval : [EOL] line = [string] % ( instr . opname , instr . arg ) [EOL] else : [EOL] line = [string] % ( instr . opname , instr . arg , instr . argval ) [EOL] line = line . rstrip ( ) [EOL] lines . append ( line ) [EOL] return [string] . join ( lines ) [EOL] [EOL] [EOL] class CFGIterator : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cfg ) : [EOL] self . cfg = cfg [EOL] self . queue = collections . deque ( [ cfg . entry_node ] ) [EOL] self . visited = set ( ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return self [EOL] [EOL] def __next__ ( self ) : [EOL] while self . queue : [EOL] node = self . queue . popleft ( ) [EOL] if node in self . visited : [EOL] continue [EOL] succs = self . cfg . get_successors ( node ) [EOL] self . visited . add ( node ) [EOL] if isinstance ( node , BasicBlock ) : [EOL] terminator = node . terminator [EOL] if terminator . opcode in CONDITIONAL_BRANCH_OPCODES : [EOL] true_block = self . cfg . blocks [ terminator . true_branch ] [EOL] false_block = self . cfg . blocks [ terminator . false_branch ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] succs = false_block , true_block [EOL] self . queue . extendleft ( succs ) [EOL] else : [EOL] self . queue . extendleft ( succs ) [EOL] continue [EOL] return node [EOL] raise StopIteration [EOL] [EOL] [EOL] def labels ( nodes ) : [EOL] labels = [ ] [EOL] for node in nodes : [EOL] if isinstance ( node , BasicBlock ) : [EOL] labels . append ( node . label ) [EOL] else : [EOL] labels . append ( node . __class__ . __name__ ) [EOL] return labels [EOL] [EOL] [EOL] class WorkStack : [EOL] def __init__ ( self ) : [EOL] self . stack = [ ] [EOL] self . index = set ( ) [EOL] [EOL] def append ( self , node ) : [EOL] if node in self . index : [EOL] return [EOL] self . stack . append ( node ) [EOL] self . index . add ( node ) [EOL] [EOL] def extend ( self , nodes ) : [EOL] for node in nodes : [EOL] self . append ( node ) [EOL] [EOL] def has_node ( self , node ) : [EOL] return node in self . index [EOL] [EOL] def pop ( self ) : [EOL] node = self . stack . pop ( ) [EOL] self . index . remove ( node ) [EOL] return node [EOL] [EOL] def is_empty ( self ) : [EOL] return len ( self . stack ) == [number] [EOL] [EOL] [EOL] class PostOrderCFGIterator : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cfg ) : [EOL] self . cfg = cfg [EOL] self . stack = WorkStack ( ) [EOL] self . stack . append ( cfg . entry_node ) [EOL] self . visited = set ( ) [EOL] self . processed = set ( ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return self [EOL] [EOL] def __next__ ( self ) : [EOL] while not self . stack . is_empty ( ) : [EOL] node = self . stack . pop ( ) [EOL] if node in self . visited : [EOL] continue [EOL] succs = self . cfg . get_successors ( node ) [EOL] if not isinstance ( node , BasicBlock ) : [EOL] self . stack . extend ( succs ) [EOL] continue [EOL] if not succs or node in self . processed : [EOL] self . visited . add ( node ) [EOL] return node [EOL] self . stack . append ( node ) [EOL] self . stack . extend ( succs ) [EOL] self . processed . add ( node ) [EOL] raise StopIteration [EOL] [EOL] [EOL] class ControlFlowGraph : [EOL] def __init__ ( self ) : [EOL] self . entry_node = EntryNode ( ) [EOL] self . exit_node = ExitNode ( ) [EOL] [comment] [EOL] self . edges = { self . entry_node : set ( ) , self . exit_node : set ( ) , } [EOL] self . blocks = { } [EOL] [EOL] def add_block ( self , block ) : [EOL] self . edges [ block ] = set ( ) [EOL] self . blocks [ block . label ] = block [EOL] [EOL] def add_edge ( self , src , dst ) : [EOL] self . edges [ src ] . add ( dst ) [EOL] [EOL] def get_successors ( self , node ) : [EOL] return self . edges . get ( node , set ( ) ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return CFGIterator ( self ) [EOL] [EOL] def __str__ ( self ) : [EOL] output = [ [string] ] [EOL] blocks = [ node for node in self if isinstance ( node , BasicBlock ) ] [EOL] blocks = sorted ( blocks , key = lambda b : b . label ) [EOL] for block in blocks : [EOL] output . append ( str ( block ) ) [EOL] return [string] . join ( output ) [EOL] [EOL] [EOL] def build_initial_cfg ( blocks ) : [EOL] [docstring] [EOL] cfg = ControlFlowGraph ( ) [EOL] if not blocks : [EOL] return cfg [EOL] cfg . add_edge ( cfg . entry_node , blocks [ [number] ] ) [EOL] block_index = { block . label : block for block in blocks } [EOL] for i , block in enumerate ( blocks ) : [EOL] cfg . add_block ( block ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] terminator = block . terminator [EOL] if terminator . opname == [string] : [EOL] cfg . add_edge ( block , cfg . exit_node ) [EOL] elif terminator . opcode in CONDITIONAL_BRANCH_OPCODES : [EOL] cfg . add_edge ( block , block_index [ terminator . true_branch ] ) [EOL] cfg . add_edge ( block , block_index [ terminator . false_branch ] ) [EOL] else : [EOL] cfg . add_edge ( block , blocks [ i + [number] ] ) [EOL] return cfg [EOL] [EOL] [EOL] DIRECT_BRANCH_OPCODES = { opcode . opmap [ [string] ] , } [EOL] [EOL] [EOL] CONDITIONAL_BRANCH_OPCODES = { opcode . opmap [ [string] ] , } [EOL] [EOL] [EOL] BRANCH_OPCODES = DIRECT_BRANCH_OPCODES | CONDITIONAL_BRANCH_OPCODES [EOL] [EOL] [EOL] [comment] [EOL] ABSOLUTE_BRANCH_OPCODES = { opcode . opmap [ [string] ] , } [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] RELATIVE_BRANCH_OPCODES = { } [EOL] [EOL] [EOL] INSTRUCTION_SIZE_B = [number] [EOL] [EOL] [EOL] def compute_block_boundaries ( func ) : [EOL] [docstring] [EOL] code_len = len ( func . __code__ . co_code ) [EOL] if code_len == [number] : [EOL] return [ ] [EOL] block_starts = { [number] } [EOL] last_offset = code_len [EOL] for instr in dis . get_instructions ( func ) : [EOL] opcode = instr . opcode [EOL] next_instr_offset = instr . offset + INSTRUCTION_SIZE_B [EOL] if opcode in BRANCH_OPCODES and next_instr_offset < last_offset : [EOL] block_starts . add ( next_instr_offset ) [EOL] if opcode in RELATIVE_BRANCH_OPCODES : [EOL] block_starts . add ( next_instr_offset + instr . argument ) [EOL] elif opcode in ABSOLUTE_BRANCH_OPCODES : [EOL] block_starts . add ( instr . argval ) [EOL] sorted_block_starts = sorted ( block_starts ) [EOL] sorted_block_starts . append ( code_len ) [EOL] boundaries = [ ] [EOL] for i in range ( [number] , len ( sorted_block_starts ) - [number] ) : [EOL] boundaries . append ( ( sorted_block_starts [ i ] , sorted_block_starts [ i + [number] ] ) ) [EOL] return boundaries [EOL] [EOL] [EOL] def make_branch_symbolic ( instr , labels ) : [EOL] if instr . opcode == opcode . opmap [ [string] ] : [EOL] instr . true_branch = labels [ instr . offset + INSTRUCTION_SIZE_B ] [EOL] instr . false_branch = labels [ instr . arg ] [EOL] [EOL] [EOL] def build_cfg ( func ) : [EOL] [docstring] [EOL] [comment] [EOL] labels = { } [EOL] block_boundaries = compute_block_boundaries ( func ) [EOL] for i , interval in enumerate ( block_boundaries ) : [EOL] labels [ interval [ [number] ] ] = f' [string] { i }' [EOL] [comment] [EOL] blocks = [ ] [EOL] boundary_iter = iter ( block_boundaries ) [EOL] instrs = [ ] [EOL] boundary = next ( boundary_iter ) [EOL] for instr in dis . get_instructions ( func ) : [EOL] if instr . opcode in CONDITIONAL_BRANCH_OPCODES : [EOL] make_branch_symbolic ( instr , labels ) [EOL] if instr . offset < boundary [ [number] ] : [EOL] [comment] [EOL] instrs . append ( instr ) [EOL] else : [EOL] [comment] [EOL] block = BasicBlock ( labels [ boundary [ [number] ] ] , instrs ) [EOL] blocks . append ( block ) [EOL] instrs = [ instr ] [EOL] boundary = next ( boundary_iter ) [EOL] if instrs : [EOL] block = BasicBlock ( labels [ boundary [ [number] ] ] , instrs ) [EOL] blocks . append ( block ) [EOL] return build_initial_cfg ( blocks ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BasicBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $template_jit.cfg.Node$ 0 0 0 0 0 0 0 0 0 0 $template_jit.cfg.Node$ 0 0 0 0 0 0 0 0 $typing.Iterable[template_jit.cfg.Node]$ 0 0 0 0 0 0 0 $template_jit.cfg.Node$ 0 0 0 0 0 0 $template_jit.cfg.Node$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[template_jit.cfg.Node]$ 0 0 0 0 0 0 $typing.Iterable[template_jit.cfg.Node]$ 0 $template_jit.cfg.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 $template_jit.cfg.Node$ 0 0 0 $template_jit.cfg.Node$ 0 0 0 0 0 0 0 $template_jit.cfg.Node$ 0 0 0 0 0 0 0 0 $typing.Iterable[template_jit.cfg.Node]$ 0 0 0 0 0 0 0 0 $template_jit.cfg.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $template_jit.cfg.EntryNode$ 0 0 0 0 0 0 0 $template_jit.cfg.ExitNode$ 0 0 0 0 0 0 0 0 0 $typing.Dict[Node,typing.Set[Node]]$ 0 0 0 0 $template_jit.cfg.EntryNode$ 0 0 0 0 0 0 0 $template_jit.cfg.ExitNode$ 0 0 0 0 0 0 0 0 0 $typing.Dict[Label,BasicBlock]$ 0 0 0 0 0 0 $None$ 0 0 0 $BasicBlock$ 0 0 0 0 0 0 0 $BasicBlock$ 0 0 0 0 0 0 0 0 0 0 $BasicBlock$ 0 0 0 0 $BasicBlock$ 0 0 0 $None$ 0 0 0 $Node$ 0 $Node$ 0 0 0 0 0 0 0 $Node$ 0 0 0 0 $Node$ 0 0 0 0 $typing.Iterable[Node]$ 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 $typing.Iterator[BasicBlock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[template_jit.cfg.BasicBlock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[template_jit.cfg.BasicBlock]$ 0 0 0 $typing.List[template_jit.cfg.BasicBlock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[template_jit.cfg.BasicBlock]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import template_jit [EOL] import typing [EOL] import ctypes [EOL] [EOL] from peachpy import * [EOL] from peachpy . x86_64 import * [EOL] from template_jit . compiler import Compiler [EOL] from template_jit . runtime import CAPI , JITFunction [EOL] [EOL] [EOL] def test_peachpy_works ( ) : [EOL] with Function ( [string] , tuple ( ) , int64_t ) as jit_func : [EOL] MOV ( rax , [number] ) [EOL] RETURN ( rax ) [EOL] meaning_of_life = jit_func . finalize ( abi . detect ( ) ) . encode ( ) . load ( ) [EOL] assert meaning_of_life ( ) == [number] [EOL] [EOL] [EOL] def test_simple_function ( ) : [EOL] [docstring] [EOL] def func ( ) : [EOL] return [number] [EOL] jitfunc = Compiler ( ) . compile ( func ) [EOL] assert jitfunc ( ) == [number] [EOL] [EOL] [EOL] def test_local_variables ( ) : [EOL] [docstring] [EOL] def identity ( x ) : [EOL] return x [EOL] jit_identity = Compiler ( ) . compile ( identity ) [EOL] arg = [string] [EOL] assert jit_identity ( arg ) is arg [EOL] [EOL] [EOL] def test_binary_add ( ) : [EOL] [docstring] [EOL] def add ( a , b ) : [EOL] return a + b [EOL] jit_add = Compiler ( ) . compile ( add ) [EOL] assert jit_add ( [number] , [number] ) == [number] [EOL] assert jit_add ( [string] , [string] ) == [string] [EOL] [EOL] [EOL] def test_compare_op ( ) : [EOL] [docstring] [EOL] def identical ( a , b ) : [EOL] return a is b [EOL] jit_gt = Compiler ( ) . compile ( identical ) [EOL] x = [number] [EOL] y = [number] [EOL] assert jit_gt ( x , y ) is False [EOL] assert jit_gt ( x , x ) is True [EOL] [EOL] [EOL] def test_control_flow ( ) : [EOL] [docstring] [EOL] def identical ( a , b ) : [EOL] if a is b : [EOL] return True [EOL] return False [EOL] jit_gt = Compiler ( ) . compile ( identical ) [EOL] x = [number] [EOL] y = [number] [EOL] assert jit_gt ( x , y ) is False [EOL] assert jit_gt ( x , x ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple [EOL] import template_jit [EOL] import typing [EOL] import pytest [EOL] [EOL] from template_jit import cfg [EOL] [EOL] [EOL] def max ( a , b ) : [EOL] if a > b : [EOL] return a [EOL] return b [EOL] [EOL] [EOL] def add ( a , b ) : [EOL] return a + b [EOL] [EOL] [EOL] def test_compute_block_boundaries ( ) : [EOL] boundaries = cfg . compute_block_boundaries ( max ) [EOL] assert boundaries == [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( max , [string] ) , ( add , [string] ) , ] ) def test_build_cfg ( func , expected ) : [EOL] g = cfg . build_cfg ( func ) [EOL] assert str ( g ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0