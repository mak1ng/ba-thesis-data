[comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] import os [EOL] import re [EOL] [EOL] from setuptools import setup [EOL] [EOL] [EOL] def get_version ( package ) : [EOL] [docstring] [EOL] with open ( os . path . join ( package , [string] ) ) as f : [EOL] return re . search ( [string] , f . read ( ) ) . group ( [number] ) [EOL] [EOL] [EOL] def get_package_data ( package ) : [EOL] [docstring] [EOL] walk = [ ( dirpath . replace ( package + os . sep , [string] , [number] ) , filenames ) for dirpath , dirnames , filenames in os . walk ( package ) if not os . path . exists ( os . path . join ( dirpath , [string] ) ) ] [EOL] [EOL] filepaths = [ ] [EOL] for base , filenames in walk : [EOL] filepaths . extend ( [ os . path . join ( base , filename ) for filename in filenames ] ) [EOL] return { package : filepaths } [EOL] [EOL] [EOL] def get_long_description ( ) : [EOL] [docstring] [EOL] with open ( [string] , encoding = [string] ) as f : [EOL] return f . read ( ) [EOL] [EOL] [EOL] def get_packages ( package ) : [EOL] [docstring] [EOL] return [ dirpath for dirpath , dirnames , filenames in os . walk ( package ) if os . path . exists ( os . path . join ( dirpath , [string] ) ) ] [EOL] [EOL] [EOL] name = [string] [EOL] package_name = [string] [EOL] [EOL] setup ( name = name , python_requires = [string] , version = get_version ( package_name ) , url = [string] , license = [string] , description = [string] , long_description = get_long_description ( ) , long_description_content_type = [string] , author = [string] , author_efile = [string] , packages = get_packages ( package_name ) , package_data = get_package_data ( package_name ) , install_requires = [ [string] , [string] , [string] , ] , extras_require = { [string] : [ [string] , [string] , ] , [string] : [ [string] , ] , [string] : [ [string] , ] } , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def test_test ( ) : [EOL] assert [number] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0
	0
import uvicorn [EOL] [EOL] if __name__ == [string] : [EOL] uvicorn . run ( [string] , host = [string] , port = [number] , debug = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , List [EOL] import builtins [EOL] import typing [EOL] import starlette_files [EOL] import example [EOL] import jinja2 [EOL] import os [EOL] import uvicorn [EOL] import sqlalchemy as sa [EOL] import typing [EOL] [EOL] from sqlalchemy import orm [EOL] from starlette . applications import Starlette [EOL] from starlette . endpoints import HTTPEndpoint [EOL] from starlette . staticfiles import StaticFiles [EOL] from starlette_core . database import Base , Database , Session [EOL] from starlette_core . templating import Jinja2Templates [EOL] [EOL] from starlette_files . constants import MB [EOL] from starlette_files . fields import ImageAttachment , ImageRenditionAttachment [EOL] from starlette_files . storages import FileSystemStorage [EOL] [EOL] root_directory = [string] [EOL] dir_path = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] templates_path = os . path . join ( dir_path , [string] ) [EOL] [EOL] [EOL] class MyImage ( ImageAttachment ) : [EOL] storage = FileSystemStorage ( root_directory ) [EOL] directory = [string] [EOL] allowed_content_types = [ [string] , [string] ] [EOL] max_length = MB * [number] [EOL] [EOL] [EOL] class MyImageRendition ( ImageRenditionAttachment ) : [EOL] storage = FileSystemStorage ( root_directory ) [EOL] directory = [string] [EOL] [EOL] [EOL] class MyImageModel ( Base ) : [EOL] file = sa . Column ( MyImage . as_mutable ( sa . JSON ) ) [EOL] renditions = orm . relationship ( [string] ) [EOL] [EOL] def get_rendition ( self , filter_specs ) : [EOL] filter_specs_str = [string] . join ( filter_specs ) [EOL] [EOL] rendition = MyImageRenditionModel . query . filter ( MyImageRenditionModel . image_id == self . id , MyImageRenditionModel . filter_spec == filter_specs_str , MyImageRenditionModel . file [ [string] ] == self . file . cache_key , ) . one_or_none ( ) [EOL] [EOL] if rendition : [EOL] return rendition [EOL] [EOL] rendition = MyImageRenditionModel ( image_id = self . id , file = MyImageRendition . create_from ( self . file , filter_specs ) , filter_spec = filter_specs_str , ) [EOL] [EOL] session = sa . inspect ( self ) . session [EOL] session . add ( rendition ) [EOL] session . commit ( ) [EOL] [EOL] return rendition [EOL] [EOL] [EOL] class MyImageRenditionModel ( Base ) : [EOL] file = sa . Column ( MyImageRendition . as_mutable ( sa . JSON ) ) [EOL] image_id = sa . Column ( sa . Integer , sa . ForeignKey ( [string] ) , nullable = False ) [EOL] image = orm . relationship ( [string] ) [EOL] filter_spec = sa . Column ( sa . Text ) [EOL] [EOL] [EOL] db = Database ( [string] ) [EOL] db . create_all ( ) [EOL] [EOL] app = Starlette ( debug = True ) [EOL] app . mount ( [string] , StaticFiles ( directory = root_directory , check_dir = False ) , name = [string] ) [EOL] [EOL] templates = Jinja2Templates ( loader = jinja2 . FileSystemLoader ( templates_path ) ) [EOL] [EOL] @ app . route ( [string] ) class Homepage ( HTTPEndpoint ) : [EOL] async def get ( self , request ) : [EOL] return templates . TemplateResponse ( [string] , { [string] : request } ) [EOL] [EOL] async def post ( self , request ) : [EOL] form = await request . form ( ) [EOL] [EOL] saved_file = MyImage . create_from ( form [ [string] ] . file , form [ [string] ] . filename ) [EOL] image = MyImageModel ( file = saved_file ) [EOL] image . save ( ) [EOL] [EOL] return templates . TemplateResponse ( [string] , { [string] : request , [string] : image } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[example.main.MyImageRenditionModel]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[example.main.MyImageRenditionModel]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[example.main.MyImageRenditionModel]$ 0 0 0 0 0 0 0 0 $typing.Type[example.main.MyImageRenditionModel]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $starlette_files.fields.ImageAttachment$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $example.main.MyImageModel$ 0 0 0 0 0 $starlette_files.fields.ImageAttachment$ 0 0 $example.main.MyImageModel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $example.main.MyImageModel$ 0 0 0
import builtins [EOL] class ContentTypeValidationError ( Exception ) : [EOL] def __init__ ( self , content_type = None , valid_content_types = None ) : [EOL] [EOL] if content_type is None : [EOL] message = [string] [EOL] else : [EOL] message = [string] % content_type [EOL] [EOL] if valid_content_types : [EOL] message += [string] % [string] . join ( valid_content_types ) [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class InvalidFilterSpecError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidImageOperationError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class MaximumAllowedFileLengthError ( Exception ) : [EOL] def __init__ ( self , max_length ) : [EOL] super ( ) . __init__ ( [string] % max_length ) [EOL] [EOL] [EOL] class MissingDependencyError ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Union , IO , Optional , List , Any , Type [EOL] import image [EOL] import builtins [EOL] import typing [EOL] import starlette_files [EOL] import hashlib [EOL] import io [EOL] import time [EOL] import typing [EOL] import uuid [EOL] [EOL] from sqlalchemy . ext . mutable import MutableDict [EOL] [EOL] from . constants import MB [EOL] from . exceptions import ( ContentTypeValidationError , MaximumAllowedFileLengthError , MissingDependencyError , ) [EOL] from . helpers import get_length [EOL] from . image . filter import ImageFilter [EOL] from . image . rect import Rect [EOL] from . mimetypes import guess_extension , magic_mime_from_buffer [EOL] from . storages import Storage [EOL] [EOL] try : [EOL] from PIL import Image [EOL] except ImportError : [comment] [EOL] Image = None [EOL] [EOL] [EOL] class FileAttachment ( MutableDict ) : [EOL] [EOL] storage = ... [EOL] directory = [string] [EOL] allowed_content_types = [ ] [EOL] max_length = MB * [number] [EOL] [EOL] @ staticmethod def _guess_content_type ( file ) : [EOL] content = file . read ( [number] ) [EOL] [EOL] if isinstance ( content , str ) : [EOL] content = str . encode ( content ) [EOL] [EOL] file . seek ( [number] ) [EOL] [EOL] return magic_mime_from_buffer ( content ) [EOL] [EOL] def set_defaults ( self , file , original_filename ) : [EOL] unique_name = str ( uuid . uuid4 ( ) ) [EOL] [EOL] self . original_filename = original_filename [EOL] self . uploaded_on = int ( time . time ( ) ) [EOL] [EOL] [comment] [EOL] content_type = self . _guess_content_type ( file ) [EOL] extension = guess_extension ( content_type ) [EOL] [EOL] self . content_type = content_type [EOL] self . extension = extension [EOL] self . file_size = get_length ( file ) [EOL] self . saved_filename = f"{ unique_name }{ extension }" [EOL] [EOL] def validate ( self ) : [EOL] if self . content_type not in self . allowed_content_types : [EOL] raise ContentTypeValidationError ( self . content_type , self . allowed_content_types ) [EOL] if self . file_size > self . max_length : [EOL] raise MaximumAllowedFileLengthError ( self . max_length ) [EOL] [EOL] @ classmethod def create_from ( cls , file , original_filename ) : [EOL] instance = cls ( ) [EOL] [EOL] instance . set_defaults ( file , original_filename ) [EOL] instance . validate ( ) [EOL] [EOL] instance . storage . put ( instance . path , file ) [EOL] [EOL] return instance [EOL] [EOL] @ property def original_filename ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ original_filename . setter def original_filename ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def saved_filename ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ saved_filename . setter def saved_filename ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def uploaded_on ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ uploaded_on . setter def uploaded_on ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def file_size ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ file_size . setter def file_size ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def content_type ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ content_type . setter def content_type ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def extension ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ extension . setter def extension ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def path ( self ) : [EOL] return f"{ self . directory } [string] { self . saved_filename }" [EOL] [EOL] @ property def locate ( self ) : [EOL] return self . storage . locate ( self . path ) [EOL] [EOL] @ property def open ( self ) : [EOL] return self . storage . open ( self . path ) [EOL] [EOL] [EOL] class ImageAttachment ( FileAttachment ) : [EOL] [EOL] directory = [string] [EOL] allowed_content_types = [ [string] , [string] ] [EOL] [EOL] @ classmethod def create_from ( cls , file , original_filename ) : [EOL] if Image is None : [EOL] raise MissingDependencyError ( [string] ) [EOL] [EOL] instance = cls ( ) [EOL] [EOL] instance . set_defaults ( file , original_filename ) [EOL] instance . validate ( ) [EOL] [EOL] with Image . open ( file ) as image : [EOL] instance . width , instance . height = image . size [EOL] [EOL] instance . storage . put ( instance . path , file ) [EOL] [EOL] return instance [EOL] [EOL] def get_focal_point ( self ) : [EOL] if None in [ self . focal_point_x , self . focal_point_y , self . focal_point_width , self . focal_point_height , ] : [EOL] return None [EOL] [EOL] return Rect ( self . focal_point_x , self . focal_point_y , self . focal_point_x + self . focal_point_width , self . focal_point_y + self . focal_point_height , ) [EOL] [EOL] @ property def width ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ width . setter def width ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def height ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ height . setter def height ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def focal_point_x ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ focal_point_x . setter def focal_point_x ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def focal_point_y ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ focal_point_y . setter def focal_point_y ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def focal_point_width ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ focal_point_width . setter def focal_point_width ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def focal_point_height ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ focal_point_height . setter def focal_point_height ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def cache_key ( self ) : [EOL] [docstring] [EOL] [EOL] vary_fields = [ str ( self . file_size ) , str ( self . focal_point_x ) , str ( self . focal_point_y ) , str ( self . focal_point_width ) , str ( self . focal_point_height ) , ] [EOL] vary_string = [string] . join ( vary_fields ) [EOL] return hashlib . sha1 ( vary_string . encode ( [string] ) ) . hexdigest ( ) [ : [number] ] [EOL] [EOL] [EOL] class ImageRenditionAttachment ( FileAttachment ) : [EOL] directory = [string] [EOL] focal_point = None [EOL] [EOL] @ classmethod def create_from ( cls , attachment , filter_specs = [ ] ) : [EOL] instance = cls ( ) [EOL] [EOL] instance . focal_point = attachment . get_focal_point ( ) [EOL] [EOL] filter_cls = ImageFilter ( specs = filter_specs ) [EOL] [EOL] with attachment . open as original_file : [EOL] with Image . open ( original_file ) as original_image : [EOL] unique_name = str ( uuid . uuid4 ( ) ) [EOL] generated_bytes = filter_cls . run ( instance , original_image , io . BytesIO ( ) ) [EOL] instance . cache_key = attachment . cache_key [EOL] instance . file_size = get_length ( generated_bytes ) [EOL] [EOL] with Image . open ( generated_bytes ) as generated_image : [EOL] image_format = generated_image . format . lower ( ) [EOL] content_type = f" [string] { image_format }" [EOL] extension = guess_extension ( content_type ) [EOL] [EOL] instance . content_type = content_type [EOL] instance . extension = extension [EOL] instance . saved_filename = f"{ unique_name }{ extension }" [EOL] instance . width , instance . height = generated_image . size [EOL] [EOL] instance . storage . put ( instance . path , generated_bytes ) [EOL] [EOL] return instance [EOL] [EOL] @ property def width ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ width . setter def width ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def height ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ height . setter def height ( self , value ) : [EOL] self [ [string] ] = value [EOL] [EOL] @ property def cache_key ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] @ cache_key . setter def cache_key ( self , value ) : [EOL] self [ [string] ] = value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $storages.Storage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ImageRenditionAttachment"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0
KB = [number] [EOL] MB = [number] * KB [EOL]	$builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] import mimetypes as mdb [EOL] import typing [EOL] [EOL] import magic [EOL] [EOL] [EOL] def magic_mime_from_buffer ( buffer ) : [EOL] return magic . from_buffer ( buffer , mime = True ) [EOL] [EOL] [EOL] def guess_extension ( mimetype ) : [EOL] [docstring] [EOL] [EOL] if mimetype == [string] : [EOL] return [string] [EOL] return mdb . guess_extension ( mimetype ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , IO [EOL] import io [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] from io import BytesIO [EOL] [EOL] from . constants import KB [EOL] [EOL] [EOL] def copy_stream ( source , target , * , chunk_size = [number] * KB ) : [EOL] length = [number] [EOL] while [number] : [EOL] buf = source . read ( chunk_size ) [EOL] if not buf : [EOL] break [EOL] length += len ( buf ) [EOL] target . write ( buf ) [EOL] return length [EOL] [EOL] [EOL] def get_length ( source ) : [EOL] buffer = BytesIO ( ) [EOL] return copy_stream ( source , buffer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Tuple , List , Any , Type [EOL] import builtins [EOL] import typing [EOL] import starlette_files [EOL] import typing [EOL] [EOL] from . . exceptions import InvalidImageOperationError [EOL] from . import operations , utils [EOL] [EOL] [EOL] class ImageFilter : [EOL] [EOL] _registered_operations = None [EOL] [EOL] def __init__ ( self , specs ) : [EOL] self . specs = specs [EOL] [EOL] @ property def operations ( self ) : [EOL] [comment] [EOL] self . _search_for_operations ( ) [EOL] [EOL] ops = [ ] [EOL] [EOL] [comment] [EOL] for op_spec in self . specs : [EOL] op_spec_parts = op_spec . split ( [string] ) [EOL] [EOL] if op_spec_parts [ [number] ] not in self . _registered_operations : [EOL] raise InvalidImageOperationError ( [string] % op_spec_parts [ [number] ] ) [EOL] [EOL] op_class = self . _registered_operations [ op_spec_parts [ [number] ] ] [EOL] ops . append ( op_class ( * op_spec_parts ) ) [EOL] [EOL] return ops [EOL] [EOL] def run ( self , attachment , image , output ) : [EOL] original_format = image . format [EOL] [EOL] env = { [string] : original_format } [EOL] [EOL] for operation in self . operations : [EOL] image = operation . run ( image , attachment , env ) or image [EOL] [EOL] if [string] in env : [EOL] output_format = env [ [string] ] . upper ( ) [EOL] else : [EOL] output_format = original_format [EOL] [EOL] if output_format == [string] : [EOL] image = utils . to_rgb ( image ) [EOL] image . save ( output , output_format , quality = [number] , progressive = True , optimize = True ) [EOL] [EOL] elif output_format == [string] : [EOL] image . save ( output , output_format , optimize = True ) [EOL] [EOL] return output [EOL] [EOL] @ classmethod def _search_for_operations ( cls ) : [EOL] if cls . _registered_operations is not None : [EOL] return [EOL] [EOL] registered = [ ( [string] , operations . DoNothingOperation ) , ( [string] , operations . WidthHeightOperation ) , ( [string] , operations . WidthHeightOperation ) , ( [string] , operations . MinMaxOperation ) , ( [string] , operations . MinMaxOperation ) , ( [string] , operations . FillOperation ) , ( [string] , operations . CropOperation ) , ( [string] , operations . ScaleOperation ) , ( [string] , operations . FormatOperation ) , ] [EOL] [EOL] cls . _registered_operations = dict ( registered ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[typing.Union[starlette_files.image.operations.crop.CropOperation,starlette_files.image.operations.do_nothing.DoNothingOperation,starlette_files.image.operations.fill.FillOperation,starlette_files.image.operations.format.FormatOperation,starlette_files.image.operations.min_max.MinMaxOperation,starlette_files.image.operations.scale.ScaleOperation,starlette_files.image.operations.width_height.WidthHeightOperation]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[typing.Union[starlette_files.image.operations.crop.CropOperation,starlette_files.image.operations.do_nothing.DoNothingOperation,starlette_files.image.operations.fill.FillOperation,starlette_files.image.operations.format.FormatOperation,starlette_files.image.operations.min_max.MinMaxOperation,starlette_files.image.operations.scale.ScaleOperation,starlette_files.image.operations.width_height.WidthHeightOperation]]]]$ 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import starlette_files [EOL] import math [EOL] [EOL] [EOL] class Vector : [EOL] def __init__ ( self , x , y ) : [EOL] self . x = x [EOL] self . y = y [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( ( self . x , self . y ) ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] return ( self . x , self . y ) [ key ] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return tuple ( self ) == tuple ( other ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . x , self . y ) [EOL] [EOL] [EOL] class Rect : [EOL] def __init__ ( self , left , top , right , bottom ) : [EOL] self . left = left [EOL] self . top = top [EOL] self . right = right [EOL] self . bottom = bottom [EOL] [EOL] def _get_size ( self ) : [EOL] return Vector ( self . right - self . left , self . bottom - self . top ) [EOL] [EOL] def _set_size ( self , new_size ) : [EOL] centroid = self . centroid [EOL] self . left = centroid [ [number] ] - new_size [ [number] ] / [number] [EOL] self . right = centroid [ [number] ] + new_size [ [number] ] / [number] [EOL] self . top = centroid [ [number] ] - new_size [ [number] ] / [number] [EOL] self . bottom = centroid [ [number] ] + new_size [ [number] ] / [number] [EOL] [EOL] size = property ( _get_size , _set_size ) [EOL] [EOL] @ property def width ( self ) : [EOL] return self . size . x [EOL] [EOL] @ property def height ( self ) : [EOL] return self . size . y [EOL] [EOL] def _get_centroid ( self ) : [EOL] return Vector ( ( self . left + self . right ) / [number] , ( self . top + self . bottom ) / [number] ) [EOL] [EOL] def _set_centroid ( self , new_centroid ) : [EOL] size = self . size [EOL] self . left = new_centroid [ [number] ] - size [ [number] ] / [number] [EOL] self . right = new_centroid [ [number] ] + size [ [number] ] / [number] [EOL] self . top = new_centroid [ [number] ] - size [ [number] ] / [number] [EOL] self . bottom = new_centroid [ [number] ] + size [ [number] ] / [number] [EOL] [EOL] centroid = property ( _get_centroid , _set_centroid ) [EOL] [EOL] @ property def x ( self ) : [EOL] return self . centroid . x [EOL] [EOL] @ property def y ( self ) : [EOL] return self . centroid . y [EOL] [EOL] @ property def centroid_x ( self ) : [EOL] [comment] [EOL] return self . centroid . x [EOL] [EOL] @ property def centroid_y ( self ) : [EOL] [comment] [EOL] return self . centroid . y [EOL] [EOL] def as_tuple ( self ) : [EOL] [comment] [EOL] [comment] [EOL] return self . left , self . top , self . right , self . bottom [EOL] [EOL] def clone ( self ) : [EOL] return type ( self ) ( self . left , self . top , self . right , self . bottom ) [EOL] [EOL] def round ( self ) : [EOL] [docstring] [EOL] clone = self . clone ( ) [EOL] [EOL] [comment] [EOL] clone . left = int ( math . floor ( clone . left ) ) [EOL] clone . top = int ( math . floor ( clone . top ) ) [EOL] [EOL] [comment] [EOL] clone . right = int ( math . ceil ( clone . right ) ) [EOL] clone . bottom = int ( math . ceil ( clone . bottom ) ) [EOL] [EOL] return clone [EOL] [EOL] def move_to_clamp ( self , other ) : [EOL] [docstring] [EOL] other = Rect ( * other ) [EOL] clone = self . clone ( ) [EOL] [EOL] if clone . left < other . left : [EOL] clone . right -= clone . left - other . left [EOL] clone . left = other . left [EOL] [EOL] if clone . top < other . top : [EOL] clone . bottom -= clone . top - other . top [EOL] clone . top = other . top [EOL] [EOL] if clone . right > other . right : [EOL] clone . left -= clone . right - other . right [EOL] clone . right = other . right [EOL] [EOL] if clone . bottom > other . bottom : [EOL] clone . top -= clone . bottom - other . bottom [EOL] clone . bottom = other . bottom [EOL] [EOL] return clone [EOL] [EOL] def move_to_cover ( self , other ) : [EOL] [docstring] [EOL] other = Rect ( * other ) [EOL] clone = self . clone ( ) [EOL] [EOL] if clone . left > other . left : [EOL] clone . right -= clone . left - other . left [EOL] clone . left = other . left [EOL] [EOL] if clone . top > other . top : [EOL] clone . bottom -= clone . top - other . top [EOL] clone . top = other . top [EOL] [EOL] if clone . right < other . right : [EOL] clone . left += other . right - clone . right [EOL] clone . right = other . right [EOL] [EOL] if clone . bottom < other . bottom : [EOL] clone . top += other . bottom - clone . bottom [EOL] clone . bottom = other . bottom [EOL] [EOL] return clone [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( ( self . left , self . top , self . right , self . bottom ) ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] return ( self . left , self . top , self . right , self . bottom ) [ key ] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return tuple ( self ) == tuple ( other ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . left , self . top , self . right , self . bottom , ) [EOL] [EOL] @ classmethod def from_point ( cls , x , y , width , height ) : [EOL] return cls ( x - width / [number] , y - height / [number] , x + width / [number] , y + height / [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.property$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.property$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 $starlette_files.image.rect.Rect$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 $starlette_files.image.rect.Rect$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $starlette_files.image.rect.Rect$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] try : [EOL] from PIL import Image [EOL] except ImportError : [comment] [EOL] Image = None [EOL] [EOL] [EOL] def has_alpha ( image ) : [EOL] return image . mode in ( [string] , [string] ) or ( image . mode == [string] and [string] in image . info ) [EOL] [EOL] [EOL] def to_rgb ( image ) : [EOL] [comment] [EOL] if image . mode in [ [string] , [string] ] : [EOL] image = image . convert ( [string] ) if has_alpha ( image ) else image . convert ( [string] ) [EOL] return image [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Image$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from . . utils import to_rgb [EOL] from . base import Operation [EOL] [EOL] try : [EOL] from PIL import Image [EOL] except ImportError : [comment] [EOL] Image = None [EOL] [EOL] [EOL] class WidthHeightOperation ( Operation ) : [EOL] def construct ( self , size ) : [EOL] self . size = int ( size ) [EOL] [EOL] def run ( self , pillow , attachment , env ) : [EOL] image_width , image_height = pillow . size [EOL] [EOL] if self . method == [string] : [EOL] if image_width <= self . size : [EOL] return [EOL] [EOL] scale = self . size / image_width [EOL] [EOL] width = self . size [EOL] height = int ( image_height * scale ) [EOL] [EOL] elif self . method == [string] : [EOL] if image_height <= self . size : [EOL] return [EOL] [EOL] scale = self . size / image_height [EOL] [EOL] width = int ( image_width * scale ) [EOL] height = self . size [EOL] [EOL] else : [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] pillow = to_rgb ( pillow ) [EOL] [EOL] return pillow . resize ( ( width , height ) , Image . ANTIALIAS ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0
import builtins [EOL] import inspect [EOL] [EOL] from . . . exceptions import InvalidFilterSpecError [EOL] [EOL] try : [EOL] from PIL import Image [EOL] except ImportError : [comment] [EOL] Image = None [EOL] [EOL] [EOL] class Operation : [EOL] def __init__ ( self , method , * args ) : [EOL] self . method = method [EOL] self . args = args [EOL] [EOL] [comment] [EOL] try : [EOL] inspect . getcallargs ( self . construct , * args ) [EOL] except TypeError as e : [EOL] raise InvalidFilterSpecError ( e ) [EOL] [EOL] [comment] [EOL] try : [EOL] self . construct ( * args ) [EOL] except ValueError as e : [EOL] raise InvalidFilterSpecError ( e ) [EOL] [EOL] def construct ( self , * args ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def run ( self , pillow , attachment , env ) : [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Image$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0
from . base import Operation [EOL] [EOL] [EOL] class ScaleOperation ( Operation ) : [EOL] def construct ( self , percent ) : [EOL] self . percent = float ( percent ) [EOL] [EOL] def run ( self , pillow , attachment , env ) : [EOL] image_width , image_height = pillow . size [EOL] [EOL] scale = self . percent / [number] [EOL] width = int ( image_width * scale ) [EOL] height = int ( image_height * scale ) [EOL] [EOL] return pillow . resize ( ( width , height ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0
from . crop import CropOperation [EOL] from . do_nothing import DoNothingOperation [EOL] from . fill import FillOperation [EOL] from . format import FormatOperation [EOL] from . min_max import MinMaxOperation [EOL] from . scale import ScaleOperation [EOL] from . width_height import WidthHeightOperation [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from . . rect import Rect [EOL] from . . utils import to_rgb [EOL] from . base import Operation [EOL] [EOL] try : [EOL] from PIL import Image [EOL] except ImportError : [comment] [EOL] Image = None [EOL] [EOL] [EOL] class FillOperation ( Operation ) : [EOL] def construct ( self , size , * extra ) : [EOL] [comment] [EOL] width_str , height_str = size . split ( [string] ) [EOL] self . width = int ( width_str ) [EOL] self . height = int ( height_str ) [EOL] [EOL] [comment] [EOL] self . crop_closeness = [number] [EOL] [EOL] for extra_part in extra : [EOL] if extra_part . startswith ( [string] ) : [EOL] self . crop_closeness = int ( extra_part [ [number] : ] ) [EOL] else : [EOL] raise ValueError ( [string] % extra_part ) [EOL] [EOL] [comment] [EOL] self . crop_closeness /= [number] [EOL] [EOL] [comment] [EOL] if self . crop_closeness > [number] : [EOL] self . crop_closeness = [number] [EOL] [EOL] def run ( self , pillow , attachment , env ) : [EOL] image_width , image_height = pillow . size [EOL] focal_point = attachment . focal_point [EOL] [EOL] [comment] [EOL] crop_aspect_ratio = self . width / self . height [EOL] [EOL] [comment] [EOL] crop_max_scale = min ( image_width , image_height * crop_aspect_ratio ) [EOL] crop_max_width = crop_max_scale [EOL] crop_max_height = crop_max_scale / crop_aspect_ratio [EOL] [EOL] [comment] [EOL] crop_width = crop_max_width [EOL] crop_height = crop_max_height [EOL] [EOL] [comment] [EOL] if focal_point is not None : [EOL] [comment] [EOL] crop_min_scale = max ( focal_point . width , focal_point . height * crop_aspect_ratio ) [EOL] crop_min_width = crop_min_scale [EOL] crop_min_height = crop_min_scale / crop_aspect_ratio [EOL] [EOL] [comment] [EOL] if not crop_min_scale >= crop_max_scale : [EOL] [comment] [EOL] max_crop_closeness = max ( [number] - ( self . width - crop_min_width ) / ( crop_max_width - crop_min_width ) , [number] - ( self . height - crop_min_height ) / ( crop_max_height - crop_min_height ) , ) [EOL] [EOL] [comment] [EOL] crop_closeness = min ( self . crop_closeness , max_crop_closeness ) [EOL] [EOL] if [number] >= crop_closeness >= [number] : [EOL] [comment] [EOL] crop_width = ( crop_max_width + ( crop_min_width - crop_max_width ) * crop_closeness ) [EOL] crop_height = ( crop_max_height + ( crop_min_height - crop_max_height ) * crop_closeness ) [EOL] [EOL] fp_x , fp_y = focal_point . centroid [EOL] else : [EOL] [comment] [EOL] fp_x = image_width / [number] [EOL] fp_y = image_height / [number] [EOL] fp_u = fp_x / image_width [EOL] fp_v = fp_y / image_height [EOL] [EOL] [comment] [EOL] crop_x = fp_x - ( fp_u - [number] ) * crop_width [EOL] crop_y = fp_y - ( fp_v - [number] ) * crop_height [EOL] [EOL] [comment] [EOL] rect = Rect . from_point ( crop_x , crop_y , crop_width , crop_height ) [EOL] [EOL] [comment] [EOL] if focal_point is not None : [EOL] rect = rect . move_to_cover ( focal_point ) [EOL] [EOL] [comment] [EOL] rect = rect . move_to_clamp ( Rect ( [number] , [number] , image_width , image_height ) ) [EOL] [EOL] [comment] [EOL] pillow = pillow . crop ( rect . round ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] aftercrop_width , aftercrop_height = pillow . size [EOL] scale = self . width / aftercrop_width [EOL] [EOL] [comment] [EOL] if scale < [number] : [EOL] [EOL] [comment] [EOL] pillow = to_rgb ( pillow ) [EOL] [EOL] [comment] [EOL] pillow = pillow . resize ( ( self . width , self . height ) , Image . ANTIALIAS ) [EOL] [EOL] return pillow [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0
from . base import Operation [EOL] [EOL] [EOL] class DoNothingOperation ( Operation ) : [EOL] def construct ( self ) : [EOL] pass [EOL] [EOL] def run ( self , pillow , attachment , env ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . base import Operation [EOL] [EOL] [EOL] class FormatOperation ( Operation ) : [EOL] def construct ( self , fmt ) : [EOL] self . format = fmt [EOL] [EOL] if self . format not in [ [string] , [string] ] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def run ( self , pillow , attachment , env ) : [EOL] env [ [string] ] = self . format [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from . . rect import Rect [EOL] from . base import Operation [EOL] [EOL] [EOL] class CropOperation ( Operation ) : [EOL] def construct ( self , size = None ) : [EOL] if size : [EOL] left_str , top_str , width_str , height_str = size . split ( [string] ) [EOL] self . left = int ( left_str ) [EOL] self . top = int ( top_str ) [EOL] self . width = int ( width_str ) [EOL] self . height = int ( height_str ) [EOL] [EOL] def run ( self , pillow , attachment , env ) : [EOL] image_width , image_height = pillow . size [EOL] focal_point = attachment . focal_point [EOL] [EOL] if hasattr ( self , [string] ) : [EOL] crop_x = min ( self . left , image_width - [number] ) [EOL] crop_y = min ( self . top , image_height - [number] ) [EOL] [EOL] remaining_after_x = image_width - crop_x [EOL] remaining_after_y = image_height - crop_y [EOL] [EOL] max_crop_width = min ( self . width , crop_x * [number] , remaining_after_x * [number] ) [EOL] max_crop_height = min ( self . height , crop_y * [number] , remaining_after_y * [number] ) [EOL] [EOL] rect = Rect . from_point ( crop_x , crop_y , max_crop_width , max_crop_height ) [EOL] [EOL] pillow = pillow . crop ( rect ) [EOL] [EOL] elif focal_point : [EOL] pillow = pillow . crop ( focal_point ) [EOL] [EOL] return pillow [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Any [EOL] import typing [EOL] from . . utils import to_rgb [EOL] from . base import Operation [EOL] [EOL] try : [EOL] from PIL import Image [EOL] except ImportError : [comment] [EOL] Image = None [EOL] [EOL] [EOL] class MinMaxOperation ( Operation ) : [EOL] def construct ( self , size ) : [EOL] width_str , height_str = size . split ( [string] ) [EOL] self . width = int ( width_str ) [EOL] self . height = int ( height_str ) [EOL] [EOL] def run ( self , pillow , attachment , env ) : [EOL] image_width , image_height = pillow . size [EOL] [EOL] horz_scale = self . width / image_width [EOL] vert_scale = self . height / image_height [EOL] [EOL] if self . method == [string] : [EOL] if image_width <= self . width or image_height <= self . height : [EOL] return [EOL] [EOL] if horz_scale > vert_scale : [EOL] width = self . width [EOL] height = int ( image_height * horz_scale ) [EOL] else : [EOL] width = int ( image_width * vert_scale ) [EOL] height = self . height [EOL] [EOL] elif self . method == [string] : [EOL] if image_width <= self . width and image_height <= self . height : [EOL] return [EOL] [EOL] if horz_scale < vert_scale : [EOL] width = self . width [EOL] height = int ( image_height * horz_scale ) [EOL] else : [EOL] width = int ( image_width * vert_scale ) [EOL] height = self . height [EOL] [EOL] else : [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] pillow = to_rgb ( pillow ) [EOL] [EOL] return pillow . resize ( ( width , height ) , Image . ANTIALIAS ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0
from . base import Storage [EOL] from . filesystem import FileSystemStorage [EOL] from . s3 import S3Storage [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import IO [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] [EOL] from . . constants import KB [EOL] [EOL] [EOL] class Storage : [EOL] [docstring] [EOL] [EOL] def put ( self , filename , stream ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def delete ( self , filename ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def open ( self , filename , mode = [string] ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def locate ( self , filename ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $typing.IO$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Dict , IO , Set , Tuple , List , Any , Generator [EOL] import builtins [EOL] import urllib [EOL] import typing [EOL] import typing [EOL] import urllib [EOL] from io import BytesIO [EOL] [EOL] from . . constants import KB [EOL] from . . exceptions import MissingDependencyError [EOL] from . base import Storage [EOL] [EOL] [comment] [EOL] try : [EOL] import boto3 [EOL] except ImportError : [comment] [EOL] boto3 = None [EOL] [EOL] [EOL] class S3Storage ( Storage ) : [EOL] def __init__ ( self , bucket , access_key , secret_key , region , max_age = [number] * [number] * [number] * [number] , prefix = None , endpoint_url = None , acl = [string] , ) : [EOL] if boto3 is None : [comment] [EOL] raise MissingDependencyError ( [string] ) [EOL] [EOL] self . session = boto3 . session . Session ( ) [EOL] self . config = boto3 . session . Config ( s3 = { [string] : [string] } , signature_version = [string] ) [EOL] [EOL] self . endpoint_url = endpoint_url [EOL] [EOL] self . s3 = self . session . resource ( [string] , config = self . config , endpoint_url = self . endpoint_url , region_name = region , aws_access_key_id = access_key , aws_secret_access_key = secret_key , ) [EOL] [EOL] self . bucket = self . s3 . Bucket ( bucket ) [EOL] self . max_age = max_age [EOL] self . prefix = prefix [EOL] self . acl = acl [EOL] [EOL] def get_s3_path ( self , filename ) : [EOL] if self . prefix : [EOL] return [string] . format ( self . prefix , filename ) [EOL] return filename [EOL] [EOL] def _upload_file ( self , filename , data , content_type , rrs = False ) : [EOL] return self . bucket . put_object ( Key = filename , Body = data , ACL = self . acl , CacheControl = [string] + str ( self . max_age ) , StorageClass = [string] if rrs else [string] , ContentType = content_type or [string] , ) [EOL] [EOL] def put ( self , filename , stream ) : [EOL] path = self . get_s3_path ( filename ) [EOL] stream . seek ( [number] ) [EOL] data = stream . read ( ) [EOL] content_type = getattr ( stream , [string] , None ) [EOL] rrs = getattr ( stream , [string] , False ) [EOL] self . _upload_file ( path , data , content_type , rrs = rrs ) [EOL] return len ( data ) [EOL] [EOL] def delete ( self , filename ) : [EOL] path = self . get_s3_path ( filename ) [EOL] self . bucket . Object ( path ) . delete ( ) [EOL] [EOL] def open ( self , filename , mode = [string] ) : [EOL] path = self . get_s3_path ( filename ) [EOL] obj = self . bucket . Object ( path ) . get ( ) [EOL] return BytesIO ( obj [ [string] ] . read ( ) ) [EOL] [EOL] def _strip_signing_parameters ( self , url ) : [EOL] split_url = urllib . parse . urlsplit ( url ) [EOL] qs = urllib . parse . parse_qsl ( split_url . query , keep_blank_values = True ) [EOL] blacklist = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] filtered_qs = ( ( key , val ) for key , val in qs if key . lower ( ) not in blacklist ) [EOL] joined_qs = ( [string] . join ( keyval ) for keyval in filtered_qs ) [EOL] split_url = split_url . _replace ( query = [string] . join ( joined_qs ) ) [EOL] return split_url . geturl ( ) [EOL] [EOL] def locate ( self , filename ) : [EOL] path = self . get_s3_path ( filename ) [EOL] params = { [string] : path , [string] : self . bucket . name } [EOL] expires = [number] [EOL] [EOL] url = self . bucket . meta . client . generate_presigned_url ( [string] , Params = params , ExpiresIn = expires ) [EOL] [EOL] if self . acl in [ [string] , [string] ] : [EOL] url = self . _strip_signing_parameters ( url ) [EOL] [EOL] return url [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0
from typing import IO [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] from os import makedirs , remove [EOL] from os . path import abspath , dirname , exists , join [EOL] [EOL] from . . constants import KB [EOL] from . . helpers import copy_stream [EOL] from . base import Storage [EOL] [EOL] [EOL] class FileSystemStorage ( Storage ) : [EOL] def __init__ ( self , root_path , chunk_size = [number] * KB ) : [EOL] self . root_path = abspath ( root_path ) [EOL] self . chunk_size = chunk_size [EOL] [EOL] def _get_physical_path ( self , filename ) : [EOL] return join ( self . root_path , filename ) [EOL] [EOL] def put ( self , filename , stream ) : [EOL] physical_path = self . _get_physical_path ( filename ) [EOL] physical_directory = dirname ( physical_path ) [EOL] [EOL] if not exists ( physical_directory ) : [EOL] makedirs ( physical_directory , exist_ok = True ) [EOL] [EOL] stream . seek ( [number] ) [EOL] [EOL] with open ( physical_path , mode = [string] ) as target_file : [EOL] return copy_stream ( stream , target_file , chunk_size = self . chunk_size ) [EOL] [EOL] def delete ( self , filename ) : [EOL] physical_path = self . _get_physical_path ( filename ) [EOL] remove ( physical_path ) [EOL] [EOL] def open ( self , filename , mode = [string] ) : [EOL] return open ( self . _get_physical_path ( filename ) , mode = mode ) [EOL] [EOL] def locate ( self , filename ) : [EOL] return f"{ self . root_path } [string] { filename }" [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $typing.IO$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.IO$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.IO$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0