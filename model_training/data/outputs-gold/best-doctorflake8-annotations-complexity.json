from typing import Optional , List [EOL] import typing [EOL] import builtins [EOL] from typing import Optional [EOL] [EOL] from setuptools import setup , find_packages [EOL] [EOL] [EOL] package_name = [string] [EOL] [EOL] [EOL] def get_version ( ) : [EOL] with open ( [string] , [string] ) as f : [EOL] lines = f . readlines ( ) [EOL] for line in lines : [EOL] if line . startswith ( [string] ) : [EOL] return line . split ( [string] ) [ - [number] ] . strip ( ) . strip ( [string] ) [EOL] [EOL] [EOL] def get_long_description ( ) : [EOL] with open ( [string] ) as f : [EOL] return f . read ( ) [EOL] [EOL] [EOL] setup ( name = package_name , description = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , long_description = get_long_description ( ) , long_description_content_type = [string] , packages = find_packages ( ) , include_package_data = True , keywords = [string] , version = get_version ( ) , author = [string] , author_email = [string] , install_requires = [ [string] ] , entry_points = { [string] : [ [string] , ] , } , url = [string] , license = [string] , py_modules = [ package_name ] , zip_safe = False , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Tuple , List [EOL] from typing import List , Dict , Optional , Tuple [EOL] [EOL] [EOL] def foo ( ) : [EOL] return [ [number] ] [EOL] [EOL] [EOL] def bar ( arg1 , arg2 ) : [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'List[int]'$ 0 0 0 0 0 0 0 0 0 0 0 0 $'int'$ 0 0 0 0 0 0 0 0 0 0
from typing import Literal [EOL] import typing [EOL] from typing import Literal [EOL] [EOL] foo = [string] [EOL] bar = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] from typing import Tuple [EOL] [EOL] foo = ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[()]$ 0 0 0 0
from typing import Dict , Optional , Tuple , List [EOL] import typing [EOL] import builtins [EOL] from typing import List , Dict , Optional , Tuple [EOL] [EOL] [EOL] def foo ( ) : [EOL] return [ [number] ] [EOL] [EOL] [EOL] def bar ( arg1 , arg2 ) : [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Dict , Optional , Tuple , List [EOL] foo = tuple ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] def foo ( ) : [EOL] pass [EOL] [EOL] [EOL] def bar ( arg ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any , Type , Generator [EOL] import flake8_annotations_complexity [EOL] import typing [EOL] import builtins [EOL] from typing import Generator , Tuple [EOL] [EOL] from flake8_annotations_complexity import __version__ as version [EOL] from flake8_annotations_complexity . ast_helpres import validate_annotations_in_ast_node [EOL] [EOL] [EOL] class AnnotationsComplexityChecker : [EOL] name = [string] [EOL] version = version [EOL] [EOL] max_annotations_complexity = None [EOL] default_max_annotations_complexity = [number] [EOL] [EOL] _error_message_template = [string] [EOL] [EOL] def __init__ ( self , tree , filename ) : [EOL] self . filename = filename [EOL] self . tree = tree [EOL] if AnnotationsComplexityChecker . max_annotations_complexity is None : [EOL] AnnotationsComplexityChecker . max_annotations_complexity = self . default_max_annotations_complexity [EOL] [EOL] @ classmethod def add_options ( cls , parser ) : [EOL] parser . add_option ( [string] , type = int , parse_from_config = True , default = cls . default_max_annotations_complexity , ) [EOL] [EOL] @ classmethod def parse_options ( cls , options ) : [EOL] cls . max_annotations_complexity = int ( options . max_annotations_complexity ) [EOL] [EOL] def run ( self ) : [EOL] too_difficult_annotations = validate_annotations_in_ast_node ( self . tree , self . max_annotations_complexity , ) [EOL] [EOL] for annotation , complexity in too_difficult_annotations : [EOL] yield ( annotation . lineno , annotation . col_offset , self . _error_message_template . format ( complexity , self . max_annotations_complexity ) , type ( self ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.type],None,None]$ 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import ast [EOL] import typing [EOL] import builtins [EOL] import _ast [EOL] import ast [EOL] from typing import List , Tuple , Any [EOL] [EOL] [EOL] def get_annotation_complexity ( annotation_node , default_complexity = [number] ) : [EOL] if isinstance ( annotation_node , ast . Str ) : [EOL] try : [EOL] annotation_node = ast . parse ( annotation_node . s ) . body [ [number] ] . value [comment] [EOL] except ( SyntaxError , IndexError ) : [EOL] return default_complexity [EOL] if isinstance ( annotation_node , ast . Subscript ) : [EOL] return [number] + get_annotation_complexity ( annotation_node . slice . value ) [comment] [EOL] if isinstance ( annotation_node , ast . Tuple ) : [EOL] return max ( ( get_annotation_complexity ( n ) for n in annotation_node . elts ) , default = [number] ) [EOL] return default_complexity [EOL] [EOL] [EOL] def validate_annotations_in_ast_node ( node , max_annotations_complexity ) : [EOL] too_difficult_annotations = [ ] [EOL] func_defs = [ f for f in ast . walk ( node ) if isinstance ( f , ast . FunctionDef ) ] [EOL] annotations = [ ] [EOL] for funcdef in func_defs : [EOL] annotations += list ( filter ( None , ( a . annotation for a in funcdef . args . args ) ) ) [EOL] if funcdef . returns : [EOL] annotations . append ( funcdef . returns ) [EOL] annotations += [ a . annotation for a in ast . walk ( node ) if isinstance ( a , ast . AnnAssign ) and a . annotation ] [EOL] for annotation in annotations : [EOL] complexity = get_annotation_complexity ( annotation ) [EOL] if complexity > max_annotations_complexity : [EOL] too_difficult_annotations . append ( ( annotation , complexity , ) ) [EOL] return too_difficult_annotations [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0