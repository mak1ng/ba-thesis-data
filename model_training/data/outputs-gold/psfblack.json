from typing import Any [EOL] import typing [EOL] import builtins [EOL] import black [EOL] [docstring] [EOL] [EOL] import hypothesmith [EOL] from hypothesis import HealthCheck , given , settings , strategies as st [EOL] [EOL] import black [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ settings ( max_examples = [number] , derandomize = True , deadline = None , suppress_health_check = HealthCheck . all ( ) , ) @ given ( src_contents = hypothesmith . from_grammar ( ) | hypothesmith . from_node ( ) , mode = st . builds ( black . FileMode , line_length = st . just ( [number] ) | st . integers ( [number] , [number] ) , string_normalization = st . booleans ( ) , is_pyi = st . booleans ( ) , ) , ) def test_idempotent_any_syntatically_valid_python ( src_contents , mode ) : [EOL] [comment] [EOL] compile ( src_contents , [string] , [string] ) [comment] [EOL] [EOL] [comment] [EOL] try : [EOL] dst_contents = black . format_str ( src_contents , mode = mode ) [EOL] except black . InvalidInput : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] black . assert_equivalent ( src_contents , dst_contents ) [EOL] black . assert_stable ( src_contents , dst_contents , mode = mode ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] test_idempotent_any_syntatically_valid_python ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Literal , List , Any [EOL] import typing [EOL] import typing_extensions [EOL] import builtins [EOL] import pathlib [EOL] from setuptools import setup [EOL] import sys [EOL] import os [EOL] [EOL] assert sys . version_info >= ( [number] , [number] , [number] ) , [string] [EOL] from pathlib import Path [comment] [EOL] [EOL] CURRENT_DIR = Path ( __file__ ) . parent [EOL] sys . path . insert ( [number] , str ( CURRENT_DIR ) ) [comment] [EOL] [EOL] [EOL] def get_long_description ( ) : [EOL] return ( ( CURRENT_DIR / [string] ) . read_text ( encoding = [string] ) + [string] + ( CURRENT_DIR / [string] ) . read_text ( encoding = [string] ) ) [EOL] [EOL] [EOL] USE_MYPYC = False [EOL] [comment] [EOL] if len ( sys . argv ) > [number] and sys . argv [ [number] ] == [string] : [EOL] sys . argv . pop ( [number] ) [EOL] USE_MYPYC = True [EOL] if os . getenv ( [string] , None ) == [string] : [EOL] USE_MYPYC = True [EOL] [EOL] if USE_MYPYC : [EOL] mypyc_targets = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] from mypyc . build import mypycify [EOL] [EOL] opt_level = os . getenv ( [string] , [string] ) [EOL] ext_modules = mypycify ( mypyc_targets , opt_level = opt_level ) [EOL] else : [EOL] ext_modules = [ ] [EOL] [EOL] setup ( name = [string] , use_scm_version = { [string] : [string] , [string] : [string] , } , description = [string] , long_description = get_long_description ( ) , long_description_content_type = [string] , keywords = [string] , author = [string] , author_email = [string] , url = [string] , project_urls = { [string] : [string] } , license = [string] , py_modules = [ [string] ] , ext_modules = ext_modules , packages = [ [string] , [string] , [string] , [string] , [string] ] , package_dir = { [string] : [string] } , package_data = { [string] : [ [string] ] , [string] : [ [string] ] } , python_requires = [string] , zip_safe = False , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , extras_require = { [string] : [ [string] , [string] ] , [string] : [ [string] ] , } , test_suite = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , entry_points = { [string] : [ [string] , [string] , [string] , ] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
\ [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class MyClass : [EOL] [docstring] [EOL] [EOL] def method ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def foo ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def bar ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def baz ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def troz ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def zort ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def poit ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def under_indent ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def over_indent ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def single_line ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def this ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def that ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def and_that ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def and_this ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def believe_it_or_not_this_is_in_the_py_stdlib ( ) : [docstring] [EOL] [EOL] [EOL] def ignored_docstring ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] class MyClass : [EOL] [docstring] [EOL] [EOL] def method ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def foo ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def bar ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def baz ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def troz ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def zort ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def poit ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def under_indent ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def over_indent ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def single_line ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def this ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def that ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def and_that ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def and_this ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def believe_it_or_not_this_is_in_the_py_stdlib ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def ignored_docstring ( ) : [EOL] [docstring]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] def f ( ) : [EOL] return ( i * [number] async for i in arange ( [number] ) ) [EOL] [EOL] [EOL] def g ( ) : [EOL] return ( something_long * something_long async for something_long in async_generator ( with_an_argument ) ) [EOL] [EOL] [EOL] async def func ( ) : [EOL] if test : [EOL] out_batched = [ i async for i in aitertools . _async_map ( self . async_inc , arange ( [number] ) , batch_size = [number] ) ] [EOL] [EOL] [EOL] def awaited_generator_value ( n ) : [EOL] return ( await awaitable for awaitable in awaitable_list ) [EOL] [EOL] [EOL] def make_arange ( n ) : [EOL] return ( i * [number] for i in range ( n ) if await wrap ( i ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def f ( ) : [EOL] return ( i * [number] async for i in arange ( [number] ) ) [EOL] [EOL] [EOL] def g ( ) : [EOL] return ( something_long * something_long async for something_long in async_generator ( with_an_argument ) ) [EOL] [EOL] [EOL] async def func ( ) : [EOL] if test : [EOL] out_batched = [ i async for i in aitertools . _async_map ( self . async_inc , arange ( [number] ) , batch_size = [number] ) ] [EOL] [EOL] [EOL] def awaited_generator_value ( n ) : [EOL] return ( await awaitable for awaitable in awaitable_list ) [EOL] [EOL] [EOL] def make_arange ( n ) : [EOL] return ( i * [number] for i in range ( n ) if await wrap ( i ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Dict , Literal , List , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] import builtins [EOL] def f ( a , ) : [EOL] d = { [string] : [string] , } [EOL] tup = ( [number] , ) [EOL] [EOL] def f2 ( a , b , ) : [EOL] d = { [string] : [string] , [string] : [string] , } [EOL] tup = ( [number] , [number] , ) [EOL] [EOL] def f ( a = [number] , ) : [EOL] call ( arg = { [string] : [string] , } ) [EOL] call2 ( arg = [ [number] , [number] , [number] ] , ) [EOL] x = { [string] : [number] , [string] : [number] , } [ [string] ] [EOL] if a == { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [ [string] ] : [EOL] pass [EOL] [EOL] def xxxxxxxxxxxxxxxxxxxxxxxxxxxx ( ) : [EOL] json = { [string] : { [string] : { [string] : [ [number] , ] } } } [EOL] [EOL] [comment] [EOL] [EOL] def f ( a , ) : [EOL] d = { [string] : [string] , } [EOL] tup = ( [number] , ) [EOL] [EOL] [EOL] def f2 ( a , b , ) : [EOL] d = { [string] : [string] , [string] : [string] , } [EOL] tup = ( [number] , [number] , ) [EOL] [EOL] [EOL] def f ( a = [number] , ) : [EOL] call ( arg = { [string] : [string] , } ) [EOL] call2 ( arg = [ [number] , [number] , [number] ] , ) [EOL] x = { [string] : [number] , [string] : [number] , } [ [string] ] [EOL] if a == { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [ [string] ] : [EOL] pass [EOL] [EOL] [EOL] def xxxxxxxxxxxxxxxxxxxxxxxxxxxx ( ) : [EOL] json = { [string] : { [string] : { [string] : [ [number] , ] } } }	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def abc ( ) : [EOL] return [ [string] , [string] , [string] ] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class ALonelyClass : [EOL] [docstring] [EOL] def AnEquallyLonelyMethod ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def one_function ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def shockingly_the_quotes_are_normalized ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def foo ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def baz ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def poit ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def under_indent ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def over_indent ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def single_line ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def this ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def that ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def and_that ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def and_this ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def believe_it_or_not_this_is_in_the_py_stdlib ( ) : [docstring] [EOL] [EOL] [EOL] def shockingly_the_quotes_are_normalized_v2 ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [comment] [EOL] [EOL] class ALonelyClass : [EOL] [docstring] [EOL] [EOL] def AnEquallyLonelyMethod ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def one_function ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def shockingly_the_quotes_are_normalized ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def foo ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def baz ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def poit ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def under_indent ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def over_indent ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def single_line ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def this ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def that ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def and_that ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def and_this ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def believe_it_or_not_this_is_in_the_py_stdlib ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] def shockingly_the_quotes_are_normalized_v2 ( ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] name = [string] [EOL] F" [string] { name }" [EOL] [docstring] [EOL] [docstring] [EOL] fR" [string] " [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] name = [string] [EOL] f" [string] { name }" [EOL] [docstring] [EOL] [docstring] [EOL] fR" [string] " [EOL]	0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
ä = [number] [EOL] µ = [number] [EOL] 蟒 = [number] [EOL] x󠄀 = [number] [EOL] មុ = [number] [EOL] Q̇_per_meter = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] def long_function_name ( argument_one , argument_two , argument_three , argument_four , argument_five , argument_six , * rest ) : ... [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def long_function_name ( argument_one , argument_two , argument_three , argument_four , argument_five , argument_six , * rest , ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] x = [ [number] , [number] , [number] , [number] , ] [EOL] [comment] [EOL] [EOL] [comment] [EOL] x = [ [number] , [number] , [number] , [number] , ] [EOL] [comment] [EOL] [EOL] x = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] x = [ [number] , [number] , [number] , [number] , ] [EOL] [comment] [EOL] [EOL] [comment] [EOL] x = [ [number] , [number] , [number] , [number] , ] [EOL] [comment] [EOL] [EOL] x = [ [number] , [number] , [number] , [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0
def bob ( ) : \ [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] def bobtwo ( ) : \ [EOL] \ [EOL] [comment] [EOL] pass [EOL] [EOL] [comment] [EOL] [EOL] def bob ( ) : [comment] [EOL] pass [EOL] [EOL] [EOL] def bobtwo ( ) : [comment] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Literal , Any , Callable , List , Sequence , Union , Tuple , Optional [EOL] import typing_extensions [EOL] import functools [EOL] import subprocess [EOL] import urllib [EOL] import typing [EOL] import src [EOL] import logging [EOL] import builtins [EOL] import asyncio [EOL] import pathlib [EOL] import asyncio [EOL] import errno [EOL] import json [EOL] import logging [EOL] import os [EOL] import stat [EOL] import sys [EOL] from functools import partial [EOL] from pathlib import Path [EOL] from platform import system [EOL] from shutil import rmtree , which [EOL] from subprocess import CalledProcessError [EOL] from sys import version_info [EOL] from typing import Any , Callable , Dict , NamedTuple , Optional , Sequence , Tuple [EOL] from urllib . parse import urlparse [EOL] [EOL] import click [EOL] [EOL] [EOL] WINDOWS = system ( ) == [string] [EOL] BLACK_BINARY = [string] if WINDOWS else [string] [EOL] GIT_BIANRY = [string] if WINDOWS else [string] [EOL] LOG = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if sys . platform == [string] : [EOL] asyncio . set_event_loop ( asyncio . ProactorEventLoop ( ) ) [EOL] [EOL] [EOL] class Results ( NamedTuple ) : [EOL] stats = { } [EOL] failed_projects = { } [EOL] [EOL] [EOL] async def _gen_check_output ( cmd , timeout = [number] , env = None , cwd = None , ) : [EOL] process = await asyncio . create_subprocess_exec ( * cmd , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . STDOUT , env = env , cwd = cwd , ) [EOL] try : [EOL] ( stdout , stderr ) = await asyncio . wait_for ( process . communicate ( ) , timeout ) [EOL] except asyncio . TimeoutError : [EOL] process . kill ( ) [EOL] await process . wait ( ) [EOL] raise [EOL] [EOL] if process . returncode != [number] : [EOL] cmd_str = [string] . join ( cmd ) [EOL] raise CalledProcessError ( process . returncode , cmd_str , output = stdout , stderr = stderr ) [EOL] [EOL] return ( stdout , stderr ) [EOL] [EOL] [EOL] def analyze_results ( project_count , results ) : [EOL] failed_pct = round ( ( ( results . stats [ [string] ] / project_count ) * [number] ) , [number] ) [EOL] success_pct = round ( ( ( results . stats [ [string] ] / project_count ) * [number] ) , [number] ) [EOL] [EOL] click . secho ( [string] , bold = True ) [EOL] click . secho ( f"{ results . stats [ [string] ] } [string] { project_count } [string] { success_pct } [string] " , bold = True , fg = [string] , ) [EOL] click . secho ( f"{ results . stats [ [string] ] } [string] { project_count } [string] { failed_pct } [string] " , bold = bool ( results . stats [ [string] ] ) , fg = [string] , ) [EOL] s = [string] if results . stats [ [string] ] == [number] else [string] [EOL] click . echo ( f" [string] { results . stats [ [string] ] } [string] { s } [string] " ) [EOL] s = [string] if results . stats [ [string] ] == [number] else [string] [EOL] click . echo ( f" [string] { results . stats [ [string] ] } [string] { s } [string] " ) [EOL] click . echo ( f" [string] { results . stats [ [string] ] } [string] " ) [EOL] [EOL] if results . failed_projects : [EOL] click . secho ( [string] , bold = True ) [EOL] [EOL] for project_name , project_cpe in results . failed_projects . items ( ) : [EOL] print ( f" [string] { project_name } [string] " ) [EOL] print ( f" [string] { project_cpe . returncode }" ) [EOL] if project_cpe . stderr : [EOL] print ( f" [string] { project_cpe . stderr . decode ( [string] ) }" ) [EOL] if project_cpe . stdout : [EOL] print ( f" [string] { project_cpe . stdout . decode ( [string] ) }" ) [EOL] print ( [string] ) [EOL] [EOL] return results . stats [ [string] ] [EOL] [EOL] [EOL] async def black_run ( repo_path , project_config , results ) : [EOL] [docstring] [EOL] cmd = [ str ( which ( BLACK_BINARY ) ) ] [EOL] if [string] in project_config and project_config [ [string] ] : [EOL] cmd . extend ( * project_config [ [string] ] ) [EOL] cmd . extend ( [ [string] , [string] , [string] ] ) [EOL] [EOL] try : [EOL] _stdout , _stderr = await _gen_check_output ( cmd , cwd = repo_path ) [EOL] except asyncio . TimeoutError : [EOL] results . stats [ [string] ] += [number] [EOL] LOG . error ( f" [string] { repo_path } [string] { cmd } [string] " ) [EOL] except CalledProcessError as cpe : [EOL] [comment] [EOL] [comment] [EOL] if cpe . returncode == [number] : [EOL] if not project_config [ [string] ] : [EOL] results . stats [ [string] ] += [number] [EOL] results . failed_projects [ repo_path . name ] = cpe [EOL] else : [EOL] results . stats [ [string] ] += [number] [EOL] return [EOL] elif cpe . returncode > [number] : [EOL] results . stats [ [string] ] += [number] [EOL] results . failed_projects [ repo_path . name ] = cpe [EOL] return [EOL] [EOL] LOG . error ( f" [string] { repo_path }" ) [EOL] raise [EOL] [EOL] [comment] [EOL] if project_config [ [string] ] : [EOL] results . stats [ [string] ] += [number] [EOL] results . failed_projects [ repo_path . name ] = CalledProcessError ( [number] , cmd , [string] , [string] ) [EOL] return [EOL] [EOL] results . stats [ [string] ] += [number] [EOL] [EOL] [EOL] async def git_checkout_or_rebase ( work_path , project_config , rebase = False , * , depth = [number] , ) : [EOL] [docstring] [EOL] git_bin = str ( which ( GIT_BIANRY ) ) [EOL] if not git_bin : [EOL] LOG . error ( [string] ) [EOL] return None [EOL] [EOL] repo_url_parts = urlparse ( project_config [ [string] ] ) [EOL] path_parts = repo_url_parts . path [ [number] : ] . split ( [string] , maxsplit = [number] ) [EOL] [EOL] repo_path = work_path / path_parts [ [number] ] . replace ( [string] , [string] ) [EOL] cmd = [ git_bin , [string] , [string] , str ( depth ) , project_config [ [string] ] ] [EOL] cwd = work_path [EOL] if repo_path . exists ( ) and rebase : [EOL] cmd = [ git_bin , [string] , [string] ] [EOL] cwd = repo_path [EOL] elif repo_path . exists ( ) : [EOL] return repo_path [EOL] [EOL] try : [EOL] _stdout , _stderr = await _gen_check_output ( cmd , cwd = cwd ) [EOL] except ( asyncio . TimeoutError , CalledProcessError ) as e : [EOL] LOG . error ( f" [string] { project_config [ [string] ] } [string] { e }" ) [EOL] return None [EOL] [EOL] return repo_path [EOL] [EOL] [EOL] def handle_PermissionError ( func , path , exc ) : [EOL] [docstring] [EOL] excvalue = exc [ [number] ] [EOL] LOG . debug ( f" [string] { excvalue } [string] { func . __name__ } [string] " ) [EOL] if func in ( os . rmdir , os . unlink ) and excvalue . errno == errno . EACCES : [EOL] LOG . debug ( f" [string] { path } [string] " ) [EOL] os . chmod ( path , stat . S_IRWXU | stat . S_IRWXG | stat . S_IRWXO ) [comment] [EOL] func ( path ) [comment] [EOL] else : [EOL] raise [EOL] [EOL] [EOL] async def load_projects_queue ( config_path , ) : [EOL] [docstring] [EOL] with config_path . open ( [string] ) as cfp : [EOL] config = json . load ( cfp ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] project_names = sorted ( config [ [string] ] . keys ( ) ) [EOL] queue = asyncio . Queue ( maxsize = len ( project_names ) ) [EOL] for project in project_names : [EOL] await queue . put ( project ) [EOL] [EOL] return config , queue [EOL] [EOL] [EOL] async def project_runner ( idx , config , queue , work_path , results , long_checkouts = False , rebase = False , keep = False , ) : [EOL] [docstring] [EOL] loop = asyncio . get_event_loop ( ) [EOL] py_version = f"{ version_info [ [number] ] } [string] { version_info [ [number] ] }" [EOL] while True : [EOL] try : [EOL] project_name = queue . get_nowait ( ) [EOL] except asyncio . QueueEmpty : [EOL] LOG . debug ( f" [string] { idx } [string] " ) [EOL] return [EOL] LOG . debug ( f" [string] { idx } [string] { project_name }" ) [EOL] [EOL] project_config = config [ [string] ] [ project_name ] [EOL] [EOL] [comment] [EOL] if [string] in project_config and project_config [ [string] ] : [EOL] results . stats [ [string] ] += [number] [EOL] LOG . info ( f" [string] { project_name } [string] " ) [EOL] continue [EOL] [EOL] [comment] [EOL] if ( [string] not in project_config [ [string] ] [EOL] and py_version not in project_config [ [string] ] ) : [EOL] results . stats [ [string] ] += [number] [EOL] LOG . debug ( f" [string] { project_name } [string] { py_version }" ) [EOL] continue [EOL] [EOL] [comment] [EOL] if not long_checkouts and project_config [ [string] ] : [EOL] results . stats [ [string] ] += [number] [EOL] LOG . debug ( f" [string] { project_name } [string] " ) [EOL] continue [EOL] [EOL] repo_path = await git_checkout_or_rebase ( work_path , project_config , rebase ) [EOL] if not repo_path : [EOL] continue [EOL] await black_run ( repo_path , project_config , results ) [EOL] [EOL] if not keep : [EOL] LOG . debug ( f" [string] { repo_path }" ) [EOL] rmtree_partial = partial ( rmtree , path = repo_path , onerror = handle_PermissionError ) [EOL] await loop . run_in_executor ( None , rmtree_partial ) [EOL] [EOL] LOG . info ( f" [string] { project_name }" ) [EOL] [EOL] [EOL] async def process_queue ( config_file , work_path , workers , keep = False , long_checkouts = False , rebase = False , ) : [EOL] [docstring] [EOL] results = Results ( ) [EOL] results . stats [ [string] ] = [number] [EOL] results . stats [ [string] ] = [number] [EOL] results . stats [ [string] ] = [number] [EOL] results . stats [ [string] ] = [number] [EOL] results . stats [ [string] ] = [number] [EOL] [EOL] config , queue = await load_projects_queue ( Path ( config_file ) ) [EOL] project_count = queue . qsize ( ) [EOL] s = [string] if project_count == [number] else [string] [EOL] LOG . info ( f"{ project_count } [string] { s } [string] " ) [EOL] if project_count < [number] : [EOL] return - [number] [EOL] [EOL] s = [string] if workers == [number] else [string] [EOL] LOG . debug ( f" [string] { workers } [string] { s } [string] " ) [EOL] [comment] [EOL] await asyncio . gather ( * [ project_runner ( i , config , queue , work_path , results , long_checkouts , rebase , keep ) for i in range ( workers ) ] ) [EOL] [EOL] LOG . info ( [string] ) [EOL] return analyze_results ( project_count , results ) [EOL] [EOL] [EOL] if __name__ == [string] : [comment] [EOL] raise NotImplementedError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $typing.Dict[builtins.str,subprocess.CalledProcessError]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from black import patched_main [EOL] [EOL] patched_main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0