from typing import Optional , Literal , Any , List , Tuple , Dict [EOL] import steppygraph [EOL] import typing_extensions [EOL] import typing [EOL] import builtins [EOL] import json [EOL] from typing import List , Dict , TypeVar , Any , Optional , Tuple [EOL] [EOL] from steppygraph . states import State , JSON_INDENT , Task , ResourceType , Resource , Wait , Pass , StateType , Catcher [EOL] from steppygraph . utils import filter_props [EOL] from steppygraph . serialize import to_serializable [EOL] [EOL] TERMINAL_STATES = ( StateType . FAIL , StateType . SUCCEED ) [EOL] [EOL] [EOL] class DuplicateStateError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class StateMachine : [EOL] def __init__ ( self , region = [string] , account = [string] , name = [string] ) : [EOL] self . TimeoutSeconds = [number] [EOL] self . States = { } [EOL] self . StartAt = None [EOL] self . _states = [ ] [EOL] self . _region = region [EOL] self . _account = account [EOL] self . _name = name [EOL] self . End = None [EOL] [EOL] def to_json ( self ) : [EOL] return json . dumps ( self , sort_keys = True , indent = JSON_INDENT , default = to_serializable ) [comment] [EOL] [EOL] def idx ( self , name ) : [EOL] [docstring] [EOL] for i in range ( [number] , len ( self . _states ) ) : [EOL] s = self . _states [ i ] [EOL] if name == s . name ( ) : [EOL] return i [EOL] return None [EOL] [EOL] def last_orphan ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] for index in range ( len ( self . _states ) - [number] , - [number] , - [number] ) : [EOL] s = self . _states [ index ] [EOL] if s . _autoconnect is True and s . Type not in TERMINAL_STATES and s . _next is None : [EOL] return index [EOL] return None [EOL] [EOL] def next ( self , state ) : [EOL] [docstring] [EOL] state . _autoconnect = True [EOL] [EOL] if len ( self . _states ) > [number] : [EOL] orphan_idx = self . last_orphan ( ) [EOL] if orphan_idx is not None : [EOL] s = self . _states [ orphan_idx ] [EOL] if s . _autoconnect : [EOL] s . set_next ( state . name ( ) ) [EOL] [EOL] return self . add_state ( state ) [EOL] [EOL] def add_state ( self , state ) : [EOL] [docstring] [EOL] for s in self . _states : [EOL] if s . name ( ) == state . name ( ) : [EOL] err_message = f" [string] { s . name ( ) } [string] { [ ss . name ( ) for ss in self . _states ] }" [EOL] raise DuplicateStateError ( err_message ) [EOL] [EOL] self . set_resource_attrs ( state ) [EOL] self . _states . append ( state ) [EOL] return self [EOL] [EOL] def set_resource_attrs ( self , state ) : [EOL] [docstring] [EOL] if isinstance ( state , Task ) : [EOL] if state . Resource : [EOL] state . Resource . aws_ac = self . _account [EOL] state . Resource . region = self . _region [EOL] [EOL] def build ( self ) : [EOL] d = { } [EOL] states_len = len ( self . _states ) [EOL] for i in range ( [number] , states_len ) : [EOL] s = self . _states [ i ] [EOL] [EOL] if i == [number] : [EOL] self . StartAt = s . name ( ) [EOL] [EOL] if i == states_len - [number] : [EOL] if s . Type not in [ ts . value for ts in TERMINAL_STATES ] : [EOL] s . End = True [EOL] d [ s . name ( ) ] = s . build ( ) [EOL] self . States = d [EOL] return self [EOL] [EOL] def get_states ( self ) : [EOL] return self . _states [EOL] [EOL] def count_states ( self ) : [EOL] return len ( self . _states ) [EOL] [EOL] def printable ( self ) : [EOL] return [string] . join ( [ str ( s . __dict__ ) for k , s in self . build ( ) . States . items ( ) ] ) [EOL] [EOL] def last ( self ) : [EOL] return self . _states [ - [number] ] [EOL] [EOL] def name ( self ) : [EOL] return self . _name [EOL] [EOL] [EOL] @ to_serializable . register ( StateMachine ) def machine_to_json ( obj ) : [EOL] for k , s in obj . States . items ( ) : [EOL] obj . States [ k ] = s [EOL] return filter_props ( obj . __dict__ ) [EOL] [EOL] [EOL] class Branch ( StateMachine ) : [EOL] def __init__ ( self , region = [string] , account = [string] , name = [string] ) : [EOL] StateMachine . __init__ ( self , region = region , account = account , name = name ) [EOL] del self . TimeoutSeconds [EOL] [EOL] [EOL] class Parallel ( State ) : [EOL] def __init__ ( self , name , branches , comment = None , catch = None ) : [EOL] State . __init__ ( self , type = StateType . PARALLEL , name = name , comment = comment ) [EOL] self . _catch = catch [EOL] self . Branches = branches [EOL] [EOL] def build ( self ) : [EOL] if self . _catch : [EOL] self . Catch = self . _catch [EOL] [EOL] for b in self . Branches : [EOL] b . build ( ) [EOL] return self [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[steppygraph.states.Catcher]$ 0 0 0 0 0 $typing.List[steppygraph.machine.Branch]$ 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] def filter_props ( d ) : [EOL] filtered = { } [EOL] for key , value in d . items ( ) : [EOL] if key [ [number] ] != [string] and value is not None : [EOL] filtered [ key ] = value [EOL] [EOL] return filtered	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from functools import singledispatch [EOL] [EOL] @ singledispatch def to_serializable ( val ) : [EOL] [docstring] [EOL] return str ( val ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
name = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from steppygraph . utils import filter_props [EOL] [EOL] d = { [string] : True , [string] : [number] } [EOL] [EOL] [EOL] def test_filter_keys ( ) : [EOL] o = filter_props ( d ) [EOL] assert o [ [string] ] == True [EOL] assert [string] not in o . keys ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import json [EOL] from pathlib import PurePath [EOL] [EOL] from steppygraph . serialize import to_serializable [EOL] [EOL] [EOL] def write_json_test_case ( name , s ) : [EOL] with open ( PurePath ( ) / f' [string] { name } [string] ' , [string] ) as f : [EOL] if type ( s ) == str : [EOL] f . write ( s ) [EOL] else : [EOL] f . write ( json . dumps ( s , default = to_serializable ) ) [EOL] [EOL] [EOL] def read_json_test_case ( name ) : [EOL] with open ( PurePath ( ) / f' [string] { name } [string] ' , [string] ) as f : [EOL] return f . read ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import steppygraph [EOL] import typing [EOL] import json [EOL] [EOL] from steppygraph . machine import Branch , Parallel [EOL] from steppygraph . states import Choice , ChoiceCase , Comparison , ComparisonType , Task , StateType , to_serializable , Pass , Catcher , ErrorType , State , BatchJob , EcsTask [EOL] from steppygraph . states import Resource , ResourceType [EOL] from steppygraph . test . testutils import read_json_test_case , write_json_test_case [EOL] [EOL] [EOL] def test_state_to_str ( ) : [EOL] assert str ( StateType . CHOICE ) == [string] [EOL] [EOL] [EOL] def test_comparison_type_to_str ( ) : [EOL] assert str ( ComparisonType . BOOLEAN_EQ ) == [string] [EOL] [EOL] [EOL] def test_resource_to_json ( ) : [EOL] res = Resource ( name = [string] , type = ResourceType . LAMBDA , aws_ac = [number] , region = [string] ) [EOL] assert json . dumps ( res , default = to_serializable ) == [string] [EOL] [EOL] [EOL] def test_lambda_task_to_json ( ) : [EOL] assert json . dumps ( Task ( name = [string] , resource = Resource ( type = ResourceType . LAMBDA , name = [string] ) ) , default = to_serializable ) == [string] [EOL] [EOL] [EOL] def test_batch_task_to_json ( ) : [EOL] assert json . dumps ( BatchJob ( name = [string] , definition = [string] , queue = [string] , parameters = [string] ) , default = to_serializable ) == [string] + [string] [EOL] [EOL] [EOL] def test_ecs_task_to_json ( ) : [EOL] assert json . dumps ( EcsTask ( name = [string] , cluster = [string] , definition = [string] , launch_type = [string] ) , default = to_serializable ) == [string] + [string] [EOL] [EOL] [EOL] def test_choice_case_to_json ( ) : [EOL] assert json . dumps ( ChoiceCase ( [string] , comparison = Comparison ( ComparisonType . BOOLEAN_EQ , value = True ) , next = Pass ( name = [string] ) ) , default = to_serializable ) == [string] [EOL] [EOL] [EOL] def test_choice_to_json ( ) : [EOL] t = Task ( name = [string] , resource = Resource ( name = [string] , type = ResourceType . LAMBDA ) ) [EOL] choices = [ ChoiceCase ( variable = [string] , comparison = Comparison ( comparison_type = ComparisonType . BOOLEAN_EQ , value = True ) , next = t ) ] [EOL] c = Choice ( name = [string] , choices = choices , default = t ) [EOL] [EOL] assert json . dumps ( c , default = to_serializable ) == [string] [EOL] [EOL] [EOL] def test_parallel ( ) : [EOL] t = Task ( name = [string] , resource = Resource ( name = [string] , type = ResourceType . LAMBDA ) ) [EOL] branch_a = Branch ( [string] ) [EOL] branch_a . next ( t ) [EOL] branch_b = Branch ( [string] ) [EOL] branch_b . next ( t ) [EOL] p = Parallel ( [string] , branches = [ branch_a , branch_b ] ) [EOL] p . build ( ) [EOL] assert len ( p . Branches ) == [number] [EOL] read_json_test_case ( [string] ) == p . to_json ( ) [EOL] [EOL] [EOL] def test_catcher_to_json ( ) : [EOL] c = Catcher ( error_equals = [ ErrorType . TASK_FAILED ] , next = Task ( [string] , resource = Resource ( [string] , type = ResourceType . ACTIVITY ) ) ) [EOL] assert json . dumps ( c , default = to_serializable ) == read_json_test_case ( [string] ) [EOL] [EOL] [EOL] def test_setting_timeout_works ( ) : [EOL] t = Task ( [string] , timeout_seconds = [number] , resource = Resource ( [string] , type = ResourceType . LAMBDA ) ) [EOL] assert t . TimeoutSeconds == [number] [EOL] [EOL] [EOL] def test_setting_catcher_on_task_works ( ) : [EOL] t2 = Task ( [string] , resource = Resource ( [string] , type = ResourceType . LAMBDA ) ) [EOL] [EOL] t = Task ( name = [string] , resource = Resource ( name = [string] , type = ResourceType . LAMBDA ) , catch = [ Catcher ( error_equals = [ ErrorType . TASK_FAILED ] , next = t2 ) ] ) [EOL] assert read_json_test_case ( [string] ) == json . dumps ( t , default = to_serializable ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import steppygraph [EOL] import builtins [EOL] import json [EOL] import sys [EOL] from pathlib import PurePath [EOL] [EOL] from steppygraph . machine import StateMachine [EOL] from steppygraph . states import Task , Resource , ResourceType , Wait , Pass , Succeed , Fail , ErrorType , Catcher [EOL] from steppygraph . test . testutils import read_json_test_case [EOL] [EOL] [EOL] def test_hello_machine ( ) : [EOL] s = StateMachine ( ) [EOL] s . next ( Task ( resource = Resource ( [string] , type = ResourceType . LAMBDA ) , name = [string] , comment = [string] ) ) [EOL] s . build ( ) [EOL] assert len ( s . get_states ( ) ) == [number] [EOL] assert s . StartAt == s . get_states ( ) [ [number] ] . name ( ) , str ( s . get_states ( ) [ [number] ] ) [EOL] [EOL] [EOL] def test_add_state_does_not_update_next_property ( ) : [EOL] s = StateMachine ( ) [EOL] s . add_state ( Task ( resource = Resource ( [string] , type = ResourceType . LAMBDA ) , name = [string] , comment = [string] ) ) [EOL] s . add_state ( Task ( resource = Resource ( [string] , type = ResourceType . LAMBDA ) , name = [string] , comment = [string] ) ) [EOL] s . build ( ) [EOL] assert s . get_states ( ) [ [number] ] . _next != s . get_states ( ) [ [number] ] . name ( ) , s . printable ( ) [EOL] [EOL] [EOL] def test_next_set_for_two_state_machine ( ) : [EOL] s = StateMachine ( ) [EOL] res = Resource ( name = [string] , type = ResourceType . LAMBDA ) [EOL] s . next ( Task ( resource = res , name = [string] , comment = [string] ) ) [EOL] s . next ( Task ( resource = res , name = [string] , comment = [string] ) ) [EOL] s . build ( ) [EOL] assert len ( s . get_states ( ) ) == [number] [EOL] assert s . StartAt == [string] [EOL] assert s . get_states ( ) [ [number] ] . _next == s . get_states ( ) [ [number] ] . name ( ) , s . printable ( ) [EOL] assert s . get_states ( ) [ - [number] ] . _next == None [EOL] [comment] [EOL] assert s . get_states ( ) [ [number] ] . End == None [EOL] assert s . get_states ( ) [ - [number] ] . End == True [EOL] [EOL] [EOL] def test_pass_wait ( ) : [EOL] s = StateMachine ( ) [EOL] s . next ( Wait ( name = [string] ) ) [EOL] s . next ( Pass ( name = [string] ) ) [EOL] s . next ( Wait ( name = [string] , seconds = [number] ) ) [EOL] s . build ( ) [EOL] [EOL] assert s . count_states ( ) == [number] [EOL] assert s . last ( ) . Seconds == [number] [EOL] assert s . to_json ( ) == read_json_test_case ( [string] ) [EOL] [EOL] [EOL] def test_machine_sets_region_and_ac ( ) : [EOL] s = StateMachine ( region = [string] , account = [number] ) [EOL] s . next ( Task ( name = [string] , resource = Resource ( [string] , type = ResourceType . LAMBDA ) ) ) [EOL] s . build ( ) [EOL] assert s . get_states ( ) [ [number] ] . Resource . region == [string] [EOL] assert s . get_states ( ) [ [number] ] . Resource . aws_ac == [number] [EOL] [EOL] [EOL] def test_idx ( ) : [EOL] s = StateMachine ( ) [EOL] s . next ( Task ( resource = Resource ( [string] , type = ResourceType . LAMBDA ) , name = [string] , comment = [string] ) ) [EOL] s . next ( Task ( resource = Resource ( [string] , type = ResourceType . LAMBDA ) , name = [string] , comment = [string] ) ) [EOL] s . build ( ) [EOL] assert s . idx ( [string] ) == [number] [EOL] assert s . idx ( [string] ) == [number] [EOL] assert s . idx ( [string] ) == None [EOL] [EOL] [EOL] def test_last_orphan ( ) : [EOL] s = StateMachine ( ) [EOL] s . next ( Task ( resource = Resource ( [string] , type = ResourceType . LAMBDA ) , name = [string] , comment = [string] ) ) [EOL] s . add_state ( Pass ( [string] ) ) [EOL] s . add_state ( Wait ( [string] ) ) [EOL] s . next ( Succeed ( [string] ) ) [EOL] s . build ( ) [EOL] assert s . idx ( [string] ) == [number] [EOL] assert s . get_states ( ) [ [number] ] . Next == [string] [EOL] [EOL] [EOL] def test_end_not_set_in_succeed_state ( ) : [EOL] s = StateMachine ( ) [EOL] s . next ( Task ( resource = Resource ( [string] , type = ResourceType . LAMBDA ) , name = [string] , comment = [string] ) ) [EOL] s . next ( Wait ( [string] ) ) [EOL] s . next ( Succeed ( [string] ) ) [EOL] s . build ( ) [EOL] print ( s . to_json ( ) ) [EOL] assert s . get_states ( ) [ - [number] ] . End is None [EOL] [EOL] [EOL] [EOL] def snake_to_camel ( name ) : [EOL] return [string] . join ( map ( str . capitalize , name . split ( [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0