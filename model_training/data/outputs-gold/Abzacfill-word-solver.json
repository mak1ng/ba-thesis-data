import builtins [EOL] from typing import List , Type , Any , Union [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import sys [EOL] from typing import List , Union [EOL] [EOL] import resources [EOL] from recursive_dict import RecursiveDict [EOL] [EOL] [EOL] LOG_FORMAT = [string] [EOL] [EOL] MatrixType = List [ Union [ str , List [ str ] ] ] [EOL] [EOL] [EOL] INPUT_MATRIX = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def print_word_matrix ( matrix , path ) : [EOL] for y , row in enumerate ( matrix ) : [EOL] print_row = [string] . join ( letter if ( y , x ) in path else [string] for x , letter in enumerate ( row ) ) [EOL] print ( print_row ) [EOL] [EOL] [EOL] def main ( ) : [EOL] logging . basicConfig ( level = logging . INFO , format = LOG_FORMAT ) [EOL] logger = logging . getLogger ( ) [EOL] [EOL] words = resources . load_dict_files ( ) [EOL] logger . info ( f' [string] ' , len ( words ) ) [EOL] if len ( words ) == [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] matrix = INPUT_MATRIX [EOL] [EOL] logger . info ( [string] ) [EOL] word_index = RecursiveDict . build_word_index ( words ) [EOL] [EOL] logger . info ( [string] ) [EOL] [EOL] paths = word_index . search_words ( matrix ) [EOL] [EOL] logger . info ( f' [string] ' , len ( paths ) ) [EOL] [EOL] sys . stdout . flush ( ) [EOL] print ( ) [EOL] for word in sorted ( paths , key = lambda word : ( - len ( word ) , word ) ) : [EOL] word_paths = paths . get ( word ) [EOL] [EOL] print ( f' [string] { word } [string] { len ( word_paths ) } [string] ' ) [EOL] for path in word_paths : [EOL] print_word_matrix ( matrix , path ) [EOL] print ( ) [EOL] [EOL] logger . info ( [string] , len ( paths ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MatrixType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MatrixType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Type , List , Tuple , Set , Dict [EOL] import typing [EOL] import builtins [EOL] import src [EOL] import collections [EOL] from typing import List , Optional , Dict , Set , Tuple [EOL] [EOL] [EOL] __all__ = [ [string] , ] [EOL] [EOL] Point = Tuple [ int , int ] [EOL] [EOL] [EOL] DIAGONAL_DIRECTIONS = [ ] [EOL] for dy in range ( - [number] , [number] ) : [EOL] for dx in range ( - [number] , [number] ) : [EOL] if dx != [number] or dy != [number] : [EOL] DIAGONAL_DIRECTIONS . append ( ( dy , dx ) ) [EOL] [EOL] [EOL] SQUARE_DIRECTIONS = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) , ( - [number] , [number] ) , ] [EOL] [EOL] [EOL] class RecursiveDict ( object ) : [EOL] def __init__ ( self ) : [EOL] self . _root = { } [EOL] [EOL] @ property def root ( self ) : [EOL] return self . _root [EOL] [EOL] @ classmethod def build_word_index ( cls , words ) : [EOL] word_index = RecursiveDict ( ) [EOL] for word in words : [EOL] node = word_index [EOL] for letter in word : [EOL] node = node [ letter ] [EOL] node [ None ] [comment] [EOL] return word_index [EOL] [EOL] def search_words ( self , input_matrix , * , directions = None , ) : [EOL] if directions is None : [EOL] directions = SQUARE_DIRECTIONS [EOL] [EOL] paths = collections . defaultdict ( list ) [EOL] [EOL] for y , row in enumerate ( input_matrix ) : [EOL] for x , letter in enumerate ( row ) : [EOL] self . _recursive_search ( input_matrix , x = x , y = y , paths = paths , directions = directions , ) [EOL] [EOL] return paths [EOL] [EOL] def _recursive_search ( self , input_matrix , * , x , y , paths , prefix = [string] , used_points = None , path = None , directions , ) : [EOL] rows = len ( input_matrix ) [EOL] cols = len ( input_matrix [ [number] ] ) [EOL] [EOL] if used_points is None : [EOL] used_points = set ( ) [EOL] else : [EOL] used_points = set ( used_points ) [EOL] used_points . add ( ( y , x ) ) [EOL] [EOL] if path is None : [EOL] path = list ( ) [EOL] else : [EOL] path = list ( path ) [EOL] path . append ( ( y , x ) ) [EOL] [EOL] letter = input_matrix [ y ] [ x ] [EOL] [EOL] if letter == [string] and letter not in self and [string] in self : [EOL] letter = [string] [EOL] [EOL] if letter in self : [EOL] if None in self [ letter ] : [EOL] word = prefix + letter [EOL] paths [ word ] . append ( path ) [EOL] [EOL] for dy , dx in directions : [EOL] new_y = y + dy [EOL] new_x = x + dx [EOL] if ( [number] <= new_y < rows and [number] <= new_x < cols and ( new_y , new_x ) not in used_points ) : [EOL] if letter in self : [EOL] self [ letter ] . _recursive_search ( input_matrix , x = new_x , y = new_y , paths = paths , prefix = prefix + letter , used_points = used_points , path = path , directions = directions , ) [EOL] [EOL] def __getitem__ ( self , k ) : [EOL] if k not in self . _root : [EOL] self . _root [ k ] = type ( self ) ( ) [EOL] return self . _root [ k ] [EOL] [EOL] def __contains__ ( self , k ) : [EOL] return k in self . _root [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _root ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( type ( self ) . __name__ , len ( self ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Set[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 $typing.Optional[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 $typing.List[Point]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Set[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 $typing.Optional[typing.Set[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Set[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 $typing.Optional[typing.Set[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 $typing.Optional[typing.Set[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 $typing.Optional[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 $typing.Optional[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 $typing.Optional[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 $typing.List[Point]$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Set[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[typing.Set[typing.Tuple[builtins.int,builtins.int]]]$ 0 $typing.Optional[typing.Set[typing.Tuple[builtins.int,builtins.int]]]$ 0 $typing.Optional[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 $typing.Optional[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 $typing.List[Point]$ 0 $typing.List[Point]$ 0 0 0 0 0 $'RecursiveDict'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Optional , Set [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] from typing import Optional , List [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , ] [EOL] [EOL] [EOL] DEFAULT_DICTS_PATH = [string] [EOL] DEFAULT_DICT_EXTENSIONS = { [string] , [string] } [EOL] [EOL] [EOL] def iterate_dict_files ( dicts_path = None , * , extensions = None , ) : [EOL] if dicts_path is None : [EOL] dicts_path = DEFAULT_DICTS_PATH [EOL] [EOL] if extensions is None : [EOL] extensions = DEFAULT_DICT_EXTENSIONS [EOL] [EOL] for path in pathlib . Path ( dicts_path ) . iterdir ( ) : [EOL] if any ( path . name . endswith ( ext ) for ext in extensions ) : [EOL] yield path [EOL] [EOL] [EOL] def load_dict_files ( dicts_path = None , * , extensions = None , min_word_length = [number] , ) : [EOL] words = [ ] [EOL] [EOL] for path in iterate_dict_files ( dicts_path , extensions = extensions ) : [EOL] data = pathlib . Path ( path ) . read_text ( encoding = [string] ) [EOL] new_words = [ word . strip ( ) . lower ( ) for word in data . split ( [string] ) if [string] not in word and [string] not in word and word . strip ( ) and len ( word . strip ( ) ) > min_word_length ] [EOL] words . extend ( new_words ) [EOL] [EOL] return words [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0