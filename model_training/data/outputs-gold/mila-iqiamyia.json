	0
	0
	0
from typing import Any [EOL] import typing [EOL] import myia [EOL] [docstring] [EOL] [EOL] [EOL] import pytest [EOL] [EOL] from myia . debug . utils import GraphIndex [EOL] from myia . pipeline import scalar_parse as parse [EOL] [EOL] [EOL] def test_GraphIndex ( ) : [EOL] @ parse def f ( x , y ) : [EOL] a = x * y [EOL] b = x + y [EOL] c = a - b [EOL] return c [EOL] [EOL] idx = GraphIndex ( f ) [EOL] [EOL] assert idx [ [string] ] is f . parameters [ [number] ] [EOL] assert idx [ [string] ] is f . parameters [ [number] ] [EOL] [EOL] assert idx [ [string] ] is f . output [EOL] assert idx [ [string] ] is f . output . inputs [ [number] ] [EOL] assert idx [ [string] ] is f . output . inputs [ [number] ] [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] idx [ [string] ] [EOL] [EOL] [EOL] def test_GraphIndex_multigraph ( ) : [EOL] def helper ( x ) : [EOL] return x * x [EOL] [EOL] @ parse def f ( x , y ) : [EOL] def inner ( a ) : [EOL] b = a - [number] [EOL] return b [EOL] [EOL] a = inner ( x ) * helper ( y ) [EOL] return a [EOL] [EOL] idx = GraphIndex ( f ) [EOL] [EOL] assert idx . get_all ( [string] ) == { idx [ [string] ] . parameters [ [number] ] , idx [ [string] ] . parameters [ [number] ] , } [EOL] [EOL] assert idx . get_all ( [string] ) == { idx [ [string] ] . parameters [ [number] ] } [EOL] [EOL] assert idx . get_all ( [string] ) == { idx [ [string] ] . output , idx [ [string] ] . parameters [ [number] ] } [EOL] [EOL] assert idx . get_all ( [string] ) == { idx [ [string] ] . output } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
[docstring] [EOL] [EOL] [EOL] from . inject import inject_suite [EOL] [EOL] inject_suite ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import myia [EOL] from dataclasses import dataclass [EOL] [EOL] from myia . abstract import ( ANYTHING as ANY , TYPE , VALUE , AbstractScalar , from_value , ) [EOL] from myia . xtype import Bool , Float , Int [EOL] [EOL] B = AbstractScalar ( { VALUE : ANY , TYPE : Bool } ) [EOL] [EOL] i16 = AbstractScalar ( { VALUE : ANY , TYPE : Int [ [number] ] } ) [EOL] i32 = AbstractScalar ( { VALUE : ANY , TYPE : Int [ [number] ] } ) [EOL] i64 = AbstractScalar ( { VALUE : ANY , TYPE : Int [ [number] ] } ) [EOL] [EOL] f16 = AbstractScalar ( { VALUE : ANY , TYPE : Float [ [number] ] } ) [EOL] f32 = AbstractScalar ( { VALUE : ANY , TYPE : Float [ [number] ] } ) [EOL] f64 = AbstractScalar ( { VALUE : ANY , TYPE : Float [ [number] ] } ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Point : [EOL] x = ... [EOL] y = ... [EOL] [EOL] def abs ( self ) : [EOL] return ( self . x ** [number] + self . y ** [number] ) ** [number] [EOL] [EOL] def __add__ ( self , other ) : [EOL] return Point ( self . x * other . x , self . y * other . y ) [EOL] [EOL] [EOL] pt = from_value ( Point ( [number] , [number] ) , broaden = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.abstract.data.AbstractScalar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.abstract.data.AbstractScalar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.abstract.data.AbstractScalar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.abstract.data.AbstractScalar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.abstract.data.AbstractScalar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.abstract.data.AbstractScalar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.abstract.data.AbstractScalar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $i64$ 0 0 0 $i64$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import myia [EOL] from myia . opt import lib [EOL] [EOL] tuple_opts = [ lib . getitem_tuple , lib . setitem_tuple , lib . bubble_op_tuple_binary , ] [EOL] [EOL] [EOL] arith_opts = [ lib . multiply_by_zero_l , lib . multiply_by_zero_r , lib . multiply_by_one_l , lib . multiply_by_one_r , lib . add_zero_l , lib . add_zero_r , ] [EOL] [EOL] [EOL] all_opt = [ * tuple_opts , * arith_opts , lib . inline , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[myia.opt.opt.PatternSubstitutionOptimization]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[myia.opt.opt.PatternSubstitutionOptimization]$ 0 0 0 0 0 0 0
from typing import Any , Dict , Tuple , List [EOL] import typing [EOL] import debug [EOL] import decimal [EOL] [docstring] [EOL] [EOL] import os [EOL] import time [EOL] from collections import Counter , defaultdict [EOL] from decimal import Decimal [EOL] [EOL] import breakword [EOL] from colorama import Fore [EOL] [EOL] from myia . utils import ( DoTrace , Profiler as prof , TraceExplorer as explore , TraceListener , ) [EOL] [EOL] from . inject import bucheg [EOL] [EOL] _beginning = time . monotonic ( ) [EOL] _current = time . monotonic ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Time : [EOL] def __init__ ( self , t = None ) : [EOL] if t is None : [EOL] self . t = time . monotonic ( ) - _beginning [EOL] else : [EOL] self . t = t [EOL] [EOL] def compare ( self , other ) : [EOL] return Time ( other . t - self . t ) [EOL] [EOL] @ classmethod def statistics ( cls , tdata ) : [EOL] data = [ t . t for t in tdata ] [EOL] print ( f" [string] " , Time ( min ( data ) ) ) [EOL] print ( f" [string] " , Time ( sum ( data ) / len ( data ) ) ) [EOL] print ( f" [string] " , Time ( max ( data ) ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] d = Decimal ( self . t ) [EOL] unit = [string] [EOL] units = [ [string] , [string] , [string] ] [EOL] for other_unit in units : [EOL] if d >= [number] : [EOL] break [EOL] else : [EOL] d *= [number] [EOL] unit = other_unit [EOL] d = round ( d , [number] ) [EOL] return f"{ d }{ unit }" [EOL] [EOL] [EOL] def _color ( color , text ) : [EOL] [docstring] [EOL] if os . environ . get ( [string] ) : [EOL] return text [EOL] else : [EOL] return f"{ color }{ text }{ Fore . RESET }" [EOL] [EOL] [EOL] def _pgraph ( path ) : [EOL] [docstring] [EOL] [EOL] def _p ( graph , ** _ ) : [EOL] bucheg ( graph ) [EOL] [EOL] return lambda : DoTrace ( { path : _p } ) [EOL] [EOL] [EOL] class Getters ( dict ) : [EOL] def __init__ ( self , fields , kwfields ) : [EOL] for field in fields : [EOL] if field == [string] : [EOL] self [ field ] = lambda ** kwargs : [string] . join ( kwargs ) [EOL] elif field . startswith ( [string] ) : [EOL] field = field [ [number] : ] [EOL] self [ field ] = globals ( ) [ f" [string] { field }" ] [EOL] else : [EOL] self [ field ] = self . _get_by_name ( field ) [EOL] for name , getter in kwfields . items ( ) : [EOL] self [ name ] = getter [EOL] [EOL] def _get_by_name ( self , field ) : [EOL] def _get ( ** kwargs ) : [EOL] return kwargs . get ( field , f" [string] { field } [string] " ) [EOL] [EOL] return _get [EOL] [EOL] def __call__ ( self , kwargs ) : [EOL] results = { name : getter ( ** kwargs ) for name , getter in self . items ( ) } [EOL] return results [EOL] [EOL] [EOL] def _display ( curpath , results , word = None , brk = True ) : [EOL] w = word or breakword . word ( ) [EOL] if len ( results ) == [number] : [EOL] print ( w , curpath ) [EOL] elif len ( results ) == [number] : [EOL] _ , value = list ( results . items ( ) ) [ [number] ] [EOL] print ( w , _color ( Fore . LIGHTBLACK_EX , curpath ) , value ) [EOL] else : [EOL] print ( w , _color ( Fore . LIGHTBLACK_EX , curpath ) ) [EOL] for name , value in results . items ( ) : [EOL] print ( f" [string] { name } [string] { value }" ) [EOL] if brk : [EOL] _brk ( w ) [EOL] [EOL] [EOL] def _brk ( w ) : [EOL] if breakword . after ( ) : [EOL] print ( [string] , w ) [EOL] breakpoint ( skip = [ [string] , [string] ] ) [EOL] [EOL] [EOL] def _resolve_path ( p , variant = [string] ) : [EOL] if not p : [EOL] rval = [string] [EOL] elif p . startswith ( [string] ) : [EOL] rval = globals ( ) [ f" [string] { variant } [string] { p [ [number] : ] }" ] [EOL] else : [EOL] rval = p [EOL] if isinstance ( rval , str ) : [EOL] rval = [ rval ] [EOL] return rval [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] graph = _pgraph ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] graph_mono = _pgraph ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] graph_parse = _pgraph ( [string] ) [EOL] [EOL] [EOL] def log ( path = None , * fields , ** kwfields ) : [EOL] [docstring] [EOL] [EOL] getters = Getters ( fields , kwfields ) [EOL] [EOL] def _p ( ** kwargs ) : [EOL] _curpath = kwargs [ [string] ] [EOL] results = getters ( kwargs ) [EOL] _display ( _curpath , results ) [EOL] [EOL] return DoTrace ( { pth : _p for pth in _resolve_path ( path ) } ) [EOL] [EOL] [EOL] def opts ( ) : [EOL] [docstring] [EOL] return log ( [string] , opt = lambda opt , ** _ : opt . name ) [EOL] [EOL] [EOL] def compare ( path = None , * fields , ** kwfields ) : [EOL] store = { } [EOL] getters = Getters ( fields , kwfields ) [EOL] [EOL] def _compare ( old , new ) : [EOL] if isinstance ( old , dict ) : [EOL] return { k : _compare ( v , new [ k ] ) for k , v in old . items ( ) } [EOL] elif isinstance ( old , ( int , float ) ) : [EOL] diff = new - old [EOL] if diff == [number] : [EOL] return old [EOL] c = Fore . LIGHTGREEN_EX if diff > [number] else Fore . LIGHTRED_EX [EOL] diff = f" [string] { diff }" if diff > [number] else str ( diff ) [EOL] return f"{ old } [string] { new } [string] { _color ( c , diff ) } [string] " [EOL] elif hasattr ( old , [string] ) : [EOL] return old . compare ( new ) [EOL] elif old == new : [EOL] return old [EOL] else : [EOL] return f"{ old } [string] { new }" [EOL] [EOL] def _enter ( _curpath , ** kwargs ) : [EOL] _path = _curpath [ : - [number] ] [EOL] w = breakword . word ( ) [EOL] store [ _path ] = ( w , getters ( kwargs ) ) [EOL] _brk ( w ) [EOL] [EOL] def _exit ( _curpath , ** kwargs ) : [EOL] if [string] in kwargs and not kwargs [ [string] ] : [EOL] return [EOL] _path = _curpath [ : - [number] ] [EOL] w , old = store [ _path ] [EOL] new = getters ( kwargs ) [EOL] _display ( _path , _compare ( old , new ) , word = w , brk = False ) [EOL] [EOL] path = _resolve_path ( path , variant = [string] ) [EOL] return DoTrace ( { f"{ path } [string] " : _enter , f"{ path } [string] " : _exit } ) [EOL] [EOL] [EOL] class StatAccumulator ( TraceListener ) : [EOL] def __init__ ( self , path , fields , kwfields ) : [EOL] [docstring] [EOL] self . path = _resolve_path ( path ) [EOL] self . accum = defaultdict ( list ) [EOL] self . getters = Getters ( fields , kwfields ) [EOL] [EOL] def install ( self , tracer ) : [EOL] [docstring] [EOL] patt = self . path or [string] [EOL] tracer . on ( patt , self . _do ) [EOL] [EOL] def _do ( self , ** kwargs ) : [EOL] for k , v in self . getters ( kwargs ) . items ( ) : [EOL] self . accum [ ( k , type ( v ) ) ] . append ( v ) [EOL] [EOL] def post ( self ) : [EOL] for ( name , typ ) , data in self . accum . items ( ) : [EOL] print ( f"{ name } [string] " ) [EOL] if not data : [EOL] print ( [string] ) [EOL] [EOL] if issubclass ( typ , ( int , float ) ) : [EOL] print ( f" [string] " , min ( data ) ) [EOL] print ( f" [string] " , sum ( data ) / len ( data ) ) [EOL] print ( f" [string] " , max ( data ) ) [EOL] [EOL] elif hasattr ( typ , [string] ) : [EOL] typ . statistics ( data ) [EOL] [EOL] else : [EOL] counts = Counter ( data ) [EOL] align = max ( len ( str ( obj ) ) for obj in counts ) [EOL] counts = sorted ( counts . items ( ) , key = lambda k : - k [ [number] ] ) [EOL] for obj , count in counts : [EOL] print ( f" [string] { str ( obj ) . ljust ( align ) } [string] { count }" ) [EOL] [EOL] [EOL] def stat ( path = None , * fields , ** kwfields ) : [EOL] [docstring] [EOL] return StatAccumulator ( path , fields , kwfields ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] _path_opt = [ [string] , [string] ] [EOL] _pathcmp_opt = [ [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def _rule_optname ( opt = None , ** kwargs ) : [EOL] if opt is None : [EOL] return [string] [EOL] return opt . name [EOL] [EOL] [EOL] def _rule_optparam ( node = None , ** kwargs ) : [EOL] if node is None : [EOL] return [string] [EOL] try : [EOL] return str ( node . inputs [ [number] ] ) [EOL] except Exception : [EOL] return [string] [EOL] [EOL] [EOL] def _rule_countnodes ( graph = None , manager = None , ** kwargs ) : [EOL] if manager is None : [EOL] if graph is None : [EOL] return [string] [EOL] if graph . _manager is None : [EOL] return [string] [EOL] manager = graph . manager [EOL] return len ( manager . all_nodes ) [EOL] [EOL] [EOL] def _rule_countgraphs ( graph = None , manager = None , ** kwargs ) : [EOL] if manager is None : [EOL] if graph is None : [EOL] return [string] [EOL] if graph . _manager is None : [EOL] return [string] [EOL] manager = graph . manager [EOL] return len ( manager . graphs ) [EOL] [EOL] [EOL] def _rule_time ( ** kwargs ) : [EOL] return Time ( ) [EOL] [EOL] [EOL] def _rule_reltime ( ** kwargs ) : [EOL] global _current [EOL] old = _current [EOL] _current = time . monotonic ( ) [EOL] return Time ( _current - old ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $decimal.Decimal$ 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 $decimal.Decimal$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.trace.Getters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0
import os [EOL] import sys [EOL] [EOL] errmsg = [string] [EOL] [EOL] if __name__ == [string] : [EOL] os . environ [ [string] ] = [string] [EOL] cmd = [string] [EOL] try : [EOL] os . execvp ( [string] , [ [string] , [string] , [string] , [string] , cmd ] + sys . argv [ [number] : ] ) [EOL] except FileNotFoundError : [EOL] print ( errmsg , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from myia . pipeline . steps import ( step_compile as export , step_debug_opt as debug_opt , step_infer as infer , step_opt as opt , step_opt2 as opt2 , step_parse as parse , step_resolve as resolve , step_simplify_types as simplify_types , step_specialize as specialize , step_validate as validate , ) [EOL] from myia . utils import Partial [EOL] [EOL] standard = [ parse , resolve , infer , specialize , simplify_types , opt , opt2 , validate , export , ] [EOL] [EOL] _debug_opt = [ parse , resolve , infer , specialize , simplify_types , debug_opt , opt2 , validate , export , ] [EOL] [EOL] _bang_parse = standard [ : standard . index ( parse ) + [number] ] [EOL] _bang_resolve = standard [ : standard . index ( resolve ) + [number] ] [EOL] _bang_infer = standard [ : standard . index ( infer ) + [number] ] [EOL] _bang_specialize = standard [ : standard . index ( specialize ) + [number] ] [EOL] _bang_simplify_types = standard [ : standard . index ( simplify_types ) + [number] ] [EOL] _bang_opt = standard [ : standard . index ( opt ) + [number] ] [EOL] _bang_opt2 = standard [ : standard . index ( opt2 ) + [number] ] [EOL] _bang_validate = standard [ : standard . index ( validate ) + [number] ] [EOL] _bang_export = standard [ : standard . index ( export ) + [number] ] [EOL] [EOL] _bang_debug_opt = _debug_opt [ : _debug_opt . index ( debug_opt ) + [number] ] [EOL] [EOL] [EOL] def _adjust ( ) : [EOL] for name , g in globals ( ) . items ( ) : [EOL] if isinstance ( g , Partial ) : [EOL] g . _name = name [EOL] [EOL] [EOL] _adjust ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Tuple , Set , Union , List [EOL] import typing [EOL] import debug [EOL] import myia [EOL] [docstring] [EOL] [EOL] import json [EOL] import os [EOL] [EOL] from hrepr import hrepr [EOL] [EOL] from myia import abstract , info , ir , operations , opt , parser , utils , vm , xtype [EOL] from myia . abstract import ANYTHING , VALUE , Possibilities [EOL] from myia . debug . label import ( CosmeticPrimitive , NodeLabeler , short_labeler , short_relation_symbols , ) [EOL] from myia . debug . utils import mixin [EOL] from myia . info import About [EOL] from myia . ir import Apply , Constant , GraphCloner , manage [EOL] from myia . ir . manager import ParentProxy [EOL] from myia . operations import primitives as primops [EOL] from myia . opt import LocalPassOptimizer , NodeMap , pattern_replacer [EOL] from myia . utils import UNKNOWN , Registry [EOL] from myia . utils . unify import SVar , Var , var [EOL] from myia . xtype import Float , Int , UInt [EOL] [EOL] try : [EOL] from myia . xtype import JTagged [EOL] except ImportError : [EOL] [EOL] class JTagged : [EOL] pass [EOL] [EOL] [EOL] gcss_path = f"{ os . path . dirname ( __file__ ) } [string] " [EOL] gcss = open ( gcss_path ) . read ( ) [EOL] [EOL] mcss_path = f"{ os . path . dirname ( __file__ ) } [string] " [EOL] mcss = open ( mcss_path ) . read ( ) [EOL] [EOL] [EOL] def _has_error ( dbg ) : [EOL] [comment] [EOL] if dbg . errors : [EOL] return True [EOL] elif dbg . about : [EOL] return _has_error ( dbg . about . debug ) [EOL] else : [EOL] return False [EOL] [EOL] [EOL] class GraphPrinter : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cyoptions , tooltip_gen = None , extra_style = None ) : [EOL] [docstring] [EOL] [comment] [EOL] self . nodes = [ ] [EOL] self . edges = [ ] [EOL] self . cyoptions = cyoptions [EOL] self . tooltip_gen = tooltip_gen [EOL] self . extra_style = extra_style or [string] [EOL] [EOL] def id ( self , x ) : [EOL] [docstring] [EOL] return f" [string] { id ( x ) }" [EOL] [EOL] def fresh_id ( self ) : [EOL] [docstring] [EOL] self . currid += [number] [EOL] return f" [string] { self . currid }" [EOL] [EOL] def _strip_cosmetic ( self , node ) : [EOL] while ( node [EOL] and node . debug . about [EOL] and node . debug . about . relation == [string] ) : [EOL] node = node . debug . about . debug . obj [EOL] return node [EOL] [EOL] def cynode ( self , id , label , classes , parent = None , node = None ) : [EOL] [docstring] [EOL] if not isinstance ( id , str ) : [EOL] if node is None : [EOL] node = id [EOL] id = self . id ( id ) [EOL] data = { [string] : id , [string] : str ( label ) } [EOL] if self . tooltip_gen and node : [EOL] ttip = self . tooltip_gen ( self . _strip_cosmetic ( node ) ) [EOL] if ttip is not None : [EOL] if not isinstance ( ttip , str ) : [EOL] ttip = str ( hrepr ( ttip ) ) [EOL] data [ [string] ] = ttip [EOL] if parent : [EOL] parent = parent if isinstance ( parent , str ) else self . id ( parent ) [EOL] data [ [string] ] = parent [EOL] self . nodes . append ( { [string] : data , [string] : classes } ) [EOL] [EOL] def cyedge ( self , src_id , dest_id , label ) : [EOL] [docstring] [EOL] cl = [string] [EOL] if isinstance ( label , tuple ) : [EOL] label , cl = label [EOL] if not isinstance ( label , str ) : [EOL] label = str ( label ) [EOL] if not isinstance ( dest_id , str ) : [EOL] dest_id = self . id ( dest_id ) [EOL] if not isinstance ( src_id , str ) : [EOL] src_id = self . id ( src_id ) [EOL] data = { [string] : f"{ dest_id } [string] { src_id } [string] { label }" , [string] : label , [string] : dest_id , [string] : src_id , } [EOL] self . edges . append ( { [string] : data , [string] : cl } ) [EOL] [EOL] @ classmethod def __hrepr_resources__ ( cls , H ) : [EOL] [docstring] [EOL] return ( H . style ( mcss ) , H . bucheRequire ( name = [string] , channels = [string] , components = [string] , ) , ) [EOL] [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] [docstring] [EOL] opts = { [string] : gcss + self . extra_style , [string] : self . nodes + self . edges , } [EOL] return H . cytoscapeGraph ( H . script ( json . dumps ( { ** opts , ** self . cyoptions } ) , type = [string] ) , width = hrepr . config . graph_width or [string] , height = hrepr . config . graph_height or [string] , interactive = True , ) [EOL] [EOL] [EOL] def _make_class_gen ( cgen ) : [EOL] if isinstance ( cgen , ( tuple , list , set , frozenset ) ) : [EOL] cgen = frozenset ( cgen ) [EOL] return lambda x , cl : f" [string] { cl }" if x in cgen else cl [EOL] elif isinstance ( cgen , dict ) : [EOL] return lambda x , cl : f"{ cgen [ x ] } [string] { cl }" if x in cgen else cl [EOL] else : [EOL] return cgen [EOL] [EOL] [EOL] class MyiaGraphPrinter ( GraphPrinter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , entry_points , * , duplicate_constants = False , duplicate_free_variables = False , function_in_node = False , follow_references = False , tooltip_gen = None , class_gen = None , extra_style = None , beautify = True , ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( { [string] : { [string] : [string] , [string] : [string] } } , tooltip_gen = tooltip_gen , extra_style = extra_style , ) [EOL] [comment] [EOL] if beautify : [EOL] self . graphs = set ( ) [EOL] self . focus = set ( ) [EOL] for g in entry_points : [EOL] self . _import_graph ( g ) [EOL] else : [EOL] self . graphs = set ( entry_points ) [EOL] self . focus = set ( self . graphs ) [EOL] [EOL] self . beautify = beautify [EOL] self . duplicate_constants = duplicate_constants [EOL] self . duplicate_free_variables = duplicate_free_variables [EOL] self . function_in_node = function_in_node [EOL] self . follow_references = follow_references [EOL] self . labeler = NodeLabeler ( function_in_node = function_in_node , relation_symbols = short_relation_symbols , ) [EOL] self . _class_gen = _make_class_gen ( class_gen ) [EOL] [comment] [EOL] self . processed = set ( ) [EOL] [comment] [EOL] self . pool = set ( ) [EOL] [comment] [EOL] self . returns = set ( ) [EOL] [comment] [EOL] self . currid = [number] [EOL] [EOL] def _import_graph ( self , graph ) : [EOL] mng = manage ( graph , weak = True ) [EOL] graphs = set ( ) [EOL] parents = mng . parents [EOL] g = graph [EOL] while g : [EOL] graphs . add ( g ) [EOL] g = parents [ g ] [EOL] clone = GraphCloner ( * graphs , total = True , relation = [string] ) [EOL] self . graphs |= { clone [ g ] for g in graphs } [EOL] self . focus . add ( clone [ graph ] ) [EOL] [EOL] def name ( self , x ) : [EOL] [docstring] [EOL] return self . labeler . name ( x , force = True ) [EOL] [EOL] def label ( self , node , fn_label = None ) : [EOL] [docstring] [EOL] return self . labeler . label ( node , None , fn_label = fn_label ) [EOL] [EOL] def const_fn ( self , node ) : [EOL] [docstring] [EOL] return self . labeler . const_fn ( node ) [EOL] [EOL] def add_graph ( self , g ) : [EOL] [docstring] [EOL] if g in self . processed : [EOL] return [EOL] if self . beautify : [EOL] g = cosmetic_transformer ( g ) [EOL] name = self . name ( g ) [EOL] argnames = [ self . name ( p ) for p in g . parameters ] [EOL] lbl = f'{ name } [string] { [string] . join ( argnames ) } [string] ' [EOL] classes = [ [string] , [string] if g in self . focus else [string] ] [EOL] self . cynode ( id = g , label = lbl , classes = [string] . join ( classes ) ) [EOL] self . processed . add ( g ) [EOL] [EOL] def process_node_generic ( self , node , g , cl ) : [EOL] [docstring] [EOL] lbl = self . label ( node ) [EOL] [EOL] self . cynode ( id = node , label = lbl , parent = g , classes = cl ) [EOL] [EOL] fn = node . inputs [ [number] ] if node . inputs else None [EOL] if fn and fn . is_constant_graph ( ) : [EOL] self . graphs . add ( fn . value ) [EOL] [EOL] for inp in node . inputs : [EOL] if inp . is_constant_graph ( ) : [EOL] self . cyedge ( src_id = g , dest_id = inp . value , label = ( [string] , [string] ) ) [EOL] [EOL] edges = [ ] [EOL] if fn and not ( fn . is_constant ( ) and self . function_in_node ) : [EOL] edges . append ( ( node , [string] , fn ) ) [EOL] [EOL] edges += [ ( node , i + [number] , inp ) for i , inp in enumerate ( node . inputs [ [number] : ] ) or [ ] ] [EOL] [EOL] self . process_edges ( edges ) [EOL] [EOL] def class_gen ( self , node , cl = None ) : [EOL] [docstring] [EOL] g = node . graph [EOL] if cl is not None : [EOL] pass [EOL] elif node in self . returns : [EOL] cl = [string] [EOL] elif node . is_parameter ( ) : [EOL] cl = [string] [EOL] if node not in g . parameters : [EOL] cl += [string] [EOL] elif node . is_constant ( ) : [EOL] cl = [string] [EOL] elif node . is_special ( ) : [EOL] cl = f" [string] { type ( node . special ) . __name__ }" [EOL] else : [EOL] cl = [string] [EOL] if _has_error ( node . debug ) : [EOL] cl += [string] [EOL] if self . _class_gen : [EOL] return self . _class_gen ( self . _strip_cosmetic ( node ) , cl ) [EOL] else : [EOL] return cl [EOL] [EOL] def process_node ( self , node ) : [EOL] [docstring] [EOL] if node in self . processed : [EOL] return [EOL] [EOL] g = node . graph [EOL] self . follow ( node ) [EOL] cl = self . class_gen ( node ) [EOL] if g and g not in self . processed : [EOL] self . add_graph ( g ) [EOL] [EOL] if node . inputs and node . inputs [ [number] ] . is_constant ( ) : [EOL] fn = node . inputs [ [number] ] . value [EOL] if fn in cosmetics : [EOL] cosmetics [ fn ] ( self , node , g , cl ) [EOL] elif hasattr ( fn , [string] ) : [EOL] fn . graph_display ( self , node , g , cl ) [EOL] else : [EOL] self . process_node_generic ( node , g , cl ) [EOL] else : [EOL] self . process_node_generic ( node , g , cl ) [EOL] [EOL] self . processed . add ( node ) [EOL] [EOL] def process_edges ( self , edges ) : [EOL] [docstring] [EOL] for edge in edges : [EOL] src , lbl , dest = edge [EOL] if dest . is_constant ( ) and self . duplicate_constants : [EOL] self . follow ( dest ) [EOL] cid = self . fresh_id ( ) [EOL] self . cynode ( id = cid , parent = src . graph , label = self . label ( dest ) , classes = self . class_gen ( dest , [string] ) , node = dest , ) [EOL] self . cyedge ( src_id = src , dest_id = cid , label = lbl ) [EOL] elif ( self . duplicate_free_variables [EOL] and src . graph [EOL] and dest . graph [EOL] and src . graph is not dest . graph ) : [EOL] self . pool . add ( dest ) [EOL] cid = self . fresh_id ( ) [EOL] self . cynode ( id = cid , parent = src . graph , label = self . labeler . label ( dest , force = True ) , classes = self . class_gen ( dest , [string] ) , node = dest , ) [EOL] self . cyedge ( src_id = src , dest_id = cid , label = lbl ) [EOL] self . cyedge ( src_id = cid , dest_id = dest , label = ( lbl , [string] ) ) [EOL] self . cyedge ( src_id = src . graph , dest_id = dest . graph , label = ( [string] , [string] ) , ) [EOL] else : [EOL] self . pool . add ( dest ) [EOL] self . cyedge ( src_id = src , dest_id = dest , label = lbl ) [EOL] [EOL] def process_graph ( self , g ) : [EOL] [docstring] [EOL] self . add_graph ( g ) [EOL] for inp in g . parameters : [EOL] self . process_node ( inp ) [EOL] [EOL] if not g . return_ : [EOL] return [EOL] [EOL] ret = g . return_ . inputs [ [number] ] [EOL] if not ret . is_apply ( ) or ret . graph is not g : [EOL] ret = g . return_ [EOL] [EOL] self . returns . add ( ret ) [EOL] self . pool . add ( ret ) [EOL] [EOL] while self . pool : [EOL] node = self . pool . pop ( ) [EOL] self . process_node ( node ) [EOL] [EOL] def process ( self ) : [EOL] [docstring] [EOL] if self . nodes or self . edges : [EOL] return [EOL] while self . graphs : [EOL] g = self . graphs . pop ( ) [EOL] self . process_graph ( g ) [EOL] return self . nodes , self . edges [EOL] [EOL] def follow ( self , node ) : [EOL] [docstring] [EOL] if node . is_constant_graph ( ) and self . follow_references : [EOL] self . graphs . add ( node . value ) [EOL] [EOL] [EOL] class MyiaNodesPrinter ( GraphPrinter ) : [EOL] def __init__ ( self , nodes , * , duplicate_constants = True , duplicate_free_variables = True , function_in_node = True , tooltip_gen = None , class_gen = None , extra_style = None , ) : [EOL] super ( ) . __init__ ( { [string] : { [string] : [string] , [string] : [string] } } , tooltip_gen = tooltip_gen , extra_style = extra_style , ) [EOL] self . duplicate_constants = duplicate_constants [EOL] self . duplicate_free_variables = duplicate_free_variables [EOL] self . function_in_node = function_in_node [EOL] self . labeler = NodeLabeler ( function_in_node = function_in_node , relation_symbols = short_relation_symbols , ) [EOL] self . _class_gen = _make_class_gen ( class_gen ) [EOL] self . todo = set ( nodes ) [EOL] self . graphs = { node . graph for node in nodes if node . graph } [EOL] self . focus = set ( ) [EOL] [comment] [EOL] self . returns = { node for node in nodes if node . graph and node is node . graph . return_ } [EOL] [comment] [EOL] self . currid = [number] [EOL] [EOL] def name ( self , x ) : [EOL] [docstring] [EOL] return self . labeler . name ( x , force = True ) [EOL] [EOL] def label ( self , node , fn_label = None ) : [EOL] [docstring] [EOL] return self . labeler . label ( node , None , fn_label = fn_label ) [EOL] [EOL] def const_fn ( self , node ) : [EOL] [docstring] [EOL] return self . labeler . const_fn ( node ) [EOL] [EOL] def add_graph ( self , g ) : [EOL] [docstring] [EOL] name = self . name ( g ) [EOL] argnames = [ self . name ( p ) for p in g . parameters ] [EOL] lbl = f'{ name } [string] { [string] . join ( argnames ) } [string] ' [EOL] classes = [ [string] , [string] if g in self . focus else [string] ] [EOL] self . cynode ( id = g , label = lbl , classes = [string] . join ( classes ) ) [EOL] [comment] [EOL] [EOL] def process_node_generic ( self , node , g , cl ) : [EOL] [docstring] [EOL] if node . is_constant ( ) and self . duplicate_constants : [EOL] return [EOL] [EOL] lbl = self . label ( node ) [EOL] [EOL] self . cynode ( id = node , label = lbl , parent = g , classes = cl ) [EOL] [EOL] fn = node . inputs [ [number] ] if node . inputs else None [EOL] if fn and fn . is_constant_graph ( ) : [EOL] self . graphs . add ( fn . value ) [EOL] [EOL] for inp in node . inputs : [EOL] if inp . is_constant_graph ( ) : [EOL] self . cyedge ( src_id = g , dest_id = inp . value , label = ( [string] , [string] ) ) [EOL] [EOL] edges = [ ] [EOL] if fn and not ( fn . is_constant ( ) and self . function_in_node ) : [EOL] edges . append ( ( node , [string] , fn ) ) [EOL] [EOL] edges += [ ( node , i + [number] , inp ) for i , inp in enumerate ( node . inputs [ [number] : ] ) or [ ] ] [EOL] [EOL] self . process_edges ( edges ) [EOL] [EOL] def class_gen ( self , node , cl = None ) : [EOL] [docstring] [EOL] g = node . graph [EOL] if cl is not None : [EOL] pass [EOL] elif node in self . returns : [EOL] cl = [string] [EOL] elif node . is_parameter ( ) : [EOL] cl = [string] [EOL] if node not in g . parameters : [EOL] cl += [string] [EOL] elif node . is_constant ( ) : [EOL] cl = [string] [EOL] elif node . is_special ( ) : [EOL] cl = f" [string] { type ( node . special ) . __name__ }" [EOL] else : [EOL] cl = [string] [EOL] if _has_error ( node . debug ) : [EOL] cl += [string] [EOL] if self . _class_gen : [EOL] return self . _class_gen ( self . _strip_cosmetic ( node ) , cl ) [EOL] else : [EOL] return cl [EOL] [EOL] def process_node ( self , node ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] g = node . graph [EOL] [comment] [EOL] cl = self . class_gen ( node ) [EOL] [EOL] if node . inputs and node . inputs [ [number] ] . is_constant ( ) : [EOL] fn = node . inputs [ [number] ] . value [EOL] if fn in cosmetics : [EOL] cosmetics [ fn ] ( self , node , g , cl ) [EOL] elif hasattr ( fn , [string] ) : [EOL] fn . graph_display ( self , node , g , cl ) [EOL] else : [EOL] self . process_node_generic ( node , g , cl ) [EOL] else : [EOL] self . process_node_generic ( node , g , cl ) [EOL] [EOL] def process_edges ( self , edges ) : [EOL] [docstring] [EOL] for edge in edges : [EOL] src , lbl , dest = edge [EOL] if dest not in self . todo : [EOL] continue [EOL] if dest . is_constant ( ) and self . duplicate_constants : [EOL] cid = self . fresh_id ( ) [EOL] self . cynode ( id = cid , parent = src . graph , label = self . label ( dest ) , classes = self . class_gen ( dest , [string] ) , node = dest , ) [EOL] self . cyedge ( src_id = src , dest_id = cid , label = lbl ) [EOL] elif ( self . duplicate_free_variables [EOL] and src . graph [EOL] and dest . graph [EOL] and src . graph is not dest . graph ) : [EOL] cid = self . fresh_id ( ) [EOL] self . cynode ( id = cid , parent = src . graph , label = self . labeler . label ( dest , force = True ) , classes = self . class_gen ( dest , [string] ) , node = dest , ) [EOL] self . cyedge ( src_id = src , dest_id = cid , label = lbl ) [EOL] self . cyedge ( src_id = cid , dest_id = dest , label = ( lbl , [string] ) ) [EOL] self . cyedge ( src_id = src . graph , dest_id = dest . graph , label = ( [string] , [string] ) , ) [EOL] else : [EOL] self . cyedge ( src_id = src , dest_id = dest , label = lbl ) [EOL] [EOL] def process ( self ) : [EOL] [docstring] [EOL] if self . nodes or self . edges : [EOL] return [EOL] for g in self . graphs : [EOL] self . add_graph ( g ) [EOL] for node in self . todo : [EOL] self . process_node ( node ) [EOL] return self . nodes , self . edges [EOL] [EOL] [EOL] cosmetics = Registry ( ) [EOL] [EOL] [EOL] @ cosmetics . register ( primops . return_ ) def _cosmetic_node_return ( self , node , g , cl ) : [EOL] [docstring] [EOL] self . cynode ( id = node , label = [string] , parent = g , classes = [string] ) [EOL] ret = node . inputs [ [number] ] [EOL] self . process_edges ( [ ( node , [string] , ret ) ] ) [EOL] [EOL] [EOL] class GraphCosmeticPrimitive ( CosmeticPrimitive ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , label , on_edge = False ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( label ) [EOL] self . on_edge = on_edge [EOL] [EOL] def graph_display ( self , gprint , node , g , cl ) : [EOL] [docstring] [EOL] if gprint . function_in_node and self . on_edge : [EOL] lbl = gprint . label ( node , [string] ) [EOL] gprint . cynode ( id = node , label = lbl , parent = g , classes = cl ) [EOL] gprint . process_edges ( [ ( node , ( self . label , [string] ) , node . inputs [ [number] ] ) ] ) [EOL] else : [EOL] gprint . process_node_generic ( node , g , cl ) [EOL] [EOL] [EOL] make_tuple = GraphCosmeticPrimitive ( [string] ) [EOL] [EOL] [EOL] X = Var ( [string] ) [EOL] Y = Var ( [string] ) [EOL] Xs = SVar ( Var ( ) ) [EOL] V = var ( lambda x : x . is_constant ( ) ) [EOL] V1 = var ( lambda x : x . is_constant ( ) ) [EOL] V2 = var ( lambda x : x . is_constant ( ) ) [EOL] L = var ( lambda x : x . is_constant_graph ( ) ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . make_tuple , Xs ) def _opt_fancy_make_tuple ( optimizer , node , equiv ) : [EOL] xs = equiv [ Xs ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( [string] ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , * xs ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . tuple_getitem , X , V ) def _opt_fancy_getitem ( optimizer , node , equiv ) : [EOL] x = equiv [ X ] [EOL] v = equiv [ V ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( f" [string] { v . value } [string] " , on_edge = True ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( operations . resolve , V1 , V2 ) def _opt_fancy_resolve ( optimizer , node , equiv ) : [EOL] ns = equiv [ V1 ] [EOL] name = equiv [ V2 ] [EOL] with About ( node . debug , [string] ) : [EOL] lbl = f"{ ns . value . label } [string] { name . value }" [EOL] ct = Constant ( GraphCosmeticPrimitive ( lbl ) ) [EOL] return ct [EOL] [EOL] [EOL] @ pattern_replacer ( primops . record_getitem , X , V ) def _opt_fancy_record_getitem ( optimizer , node , equiv ) : [EOL] x = equiv [ X ] [EOL] v = equiv [ V ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( f"{ v . value }" , on_edge = True ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . unsafe_static_cast , X , V ) def _opt_fancy_unsafe_static_cast ( optimizer , node , equiv ) : [EOL] x = equiv [ X ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( f" [string] " , on_edge = True ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . hastag , X , V ) def _opt_fancy_hastag ( optimizer , node , equiv ) : [EOL] x = equiv [ X ] [EOL] v = equiv [ V ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( f" [string] { v . value }" , on_edge = True ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . casttag , X , V ) def _opt_fancy_casttag ( optimizer , node , equiv ) : [EOL] x = equiv [ X ] [EOL] v = equiv [ V ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( f" [string] { v . value }" , on_edge = True ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . tagged , X , V ) def _opt_fancy_tagged ( optimizer , node , equiv ) : [EOL] x = equiv [ X ] [EOL] v = equiv [ V ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( f" [string] { v . value }" , on_edge = True ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . array_map , V , Xs ) def _opt_fancy_array_map ( optimizer , node , equiv ) : [EOL] xs = equiv [ Xs ] [EOL] v = equiv [ V ] [EOL] if v . is_constant_graph ( ) : [EOL] return node [EOL] name = short_labeler . label ( v ) [EOL] ct = Constant ( GraphCosmeticPrimitive ( f" [string] { name } [string] " ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , * xs ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . distribute , X , V ) def _opt_fancy_distribute ( optimizer , node , equiv ) : [EOL] x = equiv [ X ] [EOL] v = equiv [ V ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( f" [string] { v . value }" , on_edge = True ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . scalar_to_array , X , V ) def _opt_fancy_scalar_to_array ( optimizer , node , equiv ) : [EOL] x = equiv [ X ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( f" [string] " , on_edge = True ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . array_to_scalar , X ) def _opt_fancy_array_to_scalar ( optimizer , node , equiv ) : [EOL] x = equiv [ X ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( f" [string] " , on_edge = True ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . transpose , X , V ) def _opt_fancy_transpose ( optimizer , node , equiv ) : [EOL] if equiv [ V ] . value == ( [number] , [number] ) : [EOL] x = equiv [ X ] [EOL] ct = Constant ( GraphCosmeticPrimitive ( f" [string] " , on_edge = True ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] else : [EOL] return node [EOL] [EOL] [EOL] @ pattern_replacer ( primops . array_reduce , primops . scalar_add , X , V ) def _opt_fancy_sum ( optimizer , node , equiv ) : [EOL] x = equiv [ X ] [EOL] shp = equiv [ V ] . value [EOL] ct = Constant ( GraphCosmeticPrimitive ( f' [string] { [string] . join ( map ( str , shp ) ) }' ) ) [EOL] with About ( node . debug , [string] ) : [EOL] return Apply ( [ ct , x ] , node . graph ) [EOL] [EOL] [EOL] @ pattern_replacer ( primops . distribute , ( primops . scalar_to_array , V , V2 ) , X ) def _opt_distributed_constant ( optimizer , node , equiv ) : [EOL] return equiv [ V ] [EOL] [EOL] [EOL] def cosmetic_transformer ( g ) : [EOL] [docstring] [EOL] spec = ( _opt_distributed_constant , _opt_fancy_make_tuple , _opt_fancy_getitem , _opt_fancy_resolve , _opt_fancy_record_getitem , _opt_fancy_array_map , _opt_fancy_distribute , _opt_fancy_transpose , _opt_fancy_sum , _opt_fancy_unsafe_static_cast , _opt_fancy_scalar_to_array , _opt_fancy_array_to_scalar , _opt_fancy_hastag , _opt_fancy_casttag , _opt_fancy_tagged , ) [EOL] nmap = NodeMap ( ) [EOL] for optim in spec : [EOL] nmap . register ( getattr ( optim , [string] , None ) , optim ) [EOL] optim = LocalPassOptimizer ( nmap ) [EOL] optim ( g ) [EOL] return g [EOL] [EOL] [EOL] @ mixin ( ir . Graph ) class _Graph : [EOL] @ classmethod def __hrepr_resources__ ( cls , H ) : [EOL] [docstring] [EOL] return GraphPrinter . __hrepr_resources__ ( H ) [EOL] [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] [docstring] [EOL] if hrepr . config . depth > [number] and not hrepr . config . graph_expand_all : [EOL] label = short_labeler . label ( self , True ) [EOL] return H . span [ [string] , f" [string] " ] ( label ) [EOL] dc = hrepr . config . duplicate_constants [EOL] dfv = hrepr . config . duplicate_free_variables [EOL] fin = hrepr . config . function_in_node [EOL] fr = hrepr . config . follow_references [EOL] tgen = hrepr . config . node_tooltip [EOL] cgen = hrepr . config . node_class [EOL] xsty = hrepr . config . graph_style [EOL] beau = hrepr . config . graph_beautify [EOL] gpr = MyiaGraphPrinter ( { self } , duplicate_constants = True if dc is None else dc , duplicate_free_variables = True if dfv is None else dfv , function_in_node = True if fin is None else fin , follow_references = True if fr is None else fr , tooltip_gen = tgen , class_gen = cgen , extra_style = xsty , beautify = True if beau is None else beau , ) [EOL] gpr . process ( ) [EOL] return gpr . __hrepr__ ( H , hrepr ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ mixin ( ir . ANFNode ) class _ANFNode : [EOL] @ classmethod def __hrepr_resources__ ( cls , H ) : [EOL] [docstring] [EOL] return H . style ( mcss ) [EOL] [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] class_name = self . __class__ . __name__ . lower ( ) [EOL] label = short_labeler . label ( self , True ) [EOL] return H . span [ [string] , f" [string] { class_name }" ] ( label ) [EOL] [EOL] [EOL] @ mixin ( ir . Apply ) class _Apply : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] if ( len ( self . inputs ) == [number] [EOL] and isinstance ( self . inputs [ [number] ] , Constant ) [EOL] and self . inputs [ [number] ] . value is primops . return_ ) : [EOL] if hasattr ( hrepr , [string] ) : [EOL] return hrepr . hrepr_nowrap ( self . inputs [ [number] ] ) [ [string] ] [EOL] else : [EOL] return hrepr ( self . inputs [ [number] ] ) [ [string] ] [EOL] else : [EOL] return super ( Apply , self ) . __hrepr__ ( H , hrepr ) [EOL] [EOL] [EOL] @ mixin ( ParentProxy ) class _ParentProxy : [EOL] @ classmethod def __hrepr_resources__ ( cls , H ) : [EOL] [docstring] [EOL] return H . style ( mcss ) [EOL] [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] class_name = [string] [EOL] label = [string] + short_labeler . label ( self . graph , True ) [EOL] return H . span [ [string] , f" [string] { class_name }" ] ( label ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ mixin ( utils . NS ) class _NS : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr ( self . __dict__ ) [EOL] [EOL] [EOL] @ mixin ( utils . OrderedSet ) class _OrderedSet : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr ( set ( self . _d . keys ( ) ) ) [EOL] [EOL] [EOL] @ mixin ( utils . SymbolicKeyInstance ) class _SymbolicKeyInstance : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , ( ( [string] , self . node ) , ) ) [EOL] [EOL] [EOL] @ mixin ( abstract . VirtualReference ) class _VirtualReference : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , self . values . items ( ) ) [EOL] [EOL] [EOL] @ mixin ( abstract . Reference ) class _Reference : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , ( ( [string] , self . node ) , ( [string] , self . context ) ) ) [EOL] [EOL] [EOL] @ mixin ( abstract . Context ) class _Context : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] stack = [ ] [EOL] curr = self [EOL] while curr : [EOL] stack . append ( ( curr . graph , curr . argkey ) ) [EOL] curr = curr . parent [EOL] return hrepr . stdrepr_object ( [string] , stack ) [EOL] [EOL] [EOL] @ mixin ( parser . Location ) class _Location : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return H . div ( H . style ( [string] ) , H . codeSnippet ( src = self . filename , language = [string] , line = self . line , column = self . column + [number] , context = hrepr . config . snippet_context or [number] , ) , ) [EOL] [EOL] [EOL] @ mixin ( info . DebugInfo ) class _DebugInfo : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] exclude = { [string] , [string] } [EOL] [EOL] def mkdict ( info ) : [EOL] d = { k : v for k , v in info . __dict__ . items ( ) if not k . startswith ( [string] ) and k not in exclude } [EOL] tr = d . get ( [string] , None ) [EOL] if tr : [EOL] fr = tr [ - [number] ] [EOL] d [ [string] ] = parser . Location ( fr . filename , fr . lineno , [number] , fr . lineno , [number] , None ) [EOL] d [ [string] ] = short_labeler . label ( info ) [EOL] return d [EOL] [EOL] tabs = [ ] [EOL] info = self [EOL] while getattr ( info , [string] , None ) : [EOL] tabs . append ( ( info , info . about . relation ) ) [EOL] info = info . about . debug [EOL] tabs . append ( ( info , [string] ) ) [EOL] [EOL] rval = H . boxTabs ( ) [EOL] for info , rel in tabs : [EOL] pane = hrepr ( mkdict ( info ) ) [EOL] rval = rval ( H . tabEntry ( H . tabLabel ( rel ) , H . tabPane ( pane ) ) ) [EOL] [EOL] return rval [EOL] [EOL] [EOL] @ mixin ( ir . GraphManager ) class _GraphManager : [EOL] @ classmethod def __hrepr_resources__ ( cls , H ) : [EOL] return GraphPrinter . __hrepr_resources__ ( H ) [EOL] [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] pr = GraphPrinter ( { [string] : { [string] : [string] , [string] : [string] } } ) [EOL] [EOL] mode = hrepr . config . manager_mode or [string] [EOL] [EOL] def lbl ( x ) : [EOL] if isinstance ( x , ParentProxy ) : [EOL] return f"{ short_labeler . label ( x . graph ) } [string] " [EOL] else : [EOL] return short_labeler . label ( x ) [EOL] [EOL] if mode == [string] : [EOL] graph = { g : set ( ) if parent is None else { parent } for g , parent in self . parents . items ( ) } [EOL] elif mode == [string] : [EOL] graph = self . children [EOL] elif mode == [string] : [EOL] graph = self . graph_dependencies_direct [EOL] elif mode == [string] : [EOL] graph = self . graph_dependencies_total [EOL] else : [EOL] raise Exception ( f' [string] { mode } [string] ' ) [EOL] [EOL] for g , deps in graph . items ( ) : [EOL] pr . cynode ( g , lbl ( g ) , [string] ) [EOL] for dep in deps : [EOL] pr . cynode ( dep , lbl ( dep ) , [string] ) [EOL] pr . cynode ( dep , lbl ( dep ) , [string] ) [EOL] pr . cyedge ( g , dep , [string] ) [EOL] return pr . __hrepr__ ( H , hrepr ) [EOL] [EOL] [EOL] @ mixin ( vm . VMFrame ) class _VMFrame : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , [ ( [string] , self . graph ) , ( [string] , self . values ) , ( [string] , self . closure ) , ( [string] , self . todo ) , ( [string] , [ x . graph in ( None , self . graph ) for x in self . todo ] , ) , ] , ) [EOL] [EOL] [EOL] @ mixin ( vm . Closure ) class _Closure : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , [ ( [string] , self . graph ) , ( [string] , self . values ) ] ) [EOL] [EOL] [EOL] @ mixin ( opt . PatternSubstitutionOptimization ) class _PatternSubstitutionOptimization : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return H . span [ [string] ] ( H . b ( [string] ) , self . name ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ mixin ( xtype . TypeMeta ) class _TypeMeta : [EOL] def __hrepr__ ( cls , H , hrepr ) : [EOL] return cls . __type_hrepr__ ( H , hrepr ) [EOL] [EOL] @ classmethod def __hrepr_resources__ ( cls , H ) : [EOL] return H . style ( mcss ) [EOL] [EOL] [EOL] @ mixin ( xtype . Type ) class _Type : [EOL] @ classmethod def __type_hrepr__ ( cls , H , hrepr ) : [EOL] return H . span ( str ( cls ) ) [EOL] [EOL] [EOL] @ mixin ( xtype . Bool ) class _Bool : [EOL] @ classmethod def __type_hrepr__ ( cls , H , hrepr ) : [EOL] return H . div [ [string] ] ( [string] ) [EOL] [EOL] [EOL] @ mixin ( xtype . Int ) class _Int : [EOL] @ classmethod def __type_hrepr__ ( cls , H , hrepr ) : [EOL] if cls is Int : [EOL] return H . span ( [string] ) [EOL] else : [EOL] return H . span [ [string] ] ( H . sub ( cls . bits ) ) [EOL] [EOL] [EOL] @ mixin ( xtype . UInt ) class _UInt : [EOL] @ classmethod def __type_hrepr__ ( cls , H , hrepr ) : [EOL] if cls is UInt : [EOL] return H . span ( [string] ) [EOL] else : [EOL] return H . span [ [string] ] ( H . sub ( cls . bits ) ) [EOL] [EOL] [EOL] @ mixin ( xtype . Float ) class _Float : [EOL] @ classmethod def __type_hrepr__ ( cls , H , hrepr ) : [EOL] if cls is Float : [EOL] return H . span ( [string] ) [EOL] else : [EOL] return H . span [ [string] ] ( H . sub ( cls . bits ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ mixin ( utils . Var ) class _Var : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] self . ensure_tag ( ) [EOL] return H . div [ [string] ] ( f"{ self . tag }" ) [EOL] [EOL] [EOL] @ mixin ( utils . FilterVar ) class _FilterVar : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] if hrepr . config . short_vars : [EOL] return Var . __hrepr__ ( self , H , hrepr ) [EOL] else : [EOL] self . ensure_tag ( ) [EOL] return H . div [ [string] , [string] ] ( f"{ self . tag } [string] { self . filter }" ) [EOL] [EOL] [EOL] class Subgraph : [EOL] def __init__ ( self , * nodes , depth = [number] , context = [number] ) : [EOL] nodes = set ( nodes ) [EOL] for i in range ( depth ) : [EOL] for n in list ( nodes ) : [EOL] nodes . update ( n . inputs ) [EOL] if context != [number] : [EOL] for n in nodes : [EOL] if n . graph is not None : [EOL] mng = n . graph . manager [EOL] for i in range ( context ) : [EOL] for n in list ( nodes ) : [EOL] nodes . update ( n2 for n2 , _ in mng . uses [ n ] ) [EOL] self . nodes = nodes [EOL] [EOL] @ classmethod def __hrepr_resources__ ( cls , H ) : [EOL] [docstring] [EOL] return GraphPrinter . __hrepr_resources__ ( H ) [EOL] [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] dc = hrepr . config . duplicate_constants [EOL] dfv = hrepr . config . duplicate_free_variables [EOL] fin = hrepr . config . function_in_node [EOL] tgen = hrepr . config . node_tooltip [EOL] cgen = hrepr . config . node_class [EOL] xsty = hrepr . config . graph_style [EOL] gpr = MyiaNodesPrinter ( self . nodes , duplicate_constants = True if dc is None else dc , duplicate_free_variables = True if dfv is None else dfv , function_in_node = True if fin is None else fin , tooltip_gen = tgen , class_gen = cgen , extra_style = xsty , ) [EOL] gpr . process ( ) [EOL] return gpr . __hrepr__ ( H , hrepr ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ mixin ( abstract . PendingTentative ) class _PendingTentative : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , ( ( [string] , self . tentative ) , ( [string] , self . priority ( ) ) ) , ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def _clean ( values ) : [EOL] return { k : v for k , v in values . items ( ) if v not in { ANYTHING , UNKNOWN } } [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractValue ) class _AbstractValue : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( type ( self ) . __qualname__ . replace ( [string] , [string] ) , _clean ( self . values ) . items ( ) , delimiter = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractScalar ) class _AbstractScalar : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( f" [string] " , _clean ( self . values ) . items ( ) , delimiter = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractFunction ) class _AbstractFunction : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] v = self . values [ VALUE ] [EOL] return hrepr . stdrepr_iterable ( v if isinstance ( v , Possibilities ) else [ v ] , before = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractJTagged ) class _AbstractJTagged : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_iterable ( [ H . div ( hrepr . stdrepr_object ( [string] , _clean ( self . values ) . items ( ) , delimiter = [string] , cls = [string] , ) , hrepr ( self . element ) , style = [string] , ) ] , before = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractType ) class _AbstractType : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_iterable ( [ H . div ( hrepr . stdrepr_object ( [string] , _clean ( self . values ) . items ( ) , delimiter = [string] , cls = [string] , ) , hrepr ( self . element ) , style = [string] , ) ] , before = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractHandle ) class _AbstractHandle : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_iterable ( [ H . div ( hrepr . stdrepr_object ( [string] , _clean ( self . values ) . items ( ) , delimiter = [string] , cls = [string] , ) , hrepr ( self . element ) , style = [string] , ) ] , before = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractKeywordArgument ) class _AbstractKeywordArgument : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_iterable ( [ H . span ( self . key ) , H . div ( hrepr . stdrepr_object ( [string] , _clean ( self . values ) . items ( ) , delimiter = [string] , cls = [string] , ) , hrepr ( self . argument ) , style = [string] , ) , ] , before = [string] , cls = [string] , ) [EOL] [EOL] [EOL] def _toseq ( xs ) : [EOL] if not isinstance ( xs , ( list , tuple , Possibilities ) ) : [EOL] xs = [ xs ] [EOL] return xs [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractTuple ) class _AbstractTuple : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_iterable ( _toseq ( self . elements ) , before = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractUnion ) class _AbstractUnion : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_iterable ( _toseq ( self . options ) , before = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractTaggedUnion ) class _AbstractTaggedUnion : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] v = self . options [EOL] if isinstance ( v , ( Possibilities , list ) ) : [EOL] return hrepr . stdrepr_object ( f" [string] " , self . options , delimiter = [string] , cls = [string] ) [EOL] else : [EOL] return hrepr . stdrepr_iterable ( [ v ] , before = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractArray ) class _AbstractArray : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_iterable ( [ H . div ( hrepr . stdrepr_object ( [string] , _clean ( self . values ) . items ( ) , delimiter = [string] , cls = [string] , ) , hrepr ( self . element ) , style = [string] , ) ] , before = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractClassBase ) class _AbstractClassBase : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( f" [string] { self . tag . __qualname__ }" , self . attributes . items ( ) , delimiter = [string] , cls = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . GraphFunction ) class _GraphFunction : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] optkey = ( [ ( [string] , self . tracking_id ) ] [EOL] if self . tracking_id is not None [EOL] else [ ] ) [EOL] return hrepr . stdrepr_object ( [string] , ( ( [string] , self . graph ) , ( [string] , self . context ) , * optkey ) , delimiter = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . PartialApplication ) class _PartialApplication : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , ( ( [string] , self . fn ) , ( [string] , self . args ) ) , delimiter = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . TypedPrimitive ) class _TypedPrimitive : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , ( ( [string] , self . prim ) , ( [string] , self . args ) , ( [string] , self . output ) ) , delimiter = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . MetaGraphFunction ) class _MetaGraphFunction : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , ( ( [string] , self . metagraph ) , ) , delimiter = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . PrimitiveFunction ) class _PrimitiveFunction : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , ( ( [string] , self . prim ) , ) , delimiter = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . TransformedFunction ) class _TransformedFunction : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , ( ( [string] , self . fn ) , ( [string] , self . transform ) ) , delimiter = [string] , ) [EOL] [EOL] [EOL] @ mixin ( abstract . AbstractFunctionUnique ) class _AbstractFunctionUnique : [EOL] def __hrepr__ ( self , H , hrepr ) : [EOL] return hrepr . stdrepr_object ( [string] , ( ( [string] , self . args ) , ( [string] , self . output ) ) , delimiter = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.debug.label.NodeLabeler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $myia.ir.clone.GraphCloner$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $myia.ir.clone.GraphCloner$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $myia.ir.clone.GraphCloner$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.misc.Registry[typing.Any,typing.Any]$ 0 0 $myia.utils.misc.Registry[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.debug.label.NodeLabeler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.misc.Registry[typing.Any,typing.Any]$ 0 0 $myia.utils.misc.Registry[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.misc.Registry[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $myia.utils.misc.Registry[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.GraphCosmeticPrimitive$ 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.GraphCosmeticPrimitive$ 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 $myia.utils.unify.Var$ 0 0 $myia.utils.unify.SVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.utils.unify.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.MyiaGraphPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.MyiaGraphPrinter$ 0 0 0 0 0 0 $debug.gprint.MyiaGraphPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.GraphPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.GraphPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.GraphPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.GraphPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.GraphPrinter$ 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.GraphPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.MyiaNodesPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $debug.gprint.MyiaNodesPrinter$ 0 0 0 0 0 0 $debug.gprint.MyiaNodesPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[typing.Tuple[builtins.str,unknown]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[typing.Tuple[builtins.str,unknown]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Dict , Tuple , Set , Union , List [EOL] import myia_frontend_pytorch [EOL] import torch [EOL] import typing [EOL] import myia [EOL] [docstring] [EOL] [EOL] import copy [EOL] import types [EOL] from collections import OrderedDict [EOL] [EOL] import torch [EOL] [EOL] from myia import operations [EOL] from myia . abstract . data import ( ALIASID , ANYTHING , SHAPE , TYPE , VALUE , AbstractArray , AbstractScalar , ) [EOL] from myia . abstract . infer import to_abstract [EOL] from myia . classes import ADT [EOL] from myia . hypermap import hyper_map [EOL] from myia . operations import primitives as P [EOL] from myia . pipeline . resources import default_convert [EOL] from myia . pipeline . standard import standard_method_map , standard_object_map [EOL] from myia . public_api import ( _max , _sum , argmax , cat , chunk , conv2d , conv_transpose2d , cross_entropy , embedding , gather , item , linear , log_softmax , lstm_cell , max_pool2d , mean , mse_loss , nll_loss , norm , relu , reshape , scatter , scatter_add , sigmoid , size , smooth_l1_loss , softmax , split , squeeze , stack , std , transpose , unsqueeze , var , view_as , ) [EOL] from myia . utils import OrderedSet , core , get_fields [EOL] from myia . xtype import NDArray , f32 [EOL] [EOL] from . pytorch_abstract_types import ( APT , AbstractModule , PyTorchTensor , pytorch_dtype_to_type , ) [EOL] [EOL] [EOL] @ core def zeros ( * shp , dtype = None ) : [EOL] [docstring] [EOL] if dtype is None : [EOL] dtype = f32 [EOL] [EOL] if len ( shp ) == [number] : [EOL] if isinstance ( shp [ [number] ] , tuple ) : [EOL] shp = shp [ [number] ] [EOL] return P . distribute ( P . scalar_to_array ( P . scalar_cast ( [number] , dtype ) , APT ) , shp ) [EOL] [EOL] [EOL] standard_object_map . update ( { torch . abs : operations . array_abs , torch . argmax : argmax , torch . cat : cat , torch . chunk : chunk , torch . detach : operations . stop_gradient , torch . einsum : operations . einsum , torch . eq : operations . array_eq , torch . exp : operations . array_exp , torch . gather : gather , torch . log : operations . array_log , torch . log_softmax : log_softmax , torch . lstm_cell : lstm_cell , torch . max : _max , torch . mean : mean , torch . mm : P . dot , torch . norm : norm , torch . pow : operations . array_pow , torch . relu : relu , torch . reshape : reshape , torch . scatter : scatter , torch . scatter_add : scatter_add , torch . sigmoid : sigmoid , torch . sign : operations . array_sign , torch . softmax : softmax , torch . split : split , torch . squeeze : squeeze , torch . stack : stack , torch . std : std , torch . sum : _sum , torch . t : operations . t , torch . tanh : operations . array_tanh , torch . transpose : transpose , torch . unsqueeze : unsqueeze , torch . var : var , torch . nn . functional . conv2d : conv2d , torch . nn . functional . conv_transpose2d : conv_transpose2d , torch . nn . functional . cross_entropy : cross_entropy , torch . nn . functional . embedding : embedding , torch . nn . functional . linear : linear , torch . nn . functional . log_softmax : log_softmax , torch . nn . functional . max_pool2d : max_pool2d , torch . nn . functional . mse_loss : mse_loss , torch . nn . functional . nll_loss : nll_loss , torch . nn . functional . smooth_l1_loss : smooth_l1_loss , torch . zeros : zeros , } ) [EOL] [EOL] [EOL] standard_method_map [ PyTorchTensor ] = standard_method_map [ NDArray ] . copy ( ) [EOL] standard_method_map [ PyTorchTensor ] . update ( { [string] : operations . array_abs , [string] : argmax , [string] : chunk , [string] : operations . stop_gradient , [string] : operations . ndim , [string] : property ( operations . dtype ) , [string] : operations . array_eq , [string] : operations . array_exp , [string] : gather , [string] : item , [string] : operations . array_log , [string] : log_softmax , [string] : _max , [string] : mean , [string] : P . transpose , [string] : operations . array_pow , [string] : relu , [string] : reshape , [string] : scatter , [string] : scatter_add , [string] : sigmoid , [string] : property ( operations . shape ) , [string] : operations . array_sign , [string] : size , [string] : softmax , [string] : split , [string] : squeeze , [string] : std , [string] : _sum , [string] : operations . t , [string] : transpose , [string] : operations . array_tanh , [string] : unsqueeze , [string] : var , [string] : reshape , [string] : view_as , [string] : operations . zeros_like , } ) [EOL] [EOL] [EOL] [comment] [EOL] @ core def mod_sub ( self , x ) : [EOL] [docstring] [EOL] return hyper_map ( operations . sub , self , x ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] blacklist = set ( dir ( torch . nn . Module ( ) ) ) [EOL] blacklist . add ( [string] ) [EOL] blacklist . add ( [string] ) [EOL] [EOL] [EOL] @ to_abstract . register def _to_abstract ( self , v , ** kwargs ) : [EOL] standard_method_map [ type ( v ) ] = { [string] : getattr ( type ( v ) , [string] ) , [string] : mod_sub , } [EOL] fields = { } [EOL] for var_k in dir ( v ) : [EOL] if ( var_k not in blacklist ) or ( var_k in ( [string] , [string] ) ) : [EOL] var_v = getattr ( v , var_k ) [EOL] if not isinstance ( var_v , types . MethodType ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if var_k not in ( [string] , [string] ) or ( isinstance ( v , torch . nn . Sequential ) [EOL] and var_v != OrderedDict ( ) ) : [EOL] [EOL] fields [ var_k ] = self ( var_v , ** kwargs ) [EOL] else : [EOL] pass [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not isinstance ( v , torch . nn . Sequential ) : [EOL] for mod_k , mod_v in v . _modules . items ( ) : [EOL] fields [ mod_k ] = self ( mod_v , ** kwargs ) [EOL] [EOL] for par_k , par_v in v . _parameters . items ( ) : [EOL] fields [ par_k ] = self ( par_v , ** kwargs ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] names = list ( fields . keys ( ) ) [EOL] [EOL] def new_module ( * args ) : [EOL] nonlocal v [EOL] [comment] [EOL] [comment] [EOL] v = copy . deepcopy ( v ) [EOL] for k , a in zip ( names , args ) : [EOL] if isinstance ( getattr ( v , k ) , torch . nn . Parameter ) : [EOL] setattr ( v , k , torch . nn . Parameter ( a ) ) [EOL] else : [EOL] setattr ( v , k , a ) [EOL] return v [EOL] [EOL] return AbstractModule ( v . __class__ , fields , constructor = new_module ) [EOL] [EOL] [EOL] @ to_abstract . register def _to_abstract ( self , v , ** kwargs ) : [EOL] return AbstractArray ( AbstractScalar ( { VALUE : ANYTHING , TYPE : pytorch_dtype_to_type ( v . dtype ) } ) , { SHAPE : tuple ( v . shape ) , TYPE : PyTorchTensor } , ) [EOL] [EOL] [EOL] @ to_abstract . register def _to_abstract ( self , v , alias_map = { } , ** kwargs ) : [EOL] tracks = { SHAPE : tuple ( v . shape ) , TYPE : PyTorchTensor } [EOL] if id ( v ) in alias_map : [EOL] tracks [ ALIASID ] = alias_map [ id ( v ) ] [EOL] return AbstractArray ( AbstractScalar ( { VALUE : ANYTHING , TYPE : pytorch_dtype_to_type ( v . dtype ) } ) , tracks , ) [EOL] [EOL] [EOL] @ default_convert . register def _default_convert ( env , x ) : [EOL] return default_convert ( env , pytorch_dtype_to_type ( x ) ) [EOL] [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] @ get_fields . register def _get_fields ( instance ) : [EOL] blacklist = OrderedSet ( dir ( torch . nn . Module ( ) ) ) [EOL] blacklist . add ( [string] ) [EOL] blacklist . add ( [string] ) [EOL] [EOL] blacklist . remove ( [string] ) [EOL] blacklist . remove ( [string] ) [EOL] [EOL] keys = OrderedSet ( dir ( instance ) ) - blacklist [EOL] d = { } [EOL] [EOL] for k in keys : [EOL] d [ k ] = getattr ( instance , k ) [EOL] return d [EOL] [EOL] [EOL] def tensor_pytorch_aliasable ( v , vseq , path ) : [EOL] [docstring] [EOL] if isinstance ( v , torch . Tensor ) : [EOL] if any ( isinstance ( x , ( list , ADT ) ) for x in vseq ) : [EOL] return [string] [EOL] else : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import myia [EOL] [docstring] [EOL] [EOL] from myia . abstract . data import ( ANYTHING , SHAPE , TYPE , VALUE , AbstractArray , AbstractClassBase , AbstractScalar , ) [EOL] from myia . utils import MyiaInputTypeError [EOL] from myia . xtype import Bool , Float , Int , Object , UInt [EOL] [EOL] [EOL] class PyTorchTensor ( Object ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def to_numpy ( self , x ) : [EOL] [docstring] [EOL] import torch [EOL] [EOL] if not isinstance ( x , torch . Tensor ) : [EOL] raise MyiaInputTypeError ( f" [string] { x } [string] " ) [EOL] return x . detach ( ) . cpu ( ) . numpy ( ) [EOL] [EOL] @ classmethod def from_numpy ( self , x ) : [EOL] [docstring] [EOL] import torch [EOL] [EOL] return torch . from_numpy ( x ) [EOL] [EOL] [EOL] class AbstractModule ( AbstractClassBase ) : [EOL] [docstring] [EOL] [EOL] def user_defined_version ( self ) : [EOL] [docstring] [EOL] return AbstractModule ( self . tag , { attr : ANYTHING for attr in self . attributes } , constructor = self . constructor , ) [EOL] [EOL] [EOL] def pytorch_dtype_to_type ( dtype ) : [EOL] [docstring] [EOL] import torch [EOL] [EOL] _type_map = { torch . int8 : Int [ [number] ] , torch . int16 : Int [ [number] ] , torch . int32 : Int [ [number] ] , torch . int64 : Int [ [number] ] , torch . uint8 : UInt [ [number] ] , torch . float16 : Float [ [number] ] , torch . float32 : Float [ [number] ] , torch . float64 : Float [ [number] ] , torch . bool : Bool , } [EOL] if dtype not in _type_map : [EOL] raise TypeError ( f" [string] { dtype }" ) [EOL] return _type_map [ dtype ] [EOL] [EOL] [EOL] APT = AbstractArray ( AbstractScalar ( { TYPE : ANYTHING , VALUE : ANYTHING } ) , { SHAPE : ANYTHING , TYPE : PyTorchTensor } , ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $myia.abstract.data.AbstractArray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL] [EOL] from . pytorch import * [EOL]	$builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import _importlib_modulespec [EOL] import typing [EOL] [docstring] [EOL] [EOL] import importlib [EOL] import os [EOL] [EOL] [comment] [EOL] operations_ignore = [ [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] opinit_prelude = [string] [EOL] [EOL] [EOL] [comment] [EOL] prim_prelude = [string] [comment] [EOL] [EOL] [EOL] [comment] [EOL] op_format = [string] [EOL] [EOL] [EOL] [comment] [EOL] prim_format = [string] [EOL] [EOL] [EOL] def regen ( ) : [EOL] [docstring] [EOL] regen_operations ( ) [EOL] [EOL] [EOL] def regen_operations ( ) : [EOL] [docstring] [EOL] oppaths = { } [EOL] operations = { } [EOL] primitives = { } [EOL] [EOL] def addop ( module_name , data ) : [EOL] data [ [string] ] = module_name [EOL] oppaths [ module_name ] = data [EOL] operations [ data [ [string] ] ] = data [EOL] [EOL] def addprim ( module_name , data ) : [EOL] data [ [string] ] = module_name [EOL] primclass = { [string] : [string] , [string] : [string] , [string] : [string] , } [ data [ [string] ] ] [EOL] data [ [string] ] = primclass [EOL] primitives [ data [ [string] ] ] = data [EOL] [EOL] for entry in os . listdir ( [string] ) : [EOL] if entry in operations_ignore : [EOL] continue [EOL] if entry . startswith ( [string] ) : [EOL] continue [EOL] if not entry . endswith ( [string] ) : [EOL] continue [EOL] [EOL] module_name = f" [string] { entry [ : - [number] ] }" [EOL] mod = importlib . import_module ( module_name ) [EOL] if hasattr ( mod , [string] ) : [EOL] addop ( module_name , mod . __operation_defaults__ ) [EOL] if hasattr ( mod , [string] ) : [EOL] addprim ( module_name , mod . __primitive_defaults__ ) [EOL] [EOL] for name , thing in vars ( mod ) . items ( ) : [EOL] if name . startswith ( [string] ) : [EOL] continue [EOL] path = f"{ module_name } [string] { name }" [EOL] if isinstance ( thing , dict ) and [string] in thing : [EOL] if [string] in thing : [EOL] addprim ( path , thing ) [EOL] else : [EOL] addop ( path , thing ) [EOL] [EOL] oppath = [string] [EOL] with open ( oppath , [string] ) as opfile : [EOL] print ( opinit_prelude , file = opfile ) [EOL] for regname , data in sorted ( operations . items ( ) ) : [EOL] print ( op_format . format ( ** data ) , file = opfile ) [EOL] print ( f" [string] { oppath }" ) [EOL] [EOL] primpath = [string] [EOL] with open ( primpath , [string] ) as primfile : [EOL] print ( prim_prelude , file = primfile ) [EOL] for regname , data in sorted ( primitives . items ( ) ) : [EOL] print ( prim_format . format ( ** data ) , file = primfile ) [EOL] print ( f" [string] { primpath }" ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] regen ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [comment] [EOL] [EOL] import os [EOL] import sys [EOL] [EOL] from scripts . regen import regen_operations [EOL] [EOL] here = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] [EOL] [EOL] def parse_subs ( subs ) : [EOL] return dict ( sub . split ( [string] ) for sub in subs ) [EOL] [EOL] [EOL] def template ( type , subs ) : [EOL] contents = open ( f"{ here } [string] { type } [string] " ) . read ( ) [EOL] for key , repl in subs . items ( ) : [EOL] contents = contents . replace ( key , repl ) [EOL] return contents [EOL] [EOL] [EOL] def make_op ( subs ) : [EOL] subs = parse_subs ( subs ) [EOL] name = subs [ [string] ] [EOL] op_contents = template ( [string] , subs ) [EOL] test_contents = template ( [string] , subs ) [EOL] [EOL] filename = f" [string] { name } [string] " [EOL] open ( filename , [string] ) . write ( op_contents ) [EOL] print ( [string] , filename ) [EOL] [EOL] filename = f" [string] { name } [string] " [EOL] open ( filename , [string] ) . write ( test_contents ) [EOL] print ( [string] , filename ) [EOL] [EOL] regen_operations ( ) [EOL] [EOL] [EOL] def make_macro ( subs ) : [EOL] subs = parse_subs ( subs ) [EOL] name = subs [ [string] ] [EOL] macro_contents = template ( [string] , subs ) [EOL] test_contents = template ( [string] , subs ) [EOL] [EOL] filename = f" [string] { name } [string] " [EOL] open ( filename , [string] ) . write ( macro_contents ) [EOL] print ( [string] , filename ) [EOL] [EOL] filename = f" [string] { name } [string] " [EOL] open ( filename , [string] ) . write ( test_contents ) [EOL] print ( [string] , filename ) [EOL] [EOL] regen_operations ( ) [EOL] [EOL] [EOL] def make_prim ( subs ) : [EOL] subs = parse_subs ( subs ) [EOL] name = subs [ [string] ] [EOL] prim_contents = template ( [string] , subs ) [EOL] test_contents = template ( [string] , subs ) [EOL] [EOL] filename = f" [string] { name } [string] " [EOL] open ( filename , [string] ) . write ( prim_contents ) [EOL] print ( [string] , filename ) [EOL] [EOL] filename = f" [string] { name } [string] " [EOL] open ( filename , [string] ) . write ( test_contents ) [EOL] print ( [string] , filename ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] filename = f" [string] " [EOL] line = f"{ name } [string] { name } [string] " [EOL] open ( filename , [string] ) . write ( line ) [EOL] [EOL] filename = f" [string] " [EOL] line = f"{ name } [string] { name } [string] " [EOL] open ( filename , [string] ) . write ( line ) [EOL] [EOL] regen_operations ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] type , * subs = sys . argv [ [number] : ] [EOL] globals ( ) [ f" [string] { type }" ] ( subs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0