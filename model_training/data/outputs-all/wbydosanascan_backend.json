from setuptools import setup [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0
from typing import ClassVar , Type [EOL] import sanascan_backend [EOL] import typing [EOL] from typing import ClassVar [EOL] from pathlib import Path [EOL] import unittest [EOL] [EOL] from sanascan_backend . lang_model import LangModel [EOL] [EOL] [EOL] with ( Path . home ( ) / [string] ) . open ( ) as f : [EOL] LM = LangModel ( f . read ( ) ) [EOL] [EOL] [EOL] class UseLangModel ( unittest . TestCase ) : [EOL] LM = ClassVar [ LangModel ] [EOL] [EOL] @ classmethod def setUpClass ( klass ) : [EOL] klass . LM = LM [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import sanascan_backend [EOL] import typing [EOL] import unittest [EOL] [EOL] from sanascan_backend . word import Word , TagWord [EOL] from sanascan_backend . key import Key [EOL] [EOL] [EOL] class TestKey ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . hoge = Word ( surface = [string] , yomi = [string] ) [EOL] self . fuga = Word ( surface = [string] , yomi = [string] ) [EOL] [EOL] self . key = Key ( [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_from_words ( self ) : [EOL] with self . subTest ( ) : [EOL] k1 = Key . from_words ( [ self . hoge ] ) [EOL] k2 = Key ( [ [number] , [number] ] ) [EOL] self . assertEqual ( k1 , k2 ) [EOL] [EOL] with self . subTest ( ) : [EOL] k1 = Key . from_words ( [ self . hoge , self . fuga ] ) [EOL] k2 = Key ( [ [number] , [number] , [number] , [number] ] ) [EOL] self . assertEqual ( k1 , k2 ) [EOL] [EOL] def test_str ( self ) : [EOL] k = Key ( [ [number] ] ) [EOL] self . assertEqual ( str ( k ) , [string] ) [EOL] [EOL] k = Key ( [ [number] , [number] ] ) [EOL] with self . assertRaises ( TypeError ) : [EOL] str ( k ) [EOL] [EOL] def test_add ( self ) : [EOL] k1 = Key ( [ [number] , [number] , TagWord ( [string] ) ] ) [EOL] k2 = Key ( [ [number] , [number] ] ) [EOL] self . assertEqual ( k1 + k2 , Key ( [ [number] , [number] , TagWord ( [string] ) , [number] , [number] ] ) ) [EOL] [EOL] def test_subsequence ( self ) : [EOL] with self . subTest ( msg = [string] ) : [EOL] with self . assertRaises ( ValueError ) : [EOL] list ( self . key . subsequence_with_end ( [number] ) ) [EOL] [EOL] with self . subTest ( msg = [string] ) : [EOL] with self . assertRaises ( ValueError ) : [EOL] list ( self . key . subsequence_with_end ( - [number] ) ) [EOL] [EOL] with self . subTest ( msg = [string] ) : [EOL] list_ = list ( self . key . subsequence_with_end ( [number] ) ) [EOL] self . assertIn ( Key ( [ [number] ] ) , list_ ) [EOL] self . assertIn ( Key ( [ [number] , [number] ] ) , list_ ) [EOL] self . assertIn ( Key ( [ [number] , [number] , [number] ] ) , list_ ) [EOL] [EOL] with self . subTest ( msg = [string] ) : [EOL] target = list ( self . key . all_of_subsequence ( ) ) [EOL] wrong = [ Key ( [ [number] , [number] ] ) , Key ( [ [number] ] ) , Key ( [ [number] , [number] , [number] ] ) , Key ( [ [number] , [number] , [number] , [number] ] ) , ] [EOL] self . assertNotEqual ( target , wrong ) [EOL] [EOL] correct = [ Key ( [ [number] ] ) , Key ( [ [number] , [number] ] ) , Key ( [ [number] , [number] , [number] ] ) , Key ( [ [number] , [number] , [number] , [number] ] ) , ] [EOL] self . assertEqual ( target , correct ) [EOL] [EOL] with self . subTest ( msg = [string] ) : [EOL] k = Key ( [ [number] , [number] , [number] , TagWord ( [string] ) ] ) [EOL] target = list ( k . all_of_subsequence ( ) ) [EOL] [EOL] correct = [ Key ( [ TagWord ( [string] ) ] ) , Key ( [ [number] , TagWord ( [string] ) ] ) , Key ( [ [number] , [number] , TagWord ( [string] ) ] ) , Key ( [ [number] , [number] , [number] , TagWord ( [string] ) ] ) , ] [EOL] self . assertEqual ( target , correct ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $sanascan_backend.word.Word$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.word.Word$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 $sanascan_backend.key.Key$ 0 0 0 0 $None$ 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 $None$ 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 $sanascan_backend.key.Key$ 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.key.Key]$ 0 $typing.List[sanascan_backend.key.Key]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import sanascan_backend [EOL] import builtins [EOL] import typing [EOL] import unittest [EOL] from natto import MeCab [EOL] [EOL] from sanascan_backend . word import Word , TagWord [EOL] [EOL] [EOL] class TestWord ( unittest . TestCase ) : [EOL] def test_from_str_of_singleword ( self , msg = [string] ) : [EOL] [EOL] with self . subTest ( msg = [string] ) : [EOL] a = Word . from_str_of_singleword ( [string] ) [EOL] b = Word ( surface = [string] , yomi = [string] ) [EOL] self . assertNotEqual ( a , b ) [EOL] [EOL] b = TagWord ( [string] ) [EOL] self . assertEqual ( a , b ) [EOL] [EOL] with self . subTest ( msg = [string] ) : [EOL] a = Word . from_str_of_singleword ( [string] ) [EOL] b = Word ( surface = [string] , yomi = [string] ) [EOL] self . assertEqual ( a , b ) [EOL] [EOL] def test_str ( self , msg = [string] ) : [EOL] word = Word ( surface = [string] , yomi = [string] ) [EOL] str_ = str ( word ) [EOL] self . assertEqual ( str_ , [string] ) [EOL] [EOL] def test_static_to_str ( self , msg = [string] ) : [EOL] words = [ Word ( surface = [string] , yomi = [string] ) , Word ( surface = [string] , yomi = [string] ) , Word ( surface = [string] , yomi = [string] ) , ] [EOL] [EOL] self . assertEqual ( Word . to_str ( words ) , [string] ) [EOL] [EOL] def test_eq ( self ) : [EOL] self . assertNotEqual ( Word ( surface = [string] , yomi = [string] ) , TagWord ( [string] ) ) [EOL] [EOL] def test_from_sentence ( self ) : [EOL] r1 = list ( Word . from_sentence ( [string] , MeCab ( ) ) ) [EOL] [EOL] r2 = [ Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , TagWord ( [string] ) , TagWord ( [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) , Word ( [string] , [string] ) ] [EOL] self . assertEqual ( r1 , r2 ) [EOL] [EOL] def test_tag_word ( self ) : [EOL] TagWord ( [string] ) [EOL] with self . assertRaises ( ValueError ) : [EOL] TagWord ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $sanascan_backend.word.Word$ 0 0 0 0 0 0 0 0 $sanascan_backend.word.Word$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.word.Word$ 0 $sanascan_backend.word.Word$ 0 0 0 $sanascan_backend.word.Word$ 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.word.Word$ 0 $sanascan_backend.word.Word$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $sanascan_backend.word.Word$ 0 0 0 0 0 0 0 0 $sanascan_backend.word.Word$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.word.Word$ 0 $sanascan_backend.word.Word$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $sanascan_backend.word.Word$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $sanascan_backend.word.Word$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.word.Word]$ 0 $typing.List[sanascan_backend.word.Word]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import sanascan_backend [EOL] import builtins [EOL] import typing [EOL] import unittest [EOL] [EOL] [EOL] from sanascan_backend . word import Word [EOL] [EOL] from tests . use_lang_model import UseLangModel [EOL] [EOL] [EOL] class TestLangModel ( UseLangModel ) : [EOL] def setUp ( self ) : [EOL] self . lm = self . __class__ . LM [EOL] [EOL] def test_score ( self , msg = [string] ) : [EOL] words = [ Word ( surface = [string] , yomi = [string] ) ] [EOL] self . lm . score ( words ) [EOL] [EOL] def test_vocab ( self , msg = [string] ) : [EOL] self . lm . _get_word_set ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sanascan_backend.word.Word]$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from subprocess import Popen [EOL] from subprocess import STDOUT [EOL] from subprocess import PIPE [EOL] [EOL] def srilm ( wakati , order ) : [EOL] with Popen ( [ [string] , [string] , [string] , [string] , str ( order ) , [string] , [string] ] , stdout = PIPE , stdin = PIPE ) as pros : [EOL] s = wakati . encode ( [string] ) [EOL] count = pros . communicate ( s ) [ [number] ] . strip ( ) [EOL] [EOL] with Popen ( [ [string] , [string] , str ( order ) , [string] , [string] , [string] , [string] , [string] , [string] ] , stdout = PIPE , stdin = PIPE ) as pros : [EOL] arpa_binary = pros . communicate ( count ) [ [number] ] . strip ( ) [EOL] [EOL] return arpa_binary [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Union , Tuple , Literal [EOL] import deplicated [EOL] import typing [EOL] import typing_extensions [EOL] from collections import namedtuple , defaultdict [EOL] from functools import total_ordering [EOL] [EOL] class DPMatching : [EOL] def __init__ ( self , ref_words , est_words ) : [EOL] self . _max_x = len ( ref_words ) - [number] [EOL] self . _max_y = len ( est_words ) - [number] [EOL] [EOL] self . _ref_words = ref_words [EOL] self . _est_words = est_words [EOL] [EOL] self . _nodes = { } [EOL] [EOL] self . end_node = self . get_node ( self . _max_x , self . _max_y ) [EOL] self . score = self . end_node . score [EOL] [EOL] def get_node ( self , x , y ) : [EOL] if x > self . _max_x or y > self . _max_y : [EOL] raise ValueError ( ) [EOL] [EOL] pos = ( x , y ) [EOL] if pos in self . _nodes : [EOL] return self . _nodes [ pos ] [EOL] [EOL] is_root = True if x == [number] and y == [number] else False [EOL] node = Node ( x = pos [ [number] ] , y = pos [ [number] ] , ref = self . _ref_words [ x ] , est = self . _est_words [ y ] , dpm = self , root = is_root ) [EOL] self . _nodes [ pos ] = node [EOL] return node [EOL] [EOL] def nodes ( self ) : [EOL] e = self . end_node [EOL] while ( not e . is_root ) : [EOL] yield e [EOL] e = e . parent [EOL] yield e [EOL] [EOL] class IllegalAlgorithmError ( Exception ) : [EOL] pass [EOL] [EOL] class Node : [EOL] def __init__ ( self , x , y , ref , est , dpm , root = False ) : [EOL] self . _x = x [EOL] self . _y = y [EOL] self . _matching_score = self . _calc_matching_score ( ref , est ) [EOL] self . _dpm = dpm [comment] [EOL] [EOL] self . is_root = root [EOL] self . parent = None [EOL] self . score = None [EOL] [EOL] if self . is_root : [EOL] self . score = self . _matching_score [EOL] else : [EOL] self . _set_parent ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . _x } [string] { self . _y } [string] ' [EOL] [EOL] def position ( self ) : [EOL] return self . _x , self . _y [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , type ( self ) ) : [EOL] raise TypeError ( ) [EOL] [EOL] if self . is_root and other . is_root : [EOL] return True [EOL] [EOL] return tuple ( self ) == tuple ( other ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( tuple ( self ) ) [EOL] [EOL] def __tuple__ ( self ) : [EOL] if self . is_root : [EOL] return self . position ( ) [EOL] [EOL] if not self . _parent : [EOL] raise IllegalAlgorithmError ( [string] ) [EOL] [EOL] return self . position ( ) + self . _parent . position ( ) [EOL] [EOL] def _is_match ( self ) : [EOL] ms = self . _matching_score [EOL] if ms . perfect == [number] or ms . yomi == [number] : [EOL] return True [EOL] return False [EOL] [EOL] def _parent_candidates ( self ) : [EOL] [comment] [EOL] if self . _x >= [number] and self . _y >= [number] : [EOL] yield self . _dpm . get_node ( self . _x - [number] , self . _y - [number] ) [EOL] if self . _x >= [number] : [EOL] yield self . _dpm . get_node ( self . _x - [number] , self . _y ) [EOL] if self . _y >= [number] : [EOL] yield self . _dpm . get_node ( self . _x , self . _y - [number] ) [EOL] [EOL] def _prev_path ( self ) : [EOL] if not self . parent : [EOL] raise IllegalAlgorithmError ( [string] ) [EOL] [EOL] return ( self . _x - self . _parent . _x , self . _y - self . _parent . _y ) [EOL] [EOL] def _calc_matching_score ( self , ref , est ) : [EOL] [comment] [EOL] if ref == est : [EOL] return Score ( perfect = [number] ) [EOL] if ref . yomi == est . yomi : [EOL] return Score ( yomi = [number] ) [EOL] return Score ( ) [EOL] [EOL] def _calc_score ( self , other ) : [EOL] [comment] [EOL] if ( other . _x == self . _x - [number] ) and ( other . _y == self . _y - [number] ) : [EOL] penalty = Score ( ) [EOL] else : [EOL] if self . _is_match ( ) or other . _is_match ( ) : [EOL] penalty = Score ( ignore = True ) [EOL] else : [EOL] penalty = Score ( miss = - [number] ) [EOL] [EOL] return other . score + self . _matching_score + penalty [EOL] [EOL] def _set_parent ( self ) : [EOL] parent = None [EOL] max_score = Score ( ) [EOL] for can in self . _parent_candidates ( ) : [EOL] score = self . _calc_score ( can ) [EOL] [EOL] if score >= max_score : [EOL] parent = can [EOL] max_score = score [EOL] [EOL] self . score = max_score [EOL] self . parent = parent [EOL] [EOL] @ total_ordering class Score : [EOL] def __init__ ( self , perfect = [number] , yomi = [number] , miss = [number] , ignore = False ) : [EOL] self . perfect = perfect [EOL] self . yomi = yomi [EOL] self . miss = miss [EOL] self . ignore = ignore [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . perfect } [string] { self . yomi } [string] { self . miss } [string] { self . ignore } [string] ' [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not self . perfect == other . perfect : [EOL] return False [EOL] if not self . yomi == other . yomi : [EOL] return False [EOL] if not self . miss == other . miss : [EOL] return False [EOL] if not self . ignore == other . ignore : [EOL] return False [EOL] return True [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . perfect , self . yomi , self . miss , self . ignore ) ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] [comment] [EOL] [comment] [EOL] if self . ignore : [EOL] return True [EOL] [EOL] if self . perfect < other . perfect : [EOL] return True [EOL] [EOL] if self . perfect == other . perfect\ [EOL] and self . yomi < other . yomi : [EOL] return True [EOL] [EOL] if self . perfect == other . perfect\ [EOL] and self . yomi == other . yomi\ [EOL] and self . miss < other . miss : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def __add__ ( self , other ) : [EOL] return Score ( perfect = self . perfect + other . perfect , yomi = self . yomi + other . yomi , miss = self . miss + other . miss , ignore = self . ignore or other . ignore ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $deplicated.util.dp_matching.Node$ 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 $deplicated.util.dp_matching.Node$ 0 0 $deplicated.util.dp_matching.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $deplicated.util.dp_matching.Score$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $deplicated.util.dp_matching.Score$ 0 0 0 0 0 0 0 0 0 0 0 $deplicated.util.dp_matching.Score$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $deplicated.util.dp_matching.Score$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from anakin . step_count . step_count import words2step [EOL] from anakin . step_count . step_count import METHODS [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , List , Dict , Optional , Any , Tuple , Match , Iterable , Pattern [EOL] import builtins [EOL] import sanascan_backend [EOL] import vocabulary [EOL] import typing [EOL] import word [EOL] import re [EOL] from typing import NamedTuple , Dict , Set , Tuple , Iterable [EOL] from enum import Enum [EOL] from enum import auto [EOL] from itertools import chain [EOL] [EOL] from . word import Word [EOL] from . vocabulary import Vocabulary [EOL] [EOL] [EOL] class ArpaArea ( Enum ) : [EOL] DATA = auto ( ) [EOL] NGRAM = auto ( ) [EOL] [EOL] [EOL] class NgramError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class ParseError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class LangModel : [EOL] class Data ( NamedTuple ) : [EOL] prob = ... [EOL] backoff = ... [EOL] [EOL] _dic = ... [EOL] order = ... [EOL] [EOL] def __init__ ( self , arpa_text ) : [EOL] title = re . compile ( [string] ) [EOL] area = ArpaArea . DATA [EOL] [EOL] result = { } [EOL] for unstriped_line in arpa_text . split ( [string] ) : [EOL] line = unstriped_line . strip ( ) [EOL] m = title . match ( line ) [EOL] if m : [EOL] area = ArpaArea . NGRAM [EOL] ngram = int ( m . group ( [number] ) ) [EOL] continue [EOL] [EOL] if area == ArpaArea . DATA or line == [string] or line == [string] : [EOL] continue [EOL] [EOL] data_line = line . split ( [string] ) [EOL] prob = float ( data_line [ [number] ] ) [EOL] word = tuple ( Word . from_wakachigaki ( data_line [ [number] ] ) ) [EOL] backoff = float ( data_line [ [number] ] ) if len ( data_line ) == [number] else [number] [EOL] result [ word ] = LangModel . Data ( prob = prob , backoff = backoff ) [EOL] [EOL] self . order = ngram [EOL] self . _dic = result [EOL] [EOL] def score ( self , words ) : [EOL] words = tuple ( words ) [EOL] len_ = len ( words ) [EOL] if len_ > self . order : [EOL] raise NgramError ( Word . to_str ( words ) ) [EOL] [EOL] if len_ == [number] and ( words not in self . _dic . keys ( ) ) : [EOL] raise NgramError ( str ( words ) + [string] ) [EOL] [EOL] if words in self . _dic . keys ( ) : [EOL] return self . _dic [ words ] . prob [EOL] else : [EOL] context = words [ : - [number] ] [EOL] p = self . score ( words [ [number] : ] ) [EOL] [EOL] if context in self . _dic . keys ( ) : [EOL] backoff = self . _dic [ context ] . backoff [EOL] return backoff + p [EOL] else : [EOL] return p [EOL] [EOL] def _get_word_set ( self ) : [EOL] return set ( chain . from_iterable ( self . _dic . keys ( ) ) ) [EOL] [EOL] def create_vocabrary ( self ) : [EOL] return Vocabulary ( self . _get_word_set ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $typing.Dict[typing.Tuple[word.Word,...],LangModel.Data]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 $builtins.int$ 0 0 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 $typing.Tuple[sanascan_backend.word.Word,...]$ 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Iterable[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 0 $typing.Tuple[sanascan_backend.word.Word,...]$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Tuple[sanascan_backend.word.Word,...]$ 0 0 $builtins.float$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Set[word.Word]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vocabulary.Vocabulary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List , Dict , Tuple , Iterator , Iterable [EOL] import word [EOL] import sanascan_backend [EOL] import builtins [EOL] import typing [EOL] from typing import Tuple , Iterable , List , Union , Iterator [EOL] [EOL] from . word import Word , TagWord [EOL] [EOL] katakana_table = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] NUM_TABLE = { c : idx for idx , col in enumerate ( katakana_table ) for c in col } [EOL] [EOL] [EOL] class Key ( ) : [EOL] _tpl = ... [EOL] [EOL] @ classmethod def from_words ( klass , words ) : [EOL] return Key ( klass . _process_words ( words ) ) [EOL] [EOL] @ staticmethod def _process_words ( words ) : [EOL] for w in words : [EOL] if isinstance ( w , TagWord ) : [EOL] yield w [EOL] else : [EOL] for c in w . yomi : [EOL] yield NUM_TABLE [ c ] [EOL] [EOL] def __init__ ( self , args ) : [EOL] [EOL] self . _tpl = tuple ( args ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Key ) : [EOL] return NotImplemented [EOL] return self . _tpl == other . _tpl [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . _tpl ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( repr ( self . _tpl ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] if not len ( self ) == [number] : [EOL] raise TypeError ( [string] ) [EOL] return str ( self . _tpl [ [number] ] ) [EOL] [EOL] def __iter__ ( self ) : [EOL] for i in self . _tpl : [EOL] yield Key ( [ i ] ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] return Key ( self . _tpl + other . _tpl ) [EOL] [EOL] def subsequence_with_end ( self , end ) : [EOL] len_ = len ( self . _tpl ) [EOL] if end > len_ - [number] or end < [number] : [EOL] raise ValueError ( ) [EOL] [EOL] for i in reversed ( range ( end + [number] ) ) : [EOL] subtpl = self . _tpl [ i : end + [number] ] [EOL] yield Key ( subtpl ) [EOL] [EOL] def all_of_subsequence ( self ) : [EOL] return self . subsequence_with_end ( len ( self ) - [number] ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _tpl ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Union[word.TagWord,builtins.int],...]$ 0 0 0 0 0 0 0 $'Key'$ 0 0 0 $typing.List[word.Word]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[word.Word]$ 0 0 0 0 0 0 0 $typing.Iterable[typing.Union[word.TagWord,builtins.int]]$ 0 $typing.List[word.Word]$ 0 0 0 0 0 0 $typing.List[word.Word]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[typing.Union[word.TagWord,builtins.int]]$ 0 0 0 0 0 0 $typing.Tuple[typing.Union[builtins.int,sanascan_backend.word.TagWord],...]$ 0 0 0 $typing.Iterable[typing.Union[word.TagWord,builtins.int]]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Iterator[Key]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Key'$ 0 0 0 $'Key'$ 0 0 0 0 0 0 0 0 0 0 $'Key'$ 0 0 0 0 0 0 $'Iterable[Key]'$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Tuple[typing.Union[builtins.int,sanascan_backend.word.TagWord],...]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Union[builtins.int,sanascan_backend.word.TagWord],...]$ 0 0 0 0 $'Iterable[Key]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import ClassVar , List , Dict , Type , Optional , Any , Tuple , Iterable , Pattern [EOL] import sanascan_backend [EOL] import natto [EOL] import builtins [EOL] import typing [EOL] import re [EOL] from typing import Dict , List , ClassVar , Pattern , Optional , Tuple [EOL] from typing import Iterable , cast [EOL] [EOL] from natto import MeCab , MeCabNode [EOL] import jaconv [EOL] [EOL] DELIMITER = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class SymbolError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class MarkError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Word : [EOL] surface = ... [EOL] yomi = ... [EOL] [EOL] @ staticmethod def from_wakachigaki ( wakachigaki ) : [EOL] return [ Word . from_str_of_singleword ( w ) for w in wakachigaki . split ( [string] ) ] [EOL] [EOL] @ classmethod def from_sentence ( klass , sentence , mecab ) : [EOL] normalized = jaconv . normalize ( sentence ) [EOL] for mec_node in mecab . parse ( normalized , as_nodes = True ) : [EOL] if mec_node . is_eos ( ) : [EOL] break [EOL] [EOL] res = AnalyzeMorp ( mec_node ) [EOL] if res . is_symbol ( ) : [EOL] continue [EOL] [EOL] if TagWord . is_include ( res . surface ( ) ) : [EOL] yield TagWord ( res . surface ( ) ) [EOL] else : [EOL] yield Word ( surface = res . surface ( ) , yomi = res . yomi ( ) ) [EOL] [EOL] @ staticmethod def from_str_of_singleword ( arg ) : [EOL] if TagWord . is_include ( arg ) : [EOL] return TagWord ( arg ) [EOL] [EOL] list_ = arg . split ( DELIMITER ) [EOL] [EOL] if len ( list_ ) >= [number] : [EOL] raise ValueError ( ) [EOL] [EOL] return Word ( surface = list_ [ [number] ] , yomi = list_ [ [number] ] ) [EOL] [EOL] @ staticmethod def to_str ( words ) : [EOL] return [string] . join ( [ str ( w ) for w in words ] ) [EOL] [EOL] def __init__ ( self , surface , yomi ) : [EOL] self . surface = surface [EOL] self . yomi = yomi [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Word ) : [EOL] return NotImplemented [EOL] [EOL] klass = self . __class__ [EOL] if not isinstance ( other , klass ) : [EOL] return False [EOL] return self . __tuple__ ( ) == other . __tuple__ ( ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . __tuple__ ( ) ) [EOL] [EOL] def __tuple__ ( self ) : [EOL] return ( self . surface , self . yomi ) [EOL] [EOL] def __str__ ( self ) : [EOL] return f'{ self . surface }{ DELIMITER }{ self . yomi }' [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . surface } [string] { self . yomi } [string] ' [EOL] [EOL] [EOL] class TagWord ( Word ) : [EOL] _tags = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] @ classmethod def is_include ( klass , arg ) : [EOL] return arg in klass . _tags [EOL] [EOL] def __init__ ( self , arg ) : [EOL] if arg not in self . _tags : [EOL] raise ValueError ( arg ) [EOL] super ( self . __class__ , self ) . __init__ ( surface = arg , yomi = arg ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . surface [EOL] [EOL] [EOL] class AnalyzeMorp : [EOL] symbol = re . compile ( [string] ) [EOL] [EOL] hira = re . compile ( [string] ) [EOL] kata = re . compile ( [string] ) [EOL] [EOL] eng = re . compile ( [string] ) [EOL] num = re . compile ( [string] ) [EOL] [EOL] old_kana_table = str . maketrans ( [string] , [string] ) [EOL] [EOL] features = ... [EOL] hinshi = ... [EOL] _surface = ... [EOL] _has_yomi = ... [EOL] _yomi = ... [EOL] [EOL] def __init__ ( self , mecab_node ) : [EOL] self . features = mecab_node . feature . split ( [string] ) [EOL] self . hinshi = self . features [ [number] ] [EOL] [EOL] self . _surface = mecab_node . surface [EOL] self . _has_yomi = True if len ( self . features ) >= [number] else False [EOL] [EOL] if self . _has_yomi : [EOL] self . _yomi = self . features [ [number] ] [EOL] [EOL] def is_symbol ( self ) : [EOL] if self . hinshi == [string] : [EOL] return True [EOL] if AnalyzeMorp . symbol . match ( self . _surface ) : [EOL] return True [EOL] if self . _has_yomi and AnalyzeMorp . symbol . match ( self . _yomi ) : [EOL] return True [EOL] return False [EOL] [EOL] def surface ( self ) : [EOL] if self . is_symbol ( ) : [EOL] raise SymbolError ( ) [EOL] [EOL] if self . _has_yomi : [EOL] return self . _surface [EOL] if AnalyzeMorp . hira . match ( self . _surface ) : [EOL] return self . _surface [EOL] if AnalyzeMorp . kata . match ( self . _surface ) : [EOL] return self . _surface [EOL] [EOL] if AnalyzeMorp . eng . match ( self . _surface ) : [EOL] return TagWord ( [string] ) . surface [EOL] if AnalyzeMorp . num . match ( self . _surface ) : [EOL] return TagWord ( [string] ) . surface [EOL] [EOL] return TagWord ( [string] ) . surface [EOL] [EOL] def yomi ( self ) : [EOL] if self . is_symbol ( ) : [EOL] raise SymbolError ( ) [EOL] [EOL] if self . _has_yomi : [EOL] if self . _yomi is None : [EOL] raise Exception ( [string] ) [EOL] [EOL] return self . _conv_kata ( self . _yomi ) [EOL] [EOL] surface = self . surface ( ) [EOL] if AnalyzeMorp . hira . match ( surface ) : [EOL] return self . _conv_kata ( surface ) [EOL] if AnalyzeMorp . kata . match ( surface ) : [EOL] return self . _conv_kata ( surface ) [EOL] [EOL] [comment] [EOL] if not TagWord . is_include ( surface ) : [EOL] raise MarkError ( ) [EOL] return surface [EOL] [EOL] def _conv_kata ( self , str_ ) : [EOL] tbl = AnalyzeMorp . old_kana_table [EOL] katakana = cast ( str , jaconv . hira2kata ( str_ ) ) [EOL] return katakana . translate ( tbl ) . replace ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $'List[Word]'$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $'Iterable[Word]'$ 0 0 0 $builtins.str$ 0 $natto.MeCab$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $natto.MeCab$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.word.AnalyzeMorp$ 0 0 0 0 0 0 0 $sanascan_backend.word.AnalyzeMorp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.word.AnalyzeMorp$ 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.word.AnalyzeMorp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanascan_backend.word.AnalyzeMorp$ 0 0 0 0 0 0 0 $sanascan_backend.word.AnalyzeMorp$ 0 0 0 0 0 0 0 0 0 0 $'Word'$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $'Iterable[Word]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Iterable[Word]'$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $typing.Type[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 $typing.Type[sanascan_backend.word.Word]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[typing.Pattern]$ 0 0 0 0 0 0 0 0 0 $typing.ClassVar[typing.Pattern]$ 0 0 0 0 0 0 0 0 $typing.ClassVar[typing.Pattern]$ 0 0 0 0 0 0 0 0 0 $typing.ClassVar[typing.Pattern]$ 0 0 0 0 0 0 0 0 $typing.ClassVar[typing.Pattern]$ 0 0 0 0 0 0 0 0 0 $typing.ClassVar[typing.Dict[builtins.int,typing.Optional[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 $natto.MeCab.Node$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $natto.MeCab.Node$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $natto.MeCab.Node$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.int,typing.Optional[builtins.int]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.int,typing.Optional[builtins.int]]$ 0 0 0 0 0 0 0 0 0
	0