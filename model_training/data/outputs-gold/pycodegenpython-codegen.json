	0
import builtins [EOL] from mypy_extensions import TypedDict [EOL] [EOL] [EOL] [EOL] SimpleTypedDict1 = TypedDict ( [string] , { [string] : str , } ) [EOL] [EOL] NestedTypedDict = TypedDict ( [string] , { [string] : SimpleTypedDict1 , } ) [EOL] [EOL] class SomeClass : [EOL] def __init__ ( self , a ) : [EOL] self . a = a [EOL] [EOL] OutputType = TypedDict ( [string] , { [string] : int , [string] : str , [string] : SomeClass , } ) [EOL] [EOL] [EOL] def func_with_typed_dict ( input ) : [EOL] return { [string] : len ( str ( input [ [string] ] [ [string] ] ) ) , [string] : [string] , [string] : SomeClass ( [number] ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $OutputType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def func_with_builtin_type_args ( a , b = [string] ) : [EOL] print ( b ) [EOL] return a + [number] [EOL]	0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar [EOL] import typing [EOL] import builtins [EOL] from typing import TypeVar , Generic [EOL] [EOL] SomeTypeVarA = TypeVar ( [string] ) [EOL] [EOL] SomeTypeVarB = TypeVar ( [string] , int , str ) [EOL] [EOL] [EOL] class SomeGenericClass ( Generic [ SomeTypeVarA , SomeTypeVarB ] ) : [EOL] a = ... [EOL] b = ... [EOL] [EOL] [EOL] def some_func_with_generics ( some_generic_instance ) : [EOL] print ( some_generic_instance ) [EOL] pass [EOL] [EOL] [EOL] print ( some_func_with_generics ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SomeTypeVarA$ 0 0 0 $SomeTypeVarB$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] from typing import Dict [EOL] [EOL] [EOL] def func_with_dict ( input ) : [EOL] return input [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] def func_with_list ( input ) : [EOL] return input [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import Tuple [EOL] [EOL] [EOL] def func_with_tuple ( input ) : [EOL] return ( input [ [number] ] , input [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union [EOL] [EOL] [EOL] class ClassWithUnionField : [EOL] cwufField1 = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,builtins.int]$ 0 0 0
class ParentClassA : [EOL] from_parent_a = ... [EOL] [EOL] [EOL] class ParentClassB : [EOL] from_parent_b = ... [EOL] [EOL] [EOL] class ChildClass ( ParentClassA , ParentClassB ) : [EOL] b = ... [EOL]	0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
import py_type_extractor [EOL] from pydantic . dataclasses import dataclass [EOL] from pydantic import BaseModel [EOL] [EOL] [EOL] @ dataclass class SomePydanticDataClass : [EOL] a = ... [EOL] b = ... [EOL] [EOL] [EOL] class SomePydanticModelClass ( BaseModel ) : [EOL] c = ... [EOL] something = ... [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] some_data_class = SomePydanticDataClass ( a = [number] , b = [string] , ) [EOL] some_model_class = SomePydanticModelClass ( c = [number] , something = [number] , ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.test_fixtures.pydantic_classes.SomePydanticDataClass$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.test_fixtures.pydantic_classes.SomePydanticModelClass$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
def func_not_annotated ( arg1 ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] from typing import Optional [EOL] [EOL] [EOL] def func_return_none ( some_input , some_input2 , ) : [EOL] print ( some_input ) [EOL] print ( some_input2 ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Mapping [EOL] import typing [EOL] import builtins [EOL] from typing import Mapping [EOL] [EOL] [EOL] def func_with_mapping ( input ) : [EOL] print ( input ) [EOL] return { [number] : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from dataclasses import dataclass [EOL] from typing import NamedTuple , Dict [EOL] [EOL] [EOL] @ dataclass class SomeDataClass : [EOL] sdcArg1 = ... [EOL] sdcArg2 = ... [EOL] [EOL] [EOL] class SomeNamedTuple ( NamedTuple ) : [EOL] sntArg1 = ... [EOL] sntArg2 = ... [EOL] [EOL] [EOL] class SomeNormalClass : [EOL] checklist = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0
import builtins [EOL] from typing import ( NewType , ) [EOL] [EOL] [EOL] UserId = NewType ( [string] , int ) [EOL] [EOL] [EOL] def name_by_id ( user_id ) : [EOL] return str ( user_id ) [EOL] [EOL] [EOL] class SomeClass : [EOL] a = ... [EOL] [EOL] [EOL] SomeClassInNewType = NewType ( [string] , SomeClass )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type , List , Callable [EOL] import typing [EOL] import py_type_extractor [EOL] import builtins [EOL] from abc import ABC [EOL] from textwrap import dedent [EOL] from typing import ( cast , List , Dict , Callable ) [EOL] [EOL] from textwrap import ( indent , ) [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import NodeType [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . nodes . DictFound import DictFound [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . ListFound import ListFound [EOL] from py_type_extractor . type_extractor . nodes . NoneNode import NoneNode [EOL] from py_type_extractor . type_extractor . nodes . TupleFound import TupleFound [EOL] from py_type_extractor . type_extractor . nodes . TypeOR import TypeOR [EOL] from py_type_extractor . type_extractor . nodes . TypedDictFound import TypedDictFound [EOL] from py_type_extractor . type_extractor . nodes . UnknownFound import unknown_found [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor , is_builtin [EOL] [EOL] MiddlewareType = Callable [ [ BaseTypeExtractor , [string] ] , List [ str ] , ] [EOL] [EOL] class BaseTypescriptConverter ( ABC ) : [EOL] extractor = ... [EOL] [EOL] middlewares = ... [EOL] [EOL] def __init__ ( self , extractor , ) : [EOL] ... [EOL] [EOL] def get_identifier ( self , node ) : [EOL] ... [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.type_extractor.TypeExtractor$ 0 0 0 0 $typing.List[MiddlewareType]$ 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.type_extractor.TypeExtractor$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0
from typing import Optional , List , Callable , Any [EOL] import typing [EOL] import py_type_extractor [EOL] import builtins [EOL] import itertools [EOL] from typing import ( cast , List , Callable , Any , Optional , ) [EOL] from typing_extensions import Protocol [EOL] [EOL] from py_type_extractor . plugins . typescript . __base__ import MiddlewareType [EOL] from py_type_extractor . plugins . typescript . middlewares . classes import class_middleware [EOL] from py_type_extractor . plugins . typescript . middlewares . functions import functionfounds_middleware [EOL] from py_type_extractor . plugins . typescript . middlewares . typeddicts import typeddicts_middleware [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import NodeType [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . nodes . DictFound import DictFound [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . ListFound import ListFound [EOL] from py_type_extractor . type_extractor . nodes . LiteralFound import LiteralFound [EOL] from py_type_extractor . type_extractor . nodes . MappingFound import MappingFound [EOL] from py_type_extractor . type_extractor . nodes . NoneNode import NoneNode [EOL] from py_type_extractor . type_extractor . nodes . TupleFound import TupleFound [EOL] from py_type_extractor . type_extractor . nodes . TypeOR import TypeOR [EOL] from py_type_extractor . type_extractor . nodes . TypedDictFound import TypedDictFound [EOL] from py_type_extractor . type_extractor . nodes . UnknownFound import unknown_found [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor , is_builtin [EOL] [EOL] [EOL] class LiteralConverterType ( Protocol ) : [EOL] def __call__ ( self , val ) : ... [EOL] [EOL] [EOL] def default_literal_converter ( val ) : [EOL] if isinstance ( val , str ) : [EOL] return f" [string] { val } [string] " [EOL] [EOL] if val is True : [EOL] return [string] [EOL] if val is False : [EOL] return [string] [EOL] if isinstance ( val , int ) or isinstance ( val , float ) : [EOL] return f"{ val }" [EOL] if isinstance ( val , list ) : [EOL] converted = [ default_literal_converter ( item ) for item in val ] [EOL] converted_str = [string] . join ( converted ) [EOL] return f" [string] { converted_str } [string] " [EOL] if val is None : [EOL] return [string] [EOL] raise NotImplementedError ( f" [string] { val }" ) [EOL] [EOL] [EOL] class TypescriptConverter : [EOL] extractor = ... [EOL] middlewares = ... [EOL] literal_converter = ... [EOL] [EOL] def __init__ ( self , extractor , middlewares = None , literal_converter = default_literal_converter , ) : [EOL] self . extractor = extractor [EOL] self . middlewares = middlewares or [ class_middleware , functionfounds_middleware , typeddicts_middleware , ] [EOL] self . literal_converter = literal_converter [EOL] [EOL] def get_identifier ( self , node ) : [EOL] [comment] [EOL] if isinstance ( node , NoneNode ) : [EOL] return [string] [EOL] if isinstance ( node , ClassFound ) : [EOL] return node . name . replace ( [string] , [string] ) [EOL] if isinstance ( node , FunctionFound ) : [EOL] return node . name . replace ( [string] , [string] ) [EOL] if isinstance ( node , TypedDictFound ) : [EOL] return f" [string] { node . name }" [EOL] if isinstance ( node , TypeOR ) : [EOL] return f"{ self . get_identifier ( node . a ) } [string] { self . get_identifier ( node . b ) }" [EOL] [comment] [EOL] if isinstance ( node , DictFound ) : [EOL] return f" [string] { self . get_identifier ( node . value ) } [string] " [EOL] if isinstance ( node , MappingFound ) : [EOL] return f" [string] { self . get_identifier ( node . value ) } [string] " [EOL] if isinstance ( node , ListFound ) : [EOL] return f"{ self . get_identifier ( node . typ ) } [string] " [EOL] if isinstance ( node , TupleFound ) : [EOL] return f" [string] { [string] . join ( [ self . get_identifier ( typ ) for typ in node . types ] ) } [string] " [EOL] if isinstance ( node , LiteralFound ) : [EOL] return self . literal_converter ( node . value ) [EOL] if node is unknown_found : [EOL] return [string] [EOL] [EOL] if is_builtin ( node ) : [EOL] return self . __convert_builtin ( cast ( type , node ) ) [EOL] [EOL] raise NotImplementedError ( f' [string] { node }' ) [EOL] [EOL] def __convert_builtin ( self , typ ) : [EOL] if typ == str : [EOL] return [string] [EOL] if typ == int or typ == float : [EOL] return [string] [EOL] if typ == bool : [EOL] return [string] [EOL] [EOL] raise NotImplementedError ( f' [string] { typ }' ) [EOL] [EOL] def run ( self ) : [EOL] r = [ middleware ( self . extractor , self ) for middleware in self . middlewares ] [EOL] merged = list ( itertools . chain . from_iterable ( r ) ) [EOL] return [string] . join ( merged ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.type_extractor.TypeExtractor$ 0 0 0 $typing.List[py_type_extractor.plugins.typescript.__base__.MiddlewareType]$ 0 0 0 $LiteralConverterType$ 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.type_extractor.TypeExtractor$ 0 $typing.List[typing.Callable[[py_type_extractor.type_extractor.__base__.BaseTypeExtractor,py_type_extractor.plugins.typescript.__base__.BaseTypescriptConverter],typing.List[builtins.str]]]$ 0 0 0 $py_type_extractor.plugins.typescript.Converter.LiteralConverterType$ 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.type_extractor.TypeExtractor$ 0 $py_type_extractor.type_extractor.type_extractor.TypeExtractor$ 0 0 0 $typing.List[typing.Callable[[py_type_extractor.type_extractor.__base__.BaseTypeExtractor,py_type_extractor.plugins.typescript.__base__.BaseTypescriptConverter],typing.List[builtins.str]]]$ 0 $typing.List[typing.Callable[[py_type_extractor.type_extractor.__base__.BaseTypeExtractor,py_type_extractor.plugins.typescript.__base__.BaseTypescriptConverter],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.plugins.typescript.Converter.LiteralConverterType$ 0 $py_type_extractor.plugins.typescript.Converter.LiteralConverterType$ 0 0 0 $builtins.str$ 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 $builtins.type$ 0 0 0 0 $builtins.type$ 0 0 0 0 0 0 0 0 $builtins.type$ 0 0 0 $builtins.type$ 0 0 0 0 0 0 0 0 $builtins.type$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.type$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0
	0
	0
import py_type_extractor [EOL] import builtins [EOL] from typing import Callable [EOL] [EOL] from py_type_extractor . plugins . typescript . Converter import TypescriptConverter [EOL] from py_type_extractor . test_fixtures . func_with_builtin_type_args import func_with_builtin_type_args [EOL] [EOL] from py_type_extractor . test_fixtures . union_type_class import ClassWithUnionField [EOL] from py_type_extractor . test_fixtures . func_with_dict import func_with_dict [EOL] from py_type_extractor . test_fixtures . func_with_list import func_with_list [EOL] from py_type_extractor . test_fixtures . func_with_typed_dict import func_with_typed_dict [EOL] from py_type_extractor . test_fixtures . func_not_annotated import func_not_annotated [EOL] from py_type_extractor . test_fixtures . func_return_none import func_return_none [EOL] from py_type_extractor . test_fixtures . func_with_tuple import func_with_tuple [EOL] from py_type_extractor . test_fixtures . func_with_literals import func_with_literals [EOL] from py_type_extractor . test_fixtures . func_with_mapping import func_with_mapping [EOL] [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] [EOL] from os import path [EOL] [EOL] def generate_and_write_ts_definition ( func_or_cls ) : [EOL] type_collector = TypeExtractor ( ) [EOL] type_collector . add ( None ) ( func_or_cls ) [EOL] converter = TypescriptConverter ( type_collector ) [EOL] __write_ts_definition__ ( func_or_cls . __qualname__ , converter . run ( ) ) [EOL] [EOL] [EOL] def __write_ts_definition__ ( name , definition_str ) : [EOL] [EOL] with open ( f'{ path . dirname ( path . abspath ( __file__ ) ) } [string] { name } [string] ' , [string] ) as file : [EOL] file . write ( definition_str ) [EOL] [EOL] [comment] [EOL] generate_and_write_ts_definition ( ClassWithUnionField ) [EOL] [EOL] [comment] [EOL] generate_and_write_ts_definition ( func_with_dict ) [EOL] generate_and_write_ts_definition ( func_with_list ) [EOL] generate_and_write_ts_definition ( func_with_typed_dict ) [EOL] generate_and_write_ts_definition ( func_not_annotated ) [EOL] generate_and_write_ts_definition ( func_return_none ) [EOL] generate_and_write_ts_definition ( func_with_tuple ) [EOL] generate_and_write_ts_definition ( func_with_literals ) [EOL] generate_and_write_ts_definition ( func_with_mapping ) [EOL] generate_and_write_ts_definition ( func_with_builtin_type_args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import py_type_extractor [EOL] import builtins [EOL] from typing import List [EOL] [EOL] from py_type_extractor . plugins . typescript . __base__ import BaseTypescriptConverter [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . NoneNode import none_node [EOL] from py_type_extractor . type_extractor . nodes . TypeOR import TypeOR [EOL] from . __base__ import ( convert_params_dict , ) [EOL] [EOL] [EOL] def functionfounds_middleware ( type_extractor , converter , ) : [EOL] classes = [ convert_functionfound ( func_found = value , converter = converter , ) for ( key , value ) in type_extractor . collected_types . items ( ) if isinstance ( value , FunctionFound ) ] [EOL] return classes [EOL] [EOL] [EOL] def convert_functionfound ( func_found , converter , ) : [EOL] raw_params = { key : value if key not in func_found . default_values [EOL] else TypeOR ( a = value , b = none_node ) for ( key , value ) in func_found . params . items ( ) } [EOL] params = convert_params_dict ( converter = converter , node_dict = raw_params , ending = [string] , ) [EOL] return ( f" [string] { converter . get_identifier ( func_found ) } [string] " f" [string] { params } [string] " f" [string] { converter . get_identifier ( func_found . return_type ) }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict [EOL] import typing [EOL] import py_type_extractor [EOL] import builtins [EOL] from typing import Dict , List [EOL] [EOL] from py_type_extractor . plugins . typescript . __base__ import BaseTypescriptConverter [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import NodeType [EOL] [EOL] [EOL] def convert_params_dict ( converter , node_dict , ending = [string] ) : [EOL] converted = [ ] [EOL] for ( field_name , node ) in node_dict . items ( ) : [EOL] _field_name = field_name if field_name . isidentifier ( ) else f" [string] { field_name } [string] " [EOL] converted . append ( f" [string] { _field_name } [string] { converter . get_identifier ( node ) }{ ending }" ) [EOL] return [string] . join ( converted ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import py_type_extractor [EOL] import builtins [EOL] from typing import List [EOL] [EOL] from py_type_extractor . plugins . typescript . __base__ import BaseTypescriptConverter [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] [EOL] from . __base__ import ( convert_params_dict , ) [EOL] [EOL] [EOL] def class_middleware ( type_extractor , converter , ) : [EOL] classes = [ convert_class ( class_found = value , converter = converter , ) for ( key , value ) in type_extractor . collected_types . items ( ) if isinstance ( value , ClassFound ) ] [EOL] return classes [EOL] [EOL] [EOL] def convert_class ( class_found , converter , ) : [EOL] fields = convert_params_dict ( converter = converter , node_dict = class_found . fields , ending = [string] , ) [EOL] return ( f" [string] { converter . get_identifier ( class_found ) } [string] " f" [string] { fields } [string] " [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import py_type_extractor [EOL] import builtins [EOL] from typing import List [EOL] from textwrap import indent [EOL] [EOL] from py_type_extractor . plugins . typescript . __base__ import BaseTypescriptConverter [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . nodes . TypedDictFound import TypedDictFound [EOL] [EOL] from . __base__ import ( convert_params_dict , ) [EOL] [EOL] [EOL] def typeddicts_middleware ( type_extractor , converter , ) : [EOL] classes = [ convert_typeddict ( typed_dict_found = value , converter = converter , ) for ( key , value ) in type_extractor . collected_types . items ( ) if isinstance ( value , TypedDictFound ) ] [EOL] return classes [EOL] [EOL] [EOL] def convert_typeddict ( typed_dict_found , converter , ) : [EOL] annotations = convert_params_dict ( converter = converter , node_dict = typed_dict_found . annotations , ) [EOL] tab = [string] [EOL] converter = converter [EOL] return ( f" [string] { converter . get_identifier ( typed_dict_found ) } [string] " f"{ indent ( annotations , tab ) } [string] " f" [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] [EOL] [EOL] class MockTypeExtractor ( BaseTypeExtractor ) : [EOL] def __init__ ( self ) : [EOL] self . functions = dict ( ) [EOL] self . classes = dict ( ) [EOL] self . typed_dicts = dict ( ) [EOL] [EOL] def add ( self , options ) : [EOL] def add_decoration ( func ) : [EOL] return func [EOL] return add_decoration [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import inspect [EOL] [EOL] [EOL] def is_builtin ( something ) : [EOL] return inspect . getmodule ( something ) is builtins	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Union , Optional , Dict , Any , Set [EOL] import typing [EOL] import py_type_extractor [EOL] import builtins [EOL] from abc import ABC [EOL] from typing import Dict , Union , List , Set , Optional [EOL] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import NodeType , BaseOption [EOL] [EOL] [EOL] class BaseTypeExtractor ( ABC ) : [EOL] collected_types = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . collected_types = dict ( ) [EOL] [EOL] def params_to_nodes ( self , params , param_names_list , ) : [EOL] pass [EOL] [EOL] def rawtype_to_node ( self , typ ) : [EOL] pass [EOL] [EOL] def add ( self , options = None , ) : [EOL] def add_decoration ( typ ) : [EOL] pass [EOL] return add_decoration [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Type[typing.Any],py_type_extractor.type_extractor.nodes.BaseNodeType.BaseNodeType]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.type,None]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Set[py_type_extractor.type_extractor.nodes.BaseNodeType.BaseOption]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Union , OrderedDict , Dict , Callable , Any , Set [EOL] import collections [EOL] import typing [EOL] import py_type_extractor [EOL] import builtins [EOL] import builtins [EOL] import inspect [EOL] from collections import ( OrderedDict , ) [EOL] from typing import ( Callable , Dict , Union , List , Any , Set , Optional ) [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . middlewares . class_found import class_found_middleware [EOL] from py_type_extractor . type_extractor . middlewares . dict_found import dict_found_middleware [EOL] from py_type_extractor . type_extractor . middlewares . fixed_generic_found import fixed_generic_found_middleware [EOL] from py_type_extractor . type_extractor . middlewares . function_found import func_found_middleware [EOL] from py_type_extractor . type_extractor . middlewares . list_found import list_found_middleware [EOL] from py_type_extractor . type_extractor . middlewares . literal_found import literal_found_middleware [EOL] from py_type_extractor . type_extractor . middlewares . mapping_found import mapping_found_middleware [EOL] from py_type_extractor . type_extractor . middlewares . newtype_found import newtype_found_middleware [EOL] from py_type_extractor . type_extractor . middlewares . tuple_found import tuple_found_middleware [EOL] from py_type_extractor . type_extractor . middlewares . type_or import typeor_middleware [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import NodeType , BaseNodeType , BaseOption [EOL] from py_type_extractor . type_extractor . nodes . NoneNode import none_node_middleware [EOL] from py_type_extractor . type_extractor . middlewares . typeddict_found import typeddict_found_middleware [EOL] from py_type_extractor . type_extractor . middlewares . TypeVar import typevar_found_middleware [EOL] from py_type_extractor . type_extractor . nodes . UnknownFound import unknown_found [EOL] [EOL] [EOL] def is_builtin ( typ ) : [EOL] return inspect . getmodule ( typ ) is builtins [EOL] [EOL] [EOL] def builtin_middleware ( typ , type_extractor , options ) : [EOL] if is_builtin ( typ ) : [EOL] return typ [EOL] [EOL] [EOL] class TypeExtractor ( BaseTypeExtractor ) : [EOL] middlewares = [ list_found_middleware , typeor_middleware , typeddict_found_middleware , literal_found_middleware , dict_found_middleware , tuple_found_middleware , mapping_found_middleware , typevar_found_middleware , fixed_generic_found_middleware , class_found_middleware , newtype_found_middleware , func_found_middleware , none_node_middleware , builtin_middleware , typeddict_found_middleware , ] [EOL] [EOL] collected_types = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . functions = dict ( ) [EOL] self . classes = dict ( ) [EOL] self . typed_dicts = dict ( ) [EOL] BaseTypeExtractor . __init__ ( self ) [EOL] [EOL] def params_to_nodes ( self , params , param_names_list , ) : [EOL] processed_params = OrderedDict ( ) [EOL] banned_words = [ [string] , [string] , [string] , ] [EOL] _param_names_list = filter ( lambda name : name not in banned_words , param_names_list ) [EOL] for param_name in _param_names_list : [EOL] processed_params [ param_name ] = self . rawtype_to_node ( params . get ( param_name ) or inspect . _empty , ) [EOL] return processed_params [EOL] [EOL] def rawtype_to_node ( self , typ , options = None , ) : [EOL] for middleware in self . middlewares : [EOL] value = middleware ( typ , self , options or set ( ) ) [EOL] if value is not None : [EOL] return value [EOL] return unknown_found [EOL] [EOL] def add ( self , options = None , ) : [EOL] def add_decoration ( typ ) : [EOL] if not is_builtin ( typ ) : [EOL] self . rawtype_to_node ( typ , options or set ( ) ) [EOL] return typ [EOL] return add_decoration [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.type,None]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $collections.OrderedDict[builtins.str,py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $collections.OrderedDict[builtins.str,py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.type,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[builtins.str,py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Set[py_type_extractor.type_extractor.nodes.BaseNodeType.BaseOption]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Set[py_type_extractor.type_extractor.nodes.BaseNodeType.BaseOption]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Set[py_type_extractor.type_extractor.nodes.BaseNodeType.BaseOption]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . DuplicateNameFound import DuplicateNameFound [comment] [EOL]	0 0 0 0 0 0 0
import py_type_extractor [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import NodeType [EOL] [EOL] [EOL] class DuplicateNameFound ( Exception ) : [EOL] def __init__ ( self , found1 , found2 , ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 0 0
import builtins [EOL] from typing import Type , NewType , List , Union , Optional , Dict , Callable , Any , TypeVar [EOL] import typing [EOL] import py_type_extractor [EOL] from collections import OrderedDict [EOL] from copy import deepcopy , copy [EOL] from typing import Callable [EOL] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import NodeType [EOL] from py_type_extractor . type_extractor . nodes . FixedGenericFound import FixedGenericFound [EOL] from py_type_extractor . type_extractor . nodes . NewType import NewTypeFound [EOL] from py_type_extractor . type_extractor . nodes . TypeVarFound import TypeVarFound [EOL] from py_type_extractor . type_extractor . nodes . TypedDictFound import TypedDictFound [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . TypeOR import TypeOR [EOL] [EOL] [EOL] traverse_func_type = Callable [ [ NodeType ] , NodeType , ] [EOL] [EOL] [EOL] def traverse ( node , func ) : [EOL] if isinstance ( node , ClassFound ) : [EOL] class_found_node = copy ( node ) [EOL] class_found_node . fields = { key : traverse ( value , func ) for ( key , value ) in node . fields . items ( ) } [EOL] class_found_node . base_classes = [ traverse ( base_class , func ) for base_class in node . base_classes ] [EOL] return func ( class_found_node ) [EOL] if isinstance ( node , FunctionFound ) : [EOL] function_found_node = copy ( node ) [EOL] function_found_node . params = OrderedDict ( [ ( key , traverse ( value , func ) ) for ( key , value ) in node . params . items ( ) ] ) [EOL] function_found_node . return_type = traverse ( node . return_type , func ) [EOL] return func ( function_found_node ) [EOL] if isinstance ( node , TypedDictFound ) : [EOL] typed_dict_node = copy ( node ) [EOL] typed_dict_node . annotations = { key : traverse ( value , func ) for ( key , value ) in node . annotations . items ( ) } [EOL] return func ( typed_dict_node ) [EOL] if isinstance ( node , TypeOR ) : [EOL] typeor_node = copy ( node ) [EOL] typeor_node . a = traverse ( node . a , func ) [EOL] typeor_node . b = traverse ( node . b , func ) [EOL] return func ( typeor_node ) [EOL] [EOL] if isinstance ( node , FixedGenericFound ) : [EOL] fixed_generic_node = copy ( node ) [EOL] fixed_generic_node . origin = traverse ( node . origin , func ) [EOL] fixed_generic_node . type_vars = [ traverse ( node_type_vars , func ) for node_type_vars in node . type_vars ] [EOL] return func ( fixed_generic_node ) [EOL] [EOL] if isinstance ( node , TypeVarFound ) : [EOL] typevar_node = copy ( node ) [EOL] typevar_node . original = traverse ( node . original , func ) [EOL] return func ( typevar_node ) [EOL] if isinstance ( node , NewTypeFound ) : [EOL] newtype_found = copy ( node ) [EOL] newtype_found . actual = traverse ( node . actual , func ) [EOL] return func ( newtype_found ) [EOL] return node [EOL] [EOL] [EOL] def cleanup ( node ) : [EOL] if isinstance ( node , ClassFound ) : [EOL] class_found_node = copy ( node ) [EOL] class_found_node . raw_fields = { } [EOL] class_found_node . class_raw = None [EOL] class_found_node . fields = copy ( node . fields ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] class_found_node . fields . pop ( [string] , None ) [EOL] [EOL] class_found_node . filePath = [string] [EOL] class_found_node . doc = [string] [EOL] return class_found_node [EOL] [EOL] if isinstance ( node , FunctionFound ) : [EOL] new_params = copy ( node . params ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] new_params . pop ( [string] , None ) [EOL] [EOL] func_found_node = copy ( node ) [EOL] func_found_node . filePath = [string] [EOL] func_found_node . raw_params = { } [EOL] func_found_node . params = new_params [EOL] func_found_node . doc = [string] [EOL] func_found_node . func = None [EOL] return func_found_node [EOL] [EOL] if isinstance ( node , TypedDictFound ) : [EOL] new_node = copy ( node ) [EOL] new_node . raw = None [EOL] return new_node [EOL] return node [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import NewType , Dict , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . test_fixtures . new_type import ( name_by_id , SomeClassInNewType , ) [EOL] from py_type_extractor . type_extractor . __tests__ . utils import traverse , cleanup [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . NewType import NewTypeFound [EOL] from py_type_extractor . type_extractor . nodes . TypeVarFound import TypeVarFound [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] [EOL] [EOL] def test_newtype ( ) : [EOL] type_extractor = TypeExtractor ( ) [EOL] type_extractor . add ( ) ( name_by_id ) [EOL] type_extractor . add ( ) ( SomeClassInNewType ) [EOL] cleaned_up = { key : traverse ( value , cleanup ) for ( key , value ) in type_extractor . collected_types . items ( ) } [EOL] user_id_newtype = NewTypeFound ( name = [string] , actual = int , ) [EOL] some_class = ClassFound ( name = [string] , fields = { [string] : int , } ) [EOL] assert cleaned_up == { [string] : user_id_newtype , [string] : FunctionFound ( name = [string] , params = { [string] : user_id_newtype , } , return_type = str , ) , [string] : some_class , [string] : NewTypeFound ( name = [string] , actual = some_class , ) , } [EOL] print ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . test_fixtures . classes_with_inheritance import ChildClass [EOL] [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . __tests__ . utils import traverse , cleanup [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] [EOL] [EOL] def test_classes_with_inheritance ( ) : [EOL] type_extractor = TypeExtractor ( ) [EOL] [EOL] type_extractor . add ( None ) ( ChildClass ) [EOL] [EOL] classes = { key : traverse ( value , cleanup ) for ( key , value ) in type_extractor . collected_types . items ( ) if isinstance ( value , ClassFound ) } [EOL] parent_class_a = ClassFound ( name = [string] , fields = { [string] : int , } , ) [EOL] parent_class_b = ClassFound ( name = [string] , fields = { [string] : str , } , ) [EOL] assert classes == { [string] : parent_class_a , [string] : parent_class_b , [string] : ClassFound ( name = [string] , fields = { [string] : str , } , base_classes = [ parent_class_a , parent_class_b , ] , ) } [EOL] print ( type_extractor ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . test_fixtures . generic_classes import ( SomeGenericClass , SomeTypeVarA , SomeTypeVarB , ) [EOL] from py_type_extractor . type_extractor . __tests__ . utils import traverse , cleanup [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . nodes . TypeVarFound import TypeVarFound [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] [EOL] [EOL] def test_class_of_generic_origin ( ) : [EOL] type_extractor = TypeExtractor ( ) [EOL] type_extractor . add ( ) ( SomeGenericClass ) [EOL] classes = { key : traverse ( value , cleanup ) for ( key , value ) in type_extractor . collected_types . items ( ) if isinstance ( value , ClassFound ) } [EOL] typevar_A = TypeVarFound ( name = [string] , original = SomeTypeVarA , ) [EOL] typevar_B = TypeVarFound ( name = [string] , original = SomeTypeVarB , ) [EOL] assert classes == { [string] : ClassFound ( name = [string] , fields = { [string] : typevar_A , [string] : typevar_B , [string] : int , } , type_vars = [ typevar_A , typevar_B , ] ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . __tests__ . utils import traverse , cleanup [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] from py_type_extractor . test_fixtures . pydantic_classes import ( SomePydanticDataClass , SomePydanticModelClass , ) [EOL] [EOL] [EOL] def test_pydantic_classes ( ) : [EOL] type_extractor = TypeExtractor ( ) [EOL] type_extractor . add ( None ) ( SomePydanticModelClass ) [EOL] type_extractor . add ( None ) ( SomePydanticDataClass ) [EOL] [EOL] print ( type_extractor ) [EOL] classes = { key : traverse ( value , cleanup ) for ( key , value ) in type_extractor . collected_types . items ( ) if isinstance ( value , ClassFound ) } [EOL] assert classes [ [string] ] == ClassFound ( name = [string] , fields = { [string] : int , [string] : str , } , ) [EOL] [EOL] assert classes [ [string] ] == ClassFound ( name = [string] , fields = { [string] : int , [string] : float , } , base_classes = [ classes [ [string] ] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from dataclasses import dataclass [EOL] [EOL] from py_type_extractor . test_fixtures . union_type_class import ClassWithUnionField [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . nodes . TypeOR import TypeOR [EOL] from py_type_extractor . type_extractor . __tests__ . utils import traverse , cleanup [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class SomeOption ( BaseOption ) : [EOL] some_var = ... [EOL] [EOL] [EOL] def test_class_with_union_field ( ) : [EOL] type_collector = TypeExtractor ( ) [EOL] [EOL] type_collector . add ( None ) ( ClassWithUnionField ) [EOL] type_collector . add ( { SomeOption ( some_var = [number] ) } ) ( ClassWithUnionField ) [EOL] [EOL] classes = { key : traverse ( value , cleanup ) for ( key , value ) in type_collector . collected_types . items ( ) if isinstance ( value , ClassFound ) } [EOL] assert classes == { [string] : ClassFound ( name = [string] , fields = { [string] : TypeOR ( a = str , b = int ) } , options = { SomeOption ( some_var = [number] ) } , ) } [EOL] functions = type_collector . functions [EOL] assert functions == { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type , Union , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . type_extractor . __tests__ . utils import cleanup , traverse [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . LiteralFound import LiteralFound [EOL] from py_type_extractor . type_extractor . nodes . TypeOR import TypeOR [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] from py_type_extractor . test_fixtures . func_with_literals import func_with_literals [EOL] [EOL] [EOL] def test_func_with_list ( ) : [EOL] type_collector = TypeExtractor ( ) [EOL] [EOL] type_collector . add ( None ) ( func_with_literals ) [EOL] [EOL] original_func_found = type_collector . collected_types [ func_with_literals . __qualname__ ] [EOL] func_found_cleaned = cleanup ( original_func_found ) [EOL] expected_func_found_cleaned = traverse ( FunctionFound ( name = func_with_literals . __qualname__ , params = { [string] : TypeOR ( a = LiteralFound ( [string] ) , b = TypeOR ( a = LiteralFound ( [number] ) , b = TypeOR ( a = TypeOR ( a = LiteralFound ( [number] ) , b = LiteralFound ( [number] ) , ) , b = TypeOR ( a = LiteralFound ( True ) , b = LiteralFound ( [number] ) , ) , ) , ) , ) , [string] : TypeOR ( a = LiteralFound ( [number] ) , b = LiteralFound ( None ) , ) , } , return_type = TypeOR ( a = LiteralFound ( True ) , b = TypeOR ( a = LiteralFound ( [number] ) , b = LiteralFound ( [number] ) , ) , ) ) , cleanup , ) [EOL] assert func_found_cleaned == expected_func_found_cleaned [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . type_extractor . __tests__ . utils import cleanup , traverse [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . UnknownFound import unknown_found [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] from py_type_extractor . test_fixtures . func_not_annotated import func_not_annotated [EOL] [EOL] [EOL] def test_func_not_annotated ( ) : [EOL] type_collector = TypeExtractor ( ) [EOL] [EOL] type_collector . add ( None ) ( func_not_annotated ) [EOL] [EOL] [comment] [EOL] func_found_cleaned = cleanup ( type_collector . collected_types [ func_not_annotated . __qualname__ ] , ) [EOL] assert func_found_cleaned . return_type == unknown_found [EOL] assert func_found_cleaned == traverse ( FunctionFound ( name = func_not_annotated . __qualname__ , params = { [string] : unknown_found , } , return_type = unknown_found , ) , cleanup , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . type_extractor . __tests__ . utils import cleanup , traverse [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . MappingFound import MappingFound [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] from py_type_extractor . test_fixtures . func_with_mapping import func_with_mapping [EOL] [EOL] [EOL] def test_func_with_tuple ( ) : [EOL] type_collector = TypeExtractor ( ) [EOL] [EOL] type_collector . add ( None ) ( func_with_mapping ) [EOL] [EOL] func_found_cleaned = cleanup ( type_collector . collected_types [ func_with_mapping . __qualname__ ] , ) [EOL] assert func_found_cleaned == traverse ( FunctionFound ( name = func_with_mapping . __qualname__ , params = { [string] : MappingFound ( key = str , value = int ) , } , return_type = MappingFound ( key = int , value = str ) , ) , cleanup , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . __tests__ . utils import traverse , cleanup [EOL] from py_type_extractor . type_extractor . nodes . DictFound import DictFound [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] from py_type_extractor . test_fixtures . various_classes import ( SomeDataClass , SomeNamedTuple , SomeNormalClass , ) [EOL] [EOL] [EOL] def test_various_classes ( ) : [EOL] [EOL] type_extractor = TypeExtractor ( ) [EOL] type_extractor . add ( None ) ( SomeDataClass ) [EOL] type_extractor . add ( None ) ( SomeNormalClass ) [EOL] type_extractor . add ( None ) ( SomeNamedTuple ) [EOL] classes = { key : traverse ( value , cleanup ) for ( key , value ) in type_extractor . collected_types . items ( ) if isinstance ( value , ClassFound ) } [EOL] assert classes == { [string] : ClassFound ( name = [string] , fields = { [string] : int , [string] : str , } , ) , [string] : ClassFound ( name = [string] , fields = { [string] : DictFound ( key = str , value = bool ) , } , ) , [string] : ClassFound ( name = [string] , fields = { [string] : int , [string] : float , } , ) } [EOL] functions = type_extractor . functions [EOL] functions_list = functions . values ( ) [EOL] assert ( functions_list . __len__ ( ) == [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . test_fixtures . generic_classes import ( some_func_with_generic_inst , SomeTypeVarA , SomeTypeVarB , ) [EOL] from py_type_extractor . type_extractor . __tests__ . utils import traverse , cleanup [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . nodes . FixedGenericFound import FixedGenericFound [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . TypeVarFound import TypeVarFound [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] [EOL] [EOL] [comment] [EOL] def test_class_of_generic_instance ( ) : [EOL] type_extractor = TypeExtractor ( ) [EOL] type_extractor . add ( ) ( some_func_with_generic_inst ) [EOL] print ( type_extractor ) [EOL] [EOL] collected_types = { key : traverse ( value , cleanup ) for ( key , value ) in type_extractor . collected_types . items ( ) } [EOL] some_typevar_A = TypeVarFound ( name = [string] , original = SomeTypeVarA , ) [EOL] some_typevar_B = TypeVarFound ( name = [string] , original = SomeTypeVarB , ) [EOL] some_generic_class = ClassFound ( name = [string] , fields = { [string] : some_typevar_A , [string] : some_typevar_B , [string] : int , } , type_vars = [ some_typevar_A , some_typevar_B , ] , ) [EOL] some_class = ClassFound ( name = [string] , fields = { [string] : int , } ) [EOL] assert collected_types [ [string] ] == some_generic_class [EOL] [EOL] assert collected_types [ [string] ] == some_class [EOL] [EOL] assert collected_types [ [string] ] == FunctionFound ( name = [string] , params = { [string] : FixedGenericFound ( type_vars = [ float , some_class ] , origin = some_generic_class , ) } , return_type = str , ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . type_extractor . __tests__ . utils import cleanup , traverse [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . TupleFound import TupleFound [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] from py_type_extractor . test_fixtures . func_with_tuple import func_with_tuple [EOL] [EOL] [EOL] def test_func_with_tuple ( ) : [EOL] type_collector = TypeExtractor ( ) [EOL] [EOL] type_collector . add ( None ) ( func_with_tuple ) [EOL] [EOL] [comment] [EOL] func_found_cleaned = cleanup ( type_collector . collected_types [ func_with_tuple . __qualname__ ] , ) [EOL] assert func_found_cleaned == traverse ( FunctionFound ( name = func_with_tuple . __qualname__ , params = { [string] : TupleFound ( [ str , int ] ) , } , return_type = TupleFound ( [ int , str ] ) , ) , cleanup , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . type_extractor . __tests__ . utils import cleanup , traverse [EOL] from py_type_extractor . type_extractor . nodes . DictFound import DictFound [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . UnknownFound import unknown_found [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] from py_type_extractor . test_fixtures . func_with_dict import func_with_dict [EOL] [EOL] [EOL] def test_func_with_dict ( ) : [EOL] type_collector = TypeExtractor ( ) [EOL] [EOL] type_collector . add ( None ) ( func_with_dict ) [EOL] [EOL] func_found_cleaned = traverse ( type_collector . collected_types [ func_with_dict . __qualname__ ] , cleanup , ) [EOL] assert func_found_cleaned == traverse ( FunctionFound ( name = func_with_dict . __qualname__ , params = { [string] : DictFound ( key = str , value = int ) , } , return_type = DictFound ( key = unknown_found , value = unknown_found ) , ) , cleanup , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import py_type_extractor [EOL] from collections import OrderedDict [EOL] [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . __tests__ . utils import traverse , cleanup [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] [EOL] [EOL] def test_func_with_nested_arg_class ( ) : [EOL] type_collector = TypeExtractor ( ) [EOL] [EOL] class ChildClass : [EOL] carg1 = ... [EOL] [EOL] class ParentClass : [EOL] parg1 = ... [EOL] parg2 = ... [EOL] [EOL] @ type_collector . add ( None ) def func_with_nested_arg_class ( a ) : [EOL] return a [EOL] [EOL] cleanedup = traverse ( type_collector . collected_types [ [string] [string] [string] [string] [string] ] , cleanup , ) [EOL] [EOL] child_class = ClassFound ( name = [string] , fields = { [string] : None , [string] : str , } , doc = [string] , filePath = [string] , raw_fields = OrderedDict ( ) , class_raw = ChildClass , ) [EOL] parent_class = ClassFound ( name = [string] , fields = { [string] : None , [string] : str , [string] : child_class , } , doc = [string] , filePath = [string] , raw_fields = OrderedDict ( ) , class_raw = ParentClass ) [EOL] parent_cleaned = traverse ( parent_class , cleanup ) [EOL] assert ( parent_cleaned == cleanedup ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $ChildClass$ 0 0 0 0 0 0 0 0 0 0 0 0 $ParentClass$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import py_type_extractor [EOL] from dataclasses import dataclass [EOL] [EOL] from py_type_extractor . type_extractor . __tests__ . utils import cleanup , traverse [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . nodes . ListFound import ListFound [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] from py_type_extractor . test_fixtures . func_with_list import func_with_list [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class SomeOption ( BaseOption ) : [EOL] some_var = ... [EOL] [EOL] [EOL] def test_func_with_list ( ) : [EOL] type_collector = TypeExtractor ( ) [EOL] [EOL] type_collector . add ( options = { SomeOption ( some_var = [number] ) } ) ( func_with_list ) [EOL] [EOL] type_collector . add ( options = { SomeOption ( some_var = [number] ) } ) ( func_with_list ) [EOL] [EOL] [comment] [EOL] func_found_cleaned = cleanup ( type_collector . collected_types [ func_with_list . __qualname__ ] , ) [EOL] assert func_found_cleaned == traverse ( FunctionFound ( name = func_with_list . __qualname__ , params = { [string] : ListFound ( str ) , } , return_type = ListFound ( str ) , options = { SomeOption ( some_var = [number] ) , SomeOption ( some_var = [number] ) } , ) , cleanup , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import py_type_extractor [EOL] from py_type_extractor . type_extractor . __tests__ . utils import cleanup , traverse [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] from py_type_extractor . type_extractor . type_extractor import TypeExtractor [EOL] [EOL] [EOL] def test_func_with_arg_class ( ) : [EOL] type_collector = TypeExtractor ( ) [EOL] [EOL] class ArgClass : [EOL] arg1 = ... [EOL] arg2 = ... [EOL] [EOL] @ type_collector . add ( None ) def func_with_arg_class ( a ) : [EOL] return a [EOL] [EOL] func_found_cleaned = traverse ( type_collector . collected_types [ [string] ] , cleanup , ) [EOL] arg_class_found = ClassFound ( name = [string] , fields = { [string] : str , [string] : int , } , ) [EOL] assert func_found_cleaned == cleanup ( FunctionFound ( name = [string] , params = { [string] : arg_class_found , [string] : arg_class_found , } , doc = [string] , return_type = arg_class_found , func = None , filePath = None , raw_params = None , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $ArgClass$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import typing [EOL] import py_type_extractor [EOL] import typing_inspect [EOL] from typing import Set [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . TypeVarFound import TypeVarFound [EOL] [EOL] [EOL] def typevar_found_middleware ( _typevar , type_extractor , options , ) : [EOL] if not typing_inspect . is_typevar ( _typevar ) : [EOL] return None [EOL] [comment] [EOL] return TypeVarFound ( name = _typevar . __name__ , original = _typevar , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , NewType [EOL] import typing [EOL] import py_type_extractor [EOL] import inspect [EOL] [EOL] from typing import Set [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . NewType import NewTypeFound [EOL] [EOL] [EOL] def newtype_found_middleware ( typ , type_extractor , options , ) : [EOL] if not inspect . isfunction ( typ ) : [EOL] return None [EOL] if typ . __module__ is not [string] : [EOL] return None [EOL] if typ . __code__ . co_name is not [string] : [EOL] return None [EOL] [EOL] newtype_found = NewTypeFound ( name = typ . __name__ , actual = type_extractor . rawtype_to_node ( typ . __supertype__ ) , ) [EOL] [EOL] type_extractor . collected_types [ newtype_found . name ] = newtype_found [EOL] return newtype_found [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Union , Any , Set [EOL] import typing [EOL] import py_type_extractor [EOL] from typing import Tuple , Set [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . middlewares . __common__ import get_typ_origin , get_typ_args [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . TupleFound import TupleFound [EOL] [EOL] [EOL] def tuple_found_middleware ( typ , type_extractor , options , ) : [EOL] typ_origin = get_typ_origin ( typ ) [EOL] if typ_origin is not tuple and typ_origin is not Tuple : [EOL] return [EOL] typ_args = get_typ_args ( typ ) [EOL] processed_typ = [ type_extractor . rawtype_to_node ( param ) for param in typ_args ] [EOL] return TupleFound ( types = processed_typ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Set , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from typing import Tuple , Set [EOL] from typing_extensions import Literal [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . middlewares . __common__ import get_typ_origin , get_typ_args [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . LiteralFound import LiteralFound [EOL] from py_type_extractor . type_extractor . nodes . TypeOR import TypeOR [EOL] [EOL] [EOL] def __is_literal_typ ( typ_origin ) : [EOL] return typ_origin == Literal or ( hasattr ( Literal , [string] ) [EOL] and typ_origin == Literal . __class__ ) [EOL] [EOL] [EOL] def literal_found_middleware ( typ , type_extractor , options , ) : [EOL] typ_origin = get_typ_origin ( typ ) [EOL] if not __is_literal_typ ( typ_origin ) : [EOL] return [EOL] return __process_literal_args ( get_typ_args ( typ ) ) [EOL] [EOL] [EOL] def __process_literal_args ( args ) : [EOL] current = LiteralFound ( args [ [number] ] ) [EOL] if __is_literal_typ ( get_typ_origin ( args [ [number] ] ) ) : [EOL] current = __process_literal_args ( get_typ_args ( args [ [number] ] ) ) [EOL] if len ( args ) == [number] : [EOL] return current [EOL] return TypeOR ( current , __process_literal_args ( args [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Union , Dict , Any , Set [EOL] import typing [EOL] import py_type_extractor [EOL] from mypy_extensions import _TypedDictMeta [comment] [EOL] from typing import Set [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . TypedDictFound import TypedDictFound [EOL] [EOL] [EOL] def typeddict_found_middleware ( typ , type_extractor , options , ) : [EOL] if not isinstance ( typ , _TypedDictMeta ) : [EOL] return [EOL] annotations = { key : type_extractor . rawtype_to_node ( value ) for key , value in typ . __annotations__ . items ( ) } [EOL] typed_dict_found = TypedDictFound ( annotations = annotations , name = typ . __qualname__ , raw = typ , ) [EOL] type_extractor . collected_types [ f"{ typ . __qualname__ } [string] { hash ( typ ) }" ] = typed_dict_found [EOL] [EOL] return typed_dict_found [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Union , Any , Set [EOL] import typing [EOL] import py_type_extractor [EOL] from typing import Dict , Set [EOL] import typing_inspect [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . nodes . FixedGenericFound import FixedGenericFound [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] [EOL] [EOL] def fixed_generic_found_middleware ( typ , type_extractor , options , ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if not typing_inspect . is_generic_type ( typ ) : [EOL] return None [EOL] [EOL] origin = typing_inspect . get_origin ( typ ) [EOL] [EOL] if origin is typ or origin is None : [EOL] return None [EOL] [EOL] origin_node = type_extractor . rawtype_to_node ( origin ) [EOL] type_vars = [ type_extractor . rawtype_to_node ( raw_type ) for raw_type in typing_inspect . get_args ( typ ) ] [EOL] return FixedGenericFound ( type_vars = type_vars , origin = origin_node , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Set , Union , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from typing import Dict , Set [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . middlewares . __common__ import get_typ_origin , get_typ_args [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . DictFound import DictFound [EOL] from py_type_extractor . type_extractor . nodes . UnknownFound import unknown_found [EOL] [EOL] [EOL] def dict_found_middleware ( typ , type_extractor , options , ) : [EOL] if typ == Dict : [comment] [EOL] return DictFound ( key = unknown_found , value = unknown_found , options = options , ) [EOL] typ_origin = get_typ_origin ( typ ) [EOL] if typ_origin is not dict and typ_origin is not Dict : [EOL] return [EOL] [EOL] typ_args = get_typ_args ( typ ) [EOL] processed_key_typ = type_extractor . rawtype_to_node ( typ_args [ [number] ] ) [EOL] processed_value_typ = type_extractor . rawtype_to_node ( typ_args [ [number] ] ) [EOL] return DictFound ( key = processed_key_typ , value = processed_value_typ , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def get_typ_origin ( typ ) : [EOL] return getattr ( typ , [string] , getattr ( typ , [string] , None ) ) [EOL] [EOL] [EOL] def get_typ_args ( typ ) : [EOL] return getattr ( typ , [string] , getattr ( typ , [string] , None ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Set , Union , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from collections import abc [EOL] from typing import Mapping , Set [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . middlewares . __common__ import get_typ_origin , get_typ_args [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . MappingFound import MappingFound [EOL] [EOL] [EOL] def mapping_found_middleware ( typ , type_extractor , options , ) : [EOL] typ_origin = get_typ_origin ( typ ) [EOL] if typ_origin is not abc . Mapping and typ_origin is not Mapping : [EOL] return [EOL] typ_args = get_typ_args ( typ ) [EOL] type_key = type_extractor . rawtype_to_node ( typ_args [ [number] ] ) [EOL] type_value = type_extractor . rawtype_to_node ( typ_args [ [number] ] ) [EOL] return MappingFound ( key = type_key , value = type_value , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type , List , Optional , Union , Dict , Any , Set [EOL] import _importlib_modulespec [EOL] import inspect [EOL] import typing [EOL] import py_type_extractor [EOL] import inspect [EOL] import typing_inspect [EOL] [EOL] from dataclasses import dataclass [EOL] [EOL] from mypy_extensions import _TypedDictMeta [comment] [EOL] from typing import Set , Dict , cast , List , Generic [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . ClassFound import ClassFound [EOL] from py_type_extractor . type_extractor . utils import is_builtin [EOL] [EOL] [EOL] def class_found_middleware ( _class , type_extractor , options , ) : [EOL] if not inspect . isclass ( _class ) or is_builtin ( _class ) or _class is inspect . _empty or isinstance ( _class , _TypedDictMeta ) : [EOL] return None [EOL] [EOL] module = inspect . getmodule ( _class ) [EOL] module_name = module . __name__ [EOL] [EOL] name = _class . __qualname__ . replace ( [string] , [string] ) [EOL] [EOL] duplicate = type_extractor . collected_types . get ( f"{ module_name } [string] { name }" ) [EOL] if duplicate is not None : [EOL] assert isinstance ( duplicate , ClassFound ) \ [EOL] and duplicate . class_raw == _class [EOL] duplicate . options = duplicate . options . union ( options ) [EOL] return duplicate [EOL] [EOL] _data_class = dataclass ( _class ) [EOL] [EOL] base_classes = cast ( List [ ClassFound ] , [ type_extractor . rawtype_to_node ( base_cls ) for base_cls in list ( _class . __bases__ ) if base_cls is not object and base_cls is not tuple and base_cls is not Generic ] ) [EOL] [EOL] argspec = inspect . getfullargspec ( _data_class ) [EOL] [EOL] filename = module and module . __file__ [EOL] annotations = getattr ( _class , [string] , argspec . annotations ) [EOL] fields = type_extractor . params_to_nodes ( annotations , annotations . keys ( ) ) [EOL] type_vars = [ type_extractor . rawtype_to_node ( _typevar ) for _typevar in list ( typing_inspect . get_parameters ( _class ) ) ] [EOL] class_found = ClassFound ( name = name , class_raw = _class , filePath = filename , base_classes = base_classes , raw_fields = argspec . annotations , fields = fields , doc = _class . __doc__ , options = options , type_vars = type_vars , ) [EOL] [EOL] type_extractor . collected_types [ f"{ module_name } [string] { name }" ] = class_found [EOL] return class_found [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Set , Union , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from typing import List , Set [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . middlewares . __common__ import get_typ_origin , get_typ_args [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . ListFound import ListFound [EOL] [EOL] [EOL] def list_found_middleware ( typ , type_extractor , options , ) : [EOL] typ_origin = get_typ_origin ( typ ) [EOL] if typ_origin is not list and typ_origin is not List : [EOL] return [EOL] typ_args = get_typ_args ( typ ) [EOL] processed_typ = type_extractor . rawtype_to_node ( typ_args [ [number] ] ) [EOL] return ListFound ( typ = processed_typ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] from typing import Type , Optional , Union , Dict , Any , Set [EOL] import _importlib_modulespec [EOL] import inspect [EOL] import typing [EOL] import py_type_extractor [EOL] import inspect [EOL] [EOL] from typing import Set [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . FunctionFound import FunctionFound [EOL] [EOL] [EOL] def func_found_middleware ( func , type_extractor , options , ) : [EOL] if not inspect . isfunction ( func ) : [EOL] return None [EOL] try : [EOL] duplicate_func_found = type_extractor . collected_types . get ( func . __name__ ) [EOL] if duplicate_func_found is not None : [EOL] assert isinstance ( duplicate_func_found , FunctionFound ) and duplicate_func_found . func == func [EOL] duplicate_func_found . options = duplicate_func_found . options . union ( options ) [EOL] return duplicate_func_found [EOL] [EOL] argspec = inspect . getfullargspec ( func ) [EOL] signature = inspect . signature ( func ) [EOL] module = inspect . getmodule ( func ) [EOL] filename = module . __file__ [EOL] params = type_extractor . params_to_nodes ( argspec . annotations , argspec . args ) [EOL] raw_default_values = { key : getattr ( signature . parameters . get ( key ) , [string] , None ) for key in argspec . args } [EOL] default_values = { key : value for ( key , value ) in raw_default_values . items ( ) if value is not inspect . _empty } [EOL] return_type = type_extractor . rawtype_to_node ( signature . return_annotation ) [EOL] func_found = FunctionFound ( name = func . __name__ , filePath = filename , raw_params = argspec . annotations , default_values = default_values , params = params , doc = func . __doc__ or [string] , func = func , return_type = return_type , options = options , ) [EOL] [EOL] type_extractor . collected_types [ func_found . name ] = func_found [EOL] return func_found [EOL] except Exception as e : [EOL] raise e [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Set , Union , Any [EOL] import typing [EOL] import py_type_extractor [EOL] from typing import Union , Set [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from py_type_extractor . type_extractor . middlewares . __common__ import get_typ_origin , get_typ_args [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseOption [EOL] from py_type_extractor . type_extractor . nodes . TypeOR import TypeOR [EOL] [EOL] [EOL] def typeor_middleware ( typ , type_extractor , options , ) : [EOL] typ_origin = get_typ_origin ( typ ) [EOL] if typ_origin is not Union : [EOL] return [EOL] types = get_typ_args ( typ ) [EOL] type_a = type_extractor . rawtype_to_node ( types [ [number] ] ) [EOL] type_b = type_extractor . rawtype_to_node ( types [ [number] ] ) [EOL] return TypeOR ( a = type_a , b = type_b , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import BaseNodeType [EOL] import typing [EOL] import py_type_extractor [EOL] from typing import Set [EOL] [EOL] from py_type_extractor . type_extractor . __base__ import BaseTypeExtractor [EOL] from . BaseNodeType import BaseNodeType , BaseOption [EOL] [EOL] [EOL] class NoneNode ( BaseNodeType ) : [comment] [EOL] pass [EOL] [EOL] [EOL] none_node = NoneNode ( ) [EOL] [EOL] [EOL] def none_node_middleware ( typ , type_extractor , options , ) : [EOL] if typ is type ( None ) : [EOL] return none_node [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.NoneNode.NoneNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.NoneNode.NoneNode$ 0 0
from typing import Set [EOL] import typing [EOL] import py_type_extractor [EOL] from dataclasses import dataclass , field [EOL] from typing import Any , Set [EOL] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseNodeType , BaseOption [EOL] [EOL] [EOL] @ dataclass class LiteralFound ( BaseNodeType ) : [comment] [EOL] value = ... [EOL] options = field ( default_factory = set ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Set[py_type_extractor.type_extractor.nodes.BaseNodeType.BaseOption]$ 0 0 0 0 0 0 0 0
from typing import List , Optional , Dict , Callable , Any , Set [EOL] import typing [EOL] import py_type_extractor [EOL] import builtins [EOL] from dataclasses import dataclass , field [EOL] from typing import ( Optional , Dict , Any , Callable , Set , List , ) [EOL] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseNodeType , NodeType , BaseOption [EOL] from py_type_extractor . type_extractor . nodes . TypeVarFound import TypeVarFound [EOL] [EOL] [EOL] @ dataclass class ClassFound ( BaseNodeType ) : [comment] [EOL] name = ... [EOL] fields = ... [EOL] filePath = field ( default = [string] ) [EOL] raw_fields = field ( default_factory = dict ) [EOL] doc = field ( default = [string] ) [EOL] base_classes = field ( default_factory = list ) [EOL] type_vars = field ( default_factory = list ) [EOL] class_raw = None [EOL] INTERNAL_fields_extra = None [EOL] options = field ( default_factory = set ) [EOL] [EOL] [EOL] def set_fields_extra ( namespace ) : [EOL] def __set_fields_extra ( class_found , extra , ) : [EOL] class_found . INTERNAL_fields_extra = class_found . INTERNAL_fields_extra or { } [EOL] [EOL] class_found . INTERNAL_fields_extra [ namespace ] = extra [EOL] return class_found [EOL] return __set_fields_extra [EOL] [EOL] [EOL] def get_fields_extra ( namespace , ) : [EOL] def __get_fields_extra ( class_found ) : [EOL] return class_found . INTERNAL_fields_extra \ [EOL] and class_found . INTERNAL_fields_extra . get ( namespace ) [EOL] return __get_fields_extra [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List['ClassFound']$ 0 0 0 0 0 0 0 0 $typing.List[py_type_extractor.type_extractor.nodes.TypeVarFound.TypeVarFound]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.type]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Set[py_type_extractor.type_extractor.nodes.BaseNodeType.BaseOption]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[ClassFound],typing.Optional[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional [EOL] import typing [EOL] import py_type_extractor [EOL] from dataclasses import dataclass [EOL] from typing import Set , Dict , List , Optional , TypeVar , Any [EOL] [comment] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseNodeType , NodeType , BaseOption [EOL] [EOL] [EOL] @ dataclass class TypeVarFound ( BaseNodeType ) : [EOL] name = ... [EOL] original = ... [EOL] type_limits = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.TypeVar$ 0 0 0 $typing.Optional[typing.List[py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]]$ 0 0 0
from typing import Optional , Dict , Callable , Any , Set [EOL] import typing [EOL] import py_type_extractor [EOL] import builtins [EOL] from dataclasses import dataclass , field [EOL] from typing import Callable , Any , Optional , Dict , Set [EOL] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseNodeType , NodeType , BaseOption [EOL] [EOL] [EOL] @ dataclass class FunctionFound ( BaseNodeType ) : [EOL] name = ... [EOL] params = ... [EOL] return_type = ... [EOL] func = None [EOL] default_values = field ( default_factory = dict ) [EOL] raw_params = field ( default_factory = dict ) [EOL] doc = [string] [EOL] filePath = [string] [EOL] INTERNAL_params_extra = None [EOL] INTERNAL_return_extra = None [EOL] options = field ( default_factory = set ) [EOL] [EOL] [EOL] def set_params_extra ( namespace ) : [EOL] def __set_fields_extra ( func_found , extra , ) : [EOL] func_found . INTERNAL_params_extra = func_found . INTERNAL_params_extra or { } [EOL] func_found . INTERNAL_params_extra [ namespace ] = extra [EOL] return func_found [EOL] [EOL] return __set_fields_extra [EOL] [EOL] [EOL] def get_params_extra ( namespace ) : [EOL] def __get_params_extra ( func_found ) : [EOL] return func_found . INTERNAL_params_extra and func_found . INTERNAL_params_extra . get ( namespace ) [EOL] return __get_params_extra [EOL] [EOL] [EOL] def set_return_type_extra ( namespace ) : [EOL] def __set_return_type_extra ( func_found , extra ) : [EOL] func_found . INTERNAL_return_extra = func_found . INTERNAL_return_extra or { } [EOL] func_found . INTERNAL_return_extra [ namespace ] = extra [EOL] return func_found [EOL] [EOL] return __set_return_type_extra [EOL] [EOL] [EOL] def get_return_type_extra ( namespace ) : [EOL] def __get_return_type_extra ( func_found ) : [EOL] return func_found . INTERNAL_return_extra and func_found . INTERNAL_return_extra . get ( namespace ) [EOL] return __get_return_type_extra [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Callable]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Set[py_type_extractor.type_extractor.nodes.BaseNodeType.BaseOption]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[FunctionFound,typing.Any],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[FunctionFound],typing.Optional[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from dataclasses import dataclass , field [EOL] from typing import Union , Set [EOL] [EOL] [EOL] class BaseOption : [EOL] pass [EOL] [EOL] [EOL] class BaseNodeType : [EOL] options = ... [EOL] [EOL] [EOL] NodeType = Union [ BaseNodeType , type ] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[BaseOption]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from dataclasses import dataclass [EOL] from typing import List [EOL] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseNodeType , NodeType [EOL] [EOL] [EOL] @ dataclass class FixedGenericFound ( BaseNodeType ) : [EOL] type_vars = ... [EOL] origin = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]$ 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0
from dataclasses import dataclass [EOL] from typing import List [EOL] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseNodeType , NodeType [EOL] [EOL] [EOL] @ dataclass class NewTypeFound ( BaseNodeType ) : [EOL] name = ... [EOL] actual = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0
from typing import Set [EOL] import typing [EOL] import py_type_extractor [EOL] from dataclasses import dataclass , field [EOL] from typing import Set [EOL] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseNodeType , NodeType , BaseOption [EOL] [EOL] [EOL] @ dataclass class ListFound ( BaseNodeType ) : [comment] [EOL] typ = ... [EOL] [EOL] options = field ( default_factory = set ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType$ 0 0 0 0 $typing.Set[py_type_extractor.type_extractor.nodes.BaseNodeType.BaseOption]$ 0 0 0 0 0 0 0 0 0 0
	0
from typing import Optional [EOL] import typing [EOL] import py_type_extractor [EOL] from typing import Optional [EOL] [EOL] from . BaseNodeType import BaseNodeType [EOL] [EOL] [comment] [EOL] class INTERNAL___UnknownFound ( BaseNodeType ) : [comment] [EOL] _instance = None [EOL] [EOL] def __new__ ( cls ) : [EOL] if not cls . _instance : [EOL] cls . _instance = super ( INTERNAL___UnknownFound , cls , ) . __new__ ( cls ) [EOL] return cls . _instance [EOL] [EOL] [comment] [EOL] unknown_found = INTERNAL___UnknownFound ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['INTERNAL___UnknownFound']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[py_type_extractor.type_extractor.nodes.UnknownFound.INTERNAL___UnknownFound]$ 0 0 0 0 $typing.Optional[py_type_extractor.type_extractor.nodes.UnknownFound.INTERNAL___UnknownFound]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[py_type_extractor.type_extractor.nodes.UnknownFound.INTERNAL___UnknownFound]$ 0 0 0 0 $py_type_extractor.type_extractor.nodes.UnknownFound.INTERNAL___UnknownFound$ 0 0 0 0 0
from dataclasses import dataclass [EOL] from typing import List [EOL] [EOL] from py_type_extractor . type_extractor . nodes . BaseNodeType import BaseNodeType , NodeType [EOL] [EOL] [EOL] @ dataclass class TupleFound ( BaseNodeType ) : [EOL] types = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[py_type_extractor.type_extractor.nodes.BaseNodeType.NodeType]$ 0 0 0
import builtins [EOL] import re [EOL] [EOL] [EOL] def strip_margin ( text ) : [EOL] return re . sub ( [string] , [string] , text ) [EOL]	0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0