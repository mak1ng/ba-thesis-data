[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] from typing import List , Dict , Tuple , Any [EOL] import typing [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [comment] [EOL] version = [string] [EOL] [comment] [EOL] release = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ ] [EOL] [EOL] [comment] [EOL] templates_path = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( master_doc , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] ) , ] [EOL] [EOL] def setup ( app ) : [EOL] app . add_stylesheet ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring]	0
from typing import Dict , List , Pattern , Match , Generator , Optional , Any [EOL] import xml [EOL] import conans [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import re [EOL] from pathlib import Path [EOL] from typing import Dict , Optional , List [EOL] from xml . dom import minidom [EOL] from xml . etree import ElementTree as ET [EOL] [EOL] from conans import ConanFile [EOL] from conans . client . output import ConanOutput [EOL] [EOL] [EOL] def _add_library ( prop_group , autodefs , ns , lmp_path , lml_path , data , out ) : [EOL] if not lml_path . is_absolute ( ) : [EOL] lml_path = lmp_path . parent / lml_path [EOL] [EOL] if lml_path . is_absolute ( ) : [EOL] lml_content = lml_path . read_text ( ) [EOL] else : [EOL] lml_content = data [ str ( lml_path . as_posix ( ) ) ] [EOL] [EOL] NAME_LEAD = [string] [EOL] PATH_LEAD = [string] [EOL] INCLUDE_LEAD = [string] [EOL] name = [string] [EOL] lib_path = [string] [EOL] includes = [ ] [EOL] for line_ in lml_content . splitlines ( ) : [EOL] line = line_ . strip ( ) [EOL] if line . startswith ( NAME_LEAD ) : [EOL] name = line [ len ( NAME_LEAD ) : ] . strip ( ) [EOL] elif line . startswith ( PATH_LEAD ) : [EOL] lib_path = line [ len ( PATH_LEAD ) : ] [EOL] elif line . startswith ( INCLUDE_LEAD ) : [EOL] includes . append ( line [ len ( INCLUDE_LEAD ) : ] + [string] ) [EOL] elif line . startswith ( [string] ) : [EOL] assert [string] in line [EOL] elif line == [string] : [EOL] pass [EOL] else : [EOL] out . warn ( f' [string] { line }' ) [EOL] [EOL] if not name : [EOL] raise RuntimeError ( f' [string] { lml_path }' ) [EOL] [EOL] def _resolve ( p ) : [EOL] if os . path . isabs ( p ) : [EOL] return p [EOL] else : [EOL] return str ( lml_path . parent / p ) [EOL] [EOL] [comment] [EOL] [EOL] condition = f' [string] { ns } [string] { name } [string] ' [EOL] [EOL] resolved_includes = ( _resolve ( inc ) for inc in includes ) [EOL] inc_prop = f' [string] { ns } [string] { name } [string] ' [EOL] ET . SubElement ( prop_group , inc_prop ) . text = [string] . join ( resolved_includes ) [EOL] aid = [string] [EOL] ET . SubElement ( ET . SubElement ( autodefs , [string] , { [string] : condition } ) , aid , ) . text = f' [string] { inc_prop } [string] { aid } [string] ' [EOL] [EOL] if lib_path : [EOL] link_prop = f' [string] { ns } [string] { name } [string] ' [EOL] ET . SubElement ( prop_group , link_prop ) . text = _resolve ( lib_path ) [EOL] adeps = [string] [EOL] ET . SubElement ( ET . SubElement ( autodefs , [string] , { [string] : condition } ) , adeps , ) . text = f' [string] { link_prop } [string] { adeps } [string] ' [EOL] [EOL] [EOL] def _add_pkg ( prop_group , autodefs , name , path , data , out ) : [EOL] if os . path . isabs ( path ) : [EOL] lmp_content = Path ( path ) . read_text ( ) [EOL] else : [EOL] lmp_content = data [ path ] [EOL] [EOL] NS_RE = re . compile ( [string] ) [EOL] namespace = [string] [EOL] LIB_RE = re . compile ( [string] ) [EOL] for line_ in lmp_content . splitlines ( ) : [EOL] line = line_ . strip ( ) [EOL] mat = NS_RE . match ( line ) [EOL] if mat : [EOL] namespace = mat . group ( [string] ) [EOL] continue [EOL] mat = LIB_RE . match ( line ) [EOL] if mat : [EOL] _add_library ( prop_group , autodefs , namespace , Path ( path ) , Path ( mat . group ( [string] ) ) , data , out ) [EOL] [EOL] [EOL] def generate_msbuild_props ( data , cf ) : [EOL] out = cf . output [EOL] root = ET . Element ( [string] , { [string] : [string] } ) [EOL] root . set ( [string] , [string] ) [EOL] out . info ( [string] ) [EOL] [EOL] check_target = ET . SubElement ( root , [string] , { [string] : [string] , [string] : [string] , } ) [EOL] bt = str ( cf . settings . build_type ) [EOL] ET . SubElement ( check_target , [string] , { [string] : f' [string] ' f' [string] { bt } [string] ' , [string] : f" [string] { bt } [string] " , } ) [EOL] vs_platform = { [string] : [string] , [string] : [string] , } . get ( str ( cf . settings . arch ) ) [EOL] if vs_platform is not None : [EOL] ET . SubElement ( check_target , [string] , { [string] : f' [string] ' f' [string] { vs_platform } [string] ' , [string] : f" [string] { vs_platform } [string] " , } ) [EOL] [EOL] prop_group = ET . SubElement ( root , [string] ) [EOL] ET . SubElement ( prop_group , [string] , { [string] : [string] , } ) [EOL] [EOL] autodefs = ET . SubElement ( root , [string] , { [string] : [string] , } ) [EOL] [EOL] index_content = data [ [string] ] [EOL] PACKAGE_RE = re . compile ( [string] ) [EOL] for line_ in index_content . splitlines ( ) : [EOL] line = line_ . strip ( ) [EOL] mat = PACKAGE_RE . match ( line ) [EOL] if mat is None : [EOL] continue [EOL] [EOL] pkg_name = mat . groupdict ( ) [ [string] ] [EOL] lmp_path = mat . groupdict ( ) [ [string] ] [EOL] _add_pkg ( prop_group , autodefs , pkg_name , lmp_path , data , out ) [EOL] [EOL] dom = minidom . parseString ( ET . tostring ( root , encoding = [string] ) ) [EOL] pretty = dom . toprettyxml ( indent = [string] , encoding = [string] ) [EOL] return pretty . decode ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Set , Optional [EOL] import typing [EOL] import conans [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] import conans [EOL] from pathlib import Path [EOL] import shutil [EOL] [EOL] from typing import Optional , Set [EOL] [EOL] [EOL] class AlreadyPackaged ( RuntimeError ) : [EOL] pass [EOL] [EOL] [EOL] def package_exports ( cf , exported = None ) : [EOL] [docstring] [EOL] exported = set ( exported or set ( ) ) [EOL] [EOL] lm_exports = list ( Path ( cf . build_folder ) . glob ( [string] ) ) [EOL] [EOL] exported_names = set ( exp . name for exp in exported ) [EOL] for export in lm_exports : [EOL] if export in exported : [EOL] [comment] [EOL] continue [EOL] [comment] [EOL] cf . output . info ( f' [string] { export . stem } [string] { export } [string] ' ) [EOL] if export . name in exported_names : [EOL] raise AlreadyPackaged ( f' [string] { export . stem } [string] ' ) [EOL] [comment] [EOL] dest = Path ( cf . package_folder ) / export . name [EOL] shutil . copytree ( export , dest ) [EOL] [comment] [EOL] exported . add ( export ) [EOL] exported_names . add ( export . name ) [EOL] [EOL] [comment] [EOL] return exported [EOL] [EOL] [EOL] class ExportCopier : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . __already_exported = set ( ) [EOL] [EOL] def package_exports ( self ) : [EOL] assert getattr ( self , [string] , None ) , [string] [EOL] assert isinstance ( self , conans . ConanFile ) , [string] [EOL] self . __already_exported = package_exports ( self , self . __already_exported ) [EOL] assert len ( self . __already_exported ) > [number] , [string] [EOL] [EOL] def package ( self ) : [EOL] self . package_exports ( ) [EOL] [EOL] def package_info ( self ) : [EOL] self . user_info . libman_simple = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import conans [EOL] import conans [EOL] from pathlib import Path [EOL] import shutil [EOL] from typing import Set , Optional [EOL] [EOL] from . export import package_exports , ExportCopier [EOL] [EOL] [EOL] def cmake_build ( cf , ** kwargs ) : [EOL] [docstring] [EOL] cmake = conans . CMake ( cf , ** kwargs ) [EOL] cmake . build_folder = [string] [EOL] cmake . configure ( ) [EOL] cmake . build ( target = [string] ) [EOL] [EOL] [EOL] class CMakeConanFile ( ExportCopier , conans . ConanFile ) : [EOL] def build ( self ) : [EOL] cmake_build ( self ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Optional , Union [EOL] import itertools [EOL] import conans [EOL] import pathlib [EOL] import lm_conan [EOL] import builtins [EOL] import typing [EOL] import json [EOL] import os [EOL] from typing import Dict , List , Optional , Union , Iterable [EOL] from pathlib import Path [EOL] from itertools import chain [EOL] [EOL] import conans [EOL] import conans . model [EOL] from conans . model . user_info import DepsUserInfo , UserInfo [EOL] from conans . model . build_info import DepsCppInfo , CppInfo [EOL] [EOL] from . data import Library [EOL] from . vs import generate_msbuild_props [EOL] [EOL] [EOL] class LibManLibrary ( Library ) : [EOL] @ classmethod def find_linkable ( cls , lib , lib_paths ) : [EOL] for lib_path in lib_paths : [EOL] lib_path = Path ( lib_path ) [EOL] candidates = chain ( lib_path . glob ( f' [string] { lib } [string] ' ) , lib_path . glob ( f' [string] { lib } [string] ' ) , lib_path . glob ( f' [string] { lib } [string] ' ) , lib_path . glob ( f'{ lib } [string] ' ) , ) [EOL] try : [EOL] return next ( iter ( candidates ) ) [EOL] except StopIteration : [EOL] pass [EOL] [comment] [EOL] return None [EOL] [EOL] @ classmethod def generate_default ( cls , name , cpp_info ) : [EOL] include_paths = [ Path ( p ) for p in cpp_info . include_paths ] [EOL] defines = list ( cpp_info . defines ) [EOL] paths = [ ] [EOL] specials = [ ] [EOL] infos = [ ] [EOL] warnings = [ ] [EOL] uses = [ ] [comment] [EOL] for lib in cpp_info . libs : [EOL] [comment] [EOL] special_by_lib = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] special = special_by_lib . get ( lib ) [EOL] if special : [EOL] infos . append ( f' [string] { lib } [string] { special } [string] ' ) [EOL] specials . append ( special ) [EOL] else : [EOL] found = cls . find_linkable ( lib , cpp_info . lib_paths ) [EOL] if found : [EOL] warnings . append ( f' [string] { found }' ) [EOL] paths . append ( found ) [EOL] else : [EOL] warnings . append ( f' [string] { name }' ) [EOL] return LibManLibrary ( name , paths , include_paths , defines , uses , specials , infos , warnings , ) [EOL] [EOL] [EOL] class AutoPackage : [EOL] def __init__ ( self , name , ns , requires , libs ) : [EOL] self . name = name [EOL] self . namespace = ns [EOL] self . requires = requires [EOL] self . libs = libs [EOL] self . has_libman_data = False [EOL] [EOL] @ staticmethod def create ( name , cpp_info , user_info , ) : [EOL] reqs = list ( cpp_info . public_deps ) [EOL] ns = name [EOL] libs = [ LibManLibrary . generate_default ( name , cpp_info ) ] [EOL] return AutoPackage ( name , ns , reqs , libs ) [EOL] [EOL] def _generate_library_file ( self , all_pkgs , lib ) : [EOL] lines = lib . get_lines ( ) [EOL] [comment] [EOL] [comment] [EOL] for req in self . requires : [EOL] other_pkg = all_pkgs [ req ] [EOL] if not getattr ( other_pkg , [string] , False ) : [EOL] lines . append ( f' [string] { other_pkg . name } [string] { other_pkg . name }' ) [EOL] else : [EOL] for other_lib in other_pkg . libs : [EOL] lines . append ( f' [string] { other_pkg . namespace } [string] { other_lib . name }' ) [EOL] [EOL] lml_path = f'{ self . name } [string] { lib . name } [string] ' [EOL] return { f' [string] { lml_path }' : [string] . join ( lines ) } , lml_path [EOL] [EOL] def generate_files ( self , pkgs ) : [EOL] lines = [ [string] , [string] , f' [string] { self . name }' , f' [string] { self . namespace }' , ] [EOL] for req in self . requires : [EOL] lines . append ( f' [string] { req }' ) [EOL] [EOL] lmp_path = f' [string] { self . name } [string] ' [EOL] ret = { } [EOL] for lib in self . libs : [EOL] more , lml_path = self . _generate_library_file ( pkgs , lib ) [EOL] ret . update ( more ) [EOL] lines . append ( f' [string] { lml_path }' ) [EOL] ret [ lmp_path ] = [string] . join ( lines ) [EOL] return ret , lmp_path [EOL] [EOL] [EOL] class ExportRootPackage : [EOL] def __init__ ( self , name , root ) : [EOL] self . name = name [EOL] self . root = root [EOL] [EOL] [EOL] class MetadataPackage : [EOL] def __init__ ( self , name , root , data ) : [EOL] self . name = name [EOL] self . root = root [EOL] packages = data . get ( [string] , [ ] ) [EOL] if not isinstance ( packages , list ) : [EOL] raise TypeError ( f' [string] { name } [string] ' ) [EOL] [EOL] self . packages = [ ] [EOL] for pkg_data in packages : [EOL] if not isinstance ( pkg_data , dict ) : [EOL] raise TypeError ( f' [string] { name } [string] ' ) [EOL] self . packages . append ( pkg_data ) [EOL] [EOL] [EOL] AnyPackage = Union [ AutoPackage , ExportRootPackage , MetadataPackage ] [EOL] [EOL] [EOL] class Generator ( conans . model . Generator ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [comment] [EOL] self . output = self . conanfile . output [EOL] [EOL] @ property def filename ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def _load_packages ( self , cpp_infos , user_infos , ) : [EOL] ret = { } [EOL] for name , cpp_info in cpp_infos . dependencies : [EOL] user_info = user_infos [ name ] [EOL] if user_info . vars . get ( [string] ) : [EOL] ret [ name ] = ExportRootPackage ( name , cpp_info . rootpath ) [EOL] elif user_info . vars . get ( [string] ) : [EOL] ret [ name ] = MetadataPackage ( name , cpp_info . rootpath , json . loads ( user_info . libman ) ) [EOL] else : [EOL] ret [ name ] = AutoPackage . create ( name , cpp_info , user_info ) [EOL] return ret [EOL] [EOL] def _generate_from_deps_info ( self , cpp_infos , user_infos , ) : [EOL] [docstring] [EOL] [comment] [EOL] index_lines = [ [string] , ] [EOL] all_pkgs = self . _load_packages ( cpp_infos , user_infos ) [EOL] [EOL] [comment] [EOL] ret = { } [EOL] for name , pkg in all_pkgs . items ( ) : [EOL] if isinstance ( pkg , ExportRootPackage ) : [EOL] for lmp in Path ( pkg . root ) . glob ( [string] ) : [EOL] index_lines . append ( f' [string] { lmp . stem } [string] { lmp }' ) [EOL] elif isinstance ( pkg , MetadataPackage ) : [EOL] for pkg_data in pkg . packages : [EOL] pkg_name = pkg_data [ [string] ] [EOL] pkg_path = Path ( pkg_data [ [string] ] ) [EOL] if not pkg_path . is_absolute ( ) : [EOL] pkg_path = Path ( pkg . root ) / pkg_path [EOL] index_lines . append ( f' [string] { pkg_name } [string] { pkg_path }' ) [EOL] else : [EOL] more_files , lmp_path = pkg . generate_files ( all_pkgs ) [EOL] ret . update ( more_files ) [EOL] index_lines . append ( f' [string] { name } [string] { lmp_path }' ) [EOL] for lib in pkg . libs : [EOL] for info in lib . infos : [EOL] self . output . info ( f'{ pkg . name } [string] { lib . name } [string] { info }' ) [EOL] for warning in lib . warnings : [EOL] self . output . warn ( f'{ pkg . name } [string] { lib . name } [string] { warning }' ) [EOL] [EOL] ret [ [string] ] = [string] . join ( index_lines ) [EOL] [EOL] [comment] [EOL] lm_for = getattr ( self . conanfile , [string] , [ ] ) [EOL] if isinstance ( lm_for , str ) : [EOL] lm_for = [ lm_for ] [EOL] [comment] [EOL] for lm_gen in lm_for : [EOL] if lm_gen == [string] : [EOL] lm_pkg_dir = self . deps_build_info [ [string] ] . rootpath [EOL] libman_cmake = ( Path ( lm_pkg_dir ) / [string] ) . read_text ( ) [EOL] ret [ [string] ] = libman_cmake [EOL] elif lm_gen in ( [string] , [string] ) : [EOL] msb_prop_content = generate_msbuild_props ( ret . copy ( ) , self . conanfile ) [EOL] fname = getattr ( self . conanfile , [string] , [string] ) [EOL] vs_platform = { [string] : [string] , [string] : [string] , None : [string] , } [ str ( self . conanfile . settings . arch ) ] [EOL] fname = fname . format ( settings = self . conanfile . settings , vs_platform = vs_platform ) [EOL] ret [ fname ] = msb_prop_content [EOL] elif lm_for is None : [EOL] pass [EOL] else : [EOL] raise RuntimeError ( f' [string] { lm_for }' ) [EOL] [EOL] return ret [EOL] [EOL] @ property def content ( self ) : [EOL] return self . _generate_from_deps_info ( self . deps_build_info , self . deps_user_info ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 $builtins.dict$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,AnyPackage]$ 0 0 0 $conans.model.build_info.DepsCppInfo$ 0 $conans.model.user_info.DepsUserInfo$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $conans.model.build_info.DepsCppInfo$ 0 0 0 0 $typing.Any$ 0 $conans.model.user_info.DepsUserInfo$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $conans.model.build_info.DepsCppInfo$ 0 $conans.model.user_info.DepsUserInfo$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[lm_conan.generator.AutoPackage,lm_conan.generator.ExportRootPackage,lm_conan.generator.MetadataPackage]]$ 0 0 0 0 0 $conans.model.build_info.DepsCppInfo$ 0 $conans.model.user_info.DepsUserInfo$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[lm_conan.generator.AutoPackage,lm_conan.generator.ExportRootPackage,lm_conan.generator.MetadataPackage]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[lm_conan.generator.AutoPackage,lm_conan.generator.ExportRootPackage,lm_conan.generator.MetadataPackage]]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import typing [EOL] import conans [EOL] [EOL] [EOL] libman = conans . python_requires ( [string] ) [EOL] [EOL] [EOL] class ConanFile ( libman . CMakeConanFile ) : [EOL] generators = [string] [EOL] libman_for = [string] [EOL] requires = ( [string] , ) [EOL] [EOL] def test ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from setuptools import setup , find_packages [EOL] [EOL] setup ( name = [string] , version = [string] , packages = find_packages ( ) , requires = [ [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[docstring] [EOL] from . main import _start [EOL] [EOL] if __name__ == [string] : [EOL] _start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional [EOL] import argparse [EOL] import pathlib [EOL] import extras [EOL] import builtins [EOL] import typing [EOL] import py [EOL] [docstring] [EOL] import argparse [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] from . import parse [EOL] [EOL] [EOL] def _query_index ( args ) : [EOL] index_path = Path ( args . index ) . resolve ( ) [EOL] index = parse . parse_index_file ( index_path ) [EOL] if args . query == [string] : [EOL] return [number] if args . package in index else [number] [EOL] if args . query == [string] : [EOL] item = index . get ( args . package ) [EOL] if not item : [EOL] print ( [string] , args . package , file = sys . stderr ) [EOL] return [number] [EOL] print ( item . path ) [EOL] return [number] [EOL] [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] def _add_query_index_parser ( parser ) : [EOL] parser . set_defaults ( main_fn = _query_index ) [EOL] parser . add_argument ( [string] , [string] , required = True , help = [string] , choices = [ [string] , [string] ] , ) [EOL] parser . add_argument ( [string] , [string] , required = True , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , required = True , help = [string] , ) [EOL] [EOL] [EOL] def _query_package ( args ) : [EOL] pkg_path = Path ( args . package ) . resolve ( ) [EOL] pkg = parse . parse_package_file ( pkg_path ) [EOL] if args . query == [string] : [EOL] print ( pkg . namespace ) [EOL] return [number] [EOL] if args . query == [string] : [EOL] print ( pkg . name ) [EOL] return [number] [EOL] if args . query == [string] : [EOL] for req in pkg . requires : [EOL] print ( req ) [EOL] return [number] [EOL] if args . query == [string] : [EOL] for lib in pkg . libraries : [EOL] print ( lib ) [EOL] return [number] [EOL] if args . query == [string] : [EOL] if args . key is None : [EOL] raise RuntimeError ( [string] ) [EOL] for field in pkg . fields : [EOL] if field . key == args . key : [EOL] print ( field . value ) [EOL] return [number] [EOL] assert False , [string] + args . query [EOL] return [number] [EOL] [EOL] [EOL] def _add_query_package_parser ( parser ) : [EOL] parser . set_defaults ( main_fn = _query_package ) [EOL] parser . add_argument ( [string] , [string] , required = True , help = [string] , choices = [ [string] , [string] , [string] , [string] , [string] ] , ) [EOL] parser . add_argument ( [string] , [string] , required = True , help = [string] , ) [EOL] parser . add_argument ( [string] , help = [string] , ) [EOL] [EOL] [EOL] def _query_library ( args ) : [EOL] [comment] [EOL] lib_path = Path ( args . library ) . resolve ( ) [EOL] lib = parse . parse_library_file ( lib_path ) [EOL] if args . query == [string] : [EOL] print ( lib . name ) [EOL] return [number] [EOL] if args . query == [string] : [EOL] print ( lib . path ) [EOL] return [number] [EOL] if args . query == [string] : [EOL] for inc in lib . includes : [EOL] print ( inc ) [EOL] return [number] [EOL] if args . query == [string] : [EOL] for define in lib . defines : [EOL] print ( define ) [EOL] return [number] [EOL] if args . query == [string] : [EOL] for use in lib . uses : [EOL] print ( f'{ use [ [number] ] } [string] { use [ [number] ] }' ) [EOL] return [number] [EOL] if args . query == [string] : [EOL] for use in lib . links : [EOL] print ( f'{ use [ [number] ] } [string] { use [ [number] ] }' ) [EOL] return [number] [EOL] if args . query == [string] : [EOL] if args . key is None : [EOL] raise RuntimeError ( [string] ) [EOL] for field in lib . fields : [EOL] if field . key == args . key : [EOL] print ( field . value ) [EOL] return [number] [EOL] [EOL] assert False , f' [string] { args . query }' [EOL] return [number] [EOL] [EOL] [EOL] def _add_library_package_parser ( parser ) : [EOL] parser . set_defaults ( main_fn = _query_library ) [EOL] parser . add_argument ( [string] , [string] , required = True , help = [string] , choices = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL] parser . add_argument ( [string] , [string] , required = True , help = [string] , ) [EOL] parser . add_argument ( [string] , help = [string] , ) [EOL] [EOL] [EOL] def _add_query_parser ( parser ) : [EOL] sub = parser . add_subparsers ( title = [string] ) [EOL] _add_query_index_parser ( sub . add_parser ( [string] , aliases = [ [string] , [string] ] , help = [string] , ) ) [EOL] _add_query_package_parser ( sub . add_parser ( [string] , aliases = [ [string] , [string] ] , help = [string] , ) ) [EOL] _add_library_package_parser ( sub . add_parser ( [string] , aliases = [ [string] , [string] ] , help = [string] , ) ) [EOL] [EOL] [EOL] def create_argument_parser ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] sub = parser . add_subparsers ( title = [string] ) [EOL] _add_query_parser ( sub . add_parser ( [string] , aliases = [ [string] ] , help = [string] , ) ) [EOL] return parser [EOL] [EOL] [EOL] def main ( argv ) : [EOL] [docstring] [EOL] parser = create_argument_parser ( ) [EOL] args = parser . parse_args ( argv ) [EOL] if not hasattr ( args , [string] ) : [EOL] parser . print_help ( ) [EOL] return [number] [EOL] return args . main_fn ( args ) [EOL] [EOL] [EOL] def _start ( ) : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import List , Type , Tuple , Optional , Iterable [EOL] import pathlib [EOL] import extras [EOL] import builtins [EOL] import typing [EOL] import py [EOL] import data [EOL] from typing import Iterable , Tuple , Type , Optional , List [EOL] from pathlib import Path [EOL] from dataclasses import dataclass , field [EOL] [EOL] import pytest [EOL] [EOL] from . import data as mod [EOL] [EOL] INDEX_PATH = Path ( [string] ) [EOL] PKG_PATH = Path ( [string] ) [EOL] [EOL] [EOL] def make_fieldseq ( * pairs ) : [EOL] [docstring] [EOL] return mod . FieldSequence ( mod . Field ( k , v ) for k , v in pairs ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class IndexTestCase : [EOL] fields = ... [EOL] path = Path ( [string] ) [EOL] expect_exception = None [EOL] expect_packages = field ( default_factory = lambda : [ ] ) [EOL] [EOL] def create_index ( self ) : [EOL] return mod . Index . from_fields ( make_fieldseq ( * self . fields ) , self . path ) [EOL] [EOL] [EOL] def test_index ( ) : [EOL] cases = [ IndexTestCase ( fields = [ ] , expect_exception = mod . InvalidIndexError , ) , IndexTestCase ( fields = [ ( [string] , [string] ) ] ) , IndexTestCase ( fields = [ ( [string] , [string] ) , ( [string] , [string] ) , ] , expect_exception = mod . InvalidIndexError , ) , IndexTestCase ( fields = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , expect_exception = mod . InvalidIndexError , ) , IndexTestCase ( fields = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , expect_packages = [ ( [string] , Path ( [string] ) ) , ( [string] , Path ( [string] ) ) , ] , ) , ] [EOL] for case in cases : [EOL] if case . expect_exception : [EOL] with pytest . raises ( case . expect_exception ) : [EOL] case . create_index ( ) [EOL] else : [EOL] idx = case . create_index ( ) [EOL] assert len ( idx ) == len ( case . expect_packages ) , [string] [EOL] for actual , expected in zip ( idx , case . expect_packages ) : [EOL] exp_name , exp_path = expected [EOL] assert actual . name == exp_name , [string] [EOL] assert actual . path == exp_path , [string] [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class PackageTestCase : [EOL] fields = ... [EOL] path = Path ( [string] ) [EOL] expect_exception = None [EOL] expect_libraries = field ( default_factory = lambda : [ ] ) [EOL] [EOL] def create_package ( self ) : [EOL] return mod . Package . from_fields ( make_fieldseq ( * self . fields ) , self . path ) [EOL] [EOL] [EOL] def test_packages ( ) : [EOL] cases = [ PackageTestCase ( fields = [ ] , expect_exception = mod . InvalidPackageError , ) , PackageTestCase ( fields = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , expect_exception = mod . InvalidPackageError , ) , PackageTestCase ( fields = [ ( [string] , [string] ) , ( [string] , [string] ) , ] , expect_exception = mod . InvalidPackageError , ) , PackageTestCase ( fields = [ ( [string] , [string] ) , ( [string] , [string] ) , ] , expect_exception = mod . InvalidPackageError , ) , ] [EOL] for case in cases : [EOL] if case . expect_exception : [EOL] with pytest . raises ( case . expect_exception ) : [EOL] case . create_package ( ) [EOL] else : [EOL] pkg = case . create_package ( ) [EOL] assert case . expect_libraries == pkg . libraries [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class LibraryTestCase : [EOL] fields = ... [EOL] path = Path ( [string] ) [EOL] expect_name = None [EOL] expect_path = None [EOL] expect_exception = None [EOL] expect_includes = field ( default_factory = lambda : [ ] ) [EOL] expect_defines = field ( default_factory = lambda : [ ] ) [EOL] expect_uses = field ( default_factory = lambda : [ ] ) [EOL] expect_links = field ( default_factory = lambda : [ ] ) [EOL] [EOL] def create_library ( self ) : [EOL] return mod . Library . from_fields ( make_fieldseq ( * self . fields ) , self . path ) [EOL] [EOL] [EOL] def test_libraries ( ) : [EOL] cases = [ LibraryTestCase ( fields = [ ] , expect_exception = mod . InvalidLibraryError , ) , LibraryTestCase ( fields = [ ( [string] , [string] ) ] , expect_exception = mod . InvalidLibraryError , ) , LibraryTestCase ( fields = [ ( [string] , [string] ) ] , expect_exception = mod . InvalidLibraryError , ) , LibraryTestCase ( fields = [ ( [string] , [string] ) , ( [string] , [string] ) , ] , expect_name = [string] , ) , LibraryTestCase ( fields = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , expect_name = [string] , expect_includes = [ Path ( [string] ) , Path ( [string] ) , ] , expect_uses = [ ( [string] , [string] ) , ] , ) , ] [EOL] for case in cases : [EOL] if case . expect_exception : [EOL] with pytest . raises ( case . expect_exception ) : [EOL] case . create_library ( ) [EOL] else : [EOL] lib = case . create_library ( ) [EOL] assert lib . path == case . expect_path [EOL] assert lib . includes == case . expect_includes [EOL] assert lib . defines == case . expect_defines [EOL] assert lib . uses == case . expect_uses [EOL] assert lib . links == case . expect_links [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $data.FieldSequence$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.Optional[typing.Type[builtins.RuntimeError]]$ 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,pathlib.Path]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Index$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.Optional[typing.Type[builtins.RuntimeError]]$ 0 0 0 $typing.Iterable[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Package$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 $typing.Optional[typing.Type[builtins.RuntimeError]]$ 0 0 0 $typing.Iterable[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Library$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Optional , Iterable , IO , ContextManager [EOL] import pathlib [EOL] import extras [EOL] import builtins [EOL] import typing [EOL] import py [EOL] import data [EOL] [docstring] [EOL] [EOL] from os import PathLike [EOL] from pathlib import Path [EOL] from contextlib import contextmanager [EOL] from typing import IO , Iterable , Optional , Union , cast , ContextManager , Generator [EOL] [EOL] from . import data [EOL] [EOL] [EOL] def parse_line ( line ) : [EOL] [docstring] [EOL] if isinstance ( line , bytes ) : [EOL] line = line . decode ( ) [EOL] line = line . strip ( ) [EOL] if line . startswith ( [string] ) : [EOL] [comment] [EOL] return None [EOL] if line == [string] : [EOL] [comment] [EOL] return None [EOL] col_pos = line . find ( [string] ) [EOL] if col_pos == - [number] : [EOL] col_pos = line . find ( [string] ) [EOL] if col_pos == - [number] or col_pos != len ( line ) - [number] : [EOL] raise ValueError ( f' [string] { line } [string] ' ) [EOL] key , value = line [ : col_pos ] , line [ col_pos + [number] : ] [EOL] key , value = key . strip ( ) , value . strip ( ) [EOL] return data . Field ( key , value ) [EOL] [EOL] [EOL] def iter_fields_from_lines ( lines ) : [EOL] [docstring] [EOL] for line in lines : [EOL] field = parse_line ( line ) [EOL] if field : [EOL] yield field [EOL] [EOL] [EOL] def iter_string_fields ( doc ) : [EOL] [docstring] [EOL] return iter_fields_from_lines ( doc . splitlines ( ) ) [EOL] [EOL] [EOL] def parse_string ( doc ) : [EOL] [docstring] [EOL] return data . FieldSequence ( iter_string_fields ( doc ) ) [EOL] [EOL] [EOL] [comment] [EOL] LibmanFile = Union [ str , PathLike , IO ] [EOL] [EOL] [EOL] @ contextmanager def _fake_file_ctx_man ( item ) : [EOL] yield item [EOL] [EOL] [EOL] def open_as_file ( what ) : [EOL] [docstring] [EOL] if hasattr ( what , [string] ) or isinstance ( what , str ) : [EOL] return Path ( cast ( PathLike , what ) ) . open ( [string] ) [EOL] [comment] [EOL] assert hasattr ( what , [string] ) , f' [string] { repr ( what ) }' [EOL] [comment] [EOL] [comment] [EOL] return _fake_file_ctx_man ( cast ( IO , what ) ) [EOL] [EOL] [EOL] def iter_file_fields ( doc ) : [EOL] [docstring] [EOL] with open_as_file ( doc ) as fd : [EOL] return iter_fields_from_lines ( fd . readlines ( ) ) [EOL] [EOL] [EOL] def parse_file ( doc ) : [EOL] [docstring] [EOL] return data . FieldSequence ( iter_file_fields ( doc ) ) [EOL] [EOL] [EOL] def parse_index_string ( doc , filepath ) : [EOL] [docstring] [EOL] return data . Index . from_fields ( parse_string ( doc ) , filepath ) [EOL] [EOL] [EOL] def parse_index_file ( fpath ) : [EOL] [docstring] [EOL] return data . Index . from_fields ( parse_file ( fpath ) , fpath ) [EOL] [EOL] [EOL] def parse_package_string ( doc , filepath ) : [EOL] [docstring] [EOL] return data . Package . from_fields ( parse_string ( doc ) , filepath ) [EOL] [EOL] [EOL] def parse_package_file ( fpath ) : [EOL] [docstring] [EOL] return data . Package . from_fields ( parse_file ( fpath ) , fpath ) [EOL] [EOL] [EOL] def parse_library_string ( doc , filepath ) : [EOL] [docstring] [EOL] return data . Library . from_fields ( parse_string ( doc ) , filepath ) [EOL] [EOL] [EOL] def parse_library_file ( fpath ) : [EOL] [docstring] [EOL] return data . Library . from_fields ( parse_file ( fpath ) , fpath ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[data.Field]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[data.Field]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.FieldSequence$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.IO,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.ContextManager[typing.IO]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[data.Field]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.FieldSequence$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Index$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Index$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Package$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Package$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Library$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Library$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Optional [EOL] import typing [EOL] import py [EOL] import extras [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] from . import parse as mod [EOL] [EOL] [EOL] def test_empty ( ) : [EOL] fields = list ( mod . iter_string_fields ( [string] ) ) [EOL] assert fields == [ ] [EOL] [EOL] [EOL] def test_simple_line ( ) : [EOL] field = mod . parse_line ( [string] ) [EOL] assert field [EOL] assert field . key == [string] [EOL] assert field . value == [string] [EOL] [EOL] [EOL] def test_extra_whitespace ( ) : [EOL] field = mod . parse_line ( [string] ) [EOL] assert field [EOL] assert field . key == [string] [EOL] assert field . value == [string] [EOL] [EOL] [EOL] def test_empty_value ( ) : [EOL] field = mod . parse_line ( [string] ) [EOL] assert field [EOL] assert field . key == [string] [EOL] assert field . value == [string] [EOL] [EOL] [EOL] def test_empty_value_at_eof ( ) : [EOL] field = mod . parse_line ( [string] ) [EOL] assert field [EOL] assert field . key == [string] [EOL] assert field . value == [string] [EOL] [EOL] [EOL] def test_empty_value_at_nl ( ) : [EOL] ( field , ) = list ( mod . iter_string_fields ( [string] ) ) [EOL] assert field . key == [string] [EOL] assert field . value == [string] [EOL] [EOL] [EOL] def test_ignore_comments ( ) : [EOL] ( field , ) = list ( mod . iter_string_fields ( [string] ) ) [EOL] assert field . key == [string] [EOL] assert field . value == [string] [EOL] [EOL] [EOL] def test_bad_line ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] mod . parse_line ( [string] ) [EOL] [EOL] [EOL] def test_key_with_colon ( ) : [EOL] field = mod . parse_line ( [string] ) [EOL] assert field [EOL] assert field . key == [string] [EOL] assert field . value == [string] [EOL] [EOL] [EOL] def test_no_trailing_comment ( ) : [EOL] field = mod . parse_line ( [string] ) [EOL] assert field [EOL] assert field . key == [string] [EOL] assert field . value == [string] [EOL] [EOL] [EOL] def test_key_with_whitespace ( ) : [EOL] field = mod . parse_line ( [string] ) [EOL] assert field [EOL] assert field . key == [string] [EOL] assert field . value == [string] [EOL] [EOL] [EOL] def test_parse_index ( ) : [EOL] content = [string] [EOL] idx = mod . parse_index_string ( content , Path ( [string] ) ) [EOL] assert len ( idx ) == [number] [EOL] [comment] [EOL] entry = idx [ [string] ] [EOL] assert entry . name == [string] [EOL] assert entry . path == Path ( [string] ) [EOL] [comment] [EOL] entry = idx [ [string] ] [EOL] assert entry . name == [string] [EOL] assert entry . path == Path ( [string] ) [EOL] [EOL] [EOL] def test_parse_index_duplicate ( ) : [EOL] content = [string] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) : [EOL] mod . parse_index_string ( content , Path ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0