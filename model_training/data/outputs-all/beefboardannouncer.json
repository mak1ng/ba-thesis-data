from typing import Union , Optional [EOL] import announcer [EOL] import typing [EOL] import os [EOL] import logging [EOL] import asyncio [EOL] from announcer . service import AnnouncerService [EOL] [EOL] [EOL] def start ( ) : [EOL] asyncio . get_event_loop ( ) . run_until_complete ( service . main_loop ( ) ) [EOL] [EOL] [EOL] posts_api = os . environ . get ( [string] , [string] ) [EOL] accounts_api = os . environ . get ( [string] , [string] ) [EOL] [EOL] email_username = os . environ . get ( [string] , None ) [EOL] email_password = os . environ . get ( [string] , None ) [EOL] email_host = os . environ . get ( [string] , [string] ) [EOL] email_port = int ( os . environ . get ( [string] , [number] ) ) [EOL] posts_base_url = os . environ . get ( [string] , [string] ) [EOL] [EOL] log_level = os . environ . get ( [string] , logging . INFO ) [EOL] [EOL] if not email_username or not email_username : [EOL] raise ValueError ( [string] ) [EOL] [EOL] assert email_username is not None [EOL] assert email_password is not None [EOL] [EOL] logging . basicConfig ( level = log_level ) [EOL] [EOL] service = AnnouncerService ( posts_api , accounts_api , email_username , email_password , email_host , email_port , posts_base_url , ) [EOL] [EOL] start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.service.AnnouncerService$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.service.AnnouncerService$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 $announcer.service.AnnouncerService$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import asyncio [EOL] import typing [EOL] import unittest [EOL] import announcer [EOL] import asyncio [EOL] import datetime [EOL] import random [EOL] import string [EOL] import time [EOL] from typing import Any [EOL] from unittest . mock import MagicMock , Mock , call , patch [EOL] [EOL] import asynctest [EOL] [EOL] from announcer . api . accounts import AccountsApi , AccountsApiError , User [EOL] from announcer . api . posts import Post , PostsApi , PostsApiError [EOL] from announcer . broadcasters . email import ( BroadcastEmail , EmailBroadcaster , EmailBroadcasterError , SendError , ) [EOL] from announcer . service import AnnouncerService [EOL] [EOL] [EOL] def async_return ( result ) : [EOL] f = asyncio . Future ( ) [EOL] f . set_result ( result ) [EOL] return f [EOL] [EOL] [EOL] def async_exception ( exception ) : [EOL] f = asyncio . Future ( ) [EOL] f . set_exception ( exception ) [EOL] return f [EOL] [EOL] [EOL] POSTS_BASE_URL = [string] [EOL] [EOL] [EOL] class TestAnnouncerService ( asynctest . TestCase ) : [EOL] MOCK_POSTS_LIST = [ Post ( id = [string] . join ( [ random . choice ( string . ascii_lowercase ) for i in range ( [number] ) ] ) , date = datetime . datetime . now ( ) , title = [string] , author = [string] , content = [string] , approved = False , approval_requested = True , num_images = [number] , notified = False , pinned = False , ) , Post ( id = [string] . join ( [ random . choice ( string . ascii_lowercase ) for i in range ( [number] ) ] ) , date = datetime . datetime . now ( ) , title = [string] , author = [string] , content = [string] , approved = False , approval_requested = False , num_images = [number] , notified = False , pinned = False , ) , Post ( id = [string] . join ( [ random . choice ( string . ascii_lowercase ) for i in range ( [number] ) ] ) , date = datetime . datetime . now ( ) , title = [string] , author = [string] , content = [string] , approved = False , approval_requested = False , num_images = [number] , notified = False , pinned = False , ) , ] [EOL] [EOL] MOCK_USERS_LIST = [ User ( username = [string] . join ( [ random . choice ( string . ascii_lowercase ) for i in range ( [number] ) ] ) , email = [string] , admin = True , firstName = [string] , lastName = [string] , ) , User ( username = [string] . join ( [ random . choice ( string . ascii_lowercase ) for i in range ( [number] ) ] ) , email = [string] , admin = True , firstName = [string] , lastName = [string] , ) , ] [EOL] [EOL] def generate_service ( self ) : [EOL] posts_addr = [string] [EOL] accounts_addr = [string] [EOL] email_username = [string] [EOL] email_password = [string] [EOL] email_host = [string] [EOL] email_port = [number] [EOL] [EOL] service = AnnouncerService ( posts_addr , accounts_addr , email_username , email_password , email_host , email_port , ) [EOL] [EOL] service . _posts_api = Mock ( spec_set = service . _posts_api ) [EOL] service . _posts_api . get_posts . return_value = async_return ( [ ] ) [EOL] service . _posts_api . set_approval_requested . return_value = async_return ( True ) [EOL] [EOL] service . _accounts_api = Mock ( spec_set = service . _accounts_api ) [EOL] service . _accounts_api . get_accounts . return_value = async_return ( [ ] ) [EOL] [EOL] service . _email_broadcaster = Mock ( spec_set = service . _email_broadcaster ) [EOL] service . _email_broadcaster . send . return_value = async_return ( None ) [EOL] [EOL] return service [EOL] [EOL] @ patch ( [string] , autospec = True ) @ patch ( [string] , autospec = True ) @ patch ( [string] , autospec = True ) def test_init ( self , MockAccountsApi , MockEmailBroadcaster , MockPostsApi , ) : [EOL] posts_addr = [string] [EOL] accounts_addr = [string] [EOL] email_username = [string] [EOL] email_password = [string] [EOL] email_host = [string] [EOL] email_port = [number] [EOL] [EOL] posts_base_url = [string] [EOL] [EOL] service = AnnouncerService ( posts_addr , accounts_addr , email_username , email_password , email_host , email_port , posts_base_url , ) [EOL] [EOL] self . assertIs ( service . _posts_base_url , posts_base_url ) [EOL] [EOL] MockPostsApi . assert_called_with ( posts_addr ) [EOL] MockAccountsApi . assert_called_with ( accounts_addr ) [EOL] MockEmailBroadcaster . assert_called_with ( email_host , email_port , email_username , email_password ) [EOL] [EOL] async def test_tick ( self ) : [EOL] service = self . generate_service ( ) [EOL] service . _posts_api . get_posts . return_value = async_return ( TestAnnouncerService . MOCK_POSTS_LIST ) [EOL] [EOL] service . _accounts_api . get_accounts . return_value = async_return ( TestAnnouncerService . MOCK_USERS_LIST ) [EOL] [EOL] await service . _tick ( ) [EOL] [EOL] admin_emails = [ ] [EOL] [EOL] for user in TestAnnouncerService . MOCK_USERS_LIST : [EOL] admin_emails . append ( user . email ) [EOL] [EOL] expected_emails = [ ] [EOL] for post in TestAnnouncerService . MOCK_POSTS_LIST : [EOL] if not post . approval_requested : [EOL] expected_emails . append ( BroadcastEmail ( admin_emails , AnnouncerService . EMAIL_POST_SUBJECT , AnnouncerService . EMAIL_POST_APPROVAL_TEMPLATE . format ( post_author = post . author , post_title = post . title , post_link = f"{ service . _posts_base_url }{ post . id }" , ) , ) ) [EOL] [EOL] service . _posts_api . get_posts . assert_called_with ( query = { [string] : [string] } ) [EOL] service . _accounts_api . get_accounts . assert_called_with ( { [string] : [string] } ) [EOL] service . _email_broadcaster . send . assert_called_with ( expected_emails ) [EOL] [EOL] expected_calls = [ ] [EOL] for post in TestAnnouncerService . MOCK_POSTS_LIST : [EOL] if not post . approval_requested : [EOL] expected_calls . append ( call ( post . id , True ) ) [EOL] [EOL] service . _posts_api . set_approval_requested . assert_has_calls ( expected_calls , any_order = True ) [EOL] [EOL] async def test_tick_no_new_posts ( self ) : [EOL] service = self . generate_service ( ) [EOL] [EOL] service . _posts_api . get_posts . return_value = async_return ( [ ] ) [EOL] [EOL] await service . _tick ( ) [EOL] [EOL] self . assertFalse ( service . _accounts_api . get_accounts . called ) [EOL] self . assertFalse ( service . _email_broadcaster . send . called ) [EOL] self . assertFalse ( service . _posts_api . set_approval_requested . called ) [EOL] [EOL] async def test_tick_post_api_failure ( self ) : [EOL] service = self . generate_service ( ) [EOL] [EOL] service . _posts_api . get_posts . return_value = async_exception ( PostsApiError ( [string] ) ) [EOL] await service . _tick ( ) [EOL] [EOL] self . assertFalse ( service . _accounts_api . get_accounts . called ) [EOL] self . assertFalse ( service . _email_broadcaster . send . called ) [EOL] self . assertFalse ( service . _posts_api . set_approval_requested . called ) [EOL] [EOL] async def test_tick_accounts_api_error ( self ) : [EOL] service = self . generate_service ( ) [EOL] [EOL] service . _posts_api . get_posts . return_value = async_return ( TestAnnouncerService . MOCK_POSTS_LIST ) [EOL] service . _accounts_api . get_accounts . return_value = async_exception ( AccountsApiError ( [string] ) ) [EOL] [EOL] await service . _tick ( ) [EOL] self . assertFalse ( service . _email_broadcaster . send . called ) [EOL] self . assertFalse ( service . _posts_api . set_approval_requested . called ) [EOL] [EOL] async def test_tick_no_admins ( self ) : [EOL] service = self . generate_service ( ) [EOL] [EOL] service . _posts_api . get_posts . return_value = async_return ( TestAnnouncerService . MOCK_POSTS_LIST ) [EOL] service . _accounts_api . get_accounts . return_value = async_return ( [ ] ) [EOL] [EOL] await service . _tick ( ) [EOL] self . assertFalse ( service . _email_broadcaster . send . called ) [EOL] self . assertFalse ( service . _posts_api . set_approval_requested . called ) [EOL] [EOL] async def test_tick_email_broadcaster_send_error ( self ) : [EOL] service = self . generate_service ( ) [EOL] [EOL] service . _posts_api . get_posts . return_value = async_return ( TestAnnouncerService . MOCK_POSTS_LIST ) [EOL] service . _accounts_api . get_accounts . return_value = async_return ( TestAnnouncerService . MOCK_USERS_LIST ) [EOL] [EOL] service . _email_broadcaster . send . return_value = async_exception ( SendError ( [string] ) ) [EOL] [EOL] await service . _tick ( ) [EOL] [EOL] service . _posts_api . set_approval_requested . assert_called ( ) [EOL] [EOL] async def test_tick_email_broadcaster_other_error ( self ) : [EOL] service = self . generate_service ( ) [EOL] [EOL] service . _posts_api . get_posts . return_value = async_return ( TestAnnouncerService . MOCK_POSTS_LIST ) [EOL] service . _accounts_api . get_accounts . return_value = async_return ( TestAnnouncerService . MOCK_USERS_LIST ) [EOL] [EOL] service . _email_broadcaster . send . return_value = async_exception ( EmailBroadcasterError ( [string] ) ) [EOL] [EOL] await service . _tick ( ) [EOL] [EOL] self . assertFalse ( service . _posts_api . set_approval_requested . called ) [EOL] [EOL] async def test_tick_set_approval_requested_error ( self ) : [EOL] service = self . generate_service ( ) [EOL] [EOL] service . _posts_api . get_posts . return_value = async_return ( TestAnnouncerService . MOCK_POSTS_LIST ) [EOL] service . _accounts_api . get_accounts . return_value = async_return ( TestAnnouncerService . MOCK_USERS_LIST ) [EOL] [EOL] service . _email_broadcaster . send . return_value = async_return ( None ) [EOL] [EOL] service . _posts_api . set_approval_requested . return_value = async_exception ( PostsApiError ( [string] ) ) [EOL] [EOL] await service . _tick ( ) [EOL] [EOL] async def test_sleep_sleeps_for_given_time ( self ) : [EOL] service = self . generate_service ( ) [EOL] [EOL] start = time . time ( ) [EOL] await service . _sleep ( [number] ) [EOL] [EOL] duration = time . time ( ) - start [EOL] self . assertGreaterEqual ( duration , [number] ) [EOL] [EOL] start = time . time ( ) [EOL] await service . _sleep ( [number] ) [EOL] [EOL] duration = time . time ( ) - start [EOL] self . assertGreaterEqual ( duration , [number] ) [EOL] self . assertLess ( duration , [number] ) [EOL] [EOL] async def test_main_loop_calls_tick_and_sleep ( self ) : [EOL] service = self . generate_service ( ) [EOL] [EOL] service . _tick = Mock ( spec_set = service . _tick ) [EOL] service . _sleep = Mock ( spec_set = service . _sleep ) [EOL] [EOL] tick_future = asyncio . Future ( ) [EOL] sleep_future = asyncio . Future ( ) [EOL] [EOL] service . _sleep . return_value = sleep_future [EOL] service . _tick . return_value = tick_future [EOL] [EOL] asyncio . ensure_future ( service . main_loop ( ) ) [EOL] [EOL] [comment] [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] service . _tick . assert_called ( ) [EOL] tick_future . set_result ( None ) [EOL] [EOL] await asyncio . sleep ( [number] ) [EOL] service . _sleep . assert_called_with ( [number] ) [EOL] [EOL] async def test_main_loop_runs_forever ( self ) : [EOL] service = self . generate_service ( ) [EOL] [EOL] service . _tick = Mock ( spec_set = service . _tick ) [EOL] service . _sleep = Mock ( spec_set = service . _sleep ) [EOL] [EOL] tick_future = asyncio . Future ( ) [EOL] sleep_future = asyncio . Future ( ) [EOL] [EOL] service . _sleep . return_value = sleep_future [EOL] service . _tick . return_value = tick_future [EOL] [EOL] asyncio . ensure_future ( service . main_loop ( ) ) [EOL] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] [comment] [EOL] await asyncio . sleep ( [number] ) [EOL] service . _tick . assert_called ( ) [EOL] [EOL] [comment] [EOL] service . _tick . reset_mock ( ) [EOL] tick_future . set_result ( None ) [EOL] [EOL] [comment] [EOL] tick_future = asyncio . Future ( ) [EOL] service . _tick . return_value = tick_future [EOL] [EOL] [comment] [EOL] await asyncio . sleep ( [number] ) [EOL] sleep_future . set_result ( None ) [EOL] [EOL] [comment] [EOL] sleep_future = asyncio . Future ( ) [EOL] service . _sleep . return_value = sleep_future [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[announcer.api.accounts.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $unittest.mock.MagicMock$ 0 $unittest.mock.MagicMock$ 0 $unittest.mock.MagicMock$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $announcer.service.AnnouncerService$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $announcer.service.AnnouncerService$ 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 $builtins.str$ 0 0 $unittest.mock.MagicMock$ 0 0 0 $builtins.str$ 0 0 $unittest.mock.MagicMock$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $asyncio.Future$ 0 $typing.Any$ 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0
from typing import List , Any [EOL] import builtins [EOL] import announcer [EOL] import typing [EOL] import asyncio [EOL] import logging [EOL] from typing import List [EOL] [EOL] from announcer . api . accounts import AccountsApi , AccountsApiError [EOL] from announcer . api . posts import Post , PostsApi , PostsApiError [EOL] from announcer . broadcasters . email import ( BroadcastEmail , EmailBroadcaster , EmailBroadcasterError , SendError , ) [EOL] [EOL] [EOL] class AnnouncerService : [EOL] EMAIL_POST_APPROVAL_TEMPLATE = [string] [EOL] EMAIL_POST_SUBJECT = [string] [EOL] [EOL] def __init__ ( self , posts_addr , accounts_addr , email_username , email_password , email_host , email_port , view_posts_base_url = [string] , ) : [EOL] self . _log = logging . getLogger ( AnnouncerService . __name__ ) [EOL] self . _posts_api = PostsApi ( posts_addr ) [EOL] self . _accounts_api = AccountsApi ( accounts_addr ) [EOL] self . _email_broadcaster = EmailBroadcaster ( email_host , email_port , email_username , email_password ) [EOL] [EOL] self . _posts_base_url = view_posts_base_url [EOL] [EOL] async def _get_new_posts ( self ) : [EOL] all_new_posts = await self . _posts_api . get_posts ( query = { [string] : [string] } ) [EOL] [EOL] new_posts = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for new_post in all_new_posts : [EOL] if not new_post . approval_requested : [EOL] new_posts . append ( new_post ) [EOL] return new_posts [EOL] [EOL] async def _get_admin_emails ( self ) : [EOL] admin_users = await self . _accounts_api . get_accounts ( { [string] : [string] } ) [EOL] [EOL] emails = [ ] [EOL] for user in admin_users : [EOL] emails . append ( user . email ) [EOL] [EOL] return emails [EOL] [EOL] def _generate_emails ( self , recipients , new_posts ) : [EOL] emails = [ ] [EOL] for post in new_posts : [EOL] emails . append ( BroadcastEmail ( recipients , AnnouncerService . EMAIL_POST_SUBJECT , AnnouncerService . EMAIL_POST_APPROVAL_TEMPLATE . format ( post_author = post . author , post_title = post . title , post_link = f"{ self . _posts_base_url }{ post . id }" , ) , ) ) [EOL] [EOL] return emails [EOL] [EOL] async def _attempt_mark_post_requested ( self , post ) : [EOL] try : [EOL] await self . _posts_api . set_approval_requested ( post . id , True ) [EOL] except PostsApiError as e : [EOL] self . _log . error ( f" [string] { post . id } [string] { e }" ) [EOL] [EOL] async def _tick ( self ) : [EOL] self . _log . debug ( [string] ) [EOL] try : [EOL] new_posts = await self . _get_new_posts ( ) [EOL] except PostsApiError as e : [EOL] self . _log . error ( f" [string] { e }" ) [EOL] return [EOL] [EOL] if not new_posts : [EOL] self . _log . debug ( [string] ) [EOL] return [EOL] [EOL] self . _log . debug ( [string] ) [EOL] try : [EOL] admin_emails = await self . _get_admin_emails ( ) [EOL] except AccountsApiError as e : [EOL] self . _log . error ( f" [string] { e }" ) [EOL] return [EOL] [EOL] if not admin_emails : [EOL] return [EOL] [EOL] self . _log . debug ( f" [string] { len ( admin_emails ) } [string] " ) [EOL] [EOL] emails = self . _generate_emails ( admin_emails , new_posts ) [EOL] [EOL] self . _log . debug ( f" [string] { len ( emails ) } [string] " ) [EOL] try : [EOL] await self . _email_broadcaster . send ( emails ) [EOL] except SendError as e : [EOL] self . _log . warning ( f" [string] { e } [string] " ) [EOL] except EmailBroadcasterError as e : [EOL] self . _log . error ( f" [string] { e }" ) [EOL] return [EOL] [EOL] self . _log . debug ( f" [string] { len ( new_posts ) } [string] " ) [EOL] tasks = [ ] [EOL] for post in new_posts : [EOL] tasks . append ( self . _attempt_mark_post_requested ( post ) ) [EOL] [EOL] await asyncio . wait ( tasks ) [EOL] [EOL] async def _sleep ( self , time ) : [EOL] await asyncio . sleep ( time ) [EOL] [EOL] async def main_loop ( self ) : [EOL] self . _log . info ( [string] ) [EOL] [EOL] while True : [EOL] await self . _tick ( ) [EOL] await self . _sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 $builtins.str$ 0 0 0 0 $announcer.api.accounts.AccountsApi$ 0 0 0 $builtins.str$ 0 0 0 0 $announcer.broadcasters.email.EmailBroadcaster$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[announcer.api.accounts.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[announcer.api.accounts.User]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[announcer.broadcasters.email.BroadcastEmail]$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 $announcer.api.posts.Post$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.Post$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.Post$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[announcer.broadcasters.email.BroadcastEmail]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[announcer.broadcasters.email.BroadcastEmail]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[announcer.broadcasters.email.BroadcastEmail]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Union , Dict [EOL] import aioresponses [EOL] import announcer [EOL] import typing [EOL] import datetime [EOL] import unittest [EOL] [EOL] import asynctest [EOL] from aioresponses import aioresponses [EOL] [EOL] from announcer . api . accounts import AccountsApi , AccountsApiError , InvalidResponse , User [EOL] [EOL] [EOL] class TestAccountsApi ( asynctest . TestCase ) : [EOL] ADDRESS = [string] [EOL] [EOL] def setUp ( self ) : [EOL] self . client = AccountsApi ( TestAccountsApi . ADDRESS ) [EOL] [EOL] def test_initialisation ( self ) : [EOL] test_client = AccountsApi ( [string] ) [EOL] self . assertIsNot ( test_client , None ) [EOL] self . assertIs ( test_client . _address , [string] ) [EOL] [EOL] @ aioresponses ( ) async def test_get_accounts ( self , m ) : [EOL] mock_account = { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , } [EOL] m . get ( TestAccountsApi . ADDRESS + [string] , payload = { [string] : [ mock_account ] } , ) [EOL] [EOL] users = await self . client . get_accounts ( { [string] : [string] } ) [EOL] assert len ( users ) == [number] [EOL] for user in users : [EOL] assert type ( user ) == User [EOL] assert user . username == mock_account [ [string] ] [EOL] [EOL] async def test_get_accounts_error ( self ) : [EOL] error = None [EOL] try : [EOL] await self . client . get_accounts ( { [string] : [string] } ) [EOL] except AccountsApiError as e : [EOL] error = e [EOL] assert type ( error ) == AccountsApiError [EOL] [EOL] @ aioresponses ( ) async def test_get_accounts_server_error ( self , m ) : [EOL] m . get ( TestAccountsApi . ADDRESS + [string] , status = [number] ) [EOL] [EOL] error = None [EOL] try : [EOL] await self . client . get_accounts ( { [string] : [string] } ) [EOL] except AccountsApiError as e : [EOL] error = e [EOL] assert type ( error ) == AccountsApiError [EOL] [EOL] @ aioresponses ( ) async def test_get_accounts_non_json_response ( self , m ) : [EOL] m . get ( TestAccountsApi . ADDRESS + [string] , body = [string] ) [EOL] error = None [EOL] try : [EOL] await self . client . get_accounts ( { [string] : [string] } ) [EOL] except AccountsApiError as e : [EOL] error = e [EOL] assert type ( error ) == InvalidResponse [EOL] [EOL] @ aioresponses ( ) async def test_get_accounts_bad_json_response ( self , m ) : [EOL] m . get ( TestAccountsApi . ADDRESS + [string] , payload = { [string] : True } ) [EOL] try : [EOL] await self . client . get_accounts ( { [string] : [string] } ) [EOL] except InvalidResponse as e : [EOL] error = e [EOL] [EOL] assert type ( error ) == InvalidResponse [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $announcer.api.accounts.AccountsApi$ 0 0 0 0 0 0 0 0 0 0 $announcer.api.accounts.AccountsApi$ 0 0 0 0 0 0 0 0 $announcer.api.accounts.AccountsApi$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioresponses.aioresponses$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioresponses.aioresponses$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $announcer.api.accounts.AccountsApiError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.accounts.AccountsApiError$ 0 0 0 0 0 0 $announcer.api.accounts.AccountsApiError$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.accounts.AccountsApiError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.accounts.AccountsApiError$ 0 0 0 0 0 0 $announcer.api.accounts.AccountsApiError$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.accounts.AccountsApiError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.accounts.AccountsApiError$ 0 0 0 0 0 0 $announcer.api.accounts.AccountsApiError$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.accounts.InvalidResponse$ 0 0 0 0 0 0 0 $announcer.api.accounts.InvalidResponse$ 0 0 0 0
	0
from typing import List , Any , Dict [EOL] import builtins [EOL] import typing [EOL] import json [EOL] from typing import Any , Dict , List [EOL] [EOL] import aiohttp [EOL] from aiohttp . client_exceptions import ClientConnectionError [EOL] [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] class AccountsApiError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidResponse ( AccountsApiError ) : [EOL] pass [EOL] [EOL] [EOL] @ dataclass class User : [EOL] username = ... [EOL] email = ... [EOL] admin = ... [EOL] firstName = ... [EOL] lastName = ... [EOL] [EOL] [EOL] class AccountsApi : [EOL] TIMEOUT = [number] [EOL] [EOL] def __init__ ( self , address ) : [EOL] self . _address = address [EOL] [EOL] def _decode_user ( self , user_data ) : [EOL] return User ( username = user_data [ [string] ] , email = user_data [ [string] ] , admin = user_data [ [string] ] , firstName = user_data [ [string] ] , lastName = user_data [ [string] ] , ) [EOL] [EOL] async def _get_response ( self , request ) : [EOL] try : [EOL] async with request as response : [EOL] if response . status == [number] : [EOL] raise AccountsApiError ( [string] ) [EOL] return await response . json ( ) [EOL] except ( TimeoutError , ClientConnectionError ) as e : [EOL] raise AccountsApiError ( e ) [EOL] except json . JSONDecodeError as e : [EOL] raise InvalidResponse ( [string] ) [EOL] [EOL] async def get_accounts ( self , query ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] data = await self . _get_response ( session . get ( self . _address + [string] , params = query ) ) [EOL] [EOL] if [string] not in data : [EOL] raise InvalidResponse ( [string] ) [EOL] [EOL] users = [ ] [EOL] for user_data in data [ [string] ] : [EOL] users . append ( self . _decode_user ( user_data ) ) [EOL] [EOL] return users [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import List , Union , Dict [EOL] import aioresponses [EOL] import announcer [EOL] import typing [EOL] import datetime [EOL] import unittest [EOL] [EOL] import asynctest [EOL] from aioresponses import aioresponses [EOL] [EOL] from announcer . api . posts import InvalidResponse , Post , PostsApi , PostsApiError [EOL] [EOL] TEST_POSTS_ADDRESS = [string] [EOL] posts_client = PostsApi ( TEST_POSTS_ADDRESS ) [EOL] [EOL] [EOL] class TestPostsApi ( asynctest . TestCase ) : [EOL] def test_initialisation ( self ) : [EOL] test_client = PostsApi ( [string] ) [EOL] assert test_client is not None [EOL] assert test_client . _address is [string] [EOL] [EOL] @ aioresponses ( ) async def test_get_posts ( self , m ) : [EOL] mock_post = { [string] : [string] , [string] : datetime . datetime . now ( ) . isoformat ( ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : True , [string] : [number] , [string] : False , [string] : False , } [EOL] m . get ( TEST_POSTS_ADDRESS + [string] , payload = { [string] : [ mock_post ] } ) [EOL] [EOL] posts_response = await posts_client . get_posts ( ) [EOL] assert len ( posts_response ) is [number] [EOL] for post in posts_response : [EOL] assert type ( post ) == Post [EOL] assert post . id == mock_post [ [string] ] [EOL] assert post . title == mock_post [ [string] ] [EOL] [EOL] @ aioresponses ( ) async def test_get_posts_query ( self , m ) : [EOL] mock_post = { [string] : [string] , [string] : datetime . datetime . now ( ) . isoformat ( ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : True , [string] : [number] , [string] : False , [string] : False , } [EOL] m . get ( TEST_POSTS_ADDRESS + [string] , payload = { [string] : [ mock_post ] } , ) [EOL] [EOL] posts_response = await posts_client . get_posts ( query = { [string] : [string] } ) [EOL] assert len ( posts_response ) is [number] [EOL] [EOL] async def test_get_posts_error ( self ) : [EOL] error = None [EOL] try : [EOL] await posts_client . get_posts ( ) [EOL] except PostsApiError as e : [EOL] error = e [EOL] assert type ( error ) == PostsApiError [EOL] [EOL] @ aioresponses ( ) async def test_get_posts_server_error ( self , m ) : [EOL] m . get ( TEST_POSTS_ADDRESS + [string] , status = [number] ) [EOL] try : [EOL] await posts_client . get_posts ( ) [EOL] except PostsApiError as e : [EOL] error = e [EOL] [EOL] assert type ( error ) == PostsApiError [EOL] [EOL] @ aioresponses ( ) async def test_get_posts_non_json_response ( self , m ) : [EOL] m . get ( TEST_POSTS_ADDRESS + [string] , body = [string] ) [EOL] try : [EOL] await posts_client . get_posts ( ) [EOL] except InvalidResponse as e : [EOL] error = e [EOL] [EOL] assert type ( error ) == InvalidResponse [EOL] [EOL] @ aioresponses ( ) async def test_get_posts_bad_json_response ( self , m ) : [EOL] m . get ( TEST_POSTS_ADDRESS + [string] , payload = { [string] : [ ] } ) [EOL] try : [EOL] await posts_client . get_posts ( ) [EOL] except InvalidResponse as e : [EOL] error = e [EOL] [EOL] assert type ( error ) == InvalidResponse [EOL] [EOL] @ aioresponses ( ) async def test_set_approval_requested ( self , m ) : [EOL] mock_post_id = [string] [EOL] m . put ( TEST_POSTS_ADDRESS + [string] + mock_post_id + [string] , payload = { [string] : True } , ) [EOL] [EOL] success = await posts_client . set_approval_requested ( mock_post_id , True ) [EOL] [EOL] assert success == True , [string] [EOL] [EOL] async def test_set_approval_requested_error ( self ) : [EOL] error = None [EOL] try : [EOL] await posts_client . set_approval_requested ( [string] , True ) [EOL] except PostsApiError as e : [EOL] error = e [EOL] assert type ( error ) == PostsApiError [EOL] [EOL] @ aioresponses ( ) async def test_set_approval_requested_server_error ( self , m ) : [EOL] mock_post_id = [string] [EOL] m . put ( TEST_POSTS_ADDRESS + [string] + mock_post_id + [string] , status = [number] , ) [EOL] [EOL] error = None [EOL] try : [EOL] await posts_client . set_approval_requested ( mock_post_id , True ) [EOL] except PostsApiError as e : [EOL] error = e [EOL] assert type ( error ) == PostsApiError [EOL] [EOL] @ aioresponses ( ) async def test_set_approval_requested_non_json_response ( self , m ) : [EOL] mock_post_id = [string] [EOL] m . put ( TEST_POSTS_ADDRESS + [string] + mock_post_id + [string] , body = [string] , ) [EOL] try : [EOL] await posts_client . set_approval_requested ( mock_post_id , True ) [EOL] except InvalidResponse as e : [EOL] error = e [EOL] [EOL] assert type ( error ) == InvalidResponse [EOL] [EOL] @ aioresponses ( ) async def test_set_approval_requested_bad_json_response ( self , m ) : [EOL] mock_post_id = [string] [EOL] m . put ( TEST_POSTS_ADDRESS + [string] + mock_post_id + [string] , payload = { [string] : True } , ) [EOL] try : [EOL] await posts_client . set_approval_requested ( mock_post_id , True ) [EOL] except InvalidResponse as e : [EOL] error = e [EOL] [EOL] assert type ( error ) == InvalidResponse [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 $announcer.api.posts.PostsApi$ 0 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 $announcer.api.posts.PostsApi$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[announcer.api.posts.Post]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.InvalidResponse$ 0 0 0 0 0 0 0 $announcer.api.posts.InvalidResponse$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.InvalidResponse$ 0 0 0 0 0 0 0 $announcer.api.posts.InvalidResponse$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $announcer.api.posts.PostsApi$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 $announcer.api.posts.PostsApiError$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.InvalidResponse$ 0 0 0 0 0 0 0 $announcer.api.posts.InvalidResponse$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 $aioresponses.aioresponses$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.PostsApi$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $announcer.api.posts.InvalidResponse$ 0 0 0 0 0 0 0 $announcer.api.posts.InvalidResponse$ 0 0 0 0
from typing import List , Any , Dict [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import json [EOL] from typing import List [EOL] [EOL] import aiohttp [EOL] from aiohttp . client_exceptions import ClientConnectionError [EOL] from dateutil . parser import parse [EOL] [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] @ dataclass class Post : [EOL] id = ... [EOL] author = ... [EOL] title = ... [EOL] content = ... [EOL] num_images = ... [EOL] date = ... [EOL] approved = False [EOL] pinned = False [EOL] notified = False [EOL] approval_requested = False [EOL] [EOL] [EOL] class PostsApiError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidResponse ( PostsApiError ) : [EOL] pass [EOL] [EOL] [EOL] class PostsApi : [EOL] TIMEOUT = [number] [EOL] POSTS_KEY = [string] [EOL] SUCCESS_KEY = [string] [EOL] [EOL] def __init__ ( self , address ) : [EOL] self . _address = address [EOL] [EOL] def _decode_post ( self , post_data ) : [EOL] return Post ( id = post_data [ [string] ] , author = post_data [ [string] ] , title = post_data [ [string] ] , content = post_data [ [string] ] , num_images = post_data [ [string] ] , date = parse ( post_data [ [string] ] ) , approved = post_data [ [string] ] , pinned = post_data [ [string] ] , notified = post_data [ [string] ] , approval_requested = post_data [ [string] ] , ) [EOL] [EOL] async def _get_response ( self , request ) : [EOL] try : [EOL] async with request as response : [EOL] if response . status == [number] : [EOL] raise PostsApiError ( [string] ) [EOL] return await response . json ( ) [EOL] except ( TimeoutError , ClientConnectionError ) as e : [EOL] raise PostsApiError ( e ) [EOL] except json . JSONDecodeError as e : [EOL] raise InvalidResponse ( [string] ) [EOL] [EOL] async def get_posts ( self , query = None ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] data = await self . _get_response ( session . get ( f"{ self . _address } [string] " , params = query , timeout = PostsApi . TIMEOUT ) ) [EOL] [EOL] if PostsApi . POSTS_KEY not in data : [EOL] raise InvalidResponse ( [string] ) [EOL] [EOL] posts = [ ] [EOL] [EOL] for post_data in data [ PostsApi . POSTS_KEY ] : [EOL] posts . append ( self . _decode_post ( post_data ) ) [EOL] [EOL] return posts [EOL] [EOL] async def set_approval_requested ( self , post_id , requested ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] data = await self . _get_response ( session . put ( f"{ self . _address } [string] { post_id } [string] " , json = { [string] : requested } , timeout = PostsApi . TIMEOUT , ) ) [EOL] [EOL] if PostsApi . SUCCESS_KEY not in data : [EOL] raise InvalidResponse ( [string] ) [EOL] [EOL] return data [ PostsApi . SUCCESS_KEY ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $datetime.datetime$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Post]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import email [EOL] import announcer [EOL] import typing [EOL] import asyncio [EOL] from email . mime . text import MIMEText [EOL] from typing import List [EOL] [EOL] import aiosmtplib [EOL] from aiosmtplib . errors import ( SMTPAuthenticationError , SMTPConnectError , SMTPRecipientsRefused , SMTPResponseException , SMTPTimeoutError , ) [EOL] [EOL] [EOL] class EmailBroadcasterError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class BroadcasterTimeoutError ( EmailBroadcasterError ) : [EOL] pass [EOL] [EOL] [EOL] class ConnectError ( EmailBroadcasterError ) : [EOL] pass [EOL] [EOL] [EOL] class LoginError ( EmailBroadcasterError ) : [EOL] pass [EOL] [EOL] [EOL] class SendError ( EmailBroadcasterError ) : [EOL] pass [EOL] [EOL] [EOL] class BroadcastEmail : [EOL] def __init__ ( self , recipients , subject , body ) : [EOL] if len ( recipients ) is [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . recipients = set ( recipients ) [EOL] self . subject = subject [EOL] self . body = body [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . recipients == other . recipients [EOL] and self . subject == other . subject [EOL] and self . body == other . body ) [EOL] [EOL] [EOL] class EmailBroadcaster : [EOL] def __init__ ( self , host , port , username , password ) : [EOL] self . _client = aiosmtplib . SMTP ( hostname = host , port = port ) [EOL] self . _username = username [EOL] self . _password = password [EOL] [EOL] def _generate_message ( self , recipient , subject , body ) : [EOL] msg = MIMEText ( body ) [EOL] msg [ [string] ] = recipient [EOL] msg [ [string] ] = self . _username [EOL] msg [ [string] ] = subject [EOL] [EOL] return msg . as_string ( ) [EOL] [EOL] async def _send ( self , emails ) : [EOL] try : [EOL] await self . _client . connect ( ) [EOL] await self . _client . starttls ( ) [EOL] except SMTPConnectError as e : [EOL] raise ConnectError ( e ) [EOL] except SMTPTimeoutError as e : [EOL] raise BroadcasterTimeoutError ( e ) [EOL] [EOL] try : [EOL] await self . _client . login ( self . _username , self . _password ) [EOL] except SMTPAuthenticationError as e : [EOL] raise LoginError ( e ) [EOL] except SMTPTimeoutError as e : [EOL] raise BroadcasterTimeoutError ( e ) [EOL] [EOL] for email in emails : [EOL] for recipient in email . recipients : [EOL] try : [EOL] await self . _client . sendmail ( self . _username , recipient , self . _generate_message ( recipient , email . subject , email . body ) , ) [EOL] except ( SMTPRecipientsRefused , SMTPResponseException ) as e : [EOL] raise SendError ( e ) [EOL] except SMTPTimeoutError as e : [EOL] raise BroadcasterTimeoutError ( e ) [EOL] [EOL] try : [EOL] await self . _client . quit ( ) [EOL] except : [EOL] pass [EOL] [EOL] async def send ( self , emails ) : [EOL] error = None [EOL] try : [EOL] await self . _send ( emails ) [EOL] except EmailBroadcasterError as e : [EOL] error = e [EOL] [EOL] self . _client . close ( ) [EOL] [EOL] if error : [EOL] assert error is not None [EOL] raise error [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $email.mime.text.MIMEText$ 0 0 0 $builtins.str$ 0 0 $email.mime.text.MIMEText$ 0 0 0 0 $builtins.str$ 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 $builtins.str$ 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[BroadcastEmail]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[BroadcastEmail]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[BroadcastEmail]$ 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[BroadcastEmail]$ 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0
from typing import List , Any [EOL] import builtins [EOL] import email [EOL] import asyncio [EOL] import typing [EOL] import unittest [EOL] import announcer [EOL] import asyncio [EOL] import unittest [EOL] from email . mime . text import MIMEText [EOL] from unittest . mock import MagicMock , call , create_autospec , patch [EOL] [EOL] import aiosmtplib [EOL] import asynctest [EOL] from aiosmtplib . errors import ( SMTPAuthenticationError , SMTPConnectError , SMTPRecipientsRefused , SMTPResponseException , SMTPTimeoutError , ) [EOL] [EOL] from announcer . broadcasters . email import ( BroadcastEmail , BroadcasterTimeoutError , ConnectError , EmailBroadcaster , EmailBroadcasterError , LoginError , SendError , ) [EOL] [EOL] [EOL] class TestEmailBroadcaster ( asynctest . TestCase ) : [EOL] TEST_EMAIL = [string] [EOL] [EOL] def setup_smtp_mocks ( self ) : [EOL] self . _mock_smtp . quit . reset_mock ( ) [EOL] self . _mock_smtp . connect . reset_mock ( ) [EOL] self . _mock_smtp . starttls . reset_mock ( ) [EOL] self . _mock_smtp . login . reset_mock ( ) [EOL] self . _mock_smtp . sendmail . reset_mock ( ) [EOL] [EOL] mock_future = asyncio . Future ( ) [EOL] mock_future . set_result ( None ) [EOL] [EOL] self . _mock_smtp . connect . return_value = mock_future [EOL] self . _mock_smtp . starttls . return_value = mock_future [EOL] self . _mock_smtp . login . return_value = mock_future [EOL] self . _mock_smtp . sendmail . return_value = mock_future [EOL] self . _mock_smtp . quit . return_value = mock_future [EOL] [EOL] def setUp ( self ) : [EOL] self . _client = EmailBroadcaster ( [string] , [number] , TestEmailBroadcaster . TEST_EMAIL , [string] ) [EOL] [comment] [EOL] self . _mock_smtp = create_autospec ( aiosmtplib . SMTP ) [EOL] self . _client . _client = self . _mock_smtp [EOL] [EOL] @ patch ( [string] ) def test_init ( self , MockSMTP ) : [EOL] [docstring] [EOL] client = EmailBroadcaster ( [string] , [number] , [string] , [string] ) [EOL] [EOL] MockSMTP . assert_called_with ( hostname = [string] , port = [number] ) [EOL] self . assertIs ( client . _username , [string] ) [EOL] self . assertIs ( client . _password , [string] ) [EOL] [EOL] def generate_message ( self , recipient , subject , body ) : [EOL] msg = MIMEText ( body ) [EOL] msg [ [string] ] = recipient [EOL] msg [ [string] ] = TestEmailBroadcaster . TEST_EMAIL [EOL] msg [ [string] ] = subject [EOL] [EOL] return msg . as_string ( ) [EOL] [EOL] async def test_send ( self ) : [EOL] recipients = [ [string] , [string] ] [EOL] subject = [string] [EOL] body = [string] [EOL] [EOL] email = BroadcastEmail ( recipients , subject , body ) [EOL] [EOL] self . setup_smtp_mocks ( ) [EOL] [EOL] await self . _client . send ( [ email ] ) [EOL] [EOL] self . _mock_smtp . connect . assert_called ( ) [EOL] self . _mock_smtp . login . assert_called_with ( self . _client . _username , self . _client . _password ) [EOL] expected_send_calls = [ ] [EOL] for recipient in recipients : [EOL] expected_send_calls . append ( call ( TestEmailBroadcaster . TEST_EMAIL , recipient , self . generate_message ( recipient , subject , body ) , ) ) [EOL] [EOL] self . _mock_smtp . sendmail . assert_has_calls ( expected_send_calls , any_order = True ) [EOL] self . _mock_smtp . quit . assert_called ( ) [EOL] [EOL] async def test_send_login_failure ( self ) : [EOL] recipients = [ [string] , [string] ] [EOL] subject = [string] [EOL] body = [string] [EOL] [EOL] email = BroadcastEmail ( recipients , subject , body ) [EOL] [EOL] self . setup_smtp_mocks ( ) [EOL] [EOL] mock_future = asyncio . Future ( ) [EOL] mock_future . set_exception ( SMTPAuthenticationError ( [number] , [string] ) ) [EOL] self . _mock_smtp . login . return_value = mock_future [EOL] [EOL] error = None [EOL] try : [EOL] await self . _client . send ( [ email ] ) [EOL] except EmailBroadcasterError as e : [EOL] error = e [EOL] [EOL] self . assertIs ( type ( error ) , LoginError ) [EOL] [EOL] mock_future2 = asyncio . Future ( ) [EOL] mock_future2 . set_exception ( SMTPTimeoutError ( [string] ) ) [EOL] self . _mock_smtp . login . return_value = mock_future2 [EOL] [EOL] error2 = None [EOL] try : [EOL] await self . _client . send ( [ email ] ) [EOL] except EmailBroadcasterError as e : [EOL] error2 = e [EOL] [EOL] self . assertIs ( type ( error2 ) , BroadcasterTimeoutError ) [EOL] [EOL] async def test_send_sendmail_failure ( self ) : [EOL] recipients = [ [string] , [string] ] [EOL] subject = [string] [EOL] body = [string] [EOL] [EOL] email = BroadcastEmail ( recipients , subject , body ) [EOL] [EOL] self . setup_smtp_mocks ( ) [EOL] [EOL] mock_future = asyncio . Future ( ) [EOL] mock_future . set_exception ( SMTPResponseException ( [number] , [string] ) ) [EOL] self . _mock_smtp . sendmail . return_value = mock_future [EOL] [EOL] error = None [EOL] try : [EOL] await self . _client . send ( [ email ] ) [EOL] except EmailBroadcasterError as e : [EOL] error = e [EOL] [EOL] self . assertIs ( type ( error ) , SendError ) [EOL] [EOL] mock_future2 = asyncio . Future ( ) [EOL] mock_future2 . set_exception ( SMTPTimeoutError ( [string] ) ) [EOL] self . _mock_smtp . sendmail . return_value = mock_future2 [EOL] [EOL] error2 = None [EOL] try : [EOL] await self . _client . send ( [ email ] ) [EOL] except EmailBroadcasterError as e : [EOL] error2 = e [EOL] [EOL] self . assertIs ( type ( error2 ) , BroadcasterTimeoutError ) [EOL] [EOL] mock_future3 = asyncio . Future ( ) [EOL] mock_future3 . set_exception ( SMTPRecipientsRefused ( [string] ) ) [EOL] self . _mock_smtp . sendmail . return_value = mock_future3 [EOL] [EOL] error3 = None [EOL] try : [EOL] await self . _client . send ( [ email ] ) [EOL] except EmailBroadcasterError as e : [EOL] error3 = e [EOL] [EOL] self . assertIs ( type ( error3 ) , SendError ) [EOL] [EOL] async def test_send_connect_failure ( self ) : [EOL] recipients = [ [string] , [string] ] [EOL] subject = [string] [EOL] body = [string] [EOL] [EOL] email = BroadcastEmail ( recipients , subject , body ) [EOL] [EOL] self . setup_smtp_mocks ( ) [EOL] [EOL] mock_future = asyncio . Future ( ) [EOL] mock_future . set_exception ( SMTPConnectError ( [string] ) ) [EOL] self . _mock_smtp . connect . return_value = mock_future [EOL] [EOL] error = None [EOL] try : [EOL] await self . _client . send ( [ email ] ) [EOL] except EmailBroadcasterError as e : [EOL] error = e [EOL] [EOL] self . assertIs ( type ( error ) , ConnectError ) [EOL] [EOL] mock_future2 = asyncio . Future ( ) [EOL] mock_future2 . set_exception ( SMTPTimeoutError ( [string] ) ) [EOL] self . _mock_smtp . connect . return_value = mock_future2 [EOL] [EOL] error2 = None [EOL] try : [EOL] await self . _client . send ( [ email ] ) [EOL] except EmailBroadcasterError as e : [EOL] error2 = e [EOL] [EOL] self . assertIs ( type ( error2 ) , BroadcasterTimeoutError ) [EOL] [EOL] async def test_quit_failure ( self ) : [EOL] recipients = [ [string] , [string] ] [EOL] subject = [string] [EOL] body = [string] [EOL] [EOL] email = BroadcastEmail ( recipients , subject , body ) [EOL] [EOL] self . setup_smtp_mocks ( ) [EOL] [EOL] mock_future = asyncio . Future ( ) [EOL] mock_future . set_exception ( SMTPResponseException ( [number] , [string] ) ) [EOL] self . _mock_smtp . quit . return_value = mock_future [EOL] [EOL] await self . _client . send ( [ email ] ) [EOL] self . _mock_smtp . quit . assert_called ( ) [EOL] [EOL] mock_future2 = asyncio . Future ( ) [EOL] mock_future2 . set_exception ( SMTPTimeoutError ( [string] ) ) [EOL] self . _mock_smtp . quit . return_value = mock_future2 [EOL] [EOL] await self . _client . send ( [ email ] ) [EOL] self . _mock_smtp . quit . assert_called ( ) [EOL] [EOL] [EOL] class TestBroadcastEmail ( unittest . TestCase ) : [EOL] def test_equality ( self ) : [EOL] self . assertEqual ( BroadcastEmail ( [ [string] , [string] ] , [string] , [string] ) , BroadcastEmail ( [ [string] , [string] ] , [string] , [string] ) , ) [EOL] [EOL] self . assertNotEqual ( BroadcastEmail ( [ [string] , [string] ] , [string] , [string] ) , BroadcastEmail ( [ [string] , [string] ] , [string] , [string] ) , ) [EOL] [EOL] def test_equality_same_recipients ( self ) : [EOL] message = BroadcastEmail ( [ [string] , [string] ] , [string] , [string] ) [EOL] message2 = BroadcastEmail ( [ [string] , [string] ] , [string] , [string] ) [EOL] [EOL] self . assertEqual ( message , message2 ) [EOL] [EOL] def test_empty_recipients ( self ) : [EOL] error = None [EOL] try : [EOL] BroadcastEmail ( [ ] , [string] , [string] ) [EOL] except ValueError as e : [EOL] error = e [EOL] [EOL] self . assertIsNotNone ( error ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcaster$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcaster$ 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcaster$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 $builtins.str$ 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.EmailBroadcasterError$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $announcer.broadcasters.email.BroadcastEmail$ 0 $announcer.broadcasters.email.BroadcastEmail$ 0 0 0 0 $None$ 0 0 0 0 0 $builtins.ValueError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.ValueError$ 0 0 0 0 0 0 0 0 $builtins.ValueError$ 0 0
	0