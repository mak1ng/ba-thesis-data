from typing import Dict , List , Any [EOL] import typing [EOL] import os [EOL] import re [EOL] from setuptools import setup , find_packages [EOL] [EOL] [EOL] HERE = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] def read_file ( filepath ) : [EOL] with open ( filepath , [string] ) as fd : [EOL] return fd . read ( ) [EOL] [EOL] [EOL] META_PATH = os . path . join ( HERE , [string] , [string] , [string] ) [EOL] META_FILE = read_file ( META_PATH ) [EOL] [EOL] [EOL] def find_meta ( name ) : [EOL] dunder_name = [string] + name + [string] [EOL] string = META_FILE [ META_FILE . index ( dunder_name ) : ] [EOL] try : [EOL] return re . match ( [string] . format ( name ) , string ) . group ( [number] ) [EOL] except AttributeError : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] EXTRAS_REQUIRE = { [string] : [ [string] , [string] , [string] ] } [EOL] [EOL] CLASSIFIERS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] setup ( name = [string] , version = find_meta ( [string] ) , url = [string] , license = [string] , description = find_meta ( [string] ) , long_description = read_file ( [string] ) , long_description_content_type = [string] , author = [string] , author_email = [string] , packages = find_packages ( where = [string] , exclude = ( [string] , ) ) , package_dir = { [string] : [string] } , include_package_data = True , keywords = [string] , classifiers = CLASSIFIERS , install_requires = [ [string] ] , extras_require = EXTRAS_REQUIRE , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0
from typing import Literal , Union , Dict [EOL] import typing [EOL] import typing_extensions [EOL] import os [EOL] import sys [EOL] [EOL] import pytest [EOL] [EOL] import futureproof [EOL] [EOL] [EOL] def get_thread_executor ( request = None ) : [EOL] kwargs = dict ( max_workers = [number] ) [EOL] if request and sys . version_info >= ( [number] , [number] ) : [EOL] kwargs [ [string] ] = request . function . __name__ [EOL] return futureproof . ThreadPoolExecutor ( ** kwargs ) [EOL] [EOL] [EOL] def get_process_executor ( ) : [EOL] return futureproof . ProcessPoolExecutor ( max_workers = [number] ) [EOL] [EOL] [EOL] def get_executor_for_type ( ) : [EOL] executor_type = os . getenv ( [string] , [string] ) [EOL] [EOL] if executor_type == [string] : [EOL] return get_thread_executor ( ) [EOL] else : [EOL] return get_process_executor ( ) [EOL] [EOL] [EOL] @ pytest . fixture def thread_executor ( request ) : [EOL] return get_thread_executor ( request ) [EOL] [EOL] [EOL] @ pytest . fixture def process_executor ( ) : [EOL] return get_process_executor ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import functools [EOL] import logging [EOL] import time [EOL] from functools import partial [EOL] from random import random [EOL] [EOL] import pytest [EOL] [EOL] import futureproof [EOL] [EOL] import conftest [EOL] [EOL] [EOL] def _setup_logging ( ) : [EOL] [docstring] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] , datefmt = [string] , ) [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] [EOL] def custom_sum ( a , b ) : [EOL] time . sleep ( random ( ) ) [EOL] return a + b [EOL] [EOL] [EOL] def flaky_sum ( a , b , delay = [number] ) : [EOL] if delay : [EOL] time . sleep ( delay ) [EOL] if a % [number] == [number] : [EOL] raise ValueError [EOL] return a + b [EOL] [EOL] [EOL] def test_raise_immediate_exceptions ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] tm = futureproof . TaskManager ( executor ) [EOL] [EOL] tm . submit ( custom_sum , [number] ) [EOL] with pytest . raises ( TypeError ) as exc_info : [EOL] tm . run ( ) [EOL] [EOL] assert [string] == str ( exc_info . value ) [EOL] [EOL] [EOL] def test_log_immediate_exceptions ( mocker ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] mock_logger = mocker . patch ( [string] ) [EOL] tm = futureproof . TaskManager ( executor , error_policy = futureproof . ErrorPolicyEnum . LOG ) [EOL] [EOL] tm . submit ( custom_sum , [number] ) [EOL] tm . run ( ) [EOL] [EOL] assert mock_logger . exception . call_count == [number] [EOL] [EOL] [EOL] def test_context_manager_raise_immediate_exceptions ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] with pytest . raises ( TypeError ) as exc_info : [EOL] with futureproof . TaskManager ( executor ) as tm : [EOL] tm . submit ( custom_sum , [number] ) [EOL] [EOL] assert [string] == str ( exc_info . value ) [EOL] [EOL] [EOL] def test_context_manager_log_immediate_exceptions ( mocker ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] mock_logger = mocker . patch ( [string] ) [EOL] [EOL] with futureproof . TaskManager ( executor , error_policy = futureproof . ErrorPolicyEnum . LOG ) as tm : [EOL] tm . submit ( custom_sum , [number] ) [EOL] [EOL] assert mock_logger . exception . call_count == [number] [EOL] [EOL] [EOL] @ pytest . mark . timeout ( [number] ) @ pytest . mark . slow def test_submit_valid_functions ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] tm = futureproof . TaskManager ( executor ) [EOL] [EOL] for i in range ( [number] ) : [EOL] tm . submit ( custom_sum , i , [number] ) [EOL] tm . run ( ) [EOL] [EOL] assert list ( range ( [number] , [number] ) ) == sorted ( tm . results ) [EOL] [EOL] [EOL] def test_submit_flaky_functions ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] tm = futureproof . TaskManager ( executor ) [EOL] [EOL] for i in range ( [number] , [number] ) : [EOL] tm . submit ( flaky_sum , i , [number] , delay = [number] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] tm . run ( ) [EOL] [EOL] assert len ( tm . results ) < [number] [EOL] failed_task = next ( task for task in tm . completed_tasks if isinstance ( task . result , Exception ) ) [EOL] assert isinstance ( failed_task . result , ValueError ) [EOL] [EOL] [EOL] def test_submit_flaky_functions_context_manager ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] with pytest . raises ( ValueError ) : [EOL] with futureproof . TaskManager ( executor ) as tm : [EOL] for i in range ( [number] , [number] ) : [EOL] tm . submit ( flaky_sum , i , [number] ) [EOL] [EOL] assert len ( tm . results ) < [number] [EOL] failed_task = next ( task for task in tm . completed_tasks if isinstance ( task . result , Exception ) ) [EOL] assert isinstance ( failed_task . result , ValueError ) [EOL] [EOL] [EOL] @ pytest . mark . timeout ( [number] ) @ pytest . mark . slow def test_map_generator ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] fn = partial ( custom_sum , b = [number] ) [EOL] with futureproof . TaskManager ( executor ) as tm : [EOL] tm . map ( fn , range ( [number] ) ) [EOL] [EOL] assert list ( range ( [number] , [number] ) ) == sorted ( tm . results ) [EOL] [EOL] [EOL] @ pytest . mark . timeout ( [number] ) @ pytest . mark . slow def test_map_lazy_generator ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] [EOL] def gen ( ) : [EOL] for i in range ( [number] ) : [EOL] time . sleep ( [number] ) [EOL] yield i [EOL] [EOL] fn = partial ( custom_sum , b = [number] ) [EOL] tm = futureproof . TaskManager ( executor ) [EOL] tm . map ( fn , gen ( ) ) [EOL] tm . run ( ) [EOL] [EOL] assert list ( range ( [number] , [number] ) ) == sorted ( tm . results ) [EOL] [EOL] [EOL] @ pytest . mark . timeout ( [number] ) def test_submit_after_map ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] fn = partial ( custom_sum , b = [number] ) [EOL] tm = futureproof . TaskManager ( executor ) [EOL] tm . map ( fn , range ( [number] ) ) [EOL] tm . submit ( fn , [number] ) [EOL] tm . run ( ) [EOL] [EOL] assert list ( range ( [number] , [number] ) ) == sorted ( tm . results ) [EOL] [EOL] [EOL] @ pytest . mark . timeout ( [number] ) def test_map_after_submit ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] fn = partial ( custom_sum , b = [number] ) [EOL] tm = futureproof . TaskManager ( executor ) [EOL] tm . submit ( fn , [number] ) [EOL] tm . map ( fn , range ( [number] , [number] ) ) [EOL] tm . run ( ) [EOL] [EOL] assert list ( range ( [number] , [number] ) ) == sorted ( tm . results ) [EOL] [EOL] [EOL] @ pytest . mark . timeout ( [number] ) def test_as_completed ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] tm = futureproof . TaskManager ( executor ) [EOL] [EOL] for i in range ( [number] ) : [EOL] tm . submit ( custom_sum , i , [number] ) [EOL] [EOL] gen = tm . as_completed ( ) [EOL] assert next ( gen ) . complete [EOL] assert len ( tm . completed_tasks ) == [number] [EOL] [EOL] assert len ( list ( gen ) ) == [number] [EOL] assert list ( range ( [number] , [number] ) ) == sorted ( tm . results ) [EOL] [EOL] [EOL] def test_task_manager_error_policy_as_string ( ) : [EOL] executor = conftest . get_executor_for_type ( ) [EOL] tm = futureproof . TaskManager ( executor , [string] ) [EOL] [EOL] assert tm . _error_policy == futureproof . ErrorPolicyEnum . LOG [EOL] [EOL] [EOL] def test_process_pool_executor_3_7_only ( mocker ) : [EOL] mock_version = mocker . patch ( [string] ) [EOL] mock_version . version_info = ( [number] , [number] , [number] ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] futureproof . ProcessPoolExecutor ( ) [EOL] [EOL] mock_version . version_info = ( [number] , [number] , [number] ) [EOL] assert futureproof . ProcessPoolExecutor ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import concurrent [EOL] [docstring] [EOL] [EOL] import concurrent . futures [EOL] import logging [EOL] import sys [EOL] import urllib . request [EOL] [EOL] import futureproof [EOL] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] , datefmt = [string] , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] URLS = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] [comment] [EOL] def load_url ( url , timeout ) : [EOL] with urllib . request . urlopen ( url , timeout = timeout ) as conn : [EOL] return conn . read ( ) [EOL] [EOL] [EOL] def with_futures ( ) : [EOL] logger . info ( [string] ) [EOL] with concurrent . futures . ThreadPoolExecutor ( max_workers = [number] ) as executor : [EOL] future_to_url = { executor . submit ( load_url , url , [number] ) : url for url in URLS } [EOL] [EOL] for future , url in future_to_url . items ( ) : [EOL] try : [EOL] data = future . result ( ) [EOL] except Exception as exc : [EOL] print ( [string] % ( url , exc ) ) [EOL] else : [EOL] print ( [string] % ( url , len ( data ) ) ) [EOL] [EOL] logger . info ( [string] ) [EOL] [EOL] [EOL] def with_futureproof ( ) : [EOL] executor = futureproof . ThreadPoolExecutor ( max_workers = [number] ) [EOL] with futureproof . TaskManager ( executor , error_policy = futureproof . ErrorPolicyEnum . IGNORE ) as tm : [EOL] for url in URLS : [EOL] tm . submit ( load_url , url , [number] ) [EOL] [EOL] for task in tm . completed_tasks : [EOL] if isinstance ( task . result , Exception ) : [EOL] print ( [string] % ( task . args [ [number] ] , task . result ) ) [EOL] else : [EOL] print ( [string] % ( task . args [ [number] ] , len ( task . result ) ) ) [EOL] [EOL] [EOL] if len ( sys . argv ) > [number] and sys . argv [ [number] ] == [string] : [EOL] with_futures ( ) [EOL] else : [EOL] with_futureproof ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import functools [EOL] [docstring] [EOL] [EOL] import concurrent . futures [EOL] import sys [EOL] import logging [EOL] import time [EOL] from functools import partial [EOL] [EOL] import futureproof [EOL] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] , datefmt = [string] , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def custom_sum ( a , b ) : [EOL] time . sleep ( [number] ) [EOL] return a + b [EOL] [EOL] [EOL] def with_futureproof ( ) : [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] [string] ) [EOL] ex = futureproof . ThreadPoolExecutor ( max_workers = [number] ) [EOL] with futureproof . TaskManager ( ex , error_policy = futureproof . ErrorPolicyEnum . RAISE ) as tm : [EOL] fn = partial ( custom_sum , b = [number] ) [EOL] tm . map ( fn , range ( [number] ) ) [EOL] [EOL] logging . info ( [string] , len ( tm . results ) ) [EOL] [EOL] [EOL] def with_futures ( ) : [EOL] response = input ( [string] [string] [string] ) [EOL] if response == [string] : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] logger . info ( [string] ) [EOL] with concurrent . futures . ThreadPoolExecutor ( max_workers = [number] ) as ex : [EOL] fn = partial ( custom_sum , b = [number] ) [EOL] ex . map ( fn , range ( [number] ) ) [EOL] [EOL] [EOL] if len ( sys . argv ) > [number] and sys . argv [ [number] ] == [string] : [EOL] with_futures ( ) [EOL] else : [EOL] with_futureproof ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import concurrent [EOL] [docstring] [EOL] [EOL] import concurrent . futures [EOL] import sys [EOL] import logging [EOL] import threading [EOL] import time [EOL] from functools import partial [EOL] from random import random [EOL] [EOL] import futureproof [EOL] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] , datefmt = [string] , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def delayed_sum ( a , b ) : [EOL] time . sleep ( random ( ) + [number] ) [EOL] return a + b [EOL] [EOL] [EOL] def with_futureproof ( ) : [EOL] logger . info ( [string] ) [EOL] ex = futureproof . FutureProofExecutor ( max_workers = [number] ) [EOL] with futureproof . TaskManager ( ex ) as tm : [EOL] for i in range ( [number] ) : [EOL] tm . submit ( delayed_sum , i , [number] ) [EOL] for task in tm . as_completed ( ) : [EOL] print ( task . result ) [EOL] [EOL] [EOL] def with_futures ( ) : [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] with concurrent . futures . ThreadPoolExecutor ( max_workers = [number] ) as ex : [EOL] fs = [ ex . submit ( delayed_sum , i , [number] ) for i in range ( [number] ) ] [EOL] for future in concurrent . futures . as_completed ( fs ) : [EOL] print ( future . result ( ) , flush = True ) [EOL] [EOL] [EOL] if len ( sys . argv ) > [number] and sys . argv [ [number] ] == [string] : [EOL] with_futures ( ) [EOL] else : [EOL] with_futureproof ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import concurrent [EOL] [docstring] [EOL] [EOL] import concurrent . futures [EOL] import sys [EOL] import logging [EOL] import time [EOL] from random import random [EOL] [EOL] import futureproof [EOL] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] , datefmt = [string] , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def flaky_sum ( a , b ) : [EOL] time . sleep ( random ( ) * [number] ) [EOL] if a % [number] == [number] : [EOL] raise ValueError [EOL] return a + b [EOL] [EOL] [EOL] def with_futureproof ( ) : [EOL] logger . info ( [string] ) [EOL] ex = futureproof . ThreadPoolExecutor ( max_workers = [number] ) [EOL] with futureproof . TaskManager ( ex , error_policy = futureproof . ErrorPolicyEnum . RAISE ) as tm : [EOL] for i in range ( [number] ) : [EOL] tm . submit ( flaky_sum , i , [number] ) [EOL] [comment] [EOL] [EOL] [EOL] def with_futures ( ) : [EOL] logger . info ( [string] ) [EOL] with concurrent . futures . ThreadPoolExecutor ( max_workers = [number] ) as ex : [EOL] fs = [ ex . submit ( flaky_sum , i , [number] ) for i in range ( [number] ) ] [EOL] for future in concurrent . futures . as_completed ( fs ) : [EOL] try : [EOL] print ( future . result ( ) ) [EOL] except ValueError : [EOL] logger . info ( [string] [string] [string] [string] ) [EOL] logger . info ( [string] [string] [string] ) [EOL] raise [EOL] [EOL] [EOL] if len ( sys . argv ) > [number] and sys . argv [ [number] ] == [string] : [EOL] with_futures ( ) [EOL] else : [EOL] with_futureproof ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import concurrent [EOL] [docstring] [EOL] [EOL] import concurrent . futures [EOL] import sys [EOL] import logging [EOL] import time [EOL] from random import random [EOL] [EOL] import futureproof [EOL] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] , datefmt = [string] , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def flaky_sum ( a , b ) : [EOL] time . sleep ( random ( ) * [number] ) [EOL] if a % [number] == [number] : [EOL] raise ValueError [EOL] return a + b [EOL] [EOL] [EOL] def with_futureproof ( ) : [EOL] logger . info ( [string] ) [EOL] ex = futureproof . ThreadPoolExecutor ( max_workers = [number] ) [EOL] results = [ ] [EOL] [comment] [EOL] with futureproof . TaskManager ( ex , error_policy = futureproof . ErrorPolicyEnum . IGNORE ) as tm : [EOL] for i in range ( [number] ) : [EOL] tm . submit ( flaky_sum , i , [number] ) [EOL] [EOL] for task in tm . as_completed ( ) : [EOL] if isinstance ( task . result , Exception ) : [EOL] logger . exception ( [string] , exc_info = task . result ) [EOL] else : [EOL] results . append ( task . result ) [EOL] [EOL] print ( results ) [EOL] [EOL] [EOL] def with_futures ( ) : [EOL] logger . info ( [string] ) [EOL] with concurrent . futures . ThreadPoolExecutor ( max_workers = [number] ) as ex : [EOL] fs = [ ex . submit ( flaky_sum , i , [number] ) for i in range ( [number] ) ] [EOL] results = [ ] [EOL] for f in concurrent . futures . as_completed ( fs ) : [EOL] logger . info ( [string] ) [EOL] try : [EOL] results . append ( f . result ( ) ) [EOL] except Exception : [EOL] logger . exception ( [string] ) [EOL] [EOL] print ( results ) [EOL] [EOL] [EOL] if len ( sys . argv ) > [number] and sys . argv [ [number] ] == [string] : [EOL] with_futures ( ) [EOL] else : [EOL] with_futureproof ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import concurrent [EOL] import concurrent . futures [EOL] import logging [EOL] import sys [EOL] import time [EOL] [EOL] import futureproof [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG , format = [string] , datefmt = [string] , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def flaky_sum ( a , b , delay = [number] ) : [EOL] if delay : [EOL] time . sleep ( delay ) [EOL] if a % [number] == [number] : [EOL] raise ValueError [EOL] return a + b [EOL] [EOL] [EOL] def with_futureproof ( ) : [EOL] process_executor = futureproof . ProcessPoolExecutor ( max_workers = [number] ) [EOL] tm = futureproof . TaskManager ( process_executor , error_policy = [string] ) [EOL] for i in range ( [number] ) : [EOL] tm . submit ( flaky_sum , i , [number] , delay = [number] ) [EOL] tm . run ( ) [EOL] [EOL] [EOL] def with_futures ( ) : [EOL] with concurrent . futures . ProcessPoolExecutor ( max_workers = [number] ) as ex : [EOL] futs = [ ex . submit ( flaky_sum , i , [number] , delay = [number] ) for i in range ( [number] ) ] [EOL] for fut in concurrent . futures . as_completed ( futs ) : [EOL] try : [EOL] result = fut . result ( ) [EOL] except Exception as exc : [EOL] print ( [string] , exc ) [EOL] else : [EOL] print ( result ) [EOL] [EOL] [EOL] if len ( sys . argv ) > [number] and sys . argv [ [number] ] == [string] : [EOL] with_futures ( ) [EOL] else : [EOL] with_futureproof ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0