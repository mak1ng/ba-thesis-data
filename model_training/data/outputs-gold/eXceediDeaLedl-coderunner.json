from typing import Any [EOL] import typing [EOL] import os [EOL] import codecs [EOL] from setuptools import find_packages , setup [EOL] [EOL] here = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] def read ( * parts ) : [EOL] with codecs . open ( os . path . join ( here , * parts ) , [string] ) as fp : [EOL] return fp . read ( ) [EOL] [EOL] [EOL] long_description = read ( [string] ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , license = [string] , classifiers = [ [string] , [string] , [string] , ] , url = [string] , project_urls = { [string] : [string] , [string] : [string] , [string] : [string] , } , keywords = [string] , author = [string] , author_email = [string] , package_dir = { [string] : [string] } , packages = find_packages ( where = [string] , exclude = [ ] , ) , entry_points = { [string] : [ [string] , ] , } , include_package_data = True , zip_safe = False , python_requires = [string] , install_requires = [ [string] , [string] , [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple , Iterator , Optional [EOL] import builtins [EOL] import typing [EOL] import ecr [EOL] import difflib [EOL] from typing import Optional , Tuple [EOL] [EOL] from ecr . lib . judger import DataItem , JudgeResult , judging , trimLineEnd [EOL] [EOL] [EOL] def judge ( std , out ) : [EOL] diff = difflib . context_diff ( trimLineEnd ( std . data ) , trimLineEnd ( out . data ) , fromfile = std . name , tofile = out . name , lineterm = [string] ) [EOL] ls = list ( diff ) [EOL] if ls : [EOL] return JudgeResult . Wrong , [string] . join ( ls ) [EOL] else : [EOL] return JudgeResult . Accept , None [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] judging ( judge ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[ecr.lib.judger.JudgeResult,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( ) : [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Optional , Tuple , Iterator [EOL] import builtins [EOL] import typing [EOL] import ecr [EOL] import difflib [EOL] import os [EOL] from typing import Optional , Tuple [EOL] [EOL] from ecr . lib . judger import DataItem , JudgeResult , trimLineEnd , getFileContents , judged [EOL] from ecr . lib . console import info , error , write [EOL] [EOL] dataPath = [string] [EOL] [EOL] [EOL] def judgeOne ( std , out ) : [EOL] diff = difflib . context_diff ( trimLineEnd ( std . data ) , trimLineEnd ( out . data ) , fromfile = std . name , tofile = out . name , lineterm = [string] ) [EOL] ls = list ( diff ) [EOL] if ls : [EOL] return JudgeResult . Wrong , [string] . join ( ls ) [EOL] else : [EOL] return JudgeResult . Accept , None [EOL] [EOL] [EOL] def judge ( ) : [EOL] total = [number] [EOL] passed = [number] [EOL] for item in os . listdir ( dataPath ) : [EOL] inputFile = os . path . join ( dataPath , item ) [EOL] if not os . path . isfile ( inputFile ) : [EOL] continue [EOL] if not item . startswith ( [string] ) : [EOL] continue [EOL] total += [number] [EOL] name = os . path . splitext ( item ) [ [number] ] . replace ( [string] , [string] ) [EOL] expect = os . path . join ( dataPath , item . replace ( [string] , [string] ) ) [EOL] real = os . path . join ( dataPath , item . replace ( [string] , [string] ) ) [EOL] info ( f" [string] { name }" ) [EOL] data = getFileContents ( expect , real ) [EOL] result , message = judgeOne ( DataItem ( expect , data [ [number] ] ) , DataItem ( real , data [ [number] ] ) ) [EOL] if result == JudgeResult . Accept : [EOL] passed += [number] [EOL] else : [EOL] error ( f" [string] { name } [string] " ) [EOL] if message : [EOL] write ( message ) [EOL] info ( f" [string] { passed } [string] { total }" ) [EOL] if total == passed : [EOL] return JudgeResult . Accept , None [EOL] else : [EOL] return JudgeResult . Wrong , None [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] judged ( * judge ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Tuple[ecr.lib.judger.JudgeResult,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import os [EOL] import sys [EOL] from ecr . lib . runner import runCommands , CIO_FIFO [EOL] from ecr . lib . console import info , error , write [EOL] [EOL] dataPath = [string] [EOL] timeLimit = [number] [EOL] command = [string] [EOL] [EOL] [EOL] def runOne ( cmd , inputFile , outputFile , timelimit ) : [EOL] return runCommands ( CIO_FIFO , [ cmd ] , { } , os . getcwd ( ) , lambda s : s , inputFile , outputFile , timelimit , False ) [EOL] [EOL] [EOL] def run ( ) : [EOL] global command , timeLimit [EOL] [EOL] if len ( sys . argv ) < [number] : [EOL] print ( [string] ) [EOL] exit ( - [number] ) [EOL] [EOL] command = sys . argv [ [number] ] [EOL] timeLimit = int ( sys . argv [ [number] ] ) [EOL] [EOL] total = [number] [EOL] passed = [number] [EOL] for item in os . listdir ( dataPath ) : [EOL] inputFile = os . path . join ( dataPath , item ) [EOL] if not os . path . isfile ( inputFile ) : [EOL] continue [EOL] if not item . startswith ( [string] ) : [EOL] continue [EOL] total += [number] [EOL] name = os . path . splitext ( item ) [ [number] ] . replace ( [string] , [string] ) [EOL] outputFile = os . path . join ( dataPath , item . replace ( [string] , [string] ) ) [EOL] info ( f" [string] { name }" ) [EOL] result = runOne ( command , inputFile , outputFile , timeLimit ) [EOL] if result : [EOL] passed += [number] [EOL] else : [EOL] error ( f" [string] { name } [string] " ) [EOL] info ( f" [string] { passed } [string] { total }" ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0