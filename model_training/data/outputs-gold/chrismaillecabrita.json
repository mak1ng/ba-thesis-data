from typing import List [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import datetime [EOL] from codecs import open [EOL] from os import path [EOL] from setuptools import setup , find_packages [EOL] from cabrita import __version__ [EOL] [EOL] [EOL] here = path . abspath ( path . dirname ( __file__ ) ) [EOL] [EOL] [comment] [EOL] with open ( path . join ( here , [string] ) , encoding = [string] ) as f : [EOL] long_description = f . read ( ) [EOL] [EOL] install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] if [string] in __version__ : [EOL] now = datetime . datetime . now ( ) [EOL] release_number = ( now - datetime . datetime ( [number] , [number] , [number] ) ) . total_seconds ( ) / [number] [EOL] version = [string] . format ( __version__ , int ( release_number ) ) [EOL] else : [EOL] version = __version__ [EOL] [EOL] setup ( name = [string] , version = version , description = [string] , long_description = long_description , author = [string] , include_package_data = True , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] ] , keywords = [string] , packages = find_packages ( exclude = [ [string] , [string] , [string] ] ) , install_requires = install_requires , entry_points = { [string] : [ [string] ] , } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.float$ 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] __version__ = [string] [EOL]	0 0 $builtins.str$ 0 0 0
from typing import Optional , Any , List [EOL] import builtins [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import sys [EOL] from typing import Optional , List [EOL] [EOL] import requests [EOL] from buzio import console , formatStr [EOL] from pkg_resources import parse_version [EOL] from requests import RequestException [EOL] [EOL] from cabrita import __version__ [EOL] [EOL] [EOL] def versions ( ) : [EOL] [docstring] [EOL] console . info ( [string] ) [EOL] url = [string] [EOL] versions_list = None [EOL] try : [EOL] ret = requests . get ( url , timeout = [number] ) [EOL] data = ret . json ( ) [EOL] except RequestException : [EOL] return None [EOL] if data : [EOL] versions_list = list ( data [ [string] ] . keys ( ) ) [EOL] versions_list . sort ( key = parse_version ) [EOL] return versions_list [EOL] [EOL] [EOL] def check_version ( ) : [EOL] [docstring] [EOL] last_version = __version__ [EOL] version_data = versions ( ) [EOL] if version_data : [EOL] last_version = version_data [ - [number] ] [EOL] if parse_version ( last_version ) > parse_version ( __version__ ) and ( [string] not in last_version and [string] not in last_version and [string] not in last_version ) : [EOL] console . warning ( [string] + [string] . format ( last_version ) ) [EOL] ret = console . confirm ( [string] ) [EOL] if ret : [EOL] result = console . run ( [string] ) [EOL] if result : [EOL] console . success ( [string] ) [EOL] else : [EOL] console . error ( [string] ) [EOL] sys . exit ( [number] ) [EOL] else : [EOL] return formatStr . error ( [string] . format ( last_version ) , use_prefix = False ) [EOL] return formatStr . success ( last_version , use_prefix = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Optional , Match , Any , List [EOL] import raven [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import re [EOL] import subprocess [EOL] from typing import Optional [EOL] [EOL] from buzio import formatStr [EOL] from raven import Client [EOL] from raven . transport . requests import RequestsHTTPTransport [EOL] [EOL] [EOL] def get_sentry_client ( ) : [EOL] [docstring] [EOL] return Client ( os . getenv ( [string] ) , transport = RequestsHTTPTransport ) if os . getenv ( [string] ) else None [EOL] [EOL] [EOL] def run_command ( task , get_stdout = False ) : [EOL] [docstring] [EOL] try : [EOL] if get_stdout is True : [EOL] ret = subprocess . check_output ( task , shell = True ) [EOL] else : [EOL] ret = subprocess . call ( task , shell = True , stderr = subprocess . STDOUT ) [EOL] [EOL] if ret != [number] and not get_stdout : [EOL] return False [EOL] except KeyboardInterrupt : [EOL] raise KeyboardInterrupt [EOL] except Exception : [EOL] return False [EOL] [EOL] if not get_stdout or ret == [number] : [EOL] return True [EOL] if isinstance ( ret , bytes ) : [EOL] return ret . decode ( [string] ) [EOL] else : [EOL] return ret [EOL] [EOL] [EOL] def get_path ( path , base_path ) : [EOL] [docstring] [EOL] def _convert_env_to_path ( env_in_path ) : [EOL] s = re . search ( [string] , env_in_path ) [EOL] if not s : [EOL] s = re . search ( [string] , env_in_path ) [EOL] if s : [EOL] env = s . group ( [number] ) . replace ( [string] , [string] ) [EOL] name = os . environ . get ( env ) [EOL] if not name : [EOL] raise ValueError ( [string] . format ( env ) ) [EOL] path_list = [ part if [string] not in part else name for part in env_in_path . split ( [string] ) ] [EOL] path = os . path . join ( * path_list ) [EOL] else : [EOL] raise ValueError ( [string] . format ( env_in_path ) ) [EOL] return path [EOL] [EOL] if [string] in base_path : [EOL] base_path = _convert_env_to_path ( base_path ) [EOL] if [string] in path : [EOL] path = _convert_env_to_path ( path ) [EOL] if path . startswith ( [string] ) : [EOL] list_path = os . path . join ( base_path , path ) [EOL] path = os . path . abspath ( list_path ) [EOL] return path [EOL] [EOL] [EOL] def format_color ( text , style , theme = None ) : [EOL] [docstring] [EOL] func = getattr ( formatStr , style ) [EOL] return func ( text , use_prefix = False , theme = theme ) if theme else func ( text , use_prefix = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[raven.Client]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List [EOL] import typing [EOL] from unittest import TestCase , mock [EOL] [EOL] import requests_mock [EOL] [EOL] PYPI_TEXT = [string] [EOL] [EOL] [EOL] class TestVersions ( TestCase ) : [EOL] def test_versions ( self ) : [EOL] from cabrita . versions import versions [EOL] with requests_mock . mock ( ) as m : [EOL] url = [string] [EOL] m . get ( url , text = PYPI_TEXT ) [EOL] [EOL] result = versions ( ) [EOL] self . assertListEqual ( result , [ [string] , [string] ] ) [EOL] [EOL] @ mock . patch ( [string] , return_value = False ) @ mock . patch ( [string] , return_value = [ [string] ] ) def test_check_version ( self , * mocks ) : [EOL] from cabrita . versions import check_version [EOL] result = check_version ( ) [EOL] self . assertEqual ( result , [string] ) [EOL] [EOL] @ mock . patch ( [string] , return_value = True ) @ mock . patch ( [string] , return_value = True ) @ mock . patch ( [string] , return_value = [ [string] ] ) def test_check_version_with_update ( self , * mocks ) : [EOL] from cabrita . versions import check_version [EOL] with self . assertRaises ( SystemExit ) as cm : [EOL] check_version ( ) [EOL] [EOL] self . assertEqual ( cm . exception . code , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] from pathlib import Path [EOL] from unittest import TestCase , mock [EOL] [EOL] [EOL] class TestUtils ( TestCase ) : [EOL] [EOL] @ mock . patch ( [string] , return_value = [number] ) def test_run_command ( self , * args ) : [EOL] from cabrita . abc . utils import run_command [EOL] [EOL] test_result = run_command ( [string] ) [EOL] assert test_result is True [EOL] [EOL] def test_real_run_command ( self ) : [EOL] from cabrita . abc . utils import run_command [EOL] [EOL] test_result = run_command ( [string] , get_stdout = True ) [EOL] assert test_result is not [string] [EOL] assert isinstance ( test_result , str ) [EOL] [EOL] def test_get_sentry_client ( self ) : [EOL] from cabrita . abc . utils import get_sentry_client [EOL] [EOL] os . environ [ [string] ] = [string] [EOL] test_client = get_sentry_client ( ) [EOL] assert test_client is not None [EOL] [EOL] def test_get_path ( self ) : [EOL] from cabrita . abc . utils import get_path [EOL] [EOL] [comment] [EOL] if not os . getenv ( [string] ) : [EOL] os . environ [ [string] ] = str ( Path . home ( ) ) [EOL] [EOL] test_path = get_path ( [string] , [string] ) [EOL] assert test_path == str ( Path . home ( ) ) [EOL] [EOL] def test_format_color ( self ) : [EOL] from cabrita . abc . utils import format_color [EOL] [EOL] test_text = format_color ( [string] , [string] ) [EOL] self . assertEqual ( test_text , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
[docstring] [EOL] LATEST_CONFIG_PATH = [string] [EOL] [EOL] INSPECT_DJANGO_CONTAINER = [string] [EOL] [EOL] INSPECT_DJANGO_IMAGE = [string] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from enum import Enum [EOL] from typing import List [EOL] [EOL] [EOL] class BoxColor ( Enum ) : [EOL] [docstring] [EOL] [EOL] black = [number] [EOL] grey = [number] [EOL] blue = [number] [EOL] cyan = [number] [EOL] yellow = [number] [EOL] white = [number] [EOL] [EOL] @ classmethod def available_colors ( cls ) : [EOL] [docstring] [EOL] return sorted ( cls . __members__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0