	0
import beacon_chain [EOL] from eth_utils import denoms [EOL] [EOL] from beacon_chain . beacon_typing . custom import ( Hash32 , ) [EOL] [EOL] [EOL] WEI_PER_ETH = denoms . ether [EOL] ZERO_HASH32 = Hash32 ( [number] * [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $beacon_chain.beacon_typing.custom.Hash32$ 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from beacon_chain . state . constants import ( WEI_PER_ETH , ) [EOL] [EOL] [EOL] BASE_REWARD_QUOTIENT = [number] ** [number] [EOL] DEFAULT_END_DYNASTY = [number] [EOL] DEPOSIT_SIZE = [number] * WEI_PER_ETH [comment] [EOL] CYCLE_LENGTH = [number] [comment] [EOL] MAX_VALIDATOR_COUNT = [number] ** [number] [comment] [EOL] MIN_COMMITTEE_SIZE = [number] [comment] [EOL] MIN_DYNASTY_LENGTH = [number] [comment] [EOL] SHARD_COUNT = [number] [comment] [EOL] SLOT_DURATION = [number] [comment] [EOL] SQRT_E_DROP_TIME = [number] ** [number] [comment] [EOL] [EOL] [comment] [EOL] assert SQRT_E_DROP_TIME % SLOT_DURATION == [number] [EOL] [EOL] [EOL] def generate_config ( * , base_reward_quotient = BASE_REWARD_QUOTIENT , default_end_dynasty = DEFAULT_END_DYNASTY , deposit_size = DEPOSIT_SIZE , cycle_length = CYCLE_LENGTH , max_validator_count = MAX_VALIDATOR_COUNT , min_committee_size = MIN_COMMITTEE_SIZE , min_dynasty_length = MIN_DYNASTY_LENGTH , shard_count = SHARD_COUNT , slot_duration = SLOT_DURATION , sqrt_e_drop_time = SQRT_E_DROP_TIME ) : [EOL] return { [string] : base_reward_quotient , [string] : default_end_dynasty , [string] : deposit_size , [string] : cycle_length , [string] : max_validator_count , [string] : min_committee_size , [string] : min_dynasty_length , [string] : shard_count , [string] : slot_duration , [string] : sqrt_e_drop_time } [EOL] [EOL] [EOL] DEFAULT_CONFIG = generate_config ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
	0
from typing import Dict , Union , Type [EOL] import typing [EOL] from typing import ( Dict , NewType , Union , ) [EOL] [EOL] [EOL] BlockVoteCache = Dict [ str , Dict [ str , Union [ str , bytes , int ] ] ] [EOL] Hash32 = NewType ( [string] , bytes ) [EOL] ShardId = NewType ( [string] , int ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def has_voted ( bitfield , index ) : [EOL] return bool ( bitfield [ index // [number] ] & ( [number] >> ( index % [number] ) ) ) [EOL] [EOL] [EOL] def set_voted ( bitfield , index ) : [EOL] byte_index = index // [number] [EOL] bit_index = index % [number] [EOL] new_byte_value = bitfield [ byte_index ] | ( [number] >> bit_index ) [EOL] return bitfield [ : byte_index ] + bytes ( [ new_byte_value ] ) + bitfield [ byte_index + [number] : ] [EOL] [EOL] [EOL] def get_bitfield_length ( bit_count ) : [EOL] [docstring] [EOL] return ( bit_count + [number] ) // [number] [EOL] [EOL] [EOL] def get_empty_bitfield ( bit_count ) : [EOL] return [string] * get_bitfield_length ( bit_count ) [EOL] [EOL] [EOL] def get_vote_count ( bitfield ) : [EOL] votes = [number] [EOL] for index in range ( len ( bitfield ) * [number] ) : [EOL] if has_voted ( bitfield , index ) : [EOL] votes += [number] [EOL] return votes [EOL] [EOL] [EOL] def or_bitfields ( bitfields ) : [EOL] new = [string] [EOL] for i in range ( len ( bitfields [ [number] ] ) ) : [EOL] byte = [number] [EOL] for bitfield in bitfields : [EOL] byte = bitfield [ i ] | byte [EOL] new += bytes ( [ byte ] ) [EOL] return new [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from . blake import blake [EOL] from py_ecc . optimized_bn128 import ( G1 , G2 , Z1 , Z2 , neg , add , multiply , FQ , FQ2 , FQ12 , pairing , normalize , field_modulus , b , b2 , is_on_curve , curve_order , final_exponentiate ) [EOL] [EOL] [EOL] CACHE = { } [EOL] [comment] [EOL] HEX_ROOT = FQ2 ( [ [number] , [number] ] ) [EOL] [EOL] [EOL] assert HEX_ROOT ** [number] != FQ2 ( [ [number] , [number] ] ) [EOL] assert HEX_ROOT ** [number] == FQ2 ( [ [number] , [number] ] ) [EOL] [EOL] [EOL] def compress_G1 ( pt ) : [EOL] x , y = normalize ( pt ) [EOL] return x . n + [number] ** [number] * ( y . n % [number] ) [EOL] [EOL] [EOL] def decompress_G1 ( p ) : [EOL] if p == [number] : [EOL] return ( FQ ( [number] ) , FQ ( [number] ) , FQ ( [number] ) ) [EOL] x = p % [number] ** [number] [EOL] y_mod_2 = p // [number] ** [number] [EOL] y = pow ( ( x ** [number] + b . n ) % field_modulus , ( field_modulus + [number] ) // [number] , field_modulus ) [EOL] assert pow ( y , [number] , field_modulus ) == ( x ** [number] + b . n ) % field_modulus [EOL] if y % [number] != y_mod_2 : [EOL] y = field_modulus - y [EOL] return ( FQ ( x ) , FQ ( y ) , FQ ( [number] ) ) [EOL] [EOL] [EOL] def sqrt_fq2 ( x ) : [EOL] y = x ** ( ( field_modulus ** [number] + [number] ) // [number] ) [EOL] while y ** [number] != x : [EOL] y *= HEX_ROOT [EOL] return y [EOL] [EOL] [EOL] def hash_to_G2 ( m ) : [EOL] if m in CACHE : [EOL] return CACHE [ m ] [EOL] k2 = m [EOL] while [number] : [EOL] k1 = blake ( k2 ) [EOL] k2 = blake ( k1 ) [EOL] x1 = int . from_bytes ( k1 , [string] ) % field_modulus [EOL] x2 = int . from_bytes ( k2 , [string] ) % field_modulus [EOL] x = FQ2 ( [ x1 , x2 ] ) [EOL] xcb = x ** [number] + b2 [EOL] if xcb ** ( ( field_modulus ** [number] - [number] ) // [number] ) == FQ2 ( [ [number] , [number] ] ) : [EOL] break [EOL] y = sqrt_fq2 ( xcb ) [EOL] o = multiply ( ( x , y , FQ2 ( [ [number] , [number] ] ) ) , [number] * field_modulus - curve_order ) [EOL] CACHE [ m ] = o [EOL] return o [EOL] [EOL] [EOL] def compress_G2 ( pt ) : [EOL] assert is_on_curve ( pt , b2 ) [EOL] x , y = normalize ( pt ) [EOL] return ( x . coeffs [ [number] ] + [number] ** [number] * ( y . coeffs [ [number] ] % [number] ) , x . coeffs [ [number] ] ) [EOL] [EOL] [EOL] def decompress_G2 ( p ) : [EOL] x1 = p [ [number] ] % [number] ** [number] [EOL] y1_mod_2 = p [ [number] ] // [number] ** [number] [EOL] x2 = p [ [number] ] [EOL] x = FQ2 ( [ x1 , x2 ] ) [EOL] if x == FQ2 ( [ [number] , [number] ] ) : [EOL] return FQ2 ( [ [number] , [number] ] ) , FQ2 ( [ [number] , [number] ] ) , FQ2 ( [ [number] , [number] ] ) [EOL] y = sqrt_fq2 ( x ** [number] + b2 ) [EOL] if y . coeffs [ [number] ] % [number] != y1_mod_2 : [EOL] y = y * - [number] [EOL] assert is_on_curve ( ( x , y , FQ2 ( [ [number] , [number] ] ) ) , b2 ) [EOL] return x , y , FQ2 ( [ [number] , [number] ] ) [EOL] [EOL] [EOL] def sign ( m , k ) : [EOL] return compress_G2 ( multiply ( hash_to_G2 ( m ) , k ) ) [EOL] [EOL] [EOL] def privtopub ( k ) : [EOL] return compress_G1 ( multiply ( G1 , k ) ) [EOL] [EOL] [EOL] def verify ( m , pub , sig ) : [EOL] final_exponentiation = final_exponentiate ( pairing ( decompress_G2 ( sig ) , G1 , False ) * pairing ( hash_to_G2 ( m ) , neg ( decompress_G1 ( pub ) ) , False ) ) [EOL] return final_exponentiation == FQ12 . one ( ) [EOL] [EOL] [EOL] def aggregate_sigs ( sigs ) : [EOL] o = Z2 [EOL] for s in sigs : [EOL] o = add ( o , decompress_G2 ( s ) ) [EOL] return compress_G2 ( o ) [EOL] [EOL] [EOL] def aggregate_pubs ( pubs ) : [EOL] o = Z1 [EOL] for p in pubs : [EOL] o = add ( o , decompress_G1 ( p ) ) [EOL] return compress_G1 ( o ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
try : [EOL] from hashlib import blake2b [EOL] except Exception : [EOL] from pyblake2 import blake2b [EOL] [EOL] [EOL] def blake ( x ) : [EOL] return blake2b ( x ) . digest ( ) [ : [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import typing [EOL] import pytest [EOL] [EOL] import beacon_chain . utils . bls as bls [EOL] from beacon_chain . utils . blake import blake [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def privkeys ( ) : [EOL] return [ int . from_bytes ( blake ( str ( i ) . encode ( [string] ) ) [ : [number] ] , [string] ) for i in range ( [number] ) ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def keymap ( privkeys ) : [EOL] keymap = { } [EOL] for i , k in enumerate ( privkeys ) : [EOL] keymap [ bls . privtopub ( k ) ] = k [EOL] if i % [number] == [number] : [EOL] print ( [string] % i ) [EOL] return keymap [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def pubkeys ( keymap ) : [EOL] return list ( keymap ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import beacon_chain [EOL] import typing [EOL] import pytest [EOL] [EOL] from beacon_chain . state . block import ( Block , ) [EOL] from beacon_chain . state . chain import ( Chain , ) [EOL] from beacon_chain . state . constants import ( ZERO_HASH32 , ) [EOL] [EOL] [EOL] def test_head ( ) : [EOL] block = Block ( ) [EOL] chain = Chain ( head = block ) [EOL] [EOL] assert chain . head == block [EOL] [EOL] [EOL] def test_block_by_hash ( ) : [EOL] block = Block ( ) [EOL] chain = Chain ( head = block , blocks = [ block ] ) [EOL] [EOL] assert chain . get_block_by_hash ( block . hash ) == block [EOL] assert chain . get_block_by_hash ( [string] * [number] ) is None [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ] ) def test_block_by_slot_number ( slot_number ) : [EOL] block = Block ( slot_number = slot_number ) [EOL] chain = Chain ( head = block , blocks = [ block ] ) [EOL] [EOL] assert chain . get_block_by_slot_number ( block . slot_number ) == block [EOL] assert chain . get_block_by_slot_number ( block . slot_number + [number] ) is None [EOL] assert chain . get_block_by_slot_number ( - [number] ) is None [EOL] [EOL] [EOL] def test_chain ( ) : [EOL] block = None [EOL] parent_hash = ZERO_HASH32 [EOL] blocks = [ ] [EOL] for slot_number in range ( [number] , [number] ) : [EOL] block = Block ( slot_number = slot_number , parent_hash = parent_hash ) [EOL] blocks . append ( block ) [EOL] parent_hash = block . hash [EOL] [EOL] extra_block = Block ( slot_number = [number] ) [EOL] chain = Chain ( head = block , blocks = blocks + [ extra_block ] ) [EOL] assert len ( chain . chain ) == len ( blocks ) [EOL] for block in blocks : [EOL] assert block in chain [EOL] assert extra_block not in chain [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from beacon_chain . state . config import ( DEFAULT_CONFIG , ) [EOL] from beacon_chain . state . constants import ( ZERO_HASH32 , ) [EOL] from beacon_chain . state . block import Block [EOL] from beacon_chain . state . validator_record import ( ValidatorRecord , ) [EOL] [EOL] [EOL] def mock_validator_record ( pubkey , start_dynasty = [number] , config = DEFAULT_CONFIG ) : [EOL] return ValidatorRecord ( pubkey = pubkey , withdrawal_shard = [number] , withdrawal_address = pubkey . to_bytes ( [number] , [string] ) [ - [number] : ] , randao_commitment = [string] * [number] , balance = config [ [string] ] , start_dynasty = start_dynasty , end_dynasty = config [ [string] ] ) [EOL] [EOL] [EOL] def get_pseudo_chain ( length ) : [EOL] [docstring] [EOL] blocks = [ ] [EOL] for slot in range ( length * [number] ) : [EOL] blocks . append ( Block ( slot_number = slot , parent_hash = blocks [ slot - [number] ] . hash if slot > [number] else ZERO_HASH32 ) ) [EOL] [EOL] return blocks [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import beacon_chain [EOL] import typing [EOL] import pytest [EOL] [EOL] from beacon_chain . state . attestation_record import ( AttestationRecord , ) [EOL] from beacon_chain . state . block import ( Block , ) [EOL] [EOL] [EOL] def test_block_hash ( ) : [EOL] block = Block ( ) [EOL] original_block_hash = block . hash [EOL] [EOL] assert original_block_hash != [string] * [number] [EOL] assert len ( original_block_hash ) == [number] [EOL] [EOL] block = Block ( slot_number = [number] ) [EOL] assert block . hash != original_block_hash [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ] ) def test_num_attestations ( expected ) : [EOL] attestations = [ AttestationRecord ( ) for i in range ( expected ) ] [EOL] block = Block ( attestations = attestations , ) [EOL] [EOL] assert block . num_attestations == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import time [EOL] import pytest [EOL] [EOL] from ssz import ( serialize , ) [EOL] [EOL] from beacon_chain . state . chain import ( Chain , ) [EOL] from beacon_chain . state . state_transition import ( compute_state_transition , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ] , ) def test_state_transition_integration ( genesis_crystallized_state , genesis_active_state , genesis_block , mock_make_child , mock_make_attestations , config ) : [EOL] c = genesis_crystallized_state [EOL] a = genesis_active_state [EOL] block = genesis_block [EOL] a . chain = Chain ( head = block , blocks = [ block ] ) [EOL] print ( [string] ) [EOL] print ( [string] , len ( serialize ( genesis_crystallized_state ) ) ) [EOL] print ( [string] , len ( serialize ( genesis_active_state ) ) ) [EOL] print ( [string] , len ( serialize ( genesis_block ) ) ) [EOL] [EOL] attestations_of_genesis = mock_make_attestations ( ( c , a ) , block , attester_share = [number] ) [EOL] [EOL] block2 , c2 , a2 = mock_make_child ( ( c , a ) , block , [number] , attestations_of_genesis ) [EOL] assert block2 . slot_number == [number] [EOL] assert len ( block2 . attestations ) == len ( attestations_of_genesis ) [EOL] assert block2 . crystallized_state_root == block . crystallized_state_root [EOL] assert block2 . active_state_root != [string] * [number] [EOL] [EOL] t = time . time ( ) [EOL] assert compute_state_transition ( ( c , a ) , block , block2 , config = config ) [EOL] print ( [string] % ( len ( attestations_of_genesis ) , len ( c . shard_and_committee_for_slots [ attestations_of_genesis [ [number] ] . slot ] [ [number] ] . committee ) , ( time . time ( ) - t ) ) ) [EOL] print ( [string] ) [EOL] [EOL] attestations_of_2 = mock_make_attestations ( ( c2 , a2 ) , block2 , attester_share = [number] ) [EOL] [EOL] cycle_transition_slot = c2 . last_state_recalc + config [ [string] ] [EOL] [EOL] block3 , c3 , a3 = mock_make_child ( ( c2 , a2 ) , block2 , cycle_transition_slot , attestations_of_2 ) [EOL] [EOL] t = time . time ( ) [EOL] assert compute_state_transition ( ( c2 , a2 ) , block2 , block3 , config = config ) [EOL] print ( [string] % ( time . time ( ) - t ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] , [number] ) , ] , ) def test_pos_finalization ( monkeypatch , genesis_crystallized_state , genesis_active_state , genesis_block , mock_make_child , mock_make_attestations , config ) : [EOL] from beacon_chain . state import state_transition [EOL] [EOL] def mock_validate_parent_block_proposer ( block , parent_block , crystallized_state , config ) : [EOL] return None [EOL] [EOL] monkeypatch . setattr ( state_transition , [string] , mock_validate_parent_block_proposer ) [EOL] [EOL] c = genesis_crystallized_state [EOL] a = genesis_active_state [EOL] block = genesis_block [EOL] a . chain = Chain ( head = block , blocks = [ block ] ) [EOL] expected_streak = [number] [EOL] assert c . justified_streak == expected_streak [EOL] [EOL] [comment] [EOL] for i in range ( config [ [string] ] - [number] ) : [EOL] attestations = mock_make_attestations ( ( c , a ) , block , attester_share = [number] ) [EOL] block , c , a = mock_make_child ( ( c , a ) , block , block . slot_number + [number] , attestations ) [EOL] [EOL] assert c . last_state_recalc == genesis_crystallized_state . last_state_recalc [EOL] assert c . justified_streak == [number] [EOL] [EOL] [comment] [EOL] attestations = mock_make_attestations ( ( c , a ) , block , attester_share = [number] ) [EOL] block , c , a = mock_make_child ( ( c , a ) , block , block . slot_number + [number] , attestations ) [EOL] [EOL] assert c . last_state_recalc == ( genesis_crystallized_state . last_state_recalc + config [ [string] ] ) [EOL] assert c . justified_streak == config [ [string] ] [EOL] assert c . last_justified_slot == [number] [EOL] assert c . last_finalized_slot == [number] [EOL] [EOL] [comment] [EOL] expected_shards = [ shard_and_committee . shard_id for indices in c . shard_and_committee_for_slots for shard_and_committee in indices ] [EOL] for shard_id , crosslink in enumerate ( c . crosslink_records ) : [EOL] if shard_id in expected_shards : [EOL] assert crosslink . slot == c . last_state_recalc [EOL] else : [EOL] assert crosslink . slot == [number] [EOL] [EOL] [comment] [EOL] for i in range ( config [ [string] ] - [number] ) : [EOL] attestations = mock_make_attestations ( ( c , a ) , block , attester_share = [number] ) [EOL] block , c , a = mock_make_child ( ( c , a ) , block , block . slot_number + [number] , attestations ) [EOL] [EOL] [comment] [EOL] assert c . last_state_recalc == ( genesis_crystallized_state . last_state_recalc + config [ [string] ] ) [EOL] assert c . justified_streak == config [ [string] ] [EOL] assert c . last_justified_slot == [number] [EOL] assert c . last_finalized_slot == [number] [EOL] [EOL] [comment] [EOL] attestations = mock_make_attestations ( ( c , a ) , block , attester_share = [number] ) [EOL] block , c , a = mock_make_child ( ( c , a ) , block , block . slot_number + [number] , attestations ) [EOL] [EOL] assert c . last_state_recalc == ( genesis_crystallized_state . last_state_recalc + config [ [string] ] * [number] ) [EOL] assert c . justified_streak == config [ [string] ] * [number] [EOL] assert c . last_justified_slot == c . last_state_recalc - config [ [string] ] - [number] [EOL] [comment] [EOL] assert c . last_finalized_slot == [number] [EOL] [EOL] [comment] [EOL] for i in range ( config [ [string] ] - [number] ) : [EOL] attestations = mock_make_attestations ( ( c , a ) , block , attester_share = [number] ) [EOL] block , c , a = mock_make_child ( ( c , a ) , block , block . slot_number + [number] , attestations ) [EOL] [EOL] [comment] [EOL] attestations = mock_make_attestations ( ( c , a ) , block , attester_share = [number] ) [EOL] block , c , a = mock_make_child ( ( c , a ) , block , block . slot_number + [number] , attestations ) [EOL] [EOL] assert c . last_state_recalc == ( genesis_crystallized_state . last_state_recalc + config [ [string] ] * [number] ) [EOL] assert c . justified_streak == config [ [string] ] * [number] [EOL] assert c . last_justified_slot == c . last_state_recalc - config [ [string] ] - [number] [EOL] [comment] [EOL] assert c . last_finalized_slot == c . last_justified_slot - config [ [string] ] - [number] [EOL] [EOL] [comment] [EOL] if block . slot_number < config [ [string] ] : [EOL] block , c , a = mock_make_child ( ( c , a ) , block , config [ [string] ] , [ ] ) [EOL] [EOL] assert c . current_dynasty == genesis_crystallized_state . current_dynasty + [number] [EOL] assert c . dynasty_start == c . last_state_recalc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import beacon_chain [EOL] import typing [EOL] import pytest [EOL] [EOL] from beacon_chain . state . crystallized_state import ( CrystallizedState , ) [EOL] from beacon_chain . state . crosslink_record import ( CrosslinkRecord , ) [EOL] [EOL] from tests . state . helpers import ( mock_validator_record , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [ ] ) , ( [string] , [number] ) , ( [string] , [ ] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [ ] ) , ( [string] , [string] * [number] ) , ( [string] , [number] ) , ] ) def test_defaults ( param , default_value , sample_crystallized_state_params ) : [EOL] del sample_crystallized_state_params [ param ] [EOL] crystallized_state = CrystallizedState ( ** sample_crystallized_state_params ) [EOL] [EOL] assert getattr ( crystallized_state , param ) == default_value [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ] ) def test_num_validators ( expected ) : [EOL] validators = [ mock_validator_record ( pubkey ) for pubkey in range ( expected ) ] [EOL] crystallized_state = CrystallizedState ( validators = validators , ) [EOL] [EOL] assert crystallized_state . num_validators == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ] ) def test_num_crosslink_records ( expected ) : [EOL] crosslink_records = [ CrosslinkRecord ( ) for i in range ( expected ) ] [EOL] crystallized_state = CrystallizedState ( crosslink_records = crosslink_records , ) [EOL] [EOL] assert crystallized_state . num_crosslink_records == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] , ] ) def test_total_deposits ( num_active_validators , config ) : [EOL] start_dynasty = [number] [EOL] active_validators = [ mock_validator_record ( pubkey , start_dynasty = start_dynasty ) for pubkey in range ( num_active_validators ) ] [EOL] non_active_validators = [ mock_validator_record ( pubkey , start_dynasty = start_dynasty + [number] ) for pubkey in range ( [number] ) ] [EOL] crystallized_state = CrystallizedState ( validators = active_validators + non_active_validators , current_dynasty = start_dynasty ) [EOL] [EOL] assert len ( crystallized_state . active_validator_indices ) == len ( active_validators ) [EOL] [EOL] expected_total_deposits = config [ [string] ] * num_active_validators [EOL] assert crystallized_state . total_deposits == expected_total_deposits [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import copy [EOL] [EOL] import pytest [EOL] [EOL] from eth_utils import ( ValidationError , ) [EOL] [EOL] from ssz import ( serialize , ) [EOL] [EOL] from beacon_chain . utils . blake import blake [EOL] from beacon_chain . utils . bitfield import ( get_empty_bitfield , has_voted , set_voted , ) [EOL] [EOL] from beacon_chain . state . chain import ( Chain , ) [EOL] from beacon_chain . state . helpers import ( get_attestation_indices , get_shards_and_committees_for_slot , ) [EOL] from beacon_chain . state . state_transition import ( fill_recent_block_hashes , calculate_crosslink_rewards , compute_cycle_transitions , initialize_new_cycle , validate_attestation , ) [EOL] [EOL] [EOL] @ pytest . fixture def attestation_validation_fixture ( genesis_crystallized_state , genesis_active_state , genesis_block , mock_make_child , mock_make_attestations , config ) : [EOL] crystallized_state = genesis_crystallized_state [EOL] active_state = genesis_active_state [EOL] parent_block = genesis_block [EOL] active_state . chain = Chain ( head = parent_block , blocks = [ parent_block ] ) [EOL] attestations_of_genesis = mock_make_attestations ( ( crystallized_state , active_state ) , parent_block , attester_share = [number] ) [EOL] block , _ , _ = mock_make_child ( ( crystallized_state , active_state ) , parent_block , [number] , attestations_of_genesis , ) [EOL] attestation = attestations_of_genesis [ [number] ] [EOL] [EOL] return ( crystallized_state , active_state , attestation , block , parent_block , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] ) , ] , ) def test_validate_attestation_valid ( attestation_validation_fixture , config ) : [EOL] ( crystallized_state , active_state , attestation , block , parent_block ) = attestation_validation_fixture [EOL] [EOL] assert validate_attestation ( crystallized_state , active_state , attestation , block , parent_block , config , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] , - [number] ) , ] , ) def test_validate_attestation_slot ( attestation_validation_fixture , attestation_slot , config ) : [EOL] ( crystallized_state , active_state , attestation , block , parent_block ) = attestation_validation_fixture [EOL] [EOL] attestation . slot = attestation_slot [EOL] with pytest . raises ( ValidationError ) : [EOL] validate_attestation ( crystallized_state , active_state , attestation , block , parent_block , config , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] ) , ] , ) def test_validate_attestation_justified ( attestation_validation_fixture , config ) : [EOL] ( crystallized_state , active_state , original_attestation , block , parent_block ) = attestation_validation_fixture [EOL] [EOL] [comment] [EOL] attestation = copy . deepcopy ( original_attestation ) [EOL] attestation . justified_slot = crystallized_state . last_justified_slot + [number] [EOL] with pytest . raises ( ValidationError ) : [EOL] validate_attestation ( crystallized_state , active_state , attestation , block , parent_block , config , ) [EOL] [EOL] [comment] [EOL] attestation = copy . deepcopy ( original_attestation ) [EOL] attestation . justified_block_hash = [string] * [number] [EOL] with pytest . raises ( ValidationError ) : [EOL] validate_attestation ( crystallized_state , active_state , attestation , block , parent_block , config , ) [EOL] [EOL] [comment] [EOL] attestation = copy . deepcopy ( original_attestation ) [EOL] attestation . justified_slot = attestation . justified_slot - [number] [EOL] with pytest . raises ( ValidationError ) : [EOL] validate_attestation ( crystallized_state , active_state , attestation , block , parent_block , config , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] ) , ] , ) def test_validate_attestation_attester_bitfield ( attestation_validation_fixture , config ) : [EOL] ( crystallized_state , active_state , original_attestation , block , parent_block ) = attestation_validation_fixture [EOL] [EOL] attestation = copy . deepcopy ( original_attestation ) [EOL] attestation . attester_bitfield = get_empty_bitfield ( [number] ) [EOL] with pytest . raises ( ValidationError ) : [EOL] validate_attestation ( crystallized_state , active_state , attestation , block , parent_block , config , ) [EOL] [EOL] attestation = copy . deepcopy ( original_attestation ) [EOL] attestation_indices = get_attestation_indices ( crystallized_state , attestation , config ) [EOL] last_bit = len ( attestation_indices ) [EOL] attestation . attester_bitfield = set_voted ( attestation . attester_bitfield , last_bit ) [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] validate_attestation ( crystallized_state , active_state , attestation , block , parent_block , config , ) [EOL] [EOL] [EOL] @ pytest . mark . noautofixt @ pytest . mark . parametrize ( ( [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] ) , ] , ) def test_validate_attestation_aggregate_sig ( attestation_validation_fixture , config ) : [EOL] ( crystallized_state , active_state , attestation , block , parent_block ) = attestation_validation_fixture [EOL] [EOL] attestation . aggregate_sig = [ [number] , [number] ] [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] validate_attestation ( crystallized_state , active_state , attestation , block , parent_block , config , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] , [number] ) , ] ) [comment] [EOL] def test_calculate_crosslink_rewards ( genesis_crystallized_state , genesis_active_state , genesis_block , config , mock_make_attestations , mock_make_child ) : [EOL] c = genesis_crystallized_state [EOL] a = genesis_active_state [EOL] block = genesis_block [EOL] a . chain = Chain ( head = block , blocks = [ block ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] attestations = mock_make_attestations ( ( c , a ) , block , attester_share = [number] ) [EOL] block2 , c2 , a2 = mock_make_child ( ( c , a ) , block , block . slot_number + config [ [string] ] , attestations ) [EOL] [EOL] [comment] [EOL] attestation = attestations [ [number] ] [EOL] [EOL] [comment] [EOL] attestations2 = mock_make_attestations ( ( c2 , a2 ) , block2 , attester_share = [number] ) [EOL] block3 , c3 , a3 = mock_make_child ( ( c2 , a2 ) , block2 , block2 . slot_number + config [ [string] ] , attestations2 ) [EOL] [EOL] rewards_and_penalties = calculate_crosslink_rewards ( c2 , a2 , block3 , config ) [EOL] [EOL] shard_and_committee = get_shards_and_committees_for_slot ( c2 , block2 . slot_number , config ) [ [number] ] [EOL] for committee_index , validator_index in enumerate ( shard_and_committee . committee ) : [EOL] if has_voted ( attestation . attester_bitfield , committee_index ) : [EOL] assert rewards_and_penalties [ validator_index ] > [number] [EOL] else : [EOL] assert rewards_and_penalties [ validator_index ] < [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] [string] [string] [string] [string] [string] [string] [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] , [number] / [number] , [number] , [number] + [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] , [number] / [number] , [number] , [number] + [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] , [number] / [number] , [number] + [number] , [number] + [number] , [number] - [number] - [number] ) , ( [number] , [number] , [number] , [number] , [number] , [number] / [number] , [number] + [number] , [number] + [number] , [number] ) , ] , ) def test_initialize_new_cycle ( genesis_crystallized_state , genesis_active_state , genesis_block , last_state_recalc , last_justified_slot , justified_streak , last_finalized_slot , fraction_voted , result_last_state_recalc , result_justified_streak , result_last_finalized_slot , config ) : [EOL] [comment] [EOL] parent_crystallized_state = genesis_crystallized_state [EOL] parent_crystallized_state . last_state_recalc = last_state_recalc [EOL] parent_crystallized_state . last_justified_slot = last_justified_slot [EOL] parent_crystallized_state . justified_streak = justified_streak [EOL] parent_crystallized_state . last_finalized_slot = last_finalized_slot [EOL] [EOL] parent_active_state = genesis_active_state [EOL] [EOL] parent_block = genesis_block [EOL] block = copy . deepcopy ( genesis_block ) [EOL] block . slot_number = [number] [EOL] block . parent_hash = blake ( serialize ( parent_block ) ) [EOL] [EOL] active_state = fill_recent_block_hashes ( parent_active_state , parent_block , block ) [EOL] [EOL] fraction_voted *= [number] [comment] [EOL] [comment] [EOL] active_state . block_vote_cache [ block . parent_hash ] = { [string] : set ( ) , [string] : int ( parent_crystallized_state . total_deposits * fraction_voted ) } [EOL] [EOL] crystallized_state , active_state = initialize_new_cycle ( parent_crystallized_state , active_state , block , config = config , ) [EOL] assert crystallized_state . last_state_recalc == result_last_state_recalc [EOL] assert crystallized_state . justified_streak == result_justified_streak [EOL] assert crystallized_state . last_finalized_slot == result_last_finalized_slot [EOL] [EOL] [EOL] def test_compute_cycle_transitions ( genesis_crystallized_state , genesis_active_state , genesis_block , config ) : [EOL] parent_crystallized_state = genesis_crystallized_state [EOL] parent_active_state = genesis_active_state [EOL] parent_block = genesis_block [EOL] block = copy . deepcopy ( genesis_block ) [EOL] block . slot_number = config [ [string] ] * [number] [EOL] [EOL] active_state = fill_recent_block_hashes ( parent_active_state , parent_block , block ) [EOL] crystallized_state , active_state = compute_cycle_transitions ( parent_crystallized_state , active_state , block , config = config , ) [EOL] assert crystallized_state . last_state_recalc == ( block . slot_number // config [ [string] ] * config [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import beacon_chain [EOL] import pytest [EOL] [EOL] from beacon_chain . state . attestation_record import ( AttestationRecord , ) [EOL] from beacon_chain . state . constants import ( ZERO_HASH32 , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [ ] ) , ( [string] , ZERO_HASH32 ) , ( [string] , [string] ) , ( [string] , [number] ) , ( [string] , ZERO_HASH32 ) , ( [string] , [ [number] , [number] ] ) , ] ) def test_defaults ( param , default_value , sample_attestation_record_params ) : [EOL] del sample_attestation_record_params [ param ] [EOL] attestation_record = AttestationRecord ( ** sample_attestation_record_params ) [EOL] [EOL] assert getattr ( attestation_record , param ) == default_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set , List [EOL] import beacon_chain [EOL] import typing [EOL] import pytest [EOL] [EOL] from beacon_chain . state . active_state import ActiveState [EOL] from beacon_chain . state . shard_and_committee import ShardAndCommittee [EOL] from beacon_chain . state . helpers import ( get_new_shuffling , get_shards_and_committees_for_slot , get_block_hash , get_proposer_position , int_sqrt , ) [EOL] [EOL] from tests . state . helpers import ( get_pseudo_chain , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] ) , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] ** [number] + [number] , [number] ** [number] ) ] , ) def test_int_sqrt ( n , output ) : [EOL] assert int_sqrt ( n ) == output [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ] , ) def test_get_new_shuffling_is_complete ( genesis_validators , config ) : [EOL] dynasty = [number] [EOL] [EOL] shuffling = get_new_shuffling ( [string] * [number] , genesis_validators , dynasty , [number] , config ) [EOL] [EOL] assert len ( shuffling ) == config [ [string] ] [EOL] validators = set ( ) [EOL] shards = set ( ) [EOL] for slot_indices in shuffling : [EOL] for shard_and_committee in slot_indices : [EOL] shards . add ( shard_and_committee . shard_id ) [EOL] for vi in shard_and_committee . committee : [EOL] validators . add ( vi ) [EOL] [EOL] [comment] [EOL] assert len ( validators ) == len ( genesis_validators ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] [string] ) , [ ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ] , ) def test_get_new_shuffling_handles_shard_wrap ( genesis_validators , config ) : [EOL] dynasty = [number] [EOL] [EOL] shuffling = get_new_shuffling ( [string] * [number] , genesis_validators , dynasty , config [ [string] ] - [number] , config ) [EOL] [EOL] [comment] [EOL] for slot_indices in shuffling : [EOL] for shard_and_committee in slot_indices : [EOL] assert shard_and_committee . shard_id < config [ [string] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] ) , [ ( [number] , [number] , True ) , ( [number] , [number] , True ) , ( [number] , [number] , False ) , ] , ) def test_get_shards_and_committees_for_slot ( genesis_crystallized_state , num_validators , slot , success , config ) : [EOL] crystallized_state = genesis_crystallized_state [EOL] [EOL] if success : [EOL] shards_and_committees_for_slot = get_shards_and_committees_for_slot ( crystallized_state , slot , config = config , ) [EOL] assert len ( shards_and_committees_for_slot ) > [number] [EOL] else : [EOL] with pytest . raises ( AssertionError ) : [EOL] get_shards_and_committees_for_slot ( crystallized_state , slot , config = config , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] ) , [ ( [number] , [number] , True ) , ( [number] , [number] , True ) , ( [number] , [number] , False ) , ( [number] , [number] , True ) , ( [number] , [number] , True ) , ( [number] , [number] , False ) , ] , ) def test_get_block_hash ( genesis_block , current_block_number , slot , success , config ) : [EOL] cycle_length = config [ [string] ] [EOL] [EOL] blocks = get_pseudo_chain ( cycle_length * [number] ) [EOL] recent_block_hashes = [ [string] * [number] for i in range ( cycle_length * [number] - current_block_number ) ] + [ block . hash for block in blocks [ : current_block_number ] ] [EOL] active_state = ActiveState ( recent_block_hashes = recent_block_hashes , ) [EOL] current_block = blocks [ current_block_number ] [EOL] [EOL] if success : [EOL] block_hash = get_block_hash ( active_state , current_block , slot , config = config , ) [EOL] assert block_hash == blocks [ slot ] . hash [EOL] else : [EOL] with pytest . raises ( AssertionError ) : [EOL] get_block_hash ( active_state , current_block , slot , config = config , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] ) , [ ( [ [number] , [number] , [number] , [number] ] , [number] , [number] ) , ( [ [number] , [number] , [number] , [number] ] , [number] , [number] ) , ( [ [number] , [number] , [number] , [number] ] , [number] , [number] ) , ] , ) def test_get_proposer_position ( monkeypatch , genesis_block , genesis_crystallized_state , committee , parent_block_number , result_proposer_index_in_committee , config ) : [EOL] from beacon_chain . state import helpers [EOL] [EOL] def mock_get_shards_and_committees_for_slot ( parent_block , crystallized_state , config ) : [EOL] return [ ShardAndCommittee ( shard_id = [number] , committee = committee ) , ] [EOL] [EOL] monkeypatch . setattr ( helpers , [string] , mock_get_shards_and_committees_for_slot ) [EOL] [EOL] parent_block = genesis_block [EOL] parent_block . slot_number = parent_block_number [EOL] [EOL] proposer_index_in_committee , shard_id = get_proposer_position ( parent_block , genesis_crystallized_state , config = config , ) [EOL] [EOL] assert proposer_index_in_committee == result_proposer_index_in_committee [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import beacon_chain [EOL] import pytest [EOL] [EOL] from beacon_chain . state . crosslink_record import ( CrosslinkRecord , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [string] * [number] ) , ] ) def test_defaults ( param , default_value , sample_crosslink_record_params ) : [EOL] del sample_crosslink_record_params [ param ] [EOL] crosslink = CrosslinkRecord ( ** sample_crosslink_record_params ) [EOL] [EOL] assert getattr ( crosslink , param ) == default_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import beacon_chain [EOL] import typing [EOL] import pytest [EOL] import random [EOL] [EOL] from ssz import ( serialize , ) [EOL] [EOL] from beacon_chain . state . config import ( BASE_REWARD_QUOTIENT , DEFAULT_END_DYNASTY , DEPOSIT_SIZE , CYCLE_LENGTH , MAX_VALIDATOR_COUNT , MIN_COMMITTEE_SIZE , MIN_DYNASTY_LENGTH , SHARD_COUNT , SLOT_DURATION , SQRT_E_DROP_TIME , generate_config , ) [EOL] from beacon_chain . state . attestation_record import ( AttestationRecord , ) [EOL] from beacon_chain . state . block import ( Block , ) [EOL] from beacon_chain . state . validator_record import ( ValidatorRecord , ) [EOL] from beacon_chain . state . state_transition import ( compute_state_transition , ) [EOL] from beacon_chain . state . genesis_helpers import ( get_genesis_active_state , get_genesis_block , get_genesis_crystallized_state , ) [EOL] from beacon_chain . state . helpers import ( get_hashes_to_sign , get_proposer_position , ) [EOL] [EOL] import beacon_chain . utils . bls [EOL] from beacon_chain . utils . bitfield import ( get_empty_bitfield , set_voted , ) [EOL] from beacon_chain . utils . blake import ( blake , ) [EOL] [EOL] bls = beacon_chain . utils . bls [EOL] [EOL] DEFAULT_SHUFFLING_SEED = [string] * [number] [EOL] DEFAULT_RANDAO = [string] * [number] [EOL] DEFAULT_NUM_VALIDATORS = [number] [EOL] [EOL] [EOL] def bls_verify_mock ( m , pub , sig ) : [EOL] return True [EOL] [EOL] [EOL] def bls_sign_mock ( m , k ) : [EOL] return [number] , [number] [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def mock_bls ( mocker , request ) : [EOL] if [string] in request . keywords : [EOL] return [EOL] [EOL] mocker . patch ( [string] , side_effect = bls_verify_mock ) [EOL] mocker . patch ( [string] , side_effect = bls_sign_mock ) [EOL] [EOL] [EOL] @ pytest . fixture def sample_active_state_params ( ) : [EOL] return { [string] : [ ] , [string] : [ ] , } [EOL] [EOL] [EOL] @ pytest . fixture def sample_attestation_record_params ( ) : [EOL] return { [string] : [number] , [string] : [number] , [string] : [ ] , [string] : [string] * [number] , [string] : [string] , [string] : [number] , [string] : [string] * [number] , [string] : [ [number] , [number] ] , } [EOL] [EOL] [EOL] @ pytest . fixture def sample_block_params ( ) : [EOL] return { [string] : [string] * [number] , [string] : [number] , [string] : [string] * [number] , [string] : [ ] , [string] : [string] * [number] , [string] : [string] * [number] , [string] : [string] * [number] } [EOL] [EOL] [EOL] @ pytest . fixture def sample_crystallized_state_params ( ) : [EOL] return { [string] : [ ] , [string] : [number] , [string] : [ ] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ ] , [string] : [string] * [number] , [string] : [number] , } [EOL] [EOL] [EOL] @ pytest . fixture def sample_recent_proposer_record_params ( ) : [EOL] return { [string] : [number] , [string] : [string] * [number] , [string] : [number] } [EOL] [EOL] [EOL] @ pytest . fixture def sample_shard_and_committee_params ( ) : [EOL] return { [string] : [number] , [string] : [ ] , } [EOL] [EOL] [EOL] @ pytest . fixture def sample_crosslink_record_params ( ) : [EOL] return { [string] : [number] , [string] : [number] , [string] : [string] * [number] , } [EOL] [EOL] [EOL] @ pytest . fixture def init_shuffling_seed ( ) : [EOL] return DEFAULT_SHUFFLING_SEED [EOL] [EOL] [EOL] @ pytest . fixture def init_randao ( ) : [EOL] return DEFAULT_RANDAO [EOL] [EOL] [EOL] @ pytest . fixture def base_reward_quotient ( ) : [EOL] return BASE_REWARD_QUOTIENT [EOL] [EOL] [EOL] @ pytest . fixture def default_end_dynasty ( ) : [EOL] return DEFAULT_END_DYNASTY [EOL] [EOL] [EOL] @ pytest . fixture def deposit_size ( ) : [EOL] return DEPOSIT_SIZE [EOL] [EOL] [EOL] @ pytest . fixture def cycle_length ( ) : [EOL] return CYCLE_LENGTH [EOL] [EOL] [EOL] @ pytest . fixture def max_validator_count ( ) : [EOL] return MAX_VALIDATOR_COUNT [EOL] [EOL] [EOL] @ pytest . fixture def min_committee_size ( ) : [EOL] return MIN_COMMITTEE_SIZE [EOL] [EOL] [EOL] @ pytest . fixture def min_dynasty_length ( ) : [EOL] return MIN_DYNASTY_LENGTH [EOL] [EOL] [EOL] @ pytest . fixture def shard_count ( ) : [EOL] return SHARD_COUNT [EOL] [EOL] [EOL] @ pytest . fixture def slot_duration ( ) : [EOL] return SLOT_DURATION [EOL] [EOL] [EOL] @ pytest . fixture def sqrt_e_drop_time ( ) : [EOL] return SQRT_E_DROP_TIME [EOL] [EOL] [EOL] @ pytest . fixture def config ( base_reward_quotient , default_end_dynasty , deposit_size , cycle_length , max_validator_count , min_committee_size , min_dynasty_length , shard_count , slot_duration , sqrt_e_drop_time ) : [EOL] return generate_config ( base_reward_quotient = base_reward_quotient , default_end_dynasty = default_end_dynasty , deposit_size = deposit_size , cycle_length = cycle_length , max_validator_count = max_validator_count , min_committee_size = min_committee_size , min_dynasty_length = min_dynasty_length , shard_count = shard_count , slot_duration = slot_duration , sqrt_e_drop_time = sqrt_e_drop_time ) [EOL] [EOL] [EOL] @ pytest . fixture def num_validators ( ) : [EOL] return DEFAULT_NUM_VALIDATORS [EOL] [EOL] [EOL] @ pytest . fixture def init_validator_keys ( pubkeys , num_validators ) : [EOL] return pubkeys [ : num_validators ] [EOL] [EOL] [EOL] @ pytest . fixture def genesis_validators ( init_validator_keys , config ) : [EOL] current_dynasty = [number] [EOL] return [ ValidatorRecord ( pubkey = pub , withdrawal_shard = [number] , withdrawal_address = blake ( pub . to_bytes ( [number] , [string] ) ) [ - [number] : ] , randao_commitment = [string] * [number] , balance = config [ [string] ] , start_dynasty = current_dynasty , end_dynasty = config [ [string] ] ) for pub in init_validator_keys ] [EOL] [EOL] [EOL] @ pytest . fixture def genesis_crystallized_state ( genesis_validators , init_shuffling_seed , config ) : [EOL] return get_genesis_crystallized_state ( genesis_validators , init_shuffling_seed , config , ) [EOL] [EOL] [EOL] @ pytest . fixture def genesis_active_state ( config ) : [EOL] return get_genesis_active_state ( config ) [EOL] [EOL] [EOL] @ pytest . fixture def genesis_block ( genesis_active_state , genesis_crystallized_state ) : [EOL] active_state_root = blake ( serialize ( genesis_active_state ) ) [EOL] crystallized_state_root = blake ( serialize ( genesis_crystallized_state ) ) [EOL] [EOL] return get_genesis_block ( active_state_root = active_state_root , crystallized_state_root = crystallized_state_root , ) [EOL] [EOL] [EOL] @ pytest . fixture def mock_make_attestations ( keymap , config ) : [EOL] def mock_make_attestations ( parent_state , block , attester_share = [number] ) : [EOL] crystallized_state , active_state = parent_state [EOL] cycle_length = config [ [string] ] [EOL] [EOL] in_cycle_slot_height = block . slot_number % cycle_length [EOL] indices = crystallized_state . shard_and_committee_for_slots [ cycle_length + in_cycle_slot_height ] [EOL] [EOL] print ( [string] % len ( indices ) ) [EOL] [EOL] proposer_index_in_committee , proposer_shard_id = get_proposer_position ( block , crystallized_state , config = config , ) [EOL] [EOL] attestations = [ ] [EOL] for shard_and_committee in indices : [EOL] shard_id = shard_and_committee . shard_id [EOL] committee_indices = shard_and_committee . committee [EOL] print ( [string] % shard_id ) [EOL] print ( [string] % len ( committee_indices ) ) [EOL] [EOL] justified_slot = crystallized_state . last_justified_slot [EOL] justified_block_hash = active_state . chain . get_block_by_slot_number ( justified_slot ) . hash [EOL] [EOL] [comment] [EOL] attestation = AttestationRecord ( slot = block . slot_number , shard_id = shard_and_committee . shard_id , oblique_parent_hashes = [ ] , shard_block_hash = blake ( bytes ( str ( shard_id ) , [string] ) ) , attester_bitfield = get_empty_bitfield ( len ( committee_indices ) ) , justified_slot = justified_slot , justified_block_hash = justified_block_hash , ) [EOL] [EOL] [comment] [EOL] is_attesting = [ i < attester_share * len ( committee_indices ) for i in range ( len ( committee_indices ) ) ] [EOL] [comment] [EOL] if shard_id == proposer_shard_id : [EOL] is_attesting [ proposer_index_in_committee ] = True [EOL] [EOL] [comment] [EOL] parent_hashes = get_hashes_to_sign ( active_state , block , config ) [EOL] message = blake ( attestation . slot . to_bytes ( [number] , byteorder = [string] ) + [string] . join ( parent_hashes ) + shard_id . to_bytes ( [number] , byteorder = [string] ) + attestation . shard_block_hash + attestation . justified_slot . to_bytes ( [number] , byteorder = [string] ) ) [EOL] sigs = [ bls . sign ( message , keymap [ crystallized_state . validators [ indice ] . pubkey ] ) for i , indice in enumerate ( committee_indices ) if is_attesting [ i ] ] [EOL] attestation . aggregate_sig = bls . aggregate_sigs ( sigs ) [EOL] print ( [string] ) [EOL] [EOL] attestation_bitfield = get_empty_bitfield ( len ( committee_indices ) ) [EOL] for i , attesting in enumerate ( is_attesting ) : [EOL] if attesting : [EOL] attestation_bitfield = set_voted ( attestation_bitfield , i ) [EOL] attestation . attester_bitfield = attestation_bitfield [EOL] print ( [string] , bin ( int . from_bytes ( attestation_bitfield , [string] ) ) ) [EOL] [EOL] attestations . append ( attestation ) [EOL] [EOL] return attestations [EOL] return mock_make_attestations [EOL] [EOL] [EOL] @ pytest . fixture def mock_make_child ( keymap , config ) : [EOL] def mock_make_child ( parent_state , parent , slot_number , attestations = None ) : [EOL] if attestations is None : [EOL] attestations = [ ] [EOL] [EOL] crystallized_state , active_state = parent_state [EOL] block = Block ( parent_hash = parent . hash , slot_number = slot_number , randao_reveal = blake ( str ( random . random ( ) ) . encode ( [string] ) ) , attestations = attestations , pow_chain_ref = [string] * [number] , active_state_root = [string] * [number] , crystallized_state_root = [string] * [number] ) [EOL] print ( [string] ) [EOL] [EOL] new_crystallized_state , new_active_state = compute_state_transition ( ( crystallized_state , active_state ) , parent , block , config = config ) [EOL] print ( [string] ) [EOL] [EOL] if crystallized_state == new_crystallized_state : [EOL] block . crystallized_state_root = parent . crystallized_state_root [EOL] else : [EOL] block . crystallized_state_root = blake ( serialize ( crystallized_state ) ) [EOL] [EOL] block . active_state_root = blake ( serialize ( active_state ) ) [EOL] [EOL] return block , new_crystallized_state , new_active_state [EOL] return mock_make_child [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import beacon_chain [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] from beacon_chain . state . active_state import ( ActiveState , ) [EOL] from beacon_chain . state . attestation_record import ( AttestationRecord , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [ ] ) , ( [string] , [ ] ) , ] ) def test_defaults ( param , default_value , sample_active_state_params ) : [EOL] del sample_active_state_params [ param ] [EOL] active_state = ActiveState ( ** sample_active_state_params ) [EOL] [EOL] assert getattr ( active_state , param ) == default_value [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ] ) def test_num_pending_attestations ( expected ) : [EOL] attestations = [ AttestationRecord ( ) for i in range ( expected ) ] [EOL] active_state = ActiveState ( pending_attestations = attestations , ) [EOL] [EOL] assert active_state . num_pending_attestations == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ (None) , ( { } ) , ( { [string] : [string] } ) , ( { [number] : [number] , [number] : [number] } ) ] ) def test_block_vote_cache ( block_vote_cache ) : [EOL] if block_vote_cache is None : [EOL] active_state = ActiveState ( ) [EOL] assert active_state . block_vote_cache == { } [EOL] return [EOL] [EOL] active_state = ActiveState ( block_vote_cache = block_vote_cache ) [EOL] assert active_state . block_vote_cache == block_vote_cache [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from beacon_chain . state . shard_and_committee import ( ShardAndCommittee , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) , ( [string] , [ ] ) , ] ) def test_defaults ( param , default_value , sample_shard_and_committee_params ) : [EOL] del sample_shard_and_committee_params [ param ] [EOL] shard_and_committee = ShardAndCommittee ( ** sample_shard_and_committee_params ) [EOL] [EOL] assert getattr ( shard_and_committee , param ) == default_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import beacon_chain [EOL] import typing [EOL] from ssz import ( serialize , ) [EOL] [EOL] from beacon_chain . utils . blake import blake [EOL] [EOL] from beacon_chain . state . constants import ( ZERO_HASH32 , ) [EOL] from beacon_chain . state . genesis_helpers import ( get_genesis_active_state , get_genesis_block , get_genesis_crystallized_state , ) [EOL] [EOL] [EOL] def test_get_genesis_active_state ( config ) : [EOL] active_state = get_genesis_active_state ( config ) [EOL] assert active_state . num_pending_attestations == [number] [EOL] assert active_state . num_recent_block_hashes == config [ [string] ] * [number] [EOL] assert len ( active_state . chain . blocks ) == [number] [EOL] assert active_state . chain . head is None [EOL] [EOL] [EOL] def test_get_genesis_crystallized_state ( genesis_validators , init_shuffling_seed , config ) : [EOL] crystallized_state = get_genesis_crystallized_state ( genesis_validators , init_shuffling_seed , config , ) [EOL] len_shard_and_committee_for_slots = config [ [string] ] * [number] [EOL] total_deposits = config [ [string] ] * len ( genesis_validators ) [EOL] [EOL] assert crystallized_state . validators == genesis_validators [EOL] assert crystallized_state . last_state_recalc == [number] [EOL] assert len ( crystallized_state . shard_and_committee_for_slots ) == len_shard_and_committee_for_slots [EOL] assert crystallized_state . last_justified_slot == [number] [EOL] assert crystallized_state . justified_streak == [number] [EOL] assert crystallized_state . last_finalized_slot == [number] [EOL] assert crystallized_state . current_dynasty == [number] [EOL] assert len ( crystallized_state . crosslink_records ) == config [ [string] ] [EOL] for crosslink in crystallized_state . crosslink_records : [EOL] assert crosslink . hash == ZERO_HASH32 [EOL] assert crosslink . slot == [number] [EOL] assert crosslink . dynasty == [number] [EOL] assert crystallized_state . total_deposits == total_deposits [EOL] assert crystallized_state . dynasty_seed == init_shuffling_seed [EOL] assert crystallized_state . dynasty_start == [number] [EOL] [EOL] [EOL] def test_get_genesis_block ( genesis_active_state , genesis_crystallized_state ) : [EOL] active_state_root = blake ( serialize ( genesis_active_state ) ) [EOL] crystallized_state_root = blake ( serialize ( genesis_crystallized_state ) ) [EOL] [EOL] block = get_genesis_block ( active_state_root = active_state_root , crystallized_state_root = crystallized_state_root , ) [EOL] [EOL] assert block . parent_hash == ZERO_HASH32 [EOL] assert block . slot_number == [number] [EOL] assert block . randao_reveal == ZERO_HASH32 [EOL] assert block . num_attestations == [number] [EOL] assert block . pow_chain_ref == ZERO_HASH32 [EOL] assert block . active_state_root == active_state_root [EOL] assert block . crystallized_state_root == crystallized_state_root [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from ssz . ssz import ( eq ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ [ ] , [ ] , True ] , [ [ ( [string] , [string] , [number] ) ] , [ ( [string] , [string] , [number] ) ] , True ] , [ [ ( [string] , [string] , [number] ) , ( [string] , [string] , [string] * [number] ) ] , [ ( [string] , [string] , [number] ) , ( [string] , [string] , [string] * [number] ) ] , True ] , [ [ ( [string] , [string] , [number] ) ] , [ ] , False ] , [ [ ( [string] , [string] , [number] ) ] , [ ( [string] , [string] , [number] ) ] , False ] , [ [ ( [string] , [string] , [number] ) ] , [ ( [string] , [string] , [number] ) ] , False ] , [ [ ( [string] , [string] , [number] ) ] , [ ( [string] , [string] , [number] ) ] , False ] , ] ) def test_eq ( left_fields , right_fields , equal ) : [EOL] class LeftClass : [EOL] fields = { name : typ for name , typ , _ in left_fields } [EOL] defaults = { name : value for name , _ , value in left_fields } [EOL] [EOL] class RightClass : [EOL] fields = { name : typ for name , typ , _ in right_fields } [EOL] defaults = { name : value for name , _ , value in right_fields } [EOL] [EOL] left_object = LeftClass ( ) [EOL] for name , _ , value in left_fields : [EOL] setattr ( left_object , name , value ) [EOL] [EOL] right_object = RightClass ( ) [EOL] for name , _ , value in right_fields : [EOL] setattr ( right_object , name , value ) [EOL] [EOL] assert eq ( left_object , right_object ) == equal [EOL] assert eq ( right_object , left_object ) == equal [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from ssz . ssz import ( to_dict ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( { } , { } ) , ( { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ) , ( [ ] , [ ] ) , ( [ { [string] : [number] } , { [string] : [number] } ] , [ { [string] : [number] } , { [string] : [number] } ] ) ] ) def test_to_dict ( value , result ) : [EOL] assert to_dict ( value ) == result [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ ] , [ ( [string] , [string] , [number] ) , ( [string] , [string] , [string] ) ] ] ) def test_object_to_dict ( field_data ) : [EOL] class foo : [EOL] fields = { name : typ for name , typ , _ in field_data } [EOL] defaults = { name : value for name , _ , value in field_data } [EOL] [EOL] o = foo ( ) [EOL] for name , _ , value in field_data : [EOL] setattr ( o , name , value ) [EOL] [EOL] assert to_dict ( o ) == { name : value for name , _ , value in field_data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from random import randint [EOL] [EOL] import pytest [EOL] [EOL] import eth_utils [EOL] [EOL] from eth_hash . auto import keccak as hash [EOL] [EOL] from tests . contracts . conftest import ( MAX_DEPOSIT , MIN_DEPOSIT , DEPOSIT_CONTRACT_TREE_DEPTH , TWO_TO_POWER_OF_TREE_DEPTH , ) [EOL] [EOL] [EOL] def compute_merkle_root ( leaf_nodes ) : [EOL] assert len ( leaf_nodes ) >= [number] [EOL] empty_node = [string] * [number] [EOL] child_nodes = leaf_nodes [ : ] [EOL] for i in range ( DEPOSIT_CONTRACT_TREE_DEPTH ) : [EOL] parent_nodes = [ ] [EOL] if len ( child_nodes ) % [number] == [number] : [EOL] child_nodes . append ( empty_node ) [EOL] for j in range ( [number] , len ( child_nodes ) , [number] ) : [EOL] parent_nodes . append ( hash ( child_nodes [ j ] + child_nodes [ j + [number] ] ) ) [EOL] child_nodes = parent_nodes [EOL] return child_nodes [ [number] ] [EOL] [EOL] [EOL] def verify_merkle_branch ( leaf , branch , depth , index , root ) : [EOL] value = leaf [EOL] for i in range ( depth ) : [EOL] if index // ( [number] ** i ) % [number] : [EOL] value = hash ( branch [ i ] + value ) [EOL] else : [EOL] value = hash ( value + branch [ i ] ) [EOL] return value == root [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( True , MAX_DEPOSIT ) , ( True , MIN_DEPOSIT ) , ( False , MIN_DEPOSIT - [number] ) , ( False , MAX_DEPOSIT + [number] ) ] ) def test_deposit_amount ( registration_contract , w3 , success , amount_deposit , assert_tx_failed ) : [EOL] [EOL] call = registration_contract . functions . deposit ( [string] * [number] ) [EOL] if success : [EOL] assert call . transact ( { [string] : w3 . toWei ( amount_deposit , [string] ) } ) [EOL] else : [EOL] assert_tx_failed ( lambda : call . transact ( { [string] : w3 . toWei ( amount_deposit , [string] ) } ) ) [EOL] [EOL] [EOL] def test_deposit_log ( registration_contract , a0 , w3 ) : [EOL] log_filter = registration_contract . events . Deposit . createFilter ( fromBlock = [string] , ) [EOL] [EOL] deposit_amount = [ randint ( MIN_DEPOSIT , MAX_DEPOSIT ) * eth_utils . denoms . gwei for _ in range ( [number] ) ] [EOL] for i in range ( [number] ) : [EOL] deposit_input = i . to_bytes ( [number] , [string] ) * [number] [EOL] registration_contract . functions . deposit ( deposit_input , ) . transact ( { [string] : w3 . toWei ( deposit_amount [ i ] , [string] ) } ) [EOL] [EOL] logs = log_filter . get_new_entries ( ) [EOL] assert len ( logs ) == [number] [EOL] log = logs [ [number] ] [ [string] ] [EOL] [EOL] amount_bytes8 = deposit_amount [ i ] . to_bytes ( [number] , [string] ) [EOL] timestamp_bytes8 = int ( w3 . eth . getBlock ( w3 . eth . blockNumber ) [ [string] ] ) . to_bytes ( [number] , [string] ) [EOL] if i == [number] : [EOL] assert log [ [string] ] == [string] * [number] [EOL] else : [EOL] assert log [ [string] ] != [string] * [number] [EOL] assert log [ [string] ] == amount_bytes8 + timestamp_bytes8 + deposit_input [EOL] assert log [ [string] ] == ( i + TWO_TO_POWER_OF_TREE_DEPTH ) . to_bytes ( [number] , [string] ) [EOL] [EOL] [EOL] def test_receipt_tree ( registration_contract , w3 , assert_tx_failed ) : [EOL] deposit_amount = [ randint ( MIN_DEPOSIT , MAX_DEPOSIT ) * eth_utils . denoms . gwei for _ in range ( [number] ) ] [EOL] [EOL] leaf_nodes = [ ] [EOL] for i in range ( [number] , [number] ) : [EOL] deposit_input = i . to_bytes ( [number] , [string] ) * [number] [EOL] tx_hash = registration_contract . functions . deposit ( deposit_input , ) . transact ( { [string] : w3 . toWei ( deposit_amount [ i ] , [string] ) } ) [EOL] receipt = w3 . eth . getTransactionReceipt ( tx_hash ) [EOL] print ( [string] % receipt [ [string] ] ) [EOL] [EOL] timestamp_bytes8 = int ( w3 . eth . getBlock ( w3 . eth . blockNumber ) [ [string] ] ) . to_bytes ( [number] , [string] ) [EOL] amount_bytes8 = deposit_amount [ i ] . to_bytes ( [number] , [string] ) [EOL] data = amount_bytes8 + timestamp_bytes8 + deposit_input [EOL] leaf_nodes . append ( w3 . sha3 ( data ) ) [EOL] root = compute_merkle_root ( leaf_nodes ) [EOL] assert registration_contract . functions . get_deposit_root ( ) . call ( ) == root [EOL] index = randint ( [number] , i ) [EOL] branch = registration_contract . functions . get_branch ( index ) . call ( ) [EOL] assert verify_merkle_branch ( leaf_nodes [ index ] , branch , DEPOSIT_CONTRACT_TREE_DEPTH , index , root ) [EOL] [EOL] [EOL] def test_chain_start ( modified_registration_contract , w3 , assert_tx_failed ) : [EOL] t = getattr ( modified_registration_contract , [string] ) [EOL] [comment] [EOL] min_deposit_amount = MIN_DEPOSIT * eth_utils . denoms . gwei [comment] [EOL] max_deposit_amount = MAX_DEPOSIT * eth_utils . denoms . gwei [EOL] log_filter = modified_registration_contract . events . ChainStart . createFilter ( fromBlock = [string] , ) [EOL] [EOL] index_not_full_deposit = randint ( [number] , t - [number] ) [EOL] for i in range ( t ) : [EOL] if i == index_not_full_deposit : [EOL] [comment] [EOL] deposit_input = [string] * [number] [EOL] modified_registration_contract . functions . deposit ( deposit_input , ) . transact ( { [string] : w3 . toWei ( min_deposit_amount , [string] ) } ) [EOL] logs = log_filter . get_new_entries ( ) [EOL] [comment] [EOL] assert len ( logs ) == [number] [EOL] else : [EOL] [comment] [EOL] deposit_input = i . to_bytes ( [number] , [string] ) * [number] [EOL] modified_registration_contract . functions . deposit ( deposit_input , ) . transact ( { [string] : w3 . toWei ( max_deposit_amount , [string] ) } ) [EOL] logs = log_filter . get_new_entries ( ) [EOL] [comment] [EOL] assert len ( logs ) == [number] [EOL] [EOL] [comment] [EOL] deposit_input = [string] * [number] [EOL] modified_registration_contract . functions . deposit ( deposit_input , ) . transact ( { [string] : w3 . toWei ( max_deposit_amount , [string] ) } ) [EOL] logs = log_filter . get_new_entries ( ) [EOL] assert len ( logs ) == [number] [EOL] timestamp = int ( w3 . eth . getBlock ( w3 . eth . blockNumber ) [ [string] ] ) [EOL] timestamp_day_boundary = timestamp + ( [number] - timestamp % [number] ) [EOL] log = logs [ [number] ] [ [string] ] [EOL] assert log [ [string] ] == modified_registration_contract . functions . get_deposit_root ( ) . call ( ) [EOL] assert int . from_bytes ( log [ [string] ] , byteorder = [string] ) == timestamp_day_boundary [EOL] [EOL] [comment] [EOL] deposit_input = [string] * [number] [EOL] modified_registration_contract . functions . deposit ( deposit_input , ) . transact ( { [string] : w3 . toWei ( max_deposit_amount , [string] ) } ) [EOL] logs = log_filter . get_new_entries ( ) [EOL] assert len ( logs ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import os [EOL] import re [EOL] from random import randint [EOL] import pytest [EOL] import eth_tester [EOL] from eth_tester import ( EthereumTester , PyEVMBackend ) [EOL] from web3 . providers . eth_tester import EthereumTesterProvider [EOL] from web3 import Web3 [EOL] from vyper import compiler [EOL] [EOL] [EOL] [comment] [EOL] MIN_DEPOSIT = [number] [comment] [EOL] MAX_DEPOSIT = [number] [comment] [EOL] DEPOSIT_CONTRACT_TREE_DEPTH = [number] [EOL] TWO_TO_POWER_OF_TREE_DEPTH = [number] [comment] [EOL] [EOL] [EOL] def get_dirs ( path ) : [EOL] own_dir = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] abs_contract_path = os . path . realpath ( os . path . join ( own_dir , [string] , [string] , [string] ) ) [EOL] sub_dirs = [ x [ [number] ] for x in os . walk ( abs_contract_path ) ] [EOL] extra_args = [string] . join ( [ [string] . format ( d . split ( [string] ) [ - [number] ] , d ) for d in sub_dirs ] ) [EOL] path = [string] . format ( abs_contract_path , path ) [EOL] return path , extra_args [EOL] [EOL] [EOL] @ pytest . fixture def registration_code ( ) : [EOL] with open ( get_dirs ( [string] ) [ [number] ] ) as f : [EOL] return f . read ( ) [EOL] [EOL] [EOL] @ pytest . fixture def tester ( ) : [EOL] return EthereumTester ( PyEVMBackend ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture def a0 ( tester ) : [EOL] return tester . get_accounts ( ) [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture def w3 ( tester ) : [EOL] web3 = Web3 ( EthereumTesterProvider ( tester ) ) [EOL] return web3 [EOL] [EOL] [EOL] @ pytest . fixture def registration_contract ( w3 , tester , registration_code ) : [EOL] contract_bytecode = compiler . compile_code ( registration_code ) [ [string] ] [EOL] contract_abi = compiler . mk_full_signature ( registration_code ) [EOL] registration = w3 . eth . contract ( abi = contract_abi , bytecode = contract_bytecode ) [EOL] tx_hash = registration . constructor ( ) . transact ( ) [EOL] tx_receipt = w3 . eth . waitForTransactionReceipt ( tx_hash ) [EOL] registration_deployed = w3 . eth . contract ( address = tx_receipt . contractAddress , abi = contract_abi ) [EOL] return registration_deployed [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def chain_start_full_deposit_thresholds ( ) : [EOL] return [ randint ( [number] , [number] ) , randint ( [number] , [number] ) , randint ( [number] , [number] ) ] [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ [number] , [number] , [number] ] ) def modified_registration_contract ( request , w3 , tester , registration_code , chain_start_full_deposit_thresholds ) : [EOL] [comment] [EOL] t = str ( chain_start_full_deposit_thresholds [ request . param ] ) [EOL] modified_registration_code = re . sub ( [string] , [string] + t , registration_code , ) [EOL] assert modified_registration_code != registration_code [EOL] contract_bytecode = compiler . compile_code ( modified_registration_code ) [ [string] ] [EOL] contract_abi = compiler . mk_full_signature ( modified_registration_code ) [EOL] registration = w3 . eth . contract ( abi = contract_abi , bytecode = contract_bytecode ) [EOL] tx_hash = registration . constructor ( ) . transact ( ) [EOL] tx_receipt = w3 . eth . waitForTransactionReceipt ( tx_hash ) [EOL] registration_deployed = w3 . eth . contract ( address = tx_receipt . contractAddress , abi = contract_abi ) [EOL] setattr ( registration_deployed , [string] , chain_start_full_deposit_thresholds [ request . param ] ) [EOL] return registration_deployed [EOL] [EOL] [EOL] @ pytest . fixture def assert_tx_failed ( tester ) : [EOL] def assert_tx_failed ( function_to_test , exception = eth_tester . exceptions . TransactionFailed ) : [EOL] snapshot_id = tester . take_snapshot ( ) [EOL] with pytest . raises ( exception ) : [EOL] function_to_test ( ) [EOL] tester . revert_to_snapshot ( snapshot_id ) [EOL] return assert_tx_failed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pytest [EOL] [EOL] from beacon_chain . utils . bls import ( G1 , G2 , hash_to_G2 , compress_G1 , compress_G2 , decompress_G1 , decompress_G2 , normalize , multiply , sign , privtopub , aggregate_sigs , aggregate_pubs , verify ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) def test_bls_core ( privkey ) : [EOL] p1 = multiply ( G1 , privkey ) [EOL] p2 = multiply ( G2 , privkey ) [EOL] msg = str ( privkey ) . encode ( [string] ) [EOL] msghash = hash_to_G2 ( msg ) [EOL] assert normalize ( decompress_G1 ( compress_G1 ( p1 ) ) ) == normalize ( p1 ) [EOL] assert normalize ( decompress_G2 ( compress_G2 ( p2 ) ) ) == normalize ( p2 ) [EOL] assert normalize ( decompress_G2 ( compress_G2 ( msghash ) ) ) == normalize ( msghash ) [EOL] sig = sign ( msg , privkey ) [EOL] pub = privtopub ( privkey ) [EOL] assert verify ( msg , pub , sig ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) , ( [string] , [ [number] , [number] , [number] , [number] ] ) , ] ) def test_signature_aggregation ( msg , privkeys ) : [EOL] sigs = [ sign ( msg , k ) for k in privkeys ] [EOL] pubs = [ privtopub ( k ) for k in privkeys ] [EOL] aggsig = aggregate_sigs ( sigs ) [EOL] aggpub = aggregate_pubs ( pubs ) [EOL] assert verify ( msg , aggpub , aggsig ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pytest [EOL] [EOL] from beacon_chain . utils . bitfield import ( has_voted , set_voted , get_bitfield_length , get_empty_bitfield , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] ) def test_bitfield_length ( attester_count , bitfield_length ) : [EOL] assert get_bitfield_length ( attester_count ) == bitfield_length [EOL] [EOL] [EOL] def test_empty_bitfield ( ) : [EOL] attesters = list ( range ( [number] ) ) [EOL] bitfield = get_empty_bitfield ( len ( attesters ) ) [EOL] [EOL] for attester in attesters : [EOL] assert not has_voted ( bitfield , attester ) [EOL] [EOL] [EOL] def test_bitfield_single_votes ( ) : [EOL] attesters = list ( range ( [number] ) ) [EOL] bitfield = get_empty_bitfield ( len ( attesters ) ) [EOL] [EOL] assert set_voted ( bitfield , [number] ) == [string] [EOL] assert set_voted ( bitfield , [number] ) == [string] [EOL] assert set_voted ( bitfield , [number] ) == [string] [EOL] assert set_voted ( bitfield , [number] ) == [string] [EOL] assert set_voted ( bitfield , [number] ) == [string] [EOL] assert set_voted ( bitfield , [number] ) == [string] [EOL] [EOL] for voter in attesters : [EOL] bitfield = set_voted ( [string] , voter ) [EOL] for attester in attesters : [EOL] if attester == voter : [EOL] assert has_voted ( bitfield , attester ) [EOL] else : [EOL] assert not has_voted ( bitfield , attester ) [EOL] [EOL] [EOL] def test_bitfield_all_votes ( ) : [EOL] attesters = list ( range ( [number] ) ) [EOL] [EOL] bitfield = get_empty_bitfield ( len ( attesters ) ) [EOL] for attester in attesters : [EOL] bitfield = set_voted ( bitfield , attester ) [EOL] [EOL] for attester in attesters : [EOL] assert has_voted ( bitfield , attester ) [EOL] assert bitfield == [string] [EOL] [EOL] [EOL] def test_bitfield_some_votes ( ) : [EOL] attesters = list ( range ( [number] ) ) [EOL] voters = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] bitfield = get_empty_bitfield ( len ( attesters ) ) [EOL] for voter in voters : [EOL] bitfield = set_voted ( bitfield , voter ) [EOL] [EOL] assert bitfield == [string] [EOL] [EOL] for attester in attesters : [EOL] if attester in voters : [EOL] assert has_voted ( bitfield , attester ) [EOL] else : [EOL] assert not has_voted ( bitfield , attester ) [EOL] [EOL] [EOL] def test_bitfield_multiple_votes ( ) : [EOL] bitfield = get_empty_bitfield ( [number] ) [EOL] bitfield = set_voted ( bitfield , [number] ) [EOL] bitfield = set_voted ( bitfield , [number] ) [EOL] assert has_voted ( bitfield , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . ssz import ( deepcopy , deserialize , eq , serialize , to_dict , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Type [EOL] import typing [EOL] import collections [EOL] [EOL] [EOL] def serialize ( val , typ = None ) : [EOL] if typ is None and hasattr ( val , [string] ) : [EOL] typ = type ( val ) [EOL] if typ in ( [string] , [string] ) : [EOL] assert len ( val ) == [number] if typ == [string] else [number] [EOL] return val [EOL] elif isinstance ( typ , str ) and typ [ : [number] ] == [string] : [EOL] length = int ( typ [ [number] : ] ) [EOL] assert length % [number] == [number] [EOL] return val . to_bytes ( length // [number] , [string] , signed = True ) [EOL] elif isinstance ( typ , str ) and typ [ : [number] ] == [string] : [EOL] length = int ( typ [ [number] : ] ) [EOL] assert length % [number] == [number] [EOL] assert val >= [number] [EOL] return val . to_bytes ( length // [number] , [string] ) [EOL] elif typ == [string] : [EOL] return len ( val ) . to_bytes ( [number] , [string] ) + val [EOL] elif isinstance ( typ , list ) : [EOL] assert len ( typ ) == [number] [EOL] sub = [string] . join ( [ serialize ( x , typ [ [number] ] ) for x in val ] ) [EOL] return len ( sub ) . to_bytes ( [number] , [string] ) + sub [EOL] elif isinstance ( typ , type ) : [EOL] sub = [string] . join ( [ serialize ( getattr ( val , k ) , typ . fields [ k ] ) for k in sorted ( typ . fields . keys ( ) ) ] ) [EOL] return len ( sub ) . to_bytes ( [number] , [string] ) + sub [EOL] raise Exception ( [string] , val , typ ) [EOL] [EOL] [EOL] def _deserialize ( data , start , typ ) : [EOL] if typ in ( [string] , [string] ) : [EOL] length = [number] if typ == [string] else [number] [EOL] assert len ( data ) + start >= length [EOL] return data [ start : start + length ] , start + length [EOL] elif isinstance ( typ , str ) and typ [ : [number] ] == [string] : [EOL] length = int ( typ [ [number] : ] ) [EOL] assert length % [number] == [number] [EOL] assert len ( data ) + start >= length // [number] [EOL] return int . from_bytes ( data [ start : start + length // [number] ] , [string] , signed = True ) , start + length // [number] [EOL] elif isinstance ( typ , str ) and typ [ : [number] ] == [string] : [EOL] length = int ( typ [ [number] : ] ) [EOL] assert length % [number] == [number] [EOL] assert len ( data ) + start >= length // [number] [EOL] return int . from_bytes ( data [ start : start + length // [number] ] , [string] ) , start + length // [number] [EOL] elif typ == [string] : [EOL] length = int . from_bytes ( data [ start : start + [number] ] , [string] ) [EOL] assert len ( data ) + start >= [number] + length [EOL] return data [ start + [number] : start + [number] + length ] , start + [number] + length [EOL] elif isinstance ( typ , list ) : [EOL] assert len ( typ ) == [number] [EOL] length = int . from_bytes ( data [ start : start + [number] ] , [string] ) [EOL] pos , o = start + [number] , [ ] [EOL] while pos < start + [number] + length : [EOL] result , pos = _deserialize ( data , pos , typ [ [number] ] ) [EOL] o . append ( result ) [EOL] assert pos == start + [number] + length [EOL] return o , pos [EOL] elif isinstance ( typ , type ) : [EOL] length = int . from_bytes ( data [ start : start + [number] ] , [string] ) [EOL] values = { } [EOL] pos = start + [number] [EOL] for k in sorted ( typ . fields . keys ( ) ) : [EOL] values [ k ] , pos = _deserialize ( data , pos , typ . fields [ k ] ) [EOL] assert pos == start + [number] + length [EOL] return typ ( ** values ) , pos [EOL] raise Exception ( [string] , typ ) [EOL] [EOL] [EOL] def deserialize ( data , typ ) : [EOL] return _deserialize ( data , [number] , typ ) [ [number] ] [EOL] [EOL] [EOL] def eq ( x , y ) : [EOL] if hasattr ( x , [string] ) and hasattr ( y , [string] ) : [EOL] if x . fields != y . fields : [EOL] return False [EOL] for f in x . fields : [EOL] if not eq ( getattr ( x , f ) , getattr ( y , f ) ) : [EOL] print ( [string] , x , y , f , getattr ( x , f ) , getattr ( y , f ) ) [EOL] return False [EOL] return True [EOL] elif isinstance ( x , collections . Iterable ) and isinstance ( y , collections . Iterable ) : [EOL] return all ( eq ( xi , yi ) for xi , yi in zip ( x , y ) ) [EOL] else : [EOL] return x == y [EOL] [EOL] [EOL] def deepcopy ( x ) : [EOL] if hasattr ( x , [string] ) : [EOL] vals = { } [EOL] for f in x . fields . keys ( ) : [EOL] vals [ f ] = deepcopy ( getattr ( x , f ) ) [EOL] return x . __class__ ( ** vals ) [EOL] elif isinstance ( x , list ) : [EOL] return [ deepcopy ( y ) for y in x ] [EOL] elif isinstance ( x , dict ) : [EOL] return { key : deepcopy ( x [ key ] ) for key in x } [EOL] elif isinstance ( x , set ) : [EOL] return { deepcopy ( y ) for y in x } [EOL] else : [EOL] return x [EOL] [EOL] [EOL] def to_dict ( x ) : [EOL] if hasattr ( x , [string] ) : [EOL] vals = { } [EOL] for f in x . fields . keys ( ) : [EOL] vals [ f ] = to_dict ( getattr ( x , f ) ) [EOL] return vals [EOL] elif isinstance ( x , list ) : [EOL] return [ to_dict ( y ) for y in x ] [EOL] else : [EOL] return x [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0