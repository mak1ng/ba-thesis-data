[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import os . path [EOL] import re [EOL] import urllib [EOL] [EOL] [EOL] def main ( filename ) : [EOL] names = [ re . search ( [string] , line ) . group ( [number] ) for line in urllib . urlopen ( [string] ) if [string] in line or [string] in line ] [EOL] with open ( filename , [string] ) as f : [EOL] f . write ( [string] ) [EOL] for name in names : [EOL] f . write ( [string] % name ) [EOL] f . write ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , List , Any , Dict [EOL] import typing [EOL] import json [EOL] import os . path [EOL] import re [EOL] import sys [EOL] [EOL] BASE = os . path . dirname ( __file__ . replace ( [string] , [string] ) ) [EOL] sys . path . insert ( [number] , os . path . join ( BASE , [string] ) ) [EOL] sys . path . insert ( [number] , BASE ) [comment] [EOL] [EOL] from mako import exceptions [EOL] from mako . lookup import TemplateLookup [EOL] from mako . template import Template [EOL] [EOL] import data [EOL] [EOL] RE_PYTHON_ADDR = re . compile ( [string] ) [EOL] [EOL] OUT_DIR = os . environ . get ( [string] , [string] ) [EOL] [EOL] STYLE_STRUCT_LIST = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def main ( ) : [EOL] usage = ( [string] % sys . argv [ [number] ] ) [EOL] if len ( sys . argv ) < [number] : [EOL] abort ( usage ) [EOL] engine = sys . argv [ [number] ] [EOL] output = sys . argv [ [number] ] [EOL] [EOL] if engine not in [ [string] , [string] , [string] ] or output not in [ [string] , [string] , [string] ] : [EOL] abort ( usage ) [EOL] [EOL] properties = data . PropertiesData ( engine = engine ) [EOL] files = { } [EOL] for kind in [ [string] , [string] ] : [EOL] files [ kind ] = { } [EOL] for struct in STYLE_STRUCT_LIST : [EOL] file_name = os . path . join ( BASE , kind , [string] . format ( struct ) ) [EOL] if kind == [string] and not os . path . exists ( file_name ) : [EOL] files [ kind ] [ struct ] = [string] [EOL] continue [EOL] files [ kind ] [ struct ] = render ( file_name , engine = engine , data = properties , ) [EOL] properties_template = os . path . join ( BASE , [string] ) [EOL] files [ [string] ] = render ( properties_template , engine = engine , data = properties , __file__ = properties_template , OUT_DIR = OUT_DIR , ) [EOL] if output == [string] : [EOL] write ( OUT_DIR , [string] , files [ [string] ] ) [EOL] for kind in [ [string] , [string] ] : [EOL] for struct in files [ kind ] : [EOL] write ( os . path . join ( OUT_DIR , kind ) , [string] . format ( struct ) , files [ kind ] [ struct ] , ) [EOL] [EOL] if engine == [string] : [EOL] template = os . path . join ( BASE , [string] ) [EOL] rust = render ( template , data = properties ) [EOL] write ( OUT_DIR , [string] , rust ) [EOL] [EOL] if engine in [ [string] , [string] ] : [EOL] if engine == [string] : [EOL] pref_attr = [string] [EOL] if engine == [string] : [EOL] pref_attr = [string] [EOL] properties_dict = { kind : { p . name : { [string] : getattr ( p , pref_attr ) } for prop in properties_list if prop . enabled_in_content ( ) for p in [ prop ] + prop . alias } for kind , properties_list in [ ( [string] , properties . longhands ) , ( [string] , properties . shorthands ) ] } [EOL] as_html = render ( os . path . join ( BASE , [string] ) , properties = properties_dict ) [EOL] as_json = json . dumps ( properties_dict , indent = [number] , sort_keys = True ) [EOL] doc_servo = os . path . join ( BASE , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] write ( doc_servo , [string] , as_html ) [EOL] write ( doc_servo , [string] , as_json ) [EOL] write ( OUT_DIR , [string] , as_json ) [EOL] elif output == [string] : [EOL] if len ( sys . argv ) < [number] : [EOL] abort ( usage ) [EOL] template = sys . argv [ [number] ] [EOL] header = render ( template , data = properties ) [EOL] sys . stdout . write ( header ) [EOL] [EOL] [EOL] def abort ( message ) : [EOL] print ( message , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def render ( filename , ** context ) : [EOL] try : [EOL] lookup = TemplateLookup ( directories = [ BASE ] , input_encoding = [string] , strict_undefined = True ) [EOL] template = Template ( open ( filename , [string] ) . read ( ) , filename = filename , input_encoding = [string] , lookup = lookup , strict_undefined = True ) [EOL] [comment] [EOL] [comment] [EOL] return template . render ( ** context ) [EOL] except Exception : [EOL] [comment] [EOL] [comment] [EOL] abort ( exceptions . text_error_template ( ) . render ( ) ) [EOL] [EOL] [EOL] def write ( directory , filename , content ) : [EOL] if not os . path . exists ( directory ) : [EOL] os . makedirs ( directory ) [EOL] full_path = os . path . join ( directory , filename ) [EOL] open ( full_path , [string] , encoding = [string] ) . write ( content ) [EOL] [EOL] python_addr = RE_PYTHON_ADDR . search ( content ) [EOL] if python_addr : [EOL] abort ( [string] . format ( python_addr . group ( [number] ) , filename , full_path ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Any , List [EOL] import typing [EOL] import re [EOL] import os [EOL] import sys [EOL] [EOL] from io import BytesIO [EOL] [EOL] GECKO_DIR = os . path . dirname ( __file__ . replace ( [string] , [string] ) ) [EOL] sys . path . insert ( [number] , os . path . join ( os . path . dirname ( GECKO_DIR ) , [string] ) ) [EOL] [EOL] import build [EOL] [EOL] [EOL] [comment] [EOL] PATTERN = re . compile ( [string] , re . MULTILINE ) [EOL] FILE = [string] [EOL] [EOL] [EOL] def map_atom ( ident ) : [EOL] if ident in { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] } : [EOL] return ident + [string] [EOL] return ident [EOL] [EOL] [EOL] class Atom : [EOL] def __init__ ( self , ident , value , hash , ty , atom_type ) : [EOL] self . ident = [string] . format ( ident ) [EOL] self . original_ident = ident [EOL] self . value = value [EOL] self . hash = hash [EOL] [comment] [EOL] [comment] [EOL] self . ty = ty [EOL] [comment] [EOL] [comment] [EOL] self . atom_type = atom_type [EOL] [EOL] if self . is_pseudo_element ( ) or self . is_anon_box ( ) or self . is_tree_pseudo_element ( ) : [EOL] self . pseudo_ident = ( ident . split ( [string] , [number] ) ) [ [number] ] [EOL] [EOL] if self . is_anon_box ( ) : [EOL] assert self . is_inheriting_anon_box ( ) or self . is_non_inheriting_anon_box ( ) [EOL] [EOL] def type ( self ) : [EOL] return self . ty [EOL] [EOL] def capitalized_pseudo ( self ) : [EOL] return self . pseudo_ident [ [number] ] . upper ( ) + self . pseudo_ident [ [number] : ] [EOL] [EOL] def is_pseudo_element ( self ) : [EOL] return self . atom_type == [string] [EOL] [EOL] def is_anon_box ( self ) : [EOL] if self . is_tree_pseudo_element ( ) : [EOL] return False [EOL] return self . is_non_inheriting_anon_box ( ) or self . is_inheriting_anon_box ( ) [EOL] [EOL] def is_non_inheriting_anon_box ( self ) : [EOL] assert not self . is_tree_pseudo_element ( ) [EOL] return self . atom_type == [string] [EOL] [EOL] def is_inheriting_anon_box ( self ) : [EOL] if self . is_tree_pseudo_element ( ) : [EOL] return False [EOL] return self . atom_type == [string] [EOL] [EOL] def is_tree_pseudo_element ( self ) : [EOL] return self . value . startswith ( [string] ) [EOL] [EOL] [EOL] def collect_atoms ( objdir ) : [EOL] atoms = [ ] [EOL] path = os . path . abspath ( os . path . join ( objdir , FILE ) ) [EOL] print ( [string] . format ( path ) ) [EOL] with open ( path ) as f : [EOL] content = f . read ( ) [EOL] for result in PATTERN . finditer ( content ) : [EOL] atoms . append ( Atom ( result . group ( [number] ) , result . group ( [number] ) , result . group ( [number] ) , result . group ( [number] ) , result . group ( [number] ) ) ) [EOL] return atoms [EOL] [EOL] [EOL] class FileAvoidWrite ( BytesIO ) : [EOL] [docstring] [EOL] def __init__ ( self , filename ) : [EOL] BytesIO . __init__ ( self ) [EOL] self . name = filename [EOL] [EOL] def write ( self , buf ) : [EOL] if isinstance ( buf , str ) : [EOL] buf = buf . encode ( [string] ) [EOL] BytesIO . write ( self , buf ) [EOL] [EOL] def close ( self ) : [EOL] buf = self . getvalue ( ) [EOL] BytesIO . close ( self ) [EOL] try : [EOL] with open ( self . name , [string] ) as f : [EOL] old_content = f . read ( ) [EOL] if old_content == buf : [EOL] print ( [string] . format ( self . name ) ) [EOL] return [EOL] except IOError : [EOL] pass [EOL] with open ( self . name , [string] ) as f : [EOL] f . write ( buf ) [EOL] [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , type , value , traceback ) : [EOL] if not self . closed : [EOL] self . close ( ) [EOL] [EOL] [EOL] PRELUDE = [string] [ [number] : ] [EOL] [EOL] RULE_TEMPLATE = [string] [ [number] : ] [EOL] [EOL] MACRO_TEMPLATE = [string] [EOL] [EOL] def write_atom_macro ( atoms , file_name ) : [EOL] with FileAvoidWrite ( file_name ) as f : [EOL] f . write ( PRELUDE ) [EOL] macro_rules = [ RULE_TEMPLATE . format ( atom = atom . value , name = atom . ident , index = i ) for ( i , atom ) in enumerate ( atoms ) ] [EOL] f . write ( MACRO_TEMPLATE . format ( body = [string] . join ( macro_rules ) ) ) [EOL] [EOL] [EOL] def write_pseudo_elements ( atoms , target_filename ) : [EOL] pseudos = [ ] [EOL] for atom in atoms : [EOL] if atom . type ( ) == [string] or atom . type ( ) == [string] : [EOL] pseudos . append ( atom ) [EOL] [EOL] pseudo_definition_template = os . path . join ( GECKO_DIR , [string] ) [EOL] print ( [string] . format ( pseudo_definition_template ) ) [EOL] contents = build . render ( pseudo_definition_template , PSEUDOS = pseudos ) [EOL] [EOL] with FileAvoidWrite ( target_filename ) as f : [EOL] f . write ( contents ) [EOL] [EOL] [EOL] def generate_atoms ( dist , out ) : [EOL] atoms = collect_atoms ( dist ) [EOL] write_atom_macro ( atoms , os . path . join ( out , [string] ) ) [EOL] write_pseudo_elements ( atoms , os . path . join ( out , [string] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) != [number] : [EOL] print ( [string] . format ( sys . argv [ [number] ] ) ) [EOL] exit ( [number] ) [EOL] generate_atoms ( sys . argv [ [number] ] , sys . argv [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Iterator , Literal , Dict , List , Any [EOL] import typing_extensions [EOL] import typing [EOL] import functools [EOL] import os [EOL] [EOL] from WebIDL import IDLExternalInterface , IDLSequenceType , IDLWrapperType , WebIDLError [EOL] [EOL] [EOL] class Configuration : [EOL] [docstring] [EOL] def __init__ ( self , filename , parseData ) : [EOL] [comment] [EOL] glbl = { } [EOL] exec ( compile ( open ( filename ) . read ( ) , filename , [string] ) , glbl ) [EOL] config = glbl [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . descriptors = [ ] [EOL] self . interfaces = { } [EOL] self . maxProtoChainLength = [number] [EOL] for thing in parseData : [EOL] [comment] [EOL] if isinstance ( thing , IDLExternalInterface ) : [EOL] raise WebIDLError ( [string] , [ thing . location ] ) [EOL] [EOL] assert not thing . isType ( ) [EOL] [EOL] if not thing . isInterface ( ) and not thing . isNamespace ( ) : [EOL] continue [EOL] [EOL] iface = thing [EOL] self . interfaces [ iface . identifier . name ] = iface [EOL] if iface . identifier . name not in config : [EOL] entry = { } [EOL] else : [EOL] entry = config [ iface . identifier . name ] [EOL] if not isinstance ( entry , list ) : [EOL] assert isinstance ( entry , dict ) [EOL] entry = [ entry ] [EOL] self . descriptors . extend ( [ Descriptor ( self , iface , x ) for x in entry ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for descriptor in self . descriptors : [EOL] intefaceName = descriptor . interface . identifier . name [EOL] otherDescriptors = [ d for d in self . descriptors if d . interface . identifier . name == intefaceName ] [EOL] descriptor . uniqueImplementation = len ( otherDescriptors ) == [number] [EOL] [EOL] self . enums = [ e for e in parseData if e . isEnum ( ) ] [EOL] self . typedefs = [ e for e in parseData if e . isTypedef ( ) ] [EOL] self . dictionaries = [ d for d in parseData if d . isDictionary ( ) ] [EOL] self . callbacks = [ c for c in parseData if c . isCallback ( ) and not c . isInterface ( ) ] [EOL] [EOL] [comment] [EOL] def cmp ( x , y ) : [EOL] return ( x > y ) - ( x < y ) [EOL] self . descriptors . sort ( key = functools . cmp_to_key ( lambda x , y : cmp ( x . name , y . name ) ) ) [EOL] [EOL] def getInterface ( self , ifname ) : [EOL] return self . interfaces [ ifname ] [EOL] [EOL] def getDescriptors ( self , ** filters ) : [EOL] [docstring] [EOL] curr = self . descriptors [EOL] for key , val in filters . iteritems ( ) : [EOL] if key == [string] : [EOL] def getter ( x ) : [EOL] return x . interface . filename ( ) [EOL] elif key == [string] : [EOL] def getter ( x ) : [EOL] return x . interface . hasInterfaceObject ( ) [EOL] elif key == [string] : [EOL] def getter ( x ) : [EOL] return x . interface . isCallback ( ) [EOL] elif key == [string] : [EOL] def getter ( x ) : [EOL] return x . interface . isNamespace ( ) [EOL] elif key == [string] : [EOL] def getter ( x ) : [EOL] return x . interface . isJSImplemented ( ) [EOL] elif key == [string] : [EOL] def getter ( x ) : [EOL] return x . isGlobal ( ) [EOL] elif key == [string] : [EOL] def getter ( x ) : [EOL] return x . interface . getExtendedAttribute ( [string] ) is not None [EOL] elif key == [string] : [EOL] def getter ( x ) : [EOL] return x . interface . isExposedConditionally ( ) [EOL] elif key == [string] : [EOL] def getter ( x ) : [EOL] return x . interface . isIteratorInterface ( ) [EOL] else : [EOL] def getter ( x ) : [EOL] return getattr ( x , key ) [EOL] curr = filter ( lambda x : getter ( x ) == val , curr ) [EOL] return curr [EOL] [EOL] def getEnums ( self , webIDLFile ) : [EOL] return filter ( lambda e : e . filename ( ) == webIDLFile , self . enums ) [EOL] [EOL] def getTypedefs ( self , webIDLFile ) : [EOL] return filter ( lambda e : e . filename ( ) == webIDLFile , self . typedefs ) [EOL] [EOL] @ staticmethod def _filterForFile ( items , webIDLFile = [string] ) : [EOL] [docstring] [EOL] if not webIDLFile : [EOL] return items [EOL] [EOL] return filter ( lambda x : x . filename ( ) == webIDLFile , items ) [EOL] [EOL] def getDictionaries ( self , webIDLFile = [string] ) : [EOL] return self . _filterForFile ( self . dictionaries , webIDLFile = webIDLFile ) [EOL] [EOL] def getCallbacks ( self , webIDLFile = [string] ) : [EOL] return self . _filterForFile ( self . callbacks , webIDLFile = webIDLFile ) [EOL] [EOL] def getDescriptor ( self , interfaceName ) : [EOL] [docstring] [EOL] iface = self . getInterface ( interfaceName ) [EOL] descriptors = self . getDescriptors ( interface = iface ) [EOL] [EOL] [comment] [EOL] if len ( descriptors ) != [number] : [EOL] raise NoSuchDescriptorError ( [string] + interfaceName + [string] + str ( len ( descriptors ) ) + [string] ) [EOL] return descriptors [ [number] ] [EOL] [EOL] def getDescriptorProvider ( self ) : [EOL] [docstring] [EOL] return DescriptorProvider ( self ) [EOL] [EOL] [EOL] class NoSuchDescriptorError ( TypeError ) : [EOL] def __init__ ( self , str ) : [EOL] TypeError . __init__ ( self , str ) [EOL] [EOL] [EOL] class DescriptorProvider : [EOL] [docstring] [EOL] def __init__ ( self , config ) : [EOL] self . config = config [EOL] [EOL] def getDescriptor ( self , interfaceName ) : [EOL] [docstring] [EOL] return self . config . getDescriptor ( interfaceName ) [EOL] [EOL] [EOL] def MemberIsUnforgeable ( member , descriptor ) : [EOL] return ( ( member . isAttr ( ) or member . isMethod ( ) ) [EOL] and not member . isStatic ( ) [EOL] and ( member . isUnforgeable ( ) or bool ( descriptor . interface . getExtendedAttribute ( [string] ) ) ) ) [EOL] [EOL] [EOL] class Descriptor ( DescriptorProvider ) : [EOL] [docstring] [EOL] def __init__ ( self , config , interface , desc ) : [EOL] DescriptorProvider . __init__ ( self , config ) [EOL] self . interface = interface [EOL] [EOL] if not self . isExposedConditionally ( ) : [EOL] if interface . parent and interface . parent . isExposedConditionally ( ) : [EOL] raise TypeError ( [string] [string] % ( interface . identifier . name , interface . parent . identifier . name ) ) [EOL] [EOL] [comment] [EOL] ifaceName = self . interface . identifier . name [EOL] nativeTypeDefault = ifaceName [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . interface . isIteratorInterface ( ) : [EOL] itrName = self . interface . iterableInterface . identifier . name [EOL] itrDesc = self . getDescriptor ( itrName ) [EOL] nativeTypeDefault = iteratorNativeType ( itrDesc ) [EOL] [EOL] typeName = desc . get ( [string] , nativeTypeDefault ) [EOL] [EOL] spiderMonkeyInterface = desc . get ( [string] , False ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if spiderMonkeyInterface : [EOL] self . returnType = [string] % typeName [EOL] self . argumentType = [string] % typeName [EOL] self . nativeType = typeName [EOL] pathDefault = [string] % typeName [EOL] elif self . interface . isCallback ( ) : [EOL] ty = [string] % ( ifaceName , ifaceName ) [EOL] pathDefault = ty [EOL] self . returnType = [string] % ty [EOL] self . argumentType = [string] [EOL] self . nativeType = ty [EOL] else : [EOL] self . returnType = [string] % typeName [EOL] self . argumentType = [string] % typeName [EOL] self . nativeType = [string] % typeName [EOL] if self . interface . isIteratorInterface ( ) : [EOL] pathDefault = [string] [EOL] else : [EOL] pathDefault = [string] % MakeNativeName ( typeName ) [EOL] [EOL] self . concreteType = typeName [EOL] self . register = desc . get ( [string] , True ) [EOL] self . path = desc . get ( [string] , pathDefault ) [EOL] self . inRealmMethods = [ name for name in desc . get ( [string] , [ ] ) ] [EOL] self . bindingPath = [string] % ( [string] . join ( [ ifaceName + [string] ] * [number] ) ) [EOL] self . outerObjectHook = desc . get ( [string] , [string] ) [EOL] self . proxy = False [EOL] self . weakReferenceable = desc . get ( [string] , False ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . concrete = ( not self . interface . isCallback ( ) [EOL] and not self . interface . isNamespace ( ) [EOL] and not self . interface . getExtendedAttribute ( [string] ) [EOL] and not self . interface . getExtendedAttribute ( [string] ) [EOL] and not spiderMonkeyInterface ) [EOL] self . hasUnforgeableMembers = ( self . concrete [EOL] and any ( MemberIsUnforgeable ( m , self ) for m in self . interface . members ) ) [EOL] [EOL] self . operations = { [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , } [EOL] [EOL] self . hasDefaultToJSON = False [EOL] [EOL] def addOperation ( operation , m ) : [EOL] if not self . operations [ operation ] : [EOL] self . operations [ operation ] = m [EOL] [EOL] [comment] [EOL] [comment] [EOL] for m in self . interface . members : [EOL] if m . isMethod ( ) and m . isStringifier ( ) : [EOL] addOperation ( [string] , m ) [EOL] if m . isMethod ( ) and m . isDefaultToJSON ( ) : [EOL] self . hasDefaultToJSON = True [EOL] [EOL] if self . concrete : [EOL] iface = self . interface [EOL] while iface : [EOL] for m in iface . members : [EOL] if not m . isMethod ( ) : [EOL] continue [EOL] [EOL] def addIndexedOrNamedOperation ( operation , m ) : [EOL] self . proxy = True [EOL] if m . isIndexed ( ) : [EOL] operation = [string] + operation [EOL] else : [EOL] assert m . isNamed ( ) [EOL] operation = [string] + operation [EOL] addOperation ( operation , m ) [EOL] [EOL] if m . isGetter ( ) : [EOL] addIndexedOrNamedOperation ( [string] , m ) [EOL] if m . isSetter ( ) : [EOL] addIndexedOrNamedOperation ( [string] , m ) [EOL] if m . isDeleter ( ) : [EOL] addIndexedOrNamedOperation ( [string] , m ) [EOL] [EOL] iface = iface . parent [EOL] if iface : [EOL] iface . setUserData ( [string] , True ) [EOL] [EOL] if self . proxy : [EOL] iface = self . interface [EOL] while iface . parent : [EOL] iface = iface . parent [EOL] iface . setUserData ( [string] , True ) [EOL] [EOL] self . name = interface . identifier . name [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . extendedAttributes = { [string] : { } , [string] : { } , [string] : { } } [EOL] [EOL] def addExtendedAttribute ( attribute , config ) : [EOL] def add ( key , members , attribute ) : [EOL] for member in members : [EOL] self . extendedAttributes [ key ] . setdefault ( member , [ ] ) . append ( attribute ) [EOL] [EOL] if isinstance ( config , dict ) : [EOL] for key in [ [string] , [string] , [string] ] : [EOL] add ( key , config . get ( key , [ ] ) , attribute ) [EOL] elif isinstance ( config , list ) : [EOL] add ( [string] , config , attribute ) [EOL] else : [EOL] assert isinstance ( config , str ) [EOL] if config == [string] : [EOL] iface = self . interface [EOL] while iface : [EOL] add ( [string] , map ( lambda m : m . name , iface . members ) , attribute ) [EOL] iface = iface . parent [EOL] else : [EOL] add ( [string] , [ config ] , attribute ) [EOL] [EOL] self . _binaryNames = desc . get ( [string] , { } ) [EOL] self . _binaryNames . setdefault ( [string] , [string] ) [EOL] self . _binaryNames . setdefault ( [string] , [string] ) [EOL] [EOL] self . _internalNames = desc . get ( [string] , { } ) [EOL] [EOL] for member in self . interface . members : [EOL] if not member . isAttr ( ) and not member . isMethod ( ) : [EOL] continue [EOL] binaryName = member . getExtendedAttribute ( [string] ) [EOL] if binaryName : [EOL] assert isinstance ( binaryName , list ) [EOL] assert len ( binaryName ) == [number] [EOL] self . _binaryNames . setdefault ( member . identifier . name , binaryName [ [number] ] ) [EOL] self . _internalNames . setdefault ( member . identifier . name , member . identifier . name . replace ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] self . prototypeChain = [ ] [EOL] parent = interface [EOL] while parent : [EOL] self . prototypeChain . insert ( [number] , parent . identifier . name ) [EOL] parent = parent . parent [EOL] self . prototypeDepth = len ( self . prototypeChain ) - [number] [EOL] config . maxProtoChainLength = max ( config . maxProtoChainLength , len ( self . prototypeChain ) ) [EOL] [EOL] def binaryNameFor ( self , name ) : [EOL] return self . _binaryNames . get ( name , name ) [EOL] [EOL] def internalNameFor ( self , name ) : [EOL] return self . _internalNames . get ( name , name ) [EOL] [EOL] def getExtendedAttributes ( self , member , getter = False , setter = False ) : [EOL] def maybeAppendInfallibleToAttrs ( attrs , throws ) : [EOL] if throws is None : [EOL] attrs . append ( [string] ) [EOL] elif throws is True : [EOL] pass [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] name = member . identifier . name [EOL] if member . isMethod ( ) : [EOL] attrs = self . extendedAttributes [ [string] ] . get ( name , [ ] ) [EOL] throws = member . getExtendedAttribute ( [string] ) [EOL] maybeAppendInfallibleToAttrs ( attrs , throws ) [EOL] return attrs [EOL] [EOL] assert member . isAttr ( ) [EOL] assert bool ( getter ) != bool ( setter ) [EOL] key = [string] if getter else [string] [EOL] attrs = self . extendedAttributes [ [string] ] . get ( name , [ ] ) + self . extendedAttributes [ key ] . get ( name , [ ] ) [EOL] throws = member . getExtendedAttribute ( [string] ) [EOL] if throws is None : [EOL] throwsAttr = [string] if getter else [string] [EOL] throws = member . getExtendedAttribute ( throwsAttr ) [EOL] maybeAppendInfallibleToAttrs ( attrs , throws ) [EOL] return attrs [EOL] [EOL] def getParentName ( self ) : [EOL] parent = self . interface . parent [EOL] while parent : [EOL] if not parent . getExtendedAttribute ( [string] ) : [EOL] return parent . identifier . name [EOL] parent = parent . parent [EOL] return None [EOL] [EOL] def supportsIndexedProperties ( self ) : [EOL] return self . operations [ [string] ] is not None [EOL] [EOL] def hasDescendants ( self ) : [EOL] return ( self . interface . getUserData ( [string] , False ) or self . interface . getUserData ( [string] , False ) ) [EOL] [EOL] def hasHTMLConstructor ( self ) : [EOL] ctor = self . interface . ctor ( ) [EOL] return ctor and ctor . isHTMLConstructor ( ) [EOL] [EOL] def shouldHaveGetConstructorObjectMethod ( self ) : [EOL] assert self . interface . hasInterfaceObject ( ) [EOL] if self . interface . getExtendedAttribute ( [string] ) : [EOL] return False [EOL] return ( self . interface . isCallback ( ) or self . interface . isNamespace ( ) or self . hasDescendants ( ) or self . hasHTMLConstructor ( ) ) [EOL] [EOL] def shouldCacheConstructor ( self ) : [EOL] return self . hasDescendants ( ) or self . hasHTMLConstructor ( ) [EOL] [EOL] def isExposedConditionally ( self ) : [EOL] return self . interface . isExposedConditionally ( ) [EOL] [EOL] def isGlobal ( self ) : [EOL] [docstring] [EOL] return bool ( self . interface . getExtendedAttribute ( [string] ) or self . interface . getExtendedAttribute ( [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def MakeNativeName ( name ) : [EOL] return name [ [number] ] . upper ( ) + name [ [number] : ] [EOL] [EOL] [EOL] def getModuleFromObject ( object ) : [EOL] return ( [string] + os . path . basename ( object . location . filename ( ) ) . split ( [string] ) [ [number] ] + [string] ) [EOL] [EOL] [EOL] def getTypesFromDescriptor ( descriptor ) : [EOL] [docstring] [EOL] members = [ m for m in descriptor . interface . members ] [EOL] if descriptor . interface . ctor ( ) : [EOL] members . append ( descriptor . interface . ctor ( ) ) [EOL] members . extend ( descriptor . interface . namedConstructors ) [EOL] signatures = [ s for m in members if m . isMethod ( ) for s in m . signatures ( ) ] [EOL] types = [ ] [EOL] for s in signatures : [EOL] assert len ( s ) == [number] [EOL] ( returnType , arguments ) = s [EOL] types . append ( returnType ) [EOL] types . extend ( a . type for a in arguments ) [EOL] [EOL] types . extend ( a . type for a in members if a . isAttr ( ) ) [EOL] return types [EOL] [EOL] [EOL] def getTypesFromDictionary ( dictionary ) : [EOL] [docstring] [EOL] if isinstance ( dictionary , IDLWrapperType ) : [EOL] dictionary = dictionary . inner [EOL] types = [ ] [EOL] curDict = dictionary [EOL] while curDict : [EOL] types . extend ( [ getUnwrappedType ( m . type ) for m in curDict . members ] ) [EOL] curDict = curDict . parent [EOL] return types [EOL] [EOL] [EOL] def getTypesFromCallback ( callback ) : [EOL] [docstring] [EOL] sig = callback . signatures ( ) [ [number] ] [EOL] types = [ sig [ [number] ] ] [comment] [EOL] types . extend ( arg . type for arg in sig [ [number] ] ) [comment] [EOL] return types [EOL] [EOL] [EOL] def getUnwrappedType ( type ) : [EOL] while isinstance ( type , IDLSequenceType ) : [EOL] type = type . inner [EOL] return type [EOL] [EOL] [EOL] def iteratorNativeType ( descriptor , infer = False ) : [EOL] assert descriptor . interface . isIterable ( ) [EOL] iterableDecl = descriptor . interface . maplikeOrSetlikeOrIterable [EOL] assert iterableDecl . isPairIterator ( ) [EOL] return [string] % ( [string] if infer else [string] % descriptor . interface . identifier . name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] import sys [EOL] import json [EOL] [EOL] [EOL] def main ( ) : [EOL] os . chdir ( os . path . join ( os . path . dirname ( __file__ ) ) ) [EOL] sys . path [ [number] : [number] ] = [ [string] , [string] ] [EOL] [EOL] css_properties_json , out_dir = sys . argv [ [number] : ] [EOL] doc_servo = [string] [EOL] webidls_dir = [string] [EOL] config_file = [string] [EOL] [EOL] import WebIDL [EOL] from Configuration import Configuration [EOL] from CodegenRust import CGBindingRoot [EOL] [EOL] parser = WebIDL . Parser ( make_dir ( os . path . join ( out_dir , [string] ) ) ) [EOL] webidls = [ name for name in os . listdir ( webidls_dir ) if name . endswith ( [string] ) ] [EOL] for webidl in webidls : [EOL] filename = os . path . join ( webidls_dir , webidl ) [EOL] with open ( filename , [string] ) as f : [EOL] parser . parse ( f . read ( ) , filename ) [EOL] [EOL] add_css_properties_attributes ( css_properties_json , parser ) [EOL] parser_results = parser . finish ( ) [EOL] config = Configuration ( config_file , parser_results ) [EOL] make_dir ( os . path . join ( out_dir , [string] ) ) [EOL] [EOL] for name , filename in [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] : [EOL] generate ( config , name , os . path . join ( out_dir , filename ) ) [EOL] make_dir ( doc_servo ) [EOL] generate ( config , [string] , os . path . join ( doc_servo , [string] ) ) [EOL] [EOL] for webidl in webidls : [EOL] filename = os . path . join ( webidls_dir , webidl ) [EOL] prefix = [string] % webidl [ : - len ( [string] ) ] [EOL] module = CGBindingRoot ( config , prefix , filename ) . define ( ) [EOL] if module : [EOL] with open ( os . path . join ( out_dir , prefix + [string] ) , [string] ) as f : [EOL] f . write ( module ) [EOL] [EOL] [EOL] def make_dir ( path ) : [EOL] if not os . path . exists ( path ) : [EOL] os . makedirs ( path ) [EOL] return path [EOL] [EOL] [EOL] def generate ( config , name , filename ) : [EOL] from CodegenRust import GlobalGenRoots [EOL] root = getattr ( GlobalGenRoots , name ) ( config ) [EOL] code = root . define ( ) [EOL] with open ( filename , [string] ) as f : [EOL] f . write ( code ) [EOL] [EOL] [EOL] def add_css_properties_attributes ( css_properties_json , parser ) : [EOL] css_properties = json . load ( open ( css_properties_json , [string] ) ) [EOL] idl = [string] % [string] . join ( [string] % ( ( [string] % data [ [string] ] if data [ [string] ] else [string] ) , attribute_name ) for ( kind , properties_list ) in sorted ( css_properties . items ( ) ) for ( property_name , data ) in sorted ( properties_list . items ( ) ) for attribute_name in attribute_names ( property_name ) ) [EOL] parser . parse ( idl . encode ( [string] ) , [string] ) [EOL] [EOL] [EOL] def attribute_names ( property_name ) : [EOL] [comment] [EOL] if property_name != [string] : [EOL] yield property_name [EOL] else : [EOL] yield [string] [EOL] [EOL] [comment] [EOL] if [string] in property_name : [EOL] yield [string] . join ( camel_case ( property_name ) ) [EOL] [EOL] [comment] [EOL] if property_name . startswith ( [string] ) : [EOL] yield [string] . join ( camel_case ( property_name ) , True ) [EOL] [EOL] [EOL] [comment] [EOL] def camel_case ( chars , webkit_prefixed = False ) : [EOL] if webkit_prefixed : [EOL] chars = chars [ [number] : ] [EOL] next_is_uppercase = False [EOL] for c in chars : [EOL] if c == [string] : [EOL] next_is_uppercase = True [EOL] elif next_is_uppercase : [EOL] next_is_uppercase = False [EOL] [comment] [EOL] yield c . upper ( ) [EOL] else : [EOL] yield c [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Union , Set , Literal , Dict , List , Type , Tuple , Any [EOL] import typing_extensions [EOL] import optparse [EOL] import components [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import print_function [EOL] from ply import lex , yacc [EOL] import re [EOL] import os [EOL] import traceback [EOL] import math [EOL] import string [EOL] from collections import defaultdict , OrderedDict [EOL] from itertools import chain [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def parseInt ( literal ) : [EOL] string = literal [EOL] sign = [number] [EOL] base = [number] [EOL] [EOL] if string [ [number] ] == [string] : [EOL] sign = - [number] [EOL] string = string [ [number] : ] [EOL] else : [EOL] sign = [number] [EOL] [EOL] if string [ [number] ] == [string] and len ( string ) > [number] : [EOL] if string [ [number] ] == [string] or string [ [number] ] == [string] : [EOL] base = [number] [EOL] string = string [ [number] : ] [EOL] else : [EOL] base = [number] [EOL] string = string [ [number] : ] [EOL] else : [EOL] base = [number] [EOL] [EOL] value = int ( string , base ) [EOL] return value * sign [EOL] [EOL] [EOL] def enum ( * names , ** kw ) : [EOL] class Foo ( object ) : [EOL] attrs = OrderedDict ( ) [EOL] def __init__ ( self , names ) : [EOL] for v , k in enumerate ( names ) : [EOL] self . attrs [ k ] = v [EOL] def __getattr__ ( self , attr ) : [EOL] if attr in self . attrs : [EOL] return self . attrs [ attr ] [EOL] raise AttributeError [EOL] def __setattr__ ( self , name , value ) : [comment] [EOL] raise NotImplementedError [EOL] [EOL] if [string] not in kw : [EOL] return Foo ( names ) [EOL] return Foo ( chain ( kw [ [string] ] . attrs . keys ( ) , names ) ) [EOL] [EOL] [EOL] class WebIDLError ( Exception ) : [EOL] def __init__ ( self , message , locations , warning = False ) : [EOL] self . message = message [EOL] self . locations = [ str ( loc ) for loc in locations ] [EOL] self . warning = warning [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . warning and [string] or [string] , self . message , [string] if len ( self . locations ) != [number] else [string] , [string] . join ( self . locations ) ) [EOL] [EOL] [EOL] class Location ( object ) : [EOL] def __init__ ( self , lexer , lineno , lexpos , filename ) : [EOL] self . _line = None [EOL] self . _lineno = lineno [EOL] self . _lexpos = lexpos [EOL] self . _lexdata = lexer . lexdata [EOL] self . _file = filename if filename else [string] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . _lexpos == other . _lexpos and self . _file == other . _file ) [EOL] [EOL] def filename ( self ) : [EOL] return self . _file [EOL] [EOL] def resolve ( self ) : [EOL] if self . _line : [EOL] return [EOL] [EOL] startofline = self . _lexdata . rfind ( [string] , [number] , self . _lexpos ) + [number] [EOL] endofline = self . _lexdata . find ( [string] , self . _lexpos , self . _lexpos + [number] ) [EOL] if endofline != - [number] : [EOL] self . _line = self . _lexdata [ startofline : endofline ] [EOL] else : [EOL] self . _line = self . _lexdata [ startofline : ] [EOL] self . _colno = self . _lexpos - startofline [EOL] [EOL] [comment] [EOL] self . _lineno += self . _lexdata . count ( [string] , [number] , startofline ) [EOL] [EOL] def get ( self ) : [EOL] self . resolve ( ) [EOL] return [string] % ( self . _file , self . _lineno , self . _colno ) [EOL] [EOL] def _pointerline ( self ) : [EOL] return [string] * self . _colno + [string] [EOL] [EOL] def __str__ ( self ) : [EOL] self . resolve ( ) [EOL] return [string] % ( self . _file , self . _lineno , self . _colno , self . _line , self . _pointerline ( ) ) [EOL] [EOL] [EOL] class BuiltinLocation ( object ) : [EOL] def __init__ ( self , text ) : [EOL] self . msg = text + [string] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , BuiltinLocation ) and self . msg == other . msg ) [EOL] [EOL] def filename ( self ) : [EOL] return [string] [EOL] [EOL] def resolve ( self ) : [EOL] pass [EOL] [EOL] def get ( self ) : [EOL] return self . msg [EOL] [EOL] def __str__ ( self ) : [EOL] return self . get ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class IDLObject ( object ) : [EOL] def __init__ ( self , location ) : [EOL] self . location = location [EOL] self . userData = dict ( ) [EOL] [EOL] def filename ( self ) : [EOL] return self . location . filename ( ) [EOL] [EOL] def isInterface ( self ) : [EOL] return False [EOL] [EOL] def isNamespace ( self ) : [EOL] return False [EOL] [EOL] def isInterfaceMixin ( self ) : [EOL] return False [EOL] [EOL] def isEnum ( self ) : [EOL] return False [EOL] [EOL] def isCallback ( self ) : [EOL] return False [EOL] [EOL] def isType ( self ) : [EOL] return False [EOL] [EOL] def isDictionary ( self ) : [EOL] return False [EOL] [EOL] def isUnion ( self ) : [EOL] return False [EOL] [EOL] def isTypedef ( self ) : [EOL] return False [EOL] [EOL] def getUserData ( self , key , default ) : [EOL] return self . userData . get ( key , default ) [EOL] [EOL] def setUserData ( self , key , value ) : [EOL] self . userData [ key ] = value [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] assert False [comment] [EOL] [EOL] def handleExtendedAttribute ( self , attr ) : [EOL] assert False [comment] [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] assert False [comment] [EOL] [EOL] def getDeps ( self , visited = None ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if visited is None : [EOL] visited = set ( ) [EOL] [EOL] if self in visited : [EOL] return set ( ) [EOL] [EOL] visited . add ( self ) [EOL] [EOL] deps = set ( ) [EOL] if self . filename ( ) != [string] : [EOL] deps . add ( self . filename ( ) ) [EOL] [EOL] for d in self . _getDependentObjects ( ) : [EOL] deps . update ( d . getDeps ( visited ) ) [EOL] [EOL] return deps [EOL] [EOL] [EOL] class IDLScope ( IDLObject ) : [EOL] def __init__ ( self , location , parentScope , identifier ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] [EOL] self . parentScope = parentScope [EOL] if identifier : [EOL] assert isinstance ( identifier , IDLIdentifier ) [EOL] self . _name = identifier [EOL] else : [EOL] self . _name = None [EOL] [EOL] self . _dict = { } [EOL] self . globalNames = set ( ) [EOL] [comment] [EOL] [comment] [EOL] self . globalNameMapping = defaultdict ( set ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . QName ( ) [EOL] [EOL] def QName ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if hasattr ( self , [string] ) : [EOL] name = self . _name [EOL] else : [EOL] name = None [EOL] if name : [EOL] return name . QName ( ) + [string] [EOL] return [string] [EOL] [EOL] def ensureUnique ( self , identifier , object ) : [EOL] [docstring] [EOL] assert isinstance ( identifier , IDLUnresolvedIdentifier ) [EOL] assert not object or isinstance ( object , IDLObjectWithIdentifier ) [EOL] assert not object or object . identifier == identifier [EOL] [EOL] if identifier . name in self . _dict : [EOL] if not object : [EOL] return [EOL] [EOL] [comment] [EOL] assert id ( object ) != id ( self . _dict [ identifier . name ] ) [EOL] [EOL] replacement = self . resolveIdentifierConflict ( self , identifier , self . _dict [ identifier . name ] , object ) [EOL] self . _dict [ identifier . name ] = replacement [EOL] return [EOL] [EOL] assert object [EOL] [EOL] self . _dict [ identifier . name ] = object [EOL] [EOL] def resolveIdentifierConflict ( self , scope , identifier , originalObject , newObject ) : [EOL] if ( isinstance ( originalObject , IDLExternalInterface ) and isinstance ( newObject , IDLExternalInterface ) and originalObject . identifier . name == newObject . identifier . name ) : [EOL] return originalObject [EOL] [EOL] if ( isinstance ( originalObject , IDLExternalInterface ) or isinstance ( newObject , IDLExternalInterface ) ) : [EOL] raise WebIDLError ( [string] [string] % ( identifier . name , originalObject . location , newObject . location ) , [ ] ) [EOL] [EOL] if ( isinstance ( originalObject , IDLDictionary ) or isinstance ( newObject , IDLDictionary ) ) : [EOL] raise WebIDLError ( [string] [string] % ( identifier . name , originalObject . location , newObject . location ) , [ ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( isinstance ( originalObject , IDLMethod ) and isinstance ( newObject , IDLMethod ) ) : [EOL] return originalObject . addOverload ( newObject ) [EOL] [EOL] [comment] [EOL] conflictdesc = [string] % ( originalObject , originalObject . location , newObject , newObject . location ) [EOL] [EOL] raise WebIDLError ( [string] % ( identifier . name , str ( self ) , conflictdesc ) , [ ] ) [EOL] [EOL] def _lookupIdentifier ( self , identifier ) : [EOL] return self . _dict [ identifier . name ] [EOL] [EOL] def lookupIdentifier ( self , identifier ) : [EOL] assert isinstance ( identifier , IDLIdentifier ) [EOL] assert identifier . scope == self [EOL] return self . _lookupIdentifier ( identifier ) [EOL] [EOL] def addIfaceGlobalNames ( self , interfaceName , globalNames ) : [EOL] [docstring] [EOL] self . globalNames . update ( globalNames ) [EOL] for name in globalNames : [EOL] self . globalNameMapping [ name ] . add ( interfaceName ) [EOL] [EOL] [EOL] class IDLIdentifier ( IDLObject ) : [EOL] def __init__ ( self , location , scope , name ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] [EOL] self . name = name [EOL] assert isinstance ( scope , IDLScope ) [EOL] self . scope = scope [EOL] [EOL] def __str__ ( self ) : [EOL] return self . QName ( ) [EOL] [EOL] def QName ( self ) : [EOL] return self . scope . QName ( ) + self . name [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . QName ( ) . __hash__ ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . QName ( ) == other . QName ( ) [EOL] [EOL] def object ( self ) : [EOL] return self . scope . lookupIdentifier ( self ) [EOL] [EOL] [EOL] class IDLUnresolvedIdentifier ( IDLObject ) : [EOL] def __init__ ( self , location , name , allowDoubleUnderscore = False , allowForbidden = False ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] [EOL] assert len ( name ) > [number] [EOL] [EOL] if name == [string] : [EOL] raise WebIDLError ( [string] , [ location ] ) [EOL] [EOL] if name [ : [number] ] == [string] and name != [string] and not allowDoubleUnderscore : [EOL] raise WebIDLError ( [string] , [ location ] ) [EOL] if name [ [number] ] == [string] and not allowDoubleUnderscore : [EOL] name = name [ [number] : ] [EOL] if ( name in [ [string] , [string] ] and not allowForbidden ) : [EOL] raise WebIDLError ( [string] % (name) , [ location ] ) [EOL] [EOL] self . name = name [EOL] [EOL] def __str__ ( self ) : [EOL] return self . QName ( ) [EOL] [EOL] def QName ( self ) : [EOL] return [string] + self . name [EOL] [EOL] def resolve ( self , scope , object ) : [EOL] assert isinstance ( scope , IDLScope ) [EOL] assert not object or isinstance ( object , IDLObjectWithIdentifier ) [EOL] assert not object or object . identifier == self [EOL] [EOL] scope . ensureUnique ( self , object ) [EOL] [EOL] identifier = IDLIdentifier ( self . location , scope , self . name ) [EOL] if object : [EOL] object . identifier = identifier [EOL] return identifier [EOL] [EOL] def finish ( self ) : [EOL] assert False [comment] [EOL] [EOL] [EOL] class IDLObjectWithIdentifier ( IDLObject ) : [EOL] def __init__ ( self , location , parentScope , identifier ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] [EOL] assert isinstance ( identifier , IDLUnresolvedIdentifier ) [EOL] [EOL] self . identifier = identifier [EOL] [EOL] if parentScope : [EOL] self . resolve ( parentScope ) [EOL] [EOL] def resolve ( self , parentScope ) : [EOL] assert isinstance ( parentScope , IDLScope ) [EOL] assert isinstance ( self . identifier , IDLUnresolvedIdentifier ) [EOL] self . identifier . resolve ( parentScope , self ) [EOL] [EOL] [EOL] class IDLObjectWithScope ( IDLObjectWithIdentifier , IDLScope ) : [EOL] def __init__ ( self , location , parentScope , identifier ) : [EOL] assert isinstance ( identifier , IDLUnresolvedIdentifier ) [EOL] [EOL] IDLObjectWithIdentifier . __init__ ( self , location , parentScope , identifier ) [EOL] IDLScope . __init__ ( self , location , parentScope , self . identifier ) [EOL] [EOL] [EOL] class IDLIdentifierPlaceholder ( IDLObjectWithIdentifier ) : [EOL] def __init__ ( self , location , identifier ) : [EOL] assert isinstance ( identifier , IDLUnresolvedIdentifier ) [EOL] IDLObjectWithIdentifier . __init__ ( self , location , None , identifier ) [EOL] [EOL] def finish ( self , scope ) : [EOL] try : [EOL] scope . _lookupIdentifier ( self . identifier ) [EOL] except : [EOL] raise WebIDLError ( [string] % self . identifier , [ self . location ] ) [EOL] [EOL] obj = self . identifier . resolve ( scope , None ) [EOL] return scope . lookupIdentifier ( obj ) [EOL] [EOL] [EOL] class IDLExposureMixins ( ) : [EOL] def __init__ ( self , location ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _exposureGlobalNames = set ( ) [EOL] self . exposureSet = set ( ) [EOL] self . _location = location [EOL] self . _globalScope = None [EOL] [EOL] def finish ( self , scope ) : [EOL] assert scope . parentScope is None [EOL] self . _globalScope = scope [EOL] [EOL] [comment] [EOL] for globalName in self . _exposureGlobalNames : [EOL] if globalName not in scope . globalNames : [EOL] raise WebIDLError ( [string] % globalName , [ self . _location ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if len ( scope . globalNames ) != [number] : [EOL] if ( len ( self . _exposureGlobalNames ) == [number] ) : [EOL] raise WebIDLError ( ( [string] [string] ) % self , [ self . location ] ) [EOL] [EOL] globalNameSetToExposureSet ( scope , self . _exposureGlobalNames , self . exposureSet ) [EOL] [EOL] def isExposedInWindow ( self ) : [EOL] return [string] in self . exposureSet [EOL] [EOL] def isExposedInAnyWorker ( self ) : [EOL] return len ( self . getWorkerExposureSet ( ) ) > [number] [EOL] [EOL] def isExposedInWorkerDebugger ( self ) : [EOL] return len ( self . getWorkerDebuggerExposureSet ( ) ) > [number] [EOL] [EOL] def isExposedInAnyWorklet ( self ) : [EOL] return len ( self . getWorkletExposureSet ( ) ) > [number] [EOL] [EOL] def isExposedInSomeButNotAllWorkers ( self ) : [EOL] [docstring] [EOL] if not self . isExposedInAnyWorker ( ) : [EOL] return False [EOL] workerScopes = self . parentScope . globalNameMapping [ [string] ] [EOL] return len ( workerScopes . difference ( self . exposureSet ) ) > [number] [EOL] [EOL] def getWorkerExposureSet ( self ) : [EOL] workerScopes = self . _globalScope . globalNameMapping [ [string] ] [EOL] return workerScopes . intersection ( self . exposureSet ) [EOL] [EOL] def getWorkletExposureSet ( self ) : [EOL] workletScopes = self . _globalScope . globalNameMapping [ [string] ] [EOL] return workletScopes . intersection ( self . exposureSet ) [EOL] [EOL] def getWorkerDebuggerExposureSet ( self ) : [EOL] workerDebuggerScopes = self . _globalScope . globalNameMapping [ [string] ] [EOL] return workerDebuggerScopes . intersection ( self . exposureSet ) [EOL] [EOL] [EOL] class IDLExternalInterface ( IDLObjectWithIdentifier ) : [EOL] def __init__ ( self , location , parentScope , identifier ) : [EOL] assert isinstance ( identifier , IDLUnresolvedIdentifier ) [EOL] assert isinstance ( parentScope , IDLScope ) [EOL] self . parent = None [EOL] IDLObjectWithIdentifier . __init__ ( self , location , parentScope , identifier ) [EOL] IDLObjectWithIdentifier . resolve ( self , parentScope ) [EOL] [EOL] def finish ( self , scope ) : [EOL] pass [EOL] [EOL] def validate ( self ) : [EOL] pass [EOL] [EOL] def isIteratorInterface ( self ) : [EOL] return False [EOL] [EOL] def isExternal ( self ) : [EOL] return True [EOL] [EOL] def isInterface ( self ) : [EOL] return True [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] if len ( attrs ) != [number] : [EOL] raise WebIDLError ( [string] [string] , [ attrs [ [number] ] . location , self . location ] ) [EOL] [EOL] def resolve ( self , parentScope ) : [EOL] pass [EOL] [EOL] def getJSImplementation ( self ) : [EOL] return None [EOL] [EOL] def isJSImplemented ( self ) : [EOL] return False [EOL] [EOL] def hasProbablyShortLivingWrapper ( self ) : [EOL] return False [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( ) [EOL] [EOL] [EOL] class IDLPartialDictionary ( IDLObject ) : [EOL] def __init__ ( self , location , name , members , nonPartialDictionary ) : [EOL] assert isinstance ( name , IDLUnresolvedIdentifier ) [EOL] [EOL] IDLObject . __init__ ( self , location ) [EOL] self . identifier = name [EOL] self . members = members [EOL] self . _nonPartialDictionary = nonPartialDictionary [EOL] self . _finished = False [EOL] nonPartialDictionary . addPartialDictionary ( self ) [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] pass [EOL] [EOL] def finish ( self , scope ) : [EOL] if self . _finished : [EOL] return [EOL] self . _finished = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _nonPartialDictionary . finish ( scope ) [EOL] [EOL] def validate ( self ) : [EOL] pass [EOL] [EOL] [EOL] class IDLPartialInterfaceOrNamespace ( IDLObject ) : [EOL] def __init__ ( self , location , name , members , nonPartialInterfaceOrNamespace ) : [EOL] assert isinstance ( name , IDLUnresolvedIdentifier ) [EOL] [EOL] IDLObject . __init__ ( self , location ) [EOL] self . identifier = name [EOL] self . members = members [EOL] [comment] [EOL] [comment] [EOL] self . propagatedExtendedAttrs = [ ] [EOL] self . _haveSecureContextExtendedAttribute = False [EOL] self . _nonPartialInterfaceOrNamespace = nonPartialInterfaceOrNamespace [EOL] self . _finished = False [EOL] nonPartialInterfaceOrNamespace . addPartial ( self ) [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] for attr in attrs : [EOL] identifier = attr . identifier ( ) [EOL] [EOL] if identifier == [string] : [EOL] self . propagatedExtendedAttrs . append ( attr ) [EOL] elif identifier == [string] : [EOL] self . _haveSecureContextExtendedAttribute = True [EOL] [comment] [EOL] for member in self . members : [EOL] if member . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] [string] , [ member . location , attr . location ] ) [EOL] member . addExtendedAttributes ( [ attr ] ) [EOL] elif identifier == [string] : [EOL] [comment] [EOL] for member in self . members : [EOL] if len ( member . _exposureGlobalNames ) != [number] : [EOL] raise WebIDLError ( [string] [string] [string] , [ member . location , attr . location ] ) [EOL] member . addExtendedAttributes ( [ attr ] ) [EOL] else : [EOL] raise WebIDLError ( [string] [string] % identifier , [ attr . location ] ) [EOL] [EOL] def finish ( self , scope ) : [EOL] if self . _finished : [EOL] return [EOL] self . _finished = True [EOL] if ( not self . _haveSecureContextExtendedAttribute and self . _nonPartialInterfaceOrNamespace . getExtendedAttribute ( [string] ) ) : [EOL] [comment] [EOL] for member in self . members : [EOL] if member . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] [string] , [ member . location , self . _nonPartialInterfaceOrNamespace . location ] ) [EOL] member . addExtendedAttributes ( [ IDLExtendedAttribute ( self . _nonPartialInterfaceOrNamespace . location , ( [string] , ) ) ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _nonPartialInterfaceOrNamespace . finish ( scope ) [EOL] [EOL] def validate ( self ) : [EOL] pass [EOL] [EOL] [EOL] def convertExposedAttrToGlobalNameSet ( exposedAttr , targetSet ) : [EOL] assert len ( targetSet ) == [number] [EOL] if exposedAttr . hasValue ( ) : [EOL] targetSet . add ( exposedAttr . value ( ) ) [EOL] else : [EOL] assert exposedAttr . hasArgs ( ) [EOL] targetSet . update ( exposedAttr . args ( ) ) [EOL] [EOL] [EOL] def globalNameSetToExposureSet ( globalScope , nameSet , exposureSet ) : [EOL] for name in nameSet : [EOL] exposureSet . update ( globalScope . globalNameMapping [ name ] ) [EOL] [EOL] class IDLInterfaceOrInterfaceMixinOrNamespace ( IDLObjectWithScope , IDLExposureMixins ) : [EOL] def __init__ ( self , location , parentScope , name ) : [EOL] assert isinstance ( parentScope , IDLScope ) [EOL] assert isinstance ( name , IDLUnresolvedIdentifier ) [EOL] [EOL] self . _finished = False [EOL] self . members = [ ] [EOL] self . _partials = [ ] [EOL] self . _extendedAttrDict = { } [EOL] self . _isKnownNonPartial = False [EOL] [EOL] IDLObjectWithScope . __init__ ( self , location , parentScope , name ) [EOL] IDLExposureMixins . __init__ ( self , location ) [EOL] [EOL] def finish ( self , scope ) : [EOL] if not self . _isKnownNonPartial : [EOL] raise WebIDLError ( [string] % str ( self ) , [ self . location ] ) [EOL] [EOL] IDLExposureMixins . finish ( self , scope ) [EOL] [EOL] [comment] [EOL] for partial in self . _partials : [EOL] partial . finish ( scope ) [EOL] self . addExtendedAttributes ( partial . propagatedExtendedAttrs ) [EOL] self . members . extend ( partial . members ) [EOL] [EOL] def resolveIdentifierConflict ( self , scope , identifier , originalObject , newObject ) : [EOL] assert isinstance ( scope , IDLScope ) [EOL] assert isinstance ( originalObject , IDLInterfaceMember ) [EOL] assert isinstance ( newObject , IDLInterfaceMember ) [EOL] [EOL] retval = IDLScope . resolveIdentifierConflict ( self , scope , identifier , originalObject , newObject ) [EOL] [EOL] [comment] [EOL] if newObject in self . members : [EOL] self . members . remove ( newObject ) [EOL] return retval [EOL] [EOL] def typeName ( self ) : [EOL] if self . isInterface ( ) : [EOL] return [string] [EOL] if self . isNamespace ( ) : [EOL] return [string] [EOL] assert self . isInterfaceMixin ( ) [EOL] return [string] [EOL] [EOL] def getExtendedAttribute ( self , name ) : [EOL] return self . _extendedAttrDict . get ( name , None ) [EOL] [EOL] def setNonPartial ( self , location , members ) : [EOL] if self . _isKnownNonPartial : [EOL] raise WebIDLError ( [string] [string] % self . typeName ( ) , [ location , self . location ] ) [EOL] self . _isKnownNonPartial = True [EOL] [comment] [EOL] [comment] [EOL] self . location = location [EOL] [comment] [EOL] self . members = members + self . members [EOL] [EOL] def addPartial ( self , partial ) : [EOL] assert self . identifier . name == partial . identifier . name [EOL] self . _partials . append ( partial ) [EOL] [EOL] def getPartials ( self ) : [EOL] [comment] [EOL] return list ( self . _partials ) [EOL] [EOL] def finishMembers ( self , scope ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for m in self . members : [EOL] [comment] [EOL] [comment] [EOL] if len ( m . _exposureGlobalNames ) == [number] : [EOL] m . _exposureGlobalNames . update ( self . _exposureGlobalNames ) [EOL] if m . isAttr ( ) and m . stringifier : [EOL] m . expand ( self . members ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for member in list ( self . members ) : [EOL] member . resolve ( self ) [EOL] [EOL] for member in self . members : [EOL] member . finish ( scope ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for member in self . members : [EOL] if not member . exposureSet . issubset ( self . exposureSet ) : [EOL] raise WebIDLError ( [string] [string] , [ member . location , self . location ] ) [EOL] [EOL] def isExternal ( self ) : [EOL] return False [EOL] [EOL] [EOL] class IDLInterfaceMixin ( IDLInterfaceOrInterfaceMixinOrNamespace ) : [EOL] def __init__ ( self , location , parentScope , name , members , isKnownNonPartial ) : [EOL] self . actualExposureGlobalNames = set ( ) [EOL] [EOL] assert isKnownNonPartial or len ( members ) == [number] [EOL] IDLInterfaceOrInterfaceMixinOrNamespace . __init__ ( self , location , parentScope , name ) [EOL] [EOL] if isKnownNonPartial : [EOL] self . setNonPartial ( location , members ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % self . identifier . name [EOL] [EOL] def isInterfaceMixin ( self ) : [EOL] return True [EOL] [EOL] def finish ( self , scope ) : [EOL] if self . _finished : [EOL] return [EOL] self . _finished = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] hasImplicitExposure = len ( self . _exposureGlobalNames ) == [number] [EOL] if hasImplicitExposure : [EOL] self . _exposureGlobalNames . update ( self . actualExposureGlobalNames ) [EOL] [EOL] IDLInterfaceOrInterfaceMixinOrNamespace . finish ( self , scope ) [EOL] [EOL] self . finishMembers ( scope ) [EOL] [EOL] def validate ( self ) : [EOL] for member in self . members : [EOL] [EOL] if member . isAttr ( ) : [EOL] if member . inherit : [EOL] raise WebIDLError ( [string] [string] , [ member . location , self . location ] ) [EOL] if member . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ member . location , self . location ] ) [EOL] [EOL] if member . isMethod ( ) : [EOL] if member . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ member . location , self . location ] ) [EOL] if ( member . isGetter ( ) or member . isSetter ( ) or member . isDeleter ( ) or member . isLegacycaller ( ) ) : [EOL] raise WebIDLError ( [string] [string] , [ member . location , self . location ] ) [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] for attr in attrs : [EOL] identifier = attr . identifier ( ) [EOL] [EOL] if identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] [comment] [EOL] for member in self . members : [EOL] if member . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] [string] , [ member . location , attr . location ] ) [EOL] member . addExtendedAttributes ( [ attr ] ) [EOL] elif identifier == [string] : [EOL] convertExposedAttrToGlobalNameSet ( attr , self . _exposureGlobalNames ) [EOL] else : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] [EOL] attrlist = attr . listValue ( ) [EOL] self . _extendedAttrDict [ identifier ] = attrlist if len ( attrlist ) else True [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( self . members ) [EOL] [EOL] [EOL] class IDLInterfaceOrNamespace ( IDLInterfaceOrInterfaceMixinOrNamespace ) : [EOL] def __init__ ( self , location , parentScope , name , parent , members , isKnownNonPartial , toStringTag ) : [EOL] assert isKnownNonPartial or not parent [EOL] assert isKnownNonPartial or len ( members ) == [number] [EOL] [EOL] self . parent = None [EOL] self . _callback = False [EOL] self . maplikeOrSetlikeOrIterable = None [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . namedConstructors = list ( ) [EOL] self . legacyWindowAliases = [ ] [EOL] self . includedMixins = set ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . interfacesBasedOnSelf = set ( [ self ] ) [EOL] self . _hasChildInterfaces = False [EOL] self . _isOnGlobalProtoChain = False [EOL] [comment] [EOL] [comment] [EOL] self . totalMembersInSlots = [number] [EOL] [comment] [EOL] self . _ownMembersInSlots = [number] [EOL] [comment] [EOL] [comment] [EOL] self . iterableInterface = None [EOL] [comment] [EOL] self . hasCrossOriginMembers = False [EOL] [comment] [EOL] self . hasDescendantWithCrossOriginMembers = False [EOL] [EOL] self . toStringTag = toStringTag [EOL] [EOL] IDLInterfaceOrInterfaceMixinOrNamespace . __init__ ( self , location , parentScope , name ) [EOL] [EOL] if isKnownNonPartial : [EOL] self . setNonPartial ( location , parent , members ) [EOL] [EOL] def ctor ( self ) : [EOL] identifier = IDLUnresolvedIdentifier ( self . location , [string] , allowForbidden = True ) [EOL] try : [EOL] return self . _lookupIdentifier ( identifier ) [EOL] except : [EOL] return None [EOL] [EOL] def isIterable ( self ) : [EOL] return ( self . maplikeOrSetlikeOrIterable and self . maplikeOrSetlikeOrIterable . isIterable ( ) ) [EOL] [EOL] def isIteratorInterface ( self ) : [EOL] return self . iterableInterface is not None [EOL] [EOL] def finish ( self , scope ) : [EOL] if self . _finished : [EOL] return [EOL] [EOL] self . _finished = True [EOL] [EOL] IDLInterfaceOrInterfaceMixinOrNamespace . finish ( self , scope ) [EOL] [EOL] if len ( self . legacyWindowAliases ) > [number] : [EOL] if not self . hasInterfaceObject ( ) : [EOL] raise WebIDLError ( [string] [string] % self . identifier . name , [ self . location ] ) [EOL] if not self . isExposedInWindow ( ) : [EOL] raise WebIDLError ( [string] [string] % self . identifier . name , [ self . location ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for member in self . members : [EOL] if member . isMaplikeOrSetlikeOrIterable ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . maplikeOrSetlikeOrIterable : [EOL] raise WebIDLError ( [string] [string] [string] % ( member . maplikeOrSetlikeOrIterableType , self . maplikeOrSetlikeOrIterable . maplikeOrSetlikeOrIterableType ) , [ self . maplikeOrSetlikeOrIterable . location , member . location ] ) [EOL] self . maplikeOrSetlikeOrIterable = member [EOL] [comment] [EOL] [comment] [EOL] self . maplikeOrSetlikeOrIterable . expand ( self . members , self . isJSImplemented ( ) ) [EOL] [EOL] assert not self . parent or isinstance ( self . parent , IDLIdentifierPlaceholder ) [EOL] parent = self . parent . finish ( scope ) if self . parent else None [EOL] if parent and isinstance ( parent , IDLExternalInterface ) : [EOL] raise WebIDLError ( [string] [string] % ( self . identifier . name , self . parent . identifier . name ) , [ self . location ] ) [EOL] if parent and not isinstance ( parent , IDLInterface ) : [EOL] raise WebIDLError ( [string] % ( self . identifier . name , self . parent . identifier . name ) , [ self . location , parent . location ] ) [EOL] [EOL] self . parent = parent [EOL] [EOL] assert iter ( self . members ) [EOL] [EOL] if self . isNamespace ( ) : [EOL] assert not self . parent [EOL] for m in self . members : [EOL] if m . isAttr ( ) or m . isMethod ( ) : [EOL] if m . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location , m . location ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] m . forceStatic ( ) [EOL] [EOL] if self . parent : [EOL] self . parent . finish ( scope ) [EOL] self . parent . _hasChildInterfaces = True [EOL] [EOL] self . totalMembersInSlots = self . parent . totalMembersInSlots [EOL] [EOL] [comment] [EOL] if self . parent . getExtendedAttribute ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] raise WebIDLError ( [string] [string] , [ self . location , self . parent . location ] ) [EOL] [EOL] [comment] [EOL] if not self . exposureSet . issubset ( self . parent . exposureSet ) : [EOL] raise WebIDLError ( [string] [string] % ( self . identifier . name , self . parent . identifier . name ) , [ self . location , self . parent . location ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . isCallback ( ) : [EOL] if not self . parent . isCallback ( ) : [EOL] raise WebIDLError ( [string] [string] % ( self . identifier . name , self . parent . identifier . name ) , [ self . location , self . parent . location ] ) [EOL] elif self . parent . isCallback ( ) : [EOL] raise WebIDLError ( [string] [string] % ( self . identifier . name , self . parent . identifier . name ) , [ self . location , self . parent . location ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( self . parent . getExtendedAttribute ( [string] ) and not self . getExtendedAttribute ( [string] ) ) : [EOL] raise WebIDLError ( [string] [string] [string] % ( self . identifier . name , self . parent . identifier . name ) , [ self . location , self . parent . location ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( self . parent . getExtendedAttribute ( [string] ) and not self . getExtendedAttribute ( [string] ) ) : [EOL] raise WebIDLError ( [string] [string] [string] % ( self . identifier . name , self . parent . identifier . name ) , [ self . location , self . parent . location ] ) [EOL] [EOL] for mixin in self . includedMixins : [EOL] mixin . finish ( scope ) [EOL] [EOL] cycleInGraph = self . findInterfaceLoopPoint ( self ) [EOL] if cycleInGraph : [EOL] raise WebIDLError ( [string] % self . identifier . name , [ self . location , cycleInGraph . location ] ) [EOL] [EOL] self . finishMembers ( scope ) [EOL] [EOL] ctor = self . ctor ( ) [EOL] if ctor is not None : [EOL] if not self . hasInterfaceObject ( ) : [EOL] raise WebIDLError ( [string] , [ self . location , ctor . location ] ) [EOL] [EOL] if self . globalNames : [EOL] raise WebIDLError ( [string] , [ self . location , ctor . location ] ) [EOL] [EOL] assert ( ctor . _exposureGlobalNames == self . _exposureGlobalNames ) [EOL] ctor . _exposureGlobalNames . update ( self . _exposureGlobalNames ) [EOL] [comment] [EOL] [comment] [EOL] self . members . remove ( ctor ) [EOL] [EOL] for ctor in self . namedConstructors : [EOL] if self . globalNames : [EOL] raise WebIDLError ( [string] , [ self . location , ctor . location ] ) [EOL] assert len ( ctor . _exposureGlobalNames ) == [number] [EOL] ctor . _exposureGlobalNames . update ( self . _exposureGlobalNames ) [EOL] ctor . finish ( scope ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . originalMembers = list ( self . members ) [EOL] [EOL] for mixin in sorted ( self . includedMixins , key = lambda x : x . identifier . name ) : [EOL] for mixinMember in mixin . members : [EOL] for member in self . members : [EOL] if mixinMember . identifier . name == member . identifier . name : [EOL] raise WebIDLError ( [string] % ( member . identifier . name , self ) , [ mixinMember . location , member . location ] ) [EOL] self . members . extend ( mixin . members ) [EOL] [EOL] for ancestor in self . getInheritedInterfaces ( ) : [EOL] ancestor . interfacesBasedOnSelf . add ( self ) [EOL] if ( ancestor . maplikeOrSetlikeOrIterable is not None and self . maplikeOrSetlikeOrIterable is not None ) : [EOL] raise WebIDLError ( [string] [string] [string] % ( self . identifier . name , ancestor . identifier . name ) , [ self . maplikeOrSetlikeOrIterable . location , ancestor . maplikeOrSetlikeOrIterable . location ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not any ( m . isMethod ( ) and m . isStringifier ( ) for m in self . members ) : [EOL] raise WebIDLError ( [string] [string] % self . identifier . name , [ self . location ] ) [EOL] [EOL] for m in self . members : [EOL] if m . identifier . name == [string] : [EOL] raise WebIDLError ( [string] [string] [string] % self . identifier . name , [ self . location , m . location ] ) [EOL] [EOL] if m . identifier . name == [string] and not m . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] [string] % self . identifier . name , [ self . location , m . location ] ) [EOL] [EOL] for member in self . members : [EOL] if ( ( member . isAttr ( ) or member . isMethod ( ) ) and member . isUnforgeable ( ) and not hasattr ( member , [string] ) ) : [EOL] member . originatingInterface = self [EOL] [EOL] for member in self . members : [EOL] if ( ( member . isMethod ( ) and member . getExtendedAttribute ( [string] ) ) or ( member . isAttr ( ) and ( member . getExtendedAttribute ( [string] ) or member . getExtendedAttribute ( [string] ) ) ) ) : [EOL] self . hasCrossOriginMembers = True [EOL] break [EOL] [EOL] if self . hasCrossOriginMembers : [EOL] parent = self [EOL] while parent : [EOL] parent . hasDescendantWithCrossOriginMembers = True [EOL] parent = parent . parent [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for member in self . members : [EOL] if ( ( member . isAttr ( ) and ( member . getExtendedAttribute ( [string] ) or member . getExtendedAttribute ( [string] ) ) ) or member . isMaplikeOrSetlike ( ) ) : [EOL] if self . isJSImplemented ( ) and not member . isMaplikeOrSetlike ( ) : [EOL] raise WebIDLError ( [string] [string] [string] % self . identifier . name , [ self . location , member . location ] ) [EOL] if member . slotIndices is None : [EOL] member . slotIndices = dict ( ) [EOL] member . slotIndices [ self . identifier . name ] = self . totalMembersInSlots [EOL] self . totalMembersInSlots += [number] [EOL] if member . getExtendedAttribute ( [string] ) : [EOL] self . _ownMembersInSlots += [number] [EOL] [EOL] if self . parent : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for unforgeableMember in ( member for member in self . parent . members if ( member . isAttr ( ) or member . isMethod ( ) ) and member . isUnforgeable ( ) ) : [EOL] shadows = [ m for m in self . members if ( m . isAttr ( ) or m . isMethod ( ) ) and not m . isStatic ( ) and m . identifier . name == unforgeableMember . identifier . name ] [EOL] if len ( shadows ) != [number] : [EOL] locs = [ unforgeableMember . location ] + [ s . location for s in shadows ] [EOL] raise WebIDLError ( [string] [string] % ( self . identifier . name , ancestor . identifier . name ) , locs ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . members . append ( unforgeableMember ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . maplikeOrSetlikeOrIterable : [EOL] testInterface = self [EOL] isAncestor = False [EOL] while testInterface : [EOL] self . maplikeOrSetlikeOrIterable . checkCollisions ( testInterface . members , isAncestor ) [EOL] isAncestor = True [EOL] testInterface = testInterface . parent [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] specialMembersSeen = { } [EOL] for member in self . members : [EOL] if not member . isMethod ( ) : [EOL] continue [EOL] [EOL] if member . isGetter ( ) : [EOL] memberType = [string] [EOL] elif member . isSetter ( ) : [EOL] memberType = [string] [EOL] elif member . isDeleter ( ) : [EOL] memberType = [string] [EOL] elif member . isStringifier ( ) : [EOL] memberType = [string] [EOL] elif member . isLegacycaller ( ) : [EOL] memberType = [string] [EOL] else : [EOL] continue [EOL] [EOL] if ( memberType != [string] and memberType != [string] ) : [EOL] if member . isNamed ( ) : [EOL] memberType = [string] + memberType [EOL] else : [EOL] assert member . isIndexed ( ) [EOL] memberType = [string] + memberType [EOL] [EOL] if memberType in specialMembersSeen : [EOL] raise WebIDLError ( [string] + memberType + [string] % (self) , [ self . location , specialMembersSeen [ memberType ] . location , member . location ] ) [EOL] [EOL] specialMembersSeen [ memberType ] = member [EOL] [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] [comment] [EOL] if [string] not in specialMembersSeen : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] ancestor = self . parent [EOL] while ancestor : [EOL] if ancestor . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] [string] , [ self . location , ancestor . location ] ) [EOL] ancestor = ancestor . parent [EOL] [EOL] if self . _isOnGlobalProtoChain : [EOL] [comment] [EOL] for memberType in [ [string] , [string] ] : [EOL] memberId = [string] + memberType + [string] [EOL] if memberId in specialMembersSeen : [EOL] raise WebIDLError ( [string] % memberType , [ self . location , specialMembersSeen [ memberId ] . location ] ) [EOL] [comment] [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] [comment] [EOL] parent = self . parent [EOL] while parent : [EOL] [comment] [EOL] if parent . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location , parent . location ] ) [EOL] parent . _isOnGlobalProtoChain = True [EOL] parent = parent . parent [EOL] [EOL] def validate ( self ) : [EOL] [EOL] def checkDuplicateNames ( member , name , attributeName ) : [EOL] for m in self . members : [EOL] if m . identifier . name == name : [EOL] raise WebIDLError ( [string] % ( attributeName , name ) , [ member . location , m . location ] ) [EOL] if m . isMethod ( ) and m != member and name in m . aliases : [EOL] raise WebIDLError ( [string] % ( attributeName , name ) , [ member . location , m . location ] ) [EOL] if m . isAttr ( ) and m != member and name in m . bindingAliases : [EOL] raise WebIDLError ( [string] % ( attributeName , name ) , [ member . location , m . location ] ) [EOL] [EOL] [comment] [EOL] if self . getExtendedAttribute ( [string] ) and self . hasChildInterfaces ( ) : [EOL] locations = ( [ self . location ] + list ( i . location for i in self . interfacesBasedOnSelf if i . parent == self ) ) [EOL] raise WebIDLError ( [string] % self . identifier . name , locations ) [EOL] [EOL] ctor = self . ctor ( ) [EOL] if ctor is not None : [EOL] ctor . validate ( ) [EOL] for namedCtor in self . namedConstructors : [EOL] namedCtor . validate ( ) [EOL] [EOL] indexedGetter = None [EOL] hasLengthAttribute = False [EOL] for member in self . members : [EOL] member . validate ( ) [EOL] [EOL] if self . isCallback ( ) and member . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] % self . identifier . name , [ self . location , member . location ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if member . isAttr ( ) : [EOL] if ( member . identifier . name == [string] and member . type . isInteger ( ) ) : [EOL] hasLengthAttribute = True [EOL] [EOL] iface = self [EOL] attr = member [EOL] putForwards = attr . getExtendedAttribute ( [string] ) [EOL] if putForwards and self . isCallback ( ) : [EOL] raise WebIDLError ( [string] [string] [string] % self . identifier . name , [ self . location , member . location ] ) [EOL] [EOL] while putForwards is not None : [EOL] forwardIface = attr . type . unroll ( ) . inner [EOL] fowardAttr = None [EOL] [EOL] for forwardedMember in forwardIface . members : [EOL] if ( not forwardedMember . isAttr ( ) or forwardedMember . identifier . name != putForwards [ [number] ] ) : [EOL] continue [EOL] if forwardedMember == member : [EOL] raise WebIDLError ( [string] [string] [string] % ( member . identifier . name , self ) , [ member . location ] ) [EOL] fowardAttr = forwardedMember [EOL] break [EOL] [EOL] if fowardAttr is None : [EOL] raise WebIDLError ( [string] [string] % ( attr . identifier . name , iface , putForwards ) , [ attr . location ] ) [EOL] [EOL] iface = forwardIface [EOL] attr = fowardAttr [EOL] putForwards = attr . getExtendedAttribute ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if member . isMethod ( ) : [EOL] if member . isGetter ( ) and member . isIndexed ( ) : [EOL] indexedGetter = member [EOL] [EOL] for alias in member . aliases : [EOL] if self . isOnGlobalProtoChain ( ) : [EOL] raise WebIDLError ( [string] [string] , [ member . location ] ) [EOL] if ( member . getExtendedAttribute ( [string] ) or member . getExtendedAttribute ( [string] ) or member . getExtendedAttribute ( [string] ) or member . getExtendedAttribute ( [string] ) or member . getExtendedAttribute ( [string] ) ) : [EOL] raise WebIDLError ( [string] [string] , [ member . location ] ) [EOL] if member . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ member . location ] ) [EOL] if member . isIdentifierLess ( ) : [EOL] raise WebIDLError ( [string] [string] , [ member . location ] ) [EOL] if member . isUnforgeable ( ) : [EOL] raise WebIDLError ( [string] [string] , [ member . location ] ) [EOL] [EOL] checkDuplicateNames ( member , alias , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if member . isAttr ( ) : [EOL] for bindingAlias in member . bindingAliases : [EOL] checkDuplicateNames ( member , bindingAlias , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( self . isExposedConditionally ( exclusions = [ [string] ] ) and not self . hasInterfaceObject ( ) ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . isIterable ( ) : [EOL] iterableDecl = self . maplikeOrSetlikeOrIterable [EOL] if iterableDecl . isValueIterator ( ) : [EOL] if not indexedGetter : [EOL] raise WebIDLError ( [string] [string] , [ self . location , iterableDecl . location ] ) [EOL] [EOL] if iterableDecl . valueType != indexedGetter . signatures ( ) [ [number] ] [ [number] ] : [EOL] raise WebIDLError ( [string] [string] , [ iterableDecl . location , indexedGetter . location ] ) [EOL] [EOL] if not hasLengthAttribute : [EOL] raise WebIDLError ( [string] [string] , [ self . location , iterableDecl . location ] ) [EOL] else : [EOL] assert iterableDecl . isPairIterator ( ) [EOL] if indexedGetter : [EOL] raise WebIDLError ( [string] [string] , [ self . location , iterableDecl . location , indexedGetter . location ] ) [EOL] [EOL] if indexedGetter and not hasLengthAttribute : [EOL] raise WebIDLError ( [string] [string] , [ self . location , indexedGetter . location ] ) [EOL] [EOL] def setCallback ( self , value ) : [EOL] self . _callback = value [EOL] [EOL] def isCallback ( self ) : [EOL] return self . _callback [EOL] [EOL] def isSingleOperationInterface ( self ) : [EOL] assert self . isCallback ( ) or self . isJSImplemented ( ) [EOL] return ( not self . isJSImplemented ( ) and not self . parent and not any ( m . isAttr ( ) for m in self . members ) and len ( set ( m . identifier . name for m in self . members if m . isMethod ( ) and not m . isStatic ( ) ) ) == [number] ) [EOL] [EOL] def inheritanceDepth ( self ) : [EOL] depth = [number] [EOL] parent = self . parent [EOL] while parent : [EOL] depth = depth + [number] [EOL] parent = parent . parent [EOL] return depth [EOL] [EOL] def hasConstants ( self ) : [EOL] return any ( m . isConst ( ) for m in self . members ) [EOL] [EOL] def hasInterfaceObject ( self ) : [EOL] if self . isCallback ( ) : [EOL] return self . hasConstants ( ) [EOL] return not hasattr ( self , [string] ) [EOL] [EOL] def hasInterfacePrototypeObject ( self ) : [EOL] return ( not self . isCallback ( ) and not self . isNamespace ( ) [EOL] and self . getUserData ( [string] , False ) ) [EOL] [EOL] def addIncludedMixin ( self , includedMixin ) : [EOL] assert ( isinstance ( includedMixin , IDLInterfaceMixin ) ) [EOL] self . includedMixins . add ( includedMixin ) [EOL] [EOL] def getInheritedInterfaces ( self ) : [EOL] [docstring] [EOL] assert ( self . _finished ) [EOL] if not self . parent : [EOL] return [ ] [EOL] parentInterfaces = self . parent . getInheritedInterfaces ( ) [EOL] parentInterfaces . insert ( [number] , self . parent ) [EOL] return parentInterfaces [EOL] [EOL] def findInterfaceLoopPoint ( self , otherInterface ) : [EOL] [docstring] [EOL] if self . parent : [EOL] if self . parent == otherInterface : [EOL] return self [EOL] loopPoint = self . parent . findInterfaceLoopPoint ( otherInterface ) [EOL] if loopPoint : [EOL] return loopPoint [EOL] return None [EOL] [EOL] def setNonPartial ( self , location , parent , members ) : [EOL] assert not parent or isinstance ( parent , IDLIdentifierPlaceholder ) [EOL] IDLInterfaceOrInterfaceMixinOrNamespace . setNonPartial ( self , location , members ) [EOL] assert not self . parent [EOL] self . parent = parent [EOL] [EOL] def getJSImplementation ( self ) : [EOL] classId = self . getExtendedAttribute ( [string] ) [EOL] if not classId : [EOL] return classId [EOL] assert isinstance ( classId , list ) [EOL] assert len ( classId ) == [number] [EOL] return classId [ [number] ] [EOL] [EOL] def isJSImplemented ( self ) : [EOL] return bool ( self . getJSImplementation ( ) ) [EOL] [EOL] def hasProbablyShortLivingWrapper ( self ) : [EOL] current = self [EOL] while current : [EOL] if current . getExtendedAttribute ( [string] ) : [EOL] return True [EOL] current = current . parent [EOL] return False [EOL] [EOL] def hasChildInterfaces ( self ) : [EOL] return self . _hasChildInterfaces [EOL] [EOL] def isOnGlobalProtoChain ( self ) : [EOL] return self . _isOnGlobalProtoChain [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] deps = set ( self . members ) [EOL] deps . update ( self . includedMixins ) [EOL] if self . parent : [EOL] deps . add ( self . parent ) [EOL] return deps [EOL] [EOL] def hasMembersInSlots ( self ) : [EOL] return self . _ownMembersInSlots != [number] [EOL] [EOL] conditionExtendedAttributes = [ [string] , [string] , [string] , [string] ] [EOL] def isExposedConditionally ( self , exclusions = [ ] ) : [EOL] return any ( ( ( not a in exclusions ) and self . getExtendedAttribute ( a ) ) for a in self . conditionExtendedAttributes ) [EOL] [EOL] class IDLInterface ( IDLInterfaceOrNamespace ) : [EOL] def __init__ ( self , location , parentScope , name , parent , members , isKnownNonPartial , classNameOverride = None , toStringTag = None ) : [EOL] IDLInterfaceOrNamespace . __init__ ( self , location , parentScope , name , parent , members , isKnownNonPartial , toStringTag ) [EOL] self . classNameOverride = classNameOverride [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % self . identifier . name [EOL] [EOL] def isInterface ( self ) : [EOL] return True [EOL] [EOL] def getClassName ( self ) : [EOL] if self . classNameOverride : [EOL] return self . classNameOverride [EOL] return self . identifier . name [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] for attr in attrs : [EOL] identifier = attr . identifier ( ) [EOL] [EOL] [comment] [EOL] if identifier == [string] : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] if identifier == [string] : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] [EOL] self . _noInterfaceObject = True [EOL] elif identifier == [string] : [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] [EOL] [EOL] args = attr . args ( ) if attr . hasArgs ( ) else [ ] [EOL] [EOL] retType = IDLWrapperType ( self . location , self ) [EOL] [EOL] method = IDLConstructor ( attr . location , args , attr . value ( ) ) [EOL] method . reallyInit ( self ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] method . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( [string] , ) ) ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] method . resolve ( self . parentScope ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] newMethod = self . parentScope . lookupIdentifier ( method . identifier ) [EOL] if newMethod == method : [EOL] self . namedConstructors . append ( method ) [EOL] elif newMethod not in self . namedConstructors : [EOL] raise WebIDLError ( [string] [string] , [ method . location , newMethod . location ] ) [EOL] elif ( identifier == [string] ) : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] if self . parent : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if attr . hasValue ( ) : [EOL] self . globalNames = [ attr . value ( ) ] [EOL] elif attr . hasArgs ( ) : [EOL] self . globalNames = attr . args ( ) [EOL] else : [EOL] self . globalNames = [ self . identifier . name ] [EOL] self . parentScope . addIfaceGlobalNames ( self . identifier . name , self . globalNames ) [EOL] self . _isOnGlobalProtoChain = True [EOL] elif identifier == [string] : [EOL] if attr . hasValue ( ) : [EOL] self . legacyWindowAliases = [ attr . value ( ) ] [EOL] elif attr . hasArgs ( ) : [EOL] self . legacyWindowAliases = attr . args ( ) [EOL] else : [EOL] raise WebIDLError ( [string] [string] % identifier , [ attr . location ] ) [EOL] for alias in self . legacyWindowAliases : [EOL] unresolved = IDLUnresolvedIdentifier ( attr . location , alias ) [EOL] IDLObjectWithIdentifier ( attr . location , self . parentScope , unresolved ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] [comment] [EOL] for member in self . members : [EOL] if member . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] [string] , [ member . location , attr . location ] ) [EOL] member . addExtendedAttributes ( [ attr ] ) [EOL] elif ( identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] ) : [EOL] [comment] [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] elif identifier == [string] : [EOL] convertExposedAttrToGlobalNameSet ( attr , self . _exposureGlobalNames ) [EOL] elif ( identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] ) : [EOL] [comment] [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] elif identifier == [string] : [EOL] [comment] [EOL] if not attr . hasArgs ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] else : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] [EOL] attrlist = attr . listValue ( ) [EOL] self . _extendedAttrDict [ identifier ] = attrlist if len ( attrlist ) else True [EOL] [EOL] def validate ( self ) : [EOL] IDLInterfaceOrNamespace . validate ( self ) [EOL] if self . parent and self . isSerializable ( ) and not self . parent . isSerializable ( ) : [EOL] raise WebIDLError ( [string] [string] [string] [string] , [ self . location , self . parent . location ] ) [EOL] [EOL] def isSerializable ( self ) : [EOL] return self . getExtendedAttribute ( [string] ) [EOL] [EOL] def setNonPartial ( self , location , parent , members ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for member in members : [EOL] if isinstance ( member , IDLConstructor ) : [EOL] member . reallyInit ( self ) [EOL] [EOL] IDLInterfaceOrNamespace . setNonPartial ( self , location , parent , members ) [EOL] [EOL] [EOL] class IDLNamespace ( IDLInterfaceOrNamespace ) : [EOL] def __init__ ( self , location , parentScope , name , members , isKnownNonPartial ) : [EOL] IDLInterfaceOrNamespace . __init__ ( self , location , parentScope , name , None , members , isKnownNonPartial , toStringTag = None ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % self . identifier . name [EOL] [EOL] def isNamespace ( self ) : [EOL] return True [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for attr in attrs : [EOL] identifier = attr . identifier ( ) [EOL] [EOL] if identifier == [string] : [EOL] convertExposedAttrToGlobalNameSet ( attr , self . _exposureGlobalNames ) [EOL] elif identifier == [string] : [EOL] [comment] [EOL] [comment] [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] elif ( identifier == [string] or identifier == [string] ) : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] elif ( identifier == [string] or identifier == [string] or identifier == [string] ) : [EOL] [comment] [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] else : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] [EOL] attrlist = attr . listValue ( ) [EOL] self . _extendedAttrDict [ identifier ] = attrlist if len ( attrlist ) else True [EOL] [EOL] def isSerializable ( self ) : [EOL] return False [EOL] [EOL] [EOL] class IDLDictionary ( IDLObjectWithScope ) : [EOL] def __init__ ( self , location , parentScope , name , parent , members ) : [EOL] assert isinstance ( parentScope , IDLScope ) [EOL] assert isinstance ( name , IDLUnresolvedIdentifier ) [EOL] assert not parent or isinstance ( parent , IDLIdentifierPlaceholder ) [EOL] [EOL] self . parent = parent [EOL] self . _finished = False [EOL] self . members = list ( members ) [EOL] self . _partialDictionaries = [ ] [EOL] self . _extendedAttrDict = { } [EOL] self . needsConversionToJS = False [EOL] self . needsConversionFromJS = False [EOL] [EOL] IDLObjectWithScope . __init__ ( self , location , parentScope , name ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % self . identifier . name [EOL] [EOL] def isDictionary ( self ) : [EOL] return True [EOL] [EOL] def canBeEmpty ( self ) : [EOL] [docstring] [EOL] return ( all ( member . optional for member in self . members ) and ( not self . parent or self . parent . canBeEmpty ( ) ) ) [EOL] [EOL] def finish ( self , scope ) : [EOL] if self . _finished : [EOL] return [EOL] [EOL] self . _finished = True [EOL] [EOL] if self . parent : [EOL] assert isinstance ( self . parent , IDLIdentifierPlaceholder ) [EOL] oldParent = self . parent [EOL] self . parent = self . parent . finish ( scope ) [EOL] if not isinstance ( self . parent , IDLDictionary ) : [EOL] raise WebIDLError ( [string] % self . identifier . name , [ oldParent . location , self . parent . location ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . parent . finish ( scope ) [EOL] [EOL] [comment] [EOL] for partial in self . _partialDictionaries : [EOL] partial . finish ( scope ) [EOL] self . members . extend ( partial . members ) [EOL] [EOL] for member in self . members : [EOL] member . resolve ( self ) [EOL] if not member . isComplete ( ) : [EOL] member . complete ( scope ) [EOL] assert member . type . isComplete ( ) [EOL] [EOL] [comment] [EOL] self . members . sort ( key = lambda x : x . identifier . name ) [EOL] [EOL] inheritedMembers = [ ] [EOL] ancestor = self . parent [EOL] while ancestor : [EOL] if ancestor == self : [EOL] raise WebIDLError ( [string] % self . identifier . name , [ self . identifier . location ] ) [EOL] inheritedMembers . extend ( ancestor . members ) [EOL] ancestor = ancestor . parent [EOL] [EOL] [comment] [EOL] for inheritedMember in inheritedMembers : [EOL] for member in self . members : [EOL] if member . identifier . name == inheritedMember . identifier . name : [EOL] raise WebIDLError ( [string] % ( self . identifier . name , member . identifier . name ) , [ member . location , inheritedMember . location ] ) [EOL] [EOL] def validate ( self ) : [EOL] def typeContainsDictionary ( memberType , dictionary ) : [EOL] [docstring] [EOL] [EOL] if ( memberType . nullable ( ) or memberType . isSequence ( ) or memberType . isRecord ( ) ) : [EOL] return typeContainsDictionary ( memberType . inner , dictionary ) [EOL] [EOL] if memberType . isDictionary ( ) : [EOL] if memberType . inner == dictionary : [EOL] return ( True , [ memberType . location ] ) [EOL] [EOL] ( contains , locations ) = dictionaryContainsDictionary ( memberType . inner , dictionary ) [EOL] if contains : [EOL] return ( True , [ memberType . location ] + locations ) [EOL] [EOL] if memberType . isUnion ( ) : [EOL] for member in memberType . flatMemberTypes : [EOL] ( contains , locations ) = typeContainsDictionary ( member , dictionary ) [EOL] if contains : [EOL] return ( True , locations ) [EOL] [EOL] return ( False , None ) [EOL] [EOL] def dictionaryContainsDictionary ( dictMember , dictionary ) : [EOL] for member in dictMember . members : [EOL] ( contains , locations ) = typeContainsDictionary ( member . type , dictionary ) [EOL] if contains : [EOL] return ( True , [ member . location ] + locations ) [EOL] [EOL] if dictMember . parent : [EOL] if dictMember . parent == dictionary : [EOL] return ( True , [ dictMember . location ] ) [EOL] else : [EOL] ( contains , locations ) = dictionaryContainsDictionary ( dictMember . parent , dictionary ) [EOL] if contains : [EOL] return ( True , [ dictMember . location ] + locations ) [EOL] [EOL] return ( False , None ) [EOL] [EOL] for member in self . members : [EOL] if member . type . isDictionary ( ) and member . type . nullable ( ) : [EOL] raise WebIDLError ( [string] [string] % self . identifier . name , [ member . location ] ) [EOL] ( contains , locations ) = typeContainsDictionary ( member . type , self ) [EOL] if contains : [EOL] raise WebIDLError ( [string] % self . identifier . name , [ member . location ] + locations ) [EOL] [EOL] def getExtendedAttribute ( self , name ) : [EOL] return self . _extendedAttrDict . get ( name , None ) [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] for attr in attrs : [EOL] identifier = attr . identifier ( ) [EOL] [EOL] if ( identifier == [string] or identifier == [string] ) : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] self . needsConversionFromJS = True [EOL] elif ( identifier == [string] or identifier == [string] ) : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . needsConversionToJS = True [EOL] else : [EOL] raise WebIDLError ( [string] [string] % identifier , [ attr . location ] ) [EOL] [EOL] self . _extendedAttrDict [ identifier ] = True [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] deps = set ( self . members ) [EOL] if ( self . parent ) : [EOL] deps . add ( self . parent ) [EOL] return deps [EOL] [EOL] def addPartialDictionary ( self , partial ) : [EOL] assert self . identifier . name == partial . identifier . name [EOL] self . _partialDictionaries . append ( partial ) [EOL] [EOL] [EOL] class IDLEnum ( IDLObjectWithIdentifier ) : [EOL] def __init__ ( self , location , parentScope , name , values ) : [EOL] assert isinstance ( parentScope , IDLScope ) [EOL] assert isinstance ( name , IDLUnresolvedIdentifier ) [EOL] [EOL] if len ( values ) != len ( set ( values ) ) : [EOL] raise WebIDLError ( [string] % name . name , [ location ] ) [EOL] [EOL] IDLObjectWithIdentifier . __init__ ( self , location , parentScope , name ) [EOL] self . _values = values [EOL] [EOL] def values ( self ) : [EOL] return self . _values [EOL] [EOL] def finish ( self , scope ) : [EOL] pass [EOL] [EOL] def validate ( self ) : [EOL] pass [EOL] [EOL] def isEnum ( self ) : [EOL] return True [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] if len ( attrs ) != [number] : [EOL] raise WebIDLError ( [string] [string] , [ attrs [ [number] ] . location , self . location ] ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( ) [EOL] [EOL] [EOL] class IDLType ( IDLObject ) : [EOL] Tags = enum ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , location , name ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] self . name = name [EOL] self . builtin = False [EOL] self . treatNullAsEmpty = False [EOL] self . _clamp = False [EOL] self . _enforceRange = False [EOL] self . _allowShared = False [EOL] self . _extendedAttrDict = { } [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( other and self . builtin == other . builtin and self . name == other . name and self . _clamp == other . hasClamp ( ) and self . _enforceRange == other . hasEnforceRange ( ) and self . treatNullAsEmpty == other . treatNullAsEmpty and self . _allowShared == other . hasAllowShared ( ) ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self == other [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . name ) [EOL] [EOL] def prettyName ( self ) : [EOL] [docstring] [EOL] return str ( self . name ) [EOL] [EOL] def isType ( self ) : [EOL] return True [EOL] [EOL] def nullable ( self ) : [EOL] return False [EOL] [EOL] def isPrimitive ( self ) : [EOL] return False [EOL] [EOL] def isBoolean ( self ) : [EOL] return False [EOL] [EOL] def isNumeric ( self ) : [EOL] return False [EOL] [EOL] def isString ( self ) : [EOL] return False [EOL] [EOL] def isByteString ( self ) : [EOL] return False [EOL] [EOL] def isDOMString ( self ) : [EOL] return False [EOL] [EOL] def isUSVString ( self ) : [EOL] return False [EOL] [EOL] def isUTF8String ( self ) : [EOL] return False [EOL] [EOL] def isJSString ( self ) : [EOL] return False [EOL] [EOL] def isVoid ( self ) : [EOL] return self . name == [string] [EOL] [EOL] def isSequence ( self ) : [EOL] return False [EOL] [EOL] def isRecord ( self ) : [EOL] return False [EOL] [EOL] def isReadableStream ( self ) : [EOL] return False [EOL] [EOL] def isArrayBuffer ( self ) : [EOL] return False [EOL] [EOL] def isArrayBufferView ( self ) : [EOL] return False [EOL] [EOL] def isTypedArray ( self ) : [EOL] return False [EOL] [EOL] def isBufferSource ( self ) : [EOL] return self . isArrayBuffer ( ) or self . isArrayBufferView ( ) or self . isTypedArray ( ) [EOL] [EOL] def isCallbackInterface ( self ) : [EOL] return False [EOL] [EOL] def isNonCallbackInterface ( self ) : [EOL] return False [EOL] [EOL] def isGeckoInterface ( self ) : [EOL] [docstring] [EOL] return self . isInterface ( ) and not self . isSpiderMonkeyInterface ( ) [EOL] [EOL] def isSpiderMonkeyInterface ( self ) : [EOL] [docstring] [EOL] return self . isInterface ( ) and ( self . isBufferSource ( ) or self . isReadableStream ( ) ) [EOL] [EOL] def isDictionary ( self ) : [EOL] return False [EOL] [EOL] def isInterface ( self ) : [EOL] return False [EOL] [EOL] def isAny ( self ) : [EOL] return self . tag ( ) == IDLType . Tags . any [EOL] [EOL] def isObject ( self ) : [EOL] return self . tag ( ) == IDLType . Tags . object [EOL] [EOL] def isPromise ( self ) : [EOL] return False [EOL] [EOL] def isComplete ( self ) : [EOL] return True [EOL] [EOL] def includesRestrictedFloat ( self ) : [EOL] return False [EOL] [EOL] def isFloat ( self ) : [EOL] return False [EOL] [EOL] def isUnrestricted ( self ) : [EOL] [comment] [EOL] assert self . isFloat ( ) [EOL] [EOL] def isJSONType ( self ) : [EOL] return False [EOL] [EOL] def hasClamp ( self ) : [EOL] return self . _clamp [EOL] [EOL] def hasEnforceRange ( self ) : [EOL] return self . _enforceRange [EOL] [EOL] def hasAllowShared ( self ) : [EOL] return self . _allowShared [EOL] [EOL] def tag ( self ) : [EOL] assert False [comment] [EOL] [EOL] def treatNonCallableAsNull ( self ) : [EOL] assert self . tag ( ) == IDLType . Tags . callback [EOL] return self . nullable ( ) and self . inner . callback . _treatNonCallableAsNull [EOL] [EOL] def treatNonObjectAsNull ( self ) : [EOL] assert self . tag ( ) == IDLType . Tags . callback [EOL] return self . nullable ( ) and self . inner . callback . _treatNonObjectAsNull [EOL] [EOL] def withExtendedAttributes ( self , attrs ) : [EOL] if len ( attrs ) > [number] : [EOL] raise WebIDLError ( [string] , [ attrs [ [number] ] . location , self . location ] ) [EOL] return self [EOL] [EOL] def getExtendedAttribute ( self , name ) : [EOL] return self . _extendedAttrDict . get ( name , None ) [EOL] [EOL] def resolveType ( self , parentScope ) : [EOL] pass [EOL] [EOL] def unroll ( self ) : [EOL] return self [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] def isExposedInAllOf ( self , exposureSet ) : [EOL] return True [EOL] [EOL] [EOL] class IDLUnresolvedType ( IDLType ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , location , name , attrs = [ ] ) : [EOL] IDLType . __init__ ( self , location , name ) [EOL] self . extraTypeAttributes = attrs [EOL] [EOL] def isComplete ( self ) : [EOL] return False [EOL] [EOL] def complete ( self , scope ) : [EOL] obj = None [EOL] try : [EOL] obj = scope . _lookupIdentifier ( self . name ) [EOL] except : [EOL] raise WebIDLError ( [string] % self . name , [ self . location ] ) [EOL] [EOL] assert obj [EOL] if obj . isType ( ) : [EOL] print ( obj ) [EOL] assert not obj . isType ( ) [EOL] if obj . isTypedef ( ) : [EOL] assert self . name . name == obj . identifier . name [EOL] typedefType = IDLTypedefType ( self . location , obj . innerType , obj . identifier ) [EOL] assert not typedefType . isComplete ( ) [EOL] return typedefType . complete ( scope ) . withExtendedAttributes ( self . extraTypeAttributes ) [EOL] elif obj . isCallback ( ) and not obj . isInterface ( ) : [EOL] assert self . name . name == obj . identifier . name [EOL] return IDLCallbackType ( obj . location , obj ) [EOL] [EOL] name = self . name . resolve ( scope , None ) [EOL] return IDLWrapperType ( self . location , obj ) [EOL] [EOL] def withExtendedAttributes ( self , attrs ) : [EOL] return IDLUnresolvedType ( self . location , self . name , attrs ) [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] [EOL] class IDLParametrizedType ( IDLType ) : [EOL] def __init__ ( self , location , name , innerType ) : [EOL] IDLType . __init__ ( self , location , name ) [EOL] self . builtin = False [EOL] self . inner = innerType [EOL] [EOL] def includesRestrictedFloat ( self ) : [EOL] return self . inner . includesRestrictedFloat ( ) [EOL] [EOL] def resolveType ( self , parentScope ) : [EOL] assert isinstance ( parentScope , IDLScope ) [EOL] self . inner . resolveType ( parentScope ) [EOL] [EOL] def isComplete ( self ) : [EOL] return self . inner . isComplete ( ) [EOL] [EOL] def unroll ( self ) : [EOL] return self . inner . unroll ( ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return self . inner . _getDependentObjects ( ) [EOL] [EOL] [EOL] class IDLNullableType ( IDLParametrizedType ) : [EOL] def __init__ ( self , location , innerType ) : [EOL] assert not innerType . isVoid ( ) [EOL] assert not innerType == BuiltinTypes [ IDLBuiltinType . Types . any ] [EOL] [EOL] IDLParametrizedType . __init__ ( self , location , None , innerType ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , IDLNullableType ) and self . inner == other . inner [EOL] [EOL] def __str__ ( self ) : [EOL] return self . inner . __str__ ( ) + [string] [EOL] [EOL] def prettyName ( self ) : [EOL] return self . inner . prettyName ( ) + [string] [EOL] [EOL] def nullable ( self ) : [EOL] return True [EOL] [EOL] def isCallback ( self ) : [EOL] return self . inner . isCallback ( ) [EOL] [EOL] def isPrimitive ( self ) : [EOL] return self . inner . isPrimitive ( ) [EOL] [EOL] def isBoolean ( self ) : [EOL] return self . inner . isBoolean ( ) [EOL] [EOL] def isNumeric ( self ) : [EOL] return self . inner . isNumeric ( ) [EOL] [EOL] def isString ( self ) : [EOL] return self . inner . isString ( ) [EOL] [EOL] def isByteString ( self ) : [EOL] return self . inner . isByteString ( ) [EOL] [EOL] def isDOMString ( self ) : [EOL] return self . inner . isDOMString ( ) [EOL] [EOL] def isUSVString ( self ) : [EOL] return self . inner . isUSVString ( ) [EOL] [EOL] def isUTF8String ( self ) : [EOL] return self . inner . isUTF8String ( ) [EOL] [EOL] def isJSString ( self ) : [EOL] return self . inner . isJSString ( ) [EOL] [EOL] def isFloat ( self ) : [EOL] return self . inner . isFloat ( ) [EOL] [EOL] def isUnrestricted ( self ) : [EOL] return self . inner . isUnrestricted ( ) [EOL] [EOL] def isInteger ( self ) : [EOL] return self . inner . isInteger ( ) [EOL] [EOL] def isVoid ( self ) : [EOL] return False [EOL] [EOL] def isSequence ( self ) : [EOL] return self . inner . isSequence ( ) [EOL] [EOL] def isRecord ( self ) : [EOL] return self . inner . isRecord ( ) [EOL] [EOL] def isReadableStream ( self ) : [EOL] return self . inner . isReadableStream ( ) [EOL] [EOL] def isArrayBuffer ( self ) : [EOL] return self . inner . isArrayBuffer ( ) [EOL] [EOL] def isArrayBufferView ( self ) : [EOL] return self . inner . isArrayBufferView ( ) [EOL] [EOL] def isTypedArray ( self ) : [EOL] return self . inner . isTypedArray ( ) [EOL] [EOL] def isDictionary ( self ) : [EOL] return self . inner . isDictionary ( ) [EOL] [EOL] def isInterface ( self ) : [EOL] return self . inner . isInterface ( ) [EOL] [EOL] def isPromise ( self ) : [EOL] [comment] [EOL] assert not self . inner . isPromise ( ) [EOL] return False [EOL] [EOL] def isCallbackInterface ( self ) : [EOL] return self . inner . isCallbackInterface ( ) [EOL] [EOL] def isNonCallbackInterface ( self ) : [EOL] return self . inner . isNonCallbackInterface ( ) [EOL] [EOL] def isEnum ( self ) : [EOL] return self . inner . isEnum ( ) [EOL] [EOL] def isUnion ( self ) : [EOL] return self . inner . isUnion ( ) [EOL] [EOL] def isJSONType ( self ) : [EOL] return self . inner . isJSONType ( ) [EOL] [EOL] def hasClamp ( self ) : [EOL] return self . inner . hasClamp ( ) [EOL] [EOL] def hasEnforceRange ( self ) : [EOL] return self . inner . hasEnforceRange ( ) [EOL] [EOL] def hasAllowShared ( self ) : [EOL] return self . inner . hasAllowShared ( ) [EOL] [EOL] def isComplete ( self ) : [EOL] return self . name is not None [EOL] [EOL] def tag ( self ) : [EOL] return self . inner . tag ( ) [EOL] [EOL] def complete ( self , scope ) : [EOL] if not self . inner . isComplete ( ) : [EOL] self . inner = self . inner . complete ( scope ) [EOL] assert self . inner . isComplete ( ) [EOL] [EOL] if self . inner . nullable ( ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location , self . inner . location ] ) [EOL] if self . inner . isUnion ( ) : [EOL] if self . inner . hasNullableType : [EOL] raise WebIDLError ( [string] [string] [string] , [ self . location ] ) [EOL] if self . inner . isDOMString ( ) : [EOL] if self . inner . treatNullAsEmpty : [EOL] raise WebIDLError ( [string] , [ self . location , self . inner . location ] ) [EOL] [EOL] self . name = self . inner . name + [string] [EOL] return self [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] if ( other . nullable ( ) or other . isDictionary ( ) or ( other . isUnion ( ) and ( other . hasNullableType or other . hasDictionaryType ( ) ) ) ) : [EOL] [comment] [EOL] return False [EOL] return self . inner . isDistinguishableFrom ( other ) [EOL] [EOL] def withExtendedAttributes ( self , attrs ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return IDLNullableType ( self . location , self . inner . withExtendedAttributes ( attrs ) ) [EOL] [EOL] [EOL] class IDLSequenceType ( IDLParametrizedType ) : [EOL] def __init__ ( self , location , parameterType ) : [EOL] assert not parameterType . isVoid ( ) [EOL] [EOL] IDLParametrizedType . __init__ ( self , location , parameterType . name , parameterType ) [EOL] [comment] [EOL] [comment] [EOL] if self . inner . isComplete ( ) : [EOL] self . name = self . inner . name + [string] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , IDLSequenceType ) and self . inner == other . inner [EOL] [EOL] def __str__ ( self ) : [EOL] return self . inner . __str__ ( ) + [string] [EOL] [EOL] def prettyName ( self ) : [EOL] return [string] % self . inner . prettyName ( ) [EOL] [EOL] def nullable ( self ) : [EOL] return False [EOL] [EOL] def isPrimitive ( self ) : [EOL] return False [EOL] [EOL] def isString ( self ) : [EOL] return False [EOL] [EOL] def isByteString ( self ) : [EOL] return False [EOL] [EOL] def isDOMString ( self ) : [EOL] return False [EOL] [EOL] def isUSVString ( self ) : [EOL] return False [EOL] [EOL] def isUTF8String ( self ) : [EOL] return False [EOL] [EOL] def isJSString ( self ) : [EOL] return False [EOL] [EOL] def isVoid ( self ) : [EOL] return False [EOL] [EOL] def isSequence ( self ) : [EOL] return True [EOL] [EOL] def isDictionary ( self ) : [EOL] return False [EOL] [EOL] def isInterface ( self ) : [EOL] return False [EOL] [EOL] def isEnum ( self ) : [EOL] return False [EOL] [EOL] def isJSONType ( self ) : [EOL] return self . inner . isJSONType ( ) [EOL] [EOL] def tag ( self ) : [EOL] return IDLType . Tags . sequence [EOL] [EOL] def complete ( self , scope ) : [EOL] self . inner = self . inner . complete ( scope ) [EOL] self . name = self . inner . name + [string] [EOL] return self [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] if other . isPromise ( ) : [EOL] return False [EOL] if other . isUnion ( ) : [EOL] [comment] [EOL] return other . isDistinguishableFrom ( self ) [EOL] return ( other . isPrimitive ( ) or other . isString ( ) or other . isEnum ( ) or other . isInterface ( ) or other . isDictionary ( ) or other . isCallback ( ) or other . isRecord ( ) ) [EOL] [EOL] [EOL] class IDLRecordType ( IDLParametrizedType ) : [EOL] def __init__ ( self , location , keyType , valueType ) : [EOL] assert keyType . isString ( ) [EOL] assert keyType . isComplete ( ) [EOL] assert not valueType . isVoid ( ) [EOL] [EOL] IDLParametrizedType . __init__ ( self , location , valueType . name , valueType ) [EOL] self . keyType = keyType [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . inner . isComplete ( ) : [EOL] self . name = self . keyType . name + self . inner . name + [string] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , IDLRecordType ) and self . inner == other . inner [EOL] [EOL] def __str__ ( self ) : [EOL] return self . keyType . __str__ ( ) + self . inner . __str__ ( ) + [string] [EOL] [EOL] def prettyName ( self ) : [EOL] return [string] % ( self . keyType . prettyName ( ) , self . inner . prettyName ( ) ) [EOL] [EOL] def isRecord ( self ) : [EOL] return True [EOL] [EOL] def isJSONType ( self ) : [EOL] return self . inner . isJSONType ( ) [EOL] [EOL] def tag ( self ) : [EOL] return IDLType . Tags . record [EOL] [EOL] def complete ( self , scope ) : [EOL] self . inner = self . inner . complete ( scope ) [EOL] self . name = self . keyType . name + self . inner . name + [string] [EOL] return self [EOL] [EOL] def unroll ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return self [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] if other . isPromise ( ) : [EOL] return False [EOL] if other . isUnion ( ) : [EOL] [comment] [EOL] return other . isDistinguishableFrom ( self ) [EOL] return ( other . isPrimitive ( ) or other . isString ( ) or other . isEnum ( ) or other . isNonCallbackInterface ( ) or other . isSequence ( ) ) [EOL] [EOL] def isExposedInAllOf ( self , exposureSet ) : [EOL] return self . inner . unroll ( ) . isExposedInAllOf ( exposureSet ) [EOL] [EOL] [EOL] class IDLUnionType ( IDLType ) : [EOL] def __init__ ( self , location , memberTypes ) : [EOL] IDLType . __init__ ( self , location , [string] ) [EOL] self . memberTypes = memberTypes [EOL] self . hasNullableType = False [EOL] self . _dictionaryType = None [EOL] self . flatMemberTypes = None [EOL] self . builtin = False [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , IDLUnionType ) and self . memberTypes == other . memberTypes [EOL] [EOL] def __hash__ ( self ) : [EOL] assert self . isComplete ( ) [EOL] return self . name . __hash__ ( ) [EOL] [EOL] def prettyName ( self ) : [EOL] return [string] + [string] . join ( m . prettyName ( ) for m in self . memberTypes ) + [string] [EOL] [EOL] def isVoid ( self ) : [EOL] return False [EOL] [EOL] def isUnion ( self ) : [EOL] return True [EOL] [EOL] def isJSONType ( self ) : [EOL] return all ( m . isJSONType ( ) for m in self . memberTypes ) [EOL] [EOL] def includesRestrictedFloat ( self ) : [EOL] return any ( t . includesRestrictedFloat ( ) for t in self . memberTypes ) [EOL] [EOL] def tag ( self ) : [EOL] return IDLType . Tags . union [EOL] [EOL] def resolveType ( self , parentScope ) : [EOL] assert isinstance ( parentScope , IDLScope ) [EOL] for t in self . memberTypes : [EOL] t . resolveType ( parentScope ) [EOL] [EOL] def isComplete ( self ) : [EOL] return self . flatMemberTypes is not None [EOL] [EOL] def complete ( self , scope ) : [EOL] def typeName ( type ) : [EOL] if isinstance ( type , IDLNullableType ) : [EOL] return typeName ( type . inner ) + [string] [EOL] if isinstance ( type , IDLWrapperType ) : [EOL] return typeName ( type . _identifier . object ( ) ) [EOL] if isinstance ( type , IDLObjectWithIdentifier ) : [EOL] return typeName ( type . identifier ) [EOL] if isinstance ( type , IDLBuiltinType ) and type . hasAllowShared ( ) : [EOL] assert type . isBufferSource ( ) [EOL] return [string] + type . name [EOL] return type . name [EOL] [EOL] for ( i , type ) in enumerate ( self . memberTypes ) : [EOL] [comment] [EOL] [comment] [EOL] if not type . isComplete ( ) and not isinstance ( type , IDLTypedefType ) : [EOL] self . memberTypes [ i ] = type . complete ( scope ) [EOL] [EOL] self . name = [string] . join ( typeName ( type ) for type in self . memberTypes ) [EOL] [EOL] [comment] [EOL] for ( i , type ) in enumerate ( self . memberTypes ) : [EOL] if not type . isComplete ( ) : [EOL] self . memberTypes [ i ] = type . complete ( scope ) [EOL] [EOL] self . flatMemberTypes = list ( self . memberTypes ) [EOL] i = [number] [EOL] while i < len ( self . flatMemberTypes ) : [EOL] if self . flatMemberTypes [ i ] . nullable ( ) : [EOL] if self . hasNullableType : [EOL] raise WebIDLError ( [string] , [ nullableType . location , self . flatMemberTypes [ i ] . location ] ) [EOL] if self . hasDictionaryType ( ) : [EOL] raise WebIDLError ( [string] [string] , [ self . _dictionaryType . location , self . flatMemberTypes [ i ] . location ] ) [EOL] self . hasNullableType = True [EOL] nullableType = self . flatMemberTypes [ i ] [EOL] self . flatMemberTypes [ i ] = self . flatMemberTypes [ i ] . inner [EOL] continue [EOL] if self . flatMemberTypes [ i ] . isDictionary ( ) : [EOL] if self . hasNullableType : [EOL] raise WebIDLError ( [string] [string] , [ nullableType . location , self . flatMemberTypes [ i ] . location ] ) [EOL] self . _dictionaryType = self . flatMemberTypes [ i ] [EOL] elif self . flatMemberTypes [ i ] . isUnion ( ) : [EOL] self . flatMemberTypes [ i : i + [number] ] = self . flatMemberTypes [ i ] . memberTypes [EOL] continue [EOL] i += [number] [EOL] [EOL] for ( i , t ) in enumerate ( self . flatMemberTypes [ : - [number] ] ) : [EOL] for u in self . flatMemberTypes [ i + [number] : ] : [EOL] if not t . isDistinguishableFrom ( u ) : [EOL] raise WebIDLError ( [string] [string] + str ( t ) + [string] [string] + str ( u ) , [ self . location , t . location , u . location ] ) [EOL] [EOL] return self [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] if self . hasNullableType and other . nullable ( ) : [EOL] [comment] [EOL] return False [EOL] if other . isUnion ( ) : [EOL] otherTypes = other . unroll ( ) . memberTypes [EOL] else : [EOL] otherTypes = [ other ] [EOL] [comment] [EOL] [comment] [EOL] for u in otherTypes : [EOL] if any ( not t . isDistinguishableFrom ( u ) for t in self . memberTypes ) : [EOL] return False [EOL] return True [EOL] [EOL] def isExposedInAllOf ( self , exposureSet ) : [EOL] [comment] [EOL] for globalName in exposureSet : [EOL] if not any ( t . unroll ( ) . isExposedInAllOf ( set ( [ globalName ] ) ) for t in self . flatMemberTypes ) : [EOL] return False [EOL] return True [EOL] [EOL] def hasDictionaryType ( self ) : [EOL] return self . _dictionaryType is not None [EOL] [EOL] def hasPossiblyEmptyDictionaryType ( self ) : [EOL] return ( self . _dictionaryType is not None and self . _dictionaryType . inner . canBeEmpty ( ) ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( self . memberTypes ) [EOL] [EOL] [EOL] class IDLTypedefType ( IDLType ) : [EOL] def __init__ ( self , location , innerType , name ) : [EOL] IDLType . __init__ ( self , location , name ) [EOL] self . inner = innerType [EOL] self . builtin = False [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , IDLTypedefType ) and self . inner == other . inner [EOL] [EOL] def __str__ ( self ) : [EOL] return self . name [EOL] [EOL] def nullable ( self ) : [EOL] return self . inner . nullable ( ) [EOL] [EOL] def isPrimitive ( self ) : [EOL] return self . inner . isPrimitive ( ) [EOL] [EOL] def isBoolean ( self ) : [EOL] return self . inner . isBoolean ( ) [EOL] [EOL] def isNumeric ( self ) : [EOL] return self . inner . isNumeric ( ) [EOL] [EOL] def isString ( self ) : [EOL] return self . inner . isString ( ) [EOL] [EOL] def isByteString ( self ) : [EOL] return self . inner . isByteString ( ) [EOL] [EOL] def isDOMString ( self ) : [EOL] return self . inner . isDOMString ( ) [EOL] [EOL] def isUSVString ( self ) : [EOL] return self . inner . isUSVString ( ) [EOL] [EOL] def isUTF8String ( self ) : [EOL] return self . inner . isUTF8String ( ) [EOL] [EOL] def isJSString ( self ) : [EOL] return self . inner . isJSString ( ) [EOL] [EOL] def isVoid ( self ) : [EOL] return self . inner . isVoid ( ) [EOL] [EOL] def isJSONType ( self ) : [EOL] return self . inner . isJSONType ( ) [EOL] [EOL] def isSequence ( self ) : [EOL] return self . inner . isSequence ( ) [EOL] [EOL] def isRecord ( self ) : [EOL] return self . inner . isRecord ( ) [EOL] [EOL] def isReadableStream ( self ) : [EOL] return self . inner . isReadableStream ( ) [EOL] [EOL] def isDictionary ( self ) : [EOL] return self . inner . isDictionary ( ) [EOL] [EOL] def isArrayBuffer ( self ) : [EOL] return self . inner . isArrayBuffer ( ) [EOL] [EOL] def isArrayBufferView ( self ) : [EOL] return self . inner . isArrayBufferView ( ) [EOL] [EOL] def isTypedArray ( self ) : [EOL] return self . inner . isTypedArray ( ) [EOL] [EOL] def isInterface ( self ) : [EOL] return self . inner . isInterface ( ) [EOL] [EOL] def isCallbackInterface ( self ) : [EOL] return self . inner . isCallbackInterface ( ) [EOL] [EOL] def isNonCallbackInterface ( self ) : [EOL] return self . inner . isNonCallbackInterface ( ) [EOL] [EOL] def isComplete ( self ) : [EOL] return False [EOL] [EOL] def complete ( self , parentScope ) : [EOL] if not self . inner . isComplete ( ) : [EOL] self . inner = self . inner . complete ( parentScope ) [EOL] assert self . inner . isComplete ( ) [EOL] return self . inner [EOL] [EOL] [comment] [EOL] [EOL] def tag ( self ) : [EOL] return self . inner . tag ( ) [EOL] [EOL] def unroll ( self ) : [EOL] return self . inner . unroll ( ) [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] return self . inner . isDistinguishableFrom ( other ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return self . inner . _getDependentObjects ( ) [EOL] [EOL] def withExtendedAttributes ( self , attrs ) : [EOL] return IDLTypedefType ( self . location , self . inner . withExtendedAttributes ( attrs ) , self . name ) [EOL] [EOL] [EOL] class IDLTypedef ( IDLObjectWithIdentifier ) : [EOL] def __init__ ( self , location , parentScope , innerType , name ) : [EOL] [comment] [EOL] [comment] [EOL] self . innerType = innerType [EOL] identifier = IDLUnresolvedIdentifier ( location , name ) [EOL] IDLObjectWithIdentifier . __init__ ( self , location , parentScope , identifier ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . identifier . name , self . innerType ) [EOL] [EOL] def finish ( self , parentScope ) : [EOL] if not self . innerType . isComplete ( ) : [EOL] self . innerType = self . innerType . complete ( parentScope ) [EOL] [EOL] def validate ( self ) : [EOL] pass [EOL] [EOL] def isTypedef ( self ) : [EOL] return True [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] if len ( attrs ) != [number] : [EOL] raise WebIDLError ( [string] [string] , [ attrs [ [number] ] . location , self . location ] ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return self . innerType . _getDependentObjects ( ) [EOL] [EOL] [EOL] class IDLWrapperType ( IDLType ) : [EOL] def __init__ ( self , location , inner ) : [EOL] IDLType . __init__ ( self , location , inner . identifier . name ) [EOL] self . inner = inner [EOL] self . _identifier = inner . identifier [EOL] self . builtin = False [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , IDLWrapperType ) and self . _identifier == other . _identifier and self . builtin == other . builtin ) [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . name ) + [string] [EOL] [EOL] def nullable ( self ) : [EOL] return False [EOL] [EOL] def isPrimitive ( self ) : [EOL] return False [EOL] [EOL] def isString ( self ) : [EOL] return False [EOL] [EOL] def isByteString ( self ) : [EOL] return False [EOL] [EOL] def isDOMString ( self ) : [EOL] return False [EOL] [EOL] def isUSVString ( self ) : [EOL] return False [EOL] [EOL] def isUTF8String ( self ) : [EOL] return False [EOL] [EOL] def isJSString ( self ) : [EOL] return False [EOL] [EOL] def isVoid ( self ) : [EOL] return False [EOL] [EOL] def isSequence ( self ) : [EOL] return False [EOL] [EOL] def isDictionary ( self ) : [EOL] return isinstance ( self . inner , IDLDictionary ) [EOL] [EOL] def isInterface ( self ) : [EOL] return ( isinstance ( self . inner , IDLInterface ) or isinstance ( self . inner , IDLExternalInterface ) ) [EOL] [EOL] def isCallbackInterface ( self ) : [EOL] return self . isInterface ( ) and self . inner . isCallback ( ) [EOL] [EOL] def isNonCallbackInterface ( self ) : [EOL] return self . isInterface ( ) and not self . inner . isCallback ( ) [EOL] [EOL] def isEnum ( self ) : [EOL] return isinstance ( self . inner , IDLEnum ) [EOL] [EOL] def isJSONType ( self ) : [EOL] if self . isInterface ( ) : [EOL] if self . inner . isExternal ( ) : [EOL] return False [EOL] iface = self . inner [EOL] while iface : [EOL] if any ( m . isMethod ( ) and m . isToJSON ( ) for m in iface . members ) : [EOL] return True [EOL] iface = iface . parent [EOL] return False [EOL] elif self . isEnum ( ) : [EOL] return True [EOL] elif self . isDictionary ( ) : [EOL] dictionary = self . inner [EOL] while dictionary : [EOL] if not all ( m . type . isJSONType ( ) for m in dictionary . members ) : [EOL] return False [EOL] dictionary = dictionary . parent [EOL] return True [EOL] else : [EOL] raise WebIDLError ( [string] [string] % type ( self . inner ) , [ self . location ] ) [EOL] [EOL] def resolveType ( self , parentScope ) : [EOL] assert isinstance ( parentScope , IDLScope ) [EOL] self . inner . resolve ( parentScope ) [EOL] [EOL] def isComplete ( self ) : [EOL] return True [EOL] [EOL] def tag ( self ) : [EOL] if self . isInterface ( ) : [EOL] return IDLType . Tags . interface [EOL] elif self . isEnum ( ) : [EOL] return IDLType . Tags . enum [EOL] elif self . isDictionary ( ) : [EOL] return IDLType . Tags . dictionary [EOL] else : [EOL] assert False [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] if other . isPromise ( ) : [EOL] return False [EOL] if other . isUnion ( ) : [EOL] [comment] [EOL] return other . isDistinguishableFrom ( self ) [EOL] assert self . isInterface ( ) or self . isEnum ( ) or self . isDictionary ( ) [EOL] if self . isEnum ( ) : [EOL] return ( other . isPrimitive ( ) or other . isInterface ( ) or other . isObject ( ) or other . isCallback ( ) or other . isDictionary ( ) or other . isSequence ( ) or other . isRecord ( ) ) [EOL] if self . isDictionary ( ) and other . nullable ( ) : [EOL] return False [EOL] if ( other . isPrimitive ( ) or other . isString ( ) or other . isEnum ( ) or other . isSequence ( ) ) : [EOL] return True [EOL] if self . isDictionary ( ) : [EOL] return other . isNonCallbackInterface ( ) [EOL] [EOL] assert self . isInterface ( ) [EOL] if other . isInterface ( ) : [EOL] if other . isSpiderMonkeyInterface ( ) : [EOL] [comment] [EOL] return other . isDistinguishableFrom ( self ) [EOL] assert self . isGeckoInterface ( ) and other . isGeckoInterface ( ) [EOL] if self . inner . isExternal ( ) or other . unroll ( ) . inner . isExternal ( ) : [EOL] return self != other [EOL] return ( len ( self . inner . interfacesBasedOnSelf & other . unroll ( ) . inner . interfacesBasedOnSelf ) == [number] and ( self . isNonCallbackInterface ( ) or other . isNonCallbackInterface ( ) ) ) [EOL] if ( other . isDictionary ( ) or other . isCallback ( ) or other . isRecord ( ) ) : [EOL] return self . isNonCallbackInterface ( ) [EOL] [EOL] [comment] [EOL] assert other . isObject ( ) [EOL] return False [EOL] [EOL] def isExposedInAllOf ( self , exposureSet ) : [EOL] if not self . isInterface ( ) : [EOL] return True [EOL] iface = self . inner [EOL] if iface . isExternal ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return True [EOL] return iface . exposureSet . issuperset ( exposureSet ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . isDictionary ( ) : [EOL] return set ( [ self . inner ] ) [EOL] return set ( ) [EOL] [EOL] [EOL] class IDLPromiseType ( IDLParametrizedType ) : [EOL] def __init__ ( self , location , innerType ) : [EOL] IDLParametrizedType . __init__ ( self , location , [string] , innerType ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , IDLPromiseType ) and self . promiseInnerType ( ) == other . promiseInnerType ( ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . inner . __str__ ( ) + [string] [EOL] [EOL] def prettyName ( self ) : [EOL] return [string] % self . inner . prettyName ( ) [EOL] [EOL] def isPromise ( self ) : [EOL] return True [EOL] [EOL] def promiseInnerType ( self ) : [EOL] return self . inner [EOL] [EOL] def tag ( self ) : [EOL] return IDLType . Tags . promise [EOL] [EOL] def complete ( self , scope ) : [EOL] self . inner = self . promiseInnerType ( ) . complete ( scope ) [EOL] return self [EOL] [EOL] def unroll ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return self [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] [comment] [EOL] return False [EOL] [EOL] def isExposedInAllOf ( self , exposureSet ) : [EOL] [comment] [EOL] return self . promiseInnerType ( ) . unroll ( ) . isExposedInAllOf ( exposureSet ) [EOL] [EOL] [EOL] class IDLBuiltinType ( IDLType ) : [EOL] [EOL] Types = enum ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] TagLookup = { Types . byte : IDLType . Tags . int8 , Types . octet : IDLType . Tags . uint8 , Types . short : IDLType . Tags . int16 , Types . unsigned_short : IDLType . Tags . uint16 , Types . long : IDLType . Tags . int32 , Types . unsigned_long : IDLType . Tags . uint32 , Types . long_long : IDLType . Tags . int64 , Types . unsigned_long_long : IDLType . Tags . uint64 , Types . boolean : IDLType . Tags . bool , Types . unrestricted_float : IDLType . Tags . unrestricted_float , Types . float : IDLType . Tags . float , Types . unrestricted_double : IDLType . Tags . unrestricted_double , Types . double : IDLType . Tags . double , Types . any : IDLType . Tags . any , Types . domstring : IDLType . Tags . domstring , Types . bytestring : IDLType . Tags . bytestring , Types . usvstring : IDLType . Tags . usvstring , Types . utf8string : IDLType . Tags . utf8string , Types . jsstring : IDLType . Tags . jsstring , Types . object : IDLType . Tags . object , Types . void : IDLType . Tags . void , Types . ArrayBuffer : IDLType . Tags . interface , Types . ArrayBufferView : IDLType . Tags . interface , Types . Int8Array : IDLType . Tags . interface , Types . Uint8Array : IDLType . Tags . interface , Types . Uint8ClampedArray : IDLType . Tags . interface , Types . Int16Array : IDLType . Tags . interface , Types . Uint16Array : IDLType . Tags . interface , Types . Int32Array : IDLType . Tags . interface , Types . Uint32Array : IDLType . Tags . interface , Types . Float32Array : IDLType . Tags . interface , Types . Float64Array : IDLType . Tags . interface , Types . ReadableStream : IDLType . Tags . interface , } [EOL] [EOL] PrettyNames = { Types . byte : [string] , Types . octet : [string] , Types . short : [string] , Types . unsigned_short : [string] , Types . long : [string] , Types . unsigned_long : [string] , Types . long_long : [string] , Types . unsigned_long_long : [string] , Types . boolean : [string] , Types . unrestricted_float : [string] , Types . float : [string] , Types . unrestricted_double : [string] , Types . double : [string] , Types . any : [string] , Types . domstring : [string] , Types . bytestring : [string] , Types . usvstring : [string] , Types . utf8string : [string] , Types . jsstring : [string] , Types . object : [string] , Types . void : [string] , Types . ArrayBuffer : [string] , Types . ArrayBufferView : [string] , Types . Int8Array : [string] , Types . Uint8Array : [string] , Types . Uint8ClampedArray : [string] , Types . Int16Array : [string] , Types . Uint16Array : [string] , Types . Int32Array : [string] , Types . Uint32Array : [string] , Types . Float32Array : [string] , Types . Float64Array : [string] , Types . ReadableStream : [string] , } [EOL] [EOL] def __init__ ( self , location , name , type , clamp = False , enforceRange = False , treatNullAsEmpty = False , allowShared = False , attrLocation = [ ] ) : [EOL] [docstring] [EOL] IDLType . __init__ ( self , location , name ) [EOL] self . builtin = True [EOL] self . _typeTag = type [EOL] self . _clamped = None [EOL] self . _rangeEnforced = None [EOL] self . _withTreatNullAs = None [EOL] self . _withAllowShared = None ; [EOL] if self . isInteger ( ) : [EOL] if clamp : [EOL] self . _clamp = True [EOL] self . name = [string] + self . name [EOL] self . _extendedAttrDict [ [string] ] = True [EOL] elif enforceRange : [EOL] self . _enforceRange = True [EOL] self . name = [string] + self . name [EOL] self . _extendedAttrDict [ [string] ] = True [EOL] elif clamp or enforceRange : [EOL] raise WebIDLError ( [string] , attrLocation ) [EOL] if self . isDOMString ( ) or self . isUTF8String ( ) : [EOL] if treatNullAsEmpty : [EOL] self . treatNullAsEmpty = True [EOL] self . name = [string] + self . name [EOL] self . _extendedAttrDict [ [string] ] = [ [string] ] [EOL] elif treatNullAsEmpty : [EOL] raise WebIDLError ( [string] , attrLocation ) [EOL] if self . isBufferSource ( ) : [EOL] if allowShared : [EOL] self . _allowShared = True [EOL] self . _extendedAttrDict [ [string] ] = True [EOL] elif allowShared : [EOL] raise WebIDLError ( [string] , attrLocation ) [EOL] [EOL] def __str__ ( self ) : [EOL] if self . _allowShared : [EOL] assert self . isBufferSource ( ) [EOL] return [string] + str ( self . name ) [EOL] return str ( self . name ) [EOL] [EOL] def prettyName ( self ) : [EOL] return IDLBuiltinType . PrettyNames [ self . _typeTag ] [EOL] [EOL] def clamped ( self , attrLocation ) : [EOL] if not self . _clamped : [EOL] self . _clamped = IDLBuiltinType ( self . location , self . name , self . _typeTag , clamp = True , attrLocation = attrLocation ) [EOL] return self . _clamped [EOL] [EOL] def rangeEnforced ( self , attrLocation ) : [EOL] if not self . _rangeEnforced : [EOL] self . _rangeEnforced = IDLBuiltinType ( self . location , self . name , self . _typeTag , enforceRange = True , attrLocation = attrLocation ) [EOL] return self . _rangeEnforced [EOL] [EOL] def withTreatNullAs ( self , attrLocation ) : [EOL] if not self . _withTreatNullAs : [EOL] self . _withTreatNullAs = IDLBuiltinType ( self . location , self . name , self . _typeTag , treatNullAsEmpty = True , attrLocation = attrLocation ) [EOL] return self . _withTreatNullAs [EOL] [EOL] def withAllowShared ( self , attrLocation ) : [EOL] if not self . _withAllowShared : [EOL] self . _withAllowShared = IDLBuiltinType ( self . location , self . name , self . _typeTag , allowShared = True , attrLocation = attrLocation ) [EOL] return self . _withAllowShared [EOL] [EOL] def isPrimitive ( self ) : [EOL] return self . _typeTag <= IDLBuiltinType . Types . double [EOL] [EOL] def isBoolean ( self ) : [EOL] return self . _typeTag == IDLBuiltinType . Types . boolean [EOL] [EOL] def isNumeric ( self ) : [EOL] return self . isPrimitive ( ) and not self . isBoolean ( ) [EOL] [EOL] def isString ( self ) : [EOL] return ( self . _typeTag == IDLBuiltinType . Types . domstring or self . _typeTag == IDLBuiltinType . Types . bytestring or self . _typeTag == IDLBuiltinType . Types . usvstring or self . _typeTag == IDLBuiltinType . Types . utf8string or self . _typeTag == IDLBuiltinType . Types . jsstring ) [EOL] [EOL] def isByteString ( self ) : [EOL] return self . _typeTag == IDLBuiltinType . Types . bytestring [EOL] [EOL] def isDOMString ( self ) : [EOL] return self . _typeTag == IDLBuiltinType . Types . domstring [EOL] [EOL] def isUSVString ( self ) : [EOL] return self . _typeTag == IDLBuiltinType . Types . usvstring [EOL] [EOL] def isUTF8String ( self ) : [EOL] return self . _typeTag == IDLBuiltinType . Types . utf8string [EOL] [EOL] def isJSString ( self ) : [EOL] return self . _typeTag == IDLBuiltinType . Types . jsstring [EOL] [EOL] def isInteger ( self ) : [EOL] return self . _typeTag <= IDLBuiltinType . Types . unsigned_long_long [EOL] [EOL] def isArrayBuffer ( self ) : [EOL] return self . _typeTag == IDLBuiltinType . Types . ArrayBuffer [EOL] [EOL] def isArrayBufferView ( self ) : [EOL] return self . _typeTag == IDLBuiltinType . Types . ArrayBufferView [EOL] [EOL] def isTypedArray ( self ) : [EOL] return ( self . _typeTag >= IDLBuiltinType . Types . Int8Array and self . _typeTag <= IDLBuiltinType . Types . Float64Array ) [EOL] [EOL] def isReadableStream ( self ) : [EOL] return self . _typeTag == IDLBuiltinType . Types . ReadableStream [EOL] [EOL] def isInterface ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return ( self . isArrayBuffer ( ) or self . isArrayBufferView ( ) or self . isTypedArray ( ) or self . isReadableStream ( ) ) [EOL] [EOL] def isNonCallbackInterface ( self ) : [EOL] [comment] [EOL] return self . isInterface ( ) [EOL] [EOL] def isFloat ( self ) : [EOL] return ( self . _typeTag == IDLBuiltinType . Types . float or self . _typeTag == IDLBuiltinType . Types . double or self . _typeTag == IDLBuiltinType . Types . unrestricted_float or self . _typeTag == IDLBuiltinType . Types . unrestricted_double ) [EOL] [EOL] def isUnrestricted ( self ) : [EOL] assert self . isFloat ( ) [EOL] return ( self . _typeTag == IDLBuiltinType . Types . unrestricted_float or self . _typeTag == IDLBuiltinType . Types . unrestricted_double ) [EOL] [EOL] def isJSONType ( self ) : [EOL] return self . isPrimitive ( ) or self . isString ( ) or self . isObject ( ) [EOL] [EOL] def includesRestrictedFloat ( self ) : [EOL] return self . isFloat ( ) and not self . isUnrestricted ( ) [EOL] [EOL] def tag ( self ) : [EOL] return IDLBuiltinType . TagLookup [ self . _typeTag ] [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] if other . isPromise ( ) : [EOL] return False [EOL] if other . isUnion ( ) : [EOL] [comment] [EOL] return other . isDistinguishableFrom ( self ) [EOL] if self . isBoolean ( ) : [EOL] return ( other . isNumeric ( ) or other . isString ( ) or other . isEnum ( ) or other . isInterface ( ) or other . isObject ( ) or other . isCallback ( ) or other . isDictionary ( ) or other . isSequence ( ) or other . isRecord ( ) ) [EOL] if self . isNumeric ( ) : [EOL] return ( other . isBoolean ( ) or other . isString ( ) or other . isEnum ( ) or other . isInterface ( ) or other . isObject ( ) or other . isCallback ( ) or other . isDictionary ( ) or other . isSequence ( ) or other . isRecord ( ) ) [EOL] if self . isString ( ) : [EOL] return ( other . isPrimitive ( ) or other . isInterface ( ) or other . isObject ( ) or other . isCallback ( ) or other . isDictionary ( ) or other . isSequence ( ) or other . isRecord ( ) ) [EOL] if self . isAny ( ) : [EOL] [comment] [EOL] return False [EOL] if self . isObject ( ) : [EOL] return other . isPrimitive ( ) or other . isString ( ) or other . isEnum ( ) [EOL] if self . isVoid ( ) : [EOL] return not other . isVoid ( ) [EOL] [comment] [EOL] assert self . isSpiderMonkeyInterface ( ) [EOL] [comment] [EOL] return ( other . isPrimitive ( ) or other . isString ( ) or other . isEnum ( ) or other . isCallback ( ) or other . isDictionary ( ) or other . isSequence ( ) or other . isRecord ( ) or ( other . isInterface ( ) and ( ( self . isArrayBuffer ( ) and not other . isArrayBuffer ( ) ) or ( self . isReadableStream ( ) and not other . isReadableStream ( ) ) or ( self . isArrayBufferView ( ) and not other . isArrayBufferView ( ) and not other . isTypedArray ( ) ) or ( self . isTypedArray ( ) and not other . isArrayBufferView ( ) and not ( other . isTypedArray ( ) and other . name == self . name ) ) ) ) ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( ) [EOL] [EOL] def withExtendedAttributes ( self , attrs ) : [EOL] ret = self [EOL] for attribute in attrs : [EOL] identifier = attribute . identifier ( ) [EOL] if identifier == [string] : [EOL] if not attribute . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attribute . location ] ) [EOL] if ret . hasEnforceRange ( ) or self . _enforceRange : [EOL] raise WebIDLError ( [string] , [ self . location , attribute . location ] ) [EOL] ret = self . clamped ( [ self . location , attribute . location ] ) [EOL] elif identifier == [string] : [EOL] if not attribute . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attribute . location ] ) [EOL] if ret . hasClamp ( ) or self . _clamp : [EOL] raise WebIDLError ( [string] , [ self . location , attribute . location ] ) [EOL] ret = self . rangeEnforced ( [ self . location , attribute . location ] ) [EOL] elif identifier == [string] : [EOL] if not ( self . isDOMString ( ) or self . isUTF8String ( ) ) : [EOL] raise WebIDLError ( [string] , [ self . location , attribute . location ] ) [EOL] assert not self . nullable ( ) [EOL] if not attribute . hasValue ( ) : [EOL] raise WebIDLError ( [string] , [ attribute . location ] ) [EOL] value = attribute . value ( ) [EOL] if value != [string] : [EOL] raise WebIDLError ( [string] [string] % value , [ attribute . location ] ) [EOL] ret = self . withTreatNullAs ( [ self . location , attribute . location ] ) [EOL] elif identifier == [string] : [EOL] if not attribute . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attribute . location ] ) [EOL] if not self . isBufferSource ( ) : [EOL] raise WebIDLError ( [string] , [ self . location , attribute . location ] ) [EOL] ret = self . withAllowShared ( [ self . location , attribute . location ] ) [EOL] [EOL] else : [EOL] raise WebIDLError ( [string] , [ self . location , attribute . location ] ) [EOL] return ret [EOL] [EOL] BuiltinTypes = { IDLBuiltinType . Types . byte : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . byte ) , IDLBuiltinType . Types . octet : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . octet ) , IDLBuiltinType . Types . short : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . short ) , IDLBuiltinType . Types . unsigned_short : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . unsigned_short ) , IDLBuiltinType . Types . long : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . long ) , IDLBuiltinType . Types . unsigned_long : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . unsigned_long ) , IDLBuiltinType . Types . long_long : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . long_long ) , IDLBuiltinType . Types . unsigned_long_long : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . unsigned_long_long ) , IDLBuiltinType . Types . boolean : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . boolean ) , IDLBuiltinType . Types . float : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . float ) , IDLBuiltinType . Types . unrestricted_float : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . unrestricted_float ) , IDLBuiltinType . Types . double : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . double ) , IDLBuiltinType . Types . unrestricted_double : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . unrestricted_double ) , IDLBuiltinType . Types . any : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . any ) , IDLBuiltinType . Types . domstring : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . domstring ) , IDLBuiltinType . Types . bytestring : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . bytestring ) , IDLBuiltinType . Types . usvstring : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . usvstring ) , IDLBuiltinType . Types . utf8string : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . utf8string ) , IDLBuiltinType . Types . jsstring : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . jsstring ) , IDLBuiltinType . Types . object : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . object ) , IDLBuiltinType . Types . void : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . void ) , IDLBuiltinType . Types . ArrayBuffer : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . ArrayBuffer ) , IDLBuiltinType . Types . ArrayBufferView : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . ArrayBufferView ) , IDLBuiltinType . Types . Int8Array : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . Int8Array ) , IDLBuiltinType . Types . Uint8Array : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . Uint8Array ) , IDLBuiltinType . Types . Uint8ClampedArray : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . Uint8ClampedArray ) , IDLBuiltinType . Types . Int16Array : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . Int16Array ) , IDLBuiltinType . Types . Uint16Array : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . Uint16Array ) , IDLBuiltinType . Types . Int32Array : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . Int32Array ) , IDLBuiltinType . Types . Uint32Array : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . Uint32Array ) , IDLBuiltinType . Types . Float32Array : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . Float32Array ) , IDLBuiltinType . Types . Float64Array : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . Float64Array ) , IDLBuiltinType . Types . ReadableStream : IDLBuiltinType ( BuiltinLocation ( [string] ) , [string] , IDLBuiltinType . Types . ReadableStream ) , } [EOL] [EOL] [EOL] integerTypeSizes = { IDLBuiltinType . Types . byte : ( - [number] , [number] ) , IDLBuiltinType . Types . octet : ( [number] , [number] ) , IDLBuiltinType . Types . short : ( - [number] , [number] ) , IDLBuiltinType . Types . unsigned_short : ( [number] , [number] ) , IDLBuiltinType . Types . long : ( - [number] , [number] ) , IDLBuiltinType . Types . unsigned_long : ( [number] , [number] ) , IDLBuiltinType . Types . long_long : ( - [number] , [number] ) , IDLBuiltinType . Types . unsigned_long_long : ( [number] , [number] ) } [EOL] [EOL] [EOL] def matchIntegerValueToType ( value ) : [EOL] for type , extremes in integerTypeSizes . items ( ) : [EOL] ( min , max ) = extremes [EOL] if value <= max and value >= min : [EOL] return BuiltinTypes [ type ] [EOL] [EOL] return None [EOL] [EOL] class NoCoercionFoundError ( WebIDLError ) : [EOL] [docstring] [EOL] [EOL] class IDLValue ( IDLObject ) : [EOL] def __init__ ( self , location , type , value ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] self . type = type [EOL] assert isinstance ( type , IDLType ) [EOL] [EOL] self . value = value [EOL] [EOL] def coerceToType ( self , type , location ) : [EOL] if type == self . type : [EOL] return self [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if type . isUnion ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for subtype in type . unroll ( ) . flatMemberTypes : [EOL] try : [EOL] coercedValue = self . coerceToType ( subtype , location ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return IDLValue ( self . location , subtype , coercedValue . value ) [EOL] except Exception as e : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( isinstance ( e , WebIDLError ) and not isinstance ( e , NoCoercionFoundError ) ) : [EOL] raise e [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] elif type . nullable ( ) and not type . isEnum ( ) : [EOL] innerValue = self . coerceToType ( type . inner , location ) [EOL] return IDLValue ( self . location , type , innerValue . value ) [EOL] [EOL] elif self . type . isInteger ( ) and type . isInteger ( ) : [EOL] [comment] [EOL] [EOL] ( min , max ) = integerTypeSizes [ type . _typeTag ] [EOL] if self . value <= max and self . value >= min : [EOL] [comment] [EOL] return IDLValue ( self . location , type , self . value ) [EOL] else : [EOL] raise WebIDLError ( [string] % ( self . value , type ) , [ location ] ) [EOL] elif self . type . isInteger ( ) and type . isFloat ( ) : [EOL] [comment] [EOL] if - [number] ** [number] <= self . value <= [number] ** [number] : [EOL] return IDLValue ( self . location , type , float ( self . value ) ) [EOL] else : [EOL] raise WebIDLError ( [string] % ( self . value , type ) , [ location ] ) [EOL] elif self . type . isString ( ) and type . isEnum ( ) : [EOL] [comment] [EOL] enum = type . unroll ( ) . inner [EOL] if self . value not in enum . values ( ) : [EOL] raise WebIDLError ( [string] % ( self . value , enum . identifier . name ) , [ location , enum . location ] ) [EOL] return self [EOL] elif self . type . isFloat ( ) and type . isFloat ( ) : [EOL] if ( not type . isUnrestricted ( ) and ( self . value == float ( [string] ) or self . value == float ( [string] ) or math . isnan ( self . value ) ) ) : [EOL] raise WebIDLError ( [string] % self . value , [ location ] ) [EOL] return IDLValue ( self . location , type , self . value ) [EOL] elif self . type . isString ( ) and type . isUSVString ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert self . type . isDOMString ( ) [EOL] return self [EOL] elif self . type . isDOMString ( ) and type . treatNullAsEmpty : [EOL] [comment] [EOL] [comment] [EOL] return self [EOL] elif self . type . isString ( ) and ( type . isByteString ( ) or type . isJSString ( ) or type . isUTF8String ( ) ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] valid_ascii_lit = [string] + string . ascii_letters + string . digits + string . punctuation [EOL] for idx , c in enumerate ( self . value ) : [EOL] if c not in valid_ascii_lit : [EOL] raise WebIDLError ( [string] [string] % ( self . value . __repr__ ( ) , ord ( c ) , idx ) , [ location ] ) [EOL] [EOL] return IDLValue ( self . location , type , self . value ) [EOL] [EOL] raise NoCoercionFoundError ( [string] % ( self . type , type ) , [ location ] ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( ) [EOL] [EOL] [EOL] class IDLNullValue ( IDLObject ) : [EOL] def __init__ ( self , location ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] self . type = None [EOL] self . value = None [EOL] [EOL] def coerceToType ( self , type , location ) : [EOL] if ( not isinstance ( type , IDLNullableType ) and not ( type . isUnion ( ) and type . hasNullableType ) and not type . isAny ( ) ) : [EOL] raise WebIDLError ( [string] % type , [ location ] ) [EOL] [EOL] nullValue = IDLNullValue ( self . location ) [EOL] if type . isUnion ( ) and not type . nullable ( ) and type . hasDictionaryType ( ) : [EOL] [comment] [EOL] [comment] [EOL] for t in type . flatMemberTypes : [EOL] if t . isDictionary ( ) : [EOL] nullValue . type = t [EOL] return nullValue [EOL] nullValue . type = type [EOL] return nullValue [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( ) [EOL] [EOL] [EOL] class IDLEmptySequenceValue ( IDLObject ) : [EOL] def __init__ ( self , location ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] self . type = None [EOL] self . value = None [EOL] [EOL] def coerceToType ( self , type , location ) : [EOL] if type . isUnion ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for subtype in type . unroll ( ) . flatMemberTypes : [EOL] try : [EOL] return self . coerceToType ( subtype , location ) [EOL] except : [EOL] pass [EOL] [EOL] if not type . isSequence ( ) : [EOL] raise WebIDLError ( [string] % type , [ location ] ) [EOL] [EOL] emptySequenceValue = IDLEmptySequenceValue ( self . location ) [EOL] emptySequenceValue . type = type [EOL] return emptySequenceValue [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( ) [EOL] [EOL] [EOL] class IDLDefaultDictionaryValue ( IDLObject ) : [EOL] def __init__ ( self , location ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] self . type = None [EOL] self . value = None [EOL] [EOL] def coerceToType ( self , type , location ) : [EOL] if type . isUnion ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for subtype in type . unroll ( ) . flatMemberTypes : [EOL] try : [EOL] return self . coerceToType ( subtype , location ) [EOL] except : [EOL] pass [EOL] [EOL] if not type . isDictionary ( ) : [EOL] raise WebIDLError ( [string] % type , [ location ] ) [EOL] [EOL] defaultDictionaryValue = IDLDefaultDictionaryValue ( self . location ) [EOL] defaultDictionaryValue . type = type [EOL] return defaultDictionaryValue [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( ) [EOL] [EOL] [EOL] class IDLUndefinedValue ( IDLObject ) : [EOL] def __init__ ( self , location ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] self . type = None [EOL] self . value = None [EOL] [EOL] def coerceToType ( self , type , location ) : [EOL] if not type . isAny ( ) : [EOL] raise WebIDLError ( [string] % type , [ location ] ) [EOL] [EOL] undefinedValue = IDLUndefinedValue ( self . location ) [EOL] undefinedValue . type = type [EOL] return undefinedValue [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( ) [EOL] [EOL] [EOL] class IDLInterfaceMember ( IDLObjectWithIdentifier , IDLExposureMixins ) : [EOL] [EOL] Tags = enum ( [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] Special = enum ( [string] , [string] ) [EOL] [EOL] AffectsValues = ( [string] , [string] ) [EOL] DependsOnValues = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , location , identifier , tag , extendedAttrDict = None ) : [EOL] IDLObjectWithIdentifier . __init__ ( self , location , None , identifier ) [EOL] IDLExposureMixins . __init__ ( self , location ) [EOL] self . tag = tag [EOL] if extendedAttrDict is None : [EOL] self . _extendedAttrDict = { } [EOL] else : [EOL] self . _extendedAttrDict = extendedAttrDict [EOL] [EOL] def isMethod ( self ) : [EOL] return self . tag == IDLInterfaceMember . Tags . Method [EOL] [EOL] def isAttr ( self ) : [EOL] return self . tag == IDLInterfaceMember . Tags . Attr [EOL] [EOL] def isConst ( self ) : [EOL] return self . tag == IDLInterfaceMember . Tags . Const [EOL] [EOL] def isMaplikeOrSetlikeOrIterable ( self ) : [EOL] return ( self . tag == IDLInterfaceMember . Tags . MaplikeOrSetlike or self . tag == IDLInterfaceMember . Tags . Iterable ) [EOL] [EOL] def isMaplikeOrSetlike ( self ) : [EOL] return self . tag == IDLInterfaceMember . Tags . MaplikeOrSetlike [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] for attr in attrs : [EOL] self . handleExtendedAttribute ( attr ) [EOL] attrlist = attr . listValue ( ) [EOL] self . _extendedAttrDict [ attr . identifier ( ) ] = attrlist if len ( attrlist ) else True [EOL] [EOL] def handleExtendedAttribute ( self , attr ) : [EOL] pass [EOL] [EOL] def getExtendedAttribute ( self , name ) : [EOL] return self . _extendedAttrDict . get ( name , None ) [EOL] [EOL] def finish ( self , scope ) : [EOL] IDLExposureMixins . finish ( self , scope ) [EOL] [EOL] def validate ( self ) : [EOL] if self . isAttr ( ) or self . isMethod ( ) : [EOL] if self . affects == [string] and self . dependsOn != [string] : [EOL] raise WebIDLError ( [string] [string] [string] , [ self . location ] ) [EOL] [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] if self . dependsOn == [string] or self . dependsOn == [string] : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] if ( self . getExtendedAttribute ( [string] ) or self . getExtendedAttribute ( [string] ) ) : [EOL] raise WebIDLError ( [string] [string] [string] [string] [string] , [ self . location ] ) [EOL] [EOL] def _setDependsOn ( self , dependsOn ) : [EOL] if self . dependsOn != [string] : [EOL] raise WebIDLError ( [string] [string] [string] , [ self . location ] ) [EOL] if dependsOn not in IDLInterfaceMember . DependsOnValues : [EOL] raise WebIDLError ( [string] % dependsOn , [ self . location ] ) [EOL] self . dependsOn = dependsOn [EOL] [EOL] def _setAffects ( self , affects ) : [EOL] if self . affects != [string] : [EOL] raise WebIDLError ( [string] [string] [string] , [ self . location ] ) [EOL] if affects not in IDLInterfaceMember . AffectsValues : [EOL] raise WebIDLError ( [string] % dependsOn , [ self . location ] ) [EOL] self . affects = affects [EOL] [EOL] def _addAlias ( self , alias ) : [EOL] if alias in self . aliases : [EOL] raise WebIDLError ( [string] % alias , [ self . location ] ) [EOL] self . aliases . append ( alias ) [EOL] [EOL] def _addBindingAlias ( self , bindingAlias ) : [EOL] if bindingAlias in self . bindingAliases : [EOL] raise WebIDLError ( [string] % bindingAlias , [ self . location ] ) [EOL] self . bindingAliases . append ( bindingAlias ) [EOL] [EOL] class IDLMaplikeOrSetlikeOrIterableBase ( IDLInterfaceMember ) : [EOL] [EOL] def __init__ ( self , location , identifier , ifaceType , keyType , valueType , ifaceKind ) : [EOL] IDLInterfaceMember . __init__ ( self , location , identifier , ifaceKind ) [EOL] if keyType is not None : [EOL] assert isinstance ( keyType , IDLType ) [EOL] else : [EOL] assert valueType is not None [EOL] assert ifaceType in [ [string] , [string] , [string] ] [EOL] if valueType is not None : [EOL] assert isinstance ( valueType , IDLType ) [EOL] self . keyType = keyType [EOL] self . valueType = valueType [EOL] self . maplikeOrSetlikeOrIterableType = ifaceType [EOL] self . disallowedMemberNames = [ ] [EOL] self . disallowedNonMethodNames = [ ] [EOL] [EOL] def isMaplike ( self ) : [EOL] return self . maplikeOrSetlikeOrIterableType == [string] [EOL] [EOL] def isSetlike ( self ) : [EOL] return self . maplikeOrSetlikeOrIterableType == [string] [EOL] [EOL] def isIterable ( self ) : [EOL] return self . maplikeOrSetlikeOrIterableType == [string] [EOL] [EOL] def hasKeyType ( self ) : [EOL] return self . keyType is not None [EOL] [EOL] def hasValueType ( self ) : [EOL] return self . valueType is not None [EOL] [EOL] def checkCollisions ( self , members , isAncestor ) : [EOL] for member in members : [EOL] [comment] [EOL] if ( member . identifier . name in self . disallowedMemberNames and not ( ( member . isMethod ( ) and member . isMaplikeOrSetlikeOrIterableMethod ( ) ) or ( member . isAttr ( ) and member . isMaplikeOrSetlikeAttr ( ) ) ) ) : [EOL] raise WebIDLError ( [string] [string] % ( member . identifier . name , self . maplikeOrSetlikeOrIterableType ) , [ self . location , member . location ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( ( isAncestor or member . isAttr ( ) or member . isConst ( ) ) and member . identifier . name in self . disallowedNonMethodNames ) : [EOL] raise WebIDLError ( [string] [string] % ( member . identifier . name , self . maplikeOrSetlikeOrIterableType ) , [ self . location , member . location ] ) [EOL] [EOL] def addMethod ( self , name , members , allowExistingOperations , returnType , args = [ ] , chromeOnly = False , isPure = False , affectsNothing = False , newObject = False , isIteratorAlias = False ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if chromeOnly : [EOL] name = [string] + name [EOL] else : [EOL] if not allowExistingOperations : [EOL] self . disallowedMemberNames . append ( name ) [EOL] else : [EOL] self . disallowedNonMethodNames . append ( name ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if allowExistingOperations : [EOL] for m in members : [EOL] if m . identifier . name == name and m . isMethod ( ) and not m . isStatic ( ) : [EOL] return [EOL] method = IDLMethod ( self . location , IDLUnresolvedIdentifier ( self . location , name , allowDoubleUnderscore = chromeOnly ) , returnType , args , maplikeOrSetlikeOrIterable = self ) [EOL] [comment] [EOL] method . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( [string] , ) ) ] ) [EOL] if chromeOnly : [EOL] method . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( [string] , ) ) ] ) [EOL] if isPure : [EOL] method . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( [string] , ) ) ] ) [EOL] [comment] [EOL] [comment] [EOL] if affectsNothing : [EOL] method . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( [string] , [string] ) ) , IDLExtendedAttribute ( self . location , ( [string] , [string] ) ) ] ) [EOL] if newObject : [EOL] method . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( [string] , ) ) ] ) [EOL] if isIteratorAlias : [EOL] method . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( [string] , [string] ) ) ] ) [EOL] [comment] [EOL] [comment] [EOL] if not self . isIterable ( ) : [EOL] method . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( [string] , ) ) ] ) [EOL] members . append ( method ) [EOL] [EOL] def resolve ( self , parentScope ) : [EOL] if self . keyType : [EOL] self . keyType . resolveType ( parentScope ) [EOL] if self . valueType : [EOL] self . valueType . resolveType ( parentScope ) [EOL] [EOL] def finish ( self , scope ) : [EOL] IDLInterfaceMember . finish ( self , scope ) [EOL] if self . keyType and not self . keyType . isComplete ( ) : [EOL] t = self . keyType . complete ( scope ) [EOL] [EOL] assert not isinstance ( t , IDLUnresolvedType ) [EOL] assert not isinstance ( t , IDLTypedefType ) [EOL] assert not isinstance ( t . name , IDLUnresolvedIdentifier ) [EOL] self . keyType = t [EOL] if self . valueType and not self . valueType . isComplete ( ) : [EOL] t = self . valueType . complete ( scope ) [EOL] [EOL] assert not isinstance ( t , IDLUnresolvedType ) [EOL] assert not isinstance ( t , IDLTypedefType ) [EOL] assert not isinstance ( t . name , IDLUnresolvedIdentifier ) [EOL] self . valueType = t [EOL] [EOL] def validate ( self ) : [EOL] IDLInterfaceMember . validate ( self ) [EOL] [EOL] def handleExtendedAttribute ( self , attr ) : [EOL] IDLInterfaceMember . handleExtendedAttribute ( self , attr ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] deps = set ( ) [EOL] if self . keyType : [EOL] deps . add ( self . keyType ) [EOL] if self . valueType : [EOL] deps . add ( self . valueType ) [EOL] return deps [EOL] [EOL] def getForEachArguments ( self ) : [EOL] return [ IDLArgument ( self . location , IDLUnresolvedIdentifier ( BuiltinLocation ( [string] ) , [string] ) , BuiltinTypes [ IDLBuiltinType . Types . object ] ) , IDLArgument ( self . location , IDLUnresolvedIdentifier ( BuiltinLocation ( [string] ) , [string] ) , BuiltinTypes [ IDLBuiltinType . Types . any ] , optional = True ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class IDLIterable ( IDLMaplikeOrSetlikeOrIterableBase ) : [EOL] [EOL] def __init__ ( self , location , identifier , keyType , valueType = None , scope = None ) : [EOL] IDLMaplikeOrSetlikeOrIterableBase . __init__ ( self , location , identifier , [string] , keyType , valueType , IDLInterfaceMember . Tags . Iterable ) [EOL] self . iteratorType = None [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . keyType , self . valueType ) [EOL] [EOL] def expand ( self , members , isJSImplemented ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if not self . isPairIterator ( ) : [EOL] return [EOL] [EOL] [comment] [EOL] self . addMethod ( [string] , members , False , self . iteratorType , affectsNothing = True , newObject = True , isIteratorAlias = True ) [EOL] [comment] [EOL] self . addMethod ( [string] , members , False , self . iteratorType , affectsNothing = True , newObject = True ) [EOL] [comment] [EOL] self . addMethod ( [string] , members , False , self . iteratorType , affectsNothing = True , newObject = True ) [EOL] [EOL] [comment] [EOL] self . addMethod ( [string] , members , False , BuiltinTypes [ IDLBuiltinType . Types . void ] , self . getForEachArguments ( ) ) [EOL] [EOL] def isValueIterator ( self ) : [EOL] return not self . isPairIterator ( ) [EOL] [EOL] def isPairIterator ( self ) : [EOL] return self . hasKeyType ( ) [EOL] [EOL] [comment] [EOL] class IDLMaplikeOrSetlike ( IDLMaplikeOrSetlikeOrIterableBase ) : [EOL] [EOL] def __init__ ( self , location , identifier , maplikeOrSetlikeType , readonly , keyType , valueType ) : [EOL] IDLMaplikeOrSetlikeOrIterableBase . __init__ ( self , location , identifier , maplikeOrSetlikeType , keyType , valueType , IDLInterfaceMember . Tags . MaplikeOrSetlike ) [EOL] self . readonly = readonly [EOL] self . slotIndices = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . isMaplike ( ) : [EOL] self . prefix = [string] [EOL] elif self . isSetlike ( ) : [EOL] self . prefix = [string] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . maplikeOrSetlikeOrIterableType , self . keyType ) [EOL] [EOL] def expand ( self , members , isJSImplemented ) : [EOL] [docstring] [EOL] [comment] [EOL] sizeAttr = IDLAttribute ( self . location , IDLUnresolvedIdentifier ( BuiltinLocation ( [string] ) , [string] ) , BuiltinTypes [ IDLBuiltinType . Types . unsigned_long ] , True , maplikeOrSetlike = self ) [EOL] [comment] [EOL] sizeAttr . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( [string] , ) ) ] ) [EOL] members . append ( sizeAttr ) [EOL] self . reserved_ro_names = [ [string] ] [EOL] self . disallowedMemberNames . append ( [string] ) [EOL] [EOL] [comment] [EOL] self . addMethod ( [string] , members , False , BuiltinTypes [ IDLBuiltinType . Types . object ] , affectsNothing = True , isIteratorAlias = self . isMaplike ( ) ) [EOL] [comment] [EOL] self . addMethod ( [string] , members , False , BuiltinTypes [ IDLBuiltinType . Types . object ] , affectsNothing = True ) [EOL] [comment] [EOL] self . addMethod ( [string] , members , False , BuiltinTypes [ IDLBuiltinType . Types . object ] , affectsNothing = True , isIteratorAlias = self . isSetlike ( ) ) [EOL] [EOL] [comment] [EOL] self . addMethod ( [string] , members , False , BuiltinTypes [ IDLBuiltinType . Types . void ] , self . getForEachArguments ( ) ) [EOL] [EOL] def getKeyArg ( ) : [EOL] return IDLArgument ( self . location , IDLUnresolvedIdentifier ( self . location , [string] ) , self . keyType ) [EOL] [EOL] [comment] [EOL] self . addMethod ( [string] , members , False , BuiltinTypes [ IDLBuiltinType . Types . boolean ] , [ getKeyArg ( ) ] , isPure = True ) [EOL] [EOL] if not self . readonly : [EOL] [comment] [EOL] self . addMethod ( [string] , members , True , BuiltinTypes [ IDLBuiltinType . Types . void ] , [ ] ) [EOL] [comment] [EOL] self . addMethod ( [string] , members , True , BuiltinTypes [ IDLBuiltinType . Types . boolean ] , [ getKeyArg ( ) ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if isJSImplemented : [EOL] [comment] [EOL] self . addMethod ( [string] , members , True , BuiltinTypes [ IDLBuiltinType . Types . void ] , [ ] , chromeOnly = True ) [EOL] [comment] [EOL] self . addMethod ( [string] , members , True , BuiltinTypes [ IDLBuiltinType . Types . boolean ] , [ getKeyArg ( ) ] , chromeOnly = True ) [EOL] [EOL] if self . isSetlike ( ) : [EOL] if not self . readonly : [EOL] [comment] [EOL] [comment] [EOL] [EOL] self . addMethod ( [string] , members , True , BuiltinTypes [ IDLBuiltinType . Types . object ] , [ getKeyArg ( ) ] ) [EOL] if isJSImplemented : [EOL] self . addMethod ( [string] , members , True , BuiltinTypes [ IDLBuiltinType . Types . object ] , [ getKeyArg ( ) ] , chromeOnly = True ) [EOL] return [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . addMethod ( [string] , members , False , BuiltinTypes [ IDLBuiltinType . Types . any ] , [ getKeyArg ( ) ] , isPure = True ) [EOL] [EOL] def getValueArg ( ) : [EOL] return IDLArgument ( self . location , IDLUnresolvedIdentifier ( self . location , [string] ) , self . valueType ) [EOL] [EOL] if not self . readonly : [EOL] self . addMethod ( [string] , members , True , BuiltinTypes [ IDLBuiltinType . Types . object ] , [ getKeyArg ( ) , getValueArg ( ) ] ) [EOL] if isJSImplemented : [EOL] self . addMethod ( [string] , members , True , BuiltinTypes [ IDLBuiltinType . Types . object ] , [ getKeyArg ( ) , getValueArg ( ) ] , chromeOnly = True ) [EOL] [EOL] class IDLConst ( IDLInterfaceMember ) : [EOL] def __init__ ( self , location , identifier , type , value ) : [EOL] IDLInterfaceMember . __init__ ( self , location , identifier , IDLInterfaceMember . Tags . Const ) [EOL] [EOL] assert isinstance ( type , IDLType ) [EOL] if type . isDictionary ( ) : [EOL] raise WebIDLError ( [string] , [ self . location ] ) [EOL] if type . isRecord ( ) : [EOL] raise WebIDLError ( [string] , [ self . location ] ) [EOL] self . type = type [EOL] self . value = value [EOL] [EOL] if identifier . name == [string] : [EOL] raise WebIDLError ( [string] , [ location ] ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . type , self . identifier ) [EOL] [EOL] def finish ( self , scope ) : [EOL] IDLInterfaceMember . finish ( self , scope ) [EOL] [EOL] if not self . type . isComplete ( ) : [EOL] type = self . type . complete ( scope ) [EOL] if not type . isPrimitive ( ) and not type . isString ( ) : [EOL] locations = [ self . type . location , type . location ] [EOL] try : [EOL] locations . append ( type . inner . location ) [EOL] except : [EOL] pass [EOL] raise WebIDLError ( [string] , locations ) [EOL] self . type = type [EOL] [EOL] [comment] [EOL] coercedValue = self . value . coerceToType ( self . type , self . location ) [EOL] assert coercedValue [EOL] [EOL] self . value = coercedValue [EOL] [EOL] def validate ( self ) : [EOL] IDLInterfaceMember . validate ( self ) [EOL] [EOL] def handleExtendedAttribute ( self , attr ) : [EOL] identifier = attr . identifier ( ) [EOL] if identifier == [string] : [EOL] convertExposedAttrToGlobalNameSet ( attr , self . _exposureGlobalNames ) [EOL] elif ( identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] ) : [EOL] [comment] [EOL] pass [EOL] else : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] IDLInterfaceMember . handleExtendedAttribute ( self , attr ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( [ self . type , self . value ] ) [EOL] [EOL] [EOL] class IDLAttribute ( IDLInterfaceMember ) : [EOL] def __init__ ( self , location , identifier , type , readonly , inherit = False , static = False , stringifier = False , maplikeOrSetlike = None , extendedAttrDict = None ) : [EOL] IDLInterfaceMember . __init__ ( self , location , identifier , IDLInterfaceMember . Tags . Attr , extendedAttrDict = extendedAttrDict ) [EOL] [EOL] assert isinstance ( type , IDLType ) [EOL] self . type = type [EOL] self . readonly = readonly [EOL] self . inherit = inherit [EOL] self . _static = static [EOL] self . lenientThis = False [EOL] self . _unforgeable = False [EOL] self . stringifier = stringifier [EOL] self . slotIndices = None [EOL] assert maplikeOrSetlike is None or isinstance ( maplikeOrSetlike , IDLMaplikeOrSetlike ) [EOL] self . maplikeOrSetlike = maplikeOrSetlike [EOL] self . dependsOn = [string] [EOL] self . affects = [string] [EOL] self . bindingAliases = [ ] [EOL] [EOL] if static and identifier . name == [string] : [EOL] raise WebIDLError ( [string] , [ location ] ) [EOL] [EOL] if readonly and inherit : [EOL] raise WebIDLError ( [string] , [ self . location ] ) [EOL] [EOL] def isStatic ( self ) : [EOL] return self . _static [EOL] [EOL] def forceStatic ( self ) : [EOL] self . _static = True [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . type , self . identifier ) [EOL] [EOL] def finish ( self , scope ) : [EOL] IDLInterfaceMember . finish ( self , scope ) [EOL] [EOL] if not self . type . isComplete ( ) : [EOL] t = self . type . complete ( scope ) [EOL] [EOL] assert not isinstance ( t , IDLUnresolvedType ) [EOL] assert not isinstance ( t , IDLTypedefType ) [EOL] assert not isinstance ( t . name , IDLUnresolvedIdentifier ) [EOL] self . type = t [EOL] [EOL] if self . readonly and ( self . type . hasClamp ( ) or self . type . hasEnforceRange ( ) or self . type . hasAllowShared ( ) or self . type . treatNullAsEmpty ) : [EOL] raise WebIDLError ( [string] , [ self . location ] ) [EOL] if self . type . isDictionary ( ) and not self . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] , [ self . location ] ) [EOL] if self . type . isSequence ( ) and not self . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] if self . type . isRecord ( ) and not self . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] if self . type . isUnion ( ) : [EOL] for f in self . type . unroll ( ) . flatMemberTypes : [EOL] if f . isDictionary ( ) : [EOL] raise WebIDLError ( [string] [string] [string] [string] [string] , [ self . location , f . location ] ) [EOL] if f . isSequence ( ) : [EOL] raise WebIDLError ( [string] [string] [string] [string] [string] , [ self . location , f . location ] ) [EOL] if f . isRecord ( ) : [EOL] raise WebIDLError ( [string] [string] [string] [string] [string] , [ self . location , f . location ] ) [EOL] if not self . type . isInterface ( ) and self . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] [EOL] if ( not self . type . isInterface ( ) and self . getExtendedAttribute ( [string] ) ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] [EOL] if self . type . isPromise ( ) and not self . readonly : [EOL] raise WebIDLError ( [string] , [ self . location ] ) [EOL] [EOL] def validate ( self ) : [EOL] def typeContainsChromeOnlyDictionaryMember ( type ) : [EOL] if ( type . nullable ( ) or type . isSequence ( ) or type . isRecord ( ) ) : [EOL] return typeContainsChromeOnlyDictionaryMember ( type . inner ) [EOL] [EOL] if type . isUnion ( ) : [EOL] for memberType in type . flatMemberTypes : [EOL] ( contains , location ) = typeContainsChromeOnlyDictionaryMember ( memberType ) [EOL] if contains : [EOL] return ( True , location ) [EOL] [EOL] if type . isDictionary ( ) : [EOL] dictionary = type . inner [EOL] while dictionary : [EOL] ( contains , location ) = dictionaryContainsChromeOnlyMember ( dictionary ) [EOL] if contains : [EOL] return ( True , location ) [EOL] dictionary = dictionary . parent [EOL] [EOL] return ( False , None ) [EOL] [EOL] def dictionaryContainsChromeOnlyMember ( dictionary ) : [EOL] for member in dictionary . members : [EOL] if member . getExtendedAttribute ( [string] ) : [EOL] return ( True , member . location ) [EOL] ( contains , location ) = typeContainsChromeOnlyDictionaryMember ( member . type ) [EOL] if contains : [EOL] return ( True , location ) [EOL] return ( False , None ) [EOL] [EOL] IDLInterfaceMember . validate ( self ) [EOL] [EOL] if ( self . getExtendedAttribute ( [string] ) or self . getExtendedAttribute ( [string] ) ) : [EOL] if not self . affects == [string] : [EOL] raise WebIDLError ( [string] [string] [string] [string] , [ self . location ] ) [EOL] ( contains , location ) = typeContainsChromeOnlyDictionaryMember ( self . type ) [EOL] if contains : [EOL] raise WebIDLError ( [string] [string] [string] , [ self . location , location ] ) [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] if ( not self . type . isSequence ( ) and not self . type . isDictionary ( ) and not self . type . isRecord ( ) ) : [EOL] raise WebIDLError ( [string] [string] [string] , [ self . location ] ) [EOL] if not self . type . unroll ( ) . isExposedInAllOf ( self . exposureSet ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] if self . readonly : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] [EOL] def handleExtendedAttribute ( self , attr ) : [EOL] identifier = attr . identifier ( ) [EOL] if ( ( identifier == [string] or identifier == [string] or identifier == [string] ) [EOL] and self . readonly ) : [EOL] raise WebIDLError ( [string] [string] % identifier , [ self . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] self . _addBindingAlias ( attr . value ( ) ) [EOL] elif ( ( ( identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] ) and self . getExtendedAttribute ( [string] ) ) or ( identifier == [string] and ( self . getExtendedAttribute ( [string] ) or self . getExtendedAttribute ( [string] ) or self . getExtendedAttribute ( [string] ) or self . getExtendedAttribute ( [string] ) ) ) ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] if self . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] self . lenientThis = True [EOL] elif identifier == [string] : [EOL] if self . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] self . _unforgeable = True [EOL] elif identifier == [string] and not self . readonly : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] and not self . readonly : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if not self . readonly : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . type . isPromise ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . getExtendedAttribute ( [string] ) is not None : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] if not self . readonly : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . type . isPromise ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . getExtendedAttribute ( [string] ) is not None : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] if not self . readonly : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . type . isPromise ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . getExtendedAttribute ( [string] ) is not None : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] if self . getExtendedAttribute ( [string] ) is not None : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if self . readonly : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] if not self . type . includesRestrictedFloat ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif ( identifier == [string] or identifier == [string] ) : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] if self . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] % identifier , [ attr . location , self . location ] ) [EOL] if self . getExtendedAttribute ( [string] ) : [EOL] raise WebIDLError ( [string] [string] % identifier , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] convertExposedAttrToGlobalNameSet ( attr , self . _exposureGlobalNames ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] self . _setDependsOn ( [string] ) [EOL] self . _setAffects ( [string] ) [EOL] elif identifier == [string] or identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] self . _setDependsOn ( [string] ) [EOL] self . _setAffects ( [string] ) [EOL] elif identifier == [string] : [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] self . _setAffects ( attr . value ( ) ) [EOL] elif identifier == [string] : [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] if ( attr . value ( ) != [string] and attr . value ( ) != [string] and not self . readonly ) : [EOL] raise WebIDLError ( [string] [string] % attr . value ( ) , [ attr . location , self . location ] ) [EOL] self . _setDependsOn ( attr . value ( ) ) [EOL] elif identifier == [string] : [EOL] if self . stringifier : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] if self . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] elif ( identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] ) : [EOL] [comment] [EOL] pass [EOL] else : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] IDLInterfaceMember . handleExtendedAttribute ( self , attr ) [EOL] [EOL] def resolve ( self , parentScope ) : [EOL] assert isinstance ( parentScope , IDLScope ) [EOL] self . type . resolveType ( parentScope ) [EOL] IDLObjectWithIdentifier . resolve ( self , parentScope ) [EOL] [EOL] def hasLenientThis ( self ) : [EOL] return self . lenientThis [EOL] [EOL] def isMaplikeOrSetlikeAttr ( self ) : [EOL] [docstring] [EOL] return self . maplikeOrSetlike is not None [EOL] [EOL] def isUnforgeable ( self ) : [EOL] return self . _unforgeable [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( [ self . type ] ) [EOL] [EOL] def expand ( self , members ) : [EOL] assert self . stringifier [EOL] if not self . type . isDOMString ( ) and not self . type . isUSVString ( ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] identifier = IDLUnresolvedIdentifier ( self . location , [string] , allowDoubleUnderscore = True ) [EOL] method = IDLMethod ( self . location , identifier , returnType = self . type , arguments = [ ] , stringifier = True , underlyingAttr = self ) [EOL] allowedExtAttrs = [ [string] , [string] , [string] ] [EOL] [comment] [EOL] attributeOnlyExtAttrs = [ [string] , [string] , [string] , ] [EOL] for ( key , value ) in self . _extendedAttrDict . items ( ) : [EOL] if key in allowedExtAttrs : [EOL] if value is not True : [EOL] raise WebIDLError ( [string] [string] [string] % key , [ self . location ] ) [EOL] method . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( key , ) ) ] ) [EOL] elif not key in attributeOnlyExtAttrs : [EOL] raise WebIDLError ( [string] [string] [string] % key , [ self . location ] ) [EOL] members . append ( method ) [EOL] [EOL] [EOL] class IDLArgument ( IDLObjectWithIdentifier ) : [EOL] def __init__ ( self , location , identifier , type , optional = False , defaultValue = None , variadic = False , dictionaryMember = False , allowTypeAttributes = False ) : [EOL] IDLObjectWithIdentifier . __init__ ( self , location , None , identifier ) [EOL] [EOL] assert isinstance ( type , IDLType ) [EOL] self . type = type [EOL] [EOL] self . optional = optional [EOL] self . defaultValue = defaultValue [EOL] self . variadic = variadic [EOL] self . dictionaryMember = dictionaryMember [EOL] self . _isComplete = False [EOL] self . _allowTreatNonCallableAsNull = False [EOL] self . _extendedAttrDict = { } [EOL] self . allowTypeAttributes = allowTypeAttributes [EOL] [EOL] assert not variadic or optional [EOL] assert not variadic or not defaultValue [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] for attribute in attrs : [EOL] identifier = attribute . identifier ( ) [EOL] if self . allowTypeAttributes and ( identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] ) : [EOL] self . type = self . type . withExtendedAttributes ( [ attribute ] ) [EOL] elif identifier == [string] : [EOL] self . _allowTreatNonCallableAsNull = True [EOL] elif ( self . dictionaryMember and ( identifier == [string] or identifier == [string] or identifier == [string] ) ) : [EOL] if not self . optional : [EOL] raise WebIDLError ( [string] [string] % identifier , [ attribute . location ] ) [EOL] else : [EOL] raise WebIDLError ( [string] % ( [string] if self . dictionaryMember else [EOL] [string] ) , [ attribute . location ] ) [EOL] attrlist = attribute . listValue ( ) [EOL] self . _extendedAttrDict [ identifier ] = attrlist if len ( attrlist ) else True [EOL] [EOL] def getExtendedAttribute ( self , name ) : [EOL] return self . _extendedAttrDict . get ( name , None ) [EOL] [EOL] def isComplete ( self ) : [EOL] return self . _isComplete [EOL] [EOL] def complete ( self , scope ) : [EOL] if self . _isComplete : [EOL] return [EOL] [EOL] self . _isComplete = True [EOL] [EOL] if not self . type . isComplete ( ) : [EOL] type = self . type . complete ( scope ) [EOL] assert not isinstance ( type , IDLUnresolvedType ) [EOL] assert not isinstance ( type , IDLTypedefType ) [EOL] assert not isinstance ( type . name , IDLUnresolvedIdentifier ) [EOL] self . type = type [EOL] [EOL] if self . type . isAny ( ) : [EOL] assert ( self . defaultValue is None or isinstance ( self . defaultValue , IDLNullValue ) ) [EOL] [comment] [EOL] if self . optional and not self . defaultValue and not self . variadic : [EOL] [comment] [EOL] [comment] [EOL] self . defaultValue = IDLUndefinedValue ( self . location ) [EOL] [EOL] if self . dictionaryMember and self . type . treatNullAsEmpty : [EOL] raise WebIDLError ( [string] , [ self . location ] ) [EOL] [comment] [EOL] [comment] [EOL] if self . defaultValue : [EOL] self . defaultValue = self . defaultValue . coerceToType ( self . type , self . location ) [EOL] assert self . defaultValue [EOL] [EOL] def allowTreatNonCallableAsNull ( self ) : [EOL] return self . _allowTreatNonCallableAsNull [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] deps = set ( [ self . type ] ) [EOL] if self . defaultValue : [EOL] deps . add ( self . defaultValue ) [EOL] return deps [EOL] [EOL] def canHaveMissingValue ( self ) : [EOL] return self . optional and not self . defaultValue [EOL] [EOL] [EOL] class IDLCallback ( IDLObjectWithScope ) : [EOL] def __init__ ( self , location , parentScope , identifier , returnType , arguments , isConstructor ) : [EOL] assert isinstance ( returnType , IDLType ) [EOL] [EOL] self . _returnType = returnType [EOL] [comment] [EOL] self . _arguments = list ( arguments ) [EOL] [EOL] IDLObjectWithScope . __init__ ( self , location , parentScope , identifier ) [EOL] [EOL] for ( returnType , arguments ) in self . signatures ( ) : [EOL] for argument in arguments : [EOL] argument . resolve ( self ) [EOL] [EOL] self . _treatNonCallableAsNull = False [EOL] self . _treatNonObjectAsNull = False [EOL] self . _isRunScriptBoundary = False [EOL] self . _isConstructor = isConstructor [EOL] [EOL] def isCallback ( self ) : [EOL] return True [EOL] [EOL] def isConstructor ( self ) : [EOL] return self . _isConstructor [EOL] [EOL] def signatures ( self ) : [EOL] return [ ( self . _returnType , self . _arguments ) ] [EOL] [EOL] def finish ( self , scope ) : [EOL] if not self . _returnType . isComplete ( ) : [EOL] type = self . _returnType . complete ( scope ) [EOL] [EOL] assert not isinstance ( type , IDLUnresolvedType ) [EOL] assert not isinstance ( type , IDLTypedefType ) [EOL] assert not isinstance ( type . name , IDLUnresolvedIdentifier ) [EOL] self . _returnType = type [EOL] [EOL] for argument in self . _arguments : [EOL] if argument . type . isComplete ( ) : [EOL] continue [EOL] [EOL] type = argument . type . complete ( scope ) [EOL] [EOL] assert not isinstance ( type , IDLUnresolvedType ) [EOL] assert not isinstance ( type , IDLTypedefType ) [EOL] assert not isinstance ( type . name , IDLUnresolvedIdentifier ) [EOL] argument . type = type [EOL] [EOL] def validate ( self ) : [EOL] pass [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] unhandledAttrs = [ ] [EOL] for attr in attrs : [EOL] if attr . identifier ( ) == [string] : [EOL] self . _treatNonCallableAsNull = True [EOL] elif attr . identifier ( ) == [string] : [EOL] if self . _isConstructor : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] self . _treatNonObjectAsNull = True [EOL] elif attr . identifier ( ) == [string] : [EOL] if self . _isConstructor : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] self . _isRunScriptBoundary = True [EOL] else : [EOL] unhandledAttrs . append ( attr ) [EOL] if self . _treatNonCallableAsNull and self . _treatNonObjectAsNull : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] if len ( unhandledAttrs ) != [number] : [EOL] IDLType . addExtendedAttributes ( self , unhandledAttrs ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return set ( [ self . _returnType ] + self . _arguments ) [EOL] [EOL] def isRunScriptBoundary ( self ) : [EOL] return self . _isRunScriptBoundary ; [EOL] [EOL] [EOL] class IDLCallbackType ( IDLType ) : [EOL] def __init__ ( self , location , callback ) : [EOL] IDLType . __init__ ( self , location , callback . identifier . name ) [EOL] self . callback = callback [EOL] [EOL] def isCallback ( self ) : [EOL] return True [EOL] [EOL] def tag ( self ) : [EOL] return IDLType . Tags . callback [EOL] [EOL] def isDistinguishableFrom ( self , other ) : [EOL] if other . isPromise ( ) : [EOL] return False [EOL] if other . isUnion ( ) : [EOL] [comment] [EOL] return other . isDistinguishableFrom ( self ) [EOL] return ( other . isPrimitive ( ) or other . isString ( ) or other . isEnum ( ) or other . isNonCallbackInterface ( ) or other . isSequence ( ) ) [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] return self . callback . _getDependentObjects ( ) [EOL] [EOL] [EOL] class IDLMethodOverload : [EOL] [docstring] [EOL] def __init__ ( self , returnType , arguments , location ) : [EOL] self . returnType = returnType [EOL] [comment] [EOL] self . arguments = list ( arguments ) [EOL] self . location = location [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] deps = set ( self . arguments ) [EOL] deps . add ( self . returnType ) [EOL] return deps [EOL] [EOL] def includesRestrictedFloatArgument ( self ) : [EOL] return any ( arg . type . includesRestrictedFloat ( ) for arg in self . arguments ) [EOL] [EOL] [EOL] class IDLMethod ( IDLInterfaceMember , IDLScope ) : [EOL] [EOL] Special = enum ( [string] , [string] , [string] , [string] , base = IDLInterfaceMember . Special ) [EOL] [EOL] NamedOrIndexed = enum ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , location , identifier , returnType , arguments , static = False , getter = False , setter = False , deleter = False , specialType = NamedOrIndexed . Neither , legacycaller = False , stringifier = False , maplikeOrSetlikeOrIterable = None , underlyingAttr = None ) : [EOL] [comment] [EOL] IDLInterfaceMember . __init__ ( self , location , identifier , IDLInterfaceMember . Tags . Method ) [EOL] [EOL] self . _hasOverloads = False [EOL] [EOL] assert isinstance ( returnType , IDLType ) [EOL] [EOL] [comment] [EOL] self . _overloads = [ IDLMethodOverload ( returnType , arguments , location ) ] [EOL] [EOL] assert isinstance ( static , bool ) [EOL] self . _static = static [EOL] assert isinstance ( getter , bool ) [EOL] self . _getter = getter [EOL] assert isinstance ( setter , bool ) [EOL] self . _setter = setter [EOL] assert isinstance ( deleter , bool ) [EOL] self . _deleter = deleter [EOL] assert isinstance ( legacycaller , bool ) [EOL] self . _legacycaller = legacycaller [EOL] assert isinstance ( stringifier , bool ) [EOL] self . _stringifier = stringifier [EOL] assert maplikeOrSetlikeOrIterable is None or isinstance ( maplikeOrSetlikeOrIterable , IDLMaplikeOrSetlikeOrIterableBase ) [EOL] self . maplikeOrSetlikeOrIterable = maplikeOrSetlikeOrIterable [EOL] self . _htmlConstructor = False [EOL] self . underlyingAttr = underlyingAttr [EOL] self . _specialType = specialType [EOL] self . _unforgeable = False [EOL] self . dependsOn = [string] [EOL] self . affects = [string] [EOL] self . aliases = [ ] [EOL] [EOL] if static and identifier . name == [string] : [EOL] raise WebIDLError ( [string] , [ location ] ) [EOL] [EOL] self . assertSignatureConstraints ( ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % self . identifier [EOL] [EOL] def assertSignatureConstraints ( self ) : [EOL] if self . _getter or self . _deleter : [EOL] assert len ( self . _overloads ) == [number] [EOL] overload = self . _overloads [ [number] ] [EOL] arguments = overload . arguments [EOL] assert len ( arguments ) == [number] [EOL] assert ( arguments [ [number] ] . type == BuiltinTypes [ IDLBuiltinType . Types . domstring ] or arguments [ [number] ] . type == BuiltinTypes [ IDLBuiltinType . Types . unsigned_long ] ) [EOL] assert not arguments [ [number] ] . optional and not arguments [ [number] ] . variadic [EOL] assert not self . _getter or not overload . returnType . isVoid ( ) [EOL] [EOL] if self . _setter : [EOL] assert len ( self . _overloads ) == [number] [EOL] arguments = self . _overloads [ [number] ] . arguments [EOL] assert len ( arguments ) == [number] [EOL] assert ( arguments [ [number] ] . type == BuiltinTypes [ IDLBuiltinType . Types . domstring ] or arguments [ [number] ] . type == BuiltinTypes [ IDLBuiltinType . Types . unsigned_long ] ) [EOL] assert not arguments [ [number] ] . optional and not arguments [ [number] ] . variadic [EOL] assert not arguments [ [number] ] . optional and not arguments [ [number] ] . variadic [EOL] [EOL] if self . _stringifier : [EOL] assert len ( self . _overloads ) == [number] [EOL] overload = self . _overloads [ [number] ] [EOL] assert len ( overload . arguments ) == [number] [EOL] if not self . underlyingAttr : [EOL] assert overload . returnType == BuiltinTypes [ IDLBuiltinType . Types . domstring ] [EOL] [EOL] def isStatic ( self ) : [EOL] return self . _static [EOL] [EOL] def forceStatic ( self ) : [EOL] self . _static = True [EOL] [EOL] def isGetter ( self ) : [EOL] return self . _getter [EOL] [EOL] def isSetter ( self ) : [EOL] return self . _setter [EOL] [EOL] def isDeleter ( self ) : [EOL] return self . _deleter [EOL] [EOL] def isNamed ( self ) : [EOL] assert ( self . _specialType == IDLMethod . NamedOrIndexed . Named or self . _specialType == IDLMethod . NamedOrIndexed . Indexed ) [EOL] return self . _specialType == IDLMethod . NamedOrIndexed . Named [EOL] [EOL] def isIndexed ( self ) : [EOL] assert ( self . _specialType == IDLMethod . NamedOrIndexed . Named or self . _specialType == IDLMethod . NamedOrIndexed . Indexed ) [EOL] return self . _specialType == IDLMethod . NamedOrIndexed . Indexed [EOL] [EOL] def isLegacycaller ( self ) : [EOL] return self . _legacycaller [EOL] [EOL] def isStringifier ( self ) : [EOL] return self . _stringifier [EOL] [EOL] def isToJSON ( self ) : [EOL] return self . identifier . name == [string] [EOL] [EOL] def isDefaultToJSON ( self ) : [EOL] return self . isToJSON ( ) and self . getExtendedAttribute ( [string] ) [EOL] [EOL] def isMaplikeOrSetlikeOrIterableMethod ( self ) : [EOL] [docstring] [EOL] return self . maplikeOrSetlikeOrIterable is not None [EOL] [EOL] def isSpecial ( self ) : [EOL] return ( self . isGetter ( ) or self . isSetter ( ) or self . isDeleter ( ) or self . isLegacycaller ( ) or self . isStringifier ( ) ) [EOL] [EOL] def isHTMLConstructor ( self ) : [EOL] return self . _htmlConstructor [EOL] [EOL] def hasOverloads ( self ) : [EOL] return self . _hasOverloads [EOL] [EOL] def isIdentifierLess ( self ) : [EOL] [docstring] [EOL] return ( self . identifier . name [ : [number] ] == [string] and not self . isMaplikeOrSetlikeOrIterableMethod ( ) ) [EOL] [EOL] def resolve ( self , parentScope ) : [EOL] assert isinstance ( parentScope , IDLScope ) [EOL] IDLObjectWithIdentifier . resolve ( self , parentScope ) [EOL] IDLScope . __init__ ( self , self . location , parentScope , self . identifier ) [EOL] for ( returnType , arguments ) in self . signatures ( ) : [EOL] for argument in arguments : [EOL] argument . resolve ( self ) [EOL] [EOL] def addOverload ( self , method ) : [EOL] assert len ( method . _overloads ) == [number] [EOL] [EOL] if self . _extendedAttrDict != method . _extendedAttrDict : [EOL] extendedAttrDiff = set ( self . _extendedAttrDict . keys ( ) ) ^ set ( method . _extendedAttrDict . keys ( ) ) [EOL] [EOL] if extendedAttrDiff == { [string] } : [EOL] if [string] not in self . _extendedAttrDict : [EOL] for overload in self . _overloads : [EOL] if overload . includesRestrictedFloatArgument ( ) : [EOL] raise WebIDLError ( [string] [string] % method . identifier , [ overload . location , method . location ] ) [EOL] self . _extendedAttrDict [ [string] ] = method . _extendedAttrDict [ [string] ] [EOL] elif method . _overloads [ [number] ] . includesRestrictedFloatArgument ( ) : [EOL] raise WebIDLError ( [string] [string] % method . identifier , [ self . location , method . location ] ) [EOL] else : [EOL] raise WebIDLError ( [string] [string] % method . identifier , [ self . location , method . location ] ) [EOL] [EOL] self . _overloads . extend ( method . _overloads ) [EOL] [EOL] self . _hasOverloads = True [EOL] [EOL] if self . isStatic ( ) != method . isStatic ( ) : [EOL] raise WebIDLError ( [string] % method . identifier , [ method . location ] ) [EOL] [EOL] if self . isLegacycaller ( ) != method . isLegacycaller ( ) : [EOL] raise WebIDLError ( [string] % method . identifier , [ method . location ] ) [EOL] [EOL] [comment] [EOL] assert not self . isGetter ( ) [EOL] assert not method . isGetter ( ) [EOL] assert not self . isSetter ( ) [EOL] assert not method . isSetter ( ) [EOL] assert not self . isDeleter ( ) [EOL] assert not method . isDeleter ( ) [EOL] assert not self . isStringifier ( ) [EOL] assert not method . isStringifier ( ) [EOL] assert not self . isHTMLConstructor ( ) [EOL] assert not method . isHTMLConstructor ( ) [EOL] [EOL] return self [EOL] [EOL] def signatures ( self ) : [EOL] return [ ( overload . returnType , overload . arguments ) for overload in self . _overloads ] [EOL] [EOL] def finish ( self , scope ) : [EOL] IDLInterfaceMember . finish ( self , scope ) [EOL] [EOL] for overload in self . _overloads : [EOL] returnType = overload . returnType [EOL] if not returnType . isComplete ( ) : [EOL] returnType = returnType . complete ( scope ) [EOL] assert not isinstance ( returnType , IDLUnresolvedType ) [EOL] assert not isinstance ( returnType , IDLTypedefType ) [EOL] assert not isinstance ( returnType . name , IDLUnresolvedIdentifier ) [EOL] overload . returnType = returnType [EOL] [EOL] for argument in overload . arguments : [EOL] if not argument . isComplete ( ) : [EOL] argument . complete ( scope ) [EOL] assert argument . type . isComplete ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . maxArgCount = max ( len ( s [ [number] ] ) for s in self . signatures ( ) ) [EOL] self . allowedArgCounts = [ i for i in range ( self . maxArgCount + [number] ) if len ( self . signaturesForArgCount ( i ) ) != [number] ] [EOL] [EOL] def validate ( self ) : [EOL] IDLInterfaceMember . validate ( self ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for argCount in self . allowedArgCounts : [EOL] possibleOverloads = self . overloadsForArgCount ( argCount ) [EOL] if len ( possibleOverloads ) == [number] : [EOL] continue [EOL] distinguishingIndex = self . distinguishingIndexForArgCount ( argCount ) [EOL] for idx in range ( distinguishingIndex ) : [EOL] firstSigType = possibleOverloads [ [number] ] . arguments [ idx ] . type [EOL] for overload in possibleOverloads [ [number] : ] : [EOL] if overload . arguments [ idx ] . type != firstSigType : [EOL] raise WebIDLError ( [string] [string] [string] % ( self . identifier . name , argCount , idx , distinguishingIndex ) , [ self . location , overload . location ] ) [EOL] [EOL] overloadWithPromiseReturnType = None [EOL] overloadWithoutPromiseReturnType = None [EOL] for overload in self . _overloads : [EOL] returnType = overload . returnType [EOL] if not returnType . unroll ( ) . isExposedInAllOf ( self . exposureSet ) : [EOL] raise WebIDLError ( [string] [string] , [ overload . location ] ) [EOL] [EOL] variadicArgument = None [EOL] [EOL] arguments = overload . arguments [EOL] for ( idx , argument ) in enumerate ( arguments ) : [EOL] assert argument . type . isComplete ( ) [EOL] [EOL] if ( ( argument . type . isDictionary ( ) and argument . type . unroll ( ) . inner . canBeEmpty ( ) ) or ( argument . type . isUnion ( ) and argument . type . unroll ( ) . hasPossiblyEmptyDictionaryType ( ) ) ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( not argument . optional and all ( arg . optional for arg in arguments [ idx + [number] : ] ) ) : [EOL] raise WebIDLError ( [string] [string] [string] [string] [string] , [ argument . location ] ) [EOL] [EOL] if ( not argument . defaultValue and all ( arg . optional for arg in arguments [ idx + [number] : ] ) ) : [EOL] raise WebIDLError ( [string] [string] [string] [string] [string] , [ argument . location ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( argument . type . nullable ( ) and ( argument . type . isDictionary ( ) or ( argument . type . isUnion ( ) and argument . type . unroll ( ) . hasDictionaryType ( ) ) ) ) : [EOL] raise WebIDLError ( [string] [string] [string] , [ argument . location ] ) [EOL] [EOL] [comment] [EOL] if variadicArgument : [EOL] raise WebIDLError ( [string] , [ variadicArgument . location ] ) [EOL] if argument . variadic : [EOL] variadicArgument = argument [EOL] [EOL] if returnType . isPromise ( ) : [EOL] overloadWithPromiseReturnType = overload [EOL] else : [EOL] overloadWithoutPromiseReturnType = overload [EOL] [EOL] [comment] [EOL] if overloadWithPromiseReturnType and overloadWithoutPromiseReturnType : [EOL] raise WebIDLError ( [string] [string] , [ overloadWithPromiseReturnType . location , overloadWithoutPromiseReturnType . location ] ) [EOL] [EOL] if overloadWithPromiseReturnType and self . _legacycaller : [EOL] raise WebIDLError ( [string] [string] , [ overloadWithPromiseReturnType . location ] ) [EOL] [EOL] if self . getExtendedAttribute ( [string] ) and not ( self . identifier . scope . isJSImplemented ( ) and self . isStatic ( ) ) : [EOL] raise WebIDLError ( [string] [string] , [ self . location ] ) [EOL] [EOL] [comment] [EOL] if self . identifier . name == [string] : [EOL] if len ( self . signatures ( ) ) != [number] : [EOL] raise WebIDLError ( [string] , [ self . _overloads [ [number] ] . location , self . _overloads [ [number] ] . location ] ) [EOL] if len ( self . signatures ( ) [ [number] ] [ [number] ] ) != [number] : [EOL] raise WebIDLError ( [string] , [ self . location ] ) [EOL] if not self . signatures ( ) [ [number] ] [ [number] ] . isJSONType ( ) : [EOL] raise WebIDLError ( [string] , [ self . location ] ) [EOL] [EOL] def overloadsForArgCount ( self , argc ) : [EOL] return [ overload for overload in self . _overloads if len ( overload . arguments ) == argc or ( len ( overload . arguments ) > argc and all ( arg . optional for arg in overload . arguments [ argc : ] ) ) or ( len ( overload . arguments ) < argc and len ( overload . arguments ) > [number] and overload . arguments [ - [number] ] . variadic ) ] [EOL] [EOL] def signaturesForArgCount ( self , argc ) : [EOL] return [ ( overload . returnType , overload . arguments ) for overload in self . overloadsForArgCount ( argc ) ] [EOL] [EOL] def locationsForArgCount ( self , argc ) : [EOL] return [ overload . location for overload in self . overloadsForArgCount ( argc ) ] [EOL] [EOL] def distinguishingIndexForArgCount ( self , argc ) : [EOL] def isValidDistinguishingIndex ( idx , signatures ) : [EOL] for ( firstSigIndex , ( firstRetval , firstArgs ) ) in enumerate ( signatures [ : - [number] ] ) : [EOL] for ( secondRetval , secondArgs ) in signatures [ firstSigIndex + [number] : ] : [EOL] if idx < len ( firstArgs ) : [EOL] firstType = firstArgs [ idx ] . type [EOL] else : [EOL] assert ( firstArgs [ - [number] ] . variadic ) [EOL] firstType = firstArgs [ - [number] ] . type [EOL] if idx < len ( secondArgs ) : [EOL] secondType = secondArgs [ idx ] . type [EOL] else : [EOL] assert ( secondArgs [ - [number] ] . variadic ) [EOL] secondType = secondArgs [ - [number] ] . type [EOL] if not firstType . isDistinguishableFrom ( secondType ) : [EOL] return False [EOL] return True [EOL] signatures = self . signaturesForArgCount ( argc ) [EOL] for idx in range ( argc ) : [EOL] if isValidDistinguishingIndex ( idx , signatures ) : [EOL] return idx [EOL] [comment] [EOL] locations = self . locationsForArgCount ( argc ) [EOL] raise WebIDLError ( [string] [string] % ( argc , self . identifier . name ) , locations ) [EOL] [EOL] def handleExtendedAttribute ( self , attr ) : [EOL] identifier = attr . identifier ( ) [EOL] if ( identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] ) : [EOL] raise WebIDLError ( [string] [string] % identifier , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if self . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] self . _unforgeable = True [EOL] elif identifier == [string] : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] [comment] [EOL] overloads = self . _overloads [EOL] assert len ( overloads ) == [number] [EOL] if not overloads [ [number] ] . returnType . isVoid ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] if not overloads [ [number] ] . includesRestrictedFloatArgument ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] convertExposedAttrToGlobalNameSet ( attr , self . _exposureGlobalNames ) [EOL] elif ( identifier == [string] or identifier == [string] ) : [EOL] [comment] [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] if identifier == [string] and self . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] self . _setDependsOn ( [string] ) [EOL] self . _setAffects ( [string] ) [EOL] elif identifier == [string] : [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] self . _setAffects ( attr . value ( ) ) [EOL] elif identifier == [string] : [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] self . _setDependsOn ( attr . value ( ) ) [EOL] elif identifier == [string] : [EOL] if not attr . hasValue ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] self . _addAlias ( attr . value ( ) ) [EOL] elif identifier == [string] : [EOL] if self . isSpecial ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] if self . isStatic ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] [EOL] if self . isSpecial ( ) and not self . isSetter ( ) and not self . isDeleter ( ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] [EOL] if not self . isToJSON ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location , self . location ] ) [EOL] [EOL] if self . signatures ( ) [ [number] ] [ [number] ] != BuiltinTypes [ IDLBuiltinType . Types . object ] : [EOL] raise WebIDLError ( [string] [string] , [ attr . location , self . location ] ) [EOL] elif ( identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] ) : [EOL] [comment] [EOL] pass [EOL] else : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] IDLInterfaceMember . handleExtendedAttribute ( self , attr ) [EOL] [EOL] def returnsPromise ( self ) : [EOL] return self . _overloads [ [number] ] . returnType . isPromise ( ) [EOL] [EOL] def isUnforgeable ( self ) : [EOL] return self . _unforgeable [EOL] [EOL] def _getDependentObjects ( self ) : [EOL] deps = set ( ) [EOL] for overload in self . _overloads : [EOL] deps . update ( overload . _getDependentObjects ( ) ) [EOL] return deps [EOL] [EOL] [EOL] class IDLConstructor ( IDLMethod ) : [EOL] def __init__ ( self , location , args , name ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _initLocation = location [EOL] self . _initArgs = args [EOL] self . _initName = name [EOL] self . _inited = False [EOL] self . _initExtendedAttrs = [ ] [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] if self . _inited : [EOL] return IDLMethod . addExtendedAttributes ( self , attrs ) [EOL] self . _initExtendedAttrs . extend ( attrs ) [EOL] [EOL] def handleExtendedAttribute ( self , attr ) : [EOL] identifier = attr . identifier ( ) [EOL] if ( identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] or identifier == [string] ) : [EOL] IDLMethod . handleExtendedAttribute ( self , attr ) [EOL] elif identifier == [string] : [EOL] if not attr . noArguments ( ) : [EOL] raise WebIDLError ( [string] , [ attr . location ] ) [EOL] [comment] [EOL] assert ( self . identifier . name == [string] ) [EOL] [EOL] if any ( len ( sig [ [number] ] ) != [number] for sig in self . signatures ( ) ) : [EOL] raise WebIDLError ( [string] [string] , [ attr . location ] ) [EOL] self . _htmlConstructor = True [EOL] else : [EOL] raise WebIDLError ( [string] % identifier , [ attr . location ] ) [EOL] [EOL] def reallyInit ( self , parentInterface ) : [EOL] name = self . _initName [EOL] location = self . _initLocation [EOL] identifier = IDLUnresolvedIdentifier ( location , name , allowForbidden = True ) [EOL] retType = IDLWrapperType ( parentInterface . location , parentInterface ) [EOL] IDLMethod . __init__ ( self , location , identifier , retType , self . _initArgs , static = True ) [EOL] self . _inited = True [EOL] [comment] [EOL] self . addExtendedAttributes ( self . _initExtendedAttrs ) [EOL] self . _initExtendedAttrs = [ ] [EOL] [comment] [EOL] [comment] [EOL] self . addExtendedAttributes ( [ IDLExtendedAttribute ( self . location , ( [string] , ) ) ] ) [EOL] [EOL] [EOL] class IDLIncludesStatement ( IDLObject ) : [EOL] def __init__ ( self , location , interface , mixin ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] self . interface = interface [EOL] self . mixin = mixin [EOL] self . _finished = False [EOL] [EOL] def finish ( self , scope ) : [EOL] if self . _finished : [EOL] return [EOL] self . _finished = True [EOL] assert ( isinstance ( self . interface , IDLIdentifierPlaceholder ) ) [EOL] assert ( isinstance ( self . mixin , IDLIdentifierPlaceholder ) ) [EOL] interface = self . interface . finish ( scope ) [EOL] mixin = self . mixin . finish ( scope ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not isinstance ( interface , IDLInterface ) : [EOL] raise WebIDLError ( [string] [string] , [ self . interface . location , interface . location ] ) [EOL] if interface . isCallback ( ) : [EOL] raise WebIDLError ( [string] [string] , [ self . interface . location , interface . location ] ) [EOL] if not isinstance ( mixin , IDLInterfaceMixin ) : [EOL] raise WebIDLError ( [string] [string] , [ self . mixin . location , mixin . location ] ) [EOL] [EOL] mixin . actualExposureGlobalNames . update ( interface . _exposureGlobalNames ) [EOL] [EOL] interface . addIncludedMixin ( mixin ) [EOL] self . interface = interface [EOL] self . mixin = mixin [EOL] [EOL] def validate ( self ) : [EOL] pass [EOL] [EOL] def addExtendedAttributes ( self , attrs ) : [EOL] if len ( attrs ) != [number] : [EOL] raise WebIDLError ( [string] [string] , [ attrs [ [number] ] . location , self . location ] ) [EOL] [EOL] class IDLExtendedAttribute ( IDLObject ) : [EOL] [docstring] [EOL] def __init__ ( self , location , tuple ) : [EOL] IDLObject . __init__ ( self , location ) [EOL] self . _tuple = tuple [EOL] [EOL] def identifier ( self ) : [EOL] return self . _tuple [ [number] ] [EOL] [EOL] def noArguments ( self ) : [EOL] return len ( self . _tuple ) == [number] [EOL] [EOL] def hasValue ( self ) : [EOL] return len ( self . _tuple ) >= [number] and isinstance ( self . _tuple [ [number] ] , str ) [EOL] [EOL] def value ( self ) : [EOL] assert ( self . hasValue ( ) ) [EOL] return self . _tuple [ [number] ] [EOL] [EOL] def hasArgs ( self ) : [EOL] return ( len ( self . _tuple ) == [number] and isinstance ( self . _tuple [ [number] ] , list ) or len ( self . _tuple ) == [number] ) [EOL] [EOL] def args ( self ) : [EOL] assert ( self . hasArgs ( ) ) [EOL] [comment] [EOL] return self . _tuple [ - [number] ] [EOL] [EOL] def listValue ( self ) : [EOL] [docstring] [EOL] return list ( self . _tuple ) [ [number] : ] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Tokenizer ( object ) : [EOL] tokens = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def t_FLOATLITERAL ( self , t ) : [EOL] [docstring] [EOL] t . value = float ( t . value ) [EOL] return t [EOL] [EOL] def t_INTEGER ( self , t ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] t . value = parseInt ( t . value ) [EOL] except : [EOL] raise WebIDLError ( [string] , [ Location ( lexer = self . lexer , lineno = self . lexer . lineno , lexpos = self . lexer . lexpos , filename = self . _filename ) ] ) [EOL] return t [EOL] [EOL] def t_IDENTIFIER ( self , t ) : [EOL] [docstring] [EOL] t . type = self . keywords . get ( t . value , [string] ) [EOL] return t [EOL] [EOL] def t_STRING ( self , t ) : [EOL] [docstring] [EOL] t . value = t . value [ [number] : - [number] ] [EOL] return t [EOL] [EOL] def t_WHITESPACE ( self , t ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def t_ELLIPSIS ( self , t ) : [EOL] [docstring] [EOL] t . type = self . keywords . get ( t . value ) [EOL] return t [EOL] [EOL] def t_OTHER ( self , t ) : [EOL] [docstring] [EOL] t . type = self . keywords . get ( t . value , [string] ) [EOL] return t [EOL] [EOL] keywords = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] tokens . extend ( keywords . values ( ) ) [EOL] [EOL] def t_error ( self , t ) : [EOL] raise WebIDLError ( [string] , [ Location ( lexer = self . lexer , lineno = self . lexer . lineno , lexpos = self . lexer . lexpos , filename = self . filename ) ] ) [EOL] [EOL] def __init__ ( self , outputdir , lexer = None ) : [EOL] if lexer : [EOL] self . lexer = lexer [EOL] else : [EOL] self . lexer = lex . lex ( object = self , outputdir = outputdir , lextab = [string] , reflags = re . DOTALL ) [EOL] [EOL] [EOL] class SqueakyCleanLogger ( object ) : [EOL] errorWhitelist = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] def __init__ ( self ) : [EOL] self . errors = [ ] [EOL] [EOL] def debug ( self , msg , * args , ** kwargs ) : [EOL] pass [EOL] info = debug [EOL] [EOL] def warning ( self , msg , * args , ** kwargs ) : [EOL] if msg == [string] or msg == [string] : [EOL] [comment] [EOL] [comment] [EOL] whitelistmsg = [string] [EOL] whitelistargs = args [ [number] : ] [EOL] else : [EOL] whitelistmsg = msg [EOL] whitelistargs = args [EOL] if ( whitelistmsg % whitelistargs ) not in SqueakyCleanLogger . errorWhitelist : [EOL] self . errors . append ( msg % args ) [EOL] error = warning [EOL] [EOL] def reportGrammarErrors ( self ) : [EOL] if self . errors : [EOL] raise WebIDLError ( [string] . join ( self . errors ) , [ ] ) [EOL] [EOL] [EOL] class Parser ( Tokenizer ) : [EOL] def getLocation ( self , p , i ) : [EOL] return Location ( self . lexer , p . lineno ( i ) , p . lexpos ( i ) , self . _filename ) [EOL] [EOL] def globalScope ( self ) : [EOL] return self . _globalScope [EOL] [EOL] [comment] [EOL] [comment] [EOL] def p_Definitions ( self , p ) : [EOL] [docstring] [EOL] if p [ [number] ] : [EOL] p [ [number] ] = [ p [ [number] ] ] [EOL] p [ [number] ] . addExtendedAttributes ( p [ [number] ] ) [EOL] else : [EOL] assert not p [ [number] ] [EOL] p [ [number] ] = [ ] [EOL] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_DefinitionsEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_Definition ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] assert p [ [number] ] [comment] [EOL] [EOL] def p_CallbackOrInterfaceOrMixinCallback ( self , p ) : [EOL] [docstring] [EOL] if p [ [number] ] . isInterface ( ) : [EOL] assert isinstance ( p [ [number] ] , IDLInterface ) [EOL] p [ [number] ] . setCallback ( True ) [EOL] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_CallbackOrInterfaceOrMixinInterfaceOrMixin ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_CallbackRestOrInterface ( self , p ) : [EOL] [docstring] [EOL] assert p [ [number] ] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def handleNonPartialObject ( self , location , identifier , constructor , constructorArgs , nonPartialArgs ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] prettyname = constructor . __name__ [ [number] : ] . lower ( ) [EOL] [EOL] try : [EOL] existingObj = self . globalScope ( ) . _lookupIdentifier ( identifier ) [EOL] if existingObj : [EOL] if not isinstance ( existingObj , constructor ) : [EOL] raise WebIDLError ( [string] [string] % ( prettyname . capitalize ( ) , prettyname ) , [ location , existingObj . location ] ) [EOL] existingObj . setNonPartial ( * nonPartialArgs ) [EOL] return existingObj [EOL] except Exception as ex : [EOL] if isinstance ( ex , WebIDLError ) : [EOL] raise ex [EOL] pass [EOL] [EOL] [comment] [EOL] return constructor ( * ( constructorArgs + [ True ] ) ) [EOL] [EOL] def p_InterfaceOrMixin ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_CallbackInterface ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_InterfaceRest ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( location , p [ [number] ] ) [EOL] members = p [ [number] ] [EOL] parent = p [ [number] ] [EOL] [EOL] p [ [number] ] = self . handleNonPartialObject ( location , identifier , IDLInterface , [ location , self . globalScope ( ) , identifier , parent , members ] , [ location , parent , members ] ) [EOL] [EOL] def p_InterfaceForwardDecl ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( location , p [ [number] ] ) [EOL] [EOL] try : [EOL] if self . globalScope ( ) . _lookupIdentifier ( identifier ) : [EOL] p [ [number] ] = self . globalScope ( ) . _lookupIdentifier ( identifier ) [EOL] if not isinstance ( p [ [number] ] , IDLExternalInterface ) : [EOL] raise WebIDLError ( [string] [string] [string] % ( identifier . name , p [ [number] ] ) , [ location , p [ [number] ] . location ] ) [EOL] return [EOL] except Exception as ex : [EOL] if isinstance ( ex , WebIDLError ) : [EOL] raise ex [EOL] pass [EOL] [EOL] p [ [number] ] = IDLExternalInterface ( location , self . globalScope ( ) , identifier ) [EOL] [EOL] def p_MixinRest ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] members = p [ [number] ] [EOL] [EOL] p [ [number] ] = self . handleNonPartialObject ( location , identifier , IDLInterfaceMixin , [ location , self . globalScope ( ) , identifier , members ] , [ location , members ] ) [EOL] [EOL] def p_Namespace ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] members = p [ [number] ] [EOL] [EOL] p [ [number] ] = self . handleNonPartialObject ( location , identifier , IDLNamespace , [ location , self . globalScope ( ) , identifier , members ] , [ location , None , members ] ) [EOL] [EOL] def p_Partial ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_PartialDefinitionInterface ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_PartialDefinition ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def handlePartialObject ( self , location , identifier , nonPartialConstructor , nonPartialConstructorArgs , partialConstructorArgs ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] prettyname = nonPartialConstructor . __name__ [ [number] : ] . lower ( ) [EOL] [EOL] nonPartialObject = None [EOL] try : [EOL] nonPartialObject = self . globalScope ( ) . _lookupIdentifier ( identifier ) [EOL] if nonPartialObject : [EOL] if not isinstance ( nonPartialObject , nonPartialConstructor ) : [EOL] raise WebIDLError ( [string] [string] % ( prettyname , prettyname ) , [ location , nonPartialObject . location ] ) [EOL] except Exception as ex : [EOL] if isinstance ( ex , WebIDLError ) : [EOL] raise ex [EOL] pass [EOL] [EOL] if not nonPartialObject : [EOL] nonPartialObject = nonPartialConstructor ( * (nonPartialConstructorArgs) , members = [ ] , isKnownNonPartial = False ) [EOL] [EOL] partialObject = None [EOL] if isinstance ( nonPartialObject , IDLDictionary ) : [EOL] partialObject = IDLPartialDictionary ( * ( partialConstructorArgs + [ nonPartialObject ] ) ) [EOL] elif isinstance ( nonPartialObject , ( IDLInterface , IDLInterfaceMixin , IDLNamespace ) ) : [EOL] partialObject = IDLPartialInterfaceOrNamespace ( * ( partialConstructorArgs + [ nonPartialObject ] ) ) [EOL] else : [EOL] raise WebIDLError ( [string] % type ( partialObject ) , [ location ] ) [EOL] [EOL] return partialObject [EOL] [EOL] def p_PartialInterfaceOrPartialMixin ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_PartialInterfaceRest ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( location , p [ [number] ] ) [EOL] members = p [ [number] ] [EOL] [EOL] p [ [number] ] = self . handlePartialObject ( location , identifier , IDLInterface , [ location , self . globalScope ( ) , identifier , None ] , [ location , identifier , members ] ) [EOL] [EOL] def p_PartialMixinRest ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] members = p [ [number] ] [EOL] [EOL] p [ [number] ] = self . handlePartialObject ( location , identifier , IDLInterfaceMixin , [ location , self . globalScope ( ) , identifier ] , [ location , identifier , members ] ) [EOL] [EOL] def p_PartialNamespace ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] members = p [ [number] ] [EOL] [EOL] p [ [number] ] = self . handlePartialObject ( location , identifier , IDLNamespace , [ location , self . globalScope ( ) , identifier ] , [ location , identifier , members ] ) [EOL] [EOL] def p_PartialDictionary ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] members = p [ [number] ] [EOL] [EOL] p [ [number] ] = self . handlePartialObject ( location , identifier , IDLDictionary , [ location , self . globalScope ( ) , identifier ] , [ location , identifier , members ] ) [EOL] [EOL] def p_Inheritance ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLIdentifierPlaceholder ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] [EOL] def p_InheritanceEmpty ( self , p ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def p_InterfaceMembers ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] [EOL] [EOL] assert not p [ [number] ] or p [ [number] ] [EOL] p [ [number] ] . addExtendedAttributes ( p [ [number] ] ) [EOL] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_InterfaceMembersEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_InterfaceMember ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_Constructor ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLConstructor ( self . getLocation ( p , [number] ) , p [ [number] ] , [string] ) [EOL] [EOL] def p_PartialInterfaceMembers ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] [EOL] [EOL] assert not p [ [number] ] or p [ [number] ] [EOL] p [ [number] ] . addExtendedAttributes ( p [ [number] ] ) [EOL] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_PartialInterfaceMembersEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_PartialInterfaceMember ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] [EOL] def p_MixinMembersEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_MixinMembers ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] [EOL] [EOL] assert not p [ [number] ] or p [ [number] ] [EOL] p [ [number] ] . addExtendedAttributes ( p [ [number] ] ) [EOL] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_MixinMember ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_Dictionary ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] members = p [ [number] ] [EOL] p [ [number] ] = IDLDictionary ( location , self . globalScope ( ) , identifier , p [ [number] ] , members ) [EOL] [EOL] def p_DictionaryMembers ( self , p ) : [EOL] [docstring] [EOL] if len ( p ) == [number] : [EOL] [comment] [EOL] p [ [number] ] = [ ] [EOL] return [EOL] p [ [number] ] . addExtendedAttributes ( p [ [number] ] ) [EOL] p [ [number] ] = [ p [ [number] ] ] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_DictionaryMemberRequired ( self , p ) : [EOL] [docstring] [EOL] [comment] [EOL] t = p [ [number] ] [EOL] assert isinstance ( t , IDLType ) [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] [EOL] p [ [number] ] = IDLArgument ( self . getLocation ( p , [number] ) , identifier , t , optional = False , defaultValue = None , variadic = False , dictionaryMember = True ) [EOL] [EOL] def p_DictionaryMember ( self , p ) : [EOL] [docstring] [EOL] [comment] [EOL] t = p [ [number] ] [EOL] assert isinstance ( t , IDLType ) [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] defaultValue = p [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] p [ [number] ] = IDLArgument ( self . getLocation ( p , [number] ) , identifier , t , optional = True , defaultValue = defaultValue , variadic = False , dictionaryMember = True , allowTypeAttributes = True ) [EOL] [EOL] def p_Default ( self , p ) : [EOL] [docstring] [EOL] if len ( p ) > [number] : [EOL] p [ [number] ] = p [ [number] ] [EOL] else : [EOL] p [ [number] ] = None [EOL] [EOL] def p_DefaultValue ( self , p ) : [EOL] [docstring] [EOL] if len ( p ) == [number] : [EOL] p [ [number] ] = p [ [number] ] [EOL] else : [EOL] assert len ( p ) == [number] [comment] [EOL] if p [ [number] ] == [string] : [EOL] p [ [number] ] = IDLEmptySequenceValue ( self . getLocation ( p , [number] ) ) [EOL] else : [EOL] assert p [ [number] ] == [string] [EOL] p [ [number] ] = IDLDefaultDictionaryValue ( self . getLocation ( p , [number] ) ) [EOL] [EOL] def p_DefaultValueNull ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLNullValue ( self . getLocation ( p , [number] ) ) [EOL] [EOL] def p_Exception ( self , p ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def p_Enum ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] [EOL] values = p [ [number] ] [EOL] assert values [EOL] p [ [number] ] = IDLEnum ( location , self . globalScope ( ) , identifier , values ) [EOL] [EOL] def p_EnumValueList ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_EnumValueListComma ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_EnumValueListCommaEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_EnumValueListString ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_EnumValueListStringEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_CallbackRest ( self , p ) : [EOL] [docstring] [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] p [ [number] ] = IDLCallback ( self . getLocation ( p , [number] ) , self . globalScope ( ) , identifier , p [ [number] ] , p [ [number] ] , isConstructor = False ) [EOL] [EOL] def p_CallbackConstructorRest ( self , p ) : [EOL] [docstring] [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] p [ [number] ] = IDLCallback ( self . getLocation ( p , [number] ) , self . globalScope ( ) , identifier , p [ [number] ] , p [ [number] ] , isConstructor = True ) [EOL] [EOL] def p_ExceptionMembers ( self , p ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def p_Typedef ( self , p ) : [EOL] [docstring] [EOL] typedef = IDLTypedef ( self . getLocation ( p , [number] ) , self . globalScope ( ) , p [ [number] ] , p [ [number] ] ) [EOL] p [ [number] ] = typedef [EOL] [EOL] def p_IncludesStatement ( self , p ) : [EOL] [docstring] [EOL] assert ( p [ [number] ] == [string] ) [EOL] interface = IDLIdentifierPlaceholder ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] mixin = IDLIdentifierPlaceholder ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] p [ [number] ] = IDLIncludesStatement ( self . getLocation ( p , [number] ) , interface , mixin ) [EOL] [EOL] def p_Const ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] type = p [ [number] ] [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] value = p [ [number] ] [EOL] p [ [number] ] = IDLConst ( location , identifier , type , value ) [EOL] [EOL] def p_ConstValueBoolean ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] booleanType = BuiltinTypes [ IDLBuiltinType . Types . boolean ] [EOL] p [ [number] ] = IDLValue ( location , booleanType , p [ [number] ] ) [EOL] [EOL] def p_ConstValueInteger ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] integerType = matchIntegerValueToType ( p [ [number] ] ) [EOL] if integerType is None : [EOL] raise WebIDLError ( [string] , [ location ] ) [EOL] [EOL] p [ [number] ] = IDLValue ( location , integerType , p [ [number] ] ) [EOL] [EOL] def p_ConstValueFloat ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] p [ [number] ] = IDLValue ( location , BuiltinTypes [ IDLBuiltinType . Types . unrestricted_float ] , p [ [number] ] ) [EOL] [EOL] def p_ConstValueString ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] stringType = BuiltinTypes [ IDLBuiltinType . Types . domstring ] [EOL] p [ [number] ] = IDLValue ( location , stringType , p [ [number] ] ) [EOL] [EOL] def p_BooleanLiteralTrue ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = True [EOL] [EOL] def p_BooleanLiteralFalse ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = False [EOL] [EOL] def p_AttributeOrOperationOrMaplikeOrSetlikeOrIterable ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_Iterable ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( location , [string] , allowDoubleUnderscore = True ) [EOL] if ( len ( p ) > [number] ) : [EOL] keyType = p [ [number] ] [EOL] valueType = p [ [number] ] [EOL] else : [EOL] keyType = None [EOL] valueType = p [ [number] ] [EOL] [EOL] p [ [number] ] = IDLIterable ( location , identifier , keyType , valueType , self . globalScope ( ) ) [EOL] [EOL] def p_Setlike ( self , p ) : [EOL] [docstring] [EOL] readonly = p [ [number] ] [EOL] maplikeOrSetlikeType = p [ [number] ] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( location , [string] , allowDoubleUnderscore = True ) [EOL] keyType = p [ [number] ] [EOL] valueType = keyType [EOL] p [ [number] ] = IDLMaplikeOrSetlike ( location , identifier , maplikeOrSetlikeType , readonly , keyType , valueType ) [EOL] [EOL] def p_Maplike ( self , p ) : [EOL] [docstring] [EOL] readonly = p [ [number] ] [EOL] maplikeOrSetlikeType = p [ [number] ] [EOL] location = self . getLocation ( p , [number] ) [EOL] identifier = IDLUnresolvedIdentifier ( location , [string] , allowDoubleUnderscore = True ) [EOL] keyType = p [ [number] ] [EOL] valueType = p [ [number] ] [EOL] p [ [number] ] = IDLMaplikeOrSetlike ( location , identifier , maplikeOrSetlikeType , readonly , keyType , valueType ) [EOL] [EOL] def p_AttributeWithQualifier ( self , p ) : [EOL] [docstring] [EOL] static = IDLInterfaceMember . Special . Static in p [ [number] ] [EOL] stringifier = IDLInterfaceMember . Special . Stringifier in p [ [number] ] [EOL] ( location , identifier , type , readonly ) = p [ [number] ] [EOL] p [ [number] ] = IDLAttribute ( location , identifier , type , readonly , static = static , stringifier = stringifier ) [EOL] [EOL] def p_AttributeInherited ( self , p ) : [EOL] [docstring] [EOL] ( location , identifier , type , readonly ) = p [ [number] ] [EOL] p [ [number] ] = IDLAttribute ( location , identifier , type , readonly , inherit = True ) [EOL] [EOL] def p_Attribute ( self , p ) : [EOL] [docstring] [EOL] ( location , identifier , type , readonly ) = p [ [number] ] [EOL] p [ [number] ] = IDLAttribute ( location , identifier , type , readonly , inherit = False ) [EOL] [EOL] def p_AttributeRest ( self , p ) : [EOL] [docstring] [EOL] location = self . getLocation ( p , [number] ) [EOL] readonly = p [ [number] ] [EOL] t = p [ [number] ] [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] p [ [number] ] = ( location , identifier , t , readonly ) [EOL] [EOL] def p_ReadOnly ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = True [EOL] [EOL] def p_ReadOnlyEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = False [EOL] [EOL] def p_Operation ( self , p ) : [EOL] [docstring] [EOL] qualifiers = p [ [number] ] [EOL] [EOL] [comment] [EOL] if not len ( set ( qualifiers ) ) == len ( qualifiers ) : [EOL] raise WebIDLError ( [string] , [ self . getLocation ( p , [number] ) ] ) [EOL] [EOL] static = IDLInterfaceMember . Special . Static in p [ [number] ] [EOL] [comment] [EOL] [comment] [EOL] assert not static or len ( qualifiers ) == [number] [EOL] [EOL] stringifier = IDLInterfaceMember . Special . Stringifier in p [ [number] ] [EOL] [comment] [EOL] [comment] [EOL] assert not stringifier or len ( qualifiers ) == [number] [EOL] [EOL] getter = True if IDLMethod . Special . Getter in p [ [number] ] else False [EOL] setter = True if IDLMethod . Special . Setter in p [ [number] ] else False [EOL] deleter = True if IDLMethod . Special . Deleter in p [ [number] ] else False [EOL] legacycaller = True if IDLMethod . Special . LegacyCaller in p [ [number] ] else False [EOL] [EOL] if getter or deleter : [EOL] if setter : [EOL] raise WebIDLError ( [string] , [ self . getLocation ( p , [number] ) ] ) [EOL] [EOL] ( returnType , identifier , arguments ) = p [ [number] ] [EOL] [EOL] assert isinstance ( returnType , IDLType ) [EOL] [EOL] specialType = IDLMethod . NamedOrIndexed . Neither [EOL] [EOL] if getter or deleter : [EOL] if len ( arguments ) != [number] : [EOL] raise WebIDLError ( [string] % ( [string] if getter else [string] ) , [ self . getLocation ( p , [number] ) ] ) [EOL] argType = arguments [ [number] ] . type [EOL] if argType == BuiltinTypes [ IDLBuiltinType . Types . domstring ] : [EOL] specialType = IDLMethod . NamedOrIndexed . Named [EOL] elif argType == BuiltinTypes [ IDLBuiltinType . Types . unsigned_long ] : [EOL] specialType = IDLMethod . NamedOrIndexed . Indexed [EOL] if deleter : [EOL] raise WebIDLError ( [string] , [ self . getLocation ( p , [number] ) ] ) [EOL] else : [EOL] raise WebIDLError ( [string] % ( [string] if getter else [string] ) , [ arguments [ [number] ] . location ] ) [EOL] if arguments [ [number] ] . optional or arguments [ [number] ] . variadic : [EOL] raise WebIDLError ( [string] % ( [string] if getter else [string] , [string] if arguments [ [number] ] . optional else [string] ) , [ arguments [ [number] ] . location ] ) [EOL] if getter : [EOL] if returnType . isVoid ( ) : [EOL] raise WebIDLError ( [string] , [ self . getLocation ( p , [number] ) ] ) [EOL] if setter : [EOL] if len ( arguments ) != [number] : [EOL] raise WebIDLError ( [string] , [ self . getLocation ( p , [number] ) ] ) [EOL] argType = arguments [ [number] ] . type [EOL] if argType == BuiltinTypes [ IDLBuiltinType . Types . domstring ] : [EOL] specialType = IDLMethod . NamedOrIndexed . Named [EOL] elif argType == BuiltinTypes [ IDLBuiltinType . Types . unsigned_long ] : [EOL] specialType = IDLMethod . NamedOrIndexed . Indexed [EOL] else : [EOL] raise WebIDLError ( [string] , [ arguments [ [number] ] . location ] ) [EOL] if arguments [ [number] ] . optional or arguments [ [number] ] . variadic : [EOL] raise WebIDLError ( [string] % ( [string] if arguments [ [number] ] . optional else [string] ) , [ arguments [ [number] ] . location ] ) [EOL] if arguments [ [number] ] . optional or arguments [ [number] ] . variadic : [EOL] raise WebIDLError ( [string] % ( [string] if arguments [ [number] ] . optional else [string] ) , [ arguments [ [number] ] . location ] ) [EOL] [EOL] if stringifier : [EOL] if len ( arguments ) != [number] : [EOL] raise WebIDLError ( [string] , [ self . getLocation ( p , [number] ) ] ) [EOL] if not returnType . isDOMString ( ) : [EOL] raise WebIDLError ( [string] , [ self . getLocation ( p , [number] ) ] ) [EOL] [EOL] [comment] [EOL] if not identifier : [EOL] if ( not getter and not setter and not deleter and not legacycaller and not stringifier ) : [EOL] raise WebIDLError ( [string] , [ self . getLocation ( p , [number] ) ] ) [EOL] [EOL] location = BuiltinLocation ( [string] ) [EOL] identifier = IDLUnresolvedIdentifier ( location , [string] % ( [string] if specialType == IDLMethod . NamedOrIndexed . Named else [EOL] [string] if specialType == IDLMethod . NamedOrIndexed . Indexed else [string] , [string] if getter else [string] , [string] if setter else [string] , [string] if deleter else [string] , [string] if legacycaller else [string] , [string] if stringifier else [string] ) , allowDoubleUnderscore = True ) [EOL] [EOL] method = IDLMethod ( self . getLocation ( p , [number] ) , identifier , returnType , arguments , static = static , getter = getter , setter = setter , deleter = deleter , specialType = specialType , legacycaller = legacycaller , stringifier = stringifier ) [EOL] p [ [number] ] = method [EOL] [EOL] def p_Stringifier ( self , p ) : [EOL] [docstring] [EOL] identifier = IDLUnresolvedIdentifier ( BuiltinLocation ( [string] ) , [string] , allowDoubleUnderscore = True ) [EOL] method = IDLMethod ( self . getLocation ( p , [number] ) , identifier , returnType = BuiltinTypes [ IDLBuiltinType . Types . domstring ] , arguments = [ ] , stringifier = True ) [EOL] p [ [number] ] = method [EOL] [EOL] def p_QualifierStatic ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ IDLInterfaceMember . Special . Static ] [EOL] [EOL] def p_QualifierStringifier ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ IDLInterfaceMember . Special . Stringifier ] [EOL] [EOL] def p_Qualifiers ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_Specials ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_SpecialsEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_SpecialGetter ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLMethod . Special . Getter [EOL] [EOL] def p_SpecialSetter ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLMethod . Special . Setter [EOL] [EOL] def p_SpecialDeleter ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLMethod . Special . Deleter [EOL] [EOL] def p_SpecialLegacyCaller ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLMethod . Special . LegacyCaller [EOL] [EOL] def p_OperationRest ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = ( p [ [number] ] , p [ [number] ] , p [ [number] ] ) [EOL] [EOL] def p_OptionalIdentifier ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] [EOL] def p_OptionalIdentifierEmpty ( self , p ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def p_ArgumentList ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] if p [ [number] ] else [ ] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_ArgumentListEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_Arguments ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] if p [ [number] ] else [ ] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_ArgumentsEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_Argument ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] p [ [number] ] . addExtendedAttributes ( p [ [number] ] ) [EOL] [EOL] def p_ArgumentRestOptional ( self , p ) : [EOL] [docstring] [EOL] t = p [ [number] ] [EOL] assert isinstance ( t , IDLType ) [EOL] [comment] [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] , allowForbidden = True ) [EOL] [EOL] defaultValue = p [ [number] ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] p [ [number] ] = IDLArgument ( self . getLocation ( p , [number] ) , identifier , t , True , defaultValue , False ) [EOL] [EOL] def p_ArgumentRest ( self , p ) : [EOL] [docstring] [EOL] t = p [ [number] ] [EOL] assert isinstance ( t , IDLType ) [EOL] [comment] [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] , allowForbidden = True ) [EOL] [EOL] variadic = p [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] p [ [number] ] = IDLArgument ( self . getLocation ( p , [number] ) , identifier , t , variadic , None , variadic , allowTypeAttributes = True ) [EOL] [EOL] def p_ArgumentName ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_ArgumentNameKeyword ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_AttributeName ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_AttributeNameKeyword ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_Ellipsis ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = True [EOL] [EOL] def p_EllipsisEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = False [EOL] [EOL] def p_ExceptionMember ( self , p ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def p_ExceptionField ( self , p ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def p_ExtendedAttributeList ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] [EOL] if p [ [number] ] : [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_ExtendedAttributeListEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_ExtendedAttribute ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLExtendedAttribute ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] [EOL] def p_ExtendedAttributeEmpty ( self , p ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def p_ExtendedAttributes ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] if p [ [number] ] else [ ] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_ExtendedAttributesEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_Other ( self , p ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def p_OtherOrComma ( self , p ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def p_TypeSingleType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_TypeUnionType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = self . handleNullable ( p [ [number] ] , p [ [number] ] ) [EOL] [EOL] def p_TypeWithExtendedAttributes ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] . withExtendedAttributes ( p [ [number] ] ) [EOL] [EOL] def p_SingleTypeDistinguishableType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_SingleTypeAnyType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = BuiltinTypes [ IDLBuiltinType . Types . any ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def p_SingleTypePromiseType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLPromiseType ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] [EOL] def p_UnionType ( self , p ) : [EOL] [docstring] [EOL] types = [ p [ [number] ] , p [ [number] ] ] [EOL] types . extend ( p [ [number] ] ) [EOL] p [ [number] ] = IDLUnionType ( self . getLocation ( p , [number] ) , types ) [EOL] [EOL] def p_UnionMemberTypeDistinguishableType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] . withExtendedAttributes ( p [ [number] ] ) [EOL] [EOL] def p_UnionMemberType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = self . handleNullable ( p [ [number] ] , p [ [number] ] ) [EOL] [EOL] def p_UnionMemberTypes ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ p [ [number] ] ] [EOL] p [ [number] ] . extend ( p [ [number] ] ) [EOL] [EOL] def p_UnionMemberTypesEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_DistinguishableType ( self , p ) : [EOL] [docstring] [EOL] if p [ [number] ] == [string] : [EOL] type = BuiltinTypes [ IDLBuiltinType . Types . object ] [EOL] elif p [ [number] ] == [string] : [EOL] type = BuiltinTypes [ IDLBuiltinType . Types . ArrayBuffer ] [EOL] elif p [ [number] ] == [string] : [EOL] type = BuiltinTypes [ IDLBuiltinType . Types . ReadableStream ] [EOL] else : [EOL] type = BuiltinTypes [ p [ [number] ] ] [EOL] [EOL] p [ [number] ] = self . handleNullable ( type , p [ [number] ] ) [EOL] [EOL] def p_DistinguishableTypeStringType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = self . handleNullable ( p [ [number] ] , p [ [number] ] ) [EOL] [EOL] def p_DistinguishableTypeSequenceType ( self , p ) : [EOL] [docstring] [EOL] innerType = p [ [number] ] [EOL] type = IDLSequenceType ( self . getLocation ( p , [number] ) , innerType ) [EOL] p [ [number] ] = self . handleNullable ( type , p [ [number] ] ) [EOL] [EOL] def p_DistinguishableTypeRecordType ( self , p ) : [EOL] [docstring] [EOL] keyType = p [ [number] ] [EOL] valueType = p [ [number] ] [EOL] type = IDLRecordType ( self . getLocation ( p , [number] ) , keyType , valueType ) [EOL] p [ [number] ] = self . handleNullable ( type , p [ [number] ] ) [EOL] [EOL] def p_DistinguishableTypeScopedName ( self , p ) : [EOL] [docstring] [EOL] assert isinstance ( p [ [number] ] , IDLUnresolvedIdentifier ) [EOL] [EOL] if p [ [number] ] . name == [string] : [EOL] raise WebIDLError ( [string] [string] , [ self . getLocation ( p , [number] ) ] ) [EOL] [EOL] type = None [EOL] [EOL] try : [EOL] if self . globalScope ( ) . _lookupIdentifier ( p [ [number] ] ) : [EOL] obj = self . globalScope ( ) . _lookupIdentifier ( p [ [number] ] ) [EOL] assert not obj . isType ( ) [EOL] if obj . isTypedef ( ) : [EOL] type = IDLTypedefType ( self . getLocation ( p , [number] ) , obj . innerType , obj . identifier . name ) [EOL] elif obj . isCallback ( ) and not obj . isInterface ( ) : [EOL] type = IDLCallbackType ( obj . location , obj ) [EOL] else : [EOL] type = IDLWrapperType ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] p [ [number] ] = self . handleNullable ( type , p [ [number] ] ) [EOL] return [EOL] except : [EOL] pass [EOL] [EOL] type = IDLUnresolvedType ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] p [ [number] ] = self . handleNullable ( type , p [ [number] ] ) [EOL] [EOL] def p_ConstType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = BuiltinTypes [ p [ [number] ] ] [EOL] [EOL] def p_ConstTypeIdentifier ( self , p ) : [EOL] [docstring] [EOL] identifier = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] [EOL] p [ [number] ] = IDLUnresolvedType ( self . getLocation ( p , [number] ) , identifier ) [EOL] [EOL] def p_PrimitiveTypeUint ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_PrimitiveTypeBoolean ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . boolean [EOL] [EOL] def p_PrimitiveTypeByte ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . byte [EOL] [EOL] def p_PrimitiveTypeOctet ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . octet [EOL] [EOL] def p_PrimitiveTypeFloat ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . float [EOL] [EOL] def p_PrimitiveTypeUnrestictedFloat ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . unrestricted_float [EOL] [EOL] def p_PrimitiveTypeDouble ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . double [EOL] [EOL] def p_PrimitiveTypeUnrestictedDouble ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . unrestricted_double [EOL] [EOL] def p_StringType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = BuiltinTypes [ p [ [number] ] ] [EOL] [EOL] def p_BuiltinStringTypeDOMString ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . domstring [EOL] [EOL] def p_BuiltinStringTypeBytestring ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . bytestring [EOL] [EOL] def p_BuiltinStringTypeUSVString ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . usvstring [EOL] [EOL] def p_BuiltinStringTypeUTF8String ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . utf8string [EOL] [EOL] def p_BuiltinStringTypeJSString ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . jsstring [EOL] [EOL] def p_UnsignedIntegerTypeUnsigned ( self , p ) : [EOL] [docstring] [EOL] [comment] [EOL] p [ [number] ] = p [ [number] ] + [number] [EOL] [EOL] def p_UnsignedIntegerType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_IntegerTypeShort ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = IDLBuiltinType . Types . short [EOL] [EOL] def p_IntegerTypeLong ( self , p ) : [EOL] [docstring] [EOL] if p [ [number] ] : [EOL] p [ [number] ] = IDLBuiltinType . Types . long_long [EOL] else : [EOL] p [ [number] ] = IDLBuiltinType . Types . long [EOL] [EOL] def p_OptionalLong ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = True [EOL] [EOL] def p_OptionalLongEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = False [EOL] [EOL] def p_Null ( self , p ) : [EOL] [docstring] [EOL] if len ( p ) > [number] : [EOL] p [ [number] ] = self . getLocation ( p , [number] ) [EOL] else : [EOL] p [ [number] ] = None [EOL] [EOL] def p_ReturnTypeType ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_ReturnTypeVoid ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = BuiltinTypes [ IDLBuiltinType . Types . void ] [EOL] [EOL] def p_ScopedName ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = p [ [number] ] [EOL] [EOL] def p_AbsoluteScopedName ( self , p ) : [EOL] [docstring] [EOL] assert False [EOL] pass [EOL] [EOL] def p_RelativeScopedName ( self , p ) : [EOL] [docstring] [EOL] assert not p [ [number] ] [comment] [EOL] [EOL] p [ [number] ] = IDLUnresolvedIdentifier ( self . getLocation ( p , [number] ) , p [ [number] ] ) [EOL] [EOL] def p_ScopedNameParts ( self , p ) : [EOL] [docstring] [EOL] assert False [EOL] pass [EOL] [EOL] def p_ScopedNamePartsEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = None [EOL] [EOL] def p_ExtendedAttributeNoArgs ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = ( p [ [number] ] , ) [EOL] [EOL] def p_ExtendedAttributeArgList ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = ( p [ [number] ] , p [ [number] ] ) [EOL] [EOL] def p_ExtendedAttributeIdent ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = ( p [ [number] ] , p [ [number] ] ) [EOL] [EOL] def p_ExtendedAttributeNamedArgList ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = ( p [ [number] ] , p [ [number] ] , p [ [number] ] ) [EOL] [EOL] def p_ExtendedAttributeIdentList ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = ( p [ [number] ] , p [ [number] ] ) [EOL] [EOL] def p_IdentifierList ( self , p ) : [EOL] [docstring] [EOL] idents = list ( p [ [number] ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ident = p [ [number] ] [EOL] if ident [ [number] ] == [string] : [EOL] ident = ident [ [number] : ] [EOL] idents . insert ( [number] , ident ) [EOL] p [ [number] ] = idents [EOL] [EOL] def p_IdentifiersList ( self , p ) : [EOL] [docstring] [EOL] idents = list ( p [ [number] ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ident = p [ [number] ] [EOL] if ident [ [number] ] == [string] : [EOL] ident = ident [ [number] : ] [EOL] idents . insert ( [number] , ident ) [EOL] p [ [number] ] = idents [EOL] [EOL] def p_IdentifiersEmpty ( self , p ) : [EOL] [docstring] [EOL] p [ [number] ] = [ ] [EOL] [EOL] def p_error ( self , p ) : [EOL] if not p : [EOL] raise WebIDLError ( [string] , [ self . _filename ] ) [EOL] else : [EOL] raise WebIDLError ( [string] , [ Location ( self . lexer , p . lineno , p . lexpos , self . _filename ) ] ) [EOL] [EOL] def __init__ ( self , outputdir = [string] , lexer = None ) : [EOL] Tokenizer . __init__ ( self , outputdir , lexer ) [EOL] [EOL] logger = SqueakyCleanLogger ( ) [EOL] try : [EOL] self . parser = yacc . yacc ( module = self , outputdir = outputdir , tabmodule = [string] , errorlog = logger , debug = False ) [EOL] finally : [EOL] logger . reportGrammarErrors ( ) [EOL] [EOL] self . _globalScope = IDLScope ( BuiltinLocation ( [string] ) , None , None ) [EOL] [EOL] self . _installBuiltins ( self . _globalScope ) [EOL] self . _productions = [ ] [EOL] [EOL] self . _filename = [string] [EOL] self . lexer . input ( Parser . _builtins ) [EOL] self . _filename = None [EOL] [EOL] self . parser . parse ( lexer = self . lexer , tracking = True ) [EOL] [EOL] def _installBuiltins ( self , scope ) : [EOL] assert isinstance ( scope , IDLScope ) [EOL] [EOL] [comment] [EOL] for x in range ( IDLBuiltinType . Types . ArrayBuffer , IDLBuiltinType . Types . Float64Array + [number] ) : [EOL] builtin = BuiltinTypes [ x ] [EOL] name = builtin . name [EOL] typedef = IDLTypedef ( BuiltinLocation ( [string] ) , scope , builtin , name ) [EOL] [EOL] @ staticmethod def handleNullable ( type , questionMarkLocation ) : [EOL] if questionMarkLocation is not None : [EOL] type = IDLNullableType ( questionMarkLocation , type ) [EOL] [EOL] return type [EOL] [EOL] def parse ( self , t , filename = None ) : [EOL] self . lexer . input ( t ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] self . _filename = filename [EOL] self . _productions . extend ( self . parser . parse ( lexer = self . lexer , tracking = True ) ) [EOL] self . _filename = None [EOL] [EOL] def finish ( self ) : [EOL] [comment] [EOL] [comment] [EOL] interfaceStatements = [ ] [EOL] for p in self . _productions : [EOL] if isinstance ( p , IDLInterface ) : [EOL] interfaceStatements . append ( p ) [EOL] [EOL] iterableIteratorIface = None [EOL] for iface in interfaceStatements : [EOL] iterable = None [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for m in iface . members : [EOL] if isinstance ( m , IDLIterable ) : [EOL] iterable = m [EOL] break [EOL] if iterable and iterable . isPairIterator ( ) : [EOL] def simpleExtendedAttr ( str ) : [EOL] return IDLExtendedAttribute ( iface . location , ( str , ) ) [EOL] nextMethod = IDLMethod ( iface . location , IDLUnresolvedIdentifier ( iface . location , [string] ) , BuiltinTypes [ IDLBuiltinType . Types . object ] , [ ] ) [EOL] nextMethod . addExtendedAttributes ( [ simpleExtendedAttr ( [string] ) ] ) [EOL] itr_ident = IDLUnresolvedIdentifier ( iface . location , iface . identifier . name + [string] ) [EOL] toStringTag = iface . identifier . name + [string] [EOL] itr_iface = IDLInterface ( iface . location , self . globalScope ( ) , itr_ident , None , [ nextMethod ] , isKnownNonPartial = True , classNameOverride = toStringTag , toStringTag = toStringTag ) [EOL] itr_iface . addExtendedAttributes ( [ simpleExtendedAttr ( [string] ) ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] itr_iface . _exposureGlobalNames = set ( iface . _exposureGlobalNames ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] itr_iface . iterableInterface = iface [EOL] self . _productions . append ( itr_iface ) [EOL] iterable . iteratorType = IDLWrapperType ( iface . location , itr_iface ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] includesStatements = [ p for p in self . _productions if isinstance ( p , IDLIncludesStatement ) ] [EOL] otherStatements = [ p for p in self . _productions if not isinstance ( p , IDLIncludesStatement ) ] [EOL] for production in includesStatements : [EOL] production . finish ( self . globalScope ( ) ) [EOL] for production in otherStatements : [EOL] production . finish ( self . globalScope ( ) ) [EOL] [EOL] [comment] [EOL] for production in self . _productions : [EOL] production . validate ( ) [EOL] [EOL] [comment] [EOL] seen = set ( ) [EOL] result = [ ] [EOL] for p in self . _productions : [EOL] if p not in seen : [EOL] seen . add ( p ) [EOL] result . append ( p ) [EOL] return result [EOL] [EOL] def reset ( self ) : [EOL] return Parser ( lexer = self . lexer ) [EOL] [EOL] [comment] [EOL] _builtins = [string] [EOL] [EOL] [EOL] def main ( ) : [EOL] [comment] [EOL] from optparse import OptionParser [EOL] usageString = [string] [EOL] o = OptionParser ( usage = usageString ) [EOL] o . add_option ( [string] , dest = [string] , default = None , help = [string] ) [EOL] o . add_option ( [string] , action = [string] , default = False , help = [string] ) [EOL] ( options , args ) = o . parse_args ( ) [EOL] [EOL] if len ( args ) < [number] : [EOL] o . error ( usageString ) [EOL] [EOL] fileList = args [EOL] baseDir = os . getcwd ( ) [EOL] [EOL] [comment] [EOL] parser = Parser ( options . cachedir ) [EOL] try : [EOL] for filename in fileList : [EOL] fullPath = os . path . normpath ( os . path . join ( baseDir , filename ) ) [EOL] f = open ( fullPath , [string] ) [EOL] lines = f . readlines ( ) [EOL] f . close ( ) [EOL] print ( fullPath ) [EOL] parser . parse ( [string] . join ( lines ) , fullPath ) [EOL] parser . finish ( ) [EOL] except WebIDLError as e : [EOL] if options . verbose_errors : [EOL] traceback . print_exc ( ) [EOL] else : [EOL] print ( e ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLPartialInterfaceOrNamespace$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLPartialInterfaceOrNamespace$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLPartialInterfaceOrNamespace$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLPartialInterfaceOrNamespace$ 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLPartialInterfaceOrNamespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLTypedef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLTypedef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLIdentifierPlaceholder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLIdentifierPlaceholder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLIdentifierPlaceholder$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLIdentifierPlaceholder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.BuiltinLocation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.BuiltinLocation$ 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.BuiltinLocation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.BuiltinLocation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.BuiltinLocation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.BuiltinLocation$ 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.BuiltinLocation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLMethod$ 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 $typing.Union[typing_extensions.Literal[typing_extensions.Literal],typing_extensions.Literal[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLMethod$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLMethod$ 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLMethod$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLSequenceType$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLSequenceType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLRecordType$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLRecordType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedType$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedType$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.SqueakyCleanLogger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.SqueakyCleanLogger$ 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.SqueakyCleanLogger$ 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLScope$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLScope$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLTypedef$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLNullableType$ 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLNullableType$ 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLNullableType$ 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLNullableType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLIterable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLIterable$ 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLIterable$ 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLIterable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLMethod$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLMethod$ 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLInterface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLUnresolvedIdentifier$ 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLMethod$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLInterface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLInterface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLInterface$ 0 0 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLInterface$ 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLIterable$ 0 0 0 0 0 0 0 0 0 $components.script.dom.bindings.codegen.parser.WebIDL.IDLInterface$ 0 0 0 0 0 0 0 0 0 $typing.List[components.script.dom.bindings.codegen.parser.WebIDL.IDLIncludesStatement]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[components.script.dom.bindings.codegen.parser.WebIDL.IDLIncludesStatement]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import optparse [EOL] import components [EOL] import typing [EOL] import os , sys [EOL] import glob [EOL] import optparse [EOL] import traceback [EOL] import WebIDL [EOL] [EOL] class TestHarness ( object ) : [EOL] def __init__ ( self , test , verbose ) : [EOL] self . test = test [EOL] self . verbose = verbose [EOL] self . printed_intro = False [EOL] [EOL] def start ( self ) : [EOL] if self . verbose : [EOL] self . maybe_print_intro ( ) [EOL] [EOL] def finish ( self ) : [EOL] if self . verbose or self . printed_intro : [EOL] print ( [string] % self . test ) [EOL] [EOL] def maybe_print_intro ( self ) : [EOL] if not self . printed_intro : [EOL] print ( [string] % self . test ) [EOL] self . printed_intro = True [EOL] [EOL] def test_pass ( self , msg ) : [EOL] if self . verbose : [EOL] print ( [string] % msg ) [EOL] [EOL] def test_fail ( self , msg ) : [EOL] self . maybe_print_intro ( ) [EOL] print ( [string] % msg ) [EOL] [EOL] def ok ( self , condition , msg ) : [EOL] if condition : [EOL] self . test_pass ( msg ) [EOL] else : [EOL] self . test_fail ( msg ) [EOL] [EOL] def check ( self , a , b , msg ) : [EOL] if a == b : [EOL] self . test_pass ( msg ) [EOL] else : [EOL] self . test_fail ( msg ) [EOL] print ( [string] % ( a , b ) ) [EOL] [EOL] def run_tests ( tests , verbose ) : [EOL] testdir = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] if not tests : [EOL] tests = glob . iglob ( os . path . join ( testdir , [string] ) ) [EOL] sys . path . append ( testdir ) [EOL] [EOL] for test in tests : [EOL] ( testpath , ext ) = os . path . splitext ( os . path . basename ( test ) ) [EOL] _test = __import__ ( testpath , globals ( ) , locals ( ) , [ [string] ] ) [EOL] [EOL] harness = TestHarness ( test , verbose ) [EOL] harness . start ( ) [EOL] try : [EOL] _test . WebIDLTest . __call__ ( WebIDL . Parser ( ) , harness ) [EOL] except Exception as ex : [EOL] print ( [string] % ( testpath , ex ) ) [EOL] traceback . print_exc ( ) [EOL] finally : [EOL] harness . finish ( ) [EOL] [EOL] if __name__ == [string] : [EOL] usage = [string] [EOL] parser = optparse . OptionParser ( usage = usage ) [EOL] parser . add_option ( [string] , [string] , action = [string] , dest = [string] , default = True , help = [string] ) [EOL] options , tests = parser . parse_args ( ) [EOL] [EOL] run_tests ( tests , verbose = options . verbose ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $optparse.OptionParser$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $optparse.OptionParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $optparse.OptionParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) ; [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] [comment] [EOL] expectedNames = sorted ( [ [string] , [string] ] ) [EOL] actualNames = sorted ( map ( lambda iface : iface . identifier . name , results ) ) [EOL] harness . check ( actualNames , expectedNames , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] def firstArgType ( method ) : [EOL] return method . signatures ( ) [ [number] ] [ [number] ] [ [number] ] . type [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] [EOL] iface = results [ [number] ] [EOL] harness . ok ( iface . isInterface ( ) , [string] ) [EOL] dictMethod = iface . members [ [number] ] [EOL] ifaceMethod = iface . members [ [number] ] [EOL] nullableUnionMethod = iface . members [ [number] ] [EOL] nullableIfaceMethod = iface . members [ [number] ] [EOL] [EOL] dictType = firstArgType ( dictMethod ) [EOL] ifaceType = firstArgType ( ifaceMethod ) [EOL] [EOL] harness . ok ( dictType . isDictionary ( ) , [string] ) ; [EOL] harness . ok ( ifaceType . isInterface ( ) , [string] ) ; [EOL] harness . ok ( ifaceType . isCallbackInterface ( ) , [string] ) ; [EOL] [EOL] harness . ok ( not dictType . isDistinguishableFrom ( ifaceType ) , [string] ) [EOL] harness . ok ( not ifaceType . isDistinguishableFrom ( dictType ) , [string] ) [EOL] [EOL] nullableUnionType = firstArgType ( nullableUnionMethod ) [EOL] nullableIfaceType = firstArgType ( nullableIfaceMethod ) [EOL] [EOL] harness . ok ( nullableUnionType . isUnion ( ) , [string] ) ; [EOL] harness . ok ( nullableIfaceType . isInterface ( ) , [string] ) ; [EOL] harness . ok ( nullableIfaceType . nullable ( ) , [string] ) ; [EOL] [EOL] harness . ok ( not nullableUnionType . isDistinguishableFrom ( nullableIfaceType ) , [string] [string] ) [EOL] harness . ok ( not nullableIfaceType . isDistinguishableFrom ( nullableUnionType ) , [string] [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] [EOL] iface = results [ [number] ] [EOL] harness . ok ( iface . isInterface ( ) , [string] ) [EOL] argTypes = [ firstArgType ( method ) for method in iface . members ] [EOL] unrelatedTypes = [ firstArgType ( method ) for method in iface . members [ - [number] : ] ] [EOL] [EOL] for type1 in argTypes : [EOL] for type2 in argTypes : [EOL] distinguishable = ( type1 is not type2 and ( type1 in unrelatedTypes or type2 in unrelatedTypes ) ) [EOL] [EOL] harness . check ( type1 . isDistinguishableFrom ( type2 ) , distinguishable , [string] % ( type1 , [string] if distinguishable else [string] , type2 ) ) [EOL] harness . check ( type2 . isDistinguishableFrom ( type1 ) , distinguishable , [string] % ( type2 , [string] if distinguishable else [string] , type1 ) ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . check ( len ( results [ [number] ] . members [ [number] ] . signatures ( ) ) , [number] , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] [comment] [EOL] argTypes = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] def allBut ( list1 , list2 ) : [EOL] return [ a for a in list1 if a not in list2 and ( a != [string] and a != [string] and a != [string] ) ] [EOL] unions = [ [string] , [string] ] [EOL] numerics = [ [string] , [string] , [string] , [string] ] [EOL] booleans = [ [string] , [string] ] [EOL] primitives = numerics + booleans [EOL] nonNumerics = allBut ( argTypes , numerics + unions ) [EOL] nonBooleans = allBut ( argTypes , booleans ) [EOL] strings = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] nonStrings = allBut ( argTypes , strings ) [EOL] nonObjects = primitives + strings [EOL] objects = allBut ( argTypes , nonObjects ) [EOL] bufferSourceTypes = [ [string] , [string] , [string] , [string] ] [EOL] interfaces = [ [string] , [string] , [string] , [string] ] + bufferSourceTypes [EOL] nullables = ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] + allBut ( unions , [ [string] ] ) ) [EOL] sequences = [ [string] , [string] ] [EOL] nonUserObjects = nonObjects + interfaces + sequences [EOL] otherObjects = allBut ( argTypes , nonUserObjects + [ [string] ] ) [EOL] notRelatedInterfaces = ( nonObjects + [ [string] ] + otherObjects + sequences + bufferSourceTypes ) [EOL] records = [ [string] , [string] , [string] , [string] ] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] data = dict ( ) [EOL] for type in argTypes : [EOL] data [ type ] = dict ( ) [EOL] def setDistinguishable ( type , types ) : [EOL] for other in types : [EOL] data [ type ] [ other ] = True [EOL] [EOL] setDistinguishable ( [string] , nonNumerics ) [EOL] setDistinguishable ( [string] , nonNumerics ) [EOL] setDistinguishable ( [string] , allBut ( nonNumerics , nullables ) ) [EOL] setDistinguishable ( [string] , allBut ( nonNumerics , nullables ) ) [EOL] setDistinguishable ( [string] , nonBooleans ) [EOL] setDistinguishable ( [string] , allBut ( nonBooleans , nullables ) ) [EOL] setDistinguishable ( [string] , nonStrings ) [EOL] setDistinguishable ( [string] , nonStrings ) [EOL] setDistinguishable ( [string] , nonStrings ) [EOL] setDistinguishable ( [string] , nonStrings ) [EOL] setDistinguishable ( [string] , nonStrings ) [EOL] setDistinguishable ( [string] , nonStrings ) [EOL] setDistinguishable ( [string] , nonStrings ) [EOL] setDistinguishable ( [string] , notRelatedInterfaces ) [EOL] setDistinguishable ( [string] , allBut ( notRelatedInterfaces , nullables ) ) [EOL] setDistinguishable ( [string] , notRelatedInterfaces ) [EOL] setDistinguishable ( [string] , allBut ( argTypes , [ [string] , [string] ] ) ) [EOL] setDistinguishable ( [string] , nonUserObjects ) [EOL] setDistinguishable ( [string] , allBut ( nonUserObjects , nullables ) ) [EOL] setDistinguishable ( [string] , nonUserObjects ) [EOL] setDistinguishable ( [string] , nonObjects ) [EOL] setDistinguishable ( [string] , nonUserObjects ) [EOL] setDistinguishable ( [string] , nonUserObjects ) [EOL] setDistinguishable ( [string] , allBut ( nonUserObjects , nullables ) ) [EOL] setDistinguishable ( [string] , allBut ( nonUserObjects , nullables ) ) [EOL] setDistinguishable ( [string] , allBut ( argTypes , sequences + [ [string] ] ) ) [EOL] setDistinguishable ( [string] , allBut ( argTypes , sequences + [ [string] ] ) ) [EOL] setDistinguishable ( [string] , nonUserObjects ) [EOL] setDistinguishable ( [string] , nonUserObjects ) [EOL] [comment] [EOL] setDistinguishable ( [string] , nonUserObjects ) [EOL] setDistinguishable ( [string] , nonUserObjects ) [EOL] setDistinguishable ( [string] , [ ] ) [EOL] setDistinguishable ( [string] , [ ] ) [EOL] setDistinguishable ( [string] , [ ] ) [EOL] setDistinguishable ( [string] , allBut ( argTypes , [ [string] , [string] ] ) ) [EOL] setDistinguishable ( [string] , allBut ( argTypes , [ [string] , [string] , [string] , [string] ] ) ) [EOL] setDistinguishable ( [string] , allBut ( argTypes , [ [string] , [string] , [string] ] ) ) [EOL] setDistinguishable ( [string] , allBut ( argTypes , [ [string] , [string] , [string] ] ) ) [EOL] setDistinguishable ( [string] , allBut ( nonUserObjects , numerics ) ) [EOL] setDistinguishable ( [string] , allBut ( nonUserObjects , numerics + nullables ) ) [EOL] [EOL] def areDistinguishable ( type1 , type2 ) : [EOL] return data [ type1 ] . get ( type2 , False ) [EOL] [EOL] def checkDistinguishability ( parser , type1 , type2 ) : [EOL] idlTemplate = [string] [EOL] methodTemplate = [string] [EOL] methods = ( methodTemplate % type1 ) + ( methodTemplate % type2 ) [EOL] idl = idlTemplate % methods [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( idl ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] if areDistinguishable ( type1 , type2 ) : [EOL] harness . ok ( not threw , [string] % ( type1 , type2 ) ) [EOL] else : [EOL] harness . ok ( threw , [string] % ( type1 , type2 ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for type1 in argTypes : [EOL] for type2 in argTypes : [EOL] checkDistinguishability ( parser , type1 , type2 ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] [comment] [EOL] [EOL] threw = False [EOL] input = [string] [EOL] try : [EOL] parser . parse ( input ) [EOL] results = parser . finish ( ) [EOL] except WebIDL . WebIDLError as e : [EOL] threw = True [EOL] lines = str ( e ) . split ( [string] ) [EOL] [EOL] harness . check ( len ( lines ) , [number] , [string] ) [EOL] harness . ok ( lines [ [number] ] . endswith ( [string] ) , [string] % lines [ [number] ] ) [EOL] harness . check ( lines [ [number] ] , [string] , [string] ) [EOL] harness . check ( lines [ [number] ] , [string] * ( len ( [string] ) - [number] ) + [string] , [string] ) [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) ; [EOL] iface = results [ [number] ] [EOL] harness . check ( len ( iface . members ) , [number] , [string] ) ; [EOL] operation = iface . members [ [number] ] [EOL] harness . check ( len ( operation . signatures ( ) ) , [number] , [string] ) ; [EOL] ( retval , args ) = operation . signatures ( ) [ [number] ] ; [EOL] harness . check ( len ( args ) , [number] , [string] ) ; [EOL] harness . check ( args [ [number] ] . identifier . name , [string] , [string] ) ; [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] harness . ok ( True , [string] ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] iface = results [ [number] ] [EOL] harness . ok ( isinstance ( iface , WebIDL . IDLInterface ) , [string] ) [EOL] harness . check ( iface . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( iface . identifier . name , [string] , [string] ) [EOL] harness . check ( len ( iface . members ) , [number] , [string] % [number] ) [EOL] [EOL] attr = iface . members [ [number] ] [EOL] harness . ok ( isinstance ( attr , WebIDL . IDLAttribute ) , [string] ) [EOL] harness . ok ( attr . isAttr ( ) , [string] ) [EOL] harness . ok ( not attr . isMethod ( ) , [string] ) [EOL] harness . ok ( not attr . isConst ( ) , [string] ) [EOL] harness . check ( attr . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( attr . identifier . name , [string] , [string] ) [EOL] t = attr . type [EOL] harness . ok ( not isinstance ( t , WebIDL . IDLWrapperType ) , [string] ) [EOL] harness . ok ( isinstance ( t , WebIDL . IDLNullableType ) , [string] ) [EOL] harness . ok ( t . isCallback ( ) , [string] ) [EOL] [EOL] callback = results [ [number] ] [EOL] harness . ok ( callback . isConstructor ( ) , [string] ) [EOL] [EOL] parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] harness . ok ( False , [string] ) [EOL] except : [EOL] harness . ok ( True , [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Tuple , Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] def checkArgument ( argument , QName , name , type , optional , variadic ) : [EOL] harness . ok ( isinstance ( argument , WebIDL . IDLArgument ) , [string] ) [EOL] harness . check ( argument . identifier . QName ( ) , QName , [string] ) [EOL] harness . check ( argument . identifier . name , name , [string] ) [EOL] harness . check ( str ( argument . type ) , type , [string] ) [EOL] harness . check ( argument . optional , optional , [string] ) [EOL] harness . check ( argument . variadic , variadic , [string] ) [EOL] [EOL] def checkMethod ( method , QName , name , signatures , static = True , getter = False , setter = False , deleter = False , legacycaller = False , stringifier = False , chromeOnly = False , htmlConstructor = False , secureContext = False , pref = None , func = None ) : [EOL] harness . ok ( isinstance ( method , WebIDL . IDLMethod ) , [string] ) [EOL] harness . ok ( method . isMethod ( ) , [string] ) [EOL] harness . ok ( not method . isAttr ( ) , [string] ) [EOL] harness . ok ( not method . isConst ( ) , [string] ) [EOL] harness . check ( method . identifier . QName ( ) , QName , [string] ) [EOL] harness . check ( method . identifier . name , name , [string] ) [EOL] harness . check ( method . isStatic ( ) , static , [string] ) [EOL] harness . check ( method . isGetter ( ) , getter , [string] ) [EOL] harness . check ( method . isSetter ( ) , setter , [string] ) [EOL] harness . check ( method . isDeleter ( ) , deleter , [string] ) [EOL] harness . check ( method . isLegacycaller ( ) , legacycaller , [string] ) [EOL] harness . check ( method . isStringifier ( ) , stringifier , [string] ) [EOL] harness . check ( method . getExtendedAttribute ( [string] ) is not None , chromeOnly , [string] ) [EOL] harness . check ( method . isHTMLConstructor ( ) , htmlConstructor , [string] ) [EOL] harness . check ( len ( method . signatures ( ) ) , len ( signatures ) , [string] ) [EOL] harness . check ( method . getExtendedAttribute ( [string] ) , pref , [string] ) [EOL] harness . check ( method . getExtendedAttribute ( [string] ) , func , [string] ) [EOL] harness . check ( method . getExtendedAttribute ( [string] ) is not None , secureContext , [string] ) [EOL] [EOL] sigpairs = zip ( method . signatures ( ) , signatures ) [EOL] for ( gotSignature , expectedSignature ) in sigpairs : [EOL] ( gotRetType , gotArgs ) = gotSignature [EOL] ( expectedRetType , expectedArgs ) = expectedSignature [EOL] [EOL] harness . check ( str ( gotRetType ) , expectedRetType , [string] ) [EOL] [EOL] for i in range ( [number] , len ( gotArgs ) ) : [EOL] ( QName , name , type , optional , variadic ) = expectedArgs [ i ] [EOL] checkArgument ( gotArgs [ i ] , QName , name , type , optional , variadic ) [EOL] [EOL] def checkResults ( results ) : [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] ) [EOL] [EOL] checkMethod ( results [ [number] ] . ctor ( ) , [string] , [string] , [ ( [string] , [ ] ) ] ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] checkMethod ( results [ [number] ] . ctor ( ) , [string] , [string] , [ ( [string] , [ ( [string] , [string] , [string] , False , False ) ] ) ] ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] checkMethod ( results [ [number] ] . ctor ( ) , [string] , [string] , [ ( [string] , [ ( [string] , [string] , [string] , False , False ) ] ) , ( [string] , [ ( [string] , [string] , [string] , False , False ) ] ) ] ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] checkResults ( results ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] ) [EOL] [EOL] checkMethod ( results [ [number] ] . ctor ( ) , [string] , [string] , [ ( [string] , [ ] ) ] , pref = [ [string] ] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] ) [EOL] [EOL] checkMethod ( results [ [number] ] . ctor ( ) , [string] , [string] , [ ( [string] , [ ] ) ] , chromeOnly = True ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] ) [EOL] [EOL] checkMethod ( results [ [number] ] . ctor ( ) , [string] , [string] , [ ( [string] , [ ] ) ] , secureContext = True ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] ) [EOL] [EOL] checkMethod ( results [ [number] ] . ctor ( ) , [string] , [string] , [ ( [string] , [ ] ) ] , func = [ [string] ] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] ) [EOL] [EOL] checkMethod ( results [ [number] ] . ctor ( ) , [string] , [string] , [ ( [string] , [ ] ) ] , func = [ [string] ] , pref = [ [string] ] , chromeOnly = True , secureContext = True ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] ) [EOL] [EOL] checkMethod ( results [ [number] ] . ctor ( ) , [string] , [string] , [ ( [string] , [ ] ) ] , htmlConstructor = True ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . isNamespace ( ) , [string] ) ; [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isAttr ( ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isStatic ( ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isMethod ( ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isStatic ( ) , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . isNamespace ( ) , [string] ) ; [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isAttr ( ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isStatic ( ) , [string] ) ; [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isMethod ( ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isStatic ( ) , [string] ) ; [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . isNamespace ( ) , [string] ) ; [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isAttr ( ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isStatic ( ) , [string] ) ; [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isMethod ( ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . isStatic ( ) , [string] ) ; [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] def should_throw ( parser , harness , message , code ) : [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( code ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] % message ) [EOL] [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] [comment] [EOL] should_throw ( parser , harness , [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] should_throw ( parser , harness , [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] should_throw ( parser , harness , [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] should_throw ( parser , harness , [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] should_throw ( parser , harness , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] [comment] [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( not threw , [string] ) [EOL] if not threw : [EOL] harness . check ( results [ [number] ] . innerType . hasEnforceRange ( ) , True , [string] ) [EOL] harness . check ( results [ [number] ] . innerType . hasClamp ( ) , True , [string] ) [EOL] harness . check ( results [ [number] ] . innerType . treatNullAsEmpty , True , [string] ) [EOL] A = results [ [number] ] [EOL] harness . check ( A . members [ [number] ] . type . hasEnforceRange ( ) , True , [string] ) [EOL] harness . check ( A . members [ [number] ] . type . hasClamp ( ) , True , [string] ) [EOL] harness . check ( A . members [ [number] ] . type . hasEnforceRange ( ) , True , [string] ) [EOL] harness . check ( A . members [ [number] ] . type . hasEnforceRange ( ) , True , [string] ) [EOL] B = results [ [number] ] [EOL] harness . check ( B . members [ [number] ] . type . hasEnforceRange ( ) , True , [string] ) [EOL] harness . check ( B . members [ [number] ] . type . hasEnforceRange ( ) , True , [string] ) [EOL] harness . check ( B . members [ [number] ] . type . hasClamp ( ) , True , [string] ) [EOL] harness . check ( B . members [ [number] ] . type . treatNullAsEmpty , True , [string] ) [EOL] method = B . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [EOL] harness . check ( method [ [number] ] . type . hasEnforceRange ( ) , True , [string] ) [EOL] harness . check ( method [ [number] ] . type . hasClamp ( ) , True , [string] ) [EOL] harness . check ( method [ [number] ] . type . treatNullAsEmpty , True , [string] ) [EOL] method2 = B . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [EOL] harness . check ( method [ [number] ] . type . hasEnforceRange ( ) , True , [string] ) [EOL] harness . check ( method [ [number] ] . type . hasClamp ( ) , True , [string] ) [EOL] harness . check ( method [ [number] ] . type . treatNullAsEmpty , True , [string] ) [EOL] C = results [ [number] ] [EOL] harness . ok ( C . members [ [number] ] . type . nullable ( ) , [string] ) [EOL] harness . ok ( C . members [ [number] ] . type . hasEnforceRange ( ) , [string] ) [EOL] harness . ok ( C . members [ [number] ] . type . nullable ( ) , [string] ) [EOL] harness . ok ( C . members [ [number] ] . type . hasClamp ( ) , [string] ) [EOL] method = C . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [EOL] harness . ok ( method [ [number] ] . type . nullable ( ) , [string] ) [EOL] harness . ok ( method [ [number] ] . type . hasEnforceRange ( ) , [string] ) [EOL] harness . ok ( method [ [number] ] . type . nullable ( ) , [string] ) [EOL] harness . ok ( method [ [number] ] . type . hasClamp ( ) , [string] ) [EOL] method2 = C . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [EOL] harness . ok ( method2 [ [number] ] . type . nullable ( ) , [string] ) [EOL] harness . ok ( method2 [ [number] ] . type . hasEnforceRange ( ) , [string] ) [EOL] harness . ok ( method2 [ [number] ] . type . nullable ( ) , [string] ) [EOL] harness . ok ( method2 [ [number] ] . type . hasClamp ( ) , [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( not threw , [string] ) [EOL] if not threw : [EOL] harness . ok ( results [ [number] ] . innerType . hasAllowShared ( ) , [string] ) [EOL] A = results [ [number] ] [EOL] harness . ok ( A . members [ [number] ] . type . hasAllowShared ( ) , [string] ) [EOL] harness . ok ( A . members [ [number] ] . type . hasAllowShared ( ) , [string] ) [EOL] harness . ok ( A . members [ [number] ] . type . hasAllowShared ( ) , [string] ) [EOL] B = results [ [number] ] [EOL] harness . ok ( B . members [ [number] ] . type . hasAllowShared ( ) , [string] ) [EOL] harness . ok ( B . members [ [number] ] . type . hasAllowShared ( ) , [string] ) [EOL] method = B . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [EOL] harness . ok ( method [ [number] ] . type . hasAllowShared ( ) , [string] ) [EOL] method2 = B . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [EOL] harness . ok ( method2 [ [number] ] . type . hasAllowShared ( ) , [string] ) [EOL] C = results [ [number] ] [EOL] harness . ok ( C . members [ [number] ] . type . nullable ( ) , [string] ) [EOL] harness . ok ( C . members [ [number] ] . type . hasAllowShared ( ) , [string] ) [EOL] method = C . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [EOL] harness . ok ( method [ [number] ] . type . nullable ( ) , [string] ) [EOL] harness . ok ( method [ [number] ] . type . hasAllowShared ( ) , [string] ) [EOL] method2 = C . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [EOL] harness . ok ( method2 [ [number] ] . type . nullable ( ) , [string] ) [EOL] harness . ok ( method2 [ [number] ] . type . hasAllowShared ( ) , [string] ) [EOL] [EOL] ATTRIBUTES = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] TEMPLATES = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] for ( name , template ) in TEMPLATES : [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( template % ( [string] , [string] ) ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( not threw , [string] % name ) [EOL] for ( attribute , type ) in ATTRIBUTES : [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( template % ( attribute , type ) ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] % ( attribute , name ) ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] TYPES = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] for type in TYPES : [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] % type ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] % type ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] % type ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] % type ) [EOL] [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( not threw , [string] ) [EOL] harness . check ( results [ [number] ] . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [ [number] ] . type . hasClamp ( ) , True , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( not threw , [string] ) [EOL] harness . check ( results [ [number] ] . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [ [number] ] . type . hasClamp ( ) , True , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] harness . ok ( True , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] [EOL] testIface = results [ [number] ] ; [EOL] harness . check ( testIface . members [ [number] ] . isStatic ( ) , False , [string] ) [EOL] harness . check ( testIface . members [ [number] ] . identifier . name , [string] , [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] [EOL] testIface = results [ [number] ] [EOL] harness . check ( testIface . members [ [number] ] . isStatic ( ) , False , [string] ) [EOL] harness . check ( testIface . members [ [number] ] . identifier . name , [string] , [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] [EOL] testDict = results [ [number] ] [EOL] harness . check ( testDict . members [ [number] ] . identifier . name , [string] , [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( not threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) is None , [string] ) [EOL] [EOL] [comment] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results [ [number] ] . members ) , [number] , [string] ) [EOL] harness . ok ( results [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( results [ [number] ] . members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] try : [EOL] parser . parse ( [string] ) [EOL] harness . ok ( False , [string] ) [EOL] except : [EOL] harness . ok ( True , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] members = results [ [number] ] . members ; [EOL] harness . check ( len ( members ) , [number] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] harness . ok ( members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] harness . ok ( not members [ [number] ] . getExtendedAttribute ( [string] ) , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] exception = None [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as e : [EOL] exception = e [EOL] [EOL] harness . ok ( exception , [string] ) [EOL] harness . check ( exception . message , [string] [string] , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] exception = None [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as e : [EOL] exception = e [EOL] [EOL] harness . ok ( exception , [string] ) [EOL] harness . check ( exception . message , [string] [string] , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] exception = None [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as e : [EOL] exception = e [EOL] [EOL] harness . ok ( exception , [string] ) [EOL] harness . check ( exception . message , [string] [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] import WebIDL [EOL] import traceback [EOL] def WebIDLTest ( parser , harness ) : [EOL] [EOL] def shouldPass ( prefix , iface , expectedMembers , numProductions = [number] ) : [EOL] p = parser . reset ( ) [EOL] p . parse ( iface ) [EOL] results = p . finish ( ) [EOL] harness . check ( len ( results ) , numProductions , [string] % ( prefix , numProductions ) ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] % (prefix) ) [EOL] [comment] [EOL] expectedMembers = list ( expectedMembers ) [EOL] for m in results [ [number] ] . members : [EOL] name = m . identifier . name [EOL] if ( name , type ( m ) ) in expectedMembers : [EOL] harness . ok ( True , [string] % ( prefix , name , type ( m ) ) ) [EOL] expectedMembers . remove ( ( name , type ( m ) ) ) [EOL] else : [EOL] harness . ok ( False , [string] % ( prefix , name , type ( m ) ) ) [EOL] [comment] [EOL] if len ( expectedMembers ) == [number] : [EOL] harness . ok ( True , [string] ) [EOL] else : [EOL] harness . ok ( False , [string] % ( expectedMembers [ [number] ] [ [number] ] , expectedMembers [ [number] ] [ [number] ] ) ) [EOL] return results [EOL] [EOL] def shouldFail ( prefix , iface ) : [EOL] try : [EOL] p = parser . reset ( ) [EOL] p . parse ( iface ) [EOL] p . finish ( ) [EOL] harness . ok ( False , prefix + [string] ) [EOL] except WebIDL . WebIDLError as e : [EOL] harness . ok ( True , prefix + [string] ) [EOL] except Exception as e : [EOL] harness . ok ( False , prefix + [string] % e ) [EOL] [EOL] iterableMembers = [ ( x , WebIDL . IDLMethod ) for x in [ [string] , [string] , [string] , [string] ] ] [EOL] setROMembers = ( [ ( x , WebIDL . IDLMethod ) for x in [ [string] ] ] + [ ( [string] , WebIDL . IDLMaplikeOrSetlike ) ] + iterableMembers ) [EOL] setROMembers . extend ( [ ( [string] , WebIDL . IDLAttribute ) ] ) [EOL] setRWMembers = ( [ ( x , WebIDL . IDLMethod ) for x in [ [string] , [string] , [string] ] ] + setROMembers ) [EOL] setROChromeMembers = ( [ ( x , WebIDL . IDLMethod ) for x in [ [string] , [string] , [string] ] ] + setROMembers ) [EOL] setRWChromeMembers = ( [ ( x , WebIDL . IDLMethod ) for x in [ [string] , [string] , [string] ] ] + setRWMembers ) [EOL] mapROMembers = ( [ ( x , WebIDL . IDLMethod ) for x in [ [string] , [string] ] ] + [ ( [string] , WebIDL . IDLMaplikeOrSetlike ) ] + iterableMembers ) [EOL] mapROMembers . extend ( [ ( [string] , WebIDL . IDLAttribute ) ] ) [EOL] mapRWMembers = ( [ ( x , WebIDL . IDLMethod ) for x in [ [string] , [string] , [string] ] ] + mapROMembers ) [EOL] mapRWChromeMembers = ( [ ( x , WebIDL . IDLMethod ) for x in [ [string] , [string] , [string] ] ] + mapRWMembers ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] iterableMembers . append ( ( [string] , WebIDL . IDLIterable ) ) [EOL] [EOL] valueIterableMembers = [ ( [string] , WebIDL . IDLIterable ) ] [EOL] valueIterableMembers . append ( ( [string] , WebIDL . IDLMethod ) ) [EOL] valueIterableMembers . append ( ( [string] , WebIDL . IDLAttribute ) ) [EOL] [EOL] disallowedIterableNames = [ [string] , [string] , [string] ] [EOL] disallowedMemberNames = [ [string] , [string] , [string] ] + disallowedIterableNames [EOL] mapDisallowedMemberNames = [ [string] ] + disallowedMemberNames [EOL] disallowedNonMethodNames = [ [string] , [string] ] [EOL] mapDisallowedNonMethodNames = [ [string] ] + disallowedNonMethodNames [EOL] setDisallowedNonMethodNames = [ [string] ] + disallowedNonMethodNames [EOL] unrelatedMembers = [ ( [string] , WebIDL . IDLAttribute ) , ( [string] , WebIDL . IDLMethod ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] shouldPass ( [string] , [string] , valueIterableMembers + unrelatedMembers ) [EOL] [EOL] shouldPass ( [string] , [string] , valueIterableMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , iterableMembers + unrelatedMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , iterableMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers + unrelatedMembers ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers + unrelatedMembers ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , mapROMembers + unrelatedMembers ) [EOL] [EOL] shouldPass ( [string] , [string] , mapROMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , setRWMembers + unrelatedMembers ) [EOL] [EOL] shouldPass ( [string] , [string] , setRWMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , setROMembers + unrelatedMembers ) [EOL] [EOL] shouldPass ( [string] , [string] , setROMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , setRWChromeMembers ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWChromeMembers ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def testConflictingMembers ( likeMember , conflictName , expectedMembers , methodPasses ) : [EOL] [docstring] [EOL] if methodPasses : [EOL] shouldPass ( [string] % ( likeMember , conflictName ) , [string] % ( likeMember , conflictName ) , expectedMembers ) [EOL] else : [EOL] shouldFail ( [string] % ( likeMember , conflictName ) , [string] % ( likeMember , conflictName ) ) [EOL] [comment] [EOL] shouldFail ( [string] % ( likeMember , conflictName ) , [string] % ( conflictName , likeMember ) ) [EOL] shouldFail ( [string] % ( likeMember , conflictName ) , [string] % ( likeMember , conflictName ) ) [EOL] shouldFail ( [string] % ( likeMember , conflictName ) , [string] % ( likeMember , conflictName ) ) [EOL] shouldFail ( [string] % ( likeMember , conflictName ) , [string] % ( likeMember , conflictName ) ) [EOL] shouldFail ( [string] % ( likeMember , conflictName ) , [string] % ( likeMember , conflictName ) ) [EOL] [EOL] for member in disallowedIterableNames : [EOL] testConflictingMembers ( [string] , member , iterableMembers , False ) [EOL] for member in mapDisallowedMemberNames : [EOL] testConflictingMembers ( [string] , member , mapRWMembers , False ) [EOL] for member in disallowedMemberNames : [EOL] testConflictingMembers ( [string] , member , setRWMembers , False ) [EOL] for member in mapDisallowedNonMethodNames : [EOL] testConflictingMembers ( [string] , member , mapRWMembers , True ) [EOL] for member in setDisallowedNonMethodNames : [EOL] testConflictingMembers ( [string] , member , setRWMembers , True ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers , numProductions = [number] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers , numProductions = [number] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers , numProductions = [number] ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers , numProductions = [number] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldPass ( [string] , [string] , mapRWMembers , numProductions = [number] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] shouldPass ( [string] , [string] , setROMembers + [ ( [string] , WebIDL . IDLAttribute ) ] ) [EOL] [EOL] shouldPass ( [string] , [string] , setROChromeMembers + [ ( [string] , WebIDL . IDLAttribute ) ] ) [EOL] [EOL] shouldFail ( [string] , [string] ) [EOL] [EOL] r = shouldPass ( [string] , [string] , mapRWMembers ) [EOL] [EOL] for m in r [ [number] ] . members : [EOL] if m . identifier . name in [ [string] , [string] , [string] ] : [EOL] harness . ok ( m . isMethod ( ) , [string] % m . identifier . name ) [EOL] harness . check ( m . maxArgCount , [number] , [string] % m . identifier . name ) [EOL] harness . ok ( not m . isMaplikeOrSetlikeOrIterableMethod ( ) , [string] % m . identifier . name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Tuple , Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] harness . ok ( True , [string] ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] iface = results [ [number] ] [EOL] harness . ok ( isinstance ( iface , WebIDL . IDLInterface ) , [string] ) [EOL] harness . check ( iface . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( iface . identifier . name , [string] , [string] ) [EOL] harness . check ( len ( iface . members ) , [number] , [string] ) [EOL] [EOL] methods = iface . members [EOL] [EOL] def checkArgument ( argument , QName , name , type , optional , variadic ) : [EOL] harness . ok ( isinstance ( argument , WebIDL . IDLArgument ) , [string] ) [EOL] harness . check ( argument . identifier . QName ( ) , QName , [string] ) [EOL] harness . check ( argument . identifier . name , name , [string] ) [EOL] harness . check ( str ( argument . type ) , type , [string] ) [EOL] harness . check ( argument . optional , optional , [string] ) [EOL] harness . check ( argument . variadic , variadic , [string] ) [EOL] [EOL] def checkMethod ( method , QName , name , signatures , static = False , getter = False , setter = False , deleter = False , legacycaller = False , stringifier = False ) : [EOL] harness . ok ( isinstance ( method , WebIDL . IDLMethod ) , [string] ) [EOL] harness . ok ( method . isMethod ( ) , [string] ) [EOL] harness . ok ( not method . isAttr ( ) , [string] ) [EOL] harness . ok ( not method . isConst ( ) , [string] ) [EOL] harness . check ( method . identifier . QName ( ) , QName , [string] ) [EOL] harness . check ( method . identifier . name , name , [string] ) [EOL] harness . check ( method . isStatic ( ) , static , [string] ) [EOL] harness . check ( method . isGetter ( ) , getter , [string] ) [EOL] harness . check ( method . isSetter ( ) , setter , [string] ) [EOL] harness . check ( method . isDeleter ( ) , deleter , [string] ) [EOL] harness . check ( method . isLegacycaller ( ) , legacycaller , [string] ) [EOL] harness . check ( method . isStringifier ( ) , stringifier , [string] ) [EOL] harness . check ( len ( method . signatures ( ) ) , len ( signatures ) , [string] ) [EOL] [EOL] sigpairs = zip ( method . signatures ( ) , signatures ) [EOL] for ( gotSignature , expectedSignature ) in sigpairs : [EOL] ( gotRetType , gotArgs ) = gotSignature [EOL] ( expectedRetType , expectedArgs ) = expectedSignature [EOL] [EOL] harness . check ( str ( gotRetType ) , expectedRetType , [string] ) [EOL] [EOL] for i in range ( [number] , len ( gotArgs ) ) : [EOL] ( QName , name , type , optional , variadic ) = expectedArgs [ i ] [EOL] checkArgument ( gotArgs [ i ] , QName , name , type , optional , variadic ) [EOL] [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ] ) ] ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ] ) ] , static = True ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ( [string] , [string] , [string] , False , False ) , ( [string] , [string] , [string] , False , False ) , ( [string] , [string] , [string] , False , False ) ] ) ] ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ] ) ] ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ] ) ] , static = True ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ( [string] , [string] , [string] , False , False ) , ( [string] , [string] , [string] , False , False ) , ( [string] , [string] , [string] , False , False ) ] ) ] ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ( [string] , [string] , [string] , True , False ) , ( [string] , [string] , [string] , True , False ) ] ) ] ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ( [string] , [string] , [string] , True , True ) ] ) ] ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ] ) ] ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ( [string] , [string] , [string] , False , False ) ] ) ] ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ( [string] , [string] , [string] , False , False ) ] ) ] ) [EOL] checkMethod ( methods [ [number] ] , [string] , [string] , [ ( [string] , [ ( [string] , [string] , [string] , False , False ) ] ) ] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( not threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( not threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] iface = results [ [number] ] [EOL] methods = iface . members [EOL] lenientFloat = methods [ [number] ] . getExtendedAttribute ( [string] ) [EOL] harness . ok ( lenientFloat is not None , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] iface = results [ [number] ] [EOL] attr = iface . members [ [number] ] [EOL] harness . check ( attr . type . treatNonCallableAsNull ( ) , True , [string] ) [EOL] attr = iface . members [ [number] ] [EOL] harness . check ( attr . type . treatNonCallableAsNull ( ) , False , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . ok ( False , [string] ) [EOL] except Exception as e : [EOL] harness . ok ( [string] in e . message , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . ok ( False , [string] ) [EOL] except Exception as e : [EOL] harness . ok ( [string] in e . message , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] harness . ok ( False , [string] ) [EOL] except Exception as e : [EOL] harness . ok ( [string] in e . message , [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) ; [EOL] [EOL] harness . ok ( isinstance ( results [ [number] ] . members [ [number] ] . signatures ( ) [ [number] ] [ [number] ] [ [number] ] . defaultValue , WebIDL . IDLEmptySequenceValue ) , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] [EOL] harness . ok ( isinstance ( results [ [number] ] . members [ [number] ] . defaultValue , WebIDL . IDLEmptySequenceValue ) , [string] [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] harness . ok ( True , [string] ) [EOL] [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] harness . ok ( isinstance ( results [ [number] ] , WebIDL . IDLInterface ) , [string] ) [EOL] iface = results [ [number] ] [EOL] harness . check ( iface . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( iface . identifier . name , [string] , [string] ) [EOL] harness . check ( iface . parent , None , [string] ) [EOL] [EOL] members = iface . members [EOL] harness . check ( len ( members ) , [number] , [string] ) [EOL] [EOL] attr = members [ [number] ] [EOL] harness . ok ( isinstance ( attr , WebIDL . IDLAttribute ) , [string] ) [EOL] harness . check ( attr . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( attr . identifier . name , [string] , [string] ) [EOL] harness . check ( str ( attr . type ) , [string] , [string] ) [EOL] harness . ok ( attr . type . isByteString ( ) , [string] ) [EOL] harness . ok ( attr . type . isString ( ) , [string] ) [EOL] harness . ok ( not attr . type . isDOMString ( ) , [string] ) [EOL] [EOL] [comment] [EOL] attr = members [ [number] ] [EOL] harness . ok ( isinstance ( attr , WebIDL . IDLAttribute ) , [string] ) [EOL] harness . check ( attr . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( attr . identifier . name , [string] , [string] ) [EOL] harness . check ( str ( attr . type ) , [string] , [string] ) [EOL] harness . ok ( attr . type . isDOMString ( ) , [string] ) [EOL] harness . ok ( attr . type . isString ( ) , [string] ) [EOL] harness . ok ( not attr . type . isByteString ( ) , [string] ) [EOL] [EOL] [comment] [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] except WebIDL . WebIDLError : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] [comment] [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results2 = parser . finish ( ) [EOL] except WebIDL . WebIDLError as e : [EOL] harness . ok ( False , [string] [string] + str ( e ) ) [EOL] [EOL] [comment] [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results3 = parser . finish ( ) [EOL] except WebIDL . WebIDLError as e : [EOL] harness . ok ( False , [string] [string] + str ( e ) ) [EOL] [EOL] [comment] [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results4 = parser . finish ( ) [EOL] except WebIDL . WebIDLError as e : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] harness . ok ( True , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Literal , Any , List [EOL] import typing_extensions [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( not threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( not threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( not threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] JsonTypes = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] nonJsonTypes = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def doTest ( testIDL , shouldThrow , description ) : [EOL] p = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] p . parse ( testIDL + [string] ) ; [EOL] p . finish ( ) ; [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( x . message == [string] , x ) [EOL] harness . check ( threw , shouldThrow , description ) [EOL] [EOL] [EOL] for type in JsonTypes : [EOL] doTest ( [string] % type , False , [string] % type ) [EOL] [EOL] doTest ( [string] % type , False , [string] % type ) [EOL] [EOL] doTest ( [string] [string] % type , False , [string] % type ) [EOL] [EOL] doTest ( [string] [string] % type , False , [string] ) [EOL] [EOL] doTest ( [string] [string] % type , True , [string] ) [EOL] [EOL] doTest ( [string] % type , False , [string] % type ) [EOL] [EOL] doTest ( [string] % type , False , [string] % type ) [EOL] [EOL] doTest ( [string] % type , False , [string] % type ) [EOL] [EOL] doTest ( [string] % type , False , [string] % type ) [EOL] [EOL] otherUnionType = [string] if type != [string] else [string] [EOL] doTest ( [string] [string] % ( otherUnionType , type ) , False , [string] % ( otherUnionType , type ) ) [EOL] [EOL] doTest ( [string] % type , False , [string] % type ) [EOL] [EOL] doTest ( [string] [string] % type , False , [string] ) [EOL] [EOL] doTest ( [string] [string] , False , [string] ) [EOL] [EOL] for type in nonJsonTypes : [EOL] doTest ( [string] % type , True , [string] % type ) [EOL] [EOL] doTest ( [string] % type , True , [string] % type ) [EOL] [EOL] doTest ( [string] [string] % type , True , [string] % type ) [EOL] [EOL] doTest ( [string] [string] % type , True , [string] ) [EOL] [EOL] doTest ( [string] % type , True , [string] % type ) [EOL] [EOL] doTest ( [string] % type , True , [string] % type ) [EOL] [EOL] doTest ( [string] % type , True , [string] % type ) [EOL] [EOL] if type != [string] : [EOL] doTest ( [string] [string] % type , True , [string] % type ) [EOL] [EOL] doTest ( [string] % type , True , [string] % type ) [EOL] [EOL] doTest ( [string] [string] , True , [string] ) [EOL] [EOL] doTest ( [string] [string] , True , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) ; [EOL] [EOL] attr = parser . finish ( ) [ [number] ] . members [ [number] ] [EOL] harness . check ( attr . type . filename ( ) , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] testData = [ ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) ] [EOL] [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] def checkAttr ( attr , QName , name , type , readonly ) : [EOL] harness . ok ( isinstance ( attr , WebIDL . IDLAttribute ) , [string] ) [EOL] harness . ok ( attr . isAttr ( ) , [string] ) [EOL] harness . ok ( not attr . isMethod ( ) , [string] ) [EOL] harness . ok ( not attr . isConst ( ) , [string] ) [EOL] harness . check ( attr . identifier . QName ( ) , QName , [string] ) [EOL] harness . check ( attr . identifier . name , name , [string] ) [EOL] harness . check ( str ( attr . type ) , type , [string] ) [EOL] harness . check ( attr . readonly , readonly , [string] ) [EOL] [EOL] harness . ok ( True , [string] ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] iface = results [ [number] ] [EOL] harness . ok ( isinstance ( iface , WebIDL . IDLInterface ) , [string] ) [EOL] harness . check ( iface . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( iface . identifier . name , [string] , [string] ) [EOL] harness . check ( len ( iface . members ) , len ( testData ) , [string] % len ( testData ) ) [EOL] [EOL] attrs = iface . members [EOL] [EOL] for i in range ( len ( attrs ) ) : [EOL] data = testData [ i ] [EOL] attr = attrs [ i ] [EOL] ( QName , name , type , readonly ) = data [EOL] checkAttr ( attr , QName % [string] , name , type % [string] , readonly ) [EOL] [EOL] iface = results [ [number] ] [EOL] harness . ok ( isinstance ( iface , WebIDL . IDLInterface ) , [string] ) [EOL] harness . check ( iface . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( iface . identifier . name , [string] , [string] ) [EOL] harness . check ( len ( iface . members ) , len ( testData ) , [string] % len ( testData ) ) [EOL] [EOL] attrs = iface . members [EOL] [EOL] for i in range ( len ( attrs ) ) : [EOL] data = testData [ i ] [EOL] attr = attrs [ i ] [EOL] ( QName , name , type , readonly ) = data [EOL] checkAttr ( attr , QName % [string] , name , type % [string] , readonly ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] results = parser . finish ( ) [EOL] except Exception as x : [EOL] threw = True [EOL] harness . ok ( not threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] harness . ok ( True , [string] ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] iface = results [ [number] ] [EOL] harness . ok ( isinstance ( iface , WebIDL . IDLInterface ) , [string] ) [EOL] harness . check ( iface . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( iface . identifier . name , [string] , [string] ) [EOL] harness . check ( len ( iface . members ) , [number] , [string] ) [EOL] [EOL] attr = iface . members [ [number] ] [EOL] harness . ok ( isinstance ( attr , WebIDL . IDLAttribute ) , [string] ) [EOL] method = iface . members [ [number] ] [EOL] harness . ok ( isinstance ( method , WebIDL . IDLMethod ) , [string] ) [EOL] [EOL] harness . check ( attr . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( attr . type . name , [string] , [string] ) [EOL] [EOL] harness . check ( method . identifier . QName ( ) , [string] , [string] ) [EOL] ( returnType , args ) = method . signatures ( ) [ [number] ] [EOL] harness . check ( returnType . name , [string] , [string] ) [EOL] harness . check ( args [ [number] ] . type . name , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] for decl in parser . finish ( ) : [EOL] if decl . isInterface ( ) : [EOL] checkEquivalent ( decl , harness ) [EOL] [EOL] def checkEquivalent ( iface , harness ) : [EOL] type1 = iface . members [ [number] ] . type [EOL] type2 = iface . members [ [number] ] . type [EOL] [EOL] harness . check ( type1 . nullable ( ) , False , [string] ) [EOL] harness . check ( type2 . nullable ( ) , True , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] harness . check ( type2 . builtin , False , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for attr in dir ( type1 ) : [EOL] if attr . startswith ( [string] ) or attr in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] or ( hasattr ( type ( type1 ) , attr ) and not callable ( getattr ( type1 , attr ) ) ) : [EOL] continue [EOL] [EOL] a1 = getattr ( type1 , attr ) [EOL] [EOL] if callable ( a1 ) : [EOL] try : [EOL] v1 = a1 ( ) [EOL] except : [EOL] [comment] [EOL] continue [EOL] [EOL] try : [EOL] a2 = getattr ( type2 , attr ) [EOL] except : [EOL] harness . ok ( False , [string] % ( attr , type2 , iface ) ) [EOL] continue [EOL] [EOL] if not callable ( a2 ) : [EOL] harness . ok ( False , [string] % ( attr , type2 , iface ) ) [EOL] continue [EOL] [EOL] v2 = a2 ( ) [EOL] harness . check ( v2 , v1 , [string] % attr ) [EOL] else : [EOL] try : [EOL] a2 = getattr ( type2 , attr ) [EOL] except : [EOL] harness . ok ( False , [string] % ( attr , type2 , iface ) ) [EOL] continue [EOL] [EOL] harness . check ( a2 , a1 , [string] % attr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] import WebIDL [EOL] [EOL] expected = [ ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , - [number] ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , - [number] ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , - [number] ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , - [number] ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , [number] ) , ( [string] , [string] , [string] , [number] ) , ] [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] harness . ok ( True , [string] ) [EOL] harness . check ( len ( results ) , [number] , [string] ) [EOL] iface = results [ [number] ] [EOL] harness . ok ( isinstance ( iface , WebIDL . IDLInterface ) , [string] ) [EOL] harness . check ( iface . identifier . QName ( ) , [string] , [string] ) [EOL] harness . check ( iface . identifier . name , [string] , [string] ) [EOL] harness . check ( len ( iface . members ) , len ( expected ) , [string] % len ( expected ) ) [EOL] [EOL] for ( const , ( QName , name , type , value ) ) in zip ( iface . members , expected ) : [EOL] harness . ok ( isinstance ( const , WebIDL . IDLConst ) , [string] ) [EOL] harness . ok ( const . isConst ( ) , [string] ) [EOL] harness . ok ( not const . isAttr ( ) , [string] ) [EOL] harness . ok ( not const . isMethod ( ) , [string] ) [EOL] harness . check ( const . identifier . QName ( ) , QName , [string] ) [EOL] harness . check ( const . identifier . name , name , [string] ) [EOL] harness . check ( str ( const . type ) , type , [string] ) [EOL] harness . ok ( const . type . isPrimitive ( ) , [string] ) [EOL] harness . check ( str ( const . value . type ) , str ( const . type ) , [string] ) [EOL] harness . check ( const . value . value , value , [string] ) [EOL] [EOL] [EOL] parser = parser . reset ( ) [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.float]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] parser . finish ( ) [EOL] [EOL] harness . ok ( True , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def WebIDLTest ( parser , harness ) : [EOL] threw = False [EOL] try : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] except : [EOL] threw = True [EOL] [EOL] harness . ok ( threw , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import WebIDL [EOL] [EOL] def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] [EOL] results = parser . finish ( ) [EOL] [EOL] iface = results [ [number] ] [EOL] [EOL] harness . ok ( True , [string] ) [EOL] harness . check ( len ( iface . members ) , [number] , [string] ) [EOL] [EOL] members = iface . members [EOL] [EOL] def checkStuff ( attr , method , t ) : [EOL] harness . ok ( isinstance ( attr , WebIDL . IDLAttribute ) , [string] ) [EOL] harness . ok ( isinstance ( method , WebIDL . IDLMethod ) , [string] ) [EOL] [EOL] harness . check ( str ( attr . type ) , t , [string] ) [EOL] harness . ok ( attr . type . isSpiderMonkeyInterface ( ) , [string] ) [EOL] [EOL] ( retType , arguments ) = method . signatures ( ) [ [number] ] [EOL] harness . ok ( retType . isVoid ( ) , [string] ) [EOL] harness . check ( len ( arguments ) , [number] , [string] ) [EOL] [EOL] harness . check ( str ( arguments [ [number] ] . type ) , t , [string] ) [EOL] harness . ok ( arguments [ [number] ] . type . isSpiderMonkeyInterface ( ) , [string] ) [EOL] [EOL] harness . check ( str ( arguments [ [number] ] . type ) , t + [string] , [string] ) [EOL] harness . ok ( arguments [ [number] ] . type . inner . isSpiderMonkeyInterface ( ) , [string] ) [EOL] [EOL] harness . check ( str ( arguments [ [number] ] . type ) , t + [string] , [string] ) [EOL] harness . ok ( arguments [ [number] ] . type . inner . isSpiderMonkeyInterface ( ) , [string] ) [EOL] [EOL] [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL] checkStuff ( members [ [number] ] , members [ [number] ] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def WebIDLTest ( parser , harness ) : [EOL] parser . parse ( [string] ) [EOL] parser . finish ( ) [EOL] harness . ok ( True , [string] ) [EOL] parser . parse ( [string] ) [EOL] parser . finish ( ) [EOL] harness . ok ( True , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import subprocess [EOL] import typing [EOL] import os [EOL] import subprocess [EOL] import tempfile [EOL] [EOL] REPO = [string] [EOL] TEST_FILE = [string] [EOL] DOMAIN = [string] [EOL] RUST_FN = [string] [EOL] SET_COOKIES_INDENT = [number] [EOL] SHOULD_PANIC = [string] [EOL] [EOL] [comment] [EOL] FAILING_TESTS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def list_tests ( dir ) : [EOL] suffix = [string] [EOL] [EOL] def keep ( name ) : [EOL] return name . endswith ( suffix ) and not name . startswith ( [string] ) [EOL] [EOL] tests = [ name [ : - len ( suffix ) ] for name in os . listdir ( dir ) if keep ( name ) ] [EOL] tests . sort ( ) [EOL] return tests [EOL] [EOL] [EOL] def escape ( s ) : [EOL] [docstring] [EOL] res = [string] [EOL] last_split = [number] [EOL] for c in s : [EOL] if len ( res ) - last_split > [number] : [EOL] res += [string] [EOL] last_split = len ( res ) [EOL] o = ord ( c ) [EOL] if o == [number] : [EOL] res += [string] [EOL] continue [EOL] if o >= [number] : [EOL] res += [string] + hex ( o ) [ [number] : ] + [string] [EOL] else : [EOL] res += c . encode ( [string] ) [EOL] return res [EOL] [EOL] [EOL] def format_slice_cookies ( cookies ) : [EOL] esc_cookies = [ [string] % escape ( c ) for c in cookies ] [EOL] if sum ( len ( s ) for s in esc_cookies ) < [number] : [EOL] sep = [string] [EOL] else : [EOL] sep = [string] + [string] * SET_COOKIES_INDENT [EOL] return [string] + sep . join ( esc_cookies ) + [string] [EOL] [EOL] [EOL] def generate_code_for_test ( test_dir , name ) : [EOL] if name in FAILING_TESTS : [EOL] should_panic = SHOULD_PANIC [EOL] else : [EOL] should_panic = [string] [EOL] [EOL] test_file = os . path . join ( test_dir , name + [string] ) [EOL] expect_file = os . path . join ( test_dir , name + [string] ) [EOL] [EOL] set_cookies = [ ] [EOL] set_location = DOMAIN + [string] + name [EOL] expect = [string] [EOL] location = DOMAIN + [string] + name [EOL] [EOL] with open ( test_file ) as fo : [EOL] for line in fo : [EOL] line = line . decode ( [string] ) . rstrip ( ) [EOL] prefix = [string] [EOL] if line . startswith ( prefix ) : [EOL] set_cookies . append ( line [ len ( prefix ) : ] ) [EOL] prefix = [string] [EOL] if line . startswith ( prefix ) : [EOL] location = line [ len ( prefix ) : ] [EOL] if location . startswith ( [string] ) : [EOL] location = DOMAIN + location [EOL] [EOL] with open ( expect_file ) as fo : [EOL] for line in fo : [EOL] line = line . decode ( [string] ) . rstrip ( ) [EOL] prefix = [string] [EOL] if line . startswith ( prefix ) : [EOL] expect = line [ len ( prefix ) : ] [EOL] [EOL] return RUST_FN . format ( name = name . replace ( [string] , [string] ) , set_location = escape ( set_location ) , set_cookies = format_slice_cookies ( set_cookies ) , should_panic = should_panic , location = escape ( location ) , expect = escape ( expect ) ) [EOL] [EOL] [EOL] def update_test_file ( cachedir ) : [EOL] workdir = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] test_file = os . path . join ( workdir , TEST_FILE ) [EOL] [EOL] [comment] [EOL] if not os . path . isdir ( cachedir ) : [EOL] os . makedirs ( cachedir ) [EOL] [EOL] [comment] [EOL] repo_dir = os . path . join ( cachedir , [string] ) [EOL] if os . path . isdir ( repo_dir ) : [EOL] args = [ [string] , [string] , [string] ] [EOL] process = subprocess . Popen ( args , cwd = repo_dir ) [EOL] if process . wait ( ) != [number] : [EOL] print ( [string] ) [EOL] return [number] [EOL] else : [EOL] args = [ [string] , [string] , REPO , repo_dir ] [EOL] process = subprocess . Popen ( args ) [EOL] if process . wait ( ) != [number] : [EOL] print ( [string] ) [EOL] return [number] [EOL] [EOL] [comment] [EOL] with open ( test_file , [string] ) as fo : [EOL] while True : [EOL] line = fo . readline ( ) [EOL] if line . strip ( ) == [string] : [EOL] fo . truncate ( ) [EOL] fo . flush ( ) [EOL] break [EOL] if line == [string] : [EOL] print ( [string] ) [EOL] return [number] [EOL] [EOL] [comment] [EOL] tests_dir = os . path . join ( repo_dir , [string] , [string] , [string] ) [EOL] with open ( test_file , [string] ) as fo : [EOL] for test in list_tests ( tests_dir ) : [EOL] fo . write ( generate_code_for_test ( tests_dir , test ) . encode ( [string] ) ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] update_test_file ( tempfile . gettempdir ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import os [EOL] from setuptools import setup , find_packages [EOL] [EOL] [EOL] VERSION = [string] [EOL] [EOL] install_requires = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] here = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] [comment] [EOL] try : [EOL] with open ( os . path . join ( here , [string] ) ) as doc : [EOL] readme = doc . read ( ) [EOL] except Exception : [EOL] readme = [string] [EOL] [EOL] try : [EOL] with open ( os . path . join ( here , [string] ) ) as doc : [EOL] history = doc . read ( ) [EOL] except Exception : [EOL] history = [string] [EOL] [EOL] long_description = readme + [string] + history [EOL] [EOL] if __name__ == [string] : [EOL] setup ( name = [string] , version = VERSION , description = [string] [string] , long_description = long_description , keywords = [string] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( exclude = [ [string] , [string] , [string] ] ) , package_data = { } , install_requires = install_requires , zip_safe = False , entry_points = { [string] : [ [string] , ] , } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] OLD_MPL = [string] [EOL] [EOL] MPL = [string] [EOL] [EOL] APACHE = [string] [EOL] [EOL] COPYRIGHT = [ [string] , [string] , ] [EOL] [EOL] [comment] [EOL] licenses_toml = [ [string] , [string] , ] [EOL] [EOL] [comment] [EOL] licenses_dep_toml = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from servo_tidy . tidy import LintRunner [EOL] [EOL] class Lint ( LintRunner ) : [EOL] def some_method ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from servo_tidy . tidy import LintRunner [EOL] [EOL] class Linter ( LintRunner ) : [EOL] def run ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class Lint ( object ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
from servo_tidy . tidy import LintRunner [EOL] [EOL] class Lint ( LintRunner ) : [EOL] def run ( self ) : [EOL] yield None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from servo_tidy . tidy import LintRunner [EOL] [EOL] class Lint ( LintRunner ) : [EOL] def run ( self ) : [EOL] for _ in [ None ] : [EOL] yield ( [string] , [number] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Iterator , Tuple , Any , List [EOL] import typing [EOL] import os [EOL] import sys [EOL] [EOL] GSTREAMER_DYLIBS = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] NON_UWP_DYLIBS = [ [string] , [string] , ] [EOL] [EOL] GSTREAMER_PLUGINS = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] WINDOWS_PLUGINS = [ [string] , [string] , ] [EOL] [EOL] MACOS_PLUGINS = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] NON_UWP_PLUGINS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def windows_dlls ( uwp ) : [EOL] dlls = [ x for x , _ in GSTREAMER_DYLIBS ] [EOL] if uwp : [EOL] dlls = filter ( lambda x : x not in NON_UWP_DYLIBS , dlls ) [EOL] return [ x + [string] for x in dlls ] [EOL] [EOL] [EOL] def windows_plugins ( uwp ) : [EOL] dlls = [ x for x , _ in GSTREAMER_PLUGINS ] + WINDOWS_PLUGINS [EOL] if uwp : [EOL] dlls = filter ( lambda x : x not in NON_UWP_PLUGINS , dlls ) [EOL] return [ x + [string] for x in dlls ] [EOL] [EOL] [EOL] def macos_libnice ( ) : [EOL] return os . path . join ( [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def macos_dylibs ( ) : [EOL] return [ os . path . join ( [string] , path , [string] , [string] + name + [string] ) for name , path in GSTREAMER_DYLIBS ] + [ os . path . join ( macos_libnice ( ) , [string] ) , os . path . join ( macos_libnice ( ) , [string] ) , ] [EOL] [EOL] [EOL] def macos_plugins ( ) : [EOL] return [ os . path . join ( [string] , path , [string] , [string] , [string] + name + [string] ) for name , path in GSTREAMER_PLUGINS + MACOS_PLUGINS ] + [ os . path . join ( macos_libnice ( ) , [string] , [string] ) , ] [EOL] [EOL] [EOL] def write_plugin_list ( target ) : [EOL] plugins = [ ] [EOL] if [string] in target : [EOL] plugins = [ os . path . basename ( x ) for x in macos_plugins ( ) ] [EOL] elif [string] in target : [EOL] plugins = windows_plugins ( [string] in target ) [EOL] print ( [string] % [string] . join ( map ( lambda x : [string] + x + [string] , plugins ) ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] write_plugin_list ( sys . argv [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict [EOL] import typing [EOL] WINDOWS_MSVC = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Literal , Any [EOL] import typing_extensions [EOL] import typing [EOL] from win32api import GetModuleHandle [EOL] from win32gui import WNDCLASS , RegisterClass , CreateWindow , UpdateWindow [EOL] from win32gui import DestroyWindow , LoadIcon , NIF_ICON , NIF_MESSAGE , NIF_TIP [EOL] from win32gui import Shell_NotifyIcon , NIM_ADD , NIM_MODIFY , NIF_INFO , NIIF_INFO [EOL] import win32con [EOL] [EOL] [EOL] class WindowsToast : [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] wc = WNDCLASS ( ) [EOL] wc . lpszClassName = [string] [EOL] wc . lpfnWndProc = { win32con . WM_DESTROY : self . OnDestroy , } [EOL] self . classAtom = RegisterClass ( wc ) [EOL] self . hinst = wc . hInstance = GetModuleHandle ( None ) [EOL] [EOL] def OnDestroy ( self , hwnd , msg , wparam , lparam ) : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] def balloon_tip ( self , title , msg ) : [EOL] style = win32con . WS_OVERLAPPED | win32con . WS_SYSMENU [EOL] hwnd = CreateWindow ( self . classAtom , [string] , style , [number] , [number] , win32con . CW_USEDEFAULT , win32con . CW_USEDEFAULT , [number] , [number] , self . hinst , None ) [EOL] UpdateWindow ( hwnd ) [EOL] [EOL] hicon = LoadIcon ( [number] , win32con . IDI_APPLICATION ) [EOL] [EOL] nid = ( hwnd , [number] , NIF_ICON | NIF_MESSAGE | NIF_TIP , win32con . WM_USER + [number] , hicon , [string] ) [EOL] Shell_NotifyIcon ( NIM_ADD , nid ) [EOL] nid = ( hwnd , [number] , NIF_INFO , win32con . WM_USER + [number] , hicon , [string] , msg , [number] , title , NIIF_INFO ) [EOL] Shell_NotifyIcon ( NIM_MODIFY , nid ) [EOL] [EOL] DestroyWindow ( hwnd ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,unknown,builtins.int,typing.Any,typing_extensions.Literal,typing.Any,typing_extensions.Literal,typing.Any,unknown]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,unknown,builtins.int,typing.Any,typing_extensions.Literal,typing.Any,typing_extensions.Literal,typing.Any,unknown]$ 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,unknown,builtins.int,typing.Any,typing_extensions.Literal,typing.Any,typing_extensions.Literal,typing.Any,unknown]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,unknown,builtins.int,typing.Any,typing_extensions.Literal,typing.Any,typing_extensions.Literal,typing.Any,unknown]$ 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import zipfile [EOL] import io [EOL] import urllib [EOL] import hashlib [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import hashlib [EOL] import os [EOL] import os . path [EOL] import platform [EOL] import shutil [EOL] from socket import error as socket_error [EOL] import stat [EOL] from io import BytesIO [EOL] import sys [EOL] import time [EOL] import zipfile [EOL] import six . moves . urllib as urllib [EOL] [EOL] [EOL] try : [EOL] from ssl import HAS_SNI [EOL] except ImportError : [EOL] HAS_SNI = False [EOL] [EOL] HAS_SNI_AND_RECENT_PYTHON = HAS_SNI and sys . version_info >= ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def get_static_rust_lang_org_dist ( ) : [EOL] if HAS_SNI_AND_RECENT_PYTHON : [EOL] return [string] [EOL] [EOL] return [string] [EOL] [EOL] [EOL] def get_urlopen_kwargs ( ) : [EOL] [comment] [EOL] if HAS_SNI_AND_RECENT_PYTHON : [EOL] import certifi [EOL] return { [string] : certifi . where ( ) } [EOL] return { } [EOL] [EOL] [EOL] def remove_readonly ( func , path , _ ) : [EOL] [docstring] [EOL] os . chmod ( path , stat . S_IWRITE ) [EOL] func ( path ) [EOL] [EOL] [EOL] def delete ( path ) : [EOL] if os . path . isdir ( path ) and not os . path . islink ( path ) : [EOL] shutil . rmtree ( path , onerror = remove_readonly ) [EOL] else : [EOL] os . remove ( path ) [EOL] [EOL] [EOL] def host_platform ( ) : [EOL] os_type = platform . system ( ) . lower ( ) [EOL] if os_type == [string] : [EOL] os_type = [string] [EOL] elif os_type == [string] : [EOL] os_type = [string] [EOL] elif os_type == [string] : [EOL] os_type = [string] [EOL] elif os_type == [string] : [EOL] os_type = [string] [EOL] elif os_type == [string] : [EOL] os_type = [string] [EOL] else : [EOL] os_type = [string] [EOL] return os_type [EOL] [EOL] [EOL] def host_triple ( ) : [EOL] os_type = host_platform ( ) [EOL] cpu_type = platform . machine ( ) . lower ( ) [EOL] if cpu_type in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] cpu_type = [string] [EOL] elif cpu_type in [ [string] , [string] , [string] , [string] ] : [EOL] cpu_type = [string] [EOL] elif cpu_type == [string] : [EOL] cpu_type = [string] [EOL] elif cpu_type == [string] : [EOL] cpu_type = [string] [EOL] else : [EOL] cpu_type = [string] [EOL] [EOL] return [string] . format ( cpu_type , os_type ) [EOL] [EOL] [EOL] def download ( desc , src , writer , start_byte = [number] ) : [EOL] if start_byte : [EOL] print ( [string] . format ( src ) ) [EOL] else : [EOL] print ( [string] . format ( src ) ) [EOL] dumb = ( os . environ . get ( [string] ) == [string] ) or ( not sys . stdout . isatty ( ) ) [EOL] [EOL] try : [EOL] req = urllib . request . Request ( src ) [EOL] if start_byte : [EOL] req = urllib . request . Request ( src , headers = { [string] : [string] . format ( start_byte ) } ) [EOL] resp = urllib . request . urlopen ( req , ** get_urlopen_kwargs ( ) ) [EOL] [EOL] fsize = None [EOL] if resp . info ( ) . get ( [string] ) : [EOL] fsize = int ( resp . info ( ) . get ( [string] ) . strip ( ) ) + start_byte [EOL] [EOL] recved = start_byte [EOL] chunk_size = [number] * [number] [EOL] [EOL] previous_progress_line = None [EOL] previous_progress_line_time = [number] [EOL] while True : [EOL] chunk = resp . read ( chunk_size ) [EOL] if not chunk : [EOL] break [EOL] recved += len ( chunk ) [EOL] if not dumb : [EOL] if fsize is not None : [EOL] pct = recved * [number] / fsize [EOL] progress_line = [string] % ( desc , pct ) [EOL] now = time . time ( ) [EOL] duration = now - previous_progress_line_time [EOL] if progress_line != previous_progress_line and duration > [number] : [EOL] print ( progress_line , end = [string] ) [EOL] previous_progress_line = progress_line [EOL] previous_progress_line_time = now [EOL] [EOL] sys . stdout . flush ( ) [EOL] writer . write ( chunk ) [EOL] [EOL] if not dumb : [EOL] print ( ) [EOL] except urllib . error . HTTPError as e : [EOL] print ( [string] . format ( e . code , e . reason , src ) ) [EOL] if e . code == [number] : [EOL] print ( [string] [string] ) [EOL] sys . exit ( [number] ) [EOL] except urllib . error . URLError as e : [EOL] print ( [string] . format ( desc , e . reason , src ) ) [EOL] sys . exit ( [number] ) [EOL] except socket_error as e : [EOL] print ( [string] . format ( e ) ) [EOL] sys . exit ( [number] ) [EOL] except KeyboardInterrupt : [EOL] writer . flush ( ) [EOL] raise [EOL] [EOL] [EOL] def download_bytes ( desc , src ) : [EOL] content_writer = BytesIO ( ) [EOL] download ( desc , src , content_writer ) [EOL] return content_writer . getvalue ( ) [EOL] [EOL] [EOL] def download_file ( desc , src , dst ) : [EOL] tmp_path = dst + [string] [EOL] try : [EOL] start_byte = os . path . getsize ( tmp_path ) [EOL] with open ( tmp_path , [string] ) as fd : [EOL] download ( desc , src , fd , start_byte = start_byte ) [EOL] except os . error : [EOL] with open ( tmp_path , [string] ) as fd : [EOL] download ( desc , src , fd ) [EOL] os . rename ( tmp_path , dst ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class ZipFileWithUnixPermissions ( zipfile . ZipFile ) : [EOL] def extract ( self , member , path = None , pwd = None ) : [EOL] if not isinstance ( member , zipfile . ZipInfo ) : [EOL] member = self . getinfo ( member ) [EOL] [EOL] if path is None : [EOL] path = os . getcwd ( ) [EOL] [EOL] extracted = self . _extract_member ( member , path , pwd ) [EOL] mode = os . stat ( extracted ) . st_mode [EOL] mode |= ( member . external_attr >> [number] ) [EOL] os . chmod ( extracted , mode ) [EOL] return extracted [EOL] [EOL] [comment] [EOL] def _extract_member ( self , member , targetpath , pwd ) : [EOL] if sys . version_info [ [number] ] >= [number] : [EOL] if not isinstance ( member , zipfile . ZipInfo ) : [EOL] member = self . getinfo ( member ) [EOL] [EOL] targetpath = super ( ) . _extract_member ( member , targetpath , pwd ) [EOL] [EOL] attr = member . external_attr >> [number] [EOL] if attr != [number] : [EOL] os . chmod ( targetpath , attr ) [EOL] return targetpath [EOL] else : [EOL] return super ( ZipFileWithUnixPermissions , self ) . _extract_member ( member , targetpath , pwd ) [EOL] [EOL] [EOL] def extract ( src , dst , movedir = None , remove = True ) : [EOL] assert src . endswith ( [string] ) [EOL] ZipFileWithUnixPermissions ( src ) . extractall ( dst ) [EOL] [EOL] if movedir : [EOL] for f in os . listdir ( movedir ) : [EOL] frm = os . path . join ( movedir , f ) [EOL] to = os . path . join ( dst , f ) [EOL] os . rename ( frm , to ) [EOL] os . rmdir ( movedir ) [EOL] [EOL] if remove : [EOL] os . remove ( src ) [EOL] [EOL] [EOL] def check_hash ( filename , expected , algorithm ) : [EOL] hasher = hashlib . new ( algorithm ) [EOL] with open ( filename , [string] ) as f : [EOL] while True : [EOL] block = f . read ( [number] * [number] ) [EOL] if len ( block ) == [number] : [EOL] break [EOL] hasher . update ( block ) [EOL] if hasher . hexdigest ( ) != expected : [EOL] print ( [string] . format ( algorithm , filename ) ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipInfo$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipInfo$ 0 0 0 0 0 0 0 $zipfile.ZipInfo$ 0 0 0 0 0 $zipfile.ZipInfo$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $zipfile.ZipInfo$ 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 $zipfile.ZipInfo$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $zipfile.ZipInfo$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipInfo$ 0 0 0 0 0 0 0 $zipfile.ZipInfo$ 0 0 0 0 0 $zipfile.ZipInfo$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $zipfile.ZipInfo$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $zipfile.ZipInfo$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipInfo$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] import os [EOL] import sys [EOL] [EOL] from servo_tidy . tidy import LintRunner , filter_file [EOL] [EOL] WPT_PATH = os . path . join ( [string] , [string] , [string] ) [EOL] SUITES = [ [string] , os . path . join ( [string] , [string] ) ] [EOL] [EOL] [EOL] class Lint ( LintRunner ) : [EOL] def _get_wpt_files ( self , suite ) : [EOL] working_dir = os . path . join ( WPT_PATH , suite , [string] ) [EOL] file_iter = self . get_files ( working_dir , exclude_dirs = [ ] ) [EOL] print ( [string] % working_dir ) [EOL] for f in file_iter : [EOL] if filter_file ( f ) : [EOL] yield f [ len ( working_dir ) : ] [EOL] [EOL] def run ( self ) : [EOL] if self . stylo or self . no_wpt : [EOL] return [EOL] [EOL] wpt_working_dir = os . path . abspath ( os . path . join ( WPT_PATH , [string] ) ) [EOL] for suite in SUITES : [EOL] files = list ( self . _get_wpt_files ( suite ) ) [EOL] if not files : [EOL] continue [EOL] sys . path . insert ( [number] , wpt_working_dir ) [EOL] from tools . lint import lint [EOL] sys . path . remove ( wpt_working_dir ) [EOL] file_dir = os . path . abspath ( os . path . join ( WPT_PATH , suite ) ) [EOL] returncode = lint . lint ( file_dir , files , output_format = [string] ) [EOL] if returncode : [EOL] yield ( [string] , [string] , [string] % returncode ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import io [EOL] import typing [EOL] import subprocess [EOL] import os [EOL] import random [EOL] import logging [EOL] [EOL] from mutator import Mutator , get_strategies [EOL] from enum import Enum [EOL] DEVNULL = open ( os . devnull , [string] ) [EOL] [EOL] logging . basicConfig ( format = [string] , level = logging . DEBUG ) [EOL] [EOL] [EOL] class Status ( Enum ) : [EOL] KILLED = [number] [EOL] SURVIVED = [number] [EOL] SKIPPED = [number] [EOL] UNEXPECTED = [number] [EOL] [EOL] [EOL] def mutation_test ( file_name , tests ) : [EOL] status = Status . UNEXPECTED [EOL] local_changes_present = subprocess . call ( [string] . format ( file_name ) , shell = True ) [EOL] if local_changes_present == [number] : [EOL] status = Status . SKIPPED [EOL] logging . warning ( [string] . format ( file_name ) ) [EOL] else : [EOL] strategies = list ( get_strategies ( ) ) [EOL] while len ( strategies ) : [EOL] strategy = random . choice ( strategies ) [EOL] strategies . remove ( strategy ) [EOL] mutator = Mutator ( strategy ( ) ) [EOL] mutated_line = mutator . mutate ( file_name ) [EOL] if mutated_line != - [number] : [EOL] logging . info ( [string] . format ( file_name , mutated_line ) ) [EOL] logging . info ( [string] . format ( file_name , mutated_line ) ) [EOL] test_command = [string] [EOL] if subprocess . call ( test_command , shell = True , stdout = DEVNULL ) : [EOL] logging . error ( [string] ) [EOL] logging . error ( [string] . format ( test_command ) ) [EOL] subprocess . call ( [string] . format ( file_name ) , shell = True ) [EOL] status = Status . UNEXPECTED [EOL] else : [EOL] for test in tests : [EOL] test_command = [string] . format ( test . encode ( [string] ) ) [EOL] logging . info ( [string] . format ( test , file_name , mutated_line ) ) [EOL] test_status = subprocess . call ( test_command , shell = True , stdout = DEVNULL ) [EOL] if test_status != [number] : [EOL] logging . error ( [string] . format ( test_command ) ) [EOL] logging . error ( [string] . format ( file_name ) ) [EOL] subprocess . call ( [string] . format ( file_name ) , shell = True ) [EOL] status = Status . SURVIVED [EOL] else : [EOL] logging . info ( [string] . format ( test . encode ( [string] ) ) ) [EOL] status = Status . KILLED [EOL] break [EOL] logging . info ( [string] . format ( file_name , mutated_line ) ) [EOL] subprocess . call ( [string] . format ( file_name ) , shell = True ) [EOL] break [EOL] elif not len ( strategies ) : [EOL] [comment] [EOL] logging . info ( [string] . format ( file_name ) ) [EOL] return status [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Any , Dict [EOL] import typing [EOL] from os import listdir [EOL] from os . path import isfile , isdir , join [EOL] import json [EOL] import sys [EOL] import test [EOL] import logging [EOL] import random [EOL] [EOL] test_summary = { test . Status . KILLED : [number] , test . Status . SURVIVED : [number] , test . Status . SKIPPED : [number] , test . Status . UNEXPECTED : [number] } [EOL] [EOL] [EOL] def get_folders_list ( path ) : [EOL] folder_list = [ ] [EOL] for filename in listdir ( path ) : [EOL] if isdir ( join ( path , filename ) ) : [EOL] folder_name = join ( path , filename ) [EOL] folder_list . append ( folder_name ) [EOL] return folder_list [EOL] [EOL] [EOL] def mutation_test_for ( mutation_path ) : [EOL] test_mapping_file = join ( mutation_path , [string] ) [EOL] if isfile ( test_mapping_file ) : [EOL] json_data = open ( test_mapping_file ) . read ( ) [EOL] test_mapping = json . loads ( json_data ) [EOL] [comment] [EOL] source_files = list ( test_mapping . keys ( ) ) [EOL] random . shuffle ( source_files ) [EOL] for src_file in source_files : [EOL] status = test . mutation_test ( join ( mutation_path , src_file . encode ( [string] ) ) , test_mapping [ src_file ] ) [EOL] test_summary [ status ] += [number] [EOL] [comment] [EOL] for folder in get_folders_list ( mutation_path ) : [EOL] mutation_test_for ( folder ) [EOL] else : [EOL] logging . warning ( [string] . format ( mutation_path ) ) [EOL] [EOL] [EOL] mutation_test_for ( sys . argv [ [number] ] ) [EOL] logging . basicConfig ( format = [string] , level = logging . DEBUG ) [EOL] logging . info ( [string] ) [EOL] logging . info ( [string] . format ( test_summary [ test . Status . KILLED ] ) ) [EOL] logging . info ( [string] . format ( test_summary [ test . Status . SURVIVED ] ) ) [EOL] logging . info ( [string] . format ( test_summary [ test . Status . SKIPPED ] ) ) [EOL] logging . info ( [string] . format ( test_summary [ test . Status . UNEXPECTED ] ) ) [EOL] if test_summary [ test . Status . SURVIVED ] : [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] import fileinput [EOL] import re [EOL] import random [EOL] [EOL] [EOL] def is_comment ( line ) : [EOL] return re . search ( [string] , line ) [EOL] [EOL] [EOL] def init_variables ( if_blocks ) : [EOL] random_index = random . randint ( [number] , len ( if_blocks ) - [number] ) [EOL] start_counter = [number] [EOL] end_counter = [number] [EOL] lines_to_delete = [ ] [EOL] line_to_mutate = if_blocks [ random_index ] [EOL] return random_index , start_counter , end_counter , lines_to_delete , line_to_mutate [EOL] [EOL] [EOL] def deleteStatements ( file_name , line_numbers ) : [EOL] for line in fileinput . input ( file_name , inplace = True ) : [EOL] if fileinput . lineno ( ) not in line_numbers : [EOL] print ( line . rstrip ( ) ) [EOL] [EOL] [EOL] class Strategy : [EOL] def __init__ ( self ) : [EOL] self . _strategy_name = [string] [EOL] self . _replace_strategy = { } [EOL] [EOL] def mutate ( self , file_name ) : [EOL] line_numbers = [ ] [EOL] for line in fileinput . input ( file_name ) : [EOL] if not is_comment ( line ) and re . search ( self . _replace_strategy [ [string] ] , line ) : [EOL] line_numbers . append ( fileinput . lineno ( ) ) [EOL] if len ( line_numbers ) == [number] : [EOL] return - [number] [EOL] else : [EOL] mutation_line_number = line_numbers [ random . randint ( [number] , len ( line_numbers ) - [number] ) ] [EOL] for line in fileinput . input ( file_name , inplace = True ) : [EOL] if fileinput . lineno ( ) == mutation_line_number : [EOL] line = re . sub ( self . _replace_strategy [ [string] ] , self . _replace_strategy [ [string] ] , line ) [EOL] print ( line . rstrip ( ) ) [EOL] return mutation_line_number [EOL] [EOL] [EOL] class AndOr ( Strategy ) : [EOL] def __init__ ( self ) : [EOL] Strategy . __init__ ( self ) [EOL] logical_and = [string] [EOL] self . _replace_strategy = { [string] : logical_and , [string] : [string] } [EOL] [EOL] [EOL] class IfTrue ( Strategy ) : [EOL] def __init__ ( self ) : [EOL] Strategy . __init__ ( self ) [EOL] if_condition = [string] [EOL] self . _replace_strategy = { [string] : if_condition , [string] : [string] } [EOL] [EOL] [EOL] class IfFalse ( Strategy ) : [EOL] def __init__ ( self ) : [EOL] Strategy . __init__ ( self ) [EOL] if_condition = [string] [EOL] self . _replace_strategy = { [string] : if_condition , [string] : [string] } [EOL] [EOL] [EOL] class ModifyComparision ( Strategy ) : [EOL] def __init__ ( self ) : [EOL] Strategy . __init__ ( self ) [EOL] less_than_equals = [string] [EOL] greater_than_equals = [string] [EOL] self . _replace_strategy = { [string] : ( less_than_equals + [string] + greater_than_equals ) , [string] : [string] } [EOL] [EOL] [EOL] class MinusToPlus ( Strategy ) : [EOL] def __init__ ( self ) : [EOL] Strategy . __init__ ( self ) [EOL] arithmetic_minus = [string] [EOL] minus_in_shorthand = [string] [EOL] self . _replace_strategy = { [string] : ( arithmetic_minus + [string] + minus_in_shorthand ) , [string] : [string] } [EOL] [EOL] [EOL] class PlusToMinus ( Strategy ) : [EOL] def __init__ ( self ) : [EOL] Strategy . __init__ ( self ) [EOL] arithmetic_plus = [string] [EOL] plus_in_shorthand = [string] [EOL] self . _replace_strategy = { [string] : ( arithmetic_plus + [string] + plus_in_shorthand ) , [string] : [string] } [EOL] [EOL] [EOL] class AtomicString ( Strategy ) : [EOL] def __init__ ( self ) : [EOL] Strategy . __init__ ( self ) [EOL] string_literal = [string] [EOL] self . _replace_strategy = { [string] : string_literal , [string] : [string] } [EOL] [EOL] [EOL] class DuplicateLine ( Strategy ) : [EOL] def __init__ ( self ) : [EOL] Strategy . __init__ ( self ) [EOL] self . _strategy_name = [string] [EOL] append_statement = [string] [EOL] remove_statement = [string] [EOL] push_statement = [string] [EOL] pop_statement = [string] [EOL] plus_equals_statement = [string] [EOL] minus_equals_statement = [string] [EOL] self . _replace_strategy = { [string] : ( append_statement + [string] + remove_statement + [string] + push_statement + [string] + pop_statement + [string] + plus_equals_statement + [string] + minus_equals_statement ) , [string] : [string] , } [EOL] [EOL] [EOL] class DeleteIfBlock ( Strategy ) : [EOL] def __init__ ( self ) : [EOL] Strategy . __init__ ( self ) [EOL] self . if_block = [string] [EOL] self . else_block = [string] [EOL] [EOL] def mutate ( self , file_name ) : [EOL] code_lines = [ ] [EOL] if_blocks = [ ] [EOL] for line in fileinput . input ( file_name ) : [EOL] code_lines . append ( line ) [EOL] if re . search ( self . if_block , line ) : [EOL] if_blocks . append ( fileinput . lineno ( ) ) [EOL] if len ( if_blocks ) == [number] : [EOL] return - [number] [EOL] random_index , start_counter , end_counter , lines_to_delete , line_to_mutate = init_variables ( if_blocks ) [EOL] while line_to_mutate <= len ( code_lines ) : [EOL] current_line = code_lines [ line_to_mutate - [number] ] [EOL] next_line = code_lines [ line_to_mutate ] [EOL] if re . search ( self . else_block , current_line ) is not None or re . search ( self . else_block , next_line ) is not None : [EOL] if_blocks . pop ( random_index ) [EOL] if len ( if_blocks ) == [number] : [EOL] return - [number] [EOL] else : [EOL] random_index , start_counter , end_counter , lines_to_delete , line_to_mutate = init_variables ( if_blocks ) [EOL] continue [EOL] lines_to_delete . append ( line_to_mutate ) [EOL] for ch in current_line : [EOL] if ch == [string] : [EOL] start_counter += [number] [EOL] elif ch == [string] : [EOL] end_counter += [number] [EOL] if start_counter and start_counter == end_counter : [EOL] deleteStatements ( file_name , lines_to_delete ) [EOL] return lines_to_delete [ [number] ] [EOL] line_to_mutate += [number] [EOL] [EOL] [EOL] def get_strategies ( ) : [EOL] return AndOr , IfTrue , IfFalse , ModifyComparision , PlusToMinus , MinusToPlus , AtomicString , DuplicateLine , DeleteIfBlock [EOL] [EOL] [EOL] class Mutator : [EOL] def __init__ ( self , strategy ) : [EOL] self . _strategy = strategy [EOL] [EOL] def mutate ( self , file_name ) : [EOL] return self . _strategy . mutate ( file_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import DefaultDict , Dict , Any , List [EOL] import typing [EOL] from mozlog . formatters import base [EOL] import collections [EOL] import json [EOL] import os [EOL] import sys [EOL] import subprocess [EOL] import platform [EOL] from six import itervalues , iteritems [EOL] [EOL] DEFAULT_MOVE_UP_CODE = [string] [EOL] DEFAULT_CLEAR_EOL_CODE = [string] [EOL] [EOL] [EOL] class ServoFormatter ( base . BaseFormatter ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] self . number_of_tests = [number] [EOL] self . completed_tests = [number] [EOL] self . need_to_erase_last_line = False [EOL] self . current_display = [string] [EOL] self . running_tests = { } [EOL] self . test_output = collections . defaultdict ( str ) [EOL] self . subtest_failures = collections . defaultdict ( list ) [EOL] self . test_failure_text = [string] [EOL] self . tests_with_failing_subtests = [ ] [EOL] self . interactive = os . isatty ( sys . stdout . fileno ( ) ) [EOL] [EOL] [comment] [EOL] if self . interactive : [EOL] self . move_up , self . clear_eol = self . get_move_up_and_clear_eol_codes ( ) [EOL] if platform . system ( ) != [string] : [EOL] self . line_width = int ( subprocess . check_output ( [ [string] , [string] ] ) . split ( ) [ [number] ] ) [EOL] else : [EOL] [comment] [EOL] self . line_width = [number] [EOL] [EOL] self . expected = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] self . unexpected_tests = { [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , } [EOL] [EOL] def get_move_up_and_clear_eol_codes ( self ) : [EOL] try : [EOL] import blessings [EOL] except ImportError : [EOL] return DEFAULT_MOVE_UP_CODE , DEFAULT_CLEAR_EOL_CODE [EOL] [EOL] try : [EOL] self . terminal = blessings . Terminal ( ) [EOL] return self . terminal . move_up , self . terminal . clear_eol [EOL] except Exception as exception : [EOL] sys . stderr . write ( [string] [string] % exception ) [EOL] return DEFAULT_MOVE_UP_CODE , DEFAULT_CLEAR_EOL_CODE [EOL] [EOL] def text_to_erase_display ( self ) : [EOL] if not self . interactive or not self . current_display : [EOL] return [string] [EOL] return ( ( self . move_up + self . clear_eol ) * self . current_display . count ( [string] ) ) [EOL] [EOL] def generate_output ( self , text = None , new_display = None , unexpected_in_test = None ) : [EOL] if not self . interactive : [EOL] return text [EOL] [EOL] output = self . text_to_erase_display ( ) [EOL] if text : [EOL] output += text [EOL] if new_display is not None : [EOL] self . current_display = new_display [EOL] return output + self . current_display [EOL] [EOL] def test_counter ( self ) : [EOL] if self . number_of_tests == [number] : [EOL] return [string] % self . completed_tests [EOL] else : [EOL] return [string] % ( self . completed_tests , self . number_of_tests ) [EOL] [EOL] def build_status_line ( self ) : [EOL] new_display = self . test_counter ( ) [EOL] [EOL] if self . running_tests : [EOL] indent = [string] * len ( new_display ) [EOL] if self . interactive : [EOL] max_width = self . line_width - len ( new_display ) [EOL] else : [EOL] max_width = sys . maxsize [EOL] return new_display + ( [string] % indent ) . join ( val [ : max_width ] for val in self . running_tests . values ( ) ) + [string] [EOL] else : [EOL] return new_display + [string] [EOL] [EOL] def suite_start ( self , data ) : [EOL] self . number_of_tests = sum ( len ( tests ) for tests in itervalues ( data [ [string] ] ) ) [EOL] self . start_time = data [ [string] ] [EOL] [EOL] if self . number_of_tests == [number] : [EOL] return [string] % data [ [string] ] [EOL] else : [EOL] return [string] % ( self . number_of_tests , data [ [string] ] ) [EOL] [EOL] def test_start ( self , data ) : [EOL] self . running_tests [ data [ [string] ] ] = data [ [string] ] [EOL] if self . interactive : [EOL] return self . generate_output ( new_display = self . build_status_line ( ) ) [EOL] [EOL] def wrap_and_indent_lines ( self , lines , indent ) : [EOL] assert ( len ( lines ) > [number] ) [EOL] [EOL] output = indent + [string] % lines [ [number] ] [EOL] for line in lines [ [number] : - [number] ] : [EOL] output += indent + [string] % line [EOL] if len ( lines ) > [number] : [EOL] output += indent + [string] % lines [ - [number] ] [EOL] return output [EOL] [EOL] def get_lines_for_unexpected_result ( self , test_name , status , expected , message , stack ) : [EOL] [comment] [EOL] [comment] [EOL] test_name = test_name . encode ( [string] ) [EOL] [EOL] if expected : [EOL] expected_text = [string] % expected [EOL] else : [EOL] expected_text = [string] [EOL] [EOL] lines = [ [string] % ( status , expected_text , test_name ) ] [EOL] if message : [EOL] for message_line in message . splitlines ( ) : [EOL] lines . append ( [string] % message_line ) [EOL] if stack : [EOL] lines . append ( [string] ) [EOL] lines . extend ( stack . splitlines ( ) ) [EOL] return lines [EOL] [EOL] def get_output_for_unexpected_subtests ( self , test_name , unexpected_subtests ) : [EOL] if not unexpected_subtests : [EOL] return [string] [EOL] [EOL] def add_subtest_failure ( lines , subtest , stack = None ) : [EOL] lines += self . get_lines_for_unexpected_result ( subtest . get ( [string] , None ) , subtest . get ( [string] , None ) , subtest . get ( [string] , None ) , subtest . get ( [string] , None ) , stack ) [EOL] [EOL] def make_subtests_failure ( test_name , subtests , stack = None ) : [EOL] lines = [ [string] % test_name ] [EOL] for subtest in subtests [ : - [number] ] : [EOL] add_subtest_failure ( lines , subtest , None ) [EOL] add_subtest_failure ( lines , subtests [ - [number] ] , stack ) [EOL] return self . wrap_and_indent_lines ( lines , [string] ) + [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] output = [string] [EOL] failures_by_stack = collections . defaultdict ( list ) [EOL] for failure in unexpected_subtests : [EOL] [comment] [EOL] if [string] not in failure : [EOL] output += make_subtests_failure ( test_name , [ failure ] , None ) [EOL] else : [EOL] failures_by_stack [ failure [ [string] ] ] . append ( failure ) [EOL] [EOL] for ( stack , failures ) in iteritems ( failures_by_stack ) : [EOL] output += make_subtests_failure ( test_name , failures , stack ) [EOL] return output [EOL] [EOL] def test_end ( self , data ) : [EOL] self . completed_tests += [number] [EOL] test_status = data [ [string] ] [EOL] test_name = data [ [string] ] [EOL] had_unexpected_test_result = [string] in data [EOL] subtest_failures = self . subtest_failures . pop ( test_name , [ ] ) [EOL] [EOL] del self . running_tests [ data [ [string] ] ] [EOL] [EOL] if not had_unexpected_test_result and not subtest_failures : [EOL] self . expected [ test_status ] += [number] [EOL] if self . interactive : [EOL] new_display = self . build_status_line ( ) [EOL] return self . generate_output ( new_display = new_display ) [EOL] else : [EOL] return self . generate_output ( text = [string] % ( self . test_counter ( ) , test_name ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if test_status in ( [string] , [string] ) : [EOL] stack = self . test_output [ test_name ] + data . get ( [string] , [string] ) [EOL] else : [EOL] stack = data . get ( [string] , None ) [EOL] [EOL] output = [string] [EOL] if had_unexpected_test_result : [EOL] self . unexpected_tests [ test_status ] . append ( data ) [EOL] lines = self . get_lines_for_unexpected_result ( test_name , test_status , data . get ( [string] , None ) , data . get ( [string] , None ) , stack ) [EOL] output += self . wrap_and_indent_lines ( lines , [string] ) + [string] [EOL] [EOL] if subtest_failures : [EOL] self . tests_with_failing_subtests . append ( test_name ) [EOL] output += self . get_output_for_unexpected_subtests ( test_name , subtest_failures ) [EOL] self . test_failure_text += output [EOL] [EOL] new_display = self . build_status_line ( ) [EOL] return self . generate_output ( text = output , new_display = new_display , unexpected_in_test = test_name ) [EOL] [EOL] def test_status ( self , data ) : [EOL] if [string] in data : [EOL] self . subtest_failures [ data [ [string] ] ] . append ( data ) [EOL] [EOL] def suite_end ( self , data ) : [EOL] self . end_time = data [ [string] ] [EOL] [EOL] if not self . interactive : [EOL] output = [string] [EOL] else : [EOL] output = [string] [EOL] [EOL] output += [string] % ( self . completed_tests , ( self . end_time - self . start_time ) / [number] ) [EOL] output += [string] % ( sum ( self . expected . values ( ) ) , self . expected [ [string] ] ) [EOL] [EOL] def text_for_unexpected_list ( text , section ) : [EOL] tests = self . unexpected_tests [ section ] [EOL] if not tests : [EOL] return [string] [EOL] return [string] % ( len ( tests ) , text ) [EOL] [EOL] output += text_for_unexpected_list ( [string] , [string] ) [EOL] output += text_for_unexpected_list ( [string] , [string] ) [EOL] output += text_for_unexpected_list ( [string] , [string] ) [EOL] output += text_for_unexpected_list ( [string] , [string] ) [EOL] output += text_for_unexpected_list ( [string] , [string] ) [EOL] output += text_for_unexpected_list ( [string] , [string] ) [EOL] [EOL] num_with_failing_subtests = len ( self . tests_with_failing_subtests ) [EOL] if num_with_failing_subtests : [EOL] output += ( [string] % num_with_failing_subtests ) [EOL] output += [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not self . interactive and self . test_failure_text : [EOL] output += [string] + self . test_failure_text [EOL] [EOL] return self . generate_output ( text = output , new_display = [string] ) [EOL] [EOL] def process_output ( self , data ) : [EOL] if data [ [string] ] not in self . running_tests : [EOL] return [EOL] test_name = self . running_tests [ data [ [string] ] ] [EOL] self . test_output [ test_name ] += data [ [string] ] + [string] [EOL] [EOL] def log ( self , data ) : [EOL] [comment] [EOL] [comment] [EOL] if data [ [string] ] . startswith ( [string] ) : [EOL] return self . generate_output ( text = data [ [string] ] + [string] ) [EOL] [EOL] if data [ [string] ] in ( [string] , [string] ) : [EOL] return self . generate_output ( text = data [ [string] ] + [string] ) [EOL] [EOL] [EOL] class ServoJsonFormatter ( ServoFormatter ) : [EOL] def suite_start ( self , data ) : [EOL] ServoFormatter . suite_start ( self , data ) [EOL] [comment] [EOL] [EOL] def generate_output ( self , text = None , new_display = None , unexpected_in_test = None ) : [EOL] if unexpected_in_test : [EOL] return [string] % json . dumps ( { [string] : unexpected_in_test , [string] : text } ) [EOL] [EOL] def log ( self , _ ) : [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Literal , Any , Dict [EOL] import typing_extensions [EOL] import typing [EOL] import multiprocessing [EOL] import os [EOL] from os import path [EOL] import sys [EOL] import mozlog [EOL] import grouping_formatter [EOL] [EOL] here = os . path . split ( __file__ ) [ [number] ] [EOL] servo_root = os . path . abspath ( os . path . join ( here , [string] , [string] ) ) [EOL] [EOL] [EOL] def wpt_path ( * args ) : [EOL] return os . path . join ( here , * args ) [EOL] [EOL] [EOL] def servo_path ( * args ) : [EOL] return os . path . join ( servo_root , * args ) [EOL] [EOL] [EOL] paths = { [string] : wpt_path ( [string] ) , [string] : wpt_path ( [string] ) , [string] : wpt_path ( [string] ) , [string] : wpt_path ( [string] ) , [string] : wpt_path ( [string] ) } [EOL] [comment] [EOL] sys . path . append ( wpt_path ( [string] , [string] ) ) [EOL] import localpaths [comment] [EOL] from wptrunner import wptrunner , wptcommandline [comment] [EOL] [EOL] [EOL] def run_tests ( ** kwargs ) : [EOL] set_defaults ( kwargs ) [EOL] [EOL] mozlog . commandline . log_formatters [ [string] ] = ( grouping_formatter . ServoFormatter , [string] ) [EOL] mozlog . commandline . log_formatters [ [string] ] = ( grouping_formatter . ServoJsonFormatter , [string] ) [EOL] [EOL] use_mach_logging = False [EOL] if len ( kwargs [ [string] ] ) == [number] : [EOL] file_ext = os . path . splitext ( kwargs [ [string] ] [ [number] ] ) [ [number] ] . lower ( ) [EOL] if file_ext in [ [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] use_mach_logging = True [EOL] [EOL] if use_mach_logging : [EOL] wptrunner . setup_logging ( kwargs , { [string] : sys . stdout } ) [EOL] else : [EOL] wptrunner . setup_logging ( kwargs , { [string] : sys . stdout } ) [EOL] [EOL] success = wptrunner . run_tests ( ** kwargs ) [EOL] return [number] if success else [number] [EOL] [EOL] [EOL] def set_defaults ( kwargs ) : [EOL] if kwargs [ [string] ] is None : [EOL] kwargs [ [string] ] = [string] [EOL] [EOL] if kwargs [ [string] ] is None and [string] in paths : [EOL] kwargs [ [string] ] = paths [ [string] ] [EOL] [EOL] if kwargs [ [string] ] is None and [string] in paths : [EOL] kwargs [ [string] ] = paths [ [string] ] [EOL] [EOL] if kwargs [ [string] ] is None : [EOL] kwargs [ [string] ] = False [EOL] [EOL] if kwargs [ [string] ] is None : [EOL] bin_dir = [string] if kwargs [ [string] ] else [string] [EOL] bin_name = [string] [EOL] if sys . platform == [string] : [EOL] bin_name += [string] [EOL] if [string] in os . environ : [EOL] bin_path = path . join ( os . environ [ [string] ] , bin_dir , bin_name ) [EOL] else : [EOL] bin_path = servo_path ( [string] , bin_dir , bin_name ) [EOL] [EOL] kwargs [ [string] ] = bin_path [EOL] kwargs [ [string] ] = bin_path [EOL] [EOL] if kwargs [ [string] ] is None : [EOL] kwargs [ [string] ] = multiprocessing . cpu_count ( ) [EOL] [EOL] if kwargs [ [string] ] is None : [EOL] kwargs [ [string] ] = paths [ [string] ] [EOL] [EOL] if kwargs [ [string] ] is None : [EOL] kwargs [ [string] ] = paths [ [string] ] [EOL] [EOL] if kwargs [ [string] ] is None : [EOL] kwargs [ [string] ] = paths [ [string] ] [EOL] [EOL] if kwargs [ [string] ] is None : [EOL] kwargs [ [string] ] = [string] [EOL] [EOL] kwargs [ [string] ] . append ( servo_path ( [string] , [string] ) ) [EOL] [EOL] wptcommandline . check_args ( kwargs ) [EOL] [EOL] if kwargs . pop ( [string] ) : [EOL] kwargs [ [string] ] [ [string] ] [ [string] ] = wpt_path ( [string] ) [EOL] kwargs [ [string] ] [ [string] ] [ [string] ] = wpt_path ( [string] ) [EOL] kwargs [ [string] ] = wpt_path ( [string] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = wptcommandline . create_parser ( ) [EOL] kwargs = vars ( parser . parse_args ( ) ) [EOL] return run_tests ( ** kwargs ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( [number] if main ( ) else [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Dict , Tuple , Any , Optional [EOL] import argparse [EOL] import _importlib_modulespec [EOL] import typing [EOL] import argparse [EOL] import imp [EOL] import os [EOL] import sys [EOL] import tempfile [EOL] from collections import defaultdict [EOL] from six import iterkeys , iteritems [EOL] [EOL] from mozlog . structured import commandline [EOL] from wptrunner . wptcommandline import get_test_paths , set_from_config [EOL] [EOL] manifest = None [EOL] [EOL] [EOL] servo_root = os . path . join ( os . path . dirname ( __file__ ) , os . pardir , os . pardir ) [EOL] [EOL] [EOL] def do_delayed_imports ( wpt_dir ) : [EOL] global manifest [EOL] sys . path . insert ( [number] , os . path . join ( wpt_dir , [string] , [string] ) ) [EOL] import manifest [comment] [EOL] [EOL] [EOL] def create_parser ( ) : [EOL] p = argparse . ArgumentParser ( ) [EOL] p . add_argument ( [string] , action = [string] , help = [string] ) [EOL] p . add_argument ( [string] , action = [string] , help = [string] ) [EOL] commandline . add_logging_group ( p ) [EOL] [EOL] return p [EOL] [EOL] [EOL] def update ( logger , wpt_dir , check_clean = True , rebuild = False ) : [EOL] localpaths = imp . load_source ( [string] , os . path . join ( wpt_dir , [string] , [string] , [string] ) ) [EOL] kwargs = { [string] : os . path . join ( wpt_dir , [string] ) , [string] : os . path . join ( wpt_dir , [string] ) , [string] : None , [string] : None } [EOL] [EOL] set_from_config ( kwargs ) [EOL] config = kwargs [ [string] ] [EOL] test_paths = get_test_paths ( config ) [EOL] [EOL] do_delayed_imports ( wpt_dir ) [EOL] [EOL] if check_clean : [EOL] return _check_clean ( logger , test_paths ) [EOL] [EOL] return _update ( logger , test_paths , rebuild ) [EOL] [EOL] [EOL] def _update ( logger , test_paths , rebuild ) : [EOL] for url_base , paths in iteritems ( test_paths ) : [EOL] manifest_path = os . path . join ( paths [ [string] ] , [string] ) [EOL] cache_subdir = os . path . relpath ( os . path . dirname ( manifest_path ) , os . path . dirname ( __file__ ) ) [EOL] manifest . manifest . load_and_update ( paths [ [string] ] , manifest_path , url_base , working_copy = True , rebuild = rebuild , cache_root = os . path . join ( servo_root , [string] , cache_subdir ) ) [EOL] return [number] [EOL] [EOL] [EOL] def _check_clean ( logger , test_paths ) : [EOL] manifests_by_path = { } [EOL] rv = [number] [EOL] for url_base , paths in iteritems ( test_paths ) : [EOL] tests_path = paths [ [string] ] [EOL] manifest_path = os . path . join ( paths [ [string] ] , [string] ) [EOL] [EOL] old_manifest = manifest . manifest . load_and_update ( tests_path , manifest_path , url_base , working_copy = False , update = False , write_manifest = False , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cache_root = tempfile . mkdtemp ( ) [EOL] new_manifest = manifest . manifest . load_and_update ( tests_path , manifest_path , url_base , working_copy = True , update = True , cache_root = cache_root , write_manifest = False , allow_cached = False ) [EOL] [EOL] manifests_by_path [ manifest_path ] = ( old_manifest , new_manifest ) [EOL] [EOL] for manifest_path , ( old_manifest , new_manifest ) in iteritems ( manifests_by_path ) : [EOL] if not diff_manifests ( logger , manifest_path , old_manifest , new_manifest ) : [EOL] logger . error ( [string] % manifest_path ) [EOL] rv = [number] [EOL] [EOL] return rv [EOL] [EOL] [EOL] def diff_manifests ( logger , manifest_path , old_manifest , new_manifest ) : [EOL] [docstring] [EOL] logger . info ( [string] % manifest_path ) [EOL] old_items , new_items = defaultdict ( set ) , defaultdict ( set ) [EOL] for manifest , items in [ ( old_manifest , old_items ) , ( new_manifest , new_items ) ] : [EOL] for test_type , path , tests in manifest : [EOL] for test in tests : [EOL] test_id = [ test . id ] [EOL] if hasattr ( test , [string] ) : [EOL] if test . script_metadata is not None : [EOL] test_id . extend ( tuple ( item ) for item in test . script_metadata ) [EOL] if hasattr ( test , [string] ) : [EOL] test_id . extend ( tuple ( item ) for item in test . references ) [EOL] test_id = tuple ( test_id ) [EOL] items [ path ] . add ( ( test_type , test_id ) ) [EOL] [EOL] old_paths = set ( iterkeys ( old_items ) ) [EOL] new_paths = set ( iterkeys ( new_items ) ) [EOL] [EOL] added_paths = new_paths - old_paths [EOL] deleted_paths = old_paths - new_paths [EOL] [EOL] common_paths = new_paths & old_paths [EOL] [EOL] clean = True [EOL] [EOL] for path in added_paths : [EOL] clean = False [EOL] log_error ( logger , manifest_path , [string] % path ) [EOL] for path in deleted_paths : [EOL] clean = False [EOL] log_error ( logger , manifest_path , [string] % path ) [EOL] [EOL] for path in common_paths : [EOL] old_tests = old_items [ path ] [EOL] new_tests = new_items [ path ] [EOL] added_tests = new_tests - old_tests [EOL] removed_tests = old_tests - new_tests [EOL] if added_tests or removed_tests : [EOL] clean = False [EOL] log_error ( logger , manifest_path , [string] % path ) [EOL] [EOL] if clean : [EOL] [comment] [EOL] [comment] [EOL] old_paths = old_manifest . to_json ( ) [ [string] ] [EOL] new_paths = new_manifest . to_json ( ) [ [string] ] [EOL] if old_paths != new_paths : [EOL] logger . warning ( [string] % manifest_path ) [comment] [EOL] clean = False [EOL] [EOL] return clean [EOL] [EOL] [EOL] def log_error ( logger , manifest_path , msg ) : [EOL] logger . lint_error ( path = manifest_path , message = msg , lineno = [number] , source = [string] , linter = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Match , Any , Optional [EOL] import typing [EOL] import json [EOL] import os [EOL] import re [EOL] import sys [EOL] import urllib . request [EOL] from html import escape as html_escape [EOL] [EOL] [EOL] TASKCLUSTER_ROOT_URL = [string] [EOL] [EOL] [EOL] def fetch ( url ) : [EOL] url = TASKCLUSTER_ROOT_URL + [string] + url [EOL] print ( [string] + url ) [EOL] response = urllib . request . urlopen ( url ) [EOL] assert response . getcode ( ) == [number] [EOL] return response [EOL] [EOL] [EOL] def fetch_json ( url ) : [EOL] with fetch ( url ) as response : [EOL] return json . load ( response ) [EOL] [EOL] [EOL] def task ( platform , chunk , key ) : [EOL] return [string] % ( platform , chunk , key ) [EOL] [EOL] [EOL] def failing_reftests ( platform , key ) : [EOL] chunk_1_task_id = fetch_json ( task ( platform , [number] , key ) ) [ [string] ] [EOL] name = fetch_json ( [string] + chunk_1_task_id ) [ [string] ] [ [string] ] [EOL] match = re . search ( [string] , name ) [EOL] assert match . group ( [number] ) == [string] [EOL] total_chunks = int ( match . group ( [number] ) ) [EOL] [EOL] for chunk in range ( [number] , total_chunks + [number] ) : [EOL] with fetch ( task ( platform , chunk , key ) + [string] ) as response : [EOL] yield from parse ( response ) [EOL] [EOL] [EOL] def parse ( file_like ) : [EOL] seen = set ( ) [EOL] for line in file_like : [EOL] message = json . loads ( line ) [EOL] status = message . get ( [string] ) [EOL] if status not in { None , [string] , [string] } : [EOL] screenshots = message . get ( [string] , { } ) . get ( [string] ) [EOL] if screenshots : [EOL] url = message [ [string] ] [EOL] assert url . startswith ( [string] ) [EOL] yield url [ [number] : ] , message . get ( [string] ) == [string] , screenshots [EOL] [EOL] [EOL] def main ( source , commit_sha = None ) : [EOL] failures = Directory ( ) [EOL] [EOL] if commit_sha : [EOL] title = [string] % commit_sha [EOL] failures_2013 = { url for url , _ , _ in failing_reftests ( [string] , source ) } [EOL] for url , _expected_pass , screenshots in failing_reftests ( [string] , source ) : [EOL] if url not in failures_2013 : [EOL] failures . add ( url , screenshots ) [EOL] else : [EOL] title = [string] [EOL] with open ( source , [string] ) as file_obj : [EOL] for url , expected_pass , screenshots in parse ( file_obj ) : [EOL] if expected_pass : [EOL] failures . add ( url , screenshots ) [EOL] [EOL] here = os . path . dirname ( __file__ ) [EOL] with open ( os . path . join ( here , [string] ) ) as f : [EOL] prism_js = f . read ( ) [EOL] with open ( os . path . join ( here , [string] ) ) as f : [EOL] prism_css = f . read ( ) [EOL] with open ( os . path . join ( here , [string] ) , [string] , encoding = [string] ) as html : [EOL] os . chdir ( os . path . join ( here , [string] ) ) [EOL] html . write ( [string] % ( prism_css , title ) ) [EOL] failures . write ( html ) [EOL] html . write ( [string] % prism_js ) [EOL] [EOL] [EOL] class Directory : [EOL] def __init__ ( self ) : [EOL] self . count = [number] [EOL] self . contents = { } [EOL] [EOL] def add ( self , path , screenshots ) : [EOL] self . count += [number] [EOL] first , _ , rest = path . partition ( [string] ) [EOL] if rest : [EOL] self . contents . setdefault ( first , Directory ( ) ) . add ( rest , screenshots ) [EOL] else : [EOL] assert path not in self . contents [EOL] self . contents [ path ] = screenshots [EOL] [EOL] def write ( self , html ) : [EOL] html . write ( [string] ) [EOL] for k , v in self . contents . items ( ) : [EOL] html . write ( [string] % k ) [EOL] if isinstance ( v , Directory ) : [EOL] html . write ( [string] % v . count ) [EOL] v . write ( html ) [EOL] else : [EOL] a , rel , b = v [EOL] html . write ( [string] % ( a [ [string] ] , rel , b [ [string] ] ) ) [EOL] for side in [ a , b ] : [EOL] html . write ( [string] % side [ [string] ] ) [EOL] url = side [ [string] ] [EOL] prefix = [string] [EOL] if url . startswith ( prefix ) : [EOL] filename = [string] + url [ len ( prefix ) : ] [EOL] elif url == [string] : [EOL] src = [string] [EOL] filename = None [EOL] else : [EOL] filename = [string] + url [EOL] if filename : [EOL] with open ( filename , encoding = [string] ) as f : [EOL] src = html_escape ( f . read ( ) ) [EOL] html . write ( [string] % src ) [EOL] html . write ( [string] ) [EOL] html . write ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( * sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] def create_parser ( ) : [EOL] from wptrunner import wptcommandline [EOL] [EOL] parser = wptcommandline . create_parser_update ( ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , type = wptcommandline . abs_path , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] def check_args ( kwargs ) : [EOL] from wptrunner import wptcommandline [EOL] [EOL] wptcommandline . set_from_config ( kwargs ) [EOL] if hasattr ( wptcommandline , [string] ) : [EOL] wptcommandline . check_paths ( kwargs ) [EOL] kwargs [ [string] ] = kwargs [ [string] ] if kwargs [ [string] ] is not None else kwargs [ [string] ] [EOL] [EOL] if kwargs [ [string] ] : [EOL] if kwargs [ [string] ] : [EOL] raise ValueError ( [string] ) [EOL] if kwargs [ [string] ] is None : [EOL] if kwargs [ [string] ] is None : [EOL] raise ValueError ( [string] ) [EOL] with open ( kwargs [ [string] ] ) as f : [EOL] token = f . read ( ) . strip ( ) [EOL] kwargs [ [string] ] = token [EOL] del kwargs [ [string] ] [EOL] return kwargs [EOL] [EOL] def parse_args ( ) : [EOL] parser = create_parser ( ) [EOL] kwargs = vars ( parser . parse_args ( ) ) [EOL] return check_args ( kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Type , Any , List [EOL] import tests [EOL] import typing [EOL] import os [EOL] [EOL] from wptrunner . update . base import Step , StepRunner [EOL] from wptrunner . update . update import LoadConfig , SyncFromUpstream , UpdateMetadata [EOL] from wptrunner . update . tree import NoVCSTree [EOL] [EOL] from . tree import GitTree , HgTree , GeckoCommit [EOL] from . upstream import SyncToUpstream [EOL] [EOL] class LoadTrees ( Step ) : [EOL] [docstring] [EOL] [EOL] provides = [ [string] , [string] ] [EOL] [EOL] def create ( self , state ) : [EOL] if os . path . exists ( state . sync [ [string] ] ) : [EOL] sync_tree = GitTree ( root = state . sync [ [string] ] ) [EOL] else : [EOL] sync_tree = None [EOL] [EOL] if GitTree . is_type ( ) : [EOL] local_tree = GitTree ( commit_cls = GeckoCommit ) [EOL] elif HgTree . is_type ( ) : [EOL] local_tree = HgTree ( commit_cls = GeckoCommit ) [EOL] else : [EOL] local_tree = NoVCSTree ( ) [EOL] [EOL] state . update ( { [string] : local_tree , [string] : sync_tree } ) [EOL] [EOL] [EOL] class UpdateRunner ( StepRunner ) : [EOL] [docstring] [EOL] steps = [ LoadConfig , LoadTrees , SyncToUpstream , SyncFromUpstream , UpdateMetadata ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Literal , Any [EOL] import requests [EOL] import typing_extensions [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] import cStringIO [EOL] import gzip [EOL] import json [EOL] import os [EOL] import requests [EOL] import six . moves . urllib as urllib [EOL] [EOL] treeherder_base = [string] [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def create_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] return parser [EOL] [EOL] def download ( url , prefix , dest , force_suffix = True ) : [EOL] if dest is None : [EOL] dest = [string] [EOL] [EOL] if prefix and not force_suffix : [EOL] name = os . path . join ( dest , prefix + [string] ) [EOL] else : [EOL] name = None [EOL] counter = [number] [EOL] [EOL] while not name or os . path . exists ( name ) : [EOL] counter += [number] [EOL] sep = [string] if not prefix else [string] [EOL] name = os . path . join ( dest , prefix + sep + str ( counter ) + [string] ) [EOL] [EOL] with open ( name , [string] ) as f : [EOL] resp = requests . get ( url , stream = True ) [EOL] for chunk in resp . iter_content ( [number] ) : [EOL] f . write ( chunk ) [EOL] [EOL] def get_blobber_url ( branch , job ) : [EOL] job_id = job [ [string] ] [EOL] resp = requests . get ( urllib . parse . urljoin ( treeherder_base , [string] % ( branch , job_id ) ) ) [EOL] job_data = resp . json ( ) [EOL] [EOL] if job_data : [EOL] assert len ( job_data ) == [number] [EOL] job_data = job_data [ [number] ] [EOL] try : [EOL] details = job_data [ [string] ] [ [string] ] [EOL] for item in details : [EOL] if item [ [string] ] == [string] : [EOL] return item [ [string] ] [EOL] except : [EOL] return None [EOL] [EOL] [EOL] def get_structured_logs ( branch , commit , dest = None ) : [EOL] resp = requests . get ( urllib . parse . urljoin ( treeherder_base , [string] % ( branch , commit ) ) ) [EOL] [EOL] revision_data = resp . json ( ) [EOL] [EOL] result_set = revision_data [ [string] ] [ [number] ] [ [string] ] [EOL] [EOL] resp = requests . get ( urllib . parse . urljoin ( treeherder_base , [string] % ( branch , result_set ) ) ) [EOL] [EOL] job_data = resp . json ( ) [EOL] [EOL] for result in job_data [ [string] ] : [EOL] job_type_name = result [ [string] ] [EOL] if job_type_name . startswith ( [string] ) : [EOL] url = get_blobber_url ( branch , result ) [EOL] if url : [EOL] prefix = result [ [string] ] [comment] [EOL] download ( url , prefix , None ) [EOL] [EOL] def main ( ) : [EOL] parser = create_parser ( ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] get_structured_logs ( args . branch , args . commit ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] import json [EOL] from six . moves . urllib . parse import urljoin [EOL] requests = None [EOL] [EOL] class GitHubError ( Exception ) : [EOL] def __init__ ( self , status , data ) : [EOL] self . status = status [EOL] self . data = data [EOL] [EOL] [EOL] class GitHub ( object ) : [EOL] url_base = [string] [EOL] [EOL] def __init__ ( self , token ) : [EOL] [comment] [EOL] global requests [EOL] if requests is None : [EOL] import requests [EOL] [EOL] self . headers = { [string] : [string] } [EOL] self . auth = ( token , [string] ) [EOL] [EOL] def get ( self , path ) : [EOL] return self . _request ( [string] , path ) [EOL] [EOL] def post ( self , path , data ) : [EOL] return self . _request ( [string] , path , data = data ) [EOL] [EOL] def put ( self , path , data ) : [EOL] return self . _request ( [string] , path , data = data ) [EOL] [EOL] def _request ( self , method , path , data = None ) : [EOL] url = urljoin ( self . url_base , path ) [EOL] [EOL] kwargs = { [string] : self . headers , [string] : self . auth } [EOL] if data is not None : [EOL] kwargs [ [string] ] = json . dumps ( data ) [EOL] [EOL] resp = requests . request ( method , url , ** kwargs ) [EOL] [EOL] if [number] <= resp . status_code < [number] : [EOL] return resp . json ( ) [EOL] else : [EOL] print ( resp . status_code , resp . json ( ) ) [EOL] raise GitHubError ( resp . status_code , resp . json ( ) ) [EOL] [EOL] def repo ( self , owner , name ) : [EOL] [docstring] [EOL] return GitHubRepo . from_name ( self , owner , name ) [EOL] [EOL] [EOL] class GitHubRepo ( object ) : [EOL] def __init__ ( self , github , data ) : [EOL] [docstring] [EOL] self . gh = github [EOL] self . owner = data [ [string] ] [EOL] self . name = data [ [string] ] [EOL] self . url = data [ [string] ] [EOL] self . _data = data [EOL] [EOL] @ classmethod def from_name ( cls , github , owner , name ) : [EOL] data = github . get ( [string] % ( owner , name ) ) [EOL] return cls ( github , data ) [EOL] [EOL] @ property def url_base ( self ) : [EOL] return [string] % ( self . _data [ [string] ] ) [EOL] [EOL] def create_pr ( self , title , head , base , body ) : [EOL] [docstring] [EOL] return PullRequest . create ( self , title , head , base , body ) [EOL] [EOL] def load_pr ( self , number ) : [EOL] [docstring] [EOL] return PullRequest . from_number ( self , number ) [EOL] [EOL] def path ( self , suffix ) : [EOL] return urljoin ( self . url_base , suffix ) [EOL] [EOL] [EOL] class PullRequest ( object ) : [EOL] def __init__ ( self , repo , data ) : [EOL] [docstring] [EOL] [EOL] self . repo = repo [EOL] self . _data = data [EOL] self . number = data [ [string] ] [EOL] self . title = data [ [string] ] [EOL] self . base = data [ [string] ] [ [string] ] [EOL] self . base = data [ [string] ] [ [string] ] [EOL] self . _issue = None [EOL] [EOL] @ classmethod def from_number ( cls , repo , number ) : [EOL] data = repo . gh . get ( repo . path ( [string] % number ) ) [EOL] return cls ( repo , data ) [EOL] [EOL] @ classmethod def create ( cls , repo , title , head , base , body ) : [EOL] data = repo . gh . post ( repo . path ( [string] ) , { [string] : title , [string] : head , [string] : base , [string] : body } ) [EOL] return cls ( repo , data ) [EOL] [EOL] def path ( self , suffix ) : [EOL] return urljoin ( self . repo . path ( [string] % self . number ) , suffix ) [EOL] [EOL] @ property def issue ( self ) : [EOL] [docstring] [EOL] if self . _issue is None : [EOL] self . _issue = Issue . from_number ( self . repo , self . number ) [EOL] return self . _issue [EOL] [EOL] def merge ( self , commit_message = None ) : [EOL] [docstring] [EOL] if commit_message is None : [EOL] commit_message = [string] % ( self . number , self . base ) [EOL] self . repo . gh . put ( self . path ( [string] ) , { [string] : commit_message } ) [EOL] [EOL] [EOL] class Issue ( object ) : [EOL] def __init__ ( self , repo , data ) : [EOL] [docstring] [EOL] self . repo = repo [EOL] self . _data = data [EOL] self . number = data [ [string] ] [EOL] [EOL] @ classmethod def from_number ( cls , repo , number ) : [EOL] data = repo . gh . get ( repo . path ( [string] % number ) ) [EOL] return cls ( repo , data ) [EOL] [EOL] def path ( self , suffix ) : [EOL] return urljoin ( self . repo . path ( [string] % self . number ) , suffix ) [EOL] [EOL] def add_label ( self , label ) : [EOL] [docstring] [EOL] self . repo . gh . post ( self . path ( [string] ) , [ label ] ) [EOL] [EOL] def add_comment ( self , message ) : [EOL] [docstring] [EOL] self . repo . gh . post ( self . path ( [string] ) , { [string] : message } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Type , Any , List [EOL] import tests [EOL] import typing [EOL] from distutils . spawn import find_executable [EOL] import re [EOL] import subprocess [EOL] import sys [EOL] import tempfile [EOL] [EOL] from wptrunner import update as wptupdate [EOL] [EOL] from wptrunner . update . tree import Commit , CommitMessage , get_unique_name [EOL] [EOL] class HgTree ( wptupdate . tree . HgTree ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . commit_cls = kwargs . pop ( [string] , Commit ) [EOL] wptupdate . tree . HgTree . __init__ ( self , * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class GitTree ( wptupdate . tree . GitTree ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] commit_cls = kwargs . pop ( [string] , Commit ) [EOL] wptupdate . tree . GitTree . __init__ ( self , * args , ** kwargs ) [EOL] self . commit_cls = commit_cls [EOL] [EOL] def create_branch ( self , name , ref = None ) : [EOL] [docstring] [EOL] [EOL] args = [ ] [EOL] if ref is not None : [EOL] if hasattr ( ref , [string] ) : [EOL] ref = ref . sha1 [EOL] args . append ( ref ) [EOL] self . git ( [string] , name , * args ) [EOL] [EOL] def commits_by_message ( self , message , path = None ) : [EOL] [docstring] [EOL] args = [ [string] , [string] , [string] , [string] % message ] [EOL] if path is not None : [EOL] args . append ( [string] ) [EOL] args . append ( path ) [EOL] data = self . git ( [string] , * args ) [EOL] return [ self . commit_cls ( self , sha1 ) for sha1 in data . split ( [string] ) ] [EOL] [EOL] def log ( self , base_commit = None , path = None ) : [EOL] [docstring] [EOL] args = [ [string] , [string] , [string] , [string] ] [EOL] if base_commit is not None : [EOL] args . append ( [string] % base_commit . sha1 ) [EOL] if path is not None : [EOL] args . append ( [string] ) [EOL] args . append ( path ) [EOL] data = self . git ( [string] , * args ) [EOL] return [ self . commit_cls ( self , sha1 ) for sha1 in data . split ( [string] ) if sha1 ] [EOL] [EOL] def import_patch ( self , patch , strip_count ) : [EOL] [docstring] [EOL] [EOL] with tempfile . NamedTemporaryFile ( ) as f : [EOL] f . write ( patch . diff ) [EOL] f . flush ( ) [EOL] f . seek ( [number] ) [EOL] self . git ( [string] , [string] , f . name , [string] , str ( strip_count ) ) [EOL] self . git ( [string] , [string] , patch . message . text , [string] % patch . full_author ) [EOL] [EOL] def rebase ( self , ref , continue_rebase = False ) : [EOL] [docstring] [EOL] if continue_rebase : [EOL] args = [ [string] ] [EOL] else : [EOL] if hasattr ( ref , [string] ) : [EOL] ref = ref . sha1 [EOL] args = [ ref ] [EOL] self . git ( [string] , * args ) [EOL] [EOL] def push ( self , remote , local_ref , remote_ref , force = False ) : [EOL] [docstring] [EOL] args = [ ] [EOL] if force : [EOL] args . append ( [string] ) [EOL] args . extend ( [ remote , [string] % ( local_ref , remote_ref ) ] ) [EOL] self . git ( [string] , * args ) [EOL] [EOL] def unique_branch_name ( self , prefix ) : [EOL] [docstring] [EOL] branches = [ ref [ len ( [string] ) : ] for sha1 , ref in self . list_refs ( ) if ref . startswith ( [string] ) ] [EOL] return get_unique_name ( branches , prefix ) [EOL] [EOL] class Patch ( object ) : [EOL] def __init__ ( self , author , email , message , merge_message , diff ) : [EOL] self . author = author [EOL] self . email = email [EOL] self . merge_message = merge_message [EOL] if isinstance ( message , CommitMessage ) : [EOL] self . message = message [EOL] else : [EOL] self . message = GeckoCommitMessage ( message ) [EOL] self . diff = diff [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % self . message . full_summary [EOL] [EOL] @ property def full_author ( self ) : [EOL] return [string] % ( self . author , self . email ) [EOL] [EOL] @ property def empty ( self ) : [EOL] return bool ( self . diff . strip ( ) ) [EOL] [EOL] [EOL] class GeckoCommitMessage ( CommitMessage ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] _bug_re = re . compile ( [string] , re . IGNORECASE ) [EOL] _merge_re = re . compile ( [string] , re . IGNORECASE ) [EOL] [EOL] _backout_re = re . compile ( [string] , re . IGNORECASE ) [EOL] _backout_sha1_re = re . compile ( [string] ) [EOL] [EOL] def _parse_message ( self ) : [EOL] CommitMessage . _parse_message ( self ) [EOL] [EOL] if self . _backout_re . match ( self . full_summary ) : [EOL] self . backouts = self . _backout_re . findall ( self . full_summary ) [EOL] else : [EOL] self . backouts = [ ] [EOL] [EOL] m = self . _merge_re . match ( self . full_summary ) [EOL] if m is not None : [EOL] self . bug , self . reviewer = m . groups ( ) [EOL] self . summary = self . full_summary [EOL] else : [EOL] m = self . _bug_re . match ( self . full_summary ) [EOL] if m is not None : [EOL] self . bug , self . summary , self . reviewer = m . groups ( ) [EOL] else : [EOL] self . bug , self . summary , self . reviewer = None , self . full_summary , None [EOL] [EOL] [EOL] class GeckoCommit ( Commit ) : [EOL] msg_cls = GeckoCommitMessage [EOL] [EOL] def __init__ ( self , tree , sha1 , is_merge = False ) : [EOL] Commit . __init__ ( self , tree , sha1 ) [EOL] if not is_merge : [EOL] args = [ [string] , sha1 ] [EOL] try : [EOL] merge_rev = self . git ( [string] , * args ) . strip ( ) [EOL] except subprocess . CalledProcessError as exn : [EOL] if not find_executable ( [string] ) : [EOL] print ( [string] + [string] ) [EOL] sys . exit ( [number] ) [EOL] raise exn [EOL] self . merge = GeckoCommit ( tree , merge_rev , True ) [EOL] [EOL] def export_patch ( self , path = None ) : [EOL] [docstring] [EOL] args = [ [string] , self . sha1 ] [EOL] if path is not None : [EOL] args . append ( [string] ) [EOL] args . append ( path ) [EOL] [EOL] diff = self . git ( [string] , * args ) [EOL] [EOL] merge_message = self . merge . message if self . merge else None [EOL] return Patch ( self . author , self . email , self . message , merge_message , diff ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.wpt.update.tree.GeckoCommitMessage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] def fail ( msg ) : [EOL] return ( [ ( [string] , [string] ) ] , [string] + msg ) [EOL] [EOL] [EOL] def main ( request , response ) : [EOL] content_type = request . headers . get ( [string] ) . split ( [string] ) [EOL] [EOL] if len ( content_type ) != [number] : [EOL] return fail ( [string] ) [EOL] [EOL] if content_type [ [number] ] != [string] : [EOL] return fail ( [string] ) [EOL] [EOL] boundary = content_type [ [number] ] . strip ( [string] ) [EOL] [EOL] body = [string] + boundary + [string] [EOL] body += [string] + [string] + boundary + [string] [EOL] [EOL] if body != request . body : [EOL] return fail ( [string] + body + [string] + request . body ) [EOL] [EOL] return ( [ ( [string] , [string] ) ] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ] [EOL] if [string] in request . GET : [EOL] headers += [ ( [string] , request . GET [ [string] ] ) ] [EOL] with open ( [string] ) as f : [EOL] return [number] , headers , f . read ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] [EOL] _DO_NOT_EDIT_WARNING = [string] [EOL] [EOL] _HTML_TEMPLATE = [string] [EOL] [EOL] _NUM_TESTS = [number] [EOL] [EOL] def WriteTest ( filename , start , end ) : [EOL] [docstring] [EOL] file = open ( filename , [string] ) [EOL] file . write ( _DO_NOT_EDIT_WARNING ) [EOL] file . write ( _HTML_TEMPLATE % { [string] : start , [string] : end } ) [EOL] file . close [EOL] [EOL] def GenerateTests ( ) : [EOL] [docstring] [EOL] filelist = [ ] [EOL] for ii in range ( _NUM_TESTS ) : [EOL] index_str = str ( ii ) [EOL] if ii < [number] : [EOL] index_str = [string] + index_str [EOL] filename = index_str + [string] [EOL] filelist . append ( filename ) [EOL] WriteTest ( filename , ii , ii + [number] ) [EOL] return filelist [EOL] [EOL] def GenerateTestList ( filelist ) : [EOL] file = open ( [string] , [string] ) [EOL] file . write ( [string] . join ( filelist ) ) [EOL] file . close [EOL] [EOL] def main ( argv ) : [EOL] [docstring] [EOL] filelist = GenerateTests ( ) [EOL] GenerateTestList ( filelist ) [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] [EOL] _DO_NOT_EDIT_WARNING = [string] [EOL] [EOL] _HTML_TEMPLATE = [string] [EOL] [EOL] _FILTERABLE_FORMAT_COUNT = [number] [EOL] _SIZE_2D_COUNT = [number] [EOL] _SIZE_CUBE_COUNT = [number] [EOL] _SIZE_2D_ARRAY_COUNT = [number] [EOL] _SIZE_3D_COUNT = [number] [EOL] _MIN_FILTER_MODE_COUNT = [number] [EOL] _MAG_FILTER_MODE_COUNT = [number] [EOL] _WRAP_MODE_COUNT = [number] [EOL] [EOL] _GROUPS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] _GROUP_TEST_COUNTS = [ _FILTERABLE_FORMAT_COUNT , _SIZE_2D_COUNT , _MIN_FILTER_MODE_COUNT , _FILTERABLE_FORMAT_COUNT , _SIZE_CUBE_COUNT , _MIN_FILTER_MODE_COUNT , [number] , _FILTERABLE_FORMAT_COUNT , _SIZE_2D_ARRAY_COUNT , _MIN_FILTER_MODE_COUNT , _FILTERABLE_FORMAT_COUNT , _SIZE_3D_COUNT , _MIN_FILTER_MODE_COUNT * _MAG_FILTER_MODE_COUNT * _WRAP_MODE_COUNT , ] [EOL] [EOL] def GenerateFilename ( group , count , index ) : [EOL] [docstring] [EOL] assert index >= [number] and index < count [EOL] filename = group [EOL] if count > [number] : [EOL] index_str = str ( index ) [EOL] if index < [number] : [EOL] index_str = [string] + index_str [EOL] filename += [string] + index_str [EOL] filename += [string] [EOL] return filename [EOL] [EOL] def WriteTest ( filename , start , end ) : [EOL] [docstring] [EOL] file = open ( filename , [string] ) [EOL] file . write ( _DO_NOT_EDIT_WARNING ) [EOL] file . write ( _HTML_TEMPLATE % { [string] : start , [string] : end } ) [EOL] file . close [EOL] [EOL] def GenerateTests ( ) : [EOL] [docstring] [EOL] assert len ( _GROUPS ) == len ( _GROUP_TEST_COUNTS ) [EOL] test_index = [number] [EOL] filelist = [ ] [EOL] for ii in range ( len ( _GROUPS ) ) : [EOL] group = _GROUPS [ ii ] [EOL] count = _GROUP_TEST_COUNTS [ ii ] [EOL] for index in range ( count ) : [EOL] filename = GenerateFilename ( group , count , index ) [EOL] filelist . append ( filename ) [EOL] WriteTest ( filename , test_index , test_index + [number] ) [EOL] test_index += [number] [EOL] return filelist [EOL] [EOL] def GenerateTestList ( filelist ) : [EOL] file = open ( [string] , [string] ) [EOL] file . write ( [string] . join ( filelist ) ) [EOL] file . close [EOL] [EOL] def main ( argv ) : [EOL] [docstring] [EOL] filelist = GenerateTests ( ) [EOL] GenerateTestList ( filelist ) [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] [EOL] _DO_NOT_EDIT_WARNING = [string] [EOL] [EOL] _HTML_TEMPLATE = [string] [EOL] [EOL] _TARGETS = [ [string] , [string] , [string] , ] [EOL] [EOL] _FILTERS = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] _COMPARE_FUNCS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] def GenerateFilename ( group ) : [EOL] [docstring] [EOL] filename = group [EOL] filename += [string] [EOL] return filename [EOL] [EOL] def WriteTest ( filename , start , end ) : [EOL] [docstring] [EOL] file = open ( filename , [string] ) [EOL] file . write ( _DO_NOT_EDIT_WARNING ) [EOL] file . write ( _HTML_TEMPLATE % { [string] : start , [string] : end } ) [EOL] file . close [EOL] [EOL] def GenerateTests ( ) : [EOL] [docstring] [EOL] filelist = [ ] [EOL] ii = [number] [EOL] for iTarget in range ( len ( _TARGETS ) ) : [EOL] for iFilter in range ( len ( _FILTERS ) ) : [EOL] for iFunc in range ( len ( _COMPARE_FUNCS ) ) : [EOL] item = _TARGETS [ iTarget ] + [string] + _FILTERS [ iFilter ] + [string] + _COMPARE_FUNCS [ iFunc ] [EOL] filename = GenerateFilename ( item ) [EOL] filelist . append ( filename ) [EOL] WriteTest ( filename , ii , ii + [number] ) [EOL] ii = ii + [number] [EOL] return filelist [EOL] [EOL] def GenerateTestList ( filelist ) : [EOL] file = open ( [string] , [string] ) [EOL] file . write ( [string] . join ( filelist ) ) [EOL] file . close [EOL] [EOL] def main ( argv ) : [EOL] [docstring] [EOL] filelist = GenerateTests ( ) [EOL] GenerateTestList ( filelist ) [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Tuple , Any , List [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] import logging [EOL] import os [EOL] import re [EOL] import subprocess [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _VERSION_REGEX = re . compile ( [string] ) [EOL] [EOL] [EOL] class JsCompilerError ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def _GetJavaVersionString ( ) : [EOL] [docstring] [EOL] return subprocess . check_output ( [ [string] , [string] ] , stderr = subprocess . STDOUT ) [EOL] [EOL] [EOL] def _ParseJavaVersion ( version_string ) : [EOL] [docstring] [EOL] match = _VERSION_REGEX . search ( version_string ) [EOL] if match : [EOL] version = tuple ( int ( x , [number] ) for x in match . groups ( ) ) [EOL] assert len ( version ) == [number] [EOL] return version [EOL] [EOL] [EOL] def _JavaSupports32BitMode ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] supported = False [EOL] try : [EOL] devnull = open ( os . devnull , [string] ) [EOL] return subprocess . call ( [ [string] , [string] , [string] ] , stdout = devnull , stderr = devnull ) == [number] [EOL] except IOError : [EOL] pass [EOL] else : [EOL] devnull . close ( ) [EOL] return supported [EOL] [EOL] [EOL] def _GetJsCompilerArgs ( compiler_jar_path , java_version , source_paths , jvm_flags , compiler_flags ) : [EOL] [docstring] [EOL] [EOL] if java_version < ( [number] , [number] ) : [EOL] raise JsCompilerError ( [string] [string] ) [EOL] [EOL] args = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if _JavaSupports32BitMode ( ) : [EOL] args += [ [string] ] [EOL] [EOL] [comment] [EOL] args += [ [string] ] [EOL] [EOL] [comment] [EOL] if jvm_flags : [EOL] args += jvm_flags [EOL] [EOL] [comment] [EOL] args += [ [string] , compiler_jar_path ] [EOL] [EOL] for path in source_paths : [EOL] args += [ [string] , path ] [EOL] [EOL] [comment] [EOL] if compiler_flags : [EOL] args += compiler_flags [EOL] [EOL] return args [EOL] [EOL] [EOL] def Compile ( compiler_jar_path , source_paths , jvm_flags = None , compiler_flags = None ) : [EOL] [docstring] [EOL] [EOL] java_version = _ParseJavaVersion ( _GetJavaVersionString ( ) ) [EOL] [EOL] args = _GetJsCompilerArgs ( compiler_jar_path , java_version , source_paths , jvm_flags , compiler_flags ) [EOL] [EOL] logging . info ( [string] , [string] . join ( args ) ) [EOL] [EOL] try : [EOL] return subprocess . check_output ( args ) [EOL] except subprocess . CalledProcessError : [EOL] raise JsCompilerError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] import os [EOL] abspath = os . path . abspath ( __file__ ) [EOL] os . chdir ( os . path . dirname ( abspath ) ) [EOL] exec ( compile ( open ( [string] , [string] ) . read ( ) , [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from six import text_type [EOL] [EOL] def main ( request , response ) : [EOL] if [string] in request . GET : [EOL] response . unset_cookie ( [string] ) [EOL] return [string] [EOL] [EOL] set_cookie_vary = request . GET . first ( [string] , default = [string] ) [EOL] if set_cookie_vary : [EOL] response . set_cookie ( [string] , set_cookie_vary ) [EOL] return [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cookie_vary = request . cookies . get ( [string] ) [EOL] if cookie_vary : [EOL] response . headers . set ( [string] , text_type ( cookie_vary ) ) [EOL] else : [EOL] [comment] [EOL] query_vary = request . GET . first ( [string] , default = [string] ) [EOL] if query_vary : [EOL] response . headers . set ( [string] , query_vary ) [EOL] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return int ( request . GET [ [string] ] ) , [ ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] [docstring] [EOL] same_site = request . GET . first ( [string] ) [EOL] cookie_name = request . GET . first ( [string] ) [EOL] drop = request . GET . first ( [string] ) [EOL] cookie_in_request = [string] [EOL] cookie = [string] % ( cookie_name , same_site ) [EOL] [EOL] if drop == [string] : [EOL] cookie += [string] [EOL] [EOL] if request . cookies . get ( cookie_name ) : [EOL] cookie_in_request = request . cookies [ cookie_name ] . value [EOL] [EOL] headers = [ ( [string] , [string] ) , ( [string] , cookie ) ] [EOL] return ( [number] , headers , cookie_in_request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] import json [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] normalized = dict ( ) [EOL] [EOL] for key , values in dict ( request . headers ) . items ( ) : [EOL] values = [ isomorphic_decode ( value ) for value in values ] [EOL] normalized [ isomorphic_decode ( key . upper ( ) ) ] = values [EOL] [EOL] return json . dumps ( normalized ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ] [EOL] [EOL] if [string] in request . GET : [EOL] for item in request . GET [ [string] ] . split ( [string] ) : [EOL] headers . append ( ( [string] , item ) ) [EOL] [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] [EOL] script = [string] [EOL] [EOL] [EOL] def main ( request , response ) : [EOL] return [ ( [string] , [string] ) ] , script % time . time ( ) [EOL]	0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] if [string] in request . GET : [EOL] return ( [ ( [string] , [string] ) ] , [string] ) [EOL] [EOL] return ( [ ( [string] , [string] ) ] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] def main ( req , res ) : [EOL] return [number] , [ ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def classic_script ( ) : [EOL] return [string] [EOL] [EOL] def module_script ( ) : [EOL] return [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] classic_first = request . GET [ [string] ] [EOL] key = request . GET [ [string] ] [EOL] requested_once = request . server . stash . take ( key ) [EOL] if requested_once is None : [EOL] request . server . stash . put ( key , True ) [EOL] body = classic_script ( ) if classic_first == [string] else module_script ( ) [EOL] else : [EOL] body = module_script ( ) if classic_first == [string] else classic_script ( ) [EOL] [EOL] return [number] , headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] if [string] in request . GET : [EOL] return ( [ ( [string] , [string] ) ] , [string] ) [EOL] [EOL] return ( [ ( [string] , [string] ) ] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] from wptserve . utils import isomorphic_encode [EOL] [EOL] filename = os . path . basename ( isomorphic_encode ( __file__ ) ) [EOL] [EOL] def main ( request , response ) : [EOL] if request . method == [string] : [EOL] return [number] , [ ( [string] , [string] % filename ) ] , [string] [EOL] [EOL] return [ ( [string] , [string] ) ] , request . request_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] import random [EOL] [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [comment] [EOL] body = [string] . strip ( ) % ( random . random ( ) ) [EOL] return headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ] [EOL] [comment] [EOL] headers . append ( ( [string] , [string] ) ) [EOL] headers . append ( ( [string] , [string] ) ) [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] import json [EOL] import os [EOL] import uuid [EOL] import sys [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] path = os . path . join ( os . path . dirname ( isomorphic_decode ( __file__ ) ) , [string] ) [EOL] body = open ( path , [string] ) . read ( ) [EOL] [EOL] data = { isomorphic_decode ( key ) : isomorphic_decode ( request . headers [ key ] ) for key , value in request . headers . items ( ) } [EOL] body = body . replace ( [string] , json . dumps ( data ) . encode ( [string] ) ) [EOL] body = body . replace ( [string] , str ( uuid . uuid4 ( ) ) . encode ( [string] ) ) [EOL] [EOL] headers = [ ] [EOL] headers . append ( ( [string] , [string] ) ) [EOL] headers . append ( ( [string] , [string] ) ) [EOL] [EOL] return headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] if [string] in request . GET : [EOL] return ( [ ( [string] , [string] ) ] , [string] % request . GET [ [string] ] ) [EOL] return ( [ ( [string] , [string] ) ] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] import os [EOL] [EOL] [EOL] BOUNDARY = [string] [EOL] [EOL] [EOL] def create_part ( path ) : [EOL] with open ( path , [string] ) as f : [EOL] return [string] + f . read ( ) + [string] % BOUNDARY [EOL] [EOL] [EOL] def main ( request , response ) : [EOL] content_type = [string] % BOUNDARY [EOL] headers = [ ( [string] , content_type ) ] [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , [string] ) ) [EOL] [EOL] image_path = os . path . join ( request . doc_root , [string] ) [EOL] body = create_part ( os . path . join ( image_path , [string] ) ) [EOL] body = body + create_part ( os . path . join ( image_path , [string] ) ) [EOL] return headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( req , res ) : [EOL] return ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , [string] % ( req . GET [ [string] ] , req . GET [ [string] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( req , res ) : [EOL] return ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , [string] % req . GET [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] if [string] in request . GET : [EOL] status = int ( request . GET [ [string] ] ) [EOL] else : [EOL] status = [number] [EOL] [EOL] headers = [ ] [EOL] [EOL] url = request . GET [ [string] ] [EOL] headers . append ( ( [string] , url ) ) [EOL] [EOL] if [string] in request . GET : [EOL] for item in request . GET [ [string] ] . split ( [string] ) : [EOL] headers . append ( ( [string] , item ) ) [EOL] [EOL] for suffix in [ [string] , [string] , [string] ] : [EOL] query = [string] % suffix [EOL] header = [string] % suffix [EOL] if query in request . GET : [EOL] headers . append ( ( header , request . GET [ query ] ) ) [EOL] [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , request . GET [ [string] ] ) ) [EOL] [EOL] return status , headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [ ( [string] , [string] ) , ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] import time [EOL] [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] imported_content_type = [string] [EOL] if [string] in request . GET : [EOL] imported_content_type = request . GET [ [string] ] [EOL] [EOL] imported_content = [string] [EOL] if imported_content_type == [string] : [EOL] imported_content = [string] % time . time ( ) [EOL] [EOL] body = [string] % (imported_content) [EOL] [EOL] return headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] if [string] in request . GET : [EOL] return ( [ ( [string] , [string] ) ] , [string] ) [EOL] [EOL] return ( [ ( [string] , [string] ) ] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] if [string] in request . GET : [EOL] return [ ( [string] , request . GET [ [string] ] ) ] , [string] [EOL] return [ ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] key = request . GET [ [string] ] [EOL] already_requested = request . server . stash . take ( key ) [EOL] [EOL] if already_requested is None : [EOL] request . server . stash . put ( key , True ) [EOL] return [ ( [string] , [string] ) ] , [string] [EOL] [EOL] response . status = ( [number] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] bodyDefault = [string] [EOL] [EOL] bodyScript = [string] [EOL] [EOL] bodyConnect = [string] [EOL] [EOL] def main ( request , response ) : [EOL] headers = [ ] [EOL] headers . append ( ( [string] , [string] ) ) [EOL] directive = request . GET [ [string] ] [EOL] body = [string] [EOL] if directive == [string] : [EOL] headers . append ( ( [string] , [string] ) ) [EOL] body = bodyDefault [EOL] elif directive == [string] : [EOL] headers . append ( ( [string] , [string] ) ) [EOL] body = bodyScript [EOL] elif directive == [string] : [EOL] headers . append ( ( [string] , [string] ) ) [EOL] body = bodyConnect [EOL] return headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import json [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] data = { isomorphic_decode ( key ) : isomorphic_decode ( request . headers [ key ] ) for key , value in request . headers . items ( ) } [EOL] [EOL] return [ ( [string] , [string] ) ] , json . dumps ( data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] [EOL] body = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [ request . url_parts . query ] [EOL] return headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] import os . path [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] header = [ ( [string] , [string] ) ] [EOL] if [string] in request . GET : [EOL] with open ( os . path . join ( os . path . dirname ( isomorphic_decode ( __file__ ) ) , [string] ) , [string] ) as f : [EOL] body = f . read ( ) [EOL] return ( header , body ) [EOL] [EOL] if [string] in request . GET : [EOL] header . append ( ( [string] , [string] % request . GET [ [string] ] ) ) [EOL] with open ( os . path . join ( os . path . dirname ( isomorphic_decode ( __file__ ) ) , [string] ) , [string] ) as f : [EOL] body = f . read ( ) [EOL] return ( header , body ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] + request . GET . first ( [string] ) ) [EOL] response . content = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] from typing import List [EOL] import typing [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] ]	0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] __all__ = [ [string] ]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0
[comment] [EOL] [EOL] from distutils . core import setup [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , author = [string] , author_email = [string] , url = [string] , packages = [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] import apiclient [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] [comment] [EOL] pytest . register_assert_rewrite ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
pytest_plugins = [string] [EOL]	$builtins.str$ 0 0 0
	0
	0
	0
from typing import List , Any , Dict [EOL] import typing [EOL] from tests . support . asserts import assert_error , assert_same_element , assert_success [EOL] from tests . support . inline import inline [EOL] [EOL] [EOL] def execute_script ( session , script , args = None ) : [EOL] if args is None : [EOL] args = [ ] [EOL] body = { [string] : script , [string] : args } [EOL] [EOL] return session . transport . send ( [string] , [string] . format ( session_id = session . session_id ) , body ) [EOL] [EOL] [EOL] def test_array ( session ) : [EOL] response = execute_script ( session , [string] ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_object ( session ) : [EOL] response = execute_script ( session , [string] ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_array_in_object ( session ) : [EOL] response = execute_script ( session , [string] ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_object_in_array ( session ) : [EOL] response = execute_script ( session , [string] ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_element_in_collection ( session ) : [EOL] session . url = inline ( [string] ) [EOL] divs = session . find . css ( [string] ) [EOL] [EOL] response = execute_script ( session , [string] ) [EOL] value = assert_success ( response ) [EOL] for expected , actual in zip ( divs , value ) : [EOL] assert_same_element ( session , expected , actual ) [EOL] [EOL] [EOL] def test_element_in_object ( session ) : [EOL] session . url = inline ( [string] ) [EOL] div = session . find . css ( [string] , all = False ) [EOL] [EOL] response = execute_script ( session , [string] ) [EOL] value = assert_success ( response ) [EOL] assert_same_element ( session , div , value [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any , Dict [EOL] import typing [EOL] from tests . support . asserts import assert_same_element , assert_success [EOL] from tests . support . inline import inline [EOL] [EOL] [EOL] def execute_script ( session , script , args = None ) : [EOL] if args is None : [EOL] args = [ ] [EOL] body = { [string] : script , [string] : args } [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) , body ) [EOL] [EOL] [EOL] def test_content_attribute ( session ) : [EOL] session . url = inline ( [string] ) [EOL] response = execute_script ( session , [string] ) [EOL] assert_success ( response , [string] ) [EOL] [EOL] [EOL] def test_idl_attribute ( session ) : [EOL] session . url = inline ( [string] ) [EOL] response = execute_script ( session , [string] ) [EOL] assert_success ( response , [string] ) [EOL] [EOL] [EOL] def test_idl_attribute_element ( session ) : [EOL] session . url = inline ( [string] ) [EOL] _foo , bar = session . find . css ( [string] ) [EOL] response = execute_script ( session , [string] ) [EOL] value = assert_success ( response ) [EOL] assert_same_element ( session , bar , value ) [EOL] [EOL] [EOL] def test_script_defining_property ( session ) : [EOL] session . url = inline ( [string] ) [EOL] execute_script ( session , [string] ) [EOL] response = execute_script ( session , [string] ) [EOL] assert_success ( response , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def opener ( session ) : [EOL] return session . execute_script ( [string] ) [EOL] [EOL] [EOL] def window_name ( session ) : [EOL] return session . execute_script ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from webdriver . transport import Response [EOL] [EOL] from tests . support . asserts import assert_error , assert_success [EOL] [EOL] [EOL] def new_window ( session , type_hint = None ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) , { [string] : type_hint } ) [EOL] [EOL] [EOL] def test_null_parameter_value ( session , http ) : [EOL] path = [string] . format ( ** vars ( session ) ) [EOL] with http . post ( path , None ) as response : [EOL] assert_error ( Response . from_http ( response ) , [string] ) [EOL] [EOL] [EOL] def test_no_browsing_context ( session , closed_window ) : [EOL] response = new_window ( session ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , [number] , [number] , [ ] , { } ] ) def test_type_with_invalid_type ( session , type_hint ) : [EOL] response = new_window ( session , type_hint ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_type_with_null_value ( session ) : [EOL] original_handles = session . handles [EOL] [EOL] response = new_window ( session , type_hint = None ) [EOL] value = assert_success ( response ) [EOL] handles = session . handles [EOL] assert len ( handles ) == len ( original_handles ) + [number] [EOL] assert value [ [string] ] in handles [EOL] assert value [ [string] ] not in original_handles [EOL] assert value [ [string] ] in [ [string] , [string] ] [EOL] [EOL] [EOL] def test_type_with_unknown_value ( session ) : [EOL] original_handles = session . handles [EOL] [EOL] response = new_window ( session , type_hint = [string] ) [EOL] value = assert_success ( response ) [EOL] handles = session . handles [EOL] assert len ( handles ) == len ( original_handles ) + [number] [EOL] assert value [ [string] ] in handles [EOL] assert value [ [string] ] not in original_handles [EOL] assert value [ [string] ] in [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def test_navigator_webdriver_active ( session ) : [EOL] assert session . execute_script ( [string] ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from tests . support . asserts import assert_error , assert_success [EOL] [EOL] [EOL] def test_basic ( new_session , add_browser_capabilities ) : [EOL] response , _ = new_session ( { [string] : { [string] : add_browser_capabilities ( { } ) } } ) [EOL] value = assert_success ( response ) [EOL] assert set ( value . keys ( ) ) == { [string] , [string] } [EOL] [EOL] [EOL] def test_repeat_new_session ( new_session , add_browser_capabilities ) : [EOL] response , _ = new_session ( { [string] : { [string] : add_browser_capabilities ( { } ) } } ) [EOL] assert_success ( response ) [EOL] [EOL] response , _ = new_session ( { [string] : { [string] : add_browser_capabilities ( { } ) } } ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_no_capabilites ( new_session ) : [EOL] response , _ = new_session ( { } ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_missing_first_match ( new_session , add_browser_capabilities ) : [EOL] response , _ = new_session ( { [string] : { [string] : add_browser_capabilities ( { } ) } } ) [EOL] assert_success ( response ) [EOL] [EOL] [EOL] def test_missing_always_match ( new_session , add_browser_capabilities ) : [EOL] response , _ = new_session ( { [string] : { [string] : [ add_browser_capabilities ( { } ) ] } } ) [EOL] assert_success ( response ) [EOL] [EOL] [EOL] def test_desired ( new_session , add_browser_capabilities ) : [EOL] response , _ = new_session ( { [string] : add_browser_capabilities ( { } ) } ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_ignore_non_spec_fields_in_capabilities ( new_session , add_browser_capabilities ) : [EOL] response , _ = new_session ( { [string] : { [string] : add_browser_capabilities ( { } ) , [string] : { [string] : [string] } , } } ) [EOL] value = assert_success ( response ) [EOL] assert value [ [string] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import uuid [EOL] import pytest [EOL] [EOL] from six import string_types [EOL] [EOL] from tests . support . asserts import assert_success [EOL] [EOL] [EOL] def test_sessionid ( new_session , add_browser_capabilities ) : [EOL] response , _ = new_session ( { [string] : { [string] : add_browser_capabilities ( { } ) } } ) [EOL] value = assert_success ( response ) [EOL] assert isinstance ( value [ [string] ] , string_types ) [EOL] uuid . UUID ( hex = value [ [string] ] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , string_types ) , ( [string] , string_types ) , ( [string] , string_types ) , ( [string] , bool ) , ( [string] , string_types ) , ( [string] , dict ) , ( [string] , bool ) , ( [string] , dict ) , ( [string] , bool ) , ( [string] , string_types ) , ] ) def test_capability_type ( session , capability , type ) : [EOL] assert isinstance ( session . capabilities , dict ) [EOL] assert capability in session . capabilities [EOL] assert isinstance ( session . capabilities [ capability ] , type ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , False ) , ( [string] , [string] ) , ( [string] , { } ) , ( [string] , True ) , ( [string] , { [string] : [number] , [string] : [number] , [string] : [number] } ) , ( [string] , False ) , ( [string] , [string] ) , ] ) def test_capability_default_value ( session , capability , default_value ) : [EOL] assert isinstance ( session . capabilities , dict ) [EOL] assert capability in session . capabilities [EOL] assert session . capabilities [ capability ] == default_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] import builtins [EOL] from typing import Union , Dict , List , Tuple , Any , Optional [EOL] import typing [EOL] valid_data = [ ( [string] , [ False , None , ] ) , ( [string] , [ None , ] ) , ( [string] , [ None , ] ) , ( [string] , [ None , ] ) , ( [string] , [ None , [string] , [string] , [string] , ] ) , ( [string] , [ None , ] ) , ( [string] , [ None , { } , { [string] : [number] , [string] : [number] , [string] : [number] ** [number] - [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] } , ] ) , ( [string] , [ True , False , None , ] ) , ( [string] , [ [string] , [string] , None , ] ) , ( [string] , [ None , False , [string] , [number] , [ ] , { [string] : [string] } , ] ) , ] [EOL] [EOL] invalid_data = [ ( [string] , [ [number] , [ ] , { } , [string] , ] ) , ( [string] , [ [number] , [ ] , { } , False , ] ) , ( [string] , [ [number] , [ ] , { } , False , ] ) , ( [string] , [ [number] , [ ] , { } , False , ] ) , ( [string] , [ [number] , [ ] , { } , False , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , ( [string] , [ [number] , [ ] , [string] , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : None } , { [string] : [number] } , { [string] : [ ] } , { [string] : { [string] : [string] } } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , ] ) , ( [string] , [ [number] , [ ] , [string] , False , { [string] : [number] } , { [string] : [number] } , { [string] : [number] } , { [string] : [number] } , { [string] : [number] } , { [string] : None } , { [string] : False } , { [string] : [ ] } , { [string] : [string] } , { [string] : [number] } , { [string] : - [number] } , { [string] : [number] ** [number] } , { [string] : { [string] : [number] } } , { [string] : [number] , [string] : [number] } , ] ) , ( [string] , [ [number] , [ ] , { } , [string] , ] ) , ( [string] , [ [number] , [ ] , { } , False , [string] , [string] , [string] , [string] , [string] , ] ) ] [EOL] [EOL] invalid_extensions = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import urllib [EOL] import typing [EOL] from six . moves . urllib . parse import urlparse [EOL] [EOL] import webdriver . protocol as protocol [EOL] [EOL] from tests . support . asserts import assert_success [EOL] from tests . support . helpers import document_location [EOL] from tests . support . inline import iframe , inline [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def switch_to_frame ( session , frame ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) , { [string] : frame } , encoder = protocol . Encoder , decoder = protocol . Decoder , session = session ) [EOL] [EOL] [EOL] def test_cross_origin_iframe ( session , server_config ) : [EOL] session . url = inline ( iframe ( [string] , domain = [string] ) ) [EOL] frame_element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = switch_to_frame ( session , frame_element ) [EOL] assert_success ( response ) [EOL] [EOL] parse_result = urlparse ( document_location ( session ) ) [EOL] assert parse_result . netloc != server_config [ [string] ] [EOL] [EOL] [EOL] def test_nested_cross_origin_iframe ( session , server_config ) : [EOL] frame2 = iframe ( [string] , domain = [string] , subdomain = [string] ) [EOL] frame1 = iframe ( frame2 ) [EOL] top_doc = inline ( frame1 , domain = [string] ) [EOL] [EOL] session . url = top_doc [EOL] [EOL] parse_result = urlparse ( document_location ( session ) ) [EOL] top_level_host = parse_result . netloc [EOL] assert not top_level_host . startswith ( server_config [ [string] ] ) [EOL] [EOL] frame1_element = session . find . css ( [string] , all = False ) [EOL] response = switch_to_frame ( session , frame1_element ) [EOL] assert_success ( response ) [EOL] [EOL] parse_result = urlparse ( document_location ( session ) ) [EOL] assert parse_result . netloc . startswith ( server_config [ [string] ] ) [EOL] [EOL] frame2_el = session . find . css ( [string] , all = False ) [EOL] response = switch_to_frame ( session , frame2_el ) [EOL] assert_success ( response ) [EOL] [EOL] parse_result = urlparse ( document_location ( session ) ) [EOL] assert parse_result . netloc == [string] . format ( top_level_host ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] import time [EOL] [EOL] from webdriver import Element [EOL] [EOL] from tests . support . asserts import ( assert_element_has_focus , assert_error , assert_events_equal , assert_in_events , assert_success , ) [EOL] from tests . support . inline import inline [EOL] [EOL] [EOL] @ pytest . fixture def tracked_events ( ) : [EOL] return [ [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def element_clear ( session , element ) : [EOL] return session . transport . send ( [string] , [string] . format ( session_id = session . session_id , element_id = element . id ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def text_file ( tmpdir_factory ) : [EOL] fh = tmpdir_factory . mktemp ( [string] ) . join ( [string] ) [EOL] fh . write ( [string] ) [EOL] return fh [EOL] [EOL] [EOL] def test_null_response_value ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] value = assert_success ( response ) [EOL] assert value is None [EOL] [EOL] [EOL] def test_no_browsing_context ( session , closed_window ) : [EOL] element = Element ( [string] + str ( time . time ( ) ) , session ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_connected_element ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] session . url = inline ( [string] ) [EOL] response = element_clear ( session , element ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_pointer_interactable ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_keyboard_interactable ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] assert element . property ( [string] ) == [string] [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_success ( response ) [EOL] assert element . property ( [string] ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] ) def test_input ( session , add_event_listeners , tracked_events , type , value , default ) : [EOL] session . url = inline ( [string] % ( type , value ) ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] add_event_listeners ( element , tracked_events ) [EOL] assert element . property ( [string] ) == value [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_success ( response ) [EOL] assert element . property ( [string] ) == default [EOL] assert_in_events ( session , [ [string] , [string] , [string] ] ) [EOL] assert_element_has_focus ( session . execute_script ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) def test_input_disabled ( session , type ) : [EOL] session . url = inline ( [string] % type ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) def test_input_readonly ( session , type ) : [EOL] session . url = inline ( [string] % type ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_textarea ( session , add_event_listeners , tracked_events ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] add_event_listeners ( element , tracked_events ) [EOL] assert element . property ( [string] ) == [string] [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_success ( response ) [EOL] assert element . property ( [string] ) == [string] [EOL] assert_in_events ( session , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def test_textarea_disabled ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_textarea_readonly ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_input_file ( session , text_file ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] element . send_keys ( str ( text_file ) ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_success ( response ) [EOL] assert element . property ( [string] ) == [string] [EOL] [EOL] [EOL] def test_input_file_multiple ( session , text_file ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] element . send_keys ( str ( text_file ) ) [EOL] element . send_keys ( str ( text_file ) ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_success ( response ) [EOL] assert element . property ( [string] ) == [string] [EOL] [EOL] [EOL] def test_select ( session ) : [EOL] session . url = inline ( [string] ) [EOL] select = session . find . css ( [string] , all = False ) [EOL] option = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_clear ( session , select ) [EOL] assert_error ( response , [string] ) [EOL] response = element_clear ( session , option ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_button ( session ) : [EOL] session . url = inline ( [string] ) [EOL] button = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_clear ( session , button ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_button_with_subtree ( session ) : [EOL] [docstring] [EOL] session . url = inline ( [string] ) [EOL] text_field = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_clear ( session , text_field ) [EOL] assert_success ( response ) [EOL] [EOL] [EOL] def test_contenteditable ( session , add_event_listeners , tracked_events ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] add_event_listeners ( element , tracked_events ) [EOL] assert element . property ( [string] ) == [string] [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_success ( response ) [EOL] assert element . property ( [string] ) == [string] [EOL] assert_events_equal ( session , [ [string] , [string] ] ) [EOL] assert_element_has_focus ( session . execute_script ( [string] ) ) [EOL] [EOL] [EOL] def test_designmode ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] assert element . property ( [string] ) == [string] [EOL] session . execute_script ( [string] ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_success ( response ) [EOL] assert element . property ( [string] ) in [ [string] , [string] ] [EOL] assert_element_has_focus ( session . execute_script ( [string] ) ) [EOL] [EOL] [EOL] def test_resettable_element_focus_when_empty ( session , add_event_listeners , tracked_events ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] add_event_listeners ( element , tracked_events ) [EOL] assert element . property ( [string] ) == [string] [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_success ( response ) [EOL] assert element . property ( [string] ) == [string] [EOL] assert_events_equal ( session , [ ] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) def test_resettable_element_does_not_satisfy_validation_constraints ( session , type , invalid_value ) : [EOL] [docstring] [EOL] session . url = inline ( [string] % type ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] def is_valid ( element ) : [EOL] return session . execute_script ( [string] , args = ( element , ) ) [EOL] [EOL] [comment] [EOL] element . send_keys ( invalid_value ) [EOL] [EOL] [comment] [EOL] if is_valid ( element ) : [EOL] return [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_success ( response ) [EOL] assert is_valid ( element ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] ] ) def test_non_editable_inputs ( session , type ) : [EOL] session . url = inline ( [string] % type ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_clear ( session , element ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_scroll_into_view ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] assert element . property ( [string] ) == [string] [EOL] assert session . execute_script ( [string] ) == [number] [EOL] [EOL] [comment] [EOL] session . execute_script ( [string] ) [EOL] [EOL] [comment] [EOL] response = element_clear ( session , element ) [EOL] assert_success ( response ) [EOL] assert element . property ( [string] ) == [string] [EOL] [EOL] [comment] [EOL] rect = session . execute_script ( [string] , args = ( element , ) ) [EOL] window = session . execute_script ( [string] ) [EOL] [EOL] assert rect [ [string] ] < ( window [ [string] ] + window [ [string] ] ) and rect [ [string] ] < ( window [ [string] ] + window [ [string] ] ) and ( rect [ [string] ] + element . rect [ [string] ] ) > window [ [string] ] and ( rect [ [string] ] + element . rect [ [string] ] ) > window [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
def element_dimensions ( session , element ) : [EOL] return tuple ( session . execute_script ( [string] , args = ( element , ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . support . asserts import assert_error , assert_success [EOL] from tests . support . helpers import center_point [EOL] from tests . support . inline import inline [EOL] [EOL] [EOL] def element_click ( session , element ) : [EOL] return session . transport . send ( [string] , [string] . format ( session_id = session . session_id , element_id = element . id ) ) [EOL] [EOL] [EOL] def square ( size ) : [EOL] return inline ( [string] . format ( size = size ) ) [EOL] [EOL] [EOL] def assert_one_click ( session ) : [EOL] [docstring] [EOL] clicks = session . execute_script ( [string] ) [EOL] assert len ( clicks ) == [number] [EOL] return tuple ( clicks [ [number] ] ) [EOL] [EOL] [EOL] def test_entirely_in_view ( session ) : [EOL] session . url = square ( [number] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_click ( session , element ) [EOL] assert_success ( response ) [EOL] [EOL] click_point = assert_one_click ( session ) [EOL] assert click_point == ( [number] , [number] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , range ( [number] , [number] ) ) def test_css_pixel_rounding ( session , size ) : [EOL] session . url = square ( size ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] expected_click_point = center_point ( element ) [EOL] [EOL] response = element_click ( session , element ) [EOL] assert_success ( response ) [EOL] [EOL] actual_click_point = assert_one_click ( session ) [EOL] assert actual_click_point == expected_click_point [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . support . asserts import assert_error , assert_success [EOL] from tests . support . helpers import center_point [EOL] from tests . support . inline import inline [EOL] [EOL] def element_click ( session , element ) : [EOL] return session . transport . send ( [string] , [string] . format ( session_id = session . session_id , element_id = element . id ) ) [EOL] [EOL] [EOL] def assert_one_click ( session ) : [EOL] [docstring] [EOL] clicks = session . execute_script ( [string] ) [EOL] assert len ( clicks ) == [number] [EOL] return tuple ( clicks [ [number] ] ) [EOL] [EOL] [EOL] def test_scroll_into_view ( session ) : [EOL] session . url = inline ( [string] ) [EOL] [EOL] element = session . find . css ( [string] , all = False ) [EOL] response = element_click ( session , element ) [EOL] assert_success ( response ) [EOL] [EOL] [comment] [EOL] assert session . execute_script ( [string] , args = ( element , ) ) is True [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , range ( [number] , [number] , - [number] ) ) def test_partially_visible_does_not_scroll ( session , offset ) : [EOL] session . url = inline ( [string] . format ( offset = offset ) ) [EOL] target = session . find . css ( [string] , all = False ) [EOL] assert session . execute_script ( [string] ) == [number] [EOL] response = element_click ( session , target ) [EOL] assert_success ( response ) [EOL] assert session . execute_script ( [string] ) == [number] [EOL] click_point = assert_one_click ( session ) [EOL] assert click_point == center_point ( target ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from tests . support . inline import inline [EOL] [EOL] [EOL] def test_click_option ( session ) : [EOL] session . url = inline ( [string] ) [EOL] options = session . find . css ( [string] ) [EOL] [EOL] assert options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] [EOL] def test_click_multiple_option ( session ) : [EOL] session . url = inline ( [string] ) [EOL] options = session . find . css ( [string] ) [EOL] [EOL] assert not options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] [EOL] def test_click_preselected_option ( session ) : [EOL] session . url = inline ( [string] ) [EOL] options = session . find . css ( [string] ) [EOL] [EOL] assert not options [ [number] ] . selected [EOL] assert options [ [number] ] . selected [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] [EOL] def test_click_preselected_multiple_option ( session ) : [EOL] session . url = inline ( [string] ) [EOL] options = session . find . css ( [string] ) [EOL] [EOL] assert not options [ [number] ] . selected [EOL] assert options [ [number] ] . selected [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert not options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] [EOL] def test_click_deselects_others ( session ) : [EOL] session . url = inline ( [string] ) [EOL] options = session . find . css ( [string] ) [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] [EOL] [EOL] def test_click_multiple_does_not_deselect_others ( session ) : [EOL] session . url = inline ( [string] ) [EOL] options = session . find . css ( [string] ) [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] assert options [ [number] ] . selected [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] assert options [ [number] ] . selected [EOL] assert options [ [number] ] . selected [EOL] [EOL] [EOL] def test_click_selected_option ( session ) : [EOL] session . url = inline ( [string] ) [EOL] options = session . find . css ( [string] ) [EOL] [EOL] [comment] [EOL] assert options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] [EOL] [EOL] def test_click_selected_multiple_option ( session ) : [EOL] session . url = inline ( [string] ) [EOL] options = session . find . css ( [string] ) [EOL] [EOL] [comment] [EOL] assert not options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] [comment] [EOL] options [ [number] ] . click ( ) [EOL] assert not options [ [number] ] . selected [EOL] assert not options [ [number] ] . selected [EOL] [EOL] [EOL] def test_out_of_view_dropdown ( session ) : [EOL] session . url = inline ( [string] ) [EOL] options = session . find . css ( [string] ) [EOL] [EOL] options [ [number] ] . click ( ) [EOL] assert options [ [number] ] . selected [EOL] [EOL] [EOL] def test_out_of_view_multiple ( session ) : [EOL] session . url = inline ( [string] ) [EOL] options = session . find . css ( [string] ) [EOL] [EOL] last_option = options [ - [number] ] [EOL] last_option . click ( ) [EOL] assert last_option . selected [EOL] [EOL] [EOL] def test_option_disabled ( session ) : [EOL] session . url = inline ( [string] ) [EOL] option = session . find . css ( [string] , all = False ) [EOL] assert not option . selected [EOL] [EOL] option . click ( ) [EOL] assert not option . selected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import typing [EOL] from tests . support . asserts import assert_success [EOL] from tests . support . inline import inline [EOL] [EOL] [EOL] def element_click ( session , element ) : [EOL] return session . transport . send ( [string] , [string] . format ( session_id = session . session_id , element_id = element . id ) ) [EOL] [EOL] [EOL] def test_numbers_link ( session , server_config ) : [EOL] link = [string] [EOL] session . url = inline ( [string] . format ( url = link ) ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] response = element_click ( session , element ) [EOL] assert_success ( response ) [EOL] host = server_config [ [string] ] [EOL] port = server_config [ [string] ] [ [string] ] [ [number] ] [EOL] [EOL] assert session . url == [string] . format ( host = host , port = port , url = link ) [EOL] [EOL] [EOL] def test_multi_line_link ( session , server_config ) : [EOL] link = [string] [EOL] session . url = inline ( [string] . format ( url = link ) ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] response = element_click ( session , element ) [EOL] assert_success ( response ) [EOL] host = server_config [ [string] ] [EOL] port = server_config [ [string] ] [ [string] ] [ [number] ] [EOL] [EOL] assert session . url == [string] . format ( host = host , port = port , url = link ) [EOL] [EOL] [EOL] def test_link_unload_event ( session , server_config ) : [EOL] link = [string] [EOL] session . url = inline ( [string] . format ( url = link ) ) [EOL] [EOL] element = session . find . css ( [string] , all = False ) [EOL] response = element_click ( session , element ) [EOL] assert_success ( response ) [EOL] [EOL] host = server_config [ [string] ] [EOL] port = server_config [ [string] ] [ [string] ] [ [number] ] [EOL] assert session . url == [string] . format ( host = host , port = port , url = link ) [EOL] [EOL] session . back ( ) [EOL] [EOL] element = session . find . css ( [string] , all = False ) [EOL] response = session . execute_script ( [string] , args = ( element , ) ) [EOL] assert response is True [EOL] [EOL] [EOL] def test_link_hash ( session ) : [EOL] id = [string] [EOL] session . url = inline ( [string] . format ( url = id , id = id ) ) [EOL] old_url = session . url [EOL] [EOL] element = session . find . css ( [string] , all = False ) [EOL] response = element_click ( session , element ) [EOL] assert_success ( response ) [EOL] [EOL] new_url = session . url [EOL] assert [string] . format ( url = old_url , id = id ) == new_url [EOL] [EOL] element = session . find . css ( [string] , all = False ) [EOL] assert session . execute_script ( [string] , args = ( element , ) ) is True [EOL] [EOL] [EOL] def test_link_closes_window ( session , url ) : [EOL] new_handle = session . new_window ( ) [EOL] session . window_handle = new_handle [EOL] [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_click ( session , element ) [EOL] assert_success ( response ) [EOL] [EOL] assert new_handle not in session . handles [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import pytest [EOL] [EOL] from webdriver . transport import Response [EOL] [EOL] from tests . support . asserts import assert_error , assert_success [EOL] [EOL] [EOL] def set_timeouts ( session , timeouts ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) , timeouts ) [EOL] [EOL] [EOL] def test_null_parameter_value ( session , http ) : [EOL] path = [string] . format ( ** vars ( session ) ) [EOL] with http . post ( path , None ) as response : [EOL] assert_error ( Response . from_http ( response ) , [string] ) [EOL] [EOL] [EOL] def test_null_response_value ( session ) : [EOL] timeouts = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] response = set_timeouts ( session , timeouts ) [EOL] value = assert_success ( response ) [EOL] assert value is None [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [string] , False , [ ] ] ) def test_parameters_invalid ( session , value ) : [EOL] response = set_timeouts ( session , value ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ { } , { [string] : [number] } ] ) def test_parameters_unknown_fields ( session , value ) : [EOL] original = session . timeouts . _get ( ) [EOL] [EOL] response = set_timeouts ( session , value ) [EOL] assert_success ( response ) [EOL] [EOL] assert session . timeouts . _get ( ) == original [EOL] [EOL] [EOL] def test_script_parameter_empty_no_change ( session ) : [EOL] original = session . timeouts . _get ( ) [EOL] [EOL] response = set_timeouts ( session , { [string] : [number] } ) [EOL] assert_success ( response ) [EOL] [EOL] assert session . timeouts . _get ( ) [ [string] ] == original [ [string] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] ] ) @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ** [number] - [number] ] ) def test_positive_integer ( session , typ , value ) : [EOL] response = set_timeouts ( session , { typ : value } ) [EOL] assert_success ( response ) [EOL] [EOL] assert session . timeouts . _get ( typ ) == value [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) @ pytest . mark . parametrize ( [string] , [ None , [ ] , { } , False , [string] ] ) def test_value_invalid_types ( session , typ , value ) : [EOL] response = set_timeouts ( session , { typ : value } ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ ] , { } , False , [string] ] ) def test_value_invalid_types_for_script ( session , value ) : [EOL] response = set_timeouts ( session , { [string] : value } ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] ] ) @ pytest . mark . parametrize ( [string] , [ - [number] , [number] , [number] ** [number] ] ) def test_value_positive_integer ( session , typ , value ) : [EOL] response = set_timeouts ( session , { typ : value } ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_set_all_fields ( session ) : [EOL] timeouts = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] response = set_timeouts ( session , timeouts ) [EOL] assert_success ( response ) [EOL] [EOL] assert session . timeouts . implicit == [number] [EOL] assert session . timeouts . page_load == [number] [EOL] assert session . timeouts . script == [number] [EOL] [EOL] [EOL] def test_script_value_null ( session ) : [EOL] response = set_timeouts ( session , { [string] : None } ) [EOL] assert_success ( response ) [EOL] [EOL] assert session . timeouts . script is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from webdriver import error [EOL] [EOL] from tests . support . asserts import assert_success [EOL] [EOL] [EOL] def switch_to_window ( session , handle ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) , { [string] : handle } ) [EOL] [EOL] [EOL] def test_retain_tab_modal_status ( session ) : [EOL] handle = session . window_handle [EOL] [EOL] new_handle = session . new_window ( ) [EOL] response = switch_to_window ( session , new_handle ) [EOL] assert_success ( response ) [EOL] [EOL] session . execute_script ( [string] ) [EOL] assert session . alert . text == [string] [EOL] [EOL] response = switch_to_window ( session , handle ) [EOL] assert_success ( response ) [EOL] [EOL] with pytest . raises ( error . NoSuchAlertException ) : [EOL] session . alert . text == [string] [EOL] [EOL] response = switch_to_window ( session , new_handle ) [EOL] assert_success ( response ) [EOL] [EOL] assert session . alert . text == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[EOL]	0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] from tests . support . asserts import assert_success [EOL] from tests . support . helpers import is_element_in_viewport [EOL] from tests . support . inline import inline [EOL] [EOL] def element_send_keys ( session , element , text ) : [EOL] return session . transport . send ( [string] , [string] . format ( session_id = session . session_id , element_id = element . id ) , { [string] : text } ) [EOL] [EOL] [EOL] def test_element_outside_of_not_scrollable_viewport ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , [string] ) [EOL] assert_success ( response ) [EOL] [EOL] assert not is_element_in_viewport ( session , element ) [EOL] [EOL] [EOL] def test_element_outside_of_scrollable_viewport ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , [string] ) [EOL] assert_success ( response ) [EOL] [EOL] assert is_element_in_viewport ( session , element ) [EOL] [EOL] [EOL] def test_option_select_container_outside_of_scrollable_viewport ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] select = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , [string] ) [EOL] assert_success ( response ) [EOL] [EOL] assert is_element_in_viewport ( session , select ) [EOL] assert is_element_in_viewport ( session , element ) [EOL] [EOL] [EOL] def test_option_stays_outside_of_scrollable_viewport ( session ) : [EOL] session . url = inline ( [string] ) [EOL] select = session . find . css ( [string] , all = False ) [EOL] option_foo = session . find . css ( [string] , all = False ) [EOL] option_bar = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , option_bar , [string] ) [EOL] assert_success ( response ) [EOL] [EOL] assert is_element_in_viewport ( session , select ) [EOL] assert is_element_in_viewport ( session , option_foo ) [EOL] assert not is_element_in_viewport ( session , option_bar ) [EOL] [EOL] [EOL] def test_contenteditable_element_outside_of_scrollable_viewport ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , [string] ) [EOL] assert_success ( response ) [EOL] [EOL] assert is_element_in_viewport ( session , element ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . support . asserts import assert_error , assert_files_uploaded , assert_success [EOL] from tests . support . inline import inline [EOL] [EOL] from . import map_files_to_multiline_text [EOL] [EOL] [EOL] def element_send_keys ( session , element , text ) : [EOL] return session . transport . send ( [string] , [string] . format ( session_id = session . session_id , element_id = element . id ) , { [string] : text } ) [EOL] [EOL] [EOL] def test_empty_text ( session ) : [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , [string] ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_multiple_files ( session , create_files ) : [EOL] files = create_files ( [ [string] , [string] ] ) [EOL] [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , map_files_to_multiline_text ( files ) ) [EOL] assert_success ( response ) [EOL] [EOL] assert_files_uploaded ( session , element , files ) [EOL] [EOL] [EOL] def test_multiple_files_last_path_not_found ( session , create_files ) : [EOL] files = create_files ( [ [string] , [string] ] ) [EOL] files . append ( [string] ) [EOL] [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , map_files_to_multiline_text ( files ) ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] assert_files_uploaded ( session , element , [ ] ) [EOL] [EOL] [EOL] def test_multiple_files_without_multiple_attribute ( session , create_files ) : [EOL] files = create_files ( [ [string] , [string] ] ) [EOL] [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , map_files_to_multiline_text ( files ) ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] assert_files_uploaded ( session , element , [ ] ) [EOL] [EOL] [EOL] def test_multiple_files_send_twice ( session , create_files ) : [EOL] first_files = create_files ( [ [string] , [string] ] ) [EOL] second_files = create_files ( [ [string] , [string] ] ) [EOL] [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , map_files_to_multiline_text ( first_files ) ) [EOL] assert_success ( response ) [EOL] [EOL] response = element_send_keys ( session , element , map_files_to_multiline_text ( second_files ) ) [EOL] assert_success ( response ) [EOL] [EOL] assert_files_uploaded ( session , element , first_files + second_files ) [EOL] [EOL] [EOL] def test_multiple_files_reset_with_element_clear ( session , create_files ) : [EOL] first_files = create_files ( [ [string] , [string] ] ) [EOL] second_files = create_files ( [ [string] , [string] ] ) [EOL] [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , map_files_to_multiline_text ( first_files ) ) [EOL] assert_success ( response ) [EOL] [EOL] [comment] [EOL] element . clear ( ) [EOL] assert_files_uploaded ( session , element , [ ] ) [EOL] [EOL] response = element_send_keys ( session , element , map_files_to_multiline_text ( second_files ) ) [EOL] assert_success ( response ) [EOL] [EOL] assert_files_uploaded ( session , element , second_files ) [EOL] [EOL] [EOL] def test_single_file ( session , create_files ) : [EOL] files = create_files ( [ [string] ] ) [EOL] [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_success ( response ) [EOL] [EOL] assert_files_uploaded ( session , element , files ) [EOL] [EOL] [EOL] def test_single_file_replaces_without_multiple_attribute ( session , create_files ) : [EOL] files = create_files ( [ [string] , [string] ] ) [EOL] [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_success ( response ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_success ( response ) [EOL] [EOL] assert_files_uploaded ( session , element , [ files [ [number] ] ] ) [EOL] [EOL] [EOL] def test_single_file_appends_with_multiple_attribute ( session , create_files ) : [EOL] files = create_files ( [ [string] , [string] ] ) [EOL] [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_success ( response ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_success ( response ) [EOL] [EOL] assert_files_uploaded ( session , element , files ) [EOL] [EOL] [EOL] def test_transparent ( session , create_files ) : [EOL] files = create_files ( [ [string] ] ) [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_success ( response ) [EOL] assert_files_uploaded ( session , element , files ) [EOL] [EOL] [EOL] def test_obscured ( session , create_files ) : [EOL] files = create_files ( [ [string] ] ) [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_success ( response ) [EOL] assert_files_uploaded ( session , element , files ) [EOL] [EOL] [EOL] def test_outside_viewport ( session , create_files ) : [EOL] files = create_files ( [ [string] ] ) [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_success ( response ) [EOL] assert_files_uploaded ( session , element , files ) [EOL] [EOL] [EOL] def test_hidden ( session , create_files ) : [EOL] files = create_files ( [ [string] ] ) [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_success ( response ) [EOL] assert_files_uploaded ( session , element , files ) [EOL] [EOL] [EOL] def test_display_none ( session , create_files ) : [EOL] files = create_files ( [ [string] ] ) [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_success ( response ) [EOL] assert_files_uploaded ( session , element , files ) [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : True } ) def test_strict_hidden ( session , create_files ) : [EOL] files = create_files ( [ [string] ] ) [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : True } ) def test_strict_display_none ( session , create_files ) : [EOL] files = create_files ( [ [string] ] ) [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , str ( files [ [number] ] ) ) [EOL] assert_error ( response , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def map_files_to_multiline_text ( files ) : [EOL] return [string] . join ( map ( lambda f : str ( f ) , files ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . support . asserts import ( assert_element_has_focus , assert_events_equal , assert_success , ) [EOL] from tests . support . inline import inline [EOL] [EOL] from . import map_files_to_multiline_text [EOL] [EOL] [EOL] @ pytest . fixture def tracked_events ( ) : [EOL] return [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def element_send_keys ( session , element , text ) : [EOL] return session . transport . send ( [string] , [string] . format ( session_id = session . session_id , element_id = element . id ) , { [string] : text } ) [EOL] [EOL] [EOL] def test_file_upload ( session , create_files , add_event_listeners , tracked_events ) : [EOL] expected_events = [ [string] , [string] , ] [EOL] [EOL] files = create_files ( [ [string] , [string] ] ) [EOL] [EOL] session . url = inline ( [string] ) [EOL] element = session . find . css ( [string] , all = False ) [EOL] add_event_listeners ( element , tracked_events ) [EOL] [EOL] response = element_send_keys ( session , element , map_files_to_multiline_text ( files ) ) [EOL] assert_success ( response ) [EOL] [EOL] assert_events_equal ( session , expected_events ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_form_control_send_text ( session , add_event_listeners , tracked_events , tag ) : [EOL] expected_events = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] session . url = inline ( [string] % tag ) [EOL] element = session . find . css ( tag , all = False ) [EOL] add_event_listeners ( element , tracked_events ) [EOL] [EOL] response = element_send_keys ( session , element , [string] ) [EOL] assert_success ( response ) [EOL] assert_events_equal ( session , expected_events ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_not_blurred ( session , tag ) : [EOL] session . url = inline ( [string] % tag ) [EOL] element = session . find . css ( tag , all = False ) [EOL] [EOL] response = element_send_keys ( session , element , [string] ) [EOL] assert_success ( response ) [EOL] assert_element_has_focus ( element ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from six import text_type [EOL] [EOL] from tests . support . asserts import assert_error , assert_success [EOL] from tests . support . inline import inline [EOL] [EOL] [EOL] def get_title ( session ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) ) [EOL] [EOL] [EOL] def test_payload ( session ) : [EOL] session . start ( ) [EOL] [EOL] response = get_title ( session ) [EOL] value = assert_success ( response ) [EOL] assert isinstance ( value , text_type ) [EOL] [EOL] [EOL] def test_no_browsing_context ( session , closed_window ) : [EOL] response = get_title ( session ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_with_duplicated_title ( session ) : [EOL] session . url = inline ( [string] ) [EOL] [EOL] result = get_title ( session ) [EOL] assert_success ( result , [string] ) [EOL] [EOL] [EOL] def test_without_title ( session ) : [EOL] session . url = inline ( [string] ) [EOL] [EOL] result = get_title ( session ) [EOL] assert_success ( result , [string] ) [EOL] [EOL] [EOL] def test_after_modification ( session ) : [EOL] session . url = inline ( [string] ) [EOL] session . execute_script ( [string] ) [EOL] [EOL] result = get_title ( session ) [EOL] assert_success ( result , [string] ) [EOL] [EOL] [EOL] def test_strip_and_collapse ( session ) : [EOL] document = [string] [EOL] session . url = inline ( document ) [EOL] [EOL] result = get_title ( session ) [EOL] assert_success ( result , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import typing [EOL] import pytest [EOL] [EOL] from webdriver import MoveTargetOutOfBoundsException [EOL] [EOL] from tests . perform_actions . support . mouse import get_inview_center , get_viewport_rect [EOL] from tests . support . inline import inline [EOL] [EOL] [EOL] def origin_doc ( inner_style , outer_style = [string] ) : [EOL] return inline ( [string] . format ( inner_style , outer_style ) ) [EOL] [EOL] [EOL] def get_click_coordinates ( session ) : [EOL] return session . execute_script ( [string] ) [EOL] [EOL] [EOL] def test_viewport_inside ( session , mouse_chain ) : [EOL] point = { [string] : [number] , [string] : [number] } [EOL] [EOL] session . url = origin_doc ( [string] ) [EOL] mouse_chain . pointer_move ( point [ [string] ] , point [ [string] ] , origin = [string] ) . perform ( ) [EOL] [EOL] click_coords = session . execute_script ( [string] ) [EOL] assert click_coords [ [string] ] == pytest . approx ( point [ [string] ] , abs = [number] ) [EOL] assert click_coords [ [string] ] == pytest . approx ( point [ [string] ] , abs = [number] ) [EOL] [EOL] [EOL] def test_viewport_outside ( session , mouse_chain ) : [EOL] with pytest . raises ( MoveTargetOutOfBoundsException ) : [EOL] mouse_chain . pointer_move ( - [number] , - [number] , origin = [string] ) . perform ( ) [EOL] [EOL] [EOL] def test_pointer_inside ( session , mouse_chain ) : [EOL] start_point = { [string] : [number] , [string] : [number] } [EOL] offset = { [string] : [number] , [string] : [number] } [EOL] [EOL] session . url = origin_doc ( [string] ) [EOL] mouse_chain . pointer_move ( start_point [ [string] ] , start_point [ [string] ] ) . pointer_move ( offset [ [string] ] , offset [ [string] ] , origin = [string] ) . perform ( ) [EOL] [EOL] click_coords = session . execute_script ( [string] ) [EOL] assert click_coords [ [string] ] == pytest . approx ( start_point [ [string] ] + offset [ [string] ] , abs = [number] ) [EOL] assert click_coords [ [string] ] == pytest . approx ( start_point [ [string] ] + offset [ [string] ] , abs = [number] ) [EOL] [EOL] [EOL] def test_pointer_outside ( session , mouse_chain ) : [EOL] with pytest . raises ( MoveTargetOutOfBoundsException ) : [EOL] mouse_chain . pointer_move ( - [number] , - [number] , origin = [string] ) . perform ( ) [EOL] [EOL] [EOL] def test_element_center_point ( session , mouse_chain ) : [EOL] session . url = origin_doc ( [string] ) [EOL] elem = session . find . css ( [string] , all = False ) [EOL] center = get_inview_center ( elem . rect , get_viewport_rect ( session ) ) [EOL] [EOL] mouse_chain . pointer_move ( [number] , [number] , origin = elem ) . perform ( ) [EOL] [EOL] click_coords = get_click_coordinates ( session ) [EOL] assert click_coords [ [string] ] == pytest . approx ( center [ [string] ] , abs = [number] ) [EOL] assert click_coords [ [string] ] == pytest . approx ( center [ [string] ] , abs = [number] ) [EOL] [EOL] [EOL] def test_element_center_point_with_offset ( session , mouse_chain ) : [EOL] session . url = origin_doc ( [string] ) [EOL] elem = session . find . css ( [string] , all = False ) [EOL] center = get_inview_center ( elem . rect , get_viewport_rect ( session ) ) [EOL] [EOL] mouse_chain . pointer_move ( [number] , [number] , origin = elem ) . perform ( ) [EOL] [EOL] click_coords = get_click_coordinates ( session ) [EOL] assert click_coords [ [string] ] == pytest . approx ( center [ [string] ] + [number] , abs = [number] ) [EOL] assert click_coords [ [string] ] == pytest . approx ( center [ [string] ] + [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_element_in_view_center_point_partly_visible ( session , mouse_chain ) : [EOL] session . url = origin_doc ( [string] ) [EOL] elem = session . find . css ( [string] , all = False ) [EOL] center = get_inview_center ( elem . rect , get_viewport_rect ( session ) ) [EOL] [EOL] mouse_chain . pointer_move ( [number] , [number] , origin = elem ) . perform ( ) [EOL] [EOL] click_coords = get_click_coordinates ( session ) [EOL] assert click_coords [ [string] ] == pytest . approx ( center [ [string] ] , abs = [number] ) [EOL] assert click_coords [ [string] ] == pytest . approx ( center [ [string] ] , abs = [number] ) [EOL] [EOL] [EOL] def test_element_larger_than_viewport ( session , mouse_chain ) : [EOL] session . url = origin_doc ( [string] ) [EOL] elem = session . find . css ( [string] , all = False ) [EOL] center = get_inview_center ( elem . rect , get_viewport_rect ( session ) ) [EOL] [EOL] mouse_chain . pointer_move ( [number] , [number] , origin = elem ) . perform ( ) [EOL] [EOL] click_coords = get_click_coordinates ( session ) [EOL] assert click_coords [ [string] ] == pytest . approx ( center [ [string] ] , abs = [number] ) [EOL] assert click_coords [ [string] ] == pytest . approx ( center [ [string] ] , abs = [number] ) [EOL] [EOL] [EOL] def test_element_outside_of_view_port ( session , mouse_chain ) : [EOL] session . url = origin_doc ( [string] ) [EOL] elem = session . find . css ( [string] , all = False ) [EOL] [EOL] with pytest . raises ( MoveTargetOutOfBoundsException ) : [EOL] mouse_chain . pointer_move ( [number] , [number] , origin = elem ) . perform ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Union , List , Any , Dict [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . perform_actions . support . refine import get_keys [EOL] from tests . support . asserts import assert_error , assert_success , assert_dialog_handled [EOL] [EOL] [EOL] actions = [ { [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] } ] [EOL] [EOL] [EOL] def perform_actions ( session , actions ) : [EOL] return session . transport . send ( [string] , [string] . format ( session_id = session . session_id ) , { [string] : actions } ) [EOL] [EOL] [EOL] @ pytest . fixture def check_user_prompt_closed_without_exception ( session , create_dialog , key_chain , key_reporter ) : [EOL] def check_user_prompt_closed_without_exception ( dialog_type , retval ) : [EOL] create_dialog ( dialog_type , text = dialog_type ) [EOL] [EOL] response = perform_actions ( session , actions ) [EOL] assert_success ( response ) [EOL] [EOL] assert_dialog_handled ( session , expected_text = dialog_type , expected_retval = retval ) [EOL] [EOL] assert get_keys ( key_reporter ) == [string] [EOL] [EOL] return check_user_prompt_closed_without_exception [EOL] [EOL] [EOL] @ pytest . fixture def check_user_prompt_closed_with_exception ( session , create_dialog , key_chain , key_reporter ) : [EOL] def check_user_prompt_closed_with_exception ( dialog_type , retval ) : [EOL] create_dialog ( dialog_type , text = dialog_type ) [EOL] [EOL] response = perform_actions ( session , actions ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] assert_dialog_handled ( session , expected_text = dialog_type , expected_retval = retval ) [EOL] [EOL] assert get_keys ( key_reporter ) == [string] [EOL] [EOL] return check_user_prompt_closed_with_exception [EOL] [EOL] [EOL] @ pytest . fixture def check_user_prompt_not_closed_but_exception ( session , create_dialog , key_reporter ) : [EOL] def check_user_prompt_not_closed_but_exception ( dialog_type ) : [EOL] create_dialog ( dialog_type , text = dialog_type ) [EOL] [EOL] response = perform_actions ( session , actions ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] assert session . alert . text == dialog_type [EOL] session . alert . dismiss ( ) [EOL] [EOL] assert get_keys ( key_reporter ) == [string] [EOL] [EOL] return check_user_prompt_not_closed_but_exception [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : [string] } ) @ pytest . mark . parametrize ( [string] , [ ( [string] , None ) , ( [string] , True ) , ( [string] , [string] ) , ] ) def test_accept ( check_user_prompt_closed_without_exception , dialog_type , retval ) : [EOL] check_user_prompt_closed_without_exception ( dialog_type , retval ) [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : [string] } ) @ pytest . mark . parametrize ( [string] , [ ( [string] , None ) , ( [string] , True ) , ( [string] , [string] ) , ] ) def test_accept_and_notify ( check_user_prompt_closed_with_exception , dialog_type , retval ) : [EOL] check_user_prompt_closed_with_exception ( dialog_type , retval ) [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : [string] } ) @ pytest . mark . parametrize ( [string] , [ ( [string] , None ) , ( [string] , False ) , ( [string] , None ) , ] ) def test_dismiss ( check_user_prompt_closed_without_exception , dialog_type , retval ) : [EOL] check_user_prompt_closed_without_exception ( dialog_type , retval ) [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : [string] } ) @ pytest . mark . parametrize ( [string] , [ ( [string] , None ) , ( [string] , False ) , ( [string] , None ) , ] ) def test_dismiss_and_notify ( check_user_prompt_closed_with_exception , dialog_type , retval ) : [EOL] check_user_prompt_closed_with_exception ( dialog_type , retval ) [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : [string] } ) @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] ] ) def test_ignore ( check_user_prompt_not_closed_but_exception , dialog_type ) : [EOL] check_user_prompt_not_closed_but_exception ( dialog_type ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , None ) , ( [string] , False ) , ( [string] , None ) , ] ) def test_default ( check_user_prompt_closed_with_exception , dialog_type , retval ) : [EOL] check_user_prompt_closed_with_exception ( dialog_type , retval ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from tests . perform_actions . support . refine import get_events , get_keys [EOL] [EOL] [EOL] def test_perform_no_actions_send_no_events ( session , key_reporter , key_chain ) : [EOL] key_chain . perform ( ) [EOL] assert len ( get_keys ( key_reporter ) ) == [number] [EOL] assert len ( get_events ( session ) ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . support . asserts import assert_error , assert_success [EOL] [EOL] [EOL] def perform_actions ( session , actions ) : [EOL] return session . transport . send ( [string] , [string] . format ( session_id = session . session_id ) , { [string] : actions } ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] ] ) def test_pause_positive_integer ( session , action_type ) : [EOL] for valid_duration in [ [number] , [number] ] : [EOL] actions = [ { [string] : action_type , [string] : [string] , [string] : [ { [string] : [string] , [string] : valid_duration } ] } ] [EOL] response = perform_actions ( session , actions ) [EOL] assert_success ( response ) [EOL] [EOL] actions = [ { [string] : action_type , [string] : [string] , [string] : [ { [string] : [string] , [string] : - [number] } ] } ] [EOL] response = perform_actions ( session , actions ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] ] ) def test_pause_invalid_types ( session , action_type ) : [EOL] for invalid_type in [ [number] , None , [string] , True , [ ] , { } ] : [EOL] actions = [ { [string] : action_type , [string] : [string] , [string] : [ { [string] : [string] , [string] : invalid_type } ] } ] [EOL] response = perform_actions ( session , actions ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] ] ) def test_pause_without_duration ( session , action_type ) : [EOL] actions = [ { [string] : action_type , [string] : [string] , [string] : [ { [string] : [string] , } ] } ] [EOL] response = perform_actions ( session , actions ) [EOL] assert_success ( response ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] ] ) def test_action_without_id ( session , action_type ) : [EOL] actions = [ { [string] : action_type , [string] : [ { [string] : [string] , [string] : [number] } ] } ] [EOL] response = perform_actions ( session , actions ) [EOL] assert_error ( response , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] def get_events ( session ) : [EOL] [docstring] [EOL] events = session . execute_script ( [string] ) or [ ] [EOL] [comment] [EOL] [comment] [EOL] for e in events : [EOL] [comment] [EOL] if [string] in e and e [ [string] ] . startswith ( [string] ) : [EOL] key = e [ [string] ] [EOL] hex_suffix = key [ key . index ( [string] ) + [number] : ] [EOL] e [ [string] ] = unichr ( int ( hex_suffix , [number] ) ) [EOL] return events [EOL] [EOL] [EOL] def get_keys ( input_el ) : [EOL] [docstring] [EOL] rv = input_el . property ( [string] ) [EOL] if rv is None : [EOL] return [string] [EOL] else : [EOL] return rv [EOL] [EOL] [EOL] def filter_dict ( source , d ) : [EOL] [docstring] [EOL] return { k : source [ k ] for k in d . keys ( ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import typing [EOL] def get_viewport_rect ( session ) : [EOL] return session . execute_script ( [string] ) [EOL] [EOL] [EOL] def get_inview_center ( elem_rect , viewport_rect ) : [EOL] x = { [string] : max ( [number] , min ( elem_rect [ [string] ] , elem_rect [ [string] ] + elem_rect [ [string] ] ) ) , [string] : min ( viewport_rect [ [string] ] , max ( elem_rect [ [string] ] , elem_rect [ [string] ] + elem_rect [ [string] ] ) ) , } [EOL] [EOL] y = { [string] : max ( [number] , min ( elem_rect [ [string] ] , elem_rect [ [string] ] + elem_rect [ [string] ] ) ) , [string] : min ( viewport_rect [ [string] ] , max ( elem_rect [ [string] ] , elem_rect [ [string] ] + elem_rect [ [string] ] ) ) , } [EOL] [EOL] return { [string] : ( x [ [string] ] + x [ [string] ] ) / [number] , [string] : ( y [ [string] ] + y [ [string] ] ) / [number] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] from webdriver . error import NoSuchAlertException [EOL] [EOL] from tests . support . asserts import assert_error , assert_success [EOL] from tests . support . inline import inline [EOL] from tests . support . sync import Poll [EOL] [EOL] [EOL] def dismiss_alert ( session ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) ) [EOL] [EOL] [EOL] def test_null_response_value ( session , url ) : [EOL] session . url = inline ( [string] ) [EOL] [EOL] response = dismiss_alert ( session ) [EOL] value = assert_success ( response ) [EOL] assert value is None [EOL] [EOL] [EOL] def test_no_browsing_context ( session , closed_window ) : [EOL] response = dismiss_alert ( session ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_no_user_prompt ( session ) : [EOL] response = dismiss_alert ( session ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_dismiss_alert ( session ) : [EOL] session . url = inline ( [string] ) [EOL] response = dismiss_alert ( session ) [EOL] assert_success ( response ) [EOL] [EOL] [EOL] def test_dismiss_confirm ( session ) : [EOL] session . url = inline ( [string] ) [EOL] response = dismiss_alert ( session ) [EOL] assert_success ( response ) [EOL] assert session . execute_script ( [string] ) is False [EOL] [EOL] [EOL] def test_dismiss_prompt ( session ) : [EOL] session . url = inline ( [string] ) [EOL] response = dismiss_alert ( session ) [EOL] assert_success ( response ) [EOL] assert session . execute_script ( [string] ) is None [EOL] [EOL] [EOL] def test_unexpected_alert ( session ) : [EOL] session . execute_script ( [string] ) [EOL] wait = Poll ( session , timeout = [number] , ignored_exceptions = NoSuchAlertException , message = [string] ) [EOL] wait . until ( lambda s : s . alert . text == [string] ) [EOL] [EOL] response = dismiss_alert ( session ) [EOL] assert_success ( response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] from tests . support . asserts import assert_error , assert_success [EOL] from tests . support . inline import inline [EOL] [EOL] [EOL] def get_page_source ( session ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) ) [EOL] [EOL] [EOL] def test_no_browsing_context ( session , closed_window ) : [EOL] response = get_page_source ( session ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_source_matches_outer_html ( session ) : [EOL] session . url = inline ( [string] ) [EOL] [EOL] expected = session . execute_script ( [string] ) [EOL] [EOL] response = get_page_source ( session ) [EOL] assert_success ( response , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . support . asserts import assert_success [EOL] from tests . support . image import png_dimensions [EOL] from tests . support . inline import iframe , inline [EOL] [EOL] from . import element_dimensions , viewport_dimensions [EOL] [EOL] DEFAULT_CONTENT = [string] [EOL] [EOL] REFERENCE_CONTENT = [string] . format ( DEFAULT_CONTENT ) [EOL] REFERENCE_STYLE = [string] [EOL] [EOL] OUTER_IFRAME_STYLE = [string] [EOL] [EOL] INNER_IFRAME_STYLE = [string] [EOL] [EOL] [EOL] def take_screenshot ( session ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) ) [EOL] [EOL] [EOL] def test_always_captures_top_browsing_context ( session ) : [EOL] iframe_content = [string] . format ( INNER_IFRAME_STYLE , DEFAULT_CONTENT ) [EOL] session . url = inline ( [string] . format ( OUTER_IFRAME_STYLE , iframe ( iframe_content ) ) ) [EOL] [EOL] response = take_screenshot ( session ) [EOL] reference_screenshot = assert_success ( response ) [EOL] assert png_dimensions ( reference_screenshot ) == viewport_dimensions ( session ) [EOL] [EOL] frame = session . find . css ( [string] , all = False ) [EOL] session . switch_frame ( frame ) [EOL] [EOL] response = take_screenshot ( session ) [EOL] screenshot = assert_success ( response ) [EOL] [EOL] assert png_dimensions ( screenshot ) == png_dimensions ( reference_screenshot ) [EOL] assert screenshot == reference_screenshot [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] , ids = [ [string] , [string] ] ) def test_source_origin ( session , domain ) : [EOL] session . url = inline ( [string] . format ( REFERENCE_STYLE , REFERENCE_CONTENT ) ) [EOL] [EOL] response = take_screenshot ( session ) [EOL] reference_screenshot = assert_success ( response ) [EOL] assert png_dimensions ( reference_screenshot ) == viewport_dimensions ( session ) [EOL] [EOL] iframe_content = [string] . format ( INNER_IFRAME_STYLE , DEFAULT_CONTENT ) [EOL] session . url = inline ( [string] . format ( OUTER_IFRAME_STYLE , iframe ( iframe_content , domain = domain ) ) ) [EOL] [EOL] response = take_screenshot ( session ) [EOL] screenshot = assert_success ( response ) [EOL] assert png_dimensions ( screenshot ) == viewport_dimensions ( session ) [EOL] [EOL] assert screenshot == reference_screenshot [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def element_dimensions ( session , element ) : [EOL] return tuple ( session . execute_script ( [string] , args = ( element , ) ) ) [EOL] [EOL] [EOL] def viewport_dimensions ( session ) : [EOL] return tuple ( session . execute_script ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . support . asserts import assert_success [EOL] from tests . support . helpers import is_fullscreen [EOL] [EOL] [EOL] def fullscreen_window ( session ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , range ( [number] ) ) def test_stress ( session , i ) : [EOL] assert not is_fullscreen ( session ) [EOL] response = fullscreen_window ( session ) [EOL] assert_success ( response ) [EOL] assert is_fullscreen ( session ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . support . asserts import assert_success [EOL] from tests . support . helpers import document_hidden [EOL] [EOL] [EOL] def minimize_window ( session ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , range ( [number] ) ) def test_stress ( session , i ) : [EOL] assert not document_hidden ( session ) [EOL] response = minimize_window ( session ) [EOL] assert_success ( response ) [EOL] assert document_hidden ( session ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . support . asserts import ( assert_dialog_handled , assert_error , assert_is_active_element , assert_success ) [EOL] from tests . support . inline import inline [EOL] [EOL] [EOL] def get_active_element ( session ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) ) [EOL] [EOL] [EOL] @ pytest . fixture def check_user_prompt_closed_without_exception ( session , create_dialog ) : [EOL] def check_user_prompt_closed_without_exception ( dialog_type , retval ) : [EOL] session . url = inline ( [string] ) [EOL] [EOL] create_dialog ( dialog_type , text = dialog_type ) [EOL] [EOL] response = get_active_element ( session ) [EOL] element = assert_success ( response ) [EOL] [EOL] assert_dialog_handled ( session , expected_text = dialog_type , expected_retval = retval ) [EOL] [EOL] assert_is_active_element ( session , element ) [EOL] [EOL] return check_user_prompt_closed_without_exception [EOL] [EOL] [EOL] @ pytest . fixture def check_user_prompt_closed_with_exception ( session , create_dialog ) : [EOL] def check_user_prompt_closed_with_exception ( dialog_type , retval ) : [EOL] session . url = inline ( [string] ) [EOL] [EOL] create_dialog ( dialog_type , text = dialog_type ) [EOL] [EOL] response = get_active_element ( session ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] assert_dialog_handled ( session , expected_text = dialog_type , expected_retval = retval ) [EOL] [EOL] return check_user_prompt_closed_with_exception [EOL] [EOL] [EOL] @ pytest . fixture def check_user_prompt_not_closed_but_exception ( session , create_dialog ) : [EOL] def check_user_prompt_not_closed_but_exception ( dialog_type ) : [EOL] session . url = inline ( [string] ) [EOL] [EOL] create_dialog ( dialog_type , text = dialog_type ) [EOL] [EOL] response = get_active_element ( session ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] assert session . alert . text == dialog_type [EOL] session . alert . dismiss ( ) [EOL] [EOL] return check_user_prompt_not_closed_but_exception [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : [string] } ) @ pytest . mark . parametrize ( [string] , [ ( [string] , None ) , ( [string] , True ) , ( [string] , [string] ) , ] ) def test_accept ( check_user_prompt_closed_without_exception , dialog_type , retval ) : [EOL] check_user_prompt_closed_without_exception ( dialog_type , retval ) [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : [string] } ) @ pytest . mark . parametrize ( [string] , [ ( [string] , None ) , ( [string] , True ) , ( [string] , [string] ) , ] ) def test_accept_and_notify ( check_user_prompt_closed_with_exception , dialog_type , retval ) : [EOL] check_user_prompt_closed_with_exception ( dialog_type , retval ) [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : [string] } ) @ pytest . mark . parametrize ( [string] , [ ( [string] , None ) , ( [string] , False ) , ( [string] , None ) , ] ) def test_dismiss ( check_user_prompt_closed_without_exception , dialog_type , retval ) : [EOL] check_user_prompt_closed_without_exception ( dialog_type , retval ) [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : [string] } ) @ pytest . mark . parametrize ( [string] , [ ( [string] , None ) , ( [string] , False ) , ( [string] , None ) , ] ) def test_dismiss_and_notify ( check_user_prompt_closed_with_exception , dialog_type , retval ) : [EOL] check_user_prompt_closed_with_exception ( dialog_type , retval ) [EOL] [EOL] [EOL] @ pytest . mark . capabilities ( { [string] : [string] } ) @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] ] ) def test_ignore ( check_user_prompt_not_closed_but_exception , dialog_type ) : [EOL] check_user_prompt_not_closed_but_exception ( dialog_type ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , None ) , ( [string] , False ) , ( [string] , None ) , ] ) def test_default ( check_user_prompt_closed_with_exception , dialog_type , retval ) : [EOL] check_user_prompt_closed_with_exception ( dialog_type , retval ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] from six import text_type [EOL] [EOL] from tests . support import platform_name [EOL] from tests . support . inline import inline [EOL] from tests . support . asserts import assert_error , assert_success [EOL] [EOL] doc = inline ( [string] ) [EOL] alert_doc = inline ( [string] ) [EOL] [EOL] [EOL] def get_current_url ( session ) : [EOL] return session . transport . send ( [string] , [string] . format ( ** vars ( session ) ) ) [EOL] [EOL] [EOL] def test_no_browsing_context ( session , closed_window ) : [EOL] response = get_current_url ( session ) [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_get_current_url_matches_location ( session ) : [EOL] session . url = doc [EOL] [EOL] response = get_current_url ( session ) [EOL] assert_success ( response , doc ) [EOL] [EOL] [EOL] def test_get_current_url_payload ( session ) : [EOL] session . start ( ) [EOL] [EOL] response = get_current_url ( session ) [EOL] value = assert_success ( response ) [EOL] assert isinstance ( value , text_type ) [EOL] [EOL] [EOL] def test_get_current_url_special_pages ( session ) : [EOL] session . url = [string] [EOL] [EOL] response = get_current_url ( session ) [EOL] assert_success ( response , [string] ) [EOL] [EOL] [EOL] def test_get_current_url_file_protocol ( session , server_config ) : [EOL] [comment] [EOL] [comment] [EOL] path = server_config [ [string] ] [EOL] if platform_name == [string] : [EOL] [comment] [EOL] path = [string] . format ( path . replace ( [string] , [string] ) ) [EOL] url = [string] . format ( path ) [EOL] session . url = url [EOL] [EOL] response = get_current_url ( session ) [EOL] if response . status == [number] and response . body [ [string] ] . endswith ( [string] ) : [EOL] url += [string] [EOL] assert_success ( response , url ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_set_malformed_url ( session ) : [EOL] response = session . transport . send ( [string] , [string] % session . session_id , { [string] : [string] } ) [EOL] [EOL] assert_error ( response , [string] ) [EOL] [EOL] [EOL] def test_get_current_url_after_modified_location ( session ) : [EOL] session . url = doc [EOL] [EOL] response = get_current_url ( session ) [EOL] assert_success ( response , doc ) [EOL] [EOL] hash_doc = [string] . format ( doc ) [EOL] session . url = hash_doc [EOL] [EOL] response = get_current_url ( session ) [EOL] assert_success ( response , hash_doc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Optional [EOL] import typing [EOL] import sys [EOL] [EOL] from . merge_dictionaries import merge_dictionaries [EOL] [EOL] platform_name = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } . get ( sys . platform ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Tuple , Literal [EOL] import typing_extensions [EOL] import typing [EOL] SCRIPT_TIMEOUT = [number] [EOL] PAGE_LOAD_TIMEOUT = [number] [EOL] IMPLICIT_WAIT_TIMEOUT = [number] [EOL] [EOL] WINDOW_POSITION = ( [number] , [number] ) [EOL] WINDOW_SIZE = ( [number] , [number] ) [EOL] [EOL] DRIVER_HOST = [string] [EOL] DRIVER_PORT = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from six . moves . urllib . parse import urlencode [EOL] [EOL] [EOL] BOILERPLATES = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] MIME_TYPES = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] def inline ( src , doctype = [string] , mime = None , charset = None , ** kwargs ) : [EOL] [docstring] [EOL] from . fixtures import server_config , url [EOL] build_url = url ( server_config ( ) ) [EOL] [EOL] if mime is None : [EOL] mime = MIME_TYPES [ doctype ] [EOL] if charset is None : [EOL] charset = [string] [EOL] doc = BOILERPLATES [ doctype ] . format ( charset = charset , src = src ) [EOL] [EOL] query = { [string] : doc , [string] : mime , [string] : charset } [EOL] return build_url ( [string] , query = urlencode ( query ) , ** kwargs ) [EOL] [EOL] [EOL] def iframe ( src , ** kwargs ) : [EOL] [docstring] [EOL] return [string] . format ( inline ( src , ** kwargs ) ) [EOL] [EOL] [EOL] def main ( request , response ) : [EOL] doc = request . GET . first ( [string] , None ) [EOL] mime = request . GET . first ( [string] , None ) [EOL] charset = request . GET . first ( [string] , None ) [EOL] [EOL] if doc is None : [EOL] return [number] , [ ( [string] , [string] ) ] , [string] [EOL] [EOL] content_type = [ ] [EOL] if mime is not None : [EOL] content_type . append ( mime ) [EOL] if charset is not None : [EOL] content_type . append ( [string] % charset ) [EOL] [EOL] headers = { [string] : [string] } [EOL] if len ( content_type ) > [number] : [EOL] headers [ [string] ] = [string] . join ( content_type ) [EOL] [EOL] return [number] , headers . items ( ) , doc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import typing [EOL] import os [EOL] from wptserve import pipes [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def run_other ( request , response , path ) : [EOL] [comment] [EOL] environ = { [string] : path } [EOL] exec ( compile ( open ( path , [string] ) . read ( ) , path , [string] ) , environ , environ ) [EOL] rv = environ [ [string] ] ( request , response ) [EOL] return rv [EOL] [EOL] def main ( request , response ) : [EOL] origin = request . GET . first ( [string] , request . headers [ [string] ] ) [EOL] credentials = request . GET . first ( [string] , [string] ) [EOL] [EOL] response . headers . update ( [ ( [string] , origin ) , ( [string] , credentials ) ] ) [EOL] [EOL] handler = request . GET . first ( [string] ) [EOL] if handler in [ [string] , [string] , [string] , [string] ] : [EOL] if handler == [string] : [EOL] response . headers . set ( [string] , [string] ) [EOL] rv = open ( os . path . join ( request . doc_root , [string] , [string] , [string] ) , [string] ) . read ( ) [EOL] response . content = rv [EOL] pipes . sub ( request , response ) [EOL] return [EOL] elif handler == [string] : [EOL] return run_other ( request , response , os . path . join ( request . doc_root , [string] , [string] ) ) [EOL] else : [EOL] return run_other ( request , response , os . path . join ( os . path . dirname ( isomorphic_decode ( __file__ ) ) , isomorphic_decode ( handler ) + [string] ) ) [EOL] else : [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] [EOL] def main ( request , response ) : [EOL] time . sleep ( [number] ) [EOL] return [number] , [ ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] [comment] [EOL] [comment] [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] response . content = request . GET . first ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any , Dict [EOL] import typing [EOL] import os , sys , json [EOL] [EOL] from wptserve . utils import isomorphic_decode , isomorphic_encode [EOL] [EOL] sys . path . insert ( [number] , os . path . dirname ( os . path . abspath ( isomorphic_decode ( __file__ ) ) ) ) [EOL] import util [EOL] [EOL] def main ( request , response ) : [EOL] policyDeliveries = json . loads ( request . GET . first ( [string] , [string] ) ) [EOL] maybe_additional_headers = { } [EOL] meta = [string] [EOL] error = [string] [EOL] for delivery in policyDeliveries : [EOL] if delivery [ [string] ] == [string] : [EOL] if delivery [ [string] ] == [string] : [EOL] meta += [string] % delivery [ [string] ] [EOL] else : [EOL] error = [string] [EOL] elif delivery [ [string] ] == [string] : [EOL] if delivery [ [string] ] == [string] : [EOL] maybe_additional_headers [ [string] ] = isomorphic_encode ( delivery [ [string] ] ) [EOL] else : [EOL] error = [string] [EOL] else : [EOL] error = [string] [EOL] [EOL] handler = lambda : util . get_template ( [string] ) % ( { [string] : meta , [string] : error } ) [EOL] util . respond ( request , response , payload_generator = handler , content_type = [string] , maybe_additional_headers = maybe_additional_headers ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any , Dict [EOL] import typing [EOL] import os , sys , json [EOL] [EOL] from wptserve . utils import isomorphic_decode , isomorphic_encode [EOL] sys . path . insert ( [number] , os . path . dirname ( os . path . abspath ( isomorphic_decode ( __file__ ) ) ) ) [EOL] import util [EOL] [EOL] def main ( request , response ) : [EOL] policyDeliveries = json . loads ( request . GET . first ( [string] , [string] ) ) [EOL] worker_type = request . GET . first ( [string] , [string] ) [EOL] commonjs_url = [string] % ( request . url_parts . scheme , request . url_parts . hostname , request . url_parts . port ) [EOL] if worker_type == [string] : [EOL] import_line = [string] % commonjs_url [EOL] else : [EOL] import_line = [string] % commonjs_url [EOL] [EOL] maybe_additional_headers = { } [EOL] error = [string] [EOL] for delivery in policyDeliveries : [EOL] if delivery [ [string] ] == [string] : [EOL] error = [string] [EOL] elif delivery [ [string] ] == [string] : [EOL] if delivery [ [string] ] == [string] : [EOL] maybe_additional_headers [ [string] ] = isomorphic_encode ( delivery [ [string] ] ) [EOL] elif delivery [ [string] ] == [string] and delivery [ [string] ] == [string] : [EOL] maybe_additional_headers [ [string] ] = [string] [EOL] elif delivery [ [string] ] == [string] and delivery [ [string] ] == [string] : [EOL] maybe_additional_headers [ [string] ] = [string] [EOL] else : [EOL] error = [string] % delivery [ [string] ] [EOL] else : [EOL] error = [string] % delivery [ [string] ] [EOL] [EOL] handler = lambda : util . get_template ( [string] ) % ( { [string] : import_line , [string] : error } ) [EOL] util . respond ( request , response , payload_generator = handler , content_type = [string] , maybe_additional_headers = maybe_additional_headers ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import os , sys [EOL] from wptserve . utils import isomorphic_decode [EOL] sys . path . insert ( [number] , os . path . dirname ( os . path . abspath ( isomorphic_decode ( __file__ ) ) ) ) [EOL] import subresource [EOL] [EOL] def generate_payload ( server_data ) : [EOL] return subresource . get_template ( [string] ) % server_data [EOL] [EOL] def main ( request , response ) : [EOL] subresource . respond ( request , response , payload_generator = generate_payload ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] referrer = request . headers . get ( [string] , [string] ) [EOL] response_headers = [ ( [string] , [string] ) ] [EOL] return ( [number] , response_headers , [string] + referrer + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , Any , List [EOL] import urllib [EOL] import typing [EOL] import os , json [EOL] from six . moves . urllib . parse import parse_qsl , SplitResult , urlencode , urlsplit , urlunsplit [EOL] [EOL] from wptserve . utils import isomorphic_decode , isomorphic_encode [EOL] [EOL] def get_template ( template_basename ) : [EOL] script_directory = os . path . dirname ( os . path . abspath ( isomorphic_decode ( __file__ ) ) ) [EOL] template_directory = os . path . abspath ( os . path . join ( script_directory , [string] ) ) [EOL] template_filename = os . path . join ( template_directory , template_basename ) [EOL] [EOL] with open ( template_filename , [string] ) as f : [EOL] return f . read ( ) [EOL] [EOL] [EOL] def redirect ( url , response ) : [EOL] response . add_required_headers = False [EOL] response . writer . write_status ( [number] ) [EOL] response . writer . write_header ( [string] , [string] ) [EOL] response . writer . write_header ( [string] , isomorphic_encode ( url ) ) [EOL] response . writer . end_headers ( ) [EOL] response . writer . write ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def __get_swapped_origin_netloc ( netloc , subdomain_prefix = [string] ) : [EOL] if netloc . startswith ( subdomain_prefix ) : [EOL] return netloc [ len ( subdomain_prefix ) : ] [EOL] else : [EOL] return subdomain_prefix + netloc [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def create_url ( request , swap_scheme = False , swap_origin = False , downgrade = False , query_parameter_to_remove = [string] ) : [EOL] parsed = urlsplit ( request . url ) [EOL] destination_netloc = parsed . netloc [EOL] [EOL] scheme = parsed . scheme [EOL] if swap_scheme : [EOL] scheme = [string] if parsed . scheme == [string] else [string] [EOL] hostname = parsed . netloc . split ( [string] ) [ [number] ] [EOL] port = request . server . config [ [string] ] [ scheme ] [ [number] ] [EOL] destination_netloc = [string] . join ( [ hostname , str ( port ) ] ) [EOL] [EOL] if downgrade : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if parsed . scheme == [string] : [EOL] scheme = [string] [EOL] elif parsed . scheme == [string] : [EOL] scheme = [string] [EOL] else : [EOL] raise ValueError ( [string] % parsed . scheme ) [EOL] hostname = parsed . netloc . split ( [string] ) [ [number] ] [EOL] port = request . server . config [ [string] ] [ parsed . scheme ] [ [number] ] [EOL] destination_netloc = [string] . join ( [ hostname , str ( port ) ] ) [EOL] [EOL] if swap_origin : [EOL] destination_netloc = __get_swapped_origin_netloc ( destination_netloc ) [EOL] [EOL] parsed_query = parse_qsl ( parsed . query , keep_blank_values = True ) [EOL] parsed_query = [ x for x in parsed_query if x [ [number] ] != query_parameter_to_remove ] [EOL] [EOL] destination_url = urlunsplit ( SplitResult ( scheme = scheme , netloc = destination_netloc , path = parsed . path , query = urlencode ( parsed_query ) , fragment = None ) ) [EOL] [EOL] return destination_url [EOL] [EOL] [EOL] def preprocess_redirection ( request , response ) : [EOL] if [string] not in request . GET : [EOL] return False [EOL] [EOL] redirection = request . GET [ [string] ] [EOL] [EOL] if redirection == [string] : [EOL] return False [EOL] elif redirection == [string] : [EOL] redirect_url = create_url ( request , swap_scheme = False ) [EOL] elif redirection == [string] : [EOL] redirect_url = create_url ( request , swap_scheme = True ) [EOL] elif redirection == [string] : [EOL] redirect_url = create_url ( request , downgrade = True ) [EOL] elif redirection == [string] : [EOL] redirect_url = create_url ( request , swap_origin = False ) [EOL] elif redirection == [string] : [EOL] redirect_url = create_url ( request , swap_origin = True ) [EOL] else : [EOL] raise ValueError ( [string] % isomorphic_decode ( redirection ) ) [EOL] [EOL] redirect ( redirect_url , response ) [EOL] return True [EOL] [EOL] [EOL] def preprocess_stash_action ( request , response ) : [EOL] if [string] not in request . GET : [EOL] return False [EOL] [EOL] action = request . GET [ [string] ] [EOL] [EOL] key = request . GET [ [string] ] [EOL] stash = request . server . stash [EOL] path = request . GET [ [string] ] if [string] in request . GET \ [EOL] else isomorphic_encode ( request . url . split ( [string] ) [ [number] ] ) [EOL] [EOL] if action == [string] : [EOL] value = isomorphic_decode ( request . GET [ [string] ] ) [EOL] stash . take ( key = key , path = path ) [EOL] stash . put ( key = key , value = value , path = path ) [EOL] response_data = json . dumps ( { [string] : [string] , [string] : isomorphic_decode ( key ) } ) [EOL] elif action == [string] : [EOL] value = stash . take ( key = key , path = path ) [EOL] return False [EOL] elif action == [string] : [EOL] value = stash . take ( key = key , path = path ) [EOL] if value is None : [EOL] status = [string] [EOL] else : [EOL] status = [string] [EOL] response_data = json . dumps ( { [string] : status , [string] : value } ) [EOL] else : [EOL] return False [EOL] [EOL] response . add_required_headers = False [EOL] response . writer . write_status ( [number] ) [EOL] response . writer . write_header ( [string] , [string] ) [EOL] response . writer . write_header ( [string] , [string] ) [EOL] response . writer . end_headers ( ) [EOL] response . writer . write ( response_data ) [EOL] return True [EOL] [EOL] [EOL] def __noop ( request , response ) : [EOL] return [string] [EOL] [EOL] [EOL] def respond ( request , response , status_code = [number] , content_type = [string] , payload_generator = __noop , cache_control = [string] , access_control_allow_origin = [string] , maybe_additional_headers = None ) : [EOL] if preprocess_redirection ( request , response ) : [EOL] return [EOL] [EOL] if preprocess_stash_action ( request , response ) : [EOL] return [EOL] [EOL] response . add_required_headers = False [EOL] response . writer . write_status ( status_code ) [EOL] [EOL] if access_control_allow_origin != None : [EOL] response . writer . write_header ( [string] , access_control_allow_origin ) [EOL] response . writer . write_header ( [string] , content_type ) [EOL] response . writer . write_header ( [string] , cache_control ) [EOL] [EOL] additional_headers = maybe_additional_headers or { } [EOL] for header , value in additional_headers . items ( ) : [EOL] response . writer . write_header ( header , value ) [EOL] [EOL] response . writer . end_headers ( ) [EOL] [EOL] new_headers = { } [EOL] new_val = [ ] [EOL] for key , val in request . headers . items ( ) : [EOL] if len ( val ) == [number] : [EOL] new_val = isomorphic_decode ( val [ [number] ] ) [EOL] else : [EOL] new_val = [ isomorphic_decode ( x ) for x in val ] [EOL] new_headers [ isomorphic_decode ( key ) ] = new_val [EOL] [EOL] server_data = { [string] : json . dumps ( new_headers , indent = [number] ) } [EOL] [EOL] payload = payload_generator ( server_data ) [EOL] response . writer . write ( payload ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from wptserve . utils import isomorphic_encode [EOL] [EOL] def main ( request , response ) : [EOL] values = request . GET . get_list ( [string] ) [EOL] content = request . GET . first ( [string] , [string] ) [EOL] output = [string] [EOL] output += [string] [EOL] if [string] in request . GET : [EOL] output += [string] + [string] . join ( values ) + [string] [EOL] else : [EOL] for value in values : [EOL] output += [string] + value + [string] [EOL] output += [string] + isomorphic_encode ( str ( len ( content ) ) ) + [string] [EOL] output += [string] [EOL] output += content [EOL] response . writer . write ( output ) [EOL] response . close_connection = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , request . GET [ [string] ] ) ] [EOL] if [string] in request . headers : [EOL] headers . append ( ( [string] , request . headers [ [string] ] ) ) [EOL] [EOL] return [number] , headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) , ( [string] , request . GET [ [string] ] ) ] [EOL] return [number] , headers , [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , request . GET [ [string] ] ) ] [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , request . GET [ [string] ] ) ) [EOL] [EOL] return [number] , headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , request . GET [ [string] ] ) ] [EOL] if [string] in request . headers : [EOL] headers . append ( ( [string] , request . headers [ [string] ] ) ) [EOL] [EOL] return [number] , headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import os . path [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] type = request . GET . first ( [string] , None ) [EOL] [EOL] if type != None and [string] in type : [EOL] filename = [string] [EOL] else : [EOL] filename = [string] [EOL] [EOL] path = os . path . join ( os . path . dirname ( isomorphic_decode ( __file__ ) ) , [string] , filename ) [EOL] body = open ( path , [string] ) . read ( ) [EOL] [EOL] response . add_required_headers = False [EOL] response . writer . write_status ( [number] ) [EOL] response . writer . write_header ( [string] , [string] ) [EOL] response . writer . write_header ( [string] , len ( body ) ) [EOL] if ( type != None ) : [EOL] response . writer . write_header ( [string] , type ) [EOL] response . writer . end_headers ( ) [EOL] [EOL] response . writer . write ( body ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] type = request . GET . first ( [string] , None ) [EOL] is_revalidation = request . headers . get ( [string] , None ) [EOL] [EOL] content = [string] [EOL] [EOL] response . add_required_headers = False [EOL] if is_revalidation is not None : [EOL] response . writer . write_status ( [number] ) [EOL] response . writer . write_header ( [string] , [string] ) [EOL] response . writer . write_header ( [string] , [number] ) [EOL] if ( type != None ) : [EOL] response . writer . write_header ( [string] , type ) [EOL] response . writer . end_headers ( ) [EOL] response . writer . write ( [string] ) [EOL] else : [EOL] response . writer . write_status ( [number] ) [EOL] response . writer . write_header ( [string] , [string] ) [EOL] response . writer . write_header ( [string] , len ( content ) ) [EOL] if ( type != None ) : [EOL] response . writer . write_header ( [string] , type ) [EOL] response . writer . end_headers ( ) [EOL] response . writer . write ( content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from wptserve . handlers import json_handler [EOL] [EOL] [EOL] @ json_handler def main ( request , response ) : [EOL] key = request . GET . first ( [string] ) [EOL] return request . server . stash . take ( key , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from wptserve . utils import isomorphic_decode , isomorphic_encode [EOL] [EOL] def main ( request , response ) : [EOL] image_url = str . replace ( request . url , [string] , [string] ) [EOL] [EOL] if [string] not in request . headers : [EOL] response . status = [number] [EOL] response . headers . set ( [string] , [string] ) [EOL] return [EOL] else : [EOL] auth = request . headers . get ( [string] ) [EOL] if auth != [string] : [EOL] response . set_error ( [number] , [string] + isomorphic_decode ( auth ) ) [EOL] return [EOL] [EOL] response . status = [number] [EOL] response . headers . set ( [string] , isomorphic_encode ( image_url ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] token = request . GET . first ( [string] ) [EOL] if request . server . stash . take ( token ) is not None : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] return [number] , headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any , List [EOL] import typing [EOL] from wptserve . handlers import json_handler [EOL] [EOL] [EOL] @ json_handler def main ( request , response ) : [EOL] dir = [string] . join ( request . url_parts . path . split ( [string] ) [ : - [number] ] ) + [string] [EOL] key = request . GET . first ( [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] return request . server . stash . take ( key , dir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] stashed_data = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] token = None [EOL] if [string] in request . GET : [EOL] token = request . GET . first ( [string] ) [EOL] [EOL] if [string] in request . GET : [EOL] for origin in request . GET [ [string] ] . split ( [string] ) : [EOL] headers . append ( ( [string] , origin ) ) [EOL] else : [EOL] headers . append ( ( [string] , [string] ) ) [EOL] [EOL] if [string] in request . GET : [EOL] if request . server . stash . take ( token ) is not None : [EOL] return headers , [string] [EOL] else : [EOL] return headers , [string] [EOL] [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , [string] ) ) [EOL] [EOL] if request . method == [string] : [EOL] if not [string] in request . headers : [EOL] response . set_error ( [number] , [string] ) [EOL] return [string] [EOL] [EOL] if request . headers . get ( [string] , [string] ) != [string] : [EOL] response . set_error ( [number] , [string] ) [EOL] return [string] [EOL] [EOL] if [string] in request . GET : [EOL] stashed_data [ [string] ] = request . headers . get ( [string] , None ) [EOL] [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , request . GET [ [string] ] ) ) [EOL] [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , request . GET [ [string] ] ) ) [EOL] [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , request . GET [ [string] ] ) ) [EOL] [EOL] preflight_status = [number] [EOL] if [string] in request . GET : [EOL] preflight_status = int ( request . GET . first ( [string] ) ) [EOL] [EOL] stashed_data [ [string] ] = [string] [EOL] stashed_data [ [string] ] = request . headers . get ( [string] , [string] ) [EOL] stashed_data [ [string] ] = request . headers . get ( [string] , [string] ) [EOL] if token : [EOL] request . server . stash . put ( token , stashed_data ) [EOL] [EOL] return preflight_status , headers , [string] [EOL] [EOL] [EOL] if token : [EOL] data = request . server . stash . take ( token ) [EOL] if data : [EOL] stashed_data = data [EOL] [EOL] if [string] in request . GET and request . headers . get ( [string] ) != stashed_data [ [string] ] : [EOL] return [number] , headers , [string] [EOL] [EOL] [comment] [EOL] headers . append ( ( [string] , [string] ) ) [EOL] headers . append ( ( [string] , stashed_data [ [string] ] ) ) [EOL] if stashed_data [ [string] ] != None : [EOL] headers . append ( ( [string] , stashed_data [ [string] ] ) ) [EOL] headers . append ( ( [string] , stashed_data [ [string] ] ) ) [EOL] headers . append ( ( [string] , request . headers . get ( [string] , [string] ) ) ) [EOL] headers . append ( ( [string] , request . headers . get ( [string] , [string] ) ) ) [EOL] [EOL] if token : [EOL] request . server . stash . put ( token , stashed_data ) [EOL] [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] body = request . GET . first ( [string] , None ) [EOL] type = request . GET . first ( [string] , None ) [EOL] [EOL] response . add_required_headers = False [EOL] response . writer . write_status ( [number] ) [EOL] response . writer . write_header ( [string] , len ( body ) ) [EOL] response . writer . write_header ( [string] , type ) [EOL] response . writer . end_headers ( ) [EOL] [EOL] response . writer . write ( body ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
thirty_two_megabytes = [number] * [number] * [number] [EOL] chunk = [string] * [number] * [number] [EOL] chunk_length = len ( chunk ) [EOL] [EOL] def main ( request , response ) : [EOL] def content ( ) : [EOL] bytes_sent = [number] [EOL] while bytes_sent < thirty_two_megabytes : [EOL] yield chunk [EOL] bytes_sent += chunk_length [EOL] [EOL] return [ ( [string] , [string] ) ] , content ( ) [EOL]	$builtins.int$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] allow = request . GET . first ( [string] , [string] ) [EOL] [EOL] headers = [ ( [string] , [string] ) ] [EOL] if allow != [string] : [EOL] headers . append ( ( [string] , [string] ) ) [EOL] [EOL] body = [string] [EOL] [EOL] return headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] time = request . url_parts . query if request . url_parts . query else [string] [EOL] return [number] , [ [ [string] , [string] ] ] , [string] % time [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from base64 import decodestring [EOL] import time [EOL] [EOL] png_response = decodestring ( [string] ) [EOL] [EOL] def main ( request , response ) : [EOL] time . sleep ( [number] ) [EOL] return [number] , [ ] , png_response [EOL]	0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0
from typing import Any [EOL] import typing [EOL] from wptserve . utils import isomorphic_encode [EOL] [EOL] def main ( request , response ) : [EOL] time = isomorphic_encode ( request . url_parts . query ) if request . url_parts . query else [string] [EOL] return [number] , [ ( [string] , time ) , ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from gentestutils import genTestUtils [EOL] [EOL] genTestUtils ( [string] , [string] , [string] , [string] , False ) [EOL] genTestUtils ( [string] , [string] , [string] , [string] , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] [EOL] for value in request . GET . get_list ( [string] ) : [EOL] headers . append ( ( [string] , value ) ) [EOL] [EOL] return ( [number] , headers , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from time import sleep [EOL] def main ( request , response ) : [EOL] if [string] in request . GET : [EOL] delay = int ( request . GET [ [string] ] ) [EOL] sleep ( delay ) [EOL] [EOL] if [string] in request . GET : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , request . GET . first ( [string] ) ) [EOL] response . content = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] directory = os . path . dirname ( isomorphic_decode ( __file__ ) ) [EOL] [EOL] try : [EOL] file_name = request . GET . first ( [string] ) [EOL] content_type = request . GET . first ( [string] ) [EOL] with open ( os . path . join ( directory , isomorphic_decode ( file_name ) ) , [string] ) as fh : [EOL] content = fh . read ( ) [EOL] [EOL] response . headers . set ( [string] , content_type ) [EOL] response . content = content [EOL] except : [EOL] response . set_error ( [number] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] body = [string] [EOL] return [number] , headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] body = [string] [EOL] return [number] , headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] body = [string] [EOL] return [number] , headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] [EOL] def main ( request , response ) : [EOL] delay = float ( request . GET . first ( [string] , [number] ) ) [EOL] time . sleep ( delay / [number] ) [EOL] [EOL] return [ ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] referrer = request . headers . get ( [string] , [string] ) [EOL] response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] return ( [number] , response_headers , [string] + referrer + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
template = [string] [EOL] [EOL] n = [number] [EOL] for timing in [ [string] , [string] , [string] ] : [EOL] for destType in [ [string] , [string] ] : [EOL] for inlineOrExternal in [ [string] , [string] , [string] ] : [EOL] for result in [ [string] , [string] , [string] ] : [EOL] for type in [ [string] , [string] ] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if inlineOrExternal == [string] and result == [string] : [EOL] continue [EOL] [EOL] if inlineOrExternal == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if result != [string] : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if timing != [string] : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if timing != [string] and destType == [string] and inlineOrExternal == [string] : [EOL] continue [EOL] [comment] [EOL] if timing != [string] and inlineOrExternal == [string] and type == [string] : [EOL] continue [EOL] [EOL] with open ( [string] % ( timing , destType , result , inlineOrExternal , type ) , [string] ) as f : [EOL] f . write ( template % ( timing , destType , result , inlineOrExternal , type ) ) [EOL]	$builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] import time [EOL] [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] [EOL] result = request . GET . first ( [string] , [string] ) [EOL] if result == [string] : [EOL] time . sleep ( [number] ) [EOL] headers = [ ( [string] , [string] ) ] [EOL] body = [string] [EOL] else : [EOL] time . sleep ( [number] ) [EOL] [EOL] body = [string] [EOL] if result == [string] : [EOL] body = [string] [EOL] if result == [string] : [EOL] return [number] , [ ( [string] , [string] ) ] , [string] [EOL] [EOL] return headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] import re [EOL] [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] test = request . GET . first ( [string] ) [EOL] assert ( re . match ( [string] , test ) ) [EOL] [EOL] if test . find ( [string] ) >= [number] : [EOL] status = [number] [EOL] content = [string] % test [EOL] else : [EOL] status = [number] [EOL] content = [string] % test [EOL] [EOL] return status , headers , content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] [EOL] def main ( request , response ) : [EOL] time . sleep ( [number] ) [EOL] return [ ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import typing [EOL] from wptserve . handlers import HTTPException [EOL] [EOL] def main ( request , response ) : [EOL] if request . method != [string] : [EOL] raise HTTPException ( [number] , message = [string] ) [EOL] [EOL] if not [string] in request . GET : [EOL] raise HTTPException ( [number] , message = [string] ) [EOL] [EOL] id = request . GET [ [string] ] [EOL] if [string] in request . GET : [EOL] data = request . server . stash . take ( id ) [EOL] if data is None : [EOL] response . set_error ( [number] , [string] ) [EOL] return [EOL] return [ ( [string] , [string] ) ] , data [EOL] [EOL] elif [string] in request . GET : [EOL] request . server . stash . take ( id ) [EOL] return [string] [EOL] [EOL] elif [string] in request . GET : [EOL] response . delete_cookie ( id ) [EOL] return [ ( [string] , [string] ) ] , [string] [EOL] [EOL] if [string] in request . GET : [EOL] response . headers . set ( [string] , request . GET [ [string] ] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] [EOL] cors = request . headers . get ( [string] , [string] ) [EOL] [EOL] cookie = request . cookies . first ( id , None ) [EOL] cookie_value = cookie . value if cookie is not None else [string] [EOL] [EOL] line = [string] + cors + [string] + cookie_value [EOL] [EOL] data = request . server . stash . take ( id ) [EOL] if data is not None : [EOL] line = data + [string] + line [EOL] [EOL] request . server . stash . put ( id , line ) [EOL] [EOL] if [string] in request . GET : [EOL] response . status = [number] [EOL] response . headers . set ( [string] , request . GET [ [string] ] ) [EOL] else : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import base64 [EOL] def main ( req , res ) : [EOL] return [number] , [ ( [string] , [string] ) ] , base64 . decodestring ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return ( [ ( [string] , [string] ) ] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] def main ( request , response ) : [EOL] bytes = bytearray ( request . raw_input . read ( ) ) [EOL] bytes_string = [string] . join ( [string] % b for b in bytes ) [EOL] return ( [ ( [string] , [string] ) ] , bytes_string ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from six import PY3 [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] testinput = request . POST . first ( [string] ) [EOL] if PY3 : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] testinput . value = isomorphic_decode ( testinput . value ) [EOL] return ( [ ( [string] , [string] ) ] , [string] + str ( testinput ) + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] if request . headers . get ( [string] ) == [string] : [EOL] result = request . body == [string] [EOL] elif request . headers . get ( [string] ) == [string] : [EOL] result = request . body == [string] [EOL] else : [EOL] result = request . POST . first ( [string] ) == [string] [EOL] [EOL] result = result and request . url_parts . query == [string] [EOL] [EOL] return ( [ ( [string] , [string] ) ] , [string] if result else [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [number] , [ ( [string] , [string] ) ] , [string] * [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] coop = request . GET . first ( [string] ) [EOL] coep = request . GET . first ( [string] ) [EOL] sandbox = request . GET . first ( [string] ) [EOL] if coop != [string] : [EOL] response . headers . set ( [string] , coop ) [EOL] if coep != [string] : [EOL] response . headers . set ( [string] , coep ) [EOL] response . headers . set ( [string] , [string] + sandbox + [string] ) [EOL] [EOL] [comment] [EOL] response . content = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] coop = request . GET . first ( [string] ) [EOL] coopReportOnly = request . GET . first ( [string] , None ) [EOL] coep = request . GET . first ( [string] ) [EOL] coepReportOnly = request . GET . first ( [string] , None ) [EOL] redirect = request . GET . first ( [string] , None ) [EOL] if coop != [string] : [EOL] response . headers . set ( [string] , coop ) [EOL] if coopReportOnly is not None : [EOL] response . headers . set ( [string] , coopReportOnly ) [EOL] if coep != [string] : [EOL] response . headers . set ( [string] , coep ) [EOL] if coepReportOnly is not None : [EOL] response . headers . set ( [string] , coepReportOnly ) [EOL] if [string] in request . GET : [EOL] response . headers . set ( [string] , [string] ) [EOL] host = request . url_parts [ [number] ] [EOL] [EOL] if redirect != None : [EOL] response . status = [number] [EOL] response . headers . set ( [string] , redirect ) [EOL] return [EOL] [EOL] [comment] [EOL] response . content = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] script = [string] [EOL] [EOL] def main ( request , response ) : [EOL] type = request . GET [ [string] ] [EOL] if request . GET [ [string] ] == [string] : [EOL] return [number] , [ ( [string] , [string] ) ] , [string] [EOL] return [ ( [string] , [string] ) ] , script % type [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] def main ( request , response ) : [EOL] type = request . GET [ [string] ] [EOL] if request . GET [ [string] ] == [string] : [EOL] return [number] , [ ( [string] , [string] ) ] , [string] [EOL] return [ ( [string] , [string] ) ] , type [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] script = [string] [EOL] [EOL] def main ( request , response ) : [EOL] type = request . GET [ [string] ] [EOL] if request . GET [ [string] ] == [string] : [EOL] return [number] , [ ( [string] , [string] ) ] , [string] [EOL] return [ ( [string] , [string] ) ] , script % type [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] script = [string] [EOL] [EOL] def main ( request , response ) : [EOL] type = request . GET [ [string] ] [EOL] if request . GET [ [string] ] == [string] : [EOL] return [number] , [ ( [string] , [string] ) ] , [string] [EOL] return [ ( [string] , [string] ) ] , script % type [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] def main ( request , response ) : [EOL] type = request . GET [ [string] ] [EOL] if request . GET [ [string] ] == [string] : [EOL] return [number] , [ ( [string] , [string] ) ] , [string] [EOL] return [ ( [string] , [string] ) ] , type [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] location = request . GET . first ( [string] ) [EOL] response . status = [number] [EOL] response . headers . set ( [string] , location ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [comment] [EOL] response . content = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os . path [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] [EOL] key = request . GET [ [string] ] [EOL] alreadyServedRequest = False [EOL] try : [EOL] alreadyServedRequest = request . server . stash . take ( key ) [EOL] except ( KeyError , ValueError ) as e : [EOL] pass [EOL] [EOL] if alreadyServedRequest : [EOL] body = open ( os . path . join ( os . path . dirname ( isomorphic_decode ( __file__ ) ) , [string] ) , [string] ) . read ( ) [EOL] else : [EOL] request . server . stash . put ( key , True ) ; [EOL] body = open ( os . path . join ( os . path . dirname ( isomorphic_decode ( __file__ ) ) , [string] ) , [string] ) . read ( ) [EOL] pass [EOL] [EOL] response . writer . write_status ( [number] ) [EOL] response . writer . write_header ( [string] , [string] ) [EOL] response . writer . write_header ( [string] , len ( body ) ) [EOL] response . writer . write_header ( [string] , [string] ) [EOL] response . writer . write_header ( [string] , [string] ) [EOL] response . writer . end_headers ( ) [EOL] [EOL] response . writer . write ( body ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [ ( [string] , [string] % ( request . GET [ [string] ] ) ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] encoding = request . GET [ [string] ] [EOL] tmpl = request . GET [ [string] ] [EOL] sheet = isomorphic_decode ( tmpl ) % [string] [EOL] return [ ( [string] , [string] % encoding ) ] , sheet . encode ( isomorphic_decode ( encoding ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] CertChainMimeType = [string] [EOL] [EOL] if request . headers . get ( [string] ) != CertChainMimeType : [EOL] return [number] , [ ] , [string] [EOL] [EOL] path = os . path . join ( os . path . dirname ( isomorphic_decode ( __file__ ) ) , [string] ) [EOL] body = open ( path , [string] ) . read ( ) [EOL] return [number] , [ ( [string] , CertChainMimeType ) ] , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] status = int ( request . GET [ [string] ] ) [EOL] module = [string] [EOL] return status , [ ( [string] , [string] ) ] , module [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) , ( [string] , request . headers . get ( [string] ) ) , ( [string] , request . headers . get ( [string] ) ) , ( [string] , [string] ) ] [EOL] [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] def main ( request , response ) : [EOL] return [number] , [ ( [string] , request . headers [ [string] ] ) ] , request . body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [string] if request . POST [ [string] ] . file . read ( ) == [string] else [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from tests . support . inline import inline [EOL] [EOL] def test_load ( session ) : [EOL] inline ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] import sys [EOL] [comment] [EOL] wdpath = os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] sys . path . insert ( [number] , wdpath ) [EOL] from tests . conftest import * [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] request . ws_extension_processors = [ ] [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from mod_pywebsocket import msgutil [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] referrer = request . headers_in . get ( [string] ) [EOL] if referrer is None : [EOL] referrer = [string] [EOL] msgutil . send_message ( request , referrer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from mod_pywebsocket import msgutil , util [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [comment] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] msgutil . send_message ( request , request . unparsed_uri . split ( [string] , [number] ) [ [number] ] or [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from mod_pywebsocket import msgutil [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [comment] [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] msgutil . send_message ( request , request . ws_origin ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from mod_pywebsocket import msgutil , util [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] line = request . headers_in . get ( [string] ) [EOL] request . ws_protocol = line . split ( [string] , [number] ) [ [number] ] [EOL] [EOL] [comment] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] while True : [EOL] msgutil . send_message ( request , request . ws_protocol ) [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from mod_pywebsocket import msgutil [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] request . ws_cookie = request . headers_in . get ( [string] ) [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] if request . ws_cookie is not None : [EOL] msgutil . send_message ( request , request . ws_cookie ) [EOL] else : [EOL] msgutil . send_message ( request , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from mod_pywebsocket import msgutil , util [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] while True : [EOL] msgutil . send_message ( request , request . unparsed_uri . split ( [string] ) [ [number] ] or [string] ) [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import six [EOL] import time [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] MESSAGE_SIZE = [number] * [number] * [number] [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] [comment] [EOL] [comment] [EOL] request . ws_extension_processors = [ ] [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] [comment] [EOL] request . ws_stream . send_message ( [string] , binary = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] start_time = time . time ( ) [EOL] [EOL] [comment] [EOL] request . ws_stream . send_message ( [string] * MESSAGE_SIZE , binary = True ) [EOL] [EOL] [comment] [EOL] request . ws_stream . send_message ( six . text_type ( time . time ( ) - start_time ) , binary = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] from six . moves import urllib [EOL] import json [EOL] from mod_pywebsocket import common , msgutil , util [EOL] from mod_pywebsocket . handshake import hybi [EOL] from wptserve import stash [EOL] [EOL] address , authkey = stash . load_env_config ( ) [EOL] stash = stash . Stash ( [string] , address = address , authkey = authkey ) [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] return [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] while True : [EOL] line = request . ws_stream . receive_message ( ) [EOL] if line == [string] : [EOL] query = request . unparsed_uri . split ( [string] ) [ [number] ] [EOL] GET = dict ( urllib . parse . parse_qsl ( query ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] path = GET . get ( [string] , request . unparsed_uri . split ( [string] ) [ [number] ] ) [EOL] key = GET [ [string] ] [EOL] action = GET [ [string] ] [EOL] [EOL] if action == [string] : [EOL] value = GET [ [string] ] [EOL] stash . take ( key = key , path = path ) [EOL] stash . put ( key = key , value = value , path = path ) [EOL] response_data = json . dumps ( { [string] : [string] , [string] : key } ) [EOL] elif action == [string] : [EOL] value = stash . take ( key = key , path = path ) [EOL] response_data = json . dumps ( { [string] : [string] , [string] : value } ) [EOL] elif action == [string] : [EOL] value = stash . take ( key = key , path = path ) [EOL] if value is None : [EOL] status = [string] [EOL] else : [EOL] status = [string] [EOL] response_data = json . dumps ( { [string] : status , [string] : value } ) [EOL] [EOL] msgutil . send_message ( request , response_data ) [EOL] [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] request . ws_protocol = [string] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] pass	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import urllib [EOL] import typing [EOL] from six . moves import urllib [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] url_parts = urllib . parse . urlsplit ( request . uri ) [EOL] max_age = [string] [EOL] if [string] in url_parts . query : [EOL] max_age = [string] [EOL] value = [string] [EOL] if [string] in url_parts . query : [EOL] value = urllib . parse . parse_qs ( url_parts . query ) [ [string] ] [ [number] ] [EOL] cookies = [ [string] . format ( value ) + max_age , [string] . format ( value ) + max_age , [string] . format ( value ) + max_age , [string] . format ( value ) + max_age ] [EOL] for cookie in cookies : [EOL] request . extra_headers . append ( ( [string] , cookie ) ) [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] [comment] [EOL] request . ws_stream . receive_message ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import six [EOL] from mod_pywebsocket import msgutil [EOL] [EOL] _GOODBYE_MESSAGE = [string] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] pass [comment] [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] while True : [EOL] line = request . ws_stream . receive_message ( ) [EOL] if line is None : [EOL] return [EOL] if isinstance ( line , six . text_type ) : [EOL] if line == _GOODBYE_MESSAGE : [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from mod_pywebsocket import msgutil [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [comment] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] while True : [EOL] line = msgutil . receive_message ( request ) [EOL] if line == [string] : [EOL] return [EOL] [EOL] if line is not None : [EOL] request . connection . write ( line ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] [comment] [EOL] request . ws_requested_protocols = None [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from mod_pywebsocket import msgutil [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] request . connection . write ( [string] ) [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import time [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] [comment] [EOL] request . ws_extension_processors = [ ] [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] [comment] [EOL] time . sleep ( [number] ) ; [EOL] request . ws_stream . receive_message ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import threading [EOL] import typing [EOL] import json [EOL] import threading [EOL] import wptserve . stash [EOL] from mod_pywebsocket import msgutil [EOL] [EOL] address , authkey = wptserve . stash . load_env_config ( ) [EOL] path = [string] [EOL] stash = wptserve . stash . Stash ( path , address = address , authkey = authkey ) [EOL] cv = threading . Condition ( ) [EOL] [EOL] def handle_set ( key , value ) : [EOL] with cv : [EOL] stash . put ( key , value ) [EOL] cv . notify_all ( ) [EOL] [EOL] def handle_get ( key ) : [EOL] with cv : [EOL] while True : [EOL] value = stash . take ( key ) [EOL] if value is not None : [EOL] return value [EOL] cv . wait ( ) [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] line = request . ws_stream . receive_message ( ) [EOL] [EOL] query = json . loads ( line ) [EOL] action = query [ [string] ] [EOL] key = query [ [string] ] [EOL] [EOL] if action == [string] : [EOL] value = query [ [string] ] [EOL] handle_set ( key , value ) [EOL] response = { } [EOL] elif action == [string] : [EOL] value = handle_get ( key ) [EOL] response = { [string] : value } [EOL] else : [EOL] response = { } [EOL] [EOL] msgutil . send_message ( request , json . dumps ( response ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $threading.Condition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Condition$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $threading.Condition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Condition$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Condition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from mod_pywebsocket import msgutil [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [comment] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] line = msgutil . receive_message ( request ) [EOL] if line == [string] : [EOL] msgutil . send_message ( request , [string] ) [EOL] else : [EOL] msgutil . send_message ( request , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from mod_pywebsocket import msgutil , util [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] request . ws_protocol = request . headers_in . get ( [string] ) [EOL] [comment] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] while True : [EOL] msgutil . send_message ( request , request . ws_protocol ) [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from mod_pywebsocket import msgutil [EOL] import time [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [string] if [string] in request . headers else [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , List , Dict [EOL] import io [EOL] import typing [EOL] import os [EOL] ccdir = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) [EOL] [comment] [EOL] invalid = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] . encode ( [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] . encode ( [string] ) , [string] : [string] , [string] : [string] . encode ( [string] ) , [string] : [string] , [string] : [string] . encode ( [string] ) , [string] : [string] , } [EOL] invalid_absolute = invalid . copy ( ) [EOL] [EOL] invalid_url_code_points = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] invalid . update ( invalid_url_code_points ) [EOL] invalid_absolute . update ( invalid_url_code_points ) [EOL] [EOL] valid_absolute = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] . encode ( [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] . encode ( [string] ) , [string] : [string] . encode ( [string] ) , [string] : [string] . encode ( [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] . encode ( [string] ) , [string] : [string] . encode ( [string] ) , [string] : [string] . encode ( [string] ) , [string] : [string] . encode ( [string] ) , [string] : [string] , } [EOL] valid = valid_absolute . copy ( ) [EOL] [EOL] valid_relative = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] . encode ( [string] ) , } [EOL] valid . update ( valid_relative ) [EOL] invalid_absolute . update ( valid_relative ) [EOL] [EOL] valid_relative_colon_dot = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] valid . update ( valid_relative_colon_dot ) [EOL] [EOL] invalid_file = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] invalid . update ( invalid_file ) [EOL] [EOL] valid_file = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] valid . update ( valid_file ) [EOL] valid_absolute . update ( valid_file ) [EOL] [EOL] warnings = { [string] : [string] , } [EOL] [EOL] element_attribute_pairs = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] template = [string] [EOL] [EOL] def write_novalid_files ( ) : [EOL] for el , attr in ( pair . split ( ) for pair in element_attribute_pairs ) : [EOL] for desc , url in invalid . items ( ) : [EOL] if ( [string] == el ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el or [string] == el ) : [EOL] f = open ( os . path . join ( ccdir , [string] % ( el , attr , desc ) ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % url ) [EOL] f . close ( ) [EOL] elif ( [string] == el and [string] == attr ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el and [string] == attr ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el and [string] == attr ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % url ) [EOL] f . close ( ) [EOL] elif ( [string] == el or [string] == el ) : [EOL] f = open ( os . path . join ( ccdir , [string] % ( el , attr , desc ) ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] else : [EOL] f = open ( os . path . join ( ccdir , [string] % ( el , attr , desc ) ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url , el ) ) [EOL] f . close ( ) [EOL] for desc , url in invalid . items ( ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % url ) [EOL] f . close ( ) [EOL] for desc , url in invalid_absolute . items ( ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % url ) [EOL] f . close ( ) [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % url ) [EOL] f . close ( ) [EOL] [EOL] def write_haswarn_files ( ) : [EOL] for el , attr in ( pair . split ( ) for pair in element_attribute_pairs ) : [EOL] for desc , url in warnings . items ( ) : [EOL] if ( [string] == el ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el or [string] == el ) : [EOL] f = open ( os . path . join ( ccdir , [string] % ( el , attr , desc ) ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el and [string] == attr ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el and [string] == attr ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el and [string] == attr ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] elif ( [string] == el or [string] == el ) : [EOL] f = open ( os . path . join ( ccdir , [string] % ( el , attr , desc ) ) , [string] ) [EOL] f . write ( template + [string] % ( attr , desc ) ) [EOL] f . write ( [string] % ( el , attr , url ) ) [EOL] f . close ( ) [EOL] else : [EOL] f = open ( os . path . join ( ccdir , [string] % ( el , attr , desc ) ) , [string] ) [EOL] f . write ( template + [string] % ( url , desc ) ) [EOL] f . write ( [string] % ( el , attr , url , el ) ) [EOL] f . close ( ) [EOL] for desc , url in warnings . items ( ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % url ) [EOL] f . close ( ) [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % url ) [EOL] f . close ( ) [EOL] [EOL] def write_isvalid_files ( ) : [EOL] for el , attr in ( pair . split ( ) for pair in element_attribute_pairs ) : [EOL] if ( [string] == el ) : [EOL] continue [EOL] if ( [string] == el ) : [EOL] continue [EOL] elif ( [string] == el and [string] == attr ) : [EOL] continue [EOL] elif ( [string] == el and [string] == attr ) : [EOL] fs = open ( os . path . join ( ccdir , [string] ) , [string] ) [EOL] fs . write ( template + [string] ) [EOL] fi = open ( os . path . join ( ccdir , [string] ) , [string] ) [EOL] fi . write ( template + [string] ) [EOL] elif ( [string] == el and [string] == attr ) : [EOL] f = open ( os . path . join ( ccdir , [string] ) , [string] ) [EOL] f . write ( template + [string] ) [EOL] else : [EOL] f = open ( os . path . join ( ccdir , [string] % ( el , attr ) ) , [string] ) [EOL] f . write ( template + [string] % attr ) [EOL] for desc , url in valid . items ( ) : [EOL] if ( [string] == el ) : [EOL] f . write ( [string] % ( el , attr , url , desc ) ) [EOL] elif ( [string] == el ) : [EOL] f . write ( [string] % ( el , attr , url , desc ) ) [EOL] elif ( [string] == el ) : [EOL] f . write ( [string] % ( el , attr , url , desc ) ) [EOL] elif ( [string] == el and [string] == attr ) : [EOL] f . write ( [string] % ( el , attr , url , desc ) ) [EOL] elif ( [string] == el and [string] == attr ) : [EOL] fs . write ( [string] % ( el , attr , url , desc ) ) [EOL] fi . write ( [string] % ( el , attr , url , desc ) ) [EOL] elif ( [string] == el ) : [EOL] f . write ( [string] % ( el , attr , url , desc ) ) [EOL] elif ( [string] == el or [string] == el ) : [EOL] f . write ( [string] % ( el , attr , url , desc ) ) [EOL] else : [EOL] f . write ( [string] % ( el , attr , url , el , desc ) ) [EOL] if ( [string] == el and [string] == attr ) : [EOL] fs . close ( ) [EOL] fi . close ( ) [EOL] else : [EOL] if ( [string] == el and [string] == attr ) : [EOL] f . write ( [string] ) [EOL] f . close ( ) [EOL] for desc , url in valid . items ( ) : [EOL] f = open ( os . path . join ( ccdir , [string] % desc ) , [string] ) [EOL] f . write ( template + [string] % desc ) [EOL] f . write ( [string] % url ) [EOL] f . close ( ) [EOL] f = open ( os . path . join ( ccdir , [string] ) , [string] ) [EOL] f . write ( template + [string] ) [EOL] for desc , url in valid . items ( ) : [EOL] f . write ( [string] % ( url , desc ) ) [EOL] f . close ( ) [EOL] f = open ( os . path . join ( ccdir , [string] ) , [string] ) [EOL] f . write ( template + [string] ) [EOL] for desc , url in valid . items ( ) : [EOL] f . write ( [string] % ( url , desc ) ) [EOL] f . close ( ) [EOL] f = open ( os . path . join ( ccdir , [string] ) , [string] ) [EOL] f . write ( template + [string] ) [EOL] for desc , url in valid_absolute . items ( ) : [EOL] f . write ( [string] % ( url , desc ) ) [EOL] f . close ( ) [EOL] f = open ( os . path . join ( ccdir , [string] ) , [string] ) [EOL] f . write ( template + [string] ) [EOL] for desc , url in valid_absolute . items ( ) : [EOL] f . write ( [string] % ( url , desc ) ) [EOL] f . close ( ) [EOL] [EOL] write_novalid_files ( ) [EOL] write_haswarn_files ( ) [EOL] write_isvalid_files ( ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import Callable , Any , List [EOL] import typing [EOL] import os [EOL] import urllib . parse [EOL] import hashlib [EOL] [EOL] doctmpl = [string] [EOL] [EOL] testobj = [string] [EOL] [EOL] def appendtest ( tests , input , expected ) : [EOL] tests . append ( testobj % ( hashlib . sha1 ( input . encode ( [string] ) ) . hexdigest ( ) , urllib . parse . quote ( input [ : - [number] ] ) , urllib . parse . quote ( expected [ : - [number] ] ) ) ) [EOL] [EOL] files = os . listdir ( [string] ) [EOL] for file in files : [EOL] if os . path . isdir ( [string] + file ) or file [ [number] ] == [string] : [EOL] continue [EOL] [EOL] tests = [ ] [EOL] input = [string] [EOL] expected = [string] [EOL] state = [string] [EOL] with open ( [string] + file , [string] ) as f : [EOL] while True : [EOL] line = f . readline ( ) [EOL] if not line : [EOL] if state != [string] : [EOL] appendtest ( tests , input , expected ) [EOL] input = [string] [EOL] expected = [string] [EOL] state = [string] [EOL] break [EOL] [EOL] if line [ [number] ] == [string] : [EOL] state = line [EOL] if line == [string] : [EOL] expected += bytes ( line , [string] ) . decode ( [string] ) [EOL] elif state == [string] : [EOL] input += bytes ( line , [string] ) . decode ( [string] ) [EOL] elif state == [string] : [EOL] pass [EOL] elif state == [string] : [EOL] if line == [string] : [EOL] appendtest ( tests , input , expected ) [EOL] input = [string] [EOL] expected = [string] [EOL] state = [string] [EOL] else : [EOL] expected += bytes ( line , [string] ) . decode ( [string] ) [EOL] else : [EOL] raise Exception ( [string] % ( file , line , state ) ) [EOL] [EOL] name = os . path . splitext ( file ) [ [number] ] [EOL] with open ( [string] + name + [string] , [string] ) as out : [EOL] out . write ( doctmpl % ( name , [string] . join ( tests ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 $builtins.str$ 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 $builtins.str$ 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0
from typing import Type , Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] type = request . GET . first ( [string] , None ) [EOL] subtype = request . GET . first ( [string] , None ) [EOL] if type and subtype : [EOL] response . headers [ [string] ] = type + [string] + subtype [EOL] [EOL] removeContentType = request . GET . first ( [string] , None ) [EOL] if removeContentType : [EOL] try : [EOL] del response . headers [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] [EOL] content = [string] [EOL] mimeHead = request . GET . first ( [string] , None ) [EOL] if mimeHead : [EOL] content += [string] % mimeHead [EOL] content += [string] [EOL] [EOL] return content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from six . moves . urllib . parse import unquote [EOL] [EOL] from wptserve . utils import isomorphic_decode , isomorphic_encode [EOL] [EOL] import sleep [EOL] [EOL] def main ( request , response ) : [EOL] index = isomorphic_encode ( request . request_path ) . index ( [string] ) [EOL] args = isomorphic_encode ( request . request_path [ index + [number] : ] ) . split ( [string] ) [EOL] headers = [ ] [EOL] statusSent = False [EOL] headersSent = False [EOL] for arg in args : [EOL] if arg . startswith ( [string] ) : [EOL] continue [EOL] elif arg . endswith ( [string] ) : [EOL] sleep . sleep_at_least ( float ( arg [ [number] : - [number] ] ) ) [EOL] elif arg . startswith ( [string] ) : [EOL] return ( [number] , [string] ) , [ ( [string] , unquote ( isomorphic_decode ( arg [ [number] : ] ) ) ) ] , [string] [EOL] [EOL] elif arg . startswith ( [string] ) : [EOL] headers . append ( ( [string] , unquote ( isomorphic_decode ( arg [ [number] : ] ) ) ) ) [EOL] [EOL] elif arg . startswith ( [string] ) : [EOL] text = unquote ( isomorphic_decode ( arg [ [number] : ] ) ) [EOL] [EOL] if not statusSent : [EOL] [comment] [EOL] response . writer . write_status ( [number] ) [EOL] statusSent = True [EOL] if not headersSent : [EOL] for key , value in headers : [EOL] response . writer . write_header ( key , value ) [EOL] response . writer . end_headers ( ) [EOL] headersSent = True [EOL] [EOL] response . writer . write_content ( text ) [EOL] elif arg . startswith ( [string] ) : [EOL] code = int ( unquote ( isomorphic_decode ( arg [ [number] : ] ) ) ) [EOL] response . writer . write_status ( code ) [EOL] if code // [number] == [number] : [EOL] [comment] [EOL] response . writer . end_headers ( ) [EOL] else : [EOL] statusSent = True [EOL] elif arg == [string] : [EOL] response . writer . flush ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] import timeit [EOL] [EOL] [comment] [EOL] [comment] [EOL] sleep_padding = [number] [EOL] [EOL] def sleep_at_least ( sleep_in_ms ) : [EOL] sleep_until = timeit . default_timer ( ) + ( sleep_in_ms / [number] ) [EOL] time . sleep ( ( sleep_in_ms + sleep_padding ) / [number] ) [EOL] [comment] [EOL] while timeit . default_timer ( ) < sleep_until : [EOL] time . sleep ( sleep_padding / [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0
def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] status = request . GET . first ( [string] ) [EOL] response . status = ( status , [string] ) ; [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] response . status = [number] [EOL] location = request . GET . first ( [string] ) [EOL] response . headers . set ( [string] , location ) [EOL] response . headers . set ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] [EOL] def main ( request , response ) : [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] return [ ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] [EOL] _LOCK_KEY = [string] [EOL] _TIMEOUT = [number] [comment] [EOL] [EOL] def wait_for_lock ( request ) : [EOL] t0 = time . time ( ) [EOL] while time . time ( ) - t0 < _TIMEOUT : [EOL] time . sleep ( [number] ) [EOL] value = request . server . stash . take ( key = _LOCK_KEY ) [EOL] if value is None : [EOL] return True [EOL] return False [EOL] [EOL] def lock ( request , report_id ) : [EOL] with request . server . stash . lock : [EOL] [comment] [EOL] if not wait_for_lock ( request ) : [EOL] return ( [number] , [ ] , [string] ) [EOL] request . server . stash . put ( key = _LOCK_KEY , value = report_id ) [EOL] return [string] % report_id [EOL] [EOL] def unlock ( request , report_id ) : [EOL] with request . server . stash . lock : [EOL] lock_holder = request . server . stash . take ( key = _LOCK_KEY ) [EOL] if lock_holder != report_id : [EOL] [comment] [EOL] request . server . stash . put ( key = _LOCK_KEY , value = lock_holder ) [EOL] return ( [number] , [ ] , [string] % lock_holder ) [EOL] return [string] % report_id [EOL] [EOL] def main ( request , response ) : [EOL] op = request . GET . first ( [string] ) [EOL] report_id = request . GET . first ( [string] ) [EOL] if op == [string] : [EOL] return lock ( request , report_id ) [EOL] elif op == [string] : [EOL] return unlock ( request , report_id ) [EOL] else : [EOL] return ( [number] , [ ] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] def main ( request , response ) : [EOL] return [number] , [ ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return ( [ ( [string] , [string] ) ] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import json [EOL] import helpers [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] headers = helpers . setNoCacheAndCORSHeaders ( request , response ) [EOL] cookies = helpers . readCookies ( request ) [EOL] headers . append ( ( [string] , [string] ) ) [EOL] [EOL] tmpl = [string] [EOL] decoded_cookies = { isomorphic_decode ( key ) : isomorphic_decode ( val ) for key , val in cookies . items ( ) } [EOL] return headers , tmpl % json . dumps ( decoded_cookies ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from helpers import makeCookieHeader , readParameter , setNoCacheAndCORSHeaders [EOL] [EOL] from wptserve . utils import isomorphic_encode [EOL] [EOL] def main ( request , response ) : [EOL] [docstring] [EOL] headers = setNoCacheAndCORSHeaders ( request , response ) [EOL] value = isomorphic_encode ( request . url_parts . query ) [EOL] [EOL] headers . append ( makeCookieHeader ( [string] , value , { [string] : [string] , [string] : [string] } ) ) [EOL] headers . append ( makeCookieHeader ( [string] , value , { [string] : [string] } ) ) [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] if [string] in request . headers : [EOL] headers . append ( ( [string] , request . headers [ [string] ] ) ) [EOL] [EOL] values = [ ] [EOL] for key in request . cookies : [EOL] for value in request . cookies . get_list ( key ) : [EOL] values . append ( [string] % ( isomorphic_decode ( key ) , value ) ) [EOL] body = [string] % [string] . join ( values ) [EOL] return headers , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from helpers import makeCookieHeader , setNoCacheAndCORSHeaders [EOL] [EOL] from wptserve . utils import isomorphic_encode [EOL] [EOL] def main ( request , response ) : [EOL] [docstring] [EOL] headers = setNoCacheAndCORSHeaders ( request , response ) [EOL] value = isomorphic_encode ( request . url_parts . query ) [EOL] [EOL] headers . append ( ( [string] , [string] ) ) [EOL] headers . append ( makeCookieHeader ( [string] , value , { [string] : [string] , [string] : [string] } ) ) [EOL] headers . append ( makeCookieHeader ( [string] , value , { [string] : [string] , [string] : [string] } ) ) [EOL] [comment] [EOL] headers . append ( makeCookieHeader ( [string] , value , { [string] : [string] , [string] : [string] , [string] : [string] } ) ) [EOL] headers . append ( makeCookieHeader ( [string] , value , { [string] : [string] } ) ) [EOL] [EOL] document = [string] [EOL] [EOL] return headers , document [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from helpers import makeDropCookie , setNoCacheAndCORSHeaders [EOL] [EOL] def main ( request , response ) : [EOL] [docstring] [EOL] headers = setNoCacheAndCORSHeaders ( request , response ) [EOL] [EOL] [comment] [EOL] headers . append ( makeDropCookie ( [string] , False ) ) [EOL] headers . append ( makeDropCookie ( [string] , False ) ) [EOL] headers . append ( makeDropCookie ( [string] , False ) ) [EOL] headers . append ( makeDropCookie ( [string] , False ) ) [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] [docstring] [EOL] [EOL] if [string] in request . GET : [EOL] header = request . GET . first ( [string] ) [EOL] response . headers . set ( [string] , header ) [EOL] [EOL] response . headers . set ( [string] , [string] ) [EOL] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import json [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] message = { } [EOL] [EOL] header = request . headers . get ( [string] ) ; [EOL] message [ [string] ] = isomorphic_decode ( header ) if header else None [EOL] [EOL] header = request . headers . get ( [string] ) ; [EOL] message [ [string] ] = isomorphic_decode ( header ) if header else None [EOL] [EOL] header = request . headers . get ( [string] ) [EOL] message [ [string] ] = isomorphic_decode ( header ) if header else None [EOL] [EOL] second_level_iframe_code = [string] [EOL] if [string] in request . GET : [EOL] if [string] in request . GET and request . GET [ [string] ] != [string] : [EOL] second_level_iframe_code = [string] . format ( isomorphic_decode ( request . GET [ [string] ] ) ) [EOL] else : [EOL] second_level_iframe_code = [string] [EOL] [EOL] return [ ( [string] , [string] ) , ( [string] , [string] ) ] , [string] . format ( json . dumps ( message ) , second_level_iframe_code , str ( request . headers ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , request . GET [ [string] ] ) ) [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , request . GET [ [string] ] ) ) [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , request . GET [ [string] ] ) ) [EOL] message = request . GET [ [string] ] [EOL] return headers , [string] % (message) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] policy = request . GET . first ( [string] ) [EOL] return [ ( [string] , [string] ) , ( [string] , policy ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import re [EOL] [EOL] from wptserve . utils import isomorphic_encode [EOL] [EOL] def main ( request , response ) : [EOL] response . status = [number] [EOL] location = re . sub ( [string] , [string] , isomorphic_encode ( request . url ) ) [EOL] response . headers . set ( [string] , location ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ] [EOL] if request . GET . first ( [string] , None ) : [EOL] headers . append ( ( [string] , request . GET [ [string] ] ) ) [EOL] [EOL] csp_header = [string] \ [EOL] if request . GET . first ( [string] , None ) == [string] else [string] [EOL] headers . append ( ( csp_header , [string] + request . GET [ [string] ] ) ) [EOL] [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] policy = request . GET . first ( [string] ) [EOL] return [ ( [string] , [string] ) , ( [string] , policy ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ] [EOL] headers . append ( ( [string] , [string] ) ) [EOL] [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] import time [EOL] def main ( request , response ) : [EOL] time . sleep ( [number] ) [EOL] headers = [ ( [string] , [string] ) ] [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . status = [number] [EOL] if [string] in request . GET : [EOL] response . headers . set ( [string] , request . GET [ [string] ] ) [EOL] else : [EOL] response . headers . set ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] if request . headers . get ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] response . status = [number] [EOL] headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] return headers , [string] [EOL] else : [EOL] headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] return headers , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import os [EOL] import subprocess [EOL] import time [EOL] import sys [EOL] from six . moves import urllib [EOL] [EOL] [EOL] class WPTServer ( object ) : [EOL] def __init__ ( self , wpt_root ) : [EOL] self . wpt_root = wpt_root [EOL] [EOL] [comment] [EOL] sys . path . insert ( [number] , os . path . join ( wpt_root , [string] ) ) [EOL] from serve . serve import build_config [EOL] with build_config ( ) as config : [EOL] self . host = config [ [string] ] [EOL] self . http_port = config [ [string] ] [ [string] ] [ [number] ] [EOL] self . https_port = config [ [string] ] [ [string] ] [ [number] ] [EOL] [EOL] self . base_url = [string] % ( self . host , self . http_port ) [EOL] self . https_base_url = [string] % ( self . host , self . https_port ) [EOL] [EOL] def start ( self ) : [EOL] self . devnull = open ( os . devnull , [string] ) [EOL] wptserve_cmd = [ os . path . join ( self . wpt_root , [string] ) , [string] ] [EOL] logging . info ( [string] % [string] . join ( wptserve_cmd ) ) [EOL] self . proc = subprocess . Popen ( wptserve_cmd , stderr = self . devnull , cwd = self . wpt_root ) [EOL] [EOL] for retry in range ( [number] ) : [EOL] [comment] [EOL] time . sleep ( [number] ** retry ) [EOL] exit_code = self . proc . poll ( ) [EOL] if exit_code != None : [EOL] logging . warn ( [string] , [string] . join ( wptserve_cmd ) , exit_code ) [EOL] break [EOL] try : [EOL] urllib . request . urlopen ( self . base_url , timeout = [number] ) [EOL] return [EOL] except urllib . error . URLError : [EOL] pass [EOL] [EOL] raise Exception ( [string] % self . base_url ) [EOL] [EOL] def stop ( self ) : [EOL] self . proc . terminate ( ) [EOL] self . proc . wait ( ) [EOL] self . devnull . close ( ) [EOL] [EOL] def url ( self , abs_path ) : [EOL] return self . https_base_url + [string] + os . path . relpath ( abs_path , self . wpt_root ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Literal , Dict , List , Tuple , Any [EOL] import typing_extensions [EOL] import typing [EOL] import copy [EOL] import json [EOL] import os [EOL] import ssl [EOL] import sys [EOL] import subprocess [EOL] [EOL] import html5lib [EOL] import py [EOL] import pytest [EOL] from six import text_type [EOL] from six . moves import urllib [EOL] [EOL] from wptserver import WPTServer [EOL] [EOL] HERE = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] WPT_ROOT = os . path . normpath ( os . path . join ( HERE , [string] , [string] ) ) [EOL] HARNESS = os . path . join ( HERE , [string] ) [EOL] TEST_TYPES = ( [string] , [string] ) [EOL] DEFAULT_VARIANTS = [ [string] ] [EOL] [EOL] sys . path . insert ( [number] , os . path . normpath ( os . path . join ( WPT_ROOT , [string] , [string] ) ) ) [EOL] import webdriver [EOL] [EOL] [EOL] def pytest_addoption ( parser ) : [EOL] parser . addoption ( [string] , action = [string] , default = None , help = [string] ) [EOL] [EOL] [EOL] def pytest_collect_file ( path , parent ) : [EOL] if path . ext . lower ( ) != [string] : [EOL] return [EOL] [EOL] [comment] [EOL] test_type = os . path . relpath ( str ( path ) , HERE ) [EOL] if os . path . sep not in test_type or [string] in test_type : [EOL] [comment] [EOL] return [EOL] test_type = test_type . split ( os . path . sep ) [ [number] ] [EOL] [EOL] return HTMLItem ( str ( path ) , test_type , parent ) [EOL] [EOL] [EOL] def pytest_configure ( config ) : [EOL] config . proc = subprocess . Popen ( [ [string] ] ) [EOL] config . add_cleanup ( config . proc . kill ) [EOL] [EOL] capabilities = { [string] : { [string] : True } } [EOL] if config . getoption ( [string] ) : [EOL] capabilities [ [string] ] [ [string] ] = { [string] : config . getoption ( [string] ) } [EOL] [EOL] config . driver = webdriver . Session ( [string] , [number] , capabilities = capabilities ) [EOL] config . add_cleanup ( config . driver . end ) [EOL] [EOL] config . server = WPTServer ( WPT_ROOT ) [EOL] config . server . start ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] config . ssl_context = ssl . _create_unverified_context ( ) [EOL] config . add_cleanup ( config . server . stop ) [EOL] [EOL] [EOL] def resolve_uri ( context , uri ) : [EOL] if uri . startswith ( [string] ) : [EOL] base = WPT_ROOT [EOL] path = uri [ [number] : ] [EOL] else : [EOL] base = os . path . dirname ( context ) [EOL] path = uri [EOL] [EOL] return os . path . exists ( os . path . join ( base , path ) ) [EOL] [EOL] [EOL] class HTMLItem ( pytest . Item , pytest . Collector ) : [EOL] def __init__ ( self , filename , test_type , parent ) : [EOL] self . url = parent . session . config . server . url ( filename ) [EOL] self . type = test_type [EOL] self . variants = [ ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] handle = urllib . request . urlopen ( self . url , context = parent . session . config . ssl_context ) [EOL] try : [EOL] markup = handle . read ( ) [EOL] finally : [EOL] handle . close ( ) [EOL] [EOL] if test_type not in TEST_TYPES : [EOL] raise ValueError ( [string] % test_type ) [EOL] [EOL] parsed = html5lib . parse ( markup , namespaceHTMLElements = False ) [EOL] name = None [EOL] includes_variants_script = False [EOL] self . expected = None [EOL] [EOL] for element in parsed . getiterator ( ) : [EOL] if not name and element . tag == [string] : [EOL] name = element . text [EOL] continue [EOL] if element . tag == [string] and element . attrib . get ( [string] ) == [string] : [EOL] self . variants . append ( element . attrib . get ( [string] ) ) [EOL] continue [EOL] if element . tag == [string] : [EOL] if element . attrib . get ( [string] ) == [string] : [EOL] self . expected = json . loads ( text_type ( element . text ) ) [EOL] [EOL] src = element . attrib . get ( [string] , [string] ) [EOL] [EOL] if [string] in src : [EOL] includes_variants_script = True [EOL] if not resolve_uri ( filename , src ) : [EOL] raise ValueError ( [string] % ( src , filename ) ) [EOL] [EOL] if not name : [EOL] raise ValueError ( [string] % filename ) [EOL] elif self . type == [string] : [EOL] if not self . expected : [EOL] raise ValueError ( [string] ) [EOL] if not includes_variants_script : [EOL] raise ValueError ( [string] [string] % filename ) [EOL] if len ( self . variants ) == [number] : [EOL] self . variants = DEFAULT_VARIANTS [EOL] elif self . type == [string] and self . expected : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pytest . Item . __init__ ( self , name , parent ) [EOL] pytest . Collector . __init__ ( self , name , parent , fspath = py . path . local ( filename ) ) [EOL] [EOL] [EOL] def reportinfo ( self ) : [EOL] return self . fspath , None , self . url [EOL] [EOL] def repr_failure ( self , excinfo ) : [EOL] return pytest . Collector . repr_failure ( self , excinfo ) [EOL] [EOL] def runtest ( self ) : [EOL] if self . type == [string] : [EOL] self . _run_unit_test ( ) [EOL] elif self . type == [string] : [EOL] self . _run_functional_test ( ) [EOL] else : [EOL] raise NotImplementedError [EOL] [EOL] def _run_unit_test ( self ) : [EOL] driver = self . session . config . driver [EOL] server = self . session . config . server [EOL] [EOL] driver . url = server . url ( HARNESS ) [EOL] [EOL] actual = driver . execute_async_script ( [string] % self . url ) [EOL] [EOL] summarized = self . _summarize ( copy . deepcopy ( actual ) ) [EOL] [EOL] print ( json . dumps ( summarized , indent = [number] ) ) [EOL] [EOL] assert summarized [ [string] ] [ [string] ] == [string] , summarized [ [string] ] [ [string] ] [EOL] for test in summarized [ [string] ] : [EOL] msg = [string] % ( test [ [string] ] , test [ [string] ] ) [EOL] assert test [ [string] ] == [string] , msg [EOL] [EOL] def _run_functional_test ( self ) : [EOL] for variant in self . variants : [EOL] self . _run_functional_test_variant ( variant ) [EOL] [EOL] def _run_functional_test_variant ( self , variant ) : [EOL] driver = self . session . config . driver [EOL] server = self . session . config . server [EOL] [EOL] driver . url = server . url ( HARNESS ) [EOL] [EOL] test_url = self . url + variant [EOL] actual = driver . execute_async_script ( [string] % test_url ) [EOL] [EOL] summarized = self . _summarize ( copy . deepcopy ( actual ) ) [EOL] [EOL] print ( json . dumps ( summarized , indent = [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] indices = [ test_obj . get ( [string] ) for test_obj in actual [ [string] ] ] [EOL] self . _assert_sequence ( indices ) [EOL] [EOL] self . expected [ [string] ] . sort ( key = lambda test_obj : test_obj . get ( [string] ) ) [EOL] [EOL] assert summarized == self . expected [EOL] [EOL] def _summarize ( self , actual ) : [EOL] summarized = { } [EOL] [EOL] summarized [ [string] ] = self . _summarize_status ( actual [ [string] ] ) [EOL] summarized [ [string] ] = [ self . _summarize_test ( test ) for test in actual [ [string] ] ] [EOL] summarized [ [string] ] . sort ( key = lambda test_obj : test_obj . get ( [string] ) ) [EOL] summarized [ [string] ] = actual [ [string] ] [EOL] [EOL] return summarized [EOL] [EOL] @ staticmethod def _assert_sequence ( nums ) : [EOL] if nums and len ( nums ) > [number] : [EOL] assert nums == list ( range ( [number] , nums [ - [number] ] + [number] ) ) [EOL] [EOL] @ staticmethod def _scrub_stack ( test_obj ) : [EOL] copy = dict ( test_obj ) [EOL] del copy [ [string] ] [EOL] return copy [EOL] [EOL] @ staticmethod def _expand_status ( status_obj ) : [EOL] for key , value in [ item for item in status_obj . items ( ) ] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if key != key . upper ( ) or not isinstance ( value , int ) : [EOL] continue [EOL] [EOL] del status_obj [ key ] [EOL] [EOL] if status_obj [ [string] ] == value : [EOL] status_obj [ [string] ] = key [EOL] [EOL] del status_obj [ [string] ] [EOL] [EOL] return status_obj [EOL] [EOL] @ staticmethod def _summarize_test ( test_obj ) : [EOL] del test_obj [ [string] ] [EOL] [EOL] assert [string] in test_obj [EOL] assert [string] in test_obj [EOL] assert [string] in test_obj [ [string] ] [EOL] assert test_obj [ [string] ] == test_obj [ [string] ] [ [string] ] [EOL] del test_obj [ [string] ] [EOL] del test_obj [ [string] ] [EOL] [EOL] return HTMLItem . _expand_status ( HTMLItem . _scrub_stack ( test_obj ) ) [EOL] [EOL] @ staticmethod def _summarize_status ( status_obj ) : [EOL] return HTMLItem . _expand_status ( HTMLItem . _scrub_stack ( status_obj ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] [docstring] [EOL] header = request . GET . first ( [string] ) [EOL] [EOL] response . headers . set ( [string] , header ) [EOL] response . headers . set ( [string] , [string] ) [EOL] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] content = [string] [EOL] [EOL] return headers , content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] return ( ( ( [string] , [string] ) , ) , [string] . format ( isomorphic_decode ( request . GET . first ( [string] ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] content = [string] [EOL] [EOL] return headers , content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] content = [string] [EOL] if [string] in request . GET : [EOL] val = request . GET . first ( [string] ) [EOL] response . headers . set ( [string] , val ) [EOL] return content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [ ( [string] , [string] ) ] , request . headers . get ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] [EOL] def main ( request , response ) : [EOL] delay = float ( request . GET . first ( [string] , [number] ) ) [EOL] time . sleep ( delay / [number] ) [EOL] [EOL] return [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] from six import int2byte [EOL] [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] [comment] [EOL] content = int2byte ( [number] ) + int2byte ( [number] ) + int2byte ( [number] ) + int2byte ( [number] ) + int2byte ( [number] ) + int2byte ( [number] ) [EOL] [EOL] return headers , content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] from six import int2byte [EOL] [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] content = [string] + int2byte ( [number] ) + [string] [EOL] [EOL] return headers , content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] if [string] in request . GET : [EOL] return request . url [EOL] else : [EOL] return request . request_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def main ( request , response ) : [EOL] content = request . method [EOL] [EOL] response . add_required_headers = False [EOL] response . writer . write ( [string] . format ( len ( content ) , content ) ) [EOL] response . writer . flush ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] from six import int2byte [EOL] [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] content = int2byte ( [number] ) [EOL] [EOL] return headers , content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] content = [string] [EOL] [EOL] return headers , content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] def main ( request , response ) : [EOL] chunks = [ [string] , [string] , [string] , [string] , ] [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] response . write_status_headers ( ) [EOL] [EOL] for value in chunks : [EOL] response . writer . write ( [string] % len ( value ) ) [EOL] response . writer . write ( value ) [EOL] response . writer . write ( [string] ) [EOL] response . writer . write ( [string] ) [EOL] response . writer . write ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [string] % ( request . POST . first ( [string] ) , request . POST . first ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import time [EOL] [EOL] from wptserve . utils import isomorphic_encode [EOL] [EOL] def main ( request , response ) : [EOL] code = int ( request . GET . first ( [string] , [number] ) ) [EOL] location = request . GET . first ( [string] , isomorphic_encode ( request . url_parts . path + [string] ) ) [EOL] [EOL] if [string] in request . GET : [EOL] delay = float ( request . GET . first ( [string] ) ) [EOL] time . sleep ( delay / [number] ) [EOL] [EOL] if [string] in request . GET : [EOL] return [ ( [string] , [string] ) ] , [string] [EOL] else : [EOL] return ( code , [string] ) , [ ( [string] , location ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . append ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] . encode ( [string] ) ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , request . headers . get ( [string] ) ) [EOL] [EOL] response . content = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] [EOL] response . text = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [number] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] [EOL] if request . method == [string] : [EOL] if not request . headers . get ( [string] ) : [EOL] response . content = [string] [EOL] response . status = [number] [EOL] else : [EOL] if request . headers . get ( [string] ) : [EOL] response . content = [string] [EOL] else : [EOL] response . content = [string] [EOL] response . status = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] content = chr ( [number] ) [EOL] [EOL] return headers , content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] [EOL] response . content = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [ ( [string] , [string] ) , request . headers . get ( [string] , [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import _importlib_modulespec [EOL] import typing [EOL] import imp [EOL] import os [EOL] [EOL] from wptserve . utils import isomorphic_decode [EOL] [EOL] here = os . path . dirname ( os . path . abspath ( isomorphic_decode ( __file__ ) ) ) [EOL] [EOL] def main ( request , response ) : [EOL] auth = imp . load_source ( [string] , os . path . join ( here , [string] , [string] ) ) [EOL] return auth . main ( request , response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from wptserve . utils import isomorphic_decode [EOL] [EOL] def main ( request , response ) : [EOL] if request . auth . username == [string] and request . auth . password == [string] : [EOL] response . headers . set ( [string] , [string] ) [EOL] content = [string] [EOL] else : [EOL] response . status = [number] [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , [string] ) [EOL] content = [string] [EOL] [EOL] content += [string] % ( request . auth . username , request . auth . password ) [EOL] return content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import typing [EOL] from wptserve . utils import isomorphic_encode [EOL] [EOL] def main ( request , response ) : [EOL] response . headers . set ( [string] , request . headers . get ( [string] ) ) [EOL] response . headers . set ( [string] , [string] ) [EOL] [EOL] if request . method == [string] : [EOL] response . headers . set ( [string] , [string] ) [EOL] [EOL] if [string] in request . GET : [EOL] response . headers . set ( [string] , request . GET . first ( [string] ) ) [EOL] [EOL] response . headers . set ( [string] , isomorphic_encode ( request . method ) ) [EOL] [EOL] response . headers . set ( [string] , request . headers . get ( [string] , [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL] try : [EOL] code = int ( request . GET . first ( [string] , [number] ) ) [EOL] except ValueError : [EOL] code = [number] [EOL] [EOL] text = request . GET . first ( [string] , [string] ) [EOL] [EOL] if request . method == [string] and [string] in request . GET : [EOL] try : [EOL] code = int ( request . GET . first ( [string] ) ) [EOL] except KeyError : [EOL] pass [EOL] [EOL] status = code , text [EOL] [EOL] if [string] in request . GET : [EOL] response . headers . set ( [string] , request . GET . first ( [string] ) ) [EOL] [EOL] body = request . GET . first ( [string] , [string] ) [EOL] [EOL] return status , [ ] , body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] token = request . GET . first ( [string] ) [EOL] if request . server . stash . remove ( token ) is not None : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] referrer = request . headers . get ( [string] , [string] ) . split ( [string] ) [ [number] ] [EOL] referrer_policy = request . GET . first ( [string] ) [EOL] expected_referrer = request . GET . first ( [string] , [string] ) [EOL] response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] if referrer_policy == [string] or referrer_policy == [string] : [EOL] if referrer == expected_referrer : [EOL] return ( [number] , response_headers , [string] ) [EOL] return ( [number] , response_headers ) [EOL] [EOL] if referrer_policy == [string] : [EOL] if referrer == expected_referrer : [EOL] return ( [number] , response_headers , [string] ) [EOL] return ( [number] , response_headers ) [EOL] return ( [number] , response_headers ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Tuple , Dict [EOL] import typing [EOL] import random [EOL] import string [EOL] [EOL] from wptserve . utils import isomorphic_encode [EOL] [EOL] def id_token ( ) : [EOL] letters = string . ascii_lowercase [EOL] return [string] . join ( random . choice ( letters ) for i in range ( [number] ) ) [EOL] [EOL] def main ( request , response ) : [EOL] client_hint_headers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] client_hints_curr = { i : request . headers . get ( i ) for i in client_hint_headers } [EOL] [EOL] token = request . GET . first ( [string] , None ) [EOL] is_query = request . GET . first ( [string] , None ) is not None [EOL] with request . server . stash . lock : [EOL] stash = request . server . stash . take ( token ) [EOL] if stash != None : [EOL] ( value , client_hints_prev ) = stash [EOL] count = int ( value ) [EOL] else : [EOL] count = [number] [EOL] client_hints_prev = { } [EOL] [EOL] if is_query : [EOL] if count < [number] : [EOL] request . server . stash . put ( token , ( count , client_hints_curr ) ) [EOL] else : [EOL] count = count + [number] [EOL] request . server . stash . put ( token , ( count , client_hints_curr ) ) [EOL] [EOL] for header in client_hint_headers : [EOL] if client_hints_curr [ header ] is not None : [EOL] response . headers . set ( header + [string] , client_hints_curr [ header ] ) [EOL] if ( header in client_hints_prev ) and ( client_hints_prev [ header ] is not None ) : [EOL] response . headers . set ( header + [string] , client_hints_prev [ header ] ) [EOL] [EOL] if is_query : [EOL] headers = [ ( [string] , count ) ] [EOL] content = [string] [EOL] return [number] , headers , content [EOL] else : [EOL] unique_id = id_token ( ) [EOL] headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , isomorphic_encode ( unique_id ) ) ] [EOL] content = [string] . format ( unique_id ) [EOL] return [number] , headers , content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] [docstring] [EOL] [EOL] response . headers . append ( [string] , [string] ) [EOL] response . headers . append ( [string] , [string] ) [EOL] response . headers . append ( [string] , [string] ) [EOL] [EOL] if [string] in request . headers : [EOL] response . headers . set ( [string] , request . headers . get ( [string] ) ) [EOL] if [string] in request . headers : [EOL] response . headers . set ( [string] , request . headers . get ( [string] ) ) [EOL] if [string] in request . headers : [EOL] response . headers . set ( [string] , request . headers . get ( [string] ) ) [EOL] if [string] in request . headers : [EOL] response . headers . set ( [string] , request . headers . get ( [string] ) ) [EOL] if [string] in request . headers : [EOL] response . headers . set ( [string] , request . headers . get ( [string] ) ) [EOL] if [string] in request . headers : [EOL] response . headers . set ( [string] , request . headers . get ( [string] ) ) [EOL] if [string] in request . headers : [EOL] response . headers . set ( [string] , request . headers . get ( [string] ) ) [EOL] if [string] in request . headers : [EOL] response . headers . set ( [string] , request . headers . get ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def main ( request , response ) : [EOL] url = [string] [EOL] if [string] in request . GET : [EOL] url = request . GET [ [string] ] [EOL] return [number] , [ ( [string] , url ) , ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Set , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import fnmatch [EOL] import os [EOL] import sys [EOL] import generate [EOL] import logging [EOL] [EOL] UPDATE_TIP = [string] [string] [EOL] [EOL] [EOL] def main ( ) : [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] logging . info ( UPDATE_TIP ) [EOL] generated_files = set ( ) [EOL] [comment] [EOL] for generated_test in generate . GetGeneratedTests ( ) : [EOL] generated_files . add ( generated_test . path ) [EOL] try : [EOL] with open ( generated_test . path , [string] ) as f : [EOL] data = f . read ( ) . decode ( [string] ) [EOL] if data != generated_test . data : [EOL] logging . error ( [string] , generated_test . path ) [EOL] return - [number] [EOL] except IOError as e : [EOL] if e . errno == [number] : [EOL] logging . error ( [string] , generated_test . path , generated_test . template ) [EOL] return - [number] [EOL] [EOL] [comment] [EOL] previous_generated_files = set ( ) [EOL] current_path = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] for root , _ , filenames in os . walk ( current_path ) : [EOL] for filename in fnmatch . filter ( filenames , [string] ) : [EOL] previous_generated_files . add ( os . path . join ( root , filename ) ) [EOL] [EOL] if previous_generated_files != generated_files : [EOL] logging . error ( [string] ) [EOL] for test_path in previous_generated_files - generated_files : [EOL] logging . error ( [string] , test_path ) [EOL] return - [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return ( [number] , [string] ) , [ ( [string] , [string] ) ] , [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return ( [number] , [string] ) , [ ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return ( [number] , [string] ) , [ ( [string] , [string] ) ] , [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return ( [number] , [string] ) , [ ( [string] , [string] ) ] , [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return ( [number] , [string] ) , [ ( [string] , [string] ) ] , [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return ( [number] , [string] ) , [ ( [string] , [string] ) ] , [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] referrer = request . headers . get ( [string] , [string] ) [EOL] [EOL] response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] return ( [number] , response_headers , [string] + referrer + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] referrer = request . headers . get ( [string] , [string] ) [EOL] [EOL] response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] return ( [number] , response_headers , [string] + [string] + [string] + referrer + [string] + [string] + [string] + [string] + [string] + referrer + [string] + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [ ( [string] , request . GET [ [string] ] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [ ( [string] , [string] ) , ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] def main ( request , response ) : [EOL] return [string] if request . GET . first ( [string] ) . decode ( [string] ) == [string] else [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . status = [number] [EOL] response . headers . append ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . status = [number] [EOL] response . headers . set ( [string] , request . GET . first ( [string] ) ) [EOL] response . headers . set ( [string] , request . GET . first ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] headers = [ ( [string] , [string] ) , ( [string] , request . GET . first ( [string] ) ) ] [EOL] [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , request . GET . first ( [string] ) ) ) [EOL] [EOL] if [string] in request . GET : [EOL] headers . append ( ( [string] , request . GET . first ( [string] ) ) ) [EOL] [EOL] body = [string] [EOL] return ( headers , body ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import subprocess [EOL] import os [EOL] [EOL] here = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] def build ( * args , ** kwargs ) : [EOL] subprocess . check_call ( [ [string] , [string] ] , cwd = here ) [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import builtins [EOL] from typing import Callable , List , Dict , Tuple , Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] import localpaths [EOL] [EOL] [comment] [EOL] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [comment] [EOL] version = [string] [EOL] [comment] [EOL] release = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] nitpick_ignore = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] from docs . wpt_lint_rules import WPTLintRules [EOL] [comment] [EOL] [comment] [EOL] from recommonmark . transform import AutoStructify [EOL] def setup ( app ) : [EOL] app . add_transform ( AutoStructify ) [EOL] app . add_directive ( [string] , WPTLintRules ) [EOL] [EOL] [comment] [EOL] pygments_style = None [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( master_doc , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_title = project [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_exclude_files = [ [string] ] [EOL] [EOL] intersphinx_mapping = { [string] : ( [string] , None ) , [string] : ( [string] , None ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] import fontforge [EOL] [EOL] font = fontforge . font ( ) [EOL] font . em = [number] [EOL] typoLineHeight = [number] [EOL] winHeight = [number] [EOL] name = [string] % ( winHeight , typoLineHeight ) [EOL] font . fontname = name [EOL] font . familyname = name [EOL] font . fullname = name [EOL] font . copyright = [string] [EOL] [EOL] glyph = font . createChar ( ord ( [string] ) , [string] ) [EOL] glyph . width = [number] [EOL] glyph = font . createChar ( ord ( [string] ) ) [EOL] pen = glyph . glyphPen ( ) [EOL] pen . moveTo ( [number] , - [number] ) [EOL] pen . lineTo ( [number] , [number] ) [EOL] pen . lineTo ( [number] , [number] ) [EOL] pen . lineTo ( [number] , - [number] ) [EOL] pen . closePath ( ) ; [EOL] [EOL] font . os2_typoascent_add = False [EOL] font . os2_typoascent = [number] [EOL] font . os2_typodescent_add = False [EOL] font . os2_typodescent = - [number] [EOL] font . os2_typolinegap = typoLineHeight - ( font . os2_typoascent - font . os2_typodescent ) [EOL] [EOL] font . hhea_ascent = winHeight / [number] [EOL] font . hhea_ascent_add = False [EOL] font . hhea_descent = - winHeight / [number] [EOL] font . hhea_descent_add = False [EOL] font . hhea_linegap = [number] [EOL] [EOL] font . os2_winascent = winHeight / [number] [EOL] font . os2_winascent_add = False [EOL] font . os2_windescent = winHeight / [number] [EOL] font . os2_windescent_add = False [EOL] [EOL] font . os2_use_typo_metrics = True [EOL] [EOL] path = [string] % ( winHeight , typoLineHeight ) [EOL] print ( [string] % path , end = [string] ) [EOL] font . generate ( path ) [EOL] if font . validate ( ) == [number] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , List [EOL] import typing [EOL] def main ( request , response ) : [EOL] response_headers = [ ( [string] , [string] ) ] [EOL] body = [string] % request . headers . get ( [string] , [string] ) [EOL] return ( [number] , response_headers , body ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] [EOL] from typing import Any , Dict [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] import os [EOL] import sys [EOL] [EOL] _dir = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = str , default = os . path . join ( _dir , [string] , [string] ) , help = [string] , ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , type = str , default = os . path . join ( _dir , [string] , [string] ) , help = [string] , ) [EOL] parser . add_argument ( [string] , type = str , default = os . path . join ( _dir , [string] , [string] , [string] , [string] , [string] ) , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] def run ( venv , ** kwargs ) : [EOL] assert sys . version_info . major == [number] , [string] [EOL] logging . basicConfig ( format = [string] , level = logging . DEBUG if kwargs . get ( [string] ) else logging . INFO , ) [EOL] [EOL] [comment] [EOL] from . quic_transport_server import start [EOL] start ( kwargs ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] kwargs = vars ( get_parser ( ) . parse_args ( ) ) [EOL] return run ( None , ** kwargs ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] import os [EOL] [EOL] [EOL] def expected_path ( metadata_path , test_path ) : [EOL] [docstring] [EOL] args = list ( test_path . split ( [string] ) ) [EOL] args [ - [number] ] += [string] [EOL] return os . path . join ( metadata_path , * args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ctypes [EOL] import os [EOL] import platform [EOL] import plistlib [EOL] [EOL] from shutil import copy2 , rmtree [EOL] from subprocess import call , check_output [EOL] [EOL] HERE = os . path . dirname ( __file__ ) [EOL] SYSTEM = platform . system ( ) . lower ( ) [EOL] [EOL] [EOL] class FontInstaller ( object ) : [EOL] def __init__ ( self , logger , font_dir = None , ** fonts ) : [EOL] self . logger = logger [EOL] self . font_dir = font_dir [EOL] self . installed_fonts = False [EOL] self . created_dir = False [EOL] self . fonts = fonts [EOL] [EOL] def __call__ ( self , env_options = None , env_config = None ) : [EOL] return self [EOL] [EOL] def __enter__ ( self ) : [EOL] for _ , font_path in self . fonts . items ( ) : [EOL] font_name = font_path . split ( [string] ) [ - [number] ] [EOL] install = getattr ( self , [string] % SYSTEM , None ) [EOL] if not install : [EOL] self . logger . warning ( [string] % SYSTEM ) [EOL] return False [EOL] if install ( font_name , font_path ) : [EOL] self . installed_fonts = True [EOL] self . logger . info ( [string] % font_name ) [EOL] else : [EOL] self . logger . warning ( [string] % font_name ) [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] if not self . installed_fonts : [EOL] return False [EOL] [EOL] for _ , font_path in self . fonts . items ( ) : [EOL] font_name = font_path . split ( [string] ) [ - [number] ] [EOL] remove = getattr ( self , [string] % SYSTEM , None ) [EOL] if not remove : [EOL] self . logger . warning ( [string] % SYSTEM ) [EOL] return False [EOL] if remove ( font_name , font_path ) : [EOL] self . logger . info ( [string] % font_name ) [EOL] else : [EOL] self . logger . warning ( [string] % font_name ) [EOL] [EOL] def install_linux_font ( self , font_name , font_path ) : [EOL] if not self . font_dir : [EOL] self . font_dir = os . path . join ( os . path . expanduser ( [string] ) , [string] ) [EOL] if not os . path . exists ( self . font_dir ) : [EOL] os . makedirs ( self . font_dir ) [EOL] self . created_dir = True [EOL] if not os . path . exists ( os . path . join ( self . font_dir , font_name ) ) : [EOL] copy2 ( font_path , self . font_dir ) [EOL] try : [EOL] fc_cache_returncode = call ( [string] ) [EOL] return not fc_cache_returncode [EOL] except OSError : [comment] [EOL] self . logger . error ( [string] ) [EOL] return False [EOL] [EOL] def install_darwin_font ( self , font_name , font_path ) : [EOL] if not self . font_dir : [EOL] self . font_dir = os . path . join ( os . path . expanduser ( [string] ) , [string] ) [EOL] if not os . path . exists ( self . font_dir ) : [EOL] os . makedirs ( self . font_dir ) [EOL] self . created_dir = True [EOL] installed_font_path = os . path . join ( self . font_dir , font_name ) [EOL] if not os . path . exists ( installed_font_path ) : [EOL] copy2 ( font_path , self . font_dir ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] fonts = check_output ( [ [string] , [string] , [string] ] ) [EOL] try : [EOL] [comment] [EOL] readPlistFromBytes = plistlib . readPlistFromBytes [EOL] except AttributeError : [EOL] readPlistFromBytes = plistlib . readPlistFromString [EOL] fonts = readPlistFromBytes ( fonts ) [EOL] assert len ( fonts ) == [number] [EOL] for font in fonts [ [number] ] [ [string] ] : [EOL] if font [ [string] ] == installed_font_path : [EOL] return True [EOL] return False [EOL] [EOL] def install_windows_font ( self , _ , font_path ) : [EOL] hwnd_broadcast = [number] [EOL] wm_fontchange = [number] [EOL] [EOL] gdi32 = ctypes . WinDLL ( [string] ) [EOL] if gdi32 . AddFontResourceW ( font_path ) : [EOL] from ctypes import wintypes [EOL] wparam = [number] [EOL] lparam = [number] [EOL] SendNotifyMessageW = ctypes . windll . user32 . SendNotifyMessageW [EOL] SendNotifyMessageW . argtypes = [ wintypes . HANDLE , wintypes . UINT , wintypes . WPARAM , wintypes . LPARAM ] [EOL] return bool ( SendNotifyMessageW ( hwnd_broadcast , wm_fontchange , wparam , lparam ) ) [EOL] [EOL] def remove_linux_font ( self , font_name , _ ) : [EOL] if self . created_dir : [EOL] rmtree ( self . font_dir ) [EOL] else : [EOL] os . remove ( [string] % ( self . font_dir , font_name ) ) [EOL] try : [EOL] fc_cache_returncode = call ( [string] ) [EOL] return not fc_cache_returncode [EOL] except OSError : [comment] [EOL] self . logger . error ( [string] ) [EOL] return False [EOL] [EOL] def remove_darwin_font ( self , font_name , _ ) : [EOL] if self . created_dir : [EOL] rmtree ( self . font_dir ) [EOL] else : [EOL] os . remove ( os . path . join ( self . font_dir , font_name ) ) [EOL] return True [EOL] [EOL] def remove_windows_font ( self , _ , font_path ) : [EOL] hwnd_broadcast = [number] [EOL] wm_fontchange = [number] [EOL] [EOL] gdi32 = ctypes . WinDLL ( [string] ) [EOL] if gdi32 . RemoveFontResourceW ( font_path ) : [EOL] from ctypes import wintypes [EOL] wparam = [number] [EOL] lparam = [number] [EOL] SendNotifyMessageW = ctypes . windll . user32 . SendNotifyMessageW [EOL] SendNotifyMessageW . argtypes = [ wintypes . HANDLE , wintypes . UINT , wintypes . WPARAM , wintypes . LPARAM ] [EOL] return bool ( SendNotifyMessageW ( hwnd_broadcast , wm_fontchange , wparam , lparam ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0
	0
from typing import Union , Any , Dict [EOL] import typing [EOL] import os [EOL] [EOL] from . base import NullBrowser , ExecutorBrowser , require_arg [EOL] from . base import get_timeout_multiplier [comment] [EOL] from . . executors import executor_kwargs as base_executor_kwargs [EOL] from . . executors . executorservo import ( ServoCrashtestExecutor , ServoTestharnessExecutor , ServoRefTestExecutor , ServoWdspecExecutor ) [comment] [EOL] [EOL] here = os . path . dirname ( __file__ ) [EOL] [EOL] __wptrunner__ = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def check_args ( ** kwargs ) : [EOL] require_arg ( kwargs , [string] ) [EOL] [EOL] [EOL] def browser_kwargs ( test_type , run_info_data , config , ** kwargs ) : [EOL] return { [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : kwargs . get ( [string] ) , [string] : config . ssl_config [ [string] ] , } [EOL] [EOL] [EOL] def executor_kwargs ( test_type , server_config , cache_manager , run_info_data , ** kwargs ) : [EOL] rv = base_executor_kwargs ( test_type , server_config , cache_manager , run_info_data , ** kwargs ) [EOL] rv [ [string] ] = kwargs [ [string] ] [EOL] if test_type == [string] : [EOL] rv [ [string] ] = { } [EOL] rv [ [string] ] = kwargs [ [string] ] [EOL] return rv [EOL] [EOL] [EOL] def env_extras ( ** kwargs ) : [EOL] return [ ] [EOL] [EOL] [EOL] def env_options ( ) : [EOL] return { [string] : [string] , [string] : False , [string] : [string] , [string] : True } [EOL] [EOL] [EOL] def update_properties ( ) : [EOL] return [ [string] , [string] , [string] ] , { [string] : [ [string] ] , [string] : [ [string] ] } [EOL] [EOL] [EOL] class ServoBrowser ( NullBrowser ) : [EOL] def __init__ ( self , logger , binary , debug_info = None , binary_args = None , user_stylesheets = None , ca_certificate_path = None ) : [EOL] NullBrowser . __init__ ( self , logger ) [EOL] self . binary = binary [EOL] self . debug_info = debug_info [EOL] self . binary_args = binary_args or [ ] [EOL] self . user_stylesheets = user_stylesheets or [ ] [EOL] self . ca_certificate_path = ca_certificate_path [EOL] [EOL] def executor_browser ( self ) : [EOL] return ExecutorBrowser , { [string] : self . binary , [string] : self . debug_info , [string] : self . binary_args , [string] : self . user_stylesheets , [string] : self . ca_certificate_path , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from typing import List [EOL] import typing [EOL] WPT_FINGERPRINT = [string] [EOL] [EOL] [comment] [EOL] SXG_WPT_FINGERPRINT = [string] [EOL] [EOL] IGNORE_CERTIFICATE_ERRORS_SPKI_LIST = [ WPT_FINGERPRINT , SXG_WPT_FINGERPRINT ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] product_list = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List , Any , Dict [EOL] import typing [EOL] from . import chrome_spki_certs [EOL] from . base import Browser , ExecutorBrowser , require_arg [EOL] from . base import get_timeout_multiplier [comment] [EOL] from . . webdriver_server import ChromeDriverServer [EOL] from . . executors import executor_kwargs as base_executor_kwargs [EOL] from . . executors . executorwebdriver import ( WebDriverTestharnessExecutor , WebDriverRefTestExecutor , WebDriverCrashtestExecutor ) [comment] [EOL] from . . executors . executorchrome import ( ChromeDriverWdspecExecutor , ChromeDriverPrintRefTestExecutor ) [comment] [EOL] [EOL] [EOL] __wptrunner__ = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] def check_args ( ** kwargs ) : [EOL] require_arg ( kwargs , [string] ) [EOL] [EOL] [EOL] def browser_kwargs ( test_type , run_info_data , config , ** kwargs ) : [EOL] return { [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : kwargs . get ( [string] ) } [EOL] [EOL] [EOL] def executor_kwargs ( test_type , server_config , cache_manager , run_info_data , ** kwargs ) : [EOL] executor_kwargs = base_executor_kwargs ( test_type , server_config , cache_manager , run_info_data , ** kwargs ) [EOL] executor_kwargs [ [string] ] = True [EOL] executor_kwargs [ [string] ] = False [EOL] [EOL] capabilities = { [string] : { [string] : { [string] : { [string] : { [string] : [number] } } } , [string] : False , [string] : [ [string] ] , [string] : True } } [EOL] [EOL] if test_type == [string] : [EOL] capabilities [ [string] ] = [string] [EOL] [EOL] chrome_options = capabilities [ [string] ] [EOL] if kwargs [ [string] ] is not None : [EOL] chrome_options [ [string] ] = kwargs [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] chrome_options [ [string] ] = [ ] [EOL] [EOL] chrome_options [ [string] ] . append ( [string] ) [EOL] chrome_options [ [string] ] . append ( [string] % [string] . join ( chrome_spki_certs . IGNORE_CERTIFICATE_ERRORS_SPKI_LIST ) ) [EOL] [EOL] [comment] [EOL] chrome_options [ [string] ] . append ( [string] ) [EOL] [comment] [EOL] chrome_options [ [string] ] . append ( [string] ) [EOL] chrome_options [ [string] ] . append ( [string] ) [EOL] [comment] [EOL] chrome_options [ [string] ] . append ( [string] ) [EOL] [comment] [EOL] chrome_options [ [string] ] . append ( [string] ) [EOL] [EOL] if kwargs [ [string] ] : [EOL] chrome_options [ [string] ] . append ( [string] ) [EOL] [EOL] [comment] [EOL] if kwargs [ [string] ] is not None : [EOL] chrome_options [ [string] ] . extend ( kwargs [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( ( kwargs [ [string] ] or test_type == [string] ) and [string] not in chrome_options [ [string] ] ) : [EOL] chrome_options [ [string] ] . append ( [string] ) [EOL] [EOL] executor_kwargs [ [string] ] = capabilities [EOL] [EOL] return executor_kwargs [EOL] [EOL] [EOL] def env_extras ( ** kwargs ) : [EOL] return [ ] [EOL] [EOL] [EOL] def env_options ( ) : [EOL] return { [string] : [string] } [EOL] [EOL] [EOL] class ChromeBrowser ( Browser ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , logger , binary , webdriver_binary = [string] , webdriver_args = None ) : [EOL] [docstring] [EOL] Browser . __init__ ( self , logger ) [EOL] self . binary = binary [EOL] self . server = ChromeDriverServer ( self . logger , binary = webdriver_binary , args = webdriver_args ) [EOL] [EOL] def start ( self , ** kwargs ) : [EOL] self . server . start ( block = False ) [EOL] [EOL] def stop ( self , force = False ) : [EOL] self . server . stop ( force = force ) [EOL] [EOL] def pid ( self ) : [EOL] return self . server . pid [EOL] [EOL] def is_alive ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return self . server . is_alive ( ) [EOL] [EOL] def cleanup ( self ) : [EOL] self . stop ( ) [EOL] [EOL] def executor_browser ( self ) : [EOL] return ExecutorBrowser , { [string] : self . server . url } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict [EOL] import tests [EOL] import typing [EOL] import os [EOL] [EOL] import moznetwork [EOL] from mozrunner import FennecEmulatorRunner [EOL] [EOL] from . base import ( get_free_port , cmd_arg , browser_command ) [EOL] from . . executors . executormarionette import ( MarionetteTestharnessExecutor , MarionetteRefTestExecutor , MarionetteCrashtestExecutor ) [comment] [EOL] from . . process import cast_env [EOL] from . base import ( Browser , ExecutorBrowser ) [EOL] from . firefox import ( get_timeout_multiplier , run_info_extras as fx_run_info_extras , update_properties , executor_kwargs , ProfileCreator as FirefoxProfileCreator ) [EOL] [EOL] [EOL] __wptrunner__ = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def check_args ( ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] def browser_kwargs ( test_type , run_info_data , config , ** kwargs ) : [EOL] return { [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : test_type , [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : config . ssl_config [ [string] ] , [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : get_timeout_multiplier ( test_type , run_info_data , ** kwargs ) , [string] : run_info_data [ [string] ] , [string] : False , [string] : kwargs [ [string] ] , [string] : kwargs [ [string] ] , [string] : config , [string] : kwargs [ [string] ] , [string] : config . doc_root } [EOL] [EOL] [EOL] def env_extras ( ** kwargs ) : [EOL] return [ ] [EOL] [EOL] [EOL] def run_info_extras ( ** kwargs ) : [EOL] rv = fx_run_info_extras ( ** kwargs ) [EOL] package = kwargs [ [string] ] [EOL] rv . update ( { [string] : True if package is not None and [string] in package else False , [string] : False } ) [EOL] return rv [EOL] [EOL] [EOL] def env_options ( ) : [EOL] [comment] [EOL] [comment] [EOL] return { [string] : moznetwork . get_ip ( ) , [string] : False , [string] : True } [EOL] [EOL] [EOL] class ProfileCreator ( FirefoxProfileCreator ) : [EOL] def __init__ ( self , logger , prefs_root , config , test_type , extra_prefs , e10s , enable_fission , browser_channel , certutil_binary , ca_certificate_path ) : [EOL] super ( ProfileCreator , self ) . __init__ ( logger , prefs_root , config , test_type , extra_prefs , e10s , enable_fission , browser_channel , None , certutil_binary , ca_certificate_path ) [EOL] [EOL] def _set_required_prefs ( self , profile ) : [EOL] profile . set_preferences ( { [string] : [string] . join ( self . config . domains_set ) , [string] : False , [string] : False , [string] : True , [string] : True , } ) [EOL] [EOL] if self . e10s : [EOL] profile . set_preferences ( { [string] : True } ) [EOL] [EOL] if self . test_type == [string] : [EOL] self . logger . info ( [string] ) [EOL] profile . set_preferences ( { [string] : [number] , [string] : [string] , [string] : False , [string] : False , [string] : True , } ) [EOL] [EOL] [EOL] [EOL] class FirefoxAndroidBrowser ( Browser ) : [EOL] init_timeout = [number] [EOL] shutdown_timeout = [number] [EOL] [EOL] def __init__ ( self , logger , prefs_root , test_type , package_name = [string] , device_serial = [string] , extra_prefs = None , debug_info = None , symbols_path = None , stackwalk_binary = None , certutil_binary = None , ca_certificate_path = None , e10s = False , enable_webrender = False , stackfix_dir = None , binary_args = None , timeout_multiplier = None , leak_check = False , asan = False , stylo_threads = [number] , chaos_mode_flags = None , config = None , browser_channel = [string] , install_fonts = False , tests_root = None , ** kwargs ) : [EOL] [EOL] super ( FirefoxAndroidBrowser , self ) . __init__ ( logger ) [EOL] self . prefs_root = prefs_root [EOL] self . test_type = test_type [EOL] self . package_name = package_name [EOL] self . device_serial = device_serial [EOL] self . debug_info = debug_info [EOL] self . symbols_path = symbols_path [EOL] self . stackwalk_binary = stackwalk_binary [EOL] self . certutil_binary = certutil_binary [EOL] self . ca_certificate_path = ca_certificate_path [EOL] self . e10s = e10s [EOL] self . enable_webrender = enable_webrender [EOL] self . stackfix_dir = stackfix_dir [EOL] self . binary_args = binary_args [EOL] self . timeout_multiplier = timeout_multiplier [EOL] self . leak_check = leak_check [EOL] self . asan = asan [EOL] self . stylo_threads = stylo_threads [EOL] self . chaos_mode_flags = chaos_mode_flags [EOL] self . config = config [EOL] self . browser_channel = browser_channel [EOL] self . install_fonts = install_fonts [EOL] self . tests_root = tests_root [EOL] [EOL] self . profile_creator = ProfileCreator ( logger , prefs_root , config , test_type , extra_prefs , e10s , False , browser_channel , certutil_binary , ca_certificate_path ) [EOL] [EOL] self . marionette_port = None [EOL] self . profile = None [EOL] self . runner = None [EOL] [EOL] def settings ( self , test ) : [EOL] return { [string] : self . leak_check and not test . leaks , [string] : test . lsan_allowed , [string] : test . lsan_max_stack_depth , [string] : self . leak_check and test . mozleak_allowed , [string] : self . leak_check and test . mozleak_threshold } [EOL] [EOL] def start ( self , ** kwargs ) : [EOL] if self . marionette_port is None : [EOL] self . marionette_port = get_free_port ( ) [EOL] [EOL] self . profile = self . profile_creator . create ( ) [EOL] self . profile . set_preferences ( { [string] : self . marionette_port } ) [EOL] [EOL] if self . install_fonts : [EOL] self . logger . debug ( [string] ) [EOL] font_dir = os . path . join ( self . profile . profile , [string] ) [EOL] if not os . path . exists ( font_dir ) : [EOL] os . makedirs ( font_dir ) [EOL] with open ( os . path . join ( self . tests_root , [string] , [string] ) , [string] ) as src : [EOL] with open ( os . path . join ( font_dir , [string] ) , [string] ) as dest : [EOL] dest . write ( src . read ( ) ) [EOL] [EOL] self . leak_report_file = None [EOL] [EOL] debug_args , cmd = browser_command ( self . package_name , self . binary_args if self . binary_args else [ ] + [ cmd_arg ( [string] ) , [string] ] , self . debug_info ) [EOL] [EOL] env = { } [EOL] env [ [string] ] = [string] [EOL] env [ [string] ] = [string] [EOL] env [ [string] ] = [string] [EOL] env [ [string] ] = str ( self . stylo_threads ) [EOL] if self . chaos_mode_flags is not None : [EOL] env [ [string] ] = str ( self . chaos_mode_flags ) [EOL] if self . enable_webrender : [EOL] env [ [string] ] = [string] [EOL] else : [EOL] env [ [string] ] = [string] [EOL] [EOL] self . runner = FennecEmulatorRunner ( app = self . package_name , profile = self . profile , cmdargs = cmd [ [number] : ] , env = cast_env ( env ) , symbols_path = self . symbols_path , serial = self . device_serial , logdir = os . getcwd ( ) ) [EOL] [EOL] self . logger . debug ( [string] % self . package_name ) [EOL] [comment] [EOL] self . runner . device . connect ( ) [EOL] [EOL] self . runner . stop ( ) [EOL] self . runner . start ( debug_args = debug_args , interactive = self . debug_info and self . debug_info . interactive ) [EOL] [EOL] self . runner . device . device . forward ( local = [string] . format ( self . marionette_port ) , remote = [string] . format ( self . marionette_port ) ) [EOL] [EOL] for ports in self . config . ports . values ( ) : [EOL] for port in ports : [EOL] self . runner . device . device . reverse ( local = [string] . format ( port ) , remote = [string] . format ( port ) ) [EOL] [EOL] self . logger . debug ( [string] % self . package_name ) [EOL] [EOL] def stop ( self , force = False ) : [EOL] if self . runner is not None : [EOL] if self . runner . device . connected : [EOL] try : [EOL] self . runner . device . device . remove_forwards ( ) [EOL] self . runner . device . device . remove_reverses ( ) [EOL] except Exception as e : [EOL] self . logger . warning ( [string] % e ) [EOL] [comment] [EOL] [comment] [EOL] self . runner . stop ( ) [EOL] self . logger . debug ( [string] ) [EOL] [EOL] def pid ( self ) : [EOL] if self . runner . process_handler is None : [EOL] return None [EOL] [EOL] try : [EOL] return self . runner . process_handler . pid [EOL] except AttributeError : [EOL] return None [EOL] [EOL] def is_alive ( self ) : [EOL] if self . runner : [EOL] return self . runner . is_running ( ) [EOL] return False [EOL] [EOL] def cleanup ( self , force = False ) : [EOL] self . stop ( force ) [EOL] [EOL] def executor_browser ( self ) : [EOL] return ExecutorBrowser , { [string] : self . marionette_port } [EOL] [EOL] def check_crash ( self , process , test ) : [EOL] if not os . environ . get ( [string] , [string] ) and self . stackwalk_binary : [EOL] os . environ [ [string] ] = self . stackwalk_binary [EOL] return bool ( self . runner . check_for_crashes ( test_name = test ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.browsers.firefox_android.ProfileCreator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Tuple , Any , Dict [EOL] import requests [EOL] import typing [EOL] import glob [EOL] import os [EOL] import shutil [EOL] import subprocess [EOL] import tarfile [EOL] import tempfile [EOL] import time [EOL] [EOL] import requests [EOL] [EOL] from six . moves import cStringIO as StringIO [EOL] [EOL] from . base import Browser , ExecutorBrowser , require_arg [EOL] from . base import get_timeout_multiplier [comment] [EOL] from . . executors import executor_kwargs as base_executor_kwargs [EOL] from . . executors . executorselenium import ( SeleniumTestharnessExecutor , SeleniumRefTestExecutor ) [comment] [EOL] [EOL] here = os . path . dirname ( __file__ ) [EOL] [comment] [EOL] [comment] [EOL] sc_poll_period = [number] [EOL] [EOL] [EOL] __wptrunner__ = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def get_capabilities ( ** kwargs ) : [EOL] browser_name = kwargs [ [string] ] [EOL] platform = kwargs [ [string] ] [EOL] version = kwargs [ [string] ] [EOL] build = kwargs [ [string] ] [EOL] tags = kwargs [ [string] ] [EOL] tunnel_id = kwargs [ [string] ] [EOL] prerun_script = { [string] : { [string] : [string] , [string] : False , } , [string] : { [string] : [string] , [string] : False , } } [EOL] capabilities = { [string] : browser_name , [string] : build , [string] : True , [string] : [string] % ( browser_name , version , platform ) , [string] : platform , [string] : [string] , [string] : [string] , [string] : tags , [string] : tunnel_id , [string] : version , [string] : prerun_script . get ( browser_name ) } [EOL] [EOL] return capabilities [EOL] [EOL] [EOL] def get_sauce_config ( ** kwargs ) : [EOL] browser_name = kwargs [ [string] ] [EOL] sauce_user = kwargs [ [string] ] [EOL] sauce_key = kwargs [ [string] ] [EOL] [EOL] hub_url = [string] % ( sauce_user , sauce_key ) [EOL] data = { [string] : [string] % hub_url , [string] : browser_name , [string] : get_capabilities ( ** kwargs ) } [EOL] [EOL] return data [EOL] [EOL] [EOL] def check_args ( ** kwargs ) : [EOL] require_arg ( kwargs , [string] ) [EOL] require_arg ( kwargs , [string] ) [EOL] require_arg ( kwargs , [string] ) [EOL] require_arg ( kwargs , [string] ) [EOL] require_arg ( kwargs , [string] ) [EOL] [EOL] [EOL] def browser_kwargs ( test_type , run_info_data , config , ** kwargs ) : [EOL] sauce_config = get_sauce_config ( ** kwargs ) [EOL] [EOL] return { [string] : sauce_config } [EOL] [EOL] [EOL] def executor_kwargs ( test_type , server_config , cache_manager , run_info_data , ** kwargs ) : [EOL] executor_kwargs = base_executor_kwargs ( test_type , server_config , cache_manager , run_info_data , ** kwargs ) [EOL] [EOL] executor_kwargs [ [string] ] = get_capabilities ( ** kwargs ) [EOL] [EOL] return executor_kwargs [EOL] [EOL] [EOL] def env_extras ( ** kwargs ) : [EOL] return [ SauceConnect ( ** kwargs ) ] [EOL] [EOL] [EOL] def env_options ( ) : [EOL] return { [string] : False } [EOL] [EOL] [EOL] def get_tar ( url , dest ) : [EOL] resp = requests . get ( url , stream = True ) [EOL] resp . raise_for_status ( ) [EOL] with tarfile . open ( fileobj = StringIO ( resp . raw . read ( ) ) ) as f : [EOL] f . extractall ( path = dest ) [EOL] [EOL] [EOL] class SauceConnect ( ) : [EOL] [EOL] def __init__ ( self , ** kwargs ) : [EOL] self . sauce_user = kwargs [ [string] ] [EOL] self . sauce_key = kwargs [ [string] ] [EOL] self . sauce_tunnel_id = kwargs [ [string] ] [EOL] self . sauce_connect_binary = kwargs . get ( [string] ) [EOL] self . sauce_connect_args = kwargs . get ( [string] ) [EOL] self . sauce_init_timeout = kwargs . get ( [string] ) [EOL] self . sc_process = None [EOL] self . temp_dir = None [EOL] self . env_config = None [EOL] [EOL] def __call__ ( self , env_options , env_config ) : [EOL] self . env_config = env_config [EOL] [EOL] return self [EOL] [EOL] def __enter__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert self . env_config is not None , [string] [EOL] [EOL] if not self . sauce_connect_binary : [EOL] self . temp_dir = tempfile . mkdtemp ( ) [EOL] get_tar ( [string] , self . temp_dir ) [EOL] self . sauce_connect_binary = glob . glob ( os . path . join ( self . temp_dir , [string] ) ) [ [number] ] [EOL] [EOL] self . upload_prerun_exec ( [string] ) [EOL] self . upload_prerun_exec ( [string] ) [EOL] [EOL] self . sc_process = subprocess . Popen ( [ self . sauce_connect_binary , [string] % self . sauce_user , [string] % self . sauce_key , [string] , [string] % self . sauce_tunnel_id , [string] , [string] , [string] , [string] . join ( self . env_config . domains_set ) ] + self . sauce_connect_args ) [EOL] [EOL] tot_wait = [number] [EOL] while not os . path . exists ( [string] ) and self . sc_process . poll ( ) is None : [EOL] if not self . sauce_init_timeout or ( tot_wait >= self . sauce_init_timeout ) : [EOL] self . quit ( ) [EOL] [EOL] raise SauceException ( [string] % tot_wait ) [EOL] [EOL] time . sleep ( sc_poll_period ) [EOL] tot_wait += sc_poll_period [EOL] [EOL] if self . sc_process . returncode is not None : [EOL] raise SauceException ( [string] , self . sc_process . returncode ) [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] self . env_config = None [EOL] self . quit ( ) [EOL] if self . temp_dir and os . path . exists ( self . temp_dir ) : [EOL] try : [EOL] shutil . rmtree ( self . temp_dir ) [EOL] except OSError : [EOL] pass [EOL] [EOL] def upload_prerun_exec ( self , file_name ) : [EOL] auth = ( self . sauce_user , self . sauce_key ) [EOL] url = [string] % ( self . sauce_user , file_name ) [EOL] [EOL] with open ( os . path . join ( here , [string] , file_name ) , [string] ) as f : [EOL] requests . post ( url , data = f , auth = auth ) [EOL] [EOL] def quit ( self ) : [EOL] [docstring] [EOL] kill_wait = [number] [EOL] tot_wait = [number] [EOL] self . sc_process . terminate ( ) [EOL] [EOL] while self . sc_process . poll ( ) is None : [EOL] time . sleep ( sc_poll_period ) [EOL] tot_wait += sc_poll_period [EOL] [EOL] if tot_wait >= kill_wait : [EOL] self . sc_process . kill ( ) [EOL] break [EOL] [EOL] [EOL] class SauceException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class SauceBrowser ( Browser ) : [EOL] init_timeout = [number] [EOL] [EOL] def __init__ ( self , logger , sauce_config ) : [EOL] Browser . __init__ ( self , logger ) [EOL] self . sauce_config = sauce_config [EOL] [EOL] def start ( self , ** kwargs ) : [EOL] pass [EOL] [EOL] def stop ( self , force = False ) : [EOL] pass [EOL] [EOL] def pid ( self ) : [EOL] return None [EOL] [EOL] def is_alive ( self ) : [EOL] [comment] [EOL] return True [EOL] [EOL] def cleanup ( self ) : [EOL] pass [EOL] [EOL] def executor_browser ( self ) : [EOL] return ExecutorBrowser , { [string] : self . sauce_config [ [string] ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Tuple[unknown,unknown]$ 0 $typing.Tuple[unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Pattern , Any , Dict [EOL] import tests [EOL] import typing [EOL] import json [EOL] import re [EOL] import sys [EOL] [EOL] from mozlog . structured . formatters . base import BaseFormatter [EOL] from . . executors . base import strip_server [EOL] [EOL] [EOL] LONE_SURROGATE_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] def surrogate_replacement_ucs4 ( match ) : [EOL] return [string] + hex ( ord ( match . group ( ) ) ) [ [number] : ] [EOL] [EOL] [EOL] class SurrogateReplacementUcs2 ( object ) : [EOL] def __init__ ( self ) : [EOL] self . skip = False [EOL] [EOL] def __call__ ( self , match ) : [EOL] char = match . group ( ) [EOL] [EOL] if self . skip : [EOL] self . skip = False [EOL] return char [EOL] [EOL] is_low = [number] <= ord ( char ) <= [number] [EOL] [EOL] escape = True [EOL] if is_low : [EOL] next_idx = match . end ( ) [EOL] if next_idx < len ( match . string ) : [EOL] next_char = match . string [ next_idx ] [EOL] if [number] <= ord ( next_char ) <= [number] : [EOL] escape = False [EOL] [EOL] if not escape : [EOL] self . skip = True [EOL] return char [EOL] [EOL] return [string] + hex ( ord ( match . group ( ) ) ) [ [number] : ] [EOL] [EOL] [EOL] if sys . maxunicode == [number] : [EOL] surrogate_replacement = surrogate_replacement_ucs4 [EOL] else : [EOL] surrogate_replacement = SurrogateReplacementUcs2 ( ) [EOL] [EOL] [EOL] def replace_lone_surrogate ( data ) : [EOL] return LONE_SURROGATE_RE . subn ( surrogate_replacement , data ) [ [number] ] [EOL] [EOL] [EOL] class WptreportFormatter ( BaseFormatter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . raw_results = { } [EOL] self . results = { } [EOL] [EOL] def suite_start ( self , data ) : [EOL] if [string] in data : [EOL] self . results [ [string] ] = data [ [string] ] [EOL] self . results [ [string] ] = data [ [string] ] [EOL] self . results [ [string] ] = [ ] [EOL] [EOL] def suite_end ( self , data ) : [EOL] self . results [ [string] ] = data [ [string] ] [EOL] for test_name in self . raw_results : [EOL] result = { [string] : test_name } [EOL] result . update ( self . raw_results [ test_name ] ) [EOL] self . results [ [string] ] . append ( result ) [EOL] return json . dumps ( self . results ) + [string] [EOL] [EOL] def find_or_create_test ( self , data ) : [EOL] test_name = data [ [string] ] [EOL] if test_name not in self . raw_results : [EOL] self . raw_results [ test_name ] = { [string] : [ ] , [string] : [string] , [string] : None } [EOL] return self . raw_results [ test_name ] [EOL] [EOL] def test_start ( self , data ) : [EOL] test = self . find_or_create_test ( data ) [EOL] test [ [string] ] = data [ [string] ] [EOL] [EOL] def create_subtest ( self , data ) : [EOL] test = self . find_or_create_test ( data ) [EOL] subtest_name = replace_lone_surrogate ( data [ [string] ] ) [EOL] [EOL] subtest = { [string] : subtest_name , [string] : [string] , [string] : None } [EOL] test [ [string] ] . append ( subtest ) [EOL] [EOL] return subtest [EOL] [EOL] def test_status ( self , data ) : [EOL] subtest = self . create_subtest ( data ) [EOL] subtest [ [string] ] = data [ [string] ] [EOL] if [string] in data : [EOL] subtest [ [string] ] = data [ [string] ] [EOL] if [string] in data : [EOL] subtest [ [string] ] = data [ [string] ] [EOL] if [string] in data : [EOL] subtest [ [string] ] = replace_lone_surrogate ( data [ [string] ] ) [EOL] [EOL] def test_end ( self , data ) : [EOL] test = self . find_or_create_test ( data ) [EOL] start_time = test . pop ( [string] ) [EOL] test [ [string] ] = data [ [string] ] - start_time [EOL] test [ [string] ] = data [ [string] ] [EOL] if [string] in data : [EOL] test [ [string] ] = data [ [string] ] [EOL] if [string] in data : [EOL] test [ [string] ] = data [ [string] ] [EOL] if [string] in data : [EOL] test [ [string] ] = replace_lone_surrogate ( data [ [string] ] ) [EOL] if [string] in data . get ( [string] , { } ) : [EOL] test [ [string] ] = { strip_server ( item [ [string] ] ) : [string] + item [ [string] ] for item in data [ [string] ] [ [string] ] if type ( item ) == dict } [EOL] test_name = data [ [string] ] [EOL] result = { [string] : data [ [string] ] } [EOL] result . update ( self . raw_results [ test_name ] ) [EOL] self . results [ [string] ] . append ( result ) [EOL] self . raw_results . pop ( test_name ) [EOL] [EOL] def assertion_count ( self , data ) : [EOL] test = self . find_or_create_test ( data ) [EOL] test [ [string] ] = { [string] : data [ [string] ] , [string] : data [ [string] ] , [string] : data [ [string] ] } [EOL] [EOL] def lsan_leak ( self , data ) : [EOL] if [string] not in self . results : [EOL] self . results [ [string] ] = [ ] [EOL] lsan_leaks = self . results [ [string] ] [EOL] lsan_leaks . append ( { [string] : data [ [string] ] , [string] : data [ [string] ] , [string] : data . get ( [string] ) } ) [EOL] [EOL] def find_or_create_mozleak ( self , data ) : [EOL] if [string] not in self . results : [EOL] self . results [ [string] ] = { } [EOL] scope = data [ [string] ] [EOL] if scope not in self . results [ [string] ] : [EOL] self . results [ [string] ] [ scope ] = { [string] : [ ] , [string] : [ ] } [EOL] return self . results [ [string] ] [ scope ] [EOL] [EOL] def mozleak_object ( self , data ) : [EOL] scope_data = self . find_or_create_mozleak ( data ) [EOL] scope_data [ [string] ] . append ( { [string] : data [ [string] ] , [string] : data [ [string] ] , [string] : data . get ( [string] , False ) , [string] : data [ [string] ] } ) [EOL] [EOL] def mozleak_total ( self , data ) : [EOL] scope_data = self . find_or_create_mozleak ( data ) [EOL] scope_data [ [string] ] . append ( { [string] : data [ [string] ] , [string] : data . get ( [string] , [number] ) , [string] : data [ [string] ] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any , Dict [EOL] import typing [EOL] from os . path import join , dirname [EOL] [EOL] import pytest [EOL] [EOL] from wptserve . config import ConfigBuilder [EOL] from . . base import active_products [EOL] from wptrunner import environment , products [EOL] [EOL] test_paths = { [string] : { [string] : join ( dirname ( __file__ ) , [string] , [string] , [string] , [string] , [string] ) } } [comment] [EOL] environment . do_delayed_imports ( None , test_paths ) [EOL] [EOL] [EOL] @ active_products ( [string] ) def test_webkitgtk_certificate_domain_list ( product ) : [EOL] [EOL] def domain_is_inside_certificate_list_cert ( domain_to_find , webkitgtk_certificate_list , cert_file ) : [EOL] for domain in webkitgtk_certificate_list : [EOL] if domain [ [string] ] == domain_to_find and domain [ [string] ] == cert_file : [EOL] return True [EOL] return False [EOL] [EOL] if product not in [ [string] , [string] , [string] ] : [EOL] pytest . skip ( [string] % product ) [EOL] [EOL] ( check_args , target_browser_cls , get_browser_kwargs , executor_classes , get_executor_kwargs , env_options , get_env_extras , run_info_extras ) = products . load_product ( { } , product ) [EOL] [EOL] cert_file = [string] [EOL] valid_domains_test = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] invalid_domains_test = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] kwargs = { } [EOL] kwargs [ [string] ] = [number] [EOL] kwargs [ [string] ] = None [EOL] kwargs [ [string] ] = cert_file [EOL] kwargs [ [string] ] = [string] [EOL] kwargs [ [string] ] = None [EOL] kwargs [ [string] ] = None [EOL] with ConfigBuilder ( browser_host = [string] , alternate_hosts = { [string] : [string] } , subdomains = { [string] , [string] } , not_subdomains = { [string] , [string] } ) as env_config : [EOL] [EOL] executor_args = get_executor_kwargs ( None , env_config , None , None , ** kwargs ) [EOL] assert ( [string] in executor_args ) [EOL] assert ( [string] in executor_args [ [string] ] ) [EOL] assert ( [string] in executor_args [ [string] ] [ [string] ] ) [EOL] cert_list = executor_args [ [string] ] [ [string] ] [ [string] ] [EOL] for valid_domain in valid_domains_test : [EOL] assert ( domain_is_inside_certificate_list_cert ( valid_domain , cert_list , cert_file ) ) [EOL] assert ( not domain_is_inside_certificate_list_cert ( valid_domain , cert_list , cert_file + [string] ) ) [EOL] for invalid_domain in invalid_domains_test : [EOL] assert ( not domain_is_inside_certificate_list_cert ( invalid_domain , cert_list , cert_file ) ) [EOL] assert ( not domain_is_inside_certificate_list_cert ( invalid_domain , cert_list , cert_file + [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type [EOL] import tests [EOL] import typing [EOL] from . . webdriver_server import WebKitDriverServer [EOL] from . base import WdspecExecutor , WdspecProtocol [EOL] [EOL] [EOL] class WebKitDriverProtocol ( WdspecProtocol ) : [EOL] server_cls = WebKitDriverServer [EOL] [EOL] [EOL] class WebKitDriverWdspecExecutor ( WdspecExecutor ) : [EOL] protocol_cls = WebKitDriverProtocol [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . base import TestExecutor [EOL] [EOL] [EOL] class ProcessTestExecutor ( TestExecutor ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] TestExecutor . __init__ ( self , * args , ** kwargs ) [EOL] self . binary = self . browser . binary [EOL] self . interactive = ( False if self . debug_info is None [EOL] else self . debug_info . interactive ) [EOL] [EOL] def setup ( self , runner ) : [EOL] self . runner = runner [EOL] self . runner . send_message ( [string] ) [EOL] return True [EOL] [EOL] def is_alive ( self ) : [EOL] return True [EOL] [EOL] def do_test ( self , test ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . base import ( executor_kwargs , testharness_result_converter , reftest_result_converter , TestExecutor ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import tests [EOL] import typing [EOL] from . . webdriver_server import EdgeChromiumDriverServer [EOL] from . base import WdspecExecutor , WdspecProtocol [EOL] [EOL] [EOL] class EdgeChromiumDriverProtocol ( WdspecProtocol ) : [EOL] server_cls = EdgeChromiumDriverServer [EOL] [EOL] [EOL] class EdgeChromiumDriverWdspecExecutor ( WdspecExecutor ) : [EOL] protocol_cls = EdgeChromiumDriverProtocol [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import tests [EOL] import typing [EOL] from . . webdriver_server import EdgeDriverServer [EOL] from . base import WdspecExecutor , WdspecProtocol [EOL] [EOL] [EOL] class EdgeDriverProtocol ( WdspecProtocol ) : [EOL] server_cls = EdgeDriverServer [EOL] [EOL] [EOL] class EdgeDriverWdspecExecutor ( WdspecExecutor ) : [EOL] protocol_cls = EdgeDriverProtocol [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import tests [EOL] import typing [EOL] from . . webdriver_server import InternetExplorerDriverServer [EOL] from . base import WdspecExecutor , WdspecProtocol [EOL] [EOL] [EOL] class InternetExplorerDriverProtocol ( WdspecProtocol ) : [EOL] server_cls = InternetExplorerDriverServer [EOL] [EOL] [EOL] class InternetExplorerDriverWdspecExecutor ( WdspecExecutor ) : [EOL] protocol_cls = InternetExplorerDriverProtocol [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type , Any , List [EOL] import tests [EOL] import typing [EOL] import json [EOL] import os [EOL] import socket [EOL] import traceback [EOL] [EOL] from . base import ( Protocol , BaseProtocolPart , RefTestExecutor , RefTestImplementation , TestharnessExecutor , TimedRunner , strip_server ) [EOL] from . . testrunner import Stop [EOL] from . . webdriver_server import wait_for_service [EOL] [EOL] webdriver = None [EOL] ServoCommandExtensions = None [EOL] [EOL] here = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] def do_delayed_imports ( ) : [EOL] global webdriver [EOL] import webdriver [EOL] [EOL] global ServoCommandExtensions [EOL] [EOL] class ServoCommandExtensions ( object ) : [EOL] def __init__ ( self , session ) : [EOL] self . session = session [EOL] [EOL] @ webdriver . client . command def get_prefs ( self , * prefs ) : [EOL] body = { [string] : list ( prefs ) } [EOL] return self . session . send_session_command ( [string] , [string] , body ) [EOL] [EOL] @ webdriver . client . command def set_prefs ( self , prefs ) : [EOL] body = { [string] : prefs } [EOL] return self . session . send_session_command ( [string] , [string] , body ) [EOL] [EOL] @ webdriver . client . command def reset_prefs ( self , * prefs ) : [EOL] body = { [string] : list ( prefs ) } [EOL] return self . session . send_session_command ( [string] , [string] , body ) [EOL] [EOL] def change_prefs ( self , old_prefs , new_prefs ) : [EOL] [comment] [EOL] if old_prefs : [EOL] self . reset_prefs ( * old_prefs . keys ( ) ) [EOL] self . set_prefs ( { k : parse_pref_value ( v ) for k , v in new_prefs . items ( ) } ) [EOL] [EOL] [EOL] [comment] [EOL] def parse_pref_value ( value ) : [EOL] if value == [string] : [EOL] return True [EOL] if value == [string] : [EOL] return False [EOL] try : [EOL] return float ( value ) [EOL] except ValueError : [EOL] return value [EOL] [EOL] [EOL] class ServoBaseProtocolPart ( BaseProtocolPart ) : [EOL] def execute_script ( self , script , asynchronous = False ) : [EOL] pass [EOL] [EOL] def set_timeout ( self , timeout ) : [EOL] pass [EOL] [EOL] def wait ( self ) : [EOL] pass [EOL] [EOL] def set_window ( self , handle ) : [EOL] pass [EOL] [EOL] def load ( self , url ) : [EOL] pass [EOL] [EOL] [EOL] class ServoWebDriverProtocol ( Protocol ) : [EOL] implements = [ ServoBaseProtocolPart ] [EOL] [EOL] def __init__ ( self , executor , browser , capabilities , ** kwargs ) : [EOL] do_delayed_imports ( ) [EOL] Protocol . __init__ ( self , executor , browser ) [EOL] self . capabilities = capabilities [EOL] self . host = browser . webdriver_host [EOL] self . port = browser . webdriver_port [EOL] self . init_timeout = browser . init_timeout [EOL] self . session = None [EOL] [EOL] def connect ( self ) : [EOL] [docstring] [EOL] wait_for_service ( ( self . host , self . port ) , timeout = self . init_timeout ) [EOL] [EOL] self . session = webdriver . Session ( self . host , self . port , extension = ServoCommandExtensions ) [EOL] self . session . start ( ) [EOL] [EOL] def after_connect ( self ) : [EOL] pass [EOL] [EOL] def teardown ( self ) : [EOL] self . logger . debug ( [string] ) [EOL] try : [EOL] self . session . end ( ) [EOL] except Exception : [EOL] pass [EOL] [EOL] def is_alive ( self ) : [EOL] try : [EOL] [comment] [EOL] self . session . window_handle [EOL] [comment] [EOL] except Exception : [EOL] return False [EOL] return True [EOL] [EOL] def wait ( self ) : [EOL] while True : [EOL] try : [EOL] self . session . execute_async_script ( [string] ) [EOL] except webdriver . TimeoutException : [EOL] pass [EOL] except ( socket . timeout , IOError ) : [EOL] break [EOL] except Exception : [EOL] self . logger . error ( traceback . format_exc ( ) ) [EOL] break [EOL] [EOL] [EOL] class ServoWebDriverRun ( TimedRunner ) : [EOL] def set_timeout ( self ) : [EOL] pass [EOL] [EOL] def run_func ( self ) : [EOL] try : [EOL] self . result = True , self . func ( self . protocol . session , self . url , self . timeout ) [EOL] except webdriver . TimeoutException : [EOL] self . result = False , ( [string] , None ) [EOL] except ( socket . timeout , IOError ) : [EOL] self . result = False , ( [string] , None ) [EOL] except Exception as e : [EOL] message = getattr ( e , [string] , [string] ) [EOL] if message : [EOL] message += [string] [EOL] message += traceback . format_exc ( ) [EOL] self . result = False , ( [string] , e ) [EOL] finally : [EOL] self . result_flag . set ( ) [EOL] [EOL] [EOL] class ServoWebDriverTestharnessExecutor ( TestharnessExecutor ) : [EOL] supports_testdriver = True [EOL] [EOL] def __init__ ( self , logger , browser , server_config , timeout_multiplier = [number] , close_after_done = True , capabilities = None , debug_info = None , ** kwargs ) : [EOL] TestharnessExecutor . __init__ ( self , logger , browser , server_config , timeout_multiplier = [number] , debug_info = None ) [EOL] self . protocol = ServoWebDriverProtocol ( self , browser , capabilities = capabilities ) [EOL] with open ( os . path . join ( here , [string] ) ) as f : [EOL] self . script = f . read ( ) [EOL] self . timeout = None [EOL] [EOL] def on_protocol_change ( self , new_protocol ) : [EOL] pass [EOL] [EOL] def is_alive ( self ) : [EOL] return self . protocol . is_alive ( ) [EOL] [EOL] def do_test ( self , test ) : [EOL] url = self . test_url ( test ) [EOL] [EOL] timeout = test . timeout * self . timeout_multiplier + self . extra_timeout [EOL] [EOL] if timeout != self . timeout : [EOL] try : [EOL] self . protocol . session . timeouts . script = timeout [EOL] self . timeout = timeout [EOL] except IOError : [EOL] self . logger . error ( [string] ) [EOL] return Stop [EOL] [EOL] success , data = ServoWebDriverRun ( self . logger , self . do_testharness , self . protocol , url , timeout , self . extra_timeout ) . run ( ) [EOL] [EOL] if success : [EOL] return self . convert_result ( test , data ) [EOL] [EOL] return ( test . result_cls ( * data ) , [ ] ) [EOL] [EOL] def do_testharness ( self , session , url , timeout ) : [EOL] session . url = url [EOL] result = json . loads ( session . execute_async_script ( self . script % { [string] : url , [string] : strip_server ( url ) , [string] : self . timeout_multiplier , [string] : timeout * [number] } ) ) [EOL] [comment] [EOL] [comment] [EOL] session . back ( ) [EOL] return result [EOL] [EOL] def on_environment_change ( self , new_environment ) : [EOL] self . protocol . session . extension . change_prefs ( self . last_environment . get ( [string] , { } ) , new_environment . get ( [string] , { } ) ) [EOL] [EOL] [EOL] class TimeoutError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class ServoWebDriverRefTestExecutor ( RefTestExecutor ) : [EOL] def __init__ ( self , logger , browser , server_config , timeout_multiplier = [number] , screenshot_cache = None , capabilities = None , debug_info = None , ** kwargs ) : [EOL] [docstring] [EOL] RefTestExecutor . __init__ ( self , logger , browser , server_config , screenshot_cache = screenshot_cache , timeout_multiplier = timeout_multiplier , debug_info = debug_info ) [EOL] self . protocol = ServoWebDriverProtocol ( self , browser , capabilities = capabilities ) [EOL] self . implementation = RefTestImplementation ( self ) [EOL] self . timeout = None [EOL] with open ( os . path . join ( here , [string] ) ) as f : [EOL] self . wait_script = f . read ( ) % { [string] : [string] } [EOL] [EOL] def reset ( self ) : [EOL] self . implementation . reset ( ) [EOL] [EOL] def is_alive ( self ) : [EOL] return self . protocol . is_alive ( ) [EOL] [EOL] def do_test ( self , test ) : [EOL] try : [EOL] result = self . implementation . run_test ( test ) [EOL] return self . convert_result ( test , result ) [EOL] except IOError : [EOL] return test . result_cls ( [string] , None ) , [ ] [EOL] except TimeoutError : [EOL] return test . result_cls ( [string] , None ) , [ ] [EOL] except Exception as e : [EOL] message = getattr ( e , [string] , [string] ) [EOL] if message : [EOL] message += [string] [EOL] message += traceback . format_exc ( ) [EOL] return test . result_cls ( [string] , message ) , [ ] [EOL] [EOL] def screenshot ( self , test , viewport_size , dpi , page_ranges ) : [EOL] [comment] [EOL] assert viewport_size is None [EOL] assert dpi is None [EOL] [EOL] timeout = ( test . timeout * self . timeout_multiplier + self . extra_timeout [EOL] if self . debug_info is None else None ) [EOL] [EOL] if self . timeout != timeout : [EOL] try : [EOL] self . protocol . session . timeouts . script = timeout [EOL] self . timeout = timeout [EOL] except IOError : [EOL] self . logger . error ( [string] ) [EOL] return Stop [EOL] [EOL] return ServoWebDriverRun ( self . logger , self . _screenshot , self . protocol , self . test_url ( test ) , timeout , self . extra_timeout ) . run ( ) [EOL] [EOL] def _screenshot ( self , session , url , timeout ) : [EOL] session . url = url [EOL] session . execute_async_script ( self . wait_script ) [EOL] return session . screenshot ( ) [EOL] [EOL] def on_environment_change ( self , new_environment ) : [EOL] self . protocol . session . extension . change_prefs ( self . last_environment . get ( [string] , { } ) , new_environment . get ( [string] , { } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.executors.executorservodriver.ServoWebDriverProtocol$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.executors.executorservodriver.ServoWebDriverProtocol$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import tests [EOL] import typing [EOL] from . . webdriver_server import SafariDriverServer [EOL] from . base import WdspecExecutor , WdspecProtocol [EOL] [EOL] [EOL] class SafariDriverProtocol ( WdspecProtocol ) : [EOL] server_cls = SafariDriverServer [EOL] [EOL] [EOL] class SafariDriverWdspecExecutor ( WdspecExecutor ) : [EOL] protocol_cls = SafariDriverProtocol [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import tests [EOL] import typing [EOL] from . . webdriver_server import OperaDriverServer [EOL] from . base import WdspecExecutor , WdspecProtocol [EOL] [EOL] [EOL] class OperaDriverProtocol ( WdspecProtocol ) : [EOL] server_cls = OperaDriverServer [EOL] [EOL] [EOL] class OperaDriverWdspecExecutor ( WdspecExecutor ) : [EOL] protocol_cls = OperaDriverProtocol [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . runner import run [comment] [EOL]	0 0 0 0 0 0 0
from typing import Any , List [EOL] import tests [EOL] import typing [EOL] from six . moves import range [EOL] [EOL] class NodeVisitor ( object ) : [EOL] def visit ( self , node ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] func = getattr ( self , [string] % ( node . __class__ . __name__ ) ) [EOL] return func ( node ) [EOL] [EOL] [EOL] class Node ( object ) : [EOL] def __init__ ( self , data = None ) : [EOL] self . data = data [EOL] self . parent = None [EOL] self . children = [ ] [EOL] [EOL] def append ( self , other ) : [EOL] other . parent = self [EOL] self . children . append ( other ) [EOL] [EOL] def remove ( self ) : [EOL] self . parent . children . remove ( self ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . data ) [EOL] [EOL] def __str__ ( self ) : [EOL] rv = [ repr ( self ) ] [EOL] for item in self . children : [EOL] rv . extend ( [string] % line for line in str ( item ) . split ( [string] ) ) [EOL] return [string] . join ( rv ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not ( self . __class__ == other . __class__ and self . data == other . data and len ( self . children ) == len ( other . children ) ) : [EOL] return False [EOL] for child , other_child in zip ( self . children , other . children ) : [EOL] if not child == other_child : [EOL] return False [EOL] return True [EOL] [EOL] def copy ( self ) : [EOL] new = self . __class__ ( self . data ) [EOL] for item in self . children : [EOL] new . append ( item . copy ( ) ) [EOL] return new [EOL] [EOL] [EOL] class DataNode ( Node ) : [EOL] def append ( self , other ) : [EOL] [comment] [EOL] [comment] [EOL] other . parent = self [EOL] if isinstance ( other , DataNode ) : [EOL] self . children . append ( other ) [EOL] else : [EOL] index = len ( self . children ) [EOL] while index > [number] and isinstance ( self . children [ index - [number] ] , DataNode ) : [EOL] index -= [number] [EOL] for i in range ( index ) : [EOL] if other . data == self . children [ i ] . data : [EOL] raise ValueError ( [string] % self . children [ i ] . data ) [EOL] self . children . insert ( index , other ) [EOL] [EOL] [EOL] class KeyValueNode ( Node ) : [EOL] def append ( self , other ) : [EOL] [comment] [EOL] [comment] [EOL] other . parent = self [EOL] if not isinstance ( other , ( ListNode , ValueNode , ConditionalNode ) ) : [EOL] raise TypeError [EOL] if isinstance ( other , ( ListNode , ValueNode ) ) : [EOL] if self . children : [EOL] assert not isinstance ( self . children [ - [number] ] , ( ListNode , ValueNode ) ) [EOL] self . children . append ( other ) [EOL] else : [EOL] if self . children and isinstance ( self . children [ - [number] ] , ValueNode ) : [EOL] self . children . insert ( len ( self . children ) - [number] , other ) [EOL] else : [EOL] self . children . append ( other ) [EOL] [EOL] [EOL] class ListNode ( Node ) : [EOL] def append ( self , other ) : [EOL] other . parent = self [EOL] self . children . append ( other ) [EOL] [EOL] [EOL] class ValueNode ( Node ) : [EOL] def append ( self , other ) : [EOL] raise TypeError [EOL] [EOL] [EOL] class AtomNode ( ValueNode ) : [EOL] pass [EOL] [EOL] [EOL] class ConditionalNode ( Node ) : [EOL] def append ( self , other ) : [EOL] if not len ( self . children ) : [EOL] if not isinstance ( other , ( BinaryExpressionNode , UnaryExpressionNode , VariableNode ) ) : [EOL] raise TypeError [EOL] else : [EOL] if len ( self . children ) > [number] : [EOL] raise ValueError [EOL] if not isinstance ( other , ( ListNode , ValueNode ) ) : [EOL] raise TypeError [EOL] other . parent = self [EOL] self . children . append ( other ) [EOL] [EOL] [EOL] class UnaryExpressionNode ( Node ) : [EOL] def __init__ ( self , operator , operand ) : [EOL] Node . __init__ ( self ) [EOL] self . append ( operator ) [EOL] self . append ( operand ) [EOL] [EOL] def append ( self , other ) : [EOL] Node . append ( self , other ) [EOL] assert len ( self . children ) <= [number] [EOL] [EOL] def copy ( self ) : [EOL] new = self . __class__ ( self . children [ [number] ] . copy ( ) , self . children [ [number] ] . copy ( ) ) [EOL] return new [EOL] [EOL] [EOL] class BinaryExpressionNode ( Node ) : [EOL] def __init__ ( self , operator , operand_0 , operand_1 ) : [EOL] Node . __init__ ( self ) [EOL] self . append ( operator ) [EOL] self . append ( operand_0 ) [EOL] self . append ( operand_1 ) [EOL] [EOL] def append ( self , other ) : [EOL] Node . append ( self , other ) [EOL] assert len ( self . children ) <= [number] [EOL] [EOL] def copy ( self ) : [EOL] new = self . __class__ ( self . children [ [number] ] . copy ( ) , self . children [ [number] ] . copy ( ) , self . children [ [number] ] . copy ( ) ) [EOL] return new [EOL] [EOL] [EOL] class UnaryOperatorNode ( Node ) : [EOL] def append ( self , other ) : [EOL] raise TypeError [EOL] [EOL] [EOL] class BinaryOperatorNode ( Node ) : [EOL] def append ( self , other ) : [EOL] raise TypeError [EOL] [EOL] [EOL] class IndexNode ( Node ) : [EOL] pass [EOL] [EOL] [EOL] class VariableNode ( Node ) : [EOL] pass [EOL] [EOL] [EOL] class StringNode ( Node ) : [EOL] pass [EOL] [EOL] [EOL] class NumberNode ( ValueNode ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.wptmanifest.node.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.wptmanifest.node.Node$ 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.wptmanifest.node.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.wptmanifest.node.UnaryExpressionNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.wptmanifest.node.UnaryExpressionNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.wptmanifest.node.BinaryExpressionNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.wptmanifest.node.BinaryExpressionNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . serializer import serialize [EOL] from . parser import parse [EOL] from . backends . static import compile as compile_static [EOL] from . backends . conditional import compile as compile_condition [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , List [EOL] import tests [EOL] import typing [EOL] import unittest [EOL] [EOL] from . . backends import conditional [EOL] from . . node import BinaryExpressionNode , BinaryOperatorNode , VariableNode , NumberNode [EOL] [EOL] [EOL] class TestConditional ( unittest . TestCase ) : [EOL] def compile ( self , input_text ) : [EOL] return conditional . compile ( input_text ) [EOL] [EOL] def test_get_0 ( self ) : [EOL] data = [string] [EOL] [EOL] manifest = self . compile ( data ) [EOL] [EOL] self . assertEqual ( manifest . get ( [string] ) , [string] ) [EOL] children = list ( item for item in manifest . iterchildren ( ) ) [EOL] self . assertEqual ( len ( children ) , [number] ) [EOL] section = children [ [number] ] [EOL] self . assertEqual ( section . name , [string] ) [EOL] [EOL] self . assertEqual ( section . get ( [string] , { [string] : [number] } ) , [string] ) [EOL] self . assertEqual ( section . get ( [string] , { [string] : [number] } ) , [string] ) [EOL] self . assertEqual ( section . get ( [string] , { [string] : [number] } ) , [string] ) [EOL] self . assertEqual ( section . get ( [string] ) , [string] ) [EOL] [EOL] def test_get_1 ( self ) : [EOL] data = [string] [EOL] [EOL] manifest = self . compile ( data ) [EOL] [EOL] children = list ( item for item in manifest . iterchildren ( ) ) [EOL] section = children [ [number] ] [EOL] [EOL] self . assertEqual ( section . get ( [string] , { [string] : [string] } ) , [string] ) [EOL] self . assertEqual ( section . get ( [string] , { [string] : [number] } ) , [string] ) [EOL] [EOL] def test_get_2 ( self ) : [EOL] data = [string] [EOL] [EOL] manifest = self . compile ( data ) [EOL] [EOL] self . assertEqual ( manifest . get ( [string] , { [string] : [string] } ) , [string] ) [EOL] self . assertEqual ( manifest . get ( [string] , { [string] : [ [number] , [number] ] } ) , [string] ) [EOL] [EOL] def test_get_3 ( self ) : [EOL] data = [string] [EOL] [EOL] manifest = self . compile ( data ) [EOL] [EOL] self . assertEqual ( manifest . get ( [string] , { [string] : [string] } ) , [string] ) [EOL] self . assertEqual ( manifest . get ( [string] , { [string] : [ [number] , [number] ] } ) , [string] ) [EOL] [EOL] def test_set_0 ( self ) : [EOL] data = [string] [EOL] manifest = self . compile ( data ) [EOL] [EOL] manifest . set ( [string] , [string] ) [EOL] [EOL] self . assertEqual ( manifest . get ( [string] ) , [string] ) [EOL] [EOL] def test_set_1 ( self ) : [EOL] data = [string] [EOL] [EOL] manifest = self . compile ( data ) [EOL] [EOL] manifest . set ( [string] , [string] ) [EOL] [EOL] self . assertEqual ( manifest . get ( [string] ) , [string] ) [EOL] self . assertEqual ( manifest . get ( [string] , { [string] : [string] } ) , [string] ) [EOL] [EOL] def test_set_2 ( self ) : [EOL] data = [string] [EOL] [EOL] manifest = self . compile ( data ) [EOL] [EOL] expr = BinaryExpressionNode ( BinaryOperatorNode ( [string] ) , VariableNode ( [string] ) , NumberNode ( [string] ) ) [EOL] [EOL] manifest . set ( [string] , [string] , expr ) [EOL] [EOL] self . assertEqual ( manifest . get ( [string] , { [string] : [number] } ) , [string] ) [EOL] self . assertEqual ( manifest . get ( [string] , { [string] : [string] } ) , [string] ) [EOL] [EOL] def test_api_0 ( self ) : [EOL] data = [string] [EOL] manifest = self . compile ( data ) [EOL] [EOL] self . assertFalse ( manifest . is_empty ) [EOL] self . assertEqual ( manifest . root , manifest ) [EOL] self . assertTrue ( manifest . has_key ( [string] ) ) [EOL] self . assertFalse ( manifest . has_key ( [string] ) ) [EOL] [EOL] self . assertEqual ( set ( manifest . iterkeys ( ) ) , { [string] , [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.wptmanifest.node.BinaryExpressionNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wptrunner.wptrunner.wptmanifest.node.BinaryExpressionNode$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sys [EOL] import unittest [EOL] [EOL] import pytest [EOL] [EOL] from . . import parser , serializer [EOL] [EOL] [EOL] class TokenizerTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . serializer = serializer . ManifestSerializer ( ) [EOL] self . parser = parser . Parser ( ) [EOL] [EOL] def serialize ( self , input_str ) : [EOL] return self . serializer . serialize ( self . parser . parse ( input_str ) ) [EOL] [EOL] def compare ( self , input_str , expected = None ) : [EOL] if expected is None : [EOL] expected = input_str . decode ( [string] ) [EOL] actual = self . serialize ( input_str ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] def test_0 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_1 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_2 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_3 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_4 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_5 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_6 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_7 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_8 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_9 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_10 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_11 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_12 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_13 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_14 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_15 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_16 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_17 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_18 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_0 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_1 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_2 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_3 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_4 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_5 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_6 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_7 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_8 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] @ pytest . mark . xfail ( sys . maxunicode == [number] , reason = [string] ) def test_escape_9 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_10 ( self ) : [EOL] self . compare ( [string] , [string] ) [EOL] [EOL] def test_escape_11 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_atom_1 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_atom_2 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_atom_3 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_atom_4 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_conditional_1 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_if_string_0 ( self ) : [EOL] self . compare ( [string] ) [EOL] [EOL] def test_non_ascii_1 ( self ) : [EOL] self . compare ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ lambda spec : spec , lambda spec : spec ( ) ] , ids = [ [string] , [string] ] , ) def he_pm ( request , pm ) : [EOL] from pluggy import HookspecMarker [EOL] hookspec = HookspecMarker ( [string] ) [EOL] [EOL] class Hooks ( object ) : [EOL] @ hookspec def he_method1 ( self , arg ) : [EOL] return arg + [number] [EOL] [EOL] pm . add_hookspecs ( request . param ( Hooks ) ) [EOL] return pm [EOL] [EOL] [EOL] @ pytest . fixture def pm ( ) : [EOL] from pluggy import PluginManager [EOL] return PluginManager ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import tests [EOL] import typing [EOL] import pytest [EOL] from pluggy import PluginValidationError , HookimplMarker , HookspecMarker [EOL] [EOL] [EOL] hookspec = HookspecMarker ( [string] ) [EOL] hookimpl = HookimplMarker ( [string] ) [EOL] [EOL] [EOL] def test_happypath ( pm ) : [EOL] class Api ( object ) : [EOL] @ hookspec def hello ( self , arg ) : [EOL] [docstring] [EOL] [EOL] pm . add_hookspecs ( Api ) [EOL] hook = pm . hook [EOL] assert hasattr ( hook , [string] ) [EOL] assert repr ( hook . hello ) . find ( [string] ) != - [number] [EOL] [EOL] class Plugin ( object ) : [EOL] @ hookimpl def hello ( self , arg ) : [EOL] return arg + [number] [EOL] [EOL] plugin = Plugin ( ) [EOL] pm . register ( plugin ) [EOL] out = hook . hello ( arg = [number] ) [EOL] assert out == [ [number] ] [EOL] assert not hasattr ( hook , [string] ) [EOL] pm . unregister ( plugin ) [EOL] assert hook . hello ( arg = [number] ) == [ ] [EOL] [EOL] [EOL] def test_argmismatch ( pm ) : [EOL] class Api ( object ) : [EOL] @ hookspec def hello ( self , arg ) : [EOL] [docstring] [EOL] [EOL] pm . add_hookspecs ( Api ) [EOL] [EOL] class Plugin ( object ) : [EOL] @ hookimpl def hello ( self , argwrong ) : [EOL] pass [EOL] [EOL] with pytest . raises ( PluginValidationError ) as exc : [EOL] pm . register ( Plugin ( ) ) [EOL] [EOL] assert [string] in str ( exc . value ) [EOL] [EOL] [EOL] def test_only_kwargs ( pm ) : [EOL] class Api ( object ) : [EOL] @ hookspec def hello ( self , arg ) : [EOL] [docstring] [EOL] [EOL] pm . add_hookspecs ( Api ) [EOL] with pytest . raises ( TypeError ) as exc : [EOL] pm . hook . hello ( [number] ) [EOL] [EOL] comprehensible = [string] [EOL] assert comprehensible in str ( exc . value ) [EOL] [EOL] [EOL] def test_call_order ( pm ) : [EOL] class Api ( object ) : [EOL] @ hookspec def hello ( self , arg ) : [EOL] [docstring] [EOL] [EOL] pm . add_hookspecs ( Api ) [EOL] [EOL] class Plugin1 ( object ) : [EOL] @ hookimpl def hello ( self , arg ) : [EOL] return [number] [EOL] [EOL] class Plugin2 ( object ) : [EOL] @ hookimpl def hello ( self , arg ) : [EOL] return [number] [EOL] [EOL] class Plugin3 ( object ) : [EOL] @ hookimpl def hello ( self , arg ) : [EOL] return [number] [EOL] [EOL] class Plugin4 ( object ) : [EOL] @ hookimpl ( hookwrapper = True ) def hello ( self , arg ) : [EOL] assert arg == [number] [EOL] outcome = yield [EOL] assert outcome . get_result ( ) == [ [number] , [number] , [number] ] [EOL] [EOL] pm . register ( Plugin1 ( ) ) [EOL] pm . register ( Plugin2 ( ) ) [EOL] pm . register ( Plugin3 ( ) ) [EOL] pm . register ( Plugin4 ( ) ) [comment] [EOL] res = pm . hook . hello ( arg = [number] ) [EOL] assert res == [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_firstresult_definition ( pm ) : [EOL] class Api ( object ) : [EOL] @ hookspec ( firstresult = True ) def hello ( self , arg ) : [EOL] [docstring] [EOL] [EOL] pm . add_hookspecs ( Api ) [EOL] [EOL] class Plugin1 ( object ) : [EOL] @ hookimpl def hello ( self , arg ) : [EOL] return arg + [number] [EOL] [EOL] class Plugin2 ( object ) : [EOL] @ hookimpl def hello ( self , arg ) : [EOL] return arg - [number] [EOL] [EOL] class Plugin3 ( object ) : [EOL] @ hookimpl def hello ( self , arg ) : [EOL] return None [EOL] [EOL] class Plugin4 ( object ) : [EOL] @ hookimpl ( hookwrapper = True ) def hello ( self , arg ) : [EOL] assert arg == [number] [EOL] outcome = yield [EOL] assert outcome . get_result ( ) == [number] [EOL] [EOL] pm . register ( Plugin1 ( ) ) [comment] [EOL] pm . register ( Plugin2 ( ) ) [comment] [EOL] pm . register ( Plugin3 ( ) ) [comment] [EOL] pm . register ( Plugin4 ( ) ) [comment] [EOL] res = pm . hook . hello ( arg = [number] ) [EOL] assert res == [number] [EOL] [EOL] [EOL] def test_firstresult_force_result ( pm ) : [EOL] [docstring] [EOL] class Api ( object ) : [EOL] @ hookspec ( firstresult = True ) def hello ( self , arg ) : [EOL] [docstring] [EOL] [EOL] pm . add_hookspecs ( Api ) [EOL] [EOL] class Plugin1 ( object ) : [EOL] @ hookimpl def hello ( self , arg ) : [EOL] return arg + [number] [EOL] [EOL] class Plugin2 ( object ) : [EOL] @ hookimpl ( hookwrapper = True ) def hello ( self , arg ) : [EOL] assert arg == [number] [EOL] outcome = yield [EOL] assert outcome . get_result ( ) == [number] [EOL] outcome . force_result ( [number] ) [EOL] [EOL] class Plugin3 ( object ) : [EOL] @ hookimpl def hello ( self , arg ) : [EOL] return None [EOL] [EOL] pm . register ( Plugin1 ( ) ) [EOL] pm . register ( Plugin2 ( ) ) [comment] [EOL] pm . register ( Plugin3 ( ) ) [comment] [EOL] res = pm . hook . hello ( arg = [number] ) [EOL] assert res == [number] [comment] [EOL] [EOL] [EOL] def test_firstresult_returns_none ( pm ) : [EOL] [docstring] [EOL] class Api ( object ) : [EOL] @ hookspec ( firstresult = True ) def hello ( self , arg ) : [EOL] [docstring] [EOL] [EOL] pm . add_hookspecs ( Api ) [EOL] [EOL] class Plugin1 ( object ) : [EOL] @ hookimpl def hello ( self , arg ) : [EOL] return None [EOL] [EOL] pm . register ( Plugin1 ( ) ) [EOL] res = pm . hook . hello ( arg = [number] ) [EOL] assert res is None [EOL] [EOL] [EOL] def test_firstresult_no_plugin ( pm ) : [EOL] [docstring] [EOL] class Api ( object ) : [EOL] @ hookspec ( firstresult = True ) def hello ( self , arg ) : [EOL] [docstring] [EOL] [EOL] pm . add_hookspecs ( Api ) [EOL] res = pm . hook . hello ( arg = [number] ) [EOL] assert res is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from __future__ import absolute_import , division , print_function [EOL] [EOL] from attr import Attribute [EOL] from attr . _make import NOTHING , make_class [EOL] [EOL] [EOL] def simple_class ( cmp = False , repr = False , hash = False , str = False , slots = False , frozen = False ) : [EOL] [docstring] [EOL] return make_class ( [string] , [ [string] , [string] ] , cmp = cmp , repr = repr , hash = hash , init = True , slots = slots , str = str , frozen = frozen , ) [EOL] [EOL] [EOL] def simple_attr ( name , default = NOTHING , validator = None , repr = True , cmp = True , hash = None , init = True , converter = None ) : [EOL] [docstring] [EOL] return Attribute ( name = name , default = default , validator = validator , repr = repr , cmp = cmp , hash = hash , init = init , converter = converter , ) [EOL] [EOL] [EOL] class TestSimpleClass ( object ) : [EOL] [docstring] [EOL] def test_returns_class ( self ) : [EOL] [docstring] [EOL] assert type is simple_class ( ) . __class__ [EOL] [EOL] def returns_distinct_classes ( self ) : [EOL] [docstring] [EOL] assert simple_class ( ) is not simple_class ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Set , ClassVar , List , Type , Any [EOL] import builtins [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] [EOL] import types [EOL] import typing [EOL] [EOL] import pytest [EOL] [EOL] import attr [EOL] [EOL] from attr . _make import _classvar_prefixes [EOL] from attr . exceptions import UnannotatedAttributeError [EOL] [EOL] [EOL] class TestAnnotations : [EOL] [docstring] [EOL] [EOL] def test_basic_annotations ( self ) : [EOL] [docstring] [EOL] @ attr . s class C : [EOL] x = attr . ib ( ) [EOL] y = attr . ib ( type = str ) [EOL] z = attr . ib ( ) [EOL] [EOL] assert int is attr . fields ( C ) . x . type [EOL] assert str is attr . fields ( C ) . y . type [EOL] assert None is attr . fields ( C ) . z . type [EOL] assert C . __init__ . __annotations__ == { [string] : int , [string] : str , [string] : None , } [EOL] [EOL] def test_catches_basic_type_conflict ( self ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as e : [EOL] @ attr . s class C : [EOL] x = attr . ib ( type = int ) [EOL] [EOL] assert ( [string] , ) == e . value . args [EOL] [EOL] def test_typing_annotations ( self ) : [EOL] [docstring] [EOL] @ attr . s class C : [EOL] x = attr . ib ( ) [EOL] y = attr . ib ( type = typing . Optional [ str ] ) [EOL] [EOL] assert typing . List [ int ] is attr . fields ( C ) . x . type [EOL] assert typing . Optional [ str ] is attr . fields ( C ) . y . type [EOL] assert C . __init__ . __annotations__ == { [string] : typing . List [ int ] , [string] : typing . Optional [ str ] , [string] : None , } [EOL] [EOL] def test_only_attrs_annotations_collected ( self ) : [EOL] [docstring] [EOL] @ attr . s class C : [EOL] x = attr . ib ( ) [EOL] y = ... [EOL] [EOL] assert [number] == len ( attr . fields ( C ) ) [EOL] assert C . __init__ . __annotations__ == { [string] : typing . List [ int ] , [string] : None , } [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_auto_attribs ( self , slots ) : [EOL] [docstring] [EOL] @ attr . s ( auto_attribs = True , slots = slots ) class C : [EOL] cls_var = [number] [EOL] a = ... [EOL] x = attr . Factory ( list ) [EOL] y = [number] [EOL] z = attr . ib ( default = [number] ) [EOL] foo = None [EOL] [EOL] i = C ( [number] ) [EOL] assert [string] == repr ( i ) [EOL] [EOL] attr_names = set ( a . name for a in C . __attrs_attrs__ ) [EOL] assert [string] in attr_names [comment] [EOL] assert [string] not in attr_names [EOL] [EOL] assert int == attr . fields ( C ) . a . type [EOL] [EOL] assert attr . Factory ( list ) == attr . fields ( C ) . x . default [EOL] assert typing . List [ int ] == attr . fields ( C ) . x . type [EOL] [EOL] assert int == attr . fields ( C ) . y . type [EOL] assert [number] == attr . fields ( C ) . y . default [EOL] [EOL] assert int == attr . fields ( C ) . z . type [EOL] [EOL] assert typing . Any == attr . fields ( C ) . foo . type [EOL] [EOL] [comment] [EOL] if slots is False : [EOL] with pytest . raises ( AttributeError ) : [EOL] C . y [EOL] [EOL] assert [number] == i . y [EOL] else : [EOL] assert isinstance ( C . y , types . MemberDescriptorType ) [EOL] [EOL] i . y = [number] [EOL] assert [number] == i . y [EOL] [EOL] assert C . __init__ . __annotations__ == { [string] : int , [string] : typing . List [ int ] , [string] : int , [string] : int , [string] : typing . Any , [string] : None , } [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_auto_attribs_unannotated ( self , slots ) : [EOL] [docstring] [EOL] with pytest . raises ( UnannotatedAttributeError ) as e : [EOL] @ attr . s ( slots = slots , auto_attribs = True ) class C : [EOL] v = attr . ib ( ) [EOL] x = ... [EOL] y = attr . ib ( ) [EOL] z = ... [EOL] [EOL] assert ( [string] , ) == e . value . args [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_auto_attribs_subclassing ( self , slots ) : [EOL] [docstring] [EOL] @ attr . s ( slots = slots , auto_attribs = True ) class A : [EOL] a = [number] [EOL] [EOL] @ attr . s ( slots = slots , auto_attribs = True ) class B ( A ) : [EOL] b = [number] [EOL] [EOL] @ attr . s ( slots = slots , auto_attribs = True ) class C ( A ) : [EOL] pass [EOL] [EOL] assert [string] == repr ( B ( ) ) [EOL] assert [string] == repr ( C ( ) ) [EOL] [EOL] assert A . __init__ . __annotations__ == { [string] : int , [string] : None , } [EOL] assert B . __init__ . __annotations__ == { [string] : int , [string] : int , [string] : None , } [EOL] assert C . __init__ . __annotations__ == { [string] : int , [string] : None , } [EOL] [EOL] def test_converter_annotations ( self ) : [EOL] [docstring] [EOL] [EOL] @ attr . s ( auto_attribs = True ) class A : [EOL] a = attr . ib ( converter = int ) [EOL] [EOL] assert A . __init__ . __annotations__ == { [string] : None } [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) @ pytest . mark . parametrize ( [string] , _classvar_prefixes ) def test_annotations_strings ( self , slots , classvar ) : [EOL] [docstring] [EOL] @ attr . s ( auto_attribs = True , slots = slots ) class C : [EOL] cls_var = [number] [EOL] a = ... [EOL] x = attr . Factory ( list ) [EOL] y = [number] [EOL] z = attr . ib ( default = [number] ) [EOL] foo = None [EOL] [EOL] assert C . __init__ . __annotations__ == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Type[tests.wpt.web-platform-tests.tools.third_party.attrs.tests.test_annotations.TestAnnotations.test_basic_annotations.C]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.wpt.web-platform-tests.tools.third_party.attrs.tests.test_annotations.TestAnnotations.test_basic_annotations.C]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Type[tests.wpt.web-platform-tests.tools.third_party.attrs.tests.test_annotations.TestAnnotations.test_typing_annotations.C]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $classvar+'[int]'$ 0 0 0 $'int'$ 0 0 0 $'typing.List[int]'$ 0 0 0 0 0 0 0 0 $'int'$ 0 0 0 $'int'$ 0 0 0 0 0 0 0 0 0 0 $'typing.Any'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import pytest [EOL] [EOL] import attr [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_init_subclass_vanilla ( slots ) : [EOL] [docstring] [EOL] @ attr . s ( slots = slots ) class Base : [EOL] def __init_subclass__ ( cls , param , ** kw ) : [EOL] super ( ) . __init_subclass__ ( ** kw ) [EOL] cls . param = param [EOL] [EOL] class Vanilla ( Base , param = [string] ) : [EOL] pass [EOL] [EOL] assert [string] == Vanilla ( ) . param [EOL] [EOL] [EOL] def test_init_subclass_attrs ( ) : [EOL] [docstring] [EOL] @ attr . s ( slots = False ) class Base : [EOL] def __init_subclass__ ( cls , param , ** kw ) : [EOL] super ( ) . __init_subclass__ ( ** kw ) [EOL] cls . param = param [EOL] [EOL] @ attr . s class Attrs ( Base , param = [string] ) : [EOL] pass [EOL] [EOL] assert [string] == Attrs ( ) . param [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from __future__ import absolute_import , division , print_function [EOL] [EOL] [EOL] def optional ( converter ) : [EOL] [docstring] [EOL] [EOL] def optional_converter ( val ) : [EOL] if val is None : [EOL] return None [EOL] return converter ( val ) [EOL] [EOL] return optional_converter [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] __version__ = [string] [EOL]	0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Any [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] class _BooleanConfigOption ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] self . attr_name = [string] % self . name [EOL] [EOL] def __get__ ( self , instance , owner ) : [EOL] return getattr ( instance , self . attr_name ) [EOL] [EOL] def __set__ ( self , instance , value ) : [EOL] if not isinstance ( value , bool ) : [EOL] raise ValueError ( [string] % self . name ) [EOL] setattr ( instance , self . attr_name , value ) [EOL] [EOL] [EOL] class DummyLogger ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , * vargs ) : [EOL] pass [EOL] [EOL] def debug ( self , * vargs , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class H2Configuration ( object ) : [EOL] [docstring] [EOL] client_side = _BooleanConfigOption ( [string] ) [EOL] validate_outbound_headers = _BooleanConfigOption ( [string] ) [EOL] normalize_outbound_headers = _BooleanConfigOption ( [string] ) [EOL] validate_inbound_headers = _BooleanConfigOption ( [string] ) [EOL] normalize_inbound_headers = _BooleanConfigOption ( [string] ) [EOL] [EOL] def __init__ ( self , client_side = True , header_encoding = None , validate_outbound_headers = True , normalize_outbound_headers = True , validate_inbound_headers = True , normalize_inbound_headers = True , logger = None ) : [EOL] self . client_side = client_side [EOL] self . header_encoding = header_encoding [EOL] self . validate_outbound_headers = validate_outbound_headers [EOL] self . normalize_outbound_headers = normalize_outbound_headers [EOL] self . validate_inbound_headers = validate_inbound_headers [EOL] self . normalize_inbound_headers = normalize_inbound_headers [EOL] self . logger = logger or DummyLogger ( __name__ ) [EOL] [EOL] @ property def header_encoding ( self ) : [EOL] [docstring] [EOL] return self . _header_encoding [EOL] [EOL] @ header_encoding . setter def header_encoding ( self , value ) : [EOL] [docstring] [EOL] if not isinstance ( value , ( bool , str , type ( None ) ) ) : [EOL] raise ValueError ( [string] ) [EOL] if value is True : [EOL] raise ValueError ( [string] ) [EOL] self . _header_encoding = value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type , Tuple , Any , List [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] import h2 . config [EOL] import h2 . connection [EOL] import h2 . errors [EOL] import h2 . events [EOL] import h2 . exceptions [EOL] [EOL] [EOL] class TestClosedStreams ( object ) : [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] example_response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] server_config = h2 . config . H2Configuration ( client_side = False ) [EOL] [EOL] def test_can_receive_multiple_rst_stream_frames ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers , end_stream = True ) [EOL] [EOL] f = frame_factory . build_rst_stream_frame ( stream_id = [number] ) [EOL] events = c . receive_data ( f . serialize ( ) * [number] ) [EOL] [EOL] [comment] [EOL] c . open_outbound_streams [EOL] [EOL] [comment] [EOL] events += c . receive_data ( f . serialize ( ) * [number] ) [EOL] [EOL] assert len ( events ) == [number] [EOL] event = events [ [number] ] [EOL] [EOL] assert isinstance ( event , h2 . events . StreamReset ) [EOL] [EOL] def test_receiving_low_stream_id_causes_goaway ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] c . initiate_connection ( ) [EOL] [EOL] f = frame_factory . build_headers_frame ( self . example_request_headers , stream_id = [number] , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] f = frame_factory . build_headers_frame ( self . example_request_headers , stream_id = [number] , ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . StreamIDTooLowError ) as e : [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] assert e . value . stream_id == [number] [EOL] assert e . value . max_stream_id == [number] [EOL] [EOL] f = frame_factory . build_goaway_frame ( last_stream_id = [number] , error_code = h2 . errors . ErrorCodes . PROTOCOL_ERROR , ) [EOL] assert c . data_to_send ( ) == f . serialize ( ) [EOL] [EOL] def test_closed_stream_not_present_in_streams_dict ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] c . initiate_connection ( ) [EOL] [EOL] f = frame_factory . build_headers_frame ( self . example_request_headers ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] c . push_stream ( [number] , [number] , self . example_request_headers ) [EOL] c . reset_stream ( [number] ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] f = frame_factory . build_rst_stream_frame ( stream_id = [number] ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] assert not c . open_outbound_streams [EOL] [EOL] [comment] [EOL] assert not c . streams [EOL] [EOL] [EOL] class TestStreamsClosedByEndStream ( object ) : [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] example_response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] server_config = h2 . config . H2Configuration ( client_side = False ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ lambda self , ff : ff . build_data_frame ( [string] ) , lambda self , ff : ff . build_headers_frame ( self . example_request_headers , flags = [ [string] ] ) , lambda self , ff : ff . build_headers_frame ( self . example_request_headers ) , ] ) @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_frames_after_recv_end_will_error ( self , frame_factory , frame , clear_streams ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] c . initiate_connection ( ) [EOL] [EOL] f = frame_factory . build_headers_frame ( self . example_request_headers , flags = [ [string] ] ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_response_headers , end_stream = True ) [EOL] [EOL] if clear_streams : [EOL] [comment] [EOL] [comment] [EOL] c . open_inbound_streams [EOL] [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] f = frame ( self , frame_factory ) [EOL] with pytest . raises ( h2 . exceptions . ProtocolError ) : [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] f = frame_factory . build_goaway_frame ( last_stream_id = [number] , error_code = h2 . errors . ErrorCodes . STREAM_CLOSED , ) [EOL] assert c . data_to_send ( ) == f . serialize ( ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ lambda self , ff : ff . build_data_frame ( [string] ) , lambda self , ff : ff . build_headers_frame ( self . example_response_headers , flags = [ [string] ] ) , lambda self , ff : ff . build_headers_frame ( self . example_response_headers ) , ] ) @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_frames_after_send_end_will_error ( self , frame_factory , frame , clear_streams ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers , end_stream = True ) [EOL] [EOL] f = frame_factory . build_headers_frame ( self . example_response_headers , flags = [ [string] ] ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] if clear_streams : [EOL] [comment] [EOL] [comment] [EOL] c . open_outbound_streams [EOL] [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] f = frame ( self , frame_factory ) [EOL] with pytest . raises ( h2 . exceptions . ProtocolError ) : [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] f = frame_factory . build_goaway_frame ( last_stream_id = [number] , error_code = h2 . errors . ErrorCodes . STREAM_CLOSED , ) [EOL] assert c . data_to_send ( ) == f . serialize ( ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ lambda self , ff : ff . build_window_update_frame ( [number] , [number] ) , lambda self , ff : ff . build_rst_stream_frame ( [number] ) ] ) def test_frames_after_send_end_will_be_ignored ( self , frame_factory , frame ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] c . initiate_connection ( ) [EOL] [EOL] f = frame_factory . build_headers_frame ( self . example_request_headers , flags = [ [string] ] ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_response_headers , end_stream = True ) [EOL] [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] f = frame ( self , frame_factory ) [EOL] events = c . receive_data ( f . serialize ( ) ) [EOL] [EOL] assert not events [EOL] [EOL] [EOL] class TestStreamsClosedByRstStream ( object ) : [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] example_response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] server_config = h2 . config . H2Configuration ( client_side = False ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ lambda self , ff : ff . build_headers_frame ( self . example_request_headers ) , lambda self , ff : ff . build_headers_frame ( self . example_request_headers , flags = [ [string] ] ) , lambda self , ff : ff . build_data_frame ( [string] ) , lambda self , ff : ff . build_window_update_frame ( [number] , [number] ) , ] ) def test_resets_further_frames_after_recv_reset ( self , frame_factory , frame ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] c . initiate_connection ( ) [EOL] [EOL] header_frame = frame_factory . build_headers_frame ( self . example_request_headers , flags = [ [string] ] ) [EOL] c . receive_data ( header_frame . serialize ( ) ) [EOL] [EOL] c . send_headers ( stream_id = [number] , headers = self . example_response_headers , end_stream = False ) [EOL] [EOL] rst_frame = frame_factory . build_rst_stream_frame ( [number] , h2 . errors . ErrorCodes . STREAM_CLOSED ) [EOL] c . receive_data ( rst_frame . serialize ( ) ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] f = frame ( self , frame_factory ) [EOL] events = c . receive_data ( f . serialize ( ) ) [EOL] [EOL] rst_frame = frame_factory . build_rst_stream_frame ( [number] , h2 . errors . ErrorCodes . STREAM_CLOSED ) [EOL] assert not events [EOL] assert c . data_to_send ( ) == rst_frame . serialize ( ) [EOL] [EOL] events = c . receive_data ( f . serialize ( ) * [number] ) [EOL] assert not events [EOL] assert c . data_to_send ( ) == rst_frame . serialize ( ) * [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] c . open_outbound_streams [EOL] [EOL] events = c . receive_data ( f . serialize ( ) * [number] ) [EOL] assert not events [EOL] assert c . data_to_send ( ) == rst_frame . serialize ( ) * [number] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ lambda self , ff : ff . build_headers_frame ( self . example_request_headers ) , lambda self , ff : ff . build_headers_frame ( self . example_request_headers , flags = [ [string] ] ) , lambda self , ff : ff . build_data_frame ( [string] ) , lambda self , ff : ff . build_window_update_frame ( [number] , [number] ) , ] ) def test_resets_further_frames_after_send_reset ( self , frame_factory , frame ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] c . initiate_connection ( ) [EOL] [EOL] header_frame = frame_factory . build_headers_frame ( self . example_request_headers , flags = [ [string] ] ) [EOL] c . receive_data ( header_frame . serialize ( ) ) [EOL] [EOL] c . send_headers ( stream_id = [number] , headers = self . example_response_headers , end_stream = False ) [EOL] [EOL] c . reset_stream ( [number] , h2 . errors . ErrorCodes . INTERNAL_ERROR ) [EOL] [EOL] rst_frame = frame_factory . build_rst_stream_frame ( [number] , h2 . errors . ErrorCodes . STREAM_CLOSED ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] f = frame ( self , frame_factory ) [EOL] events = c . receive_data ( f . serialize ( ) ) [EOL] [EOL] rst_frame = frame_factory . build_rst_stream_frame ( [number] , h2 . errors . ErrorCodes . STREAM_CLOSED ) [EOL] assert not events [EOL] assert c . data_to_send ( ) == rst_frame . serialize ( ) [EOL] [EOL] events = c . receive_data ( f . serialize ( ) * [number] ) [EOL] assert not events [EOL] assert c . data_to_send ( ) == rst_frame . serialize ( ) * [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] c . open_outbound_streams [EOL] [EOL] events = c . receive_data ( f . serialize ( ) * [number] ) [EOL] assert not events [EOL] assert c . data_to_send ( ) == rst_frame . serialize ( ) * [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import itertools [EOL] import typing [EOL] [docstring] [EOL] import itertools [EOL] import functools [EOL] [EOL] import pytest [EOL] [EOL] [EOL] class CoroutineTestCase ( object ) : [EOL] [docstring] [EOL] def run_until_complete ( self , * coroutines ) : [EOL] [docstring] [EOL] looping_coroutines = itertools . cycle ( coroutines ) [EOL] data = None [EOL] [EOL] for coro in looping_coroutines : [EOL] try : [EOL] data = coro . send ( data ) [EOL] except StopIteration : [EOL] break [EOL] [EOL] for coro in coroutines : [EOL] try : [EOL] next ( coro ) [EOL] except StopIteration : [EOL] continue [EOL] else : [EOL] pytest . fail ( [string] % coro ) [EOL] [EOL] def server ( self , func ) : [EOL] [docstring] [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] c = func ( * args , ** kwargs ) [EOL] next ( c ) [EOL] return c [EOL] [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $itertools.cycle[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] import h2 . connection [EOL] import h2 . errors [EOL] import h2 . events [EOL] [EOL] [EOL] class TestStreamReset ( object ) : [EOL] [docstring] [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] example_response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] def test_reset_stream_keeps_header_state_correct ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] c . reset_stream ( stream_id = [number] ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] f = frame_factory . build_headers_frame ( headers = self . example_response_headers , stream_id = [number] ) [EOL] rst_frame = frame_factory . build_rst_stream_frame ( [number] , h2 . errors . ErrorCodes . STREAM_CLOSED ) [EOL] events = c . receive_data ( f . serialize ( ) ) [EOL] assert not events [EOL] assert c . data_to_send ( ) == rst_frame . serialize ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] f = frame_factory . build_headers_frame ( headers = self . example_response_headers , stream_id = [number] ) [EOL] event = c . receive_data ( f . serialize ( ) ) [ [number] ] [EOL] [EOL] assert isinstance ( event , h2 . events . ResponseReceived ) [EOL] assert event . stream_id == [number] [EOL] assert event . headers == self . example_response_headers [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) ] ) def test_reset_stream_keeps_flow_control_correct ( self , close_id , other_id , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] [comment] [EOL] initial_window = c . remote_flow_control_window ( stream_id = other_id ) [EOL] [EOL] f = frame_factory . build_headers_frame ( headers = self . example_response_headers , stream_id = close_id ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] c . reset_stream ( stream_id = close_id ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] f = frame_factory . build_data_frame ( data = [string] , stream_id = close_id ) [EOL] events = c . receive_data ( f . serialize ( ) ) [EOL] [EOL] rst_frame = frame_factory . build_rst_stream_frame ( close_id , h2 . errors . ErrorCodes . STREAM_CLOSED ) [EOL] assert not events [EOL] assert c . data_to_send ( ) == rst_frame . serialize ( ) [EOL] [EOL] new_window = c . remote_flow_control_window ( stream_id = other_id ) [EOL] assert initial_window - len ( [string] ) == new_window [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_reset_stream_automatically_resets_pushed_streams ( self , frame_factory , clear_streams ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] c . reset_stream ( stream_id = [number] ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] if clear_streams : [EOL] [comment] [EOL] [comment] [EOL] c . open_outbound_streams [EOL] [EOL] f = frame_factory . build_push_promise_frame ( stream_id = [number] , promised_stream_id = [number] , headers = self . example_request_headers , ) [EOL] events = c . receive_data ( f . serialize ( ) ) [EOL] assert not events [EOL] [EOL] f = frame_factory . build_rst_stream_frame ( stream_id = [number] , error_code = h2 . errors . ErrorCodes . REFUSED_STREAM , ) [EOL] assert c . data_to_send ( ) == f . serialize ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bytes,builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bytes,builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Type , Tuple , Any , List [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from hypothesis import given [EOL] from hypothesis . strategies import integers [EOL] [EOL] import h2 . config [EOL] import h2 . connection [EOL] import h2 . errors [EOL] import h2 . events [EOL] import h2 . exceptions [EOL] import h2 . settings [EOL] [EOL] [EOL] class TestFlowControl ( object ) : [EOL] [docstring] [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] server_config = h2 . config . H2Configuration ( client_side = False ) [EOL] [EOL] DEFAULT_FLOW_WINDOW = [number] [EOL] [EOL] def test_flow_control_initializes_properly ( self ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] assert c . local_flow_control_window ( [number] ) == self . DEFAULT_FLOW_WINDOW [EOL] assert c . remote_flow_control_window ( [number] ) == self . DEFAULT_FLOW_WINDOW [EOL] [EOL] def test_flow_control_decreases_with_sent_data ( self ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] c . send_data ( [number] , [string] ) [EOL] [EOL] remaining_length = self . DEFAULT_FLOW_WINDOW - len ( [string] ) [EOL] assert ( c . local_flow_control_window ( [number] ) == remaining_length ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] ] ) def test_flow_control_decreases_with_sent_data_with_padding ( self , pad_length ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] c . send_data ( [number] , [string] , pad_length = pad_length ) [EOL] remaining_length = ( self . DEFAULT_FLOW_WINDOW - len ( [string] ) - pad_length - [number] ) [EOL] assert c . local_flow_control_window ( [number] ) == remaining_length [EOL] [EOL] def test_flow_control_decreases_with_received_data ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] f1 = frame_factory . build_headers_frame ( self . example_request_headers ) [EOL] f2 = frame_factory . build_data_frame ( [string] ) [EOL] [EOL] c . receive_data ( f1 . serialize ( ) + f2 . serialize ( ) ) [EOL] [EOL] remaining_length = self . DEFAULT_FLOW_WINDOW - len ( [string] ) [EOL] assert ( c . remote_flow_control_window ( [number] ) == remaining_length ) [EOL] [EOL] def test_flow_control_decreases_with_padded_data ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] f1 = frame_factory . build_headers_frame ( self . example_request_headers ) [EOL] f2 = frame_factory . build_data_frame ( [string] , padding_len = [number] ) [EOL] [EOL] c . receive_data ( f1 . serialize ( ) + f2 . serialize ( ) ) [EOL] [EOL] remaining_length = ( self . DEFAULT_FLOW_WINDOW - len ( [string] ) - [number] - [number] ) [EOL] assert ( c . remote_flow_control_window ( [number] ) == remaining_length ) [EOL] [EOL] def test_flow_control_is_limited_by_connection ( self ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] c . send_data ( [number] , [string] ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] remaining_length = self . DEFAULT_FLOW_WINDOW - len ( [string] ) [EOL] assert ( c . local_flow_control_window ( [number] ) == remaining_length ) [EOL] [EOL] def test_remote_flow_control_is_limited_by_connection ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] f1 = frame_factory . build_headers_frame ( self . example_request_headers ) [EOL] f2 = frame_factory . build_data_frame ( [string] ) [EOL] f3 = frame_factory . build_headers_frame ( self . example_request_headers , stream_id = [number] , ) [EOL] c . receive_data ( f1 . serialize ( ) + f2 . serialize ( ) + f3 . serialize ( ) ) [EOL] [EOL] remaining_length = self . DEFAULT_FLOW_WINDOW - len ( [string] ) [EOL] assert ( c . remote_flow_control_window ( [number] ) == remaining_length ) [EOL] [EOL] def test_cannot_send_more_data_than_window ( self ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] c . outbound_flow_control_window = [number] [EOL] [EOL] with pytest . raises ( h2 . exceptions . FlowControlError ) : [EOL] c . send_data ( [number] , [string] ) [EOL] [EOL] def test_increasing_connection_window_allows_sending ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] c . outbound_flow_control_window = [number] [EOL] [EOL] with pytest . raises ( h2 . exceptions . FlowControlError ) : [EOL] c . send_data ( [number] , [string] ) [EOL] [EOL] f = frame_factory . build_window_update_frame ( stream_id = [number] , increment = [number] , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] c . clear_outbound_data_buffer ( ) [EOL] c . send_data ( [number] , [string] ) [EOL] assert c . data_to_send ( ) [EOL] [EOL] def test_increasing_stream_window_allows_sending ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] c . _get_stream_by_id ( [number] ) . outbound_flow_control_window = [number] [EOL] [EOL] with pytest . raises ( h2 . exceptions . FlowControlError ) : [EOL] c . send_data ( [number] , [string] ) [EOL] [EOL] f = frame_factory . build_window_update_frame ( stream_id = [number] , increment = [number] , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] c . clear_outbound_data_buffer ( ) [EOL] c . send_data ( [number] , [string] ) [EOL] assert c . data_to_send ( ) [EOL] [EOL] def test_flow_control_shrinks_in_response_to_settings ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] assert c . local_flow_control_window ( [number] ) == [number] [EOL] [EOL] f = frame_factory . build_settings_frame ( settings = { h2 . settings . SettingCodes . INITIAL_WINDOW_SIZE : [number] } ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] assert c . local_flow_control_window ( [number] ) == [number] [EOL] [EOL] def test_flow_control_grows_in_response_to_settings ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] [comment] [EOL] f = frame_factory . build_window_update_frame ( stream_id = [number] , increment = [number] ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] assert c . local_flow_control_window ( [number] ) == [number] [EOL] [EOL] f = frame_factory . build_settings_frame ( settings = { h2 . settings . SettingCodes . INITIAL_WINDOW_SIZE : [number] } ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] assert c . local_flow_control_window ( [number] ) == [number] [EOL] [EOL] def test_flow_control_settings_blocked_by_conn_window ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] assert c . local_flow_control_window ( [number] ) == [number] [EOL] [EOL] f = frame_factory . build_settings_frame ( settings = { h2 . settings . SettingCodes . INITIAL_WINDOW_SIZE : [number] } ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] assert c . local_flow_control_window ( [number] ) == [number] [EOL] [EOL] def test_new_streams_have_flow_control_per_settings ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] [EOL] f = frame_factory . build_settings_frame ( settings = { h2 . settings . SettingCodes . INITIAL_WINDOW_SIZE : [number] } ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] f = frame_factory . build_window_update_frame ( stream_id = [number] , increment = [number] ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] assert c . local_flow_control_window ( [number] ) == [number] [EOL] [EOL] def test_window_update_no_stream ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] [EOL] f = frame_factory . build_window_update_frame ( stream_id = [number] , increment = [number] ) [EOL] events = c . receive_data ( f . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] event = events [ [number] ] [EOL] [EOL] assert isinstance ( event , h2 . events . WindowUpdated ) [EOL] assert event . stream_id == [number] [EOL] assert event . delta == [number] [EOL] [EOL] def test_window_update_with_stream ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] [EOL] f1 = frame_factory . build_headers_frame ( self . example_request_headers ) [EOL] f2 = frame_factory . build_window_update_frame ( stream_id = [number] , increment = [number] ) [EOL] data = [string] . join ( map ( lambda f : f . serialize ( ) , [ f1 , f2 ] ) ) [EOL] events = c . receive_data ( data ) [EOL] [EOL] assert len ( events ) == [number] [EOL] event = events [ [number] ] [EOL] [EOL] assert isinstance ( event , h2 . events . WindowUpdated ) [EOL] assert event . stream_id == [number] [EOL] assert event . delta == [number] [EOL] [EOL] def test_we_can_increment_stream_flow_control ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers , end_stream = True ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] expected_frame = frame_factory . build_window_update_frame ( stream_id = [number] , increment = [number] ) [EOL] [EOL] events = c . increment_flow_control_window ( increment = [number] , stream_id = [number] ) [EOL] assert not events [EOL] assert c . data_to_send ( ) == expected_frame . serialize ( ) [EOL] [EOL] def test_we_can_increment_connection_flow_control ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers , end_stream = True ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] expected_frame = frame_factory . build_window_update_frame ( stream_id = [number] , increment = [number] ) [EOL] [EOL] events = c . increment_flow_control_window ( increment = [number] ) [EOL] assert not events [EOL] assert c . data_to_send ( ) == expected_frame . serialize ( ) [EOL] [EOL] def test_we_enforce_our_flow_control_window ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] [EOL] [comment] [EOL] c . update_settings ( { h2 . settings . SettingCodes . INITIAL_WINDOW_SIZE : [number] } ) [EOL] f = frame_factory . build_settings_frame ( { } , ack = True ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] f = frame_factory . build_headers_frame ( self . example_request_headers ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] c . clear_outbound_data_buffer ( ) [EOL] f = frame_factory . build_data_frame ( [string] * [number] ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . FlowControlError ) : [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] expected_frame = frame_factory . build_goaway_frame ( last_stream_id = [number] , error_code = h2 . errors . ErrorCodes . FLOW_CONTROL_ERROR , ) [EOL] assert c . data_to_send ( ) == expected_frame . serialize ( ) [EOL] [EOL] def test_shrink_remote_flow_control_settings ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] assert c . remote_flow_control_window ( [number] ) == [number] [EOL] [EOL] c . update_settings ( { h2 . settings . SettingCodes . INITIAL_WINDOW_SIZE : [number] } ) [EOL] [EOL] f = frame_factory . build_settings_frame ( { } , ack = True ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] assert c . remote_flow_control_window ( [number] ) == [number] [EOL] [EOL] def test_grow_remote_flow_control_settings ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] [comment] [EOL] c . increment_flow_control_window ( increment = [number] ) [EOL] [EOL] assert c . remote_flow_control_window ( [number] ) == [number] [EOL] [EOL] c . update_settings ( { h2 . settings . SettingCodes . INITIAL_WINDOW_SIZE : [number] } ) [EOL] f = frame_factory . build_settings_frame ( { } , ack = True ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] assert c . remote_flow_control_window ( [number] ) == [number] [EOL] [EOL] def test_new_streams_have_remote_flow_control ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] [EOL] c . update_settings ( { h2 . settings . SettingCodes . INITIAL_WINDOW_SIZE : [number] } ) [EOL] f = frame_factory . build_settings_frame ( { } , ack = True ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] c . increment_flow_control_window ( increment = [number] ) [EOL] [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] assert c . remote_flow_control_window ( [number] ) == [number] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , - [number] , [number] ** [number] ] ) def test_reject_bad_attempts_to_increment_flow_control ( self , increment ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers , end_stream = True ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) : [EOL] c . increment_flow_control_window ( increment = increment , stream_id = [number] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] c . increment_flow_control_window ( increment = increment ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] ] ) def test_reject_bad_remote_increments ( self , frame_factory , stream_id ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers , end_stream = True ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] f = frame_factory . build_window_update_frame ( stream_id = stream_id , increment = [number] ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . ProtocolError ) : [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] expected_frame = frame_factory . build_goaway_frame ( last_stream_id = [number] , error_code = h2 . errors . ErrorCodes . PROTOCOL_ERROR , ) [EOL] assert c . data_to_send ( ) == expected_frame . serialize ( ) [EOL] [EOL] def test_reject_increasing_connection_window_too_far ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] increment = [number] ** [number] - c . outbound_flow_control_window [EOL] [EOL] f = frame_factory . build_window_update_frame ( stream_id = [number] , increment = increment ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . FlowControlError ) : [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] expected_frame = frame_factory . build_goaway_frame ( last_stream_id = [number] , error_code = h2 . errors . ErrorCodes . FLOW_CONTROL_ERROR , ) [EOL] assert c . data_to_send ( ) == expected_frame . serialize ( ) [EOL] [EOL] def test_reject_increasing_stream_window_too_far ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] increment = [number] ** [number] - c . outbound_flow_control_window [EOL] [EOL] f = frame_factory . build_window_update_frame ( stream_id = [number] , increment = increment ) [EOL] [EOL] events = c . receive_data ( f . serialize ( ) ) [EOL] assert len ( events ) == [number] [EOL] [EOL] event = events [ [number] ] [EOL] assert isinstance ( event , h2 . events . StreamReset ) [EOL] assert event . stream_id == [number] [EOL] assert event . error_code == h2 . errors . ErrorCodes . FLOW_CONTROL_ERROR [EOL] assert not event . remote_reset [EOL] [EOL] expected_frame = frame_factory . build_rst_stream_frame ( stream_id = [number] , error_code = h2 . errors . ErrorCodes . FLOW_CONTROL_ERROR , ) [EOL] assert c . data_to_send ( ) == expected_frame . serialize ( ) [EOL] [EOL] def test_reject_overlarge_conn_window_settings ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] [EOL] [comment] [EOL] increment = [number] ** [number] - [number] - c . outbound_flow_control_window [EOL] [EOL] f = frame_factory . build_window_update_frame ( stream_id = [number] , increment = increment ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] f = frame_factory . build_settings_frame ( settings = { h2 . settings . SettingCodes . INITIAL_WINDOW_SIZE : self . DEFAULT_FLOW_WINDOW + [number] } ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] [comment] [EOL] events = c . receive_data ( f . serialize ( ) ) [EOL] assert len ( events ) == [number] [EOL] assert isinstance ( events [ [number] ] , h2 . events . RemoteSettingsChanged ) [EOL] [EOL] expected_frame = frame_factory . build_settings_frame ( settings = { } , ack = True ) [EOL] assert c . data_to_send ( ) == expected_frame . serialize ( ) [EOL] [EOL] def test_reject_overlarge_stream_window_settings ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] [comment] [EOL] increment = [number] ** [number] - [number] - c . outbound_flow_control_window [EOL] [EOL] f = frame_factory . build_window_update_frame ( stream_id = [number] , increment = increment ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] f = frame_factory . build_settings_frame ( settings = { h2 . settings . SettingCodes . INITIAL_WINDOW_SIZE : self . DEFAULT_FLOW_WINDOW + [number] } ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] with pytest . raises ( h2 . exceptions . FlowControlError ) : [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] expected_frame = frame_factory . build_goaway_frame ( last_stream_id = [number] , error_code = h2 . errors . ErrorCodes . FLOW_CONTROL_ERROR , ) [EOL] assert c . data_to_send ( ) == expected_frame . serialize ( ) [EOL] [EOL] def test_reject_local_overlarge_increase_connection_window ( self ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] [EOL] increment = [number] ** [number] - c . inbound_flow_control_window [EOL] [EOL] with pytest . raises ( h2 . exceptions . FlowControlError ) : [EOL] c . increment_flow_control_window ( increment = increment ) [EOL] [EOL] def test_reject_local_overlarge_increase_stream_window ( self ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] increment = [number] ** [number] - c . inbound_flow_control_window [EOL] [EOL] with pytest . raises ( h2 . exceptions . FlowControlError ) : [EOL] c . increment_flow_control_window ( increment = increment , stream_id = [number] ) [EOL] [EOL] [EOL] class TestAutomaticFlowControl ( object ) : [EOL] [docstring] [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] server_config = h2 . config . H2Configuration ( client_side = False ) [EOL] [EOL] DEFAULT_FLOW_WINDOW = [number] [EOL] [EOL] def _setup_connection_and_send_headers ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . initiate_connection ( ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] [EOL] c . update_settings ( { h2 . settings . SettingCodes . MAX_FRAME_SIZE : self . DEFAULT_FLOW_WINDOW } ) [EOL] settings_frame = frame_factory . build_settings_frame ( settings = { } , ack = True ) [EOL] c . receive_data ( settings_frame . serialize ( ) ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] headers_frame = frame_factory . build_headers_frame ( headers = self . example_request_headers ) [EOL] c . receive_data ( headers_frame . serialize ( ) ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] return c [EOL] [EOL] @ given ( stream_id = integers ( max_value = [number] ) ) def test_must_acknowledge_for_stream ( self , frame_factory , stream_id ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] frame_factory . refresh_encoder ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] c = self . _setup_connection_and_send_headers ( frame_factory ) [EOL] data_frame = frame_factory . build_data_frame ( [string] , flags = [ [string] ] ) [EOL] c . receive_data ( data_frame . serialize ( ) ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] c . acknowledge_received_data ( acknowledged_size = [number] , stream_id = stream_id ) [EOL] [EOL] @ given ( size = integers ( max_value = - [number] ) ) def test_cannot_acknowledge_less_than_zero ( self , frame_factory , size ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] frame_factory . refresh_encoder ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] c = self . _setup_connection_and_send_headers ( frame_factory ) [EOL] data_frame = frame_factory . build_data_frame ( [string] , flags = [ [string] ] ) [EOL] c . receive_data ( data_frame . serialize ( ) ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] c . acknowledge_received_data ( acknowledged_size = size , stream_id = [number] ) [EOL] [EOL] def test_acknowledging_small_chunks_does_nothing ( self , frame_factory ) : [EOL] [docstring] [EOL] c = self . _setup_connection_and_send_headers ( frame_factory ) [EOL] [EOL] data_frame = frame_factory . build_data_frame ( [string] , flags = [ [string] ] ) [EOL] data_event = c . receive_data ( data_frame . serialize ( ) ) [ [number] ] [EOL] [EOL] c . acknowledge_received_data ( data_event . flow_controlled_length , stream_id = [number] ) [EOL] [EOL] assert not c . data_to_send ( ) [EOL] [EOL] def test_acknowledging_no_data_does_nothing ( self , frame_factory ) : [EOL] [docstring] [EOL] c = self . _setup_connection_and_send_headers ( frame_factory ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] data_frame = frame_factory . build_data_frame ( [string] ) [EOL] c . receive_data ( data_frame . serialize ( ) ) [EOL] [EOL] c . acknowledge_received_data ( [number] , stream_id = [number] ) [EOL] assert not c . data_to_send ( ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_acknowledging_data_on_closed_stream ( self , frame_factory , force_cleanup ) : [EOL] [docstring] [EOL] c = self . _setup_connection_and_send_headers ( frame_factory ) [EOL] [EOL] data_to_send = [string] * self . DEFAULT_FLOW_WINDOW [EOL] data_frame = frame_factory . build_data_frame ( data_to_send ) [EOL] c . receive_data ( data_frame . serialize ( ) ) [EOL] [EOL] rst_frame = frame_factory . build_rst_stream_frame ( stream_id = [number] ) [EOL] c . receive_data ( rst_frame . serialize ( ) ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] if force_cleanup : [EOL] [comment] [EOL] [comment] [EOL] assert c . open_outbound_streams == [number] [EOL] [EOL] c . acknowledge_received_data ( [number] , stream_id = [number] ) [EOL] [EOL] expected = frame_factory . build_window_update_frame ( stream_id = [number] , increment = [number] ) [EOL] assert c . data_to_send ( ) == expected . serialize ( ) [EOL] [EOL] def test_acknowledging_streams_we_never_saw ( self , frame_factory ) : [EOL] [docstring] [EOL] c = self . _setup_connection_and_send_headers ( frame_factory ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . NoSuchStreamError ) : [EOL] c . acknowledge_received_data ( [number] , stream_id = [number] ) [EOL] [EOL] @ given ( integers ( min_value = [number] , max_value = DEFAULT_FLOW_WINDOW ) ) def test_acknowledging_1024_bytes_when_empty_increments ( self , frame_factory , increment ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] frame_factory . refresh_encoder ( ) [EOL] [EOL] c = self . _setup_connection_and_send_headers ( frame_factory ) [EOL] [EOL] data_to_send = [string] * self . DEFAULT_FLOW_WINDOW [EOL] data_frame = frame_factory . build_data_frame ( data_to_send ) [EOL] c . receive_data ( data_frame . serialize ( ) ) [EOL] [EOL] c . acknowledge_received_data ( increment , stream_id = [number] ) [EOL] [EOL] first_expected = frame_factory . build_window_update_frame ( stream_id = [number] , increment = increment ) [EOL] second_expected = frame_factory . build_window_update_frame ( stream_id = [number] , increment = increment ) [EOL] expected_data = [string] . join ( [ first_expected . serialize ( ) , second_expected . serialize ( ) ] ) [EOL] assert c . data_to_send ( ) == expected_data [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ given ( integers ( min_value = [number] , max_value = ( DEFAULT_FLOW_WINDOW // [number] ) - [number] ) ) def test_connection_only_empty ( self , frame_factory , increment ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] frame_factory . refresh_encoder ( ) [EOL] [EOL] [comment] [EOL] c = self . _setup_connection_and_send_headers ( frame_factory ) [EOL] [EOL] for stream_id in [ [number] , [number] , [number] ] : [EOL] f = frame_factory . build_headers_frame ( headers = self . example_request_headers , stream_id = stream_id ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] data_to_send = [string] * ( self . DEFAULT_FLOW_WINDOW // [number] ) [EOL] for stream_id in [ [number] , [number] , [number] ] : [EOL] f = frame_factory . build_data_frame ( data_to_send , stream_id = stream_id ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] data_to_send = [string] * c . remote_flow_control_window ( [number] ) [EOL] data_frame = frame_factory . build_data_frame ( data_to_send , stream_id = [number] ) [EOL] c . receive_data ( data_frame . serialize ( ) ) [EOL] [EOL] [comment] [EOL] c . acknowledge_received_data ( increment , stream_id = [number] ) [EOL] [EOL] expected_data = frame_factory . build_window_update_frame ( stream_id = [number] , increment = increment ) . serialize ( ) [EOL] assert c . data_to_send ( ) == expected_data [EOL] [EOL] @ given ( integers ( min_value = [number] , max_value = DEFAULT_FLOW_WINDOW ) ) def test_mixing_update_forms ( self , frame_factory , increment ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] frame_factory . refresh_encoder ( ) [EOL] [EOL] [comment] [EOL] c = self . _setup_connection_and_send_headers ( frame_factory ) [EOL] data_to_send = [string] * self . DEFAULT_FLOW_WINDOW [EOL] data_frame = frame_factory . build_data_frame ( data_to_send ) [EOL] c . receive_data ( data_frame . serialize ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] c . increment_flow_control_window ( stream_id = None , increment = self . DEFAULT_FLOW_WINDOW ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] c . acknowledge_received_data ( increment , stream_id = [number] ) [EOL] [EOL] [comment] [EOL] expected_data = frame_factory . build_window_update_frame ( stream_id = [number] , increment = increment ) . serialize ( ) [EOL] assert c . data_to_send ( ) == expected_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import h2 . exceptions [EOL] [EOL] [EOL] class TestExceptions ( object ) : [EOL] def test_stream_id_too_low_prints_properly ( self ) : [EOL] x = h2 . exceptions . StreamIDTooLowError ( [number] , [number] ) [EOL] [EOL] assert [string] == str ( x ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] from hyperframe . frame import ( HeadersFrame , DataFrame , SettingsFrame , WindowUpdateFrame , PingFrame , GoAwayFrame , RstStreamFrame , PushPromiseFrame , PriorityFrame , ContinuationFrame , AltSvcFrame ) [EOL] from hpack . hpack import Encoder [EOL] [EOL] [EOL] SAMPLE_SETTINGS = { SettingsFrame . HEADER_TABLE_SIZE : [number] , SettingsFrame . ENABLE_PUSH : [number] , SettingsFrame . MAX_CONCURRENT_STREAMS : [number] , } [EOL] [EOL] [EOL] class FrameFactory ( object ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] self . encoder = Encoder ( ) [EOL] [EOL] def refresh_encoder ( self ) : [EOL] self . encoder = Encoder ( ) [EOL] [EOL] def preamble ( self ) : [EOL] return [string] [EOL] [EOL] def build_headers_frame ( self , headers , flags = [ ] , stream_id = [number] , ** priority_kwargs ) : [EOL] [docstring] [EOL] f = HeadersFrame ( stream_id ) [EOL] f . data = self . encoder . encode ( headers ) [EOL] f . flags . add ( [string] ) [EOL] for flag in flags : [EOL] f . flags . add ( flag ) [EOL] [EOL] for k , v in priority_kwargs . items ( ) : [EOL] setattr ( f , k , v ) [EOL] [EOL] return f [EOL] [EOL] def build_continuation_frame ( self , header_block , flags = [ ] , stream_id = [number] ) : [EOL] [docstring] [EOL] f = ContinuationFrame ( stream_id ) [EOL] f . data = header_block [EOL] f . flags = set ( flags ) [EOL] [EOL] return f [EOL] [EOL] def build_data_frame ( self , data , flags = None , stream_id = [number] , padding_len = [number] ) : [EOL] [docstring] [EOL] flags = set ( flags ) if flags is not None else set ( ) [EOL] f = DataFrame ( stream_id ) [EOL] f . data = data [EOL] f . flags = flags [EOL] [EOL] if padding_len : [EOL] flags . add ( [string] ) [EOL] f . pad_length = padding_len [EOL] [EOL] return f [EOL] [EOL] def build_settings_frame ( self , settings , ack = False ) : [EOL] [docstring] [EOL] f = SettingsFrame ( [number] ) [EOL] if ack : [EOL] f . flags . add ( [string] ) [EOL] [EOL] f . settings = settings [EOL] return f [EOL] [EOL] def build_window_update_frame ( self , stream_id , increment ) : [EOL] [docstring] [EOL] f = WindowUpdateFrame ( stream_id ) [EOL] f . window_increment = increment [EOL] return f [EOL] [EOL] def build_ping_frame ( self , ping_data , flags = None ) : [EOL] [docstring] [EOL] f = PingFrame ( [number] ) [EOL] f . opaque_data = ping_data [EOL] if flags : [EOL] f . flags = set ( flags ) [EOL] [EOL] return f [EOL] [EOL] def build_goaway_frame ( self , last_stream_id , error_code = [number] , additional_data = [string] ) : [EOL] [docstring] [EOL] f = GoAwayFrame ( [number] ) [EOL] f . error_code = error_code [EOL] f . last_stream_id = last_stream_id [EOL] f . additional_data = additional_data [EOL] return f [EOL] [EOL] def build_rst_stream_frame ( self , stream_id , error_code = [number] ) : [EOL] [docstring] [EOL] f = RstStreamFrame ( stream_id ) [EOL] f . error_code = error_code [EOL] return f [EOL] [EOL] def build_push_promise_frame ( self , stream_id , promised_stream_id , headers , flags = [ ] ) : [EOL] [docstring] [EOL] f = PushPromiseFrame ( stream_id ) [EOL] f . promised_stream_id = promised_stream_id [EOL] f . data = self . encoder . encode ( headers ) [EOL] f . flags = set ( flags ) [EOL] f . flags . add ( [string] ) [EOL] return f [EOL] [EOL] def build_priority_frame ( self , stream_id , weight , depends_on = [number] , exclusive = False ) : [EOL] [docstring] [EOL] f = PriorityFrame ( stream_id ) [EOL] f . depends_on = depends_on [EOL] f . stream_weight = weight [EOL] f . exclusive = exclusive [EOL] return f [EOL] [EOL] def build_alt_svc_frame ( self , stream_id , origin , field ) : [EOL] [docstring] [EOL] f = AltSvcFrame ( stream_id ) [EOL] f . origin = origin [EOL] f . field = field [EOL] return f [EOL] [EOL] def change_table_size ( self , new_size ) : [EOL] [docstring] [EOL] self . encoder . header_table_size = new_size [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type , Tuple , Any , List [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import h2 . config [EOL] import h2 . connection [EOL] import h2 . events [EOL] [EOL] [EOL] class TestRelatedEvents ( object ) : [EOL] [docstring] [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] example_response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] informational_response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] example_trailers = [ ( [string] , [string] ) , ] [EOL] [EOL] server_config = h2 . config . H2Configuration ( client_side = False ) [EOL] [EOL] def test_request_received_related_all ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . initiate_connection ( ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . example_request_headers , flags = [ [string] , [string] ] , stream_weight = [number] , depends_on = [number] , exclusive = False , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] other_events = events [ [number] : ] [EOL] [EOL] assert base_event . stream_ended in other_events [EOL] assert isinstance ( base_event . stream_ended , h2 . events . StreamEnded ) [EOL] assert base_event . priority_updated in other_events [EOL] assert isinstance ( base_event . priority_updated , h2 . events . PriorityUpdated ) [EOL] [EOL] def test_request_received_related_priority ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . initiate_connection ( ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . example_request_headers , flags = [ [string] ] , stream_weight = [number] , depends_on = [number] , exclusive = False , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] priority_updated_event = events [ [number] ] [EOL] [EOL] assert base_event . priority_updated is priority_updated_event [EOL] assert base_event . stream_ended is None [EOL] assert isinstance ( base_event . priority_updated , h2 . events . PriorityUpdated ) [EOL] [EOL] def test_request_received_related_stream_ended ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . initiate_connection ( ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . example_request_headers , flags = [ [string] ] , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] stream_ended_event = events [ [number] ] [EOL] [EOL] assert base_event . stream_ended is stream_ended_event [EOL] assert base_event . priority_updated is None [EOL] assert isinstance ( base_event . stream_ended , h2 . events . StreamEnded ) [EOL] [EOL] def test_response_received_related_nothing ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . example_response_headers , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] [EOL] assert base_event . stream_ended is None [EOL] assert base_event . priority_updated is None [EOL] [EOL] def test_response_received_related_all ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . example_response_headers , flags = [ [string] , [string] ] , stream_weight = [number] , depends_on = [number] , exclusive = False , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] other_events = events [ [number] : ] [EOL] [EOL] assert base_event . stream_ended in other_events [EOL] assert isinstance ( base_event . stream_ended , h2 . events . StreamEnded ) [EOL] assert base_event . priority_updated in other_events [EOL] assert isinstance ( base_event . priority_updated , h2 . events . PriorityUpdated ) [EOL] [EOL] def test_response_received_related_priority ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . example_response_headers , flags = [ [string] ] , stream_weight = [number] , depends_on = [number] , exclusive = False , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] priority_updated_event = events [ [number] ] [EOL] [EOL] assert base_event . priority_updated is priority_updated_event [EOL] assert base_event . stream_ended is None [EOL] assert isinstance ( base_event . priority_updated , h2 . events . PriorityUpdated ) [EOL] [EOL] def test_response_received_related_stream_ended ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . example_response_headers , flags = [ [string] ] , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] stream_ended_event = events [ [number] ] [EOL] [EOL] assert base_event . stream_ended is stream_ended_event [EOL] assert base_event . priority_updated is None [EOL] assert isinstance ( base_event . stream_ended , h2 . events . StreamEnded ) [EOL] [EOL] def test_trailers_received_related_all ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] f = frame_factory . build_headers_frame ( headers = self . example_response_headers , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . example_trailers , flags = [ [string] , [string] ] , stream_weight = [number] , depends_on = [number] , exclusive = False , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] other_events = events [ [number] : ] [EOL] [EOL] assert base_event . stream_ended in other_events [EOL] assert isinstance ( base_event . stream_ended , h2 . events . StreamEnded ) [EOL] assert base_event . priority_updated in other_events [EOL] assert isinstance ( base_event . priority_updated , h2 . events . PriorityUpdated ) [EOL] [EOL] def test_trailers_received_related_stream_ended ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] f = frame_factory . build_headers_frame ( headers = self . example_response_headers , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . example_trailers , flags = [ [string] ] , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] stream_ended_event = events [ [number] ] [EOL] [EOL] assert base_event . stream_ended is stream_ended_event [EOL] assert base_event . priority_updated is None [EOL] assert isinstance ( base_event . stream_ended , h2 . events . StreamEnded ) [EOL] [EOL] def test_informational_response_related_nothing ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . informational_response_headers , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] [EOL] assert base_event . priority_updated is None [EOL] [EOL] def test_informational_response_received_related_all ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] input_frame = frame_factory . build_headers_frame ( headers = self . informational_response_headers , flags = [ [string] ] , stream_weight = [number] , depends_on = [number] , exclusive = False , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] priority_updated_event = events [ [number] ] [EOL] [EOL] assert base_event . priority_updated is priority_updated_event [EOL] assert isinstance ( base_event . priority_updated , h2 . events . PriorityUpdated ) [EOL] [EOL] def test_data_received_normally_relates_to_nothing ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] f = frame_factory . build_headers_frame ( headers = self . example_response_headers , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] input_frame = frame_factory . build_data_frame ( data = [string] , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] [EOL] assert base_event . stream_ended is None [EOL] [EOL] def test_data_received_related_stream_ended ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] f = frame_factory . build_headers_frame ( headers = self . example_response_headers , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] input_frame = frame_factory . build_data_frame ( data = [string] , flags = [ [string] ] , ) [EOL] events = c . receive_data ( input_frame . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] base_event = events [ [number] ] [EOL] stream_ended_event = events [ [number] ] [EOL] [EOL] assert base_event . stream_ended is stream_ended_event [EOL] assert isinstance ( base_event . stream_ended , h2 . events . StreamEnded ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0
[comment] [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] [docstring] [EOL] import h2 . connection [EOL] import pytest [EOL] [EOL] [EOL] class TestHeadRequest ( object ) : [EOL] [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] example_response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] def test_non_zero_content_and_no_body ( self , frame_factory ) : [EOL] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers , end_stream = True ) [EOL] [EOL] f = frame_factory . build_headers_frame ( self . example_response_headers , flags = [ [string] ] ) [EOL] events = c . receive_data ( f . serialize ( ) ) [EOL] [EOL] assert len ( events ) == [number] [EOL] event = events [ [number] ] [EOL] [EOL] assert isinstance ( event , h2 . events . ResponseReceived ) [EOL] assert event . stream_id == [number] [EOL] assert event . headers == self . example_response_headers [EOL] [EOL] def test_reject_non_zero_content_and_body ( self , frame_factory ) : [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( [number] , self . example_request_headers ) [EOL] [EOL] headers = frame_factory . build_headers_frame ( self . example_response_headers ) [EOL] data = frame_factory . build_data_frame ( data = [string] ) [EOL] [EOL] c . receive_data ( headers . serialize ( ) ) [EOL] with pytest . raises ( h2 . exceptions . InvalidBodyLengthError ) : [EOL] c . receive_data ( data . serialize ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bytes,builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bytes,builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] from hypothesis import settings , HealthCheck [EOL] [EOL] import pytest [EOL] import helpers [EOL] [EOL] [comment] [EOL] settings . register_profile ( [string] , settings ( suppress_health_check = [ HealthCheck . too_slow ] ) ) [EOL] [EOL] [EOL] @ pytest . fixture def frame_factory ( ) : [EOL] return helpers . FrameFactory ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Type , Tuple , Any , List [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] import h2 [EOL] import h2 . config [EOL] import h2 . connection [EOL] [EOL] [EOL] class TestComplexClient ( object ) : [EOL] [docstring] [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] example_response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] def test_correctly_count_server_streams ( self , frame_factory ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] expected_inbound_streams = expected_outbound_streams = [number] [EOL] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] for stream_id in range ( [number] , [number] , [number] ) : [EOL] [comment] [EOL] c . send_headers ( stream_id , self . example_request_headers ) [EOL] expected_outbound_streams += [number] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] [comment] [EOL] [comment] [EOL] f = frame_factory . build_push_promise_frame ( stream_id = stream_id , promised_stream_id = stream_id + [number] , headers = self . example_request_headers , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] f = frame_factory . build_headers_frame ( stream_id = stream_id + [number] , headers = self . example_response_headers , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] expected_inbound_streams += [number] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] for stream_id in range ( [number] , [number] , - [number] ) : [EOL] [comment] [EOL] c . end_stream ( stream_id ) [EOL] [EOL] [comment] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] f = frame_factory . build_headers_frame ( stream_id = stream_id , headers = self . example_response_headers , flags = [ [string] ] , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] expected_outbound_streams -= [number] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] [comment] [EOL] f = frame_factory . build_data_frame ( stream_id = stream_id + [number] , data = [string] , flags = [ [string] ] , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] expected_inbound_streams -= [number] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] assert c . open_inbound_streams == [number] [EOL] assert c . open_outbound_streams == [number] [EOL] [EOL] [EOL] class TestComplexServer ( object ) : [EOL] [docstring] [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] example_response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] server_config = h2 . config . H2Configuration ( client_side = False ) [EOL] [EOL] def test_correctly_count_server_streams ( self , frame_factory ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] expected_inbound_streams = expected_outbound_streams = [number] [EOL] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] for stream_id in range ( [number] , [number] , [number] ) : [EOL] [comment] [EOL] f = frame_factory . build_headers_frame ( headers = self . example_request_headers , stream_id = stream_id , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] expected_inbound_streams += [number] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] [comment] [EOL] [comment] [EOL] c . push_stream ( stream_id , stream_id + [number] , self . example_request_headers ) [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] c . send_headers ( stream_id + [number] , self . example_response_headers ) [EOL] expected_outbound_streams += [number] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] for stream_id in range ( [number] , [number] , - [number] ) : [EOL] [comment] [EOL] f = frame_factory . build_data_frame ( data = [string] , flags = [ [string] ] , stream_id = stream_id , ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] [comment] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] c . send_data ( stream_id , [string] , end_stream = True ) [EOL] expected_inbound_streams -= [number] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] [comment] [EOL] c . send_data ( stream_id = stream_id + [number] , data = [string] , end_stream = True , ) [EOL] expected_outbound_streams -= [number] [EOL] assert c . open_inbound_streams == expected_inbound_streams [EOL] assert c . open_outbound_streams == expected_outbound_streams [EOL] [EOL] assert c . open_inbound_streams == [number] [EOL] assert c . open_outbound_streams == [number] [EOL] [EOL] [EOL] class TestContinuationFrames ( object ) : [EOL] [docstring] [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] server_config = h2 . config . H2Configuration ( client_side = False ) [EOL] [EOL] def _build_continuation_sequence ( self , headers , block_size , frame_factory ) : [EOL] f = frame_factory . build_headers_frame ( headers ) [EOL] header_data = f . data [EOL] chunks = [ header_data [ x : x + block_size ] for x in range ( [number] , len ( header_data ) , block_size ) ] [EOL] f . data = chunks . pop ( [number] ) [EOL] frames = [ frame_factory . build_continuation_frame ( c ) for c in chunks ] [EOL] f . flags = { [string] } [EOL] frames [ - [number] ] . flags . add ( [string] ) [EOL] frames . insert ( [number] , f ) [EOL] return frames [EOL] [EOL] def test_continuation_frame_basic ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . initiate_connection ( ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] [EOL] frames = self . _build_continuation_sequence ( headers = self . example_request_headers , block_size = [number] , frame_factory = frame_factory , ) [EOL] data = [string] . join ( f . serialize ( ) for f in frames ) [EOL] events = c . receive_data ( data ) [EOL] [EOL] assert len ( events ) == [number] [EOL] first_event , second_event = events [EOL] [EOL] assert isinstance ( first_event , h2 . events . RequestReceived ) [EOL] assert first_event . headers == self . example_request_headers [EOL] assert first_event . stream_id == [number] [EOL] [EOL] assert isinstance ( second_event , h2 . events . StreamEnded ) [EOL] assert second_event . stream_id == [number] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] ] ) def test_continuation_cannot_interleave_headers ( self , frame_factory , stream_id ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . initiate_connection ( ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] frames = self . _build_continuation_sequence ( headers = self . example_request_headers , block_size = [number] , frame_factory = frame_factory , ) [EOL] assert len ( frames ) > [number] [comment] [EOL] [EOL] bogus_frame = frame_factory . build_headers_frame ( headers = self . example_request_headers , stream_id = stream_id , flags = [ [string] ] , ) [EOL] frames . insert ( len ( frames ) - [number] , bogus_frame ) [EOL] data = [string] . join ( f . serialize ( ) for f in frames ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . ProtocolError ) as e : [EOL] c . receive_data ( data ) [EOL] [EOL] assert [string] in str ( e . value ) . lower ( ) [EOL] [EOL] def test_continuation_cannot_interleave_data ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . initiate_connection ( ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] frames = self . _build_continuation_sequence ( headers = self . example_request_headers , block_size = [number] , frame_factory = frame_factory , ) [EOL] assert len ( frames ) > [number] [comment] [EOL] [EOL] bogus_frame = frame_factory . build_data_frame ( data = [string] , stream_id = [number] , ) [EOL] frames . insert ( len ( frames ) - [number] , bogus_frame ) [EOL] data = [string] . join ( f . serialize ( ) for f in frames ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . ProtocolError ) as e : [EOL] c . receive_data ( data ) [EOL] [EOL] assert [string] in str ( e . value ) . lower ( ) [EOL] [EOL] def test_continuation_cannot_interleave_unknown_frame ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . initiate_connection ( ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] frames = self . _build_continuation_sequence ( headers = self . example_request_headers , block_size = [number] , frame_factory = frame_factory , ) [EOL] assert len ( frames ) > [number] [comment] [EOL] [EOL] bogus_frame = frame_factory . build_data_frame ( data = [string] , stream_id = [number] , ) [EOL] bogus_frame . type = [number] [EOL] frames . insert ( len ( frames ) - [number] , bogus_frame ) [EOL] data = [string] . join ( f . serialize ( ) for f in frames ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . ProtocolError ) as e : [EOL] c . receive_data ( data ) [EOL] [EOL] assert [string] in str ( e . value ) . lower ( ) [EOL] [EOL] def test_continuation_frame_multiple_blocks ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( config = self . server_config ) [EOL] c . initiate_connection ( ) [EOL] c . receive_data ( frame_factory . preamble ( ) ) [EOL] [EOL] for stream_id in range ( [number] , [number] , [number] ) : [EOL] frames = self . _build_continuation_sequence ( headers = self . example_request_headers , block_size = [number] , frame_factory = frame_factory , ) [EOL] for frame in frames : [EOL] frame . stream_id = stream_id [EOL] [EOL] data = [string] . join ( f . serialize ( ) for f in frames ) [EOL] events = c . receive_data ( data ) [EOL] [EOL] assert len ( events ) == [number] [EOL] first_event , second_event = events [EOL] [EOL] assert isinstance ( first_event , h2 . events . RequestReceived ) [EOL] assert first_event . headers == self . example_request_headers [EOL] assert first_event . stream_id == stream_id [EOL] [EOL] assert isinstance ( second_event , h2 . events . StreamEnded ) [EOL] assert second_event . stream_id == stream_id [EOL] [EOL] [EOL] class TestContinuationFramesPushPromise ( object ) : [EOL] [docstring] [EOL] example_request_headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] example_response_headers = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] def _build_continuation_sequence ( self , headers , block_size , frame_factory ) : [EOL] f = frame_factory . build_push_promise_frame ( stream_id = [number] , promised_stream_id = [number] , headers = headers ) [EOL] header_data = f . data [EOL] chunks = [ header_data [ x : x + block_size ] for x in range ( [number] , len ( header_data ) , block_size ) ] [EOL] f . data = chunks . pop ( [number] ) [EOL] frames = [ frame_factory . build_continuation_frame ( c ) for c in chunks ] [EOL] f . flags = { [string] } [EOL] frames [ - [number] ] . flags . add ( [string] ) [EOL] frames . insert ( [number] , f ) [EOL] return frames [EOL] [EOL] def test_continuation_frame_basic_push_promise ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] frames = self . _build_continuation_sequence ( headers = self . example_request_headers , block_size = [number] , frame_factory = frame_factory , ) [EOL] data = [string] . join ( f . serialize ( ) for f in frames ) [EOL] events = c . receive_data ( data ) [EOL] [EOL] assert len ( events ) == [number] [EOL] event = events [ [number] ] [EOL] [EOL] assert isinstance ( event , h2 . events . PushedStreamReceived ) [EOL] assert event . headers == self . example_request_headers [EOL] assert event . parent_stream_id == [number] [EOL] assert event . pushed_stream_id == [number] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ] ) def test_continuation_cannot_interleave_headers_pp ( self , frame_factory , stream_id ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] frames = self . _build_continuation_sequence ( headers = self . example_request_headers , block_size = [number] , frame_factory = frame_factory , ) [EOL] assert len ( frames ) > [number] [comment] [EOL] [EOL] bogus_frame = frame_factory . build_headers_frame ( headers = self . example_response_headers , stream_id = stream_id , flags = [ [string] ] , ) [EOL] frames . insert ( len ( frames ) - [number] , bogus_frame ) [EOL] data = [string] . join ( f . serialize ( ) for f in frames ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . ProtocolError ) as e : [EOL] c . receive_data ( data ) [EOL] [EOL] assert [string] in str ( e . value ) . lower ( ) [EOL] [EOL] def test_continuation_cannot_interleave_data ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] frames = self . _build_continuation_sequence ( headers = self . example_request_headers , block_size = [number] , frame_factory = frame_factory , ) [EOL] assert len ( frames ) > [number] [comment] [EOL] [EOL] bogus_frame = frame_factory . build_data_frame ( data = [string] , stream_id = [number] , ) [EOL] frames . insert ( len ( frames ) - [number] , bogus_frame ) [EOL] data = [string] . join ( f . serialize ( ) for f in frames ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . ProtocolError ) as e : [EOL] c . receive_data ( data ) [EOL] [EOL] assert [string] in str ( e . value ) . lower ( ) [EOL] [EOL] def test_continuation_cannot_interleave_unknown_frame ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] frames = self . _build_continuation_sequence ( headers = self . example_request_headers , block_size = [number] , frame_factory = frame_factory , ) [EOL] assert len ( frames ) > [number] [comment] [EOL] [EOL] bogus_frame = frame_factory . build_data_frame ( data = [string] , stream_id = [number] , ) [EOL] bogus_frame . type = [number] [EOL] frames . insert ( len ( frames ) - [number] , bogus_frame ) [EOL] data = [string] . join ( f . serialize ( ) for f in frames ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . ProtocolError ) as e : [EOL] c . receive_data ( data ) [EOL] [EOL] assert [string] in str ( e . value ) . lower ( ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_stream_remotely_closed_disallows_push_promise ( self , evict , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers , end_stream = True ) [EOL] [EOL] f = frame_factory . build_headers_frame ( stream_id = [number] , headers = self . example_response_headers , flags = [ [string] ] ) [EOL] c . receive_data ( f . serialize ( ) ) [EOL] c . clear_outbound_data_buffer ( ) [EOL] [EOL] if evict : [EOL] [comment] [EOL] [comment] [EOL] assert not c . open_outbound_streams [EOL] [EOL] f = frame_factory . build_push_promise_frame ( stream_id = [number] , promised_stream_id = [number] , headers = self . example_request_headers , ) [EOL] [EOL] with pytest . raises ( h2 . exceptions . ProtocolError ) : [EOL] c . receive_data ( f . serialize ( ) ) [EOL] [EOL] f = frame_factory . build_goaway_frame ( last_stream_id = [number] , error_code = h2 . errors . ErrorCodes . PROTOCOL_ERROR , ) [EOL] assert c . data_to_send ( ) == f . serialize ( ) [EOL] [EOL] def test_continuation_frame_multiple_push_promise ( self , frame_factory ) : [EOL] [docstring] [EOL] c = h2 . connection . H2Connection ( ) [EOL] c . initiate_connection ( ) [EOL] c . send_headers ( stream_id = [number] , headers = self . example_request_headers ) [EOL] [EOL] for promised_stream_id in range ( [number] , [number] , [number] ) : [EOL] frames = self . _build_continuation_sequence ( headers = self . example_request_headers , block_size = [number] , frame_factory = frame_factory , ) [EOL] frames [ [number] ] . promised_stream_id = promised_stream_id [EOL] data = [string] . join ( f . serialize ( ) for f in frames ) [EOL] events = c . receive_data ( data ) [EOL] [EOL] assert len ( events ) == [number] [EOL] event = events [ [number] ] [EOL] [EOL] assert isinstance ( event , h2 . events . PushedStreamReceived ) [EOL] assert event . headers == self . example_request_headers [EOL] assert event . parent_stream_id == [number] [EOL] assert event . pushed_stream_id == promised_stream_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bytes,builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bytes,builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Callable , Dict , List , Tuple , Any [EOL] import typing [EOL] import sys [EOL] import os [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = [string] [EOL] copyright = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = [string] [EOL] [comment] [EOL] release = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( [string] , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( [string] , [string] , [string] , [ [string] ] , [number] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] intersphinx_mapping = { [string] : ( [string] , None ) , [string] : ( [string] , None ) , [string] : ( [string] , None ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import ssl [EOL] import typing [EOL] [docstring] [EOL] import h2 . connection [EOL] import socket [EOL] import ssl [EOL] [EOL] [EOL] def establish_tcp_connection ( ) : [EOL] [docstring] [EOL] return socket . create_connection ( ( [string] , [number] ) ) [EOL] [EOL] [EOL] def get_http2_ssl_context ( ) : [EOL] [docstring] [EOL] [comment] [EOL] ctx = ssl . create_default_context ( purpose = ssl . Purpose . SERVER_AUTH ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] ctx . options |= ( ssl . OP_NO_SSLv2 | ssl . OP_NO_SSLv3 | ssl . OP_NO_TLSv1 | ssl . OP_NO_TLSv1_1 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] ctx . options |= ssl . OP_NO_COMPRESSION [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ctx . set_ciphers ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] ctx . set_alpn_protocols ( [ [string] , [string] ] ) [EOL] [EOL] try : [EOL] ctx . set_npn_protocols ( [ [string] , [string] ] ) [EOL] except NotImplementedError : [EOL] pass [EOL] [EOL] return ctx [EOL] [EOL] [EOL] def negotiate_tls ( tcp_conn , context ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] tls_conn = context . wrap_socket ( tcp_conn , server_hostname = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] negotiated_protocol = tls_conn . selected_alpn_protocol ( ) [EOL] if negotiated_protocol is None : [EOL] negotiated_protocol = tls_conn . selected_npn_protocol ( ) [EOL] [EOL] if negotiated_protocol != [string] : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] return tls_conn [EOL] [EOL] [EOL] def main ( ) : [EOL] [comment] [EOL] context = get_http2_ssl_context ( ) [EOL] [EOL] [comment] [EOL] connection = establish_tcp_connection ( ) [EOL] [EOL] [comment] [EOL] tls_connection = negotiate_tls ( connection , context ) [EOL] [EOL] [comment] [EOL] http2_connection = h2 . connection . H2Connection ( ) [EOL] [EOL] [comment] [EOL] http2_connection . initiate_connection ( ) [EOL] tls_connection . sendall ( http2_connection . data_to_send ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import socket [EOL] import ssl [EOL] import typing [EOL] [docstring] [EOL] import h2 . config [EOL] import h2 . connection [EOL] import socket [EOL] import ssl [EOL] [EOL] [EOL] def establish_tcp_connection ( ) : [EOL] [docstring] [EOL] bind_socket = socket . socket ( ) [EOL] bind_socket . bind ( ( [string] , [number] ) ) [EOL] bind_socket . listen ( [number] ) [EOL] return bind_socket . accept ( ) [ [number] ] [EOL] [EOL] [EOL] def get_http2_ssl_context ( ) : [EOL] [docstring] [EOL] [comment] [EOL] ctx = ssl . create_default_context ( purpose = ssl . Purpose . CLIENT_AUTH ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] ctx . options |= ( ssl . OP_NO_SSLv2 | ssl . OP_NO_SSLv3 | ssl . OP_NO_TLSv1 | ssl . OP_NO_TLSv1_1 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] ctx . options |= ssl . OP_NO_COMPRESSION [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ctx . set_ciphers ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] ctx . set_alpn_protocols ( [ [string] , [string] ] ) [EOL] [EOL] try : [EOL] ctx . set_npn_protocols ( [ [string] , [string] ] ) [EOL] except NotImplementedError : [EOL] pass [EOL] [EOL] return ctx [EOL] [EOL] [EOL] def negotiate_tls ( tcp_conn , context ) : [EOL] [docstring] [EOL] tls_conn = context . wrap_socket ( tcp_conn , server_side = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] negotiated_protocol = tls_conn . selected_alpn_protocol ( ) [EOL] if negotiated_protocol is None : [EOL] negotiated_protocol = tls_conn . selected_npn_protocol ( ) [EOL] [EOL] if negotiated_protocol != [string] : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] return tls_conn [EOL] [EOL] [EOL] def main ( ) : [EOL] [comment] [EOL] context = get_http2_ssl_context ( ) [EOL] [EOL] [comment] [EOL] connection = establish_tcp_connection ( ) [EOL] [EOL] [comment] [EOL] tls_connection = negotiate_tls ( connection , context ) [EOL] [EOL] [comment] [EOL] config = h2 . config . H2Configuration ( client_side = False ) [EOL] http2_connection = h2 . connection . H2Connection ( config = config ) [EOL] [EOL] [comment] [EOL] http2_connection . initiate_connection ( ) [EOL] tls_connection . sendall ( http2_connection . data_to_send ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Match , Any , Optional [EOL] import socket [EOL] import typing [EOL] [docstring] [EOL] import h2 . config [EOL] import h2 . connection [EOL] import re [EOL] import socket [EOL] [EOL] [EOL] def establish_tcp_connection ( ) : [EOL] [docstring] [EOL] bind_socket = socket . socket ( ) [EOL] bind_socket . bind ( ( [string] , [number] ) ) [EOL] bind_socket . listen ( [number] ) [EOL] return bind_socket . accept ( ) [ [number] ] [EOL] [EOL] [EOL] def receive_initial_request ( connection ) : [EOL] [docstring] [EOL] data = [string] [EOL] while not data . endswith ( [string] ) : [EOL] data += connection . recv ( [number] ) [EOL] [EOL] match = re . search ( [string] , data ) [EOL] if match is not None : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] match = re . search ( [string] , data ) [EOL] if match is not None : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] return match . group ( [number] ) [EOL] [EOL] [EOL] def send_upgrade_response ( connection ) : [EOL] [docstring] [EOL] response = ( [string] [string] [string] ) [EOL] connection . sendall ( response ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [comment] [EOL] connection = establish_tcp_connection ( ) [EOL] [EOL] [comment] [EOL] settings_header_value = receive_initial_request ( connection ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] config = h2 . config . H2Configuration ( client_side = False ) [EOL] h2_connection = h2 . connection . H2Connection ( config = config ) [EOL] h2_connection . initiate_upgrade_connection ( settings_header = settings_header_value ) [EOL] [EOL] [comment] [EOL] send_upgrade_response ( connection ) [EOL] [EOL] [comment] [EOL] connection . sendall ( h2_connection . data_to_send ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] main_loop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import binascii [EOL] import datetime [EOL] import ssl [EOL] from unittest import TestCase [EOL] from unittest . mock import patch [EOL] [EOL] from cryptography . exceptions import UnsupportedAlgorithm [EOL] from cryptography . hazmat . primitives import serialization [EOL] from cryptography . hazmat . primitives . asymmetric import ec [EOL] [EOL] from aioquic import tls [EOL] from aioquic . buffer import Buffer , BufferReadError [EOL] from aioquic . quic . configuration import QuicConfiguration [EOL] from aioquic . tls import ( Certificate , CertificateVerify , ClientHello , Context , EncryptedExtensions , Finished , NewSessionTicket , ServerHello , State , load_pem_x509_certificates , pull_block , pull_certificate , pull_certificate_verify , pull_client_hello , pull_encrypted_extensions , pull_finished , pull_new_session_ticket , pull_server_hello , push_certificate , push_certificate_verify , push_client_hello , push_encrypted_extensions , push_finished , push_new_session_ticket , push_server_hello , verify_certificate , ) [EOL] [EOL] from . utils import ( SERVER_CACERTFILE , SERVER_CERTFILE , SERVER_KEYFILE , generate_ec_certificate , load , ) [EOL] [EOL] CERTIFICATE_DATA = load ( [string] ) [ [number] : - [number] ] [EOL] CERTIFICATE_VERIFY_SIGNATURE = load ( [string] ) [ - [number] : ] [EOL] [EOL] CLIENT_QUIC_TRANSPORT_PARAMETERS = binascii . unhexlify ( [string] [string] ) [EOL] [EOL] SERVER_QUIC_TRANSPORT_PARAMETERS = binascii . unhexlify ( [string] [string] [string] ) [EOL] [EOL] SERVER_QUIC_TRANSPORT_PARAMETERS_2 = binascii . unhexlify ( [string] [string] [string] ) [EOL] [EOL] SERVER_QUIC_TRANSPORT_PARAMETERS_3 = binascii . unhexlify ( [string] [string] [string] ) [EOL] [EOL] [EOL] class BufferTest ( TestCase ) : [EOL] def test_pull_block_truncated ( self ) : [EOL] buf = Buffer ( capacity = [number] ) [EOL] with self . assertRaises ( BufferReadError ) : [EOL] with pull_block ( buf , [number] ) : [EOL] pass [EOL] [EOL] [EOL] def create_buffers ( ) : [EOL] return { tls . Epoch . INITIAL : Buffer ( capacity = [number] ) , tls . Epoch . HANDSHAKE : Buffer ( capacity = [number] ) , tls . Epoch . ONE_RTT : Buffer ( capacity = [number] ) , } [EOL] [EOL] [EOL] def merge_buffers ( buffers ) : [EOL] return [string] . join ( x . data for x in buffers . values ( ) ) [EOL] [EOL] [EOL] def reset_buffers ( buffers ) : [EOL] for k in buffers . keys ( ) : [EOL] buffers [ k ] . seek ( [number] ) [EOL] [EOL] [EOL] class ContextTest ( TestCase ) : [EOL] def create_client ( self , alpn_protocols = None , cadata = None , cafile = SERVER_CACERTFILE , ** kwargs ) : [EOL] client = Context ( alpn_protocols = alpn_protocols , cadata = cadata , cafile = cafile , is_client = True , ** kwargs ) [EOL] client . handshake_extensions = [ ( tls . ExtensionType . QUIC_TRANSPORT_PARAMETERS , CLIENT_QUIC_TRANSPORT_PARAMETERS , ) ] [EOL] self . assertEqual ( client . state , State . CLIENT_HANDSHAKE_START ) [EOL] return client [EOL] [EOL] def create_server ( self , alpn_protocols = None ) : [EOL] configuration = QuicConfiguration ( is_client = False ) [EOL] configuration . load_cert_chain ( SERVER_CERTFILE , SERVER_KEYFILE ) [EOL] [EOL] server = Context ( alpn_protocols = alpn_protocols , is_client = False , max_early_data = [number] ) [EOL] server . certificate = configuration . certificate [EOL] server . certificate_private_key = configuration . private_key [EOL] server . handshake_extensions = [ ( tls . ExtensionType . QUIC_TRANSPORT_PARAMETERS , SERVER_QUIC_TRANSPORT_PARAMETERS , ) ] [EOL] self . assertEqual ( server . state , State . SERVER_EXPECT_CLIENT_HELLO ) [EOL] return server [EOL] [EOL] def test_client_unexpected_message ( self ) : [EOL] client = self . create_client ( ) [EOL] [EOL] client . state = State . CLIENT_EXPECT_SERVER_HELLO [EOL] with self . assertRaises ( tls . AlertUnexpectedMessage ) : [EOL] client . handle_message ( [string] , create_buffers ( ) ) [EOL] [EOL] client . state = State . CLIENT_EXPECT_ENCRYPTED_EXTENSIONS [EOL] with self . assertRaises ( tls . AlertUnexpectedMessage ) : [EOL] client . handle_message ( [string] , create_buffers ( ) ) [EOL] [EOL] client . state = State . CLIENT_EXPECT_CERTIFICATE_REQUEST_OR_CERTIFICATE [EOL] with self . assertRaises ( tls . AlertUnexpectedMessage ) : [EOL] client . handle_message ( [string] , create_buffers ( ) ) [EOL] [EOL] client . state = State . CLIENT_EXPECT_CERTIFICATE_VERIFY [EOL] with self . assertRaises ( tls . AlertUnexpectedMessage ) : [EOL] client . handle_message ( [string] , create_buffers ( ) ) [EOL] [EOL] client . state = State . CLIENT_EXPECT_FINISHED [EOL] with self . assertRaises ( tls . AlertUnexpectedMessage ) : [EOL] client . handle_message ( [string] , create_buffers ( ) ) [EOL] [EOL] client . state = State . CLIENT_POST_HANDSHAKE [EOL] with self . assertRaises ( tls . AlertUnexpectedMessage ) : [EOL] client . handle_message ( [string] , create_buffers ( ) ) [EOL] [EOL] def test_client_bad_certificate_verify_data ( self ) : [EOL] client = self . create_client ( ) [EOL] server = self . create_server ( ) [EOL] [EOL] [comment] [EOL] client_buf = create_buffers ( ) [EOL] client . handle_message ( [string] , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_EXPECT_SERVER_HELLO ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] server_buf = create_buffers ( ) [EOL] server . handle_message ( server_input , server_buf ) [EOL] self . assertEqual ( server . state , State . SERVER_EXPECT_FINISHED ) [EOL] client_input = merge_buffers ( server_buf ) [EOL] reset_buffers ( server_buf ) [EOL] [EOL] [comment] [EOL] client_input = client_input [ : - [number] ] + bytes ( [number] ) + client_input [ - [number] : ] [EOL] [EOL] [comment] [EOL] with self . assertRaises ( tls . AlertDecryptError ) : [EOL] client . handle_message ( client_input , client_buf ) [EOL] [EOL] def test_client_bad_finished_verify_data ( self ) : [EOL] client = self . create_client ( ) [EOL] server = self . create_server ( ) [EOL] [EOL] [comment] [EOL] client_buf = create_buffers ( ) [EOL] client . handle_message ( [string] , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_EXPECT_SERVER_HELLO ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] server_buf = create_buffers ( ) [EOL] server . handle_message ( server_input , server_buf ) [EOL] self . assertEqual ( server . state , State . SERVER_EXPECT_FINISHED ) [EOL] client_input = merge_buffers ( server_buf ) [EOL] reset_buffers ( server_buf ) [EOL] [EOL] [comment] [EOL] client_input = client_input [ : - [number] ] + bytes ( [number] ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( tls . AlertDecryptError ) : [EOL] client . handle_message ( client_input , client_buf ) [EOL] [EOL] def test_server_unexpected_message ( self ) : [EOL] server = self . create_server ( ) [EOL] [EOL] server . state = State . SERVER_EXPECT_CLIENT_HELLO [EOL] with self . assertRaises ( tls . AlertUnexpectedMessage ) : [EOL] server . handle_message ( [string] , create_buffers ( ) ) [EOL] [EOL] server . state = State . SERVER_EXPECT_FINISHED [EOL] with self . assertRaises ( tls . AlertUnexpectedMessage ) : [EOL] server . handle_message ( [string] , create_buffers ( ) ) [EOL] [EOL] server . state = State . SERVER_POST_HANDSHAKE [EOL] with self . assertRaises ( tls . AlertUnexpectedMessage ) : [EOL] server . handle_message ( [string] , create_buffers ( ) ) [EOL] [EOL] def _server_fail_hello ( self , client , server ) : [EOL] [comment] [EOL] client_buf = create_buffers ( ) [EOL] client . handle_message ( [string] , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_EXPECT_SERVER_HELLO ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] server_buf = create_buffers ( ) [EOL] server . handle_message ( server_input , server_buf ) [EOL] [EOL] def test_server_unsupported_cipher_suite ( self ) : [EOL] client = self . create_client ( ) [EOL] client . _cipher_suites = [ tls . CipherSuite . AES_128_GCM_SHA256 ] [EOL] [EOL] server = self . create_server ( ) [EOL] server . _cipher_suites = [ tls . CipherSuite . AES_256_GCM_SHA384 ] [EOL] [EOL] with self . assertRaises ( tls . AlertHandshakeFailure ) as cm : [EOL] self . _server_fail_hello ( client , server ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] def test_server_unsupported_signature_algorithm ( self ) : [EOL] client = self . create_client ( ) [EOL] client . _signature_algorithms = [ tls . SignatureAlgorithm . ED448 ] [EOL] [EOL] server = self . create_server ( ) [EOL] [EOL] with self . assertRaises ( tls . AlertHandshakeFailure ) as cm : [EOL] self . _server_fail_hello ( client , server ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] def test_server_unsupported_version ( self ) : [EOL] client = self . create_client ( ) [EOL] client . _supported_versions = [ tls . TLS_VERSION_1_2 ] [EOL] [EOL] server = self . create_server ( ) [EOL] [EOL] with self . assertRaises ( tls . AlertProtocolVersion ) as cm : [EOL] self . _server_fail_hello ( client , server ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] def test_server_bad_finished_verify_data ( self ) : [EOL] client = self . create_client ( ) [EOL] server = self . create_server ( ) [EOL] [EOL] [comment] [EOL] client_buf = create_buffers ( ) [EOL] client . handle_message ( [string] , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_EXPECT_SERVER_HELLO ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] server_buf = create_buffers ( ) [EOL] server . handle_message ( server_input , server_buf ) [EOL] self . assertEqual ( server . state , State . SERVER_EXPECT_FINISHED ) [EOL] client_input = merge_buffers ( server_buf ) [EOL] reset_buffers ( server_buf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] client . handle_message ( client_input , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_POST_HANDSHAKE ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] server_input = server_input [ : - [number] ] + bytes ( [number] ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( tls . AlertDecryptError ) : [EOL] server . handle_message ( server_input , server_buf ) [EOL] [EOL] def _handshake ( self , client , server ) : [EOL] [comment] [EOL] client_buf = create_buffers ( ) [EOL] client . handle_message ( [string] , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_EXPECT_SERVER_HELLO ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] self . assertGreaterEqual ( len ( server_input ) , [number] ) [EOL] self . assertLessEqual ( len ( server_input ) , [number] ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] server_buf = create_buffers ( ) [EOL] server . handle_message ( server_input , server_buf ) [EOL] self . assertEqual ( server . state , State . SERVER_EXPECT_FINISHED ) [EOL] client_input = merge_buffers ( server_buf ) [EOL] self . assertGreaterEqual ( len ( client_input ) , [number] ) [EOL] self . assertLessEqual ( len ( client_input ) , [number] ) [EOL] [EOL] reset_buffers ( server_buf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] client . handle_message ( client_input , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_POST_HANDSHAKE ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] self . assertEqual ( len ( server_input ) , [number] ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] server . handle_message ( server_input , server_buf ) [EOL] self . assertEqual ( server . state , State . SERVER_POST_HANDSHAKE ) [EOL] client_input = merge_buffers ( server_buf ) [EOL] self . assertEqual ( len ( client_input ) , [number] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( client . _dec_key , server . _enc_key ) [EOL] self . assertEqual ( client . _enc_key , server . _dec_key ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( client . key_schedule . cipher_suite , tls . CipherSuite . AES_256_GCM_SHA384 ) [EOL] self . assertEqual ( server . key_schedule . cipher_suite , tls . CipherSuite . AES_256_GCM_SHA384 ) [EOL] [EOL] def test_handshake ( self ) : [EOL] client = self . create_client ( ) [EOL] server = self . create_server ( ) [EOL] [EOL] self . _handshake ( client , server ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( client . alpn_negotiated , None ) [EOL] self . assertEqual ( server . alpn_negotiated , None ) [EOL] [EOL] def test_handshake_ecdsa_secp256r1 ( self ) : [EOL] server = self . create_server ( ) [EOL] server . certificate , server . certificate_private_key = generate_ec_certificate ( common_name = [string] , curve = ec . SECP256R1 ) [EOL] [EOL] client = self . create_client ( cadata = server . certificate . public_bytes ( serialization . Encoding . PEM ) , cafile = None , ) [EOL] [EOL] self . _handshake ( client , server ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( client . alpn_negotiated , None ) [EOL] self . assertEqual ( server . alpn_negotiated , None ) [EOL] [EOL] def test_handshake_with_alpn ( self ) : [EOL] client = self . create_client ( alpn_protocols = [ [string] ] ) [EOL] server = self . create_server ( alpn_protocols = [ [string] , [string] ] ) [EOL] [EOL] self . _handshake ( client , server ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( client . alpn_negotiated , [string] ) [EOL] self . assertEqual ( server . alpn_negotiated , [string] ) [EOL] [EOL] def test_handshake_with_alpn_fail ( self ) : [EOL] client = self . create_client ( alpn_protocols = [ [string] ] ) [EOL] server = self . create_server ( alpn_protocols = [ [string] ] ) [EOL] [EOL] with self . assertRaises ( tls . AlertHandshakeFailure ) as cm : [EOL] self . _handshake ( client , server ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] def test_handshake_with_rsa_pkcs1_sha256_signature ( self ) : [EOL] client = self . create_client ( ) [EOL] client . _signature_algorithms = [ tls . SignatureAlgorithm . RSA_PKCS1_SHA256 ] [EOL] server = self . create_server ( ) [EOL] [EOL] self . _handshake ( client , server ) [EOL] [EOL] def test_handshake_with_certificate_error ( self ) : [EOL] client = self . create_client ( cafile = None ) [EOL] server = self . create_server ( ) [EOL] [EOL] with self . assertRaises ( tls . AlertBadCertificate ) as cm : [EOL] self . _handshake ( client , server ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] def test_handshake_with_certificate_no_verify ( self ) : [EOL] client = self . create_client ( cafile = None , verify_mode = ssl . CERT_NONE ) [EOL] server = self . create_server ( ) [EOL] [EOL] self . _handshake ( client , server ) [EOL] [EOL] def test_handshake_with_grease_group ( self ) : [EOL] client = self . create_client ( ) [EOL] client . _supported_groups = [ tls . Group . GREASE , tls . Group . SECP256R1 ] [EOL] server = self . create_server ( ) [EOL] [EOL] self . _handshake ( client , server ) [EOL] [EOL] def test_handshake_with_x25519 ( self ) : [EOL] client = self . create_client ( ) [EOL] client . _supported_groups = [ tls . Group . X25519 ] [EOL] server = self . create_server ( ) [EOL] [EOL] try : [EOL] self . _handshake ( client , server ) [EOL] except UnsupportedAlgorithm as exc : [EOL] self . skipTest ( str ( exc ) ) [EOL] [EOL] def test_handshake_with_x448 ( self ) : [EOL] client = self . create_client ( ) [EOL] client . _supported_groups = [ tls . Group . X448 ] [EOL] server = self . create_server ( ) [EOL] [EOL] try : [EOL] self . _handshake ( client , server ) [EOL] except UnsupportedAlgorithm as exc : [EOL] self . skipTest ( str ( exc ) ) [EOL] [EOL] def test_session_ticket ( self ) : [EOL] client_tickets = [ ] [EOL] server_tickets = [ ] [EOL] [EOL] def client_new_ticket ( ticket ) : [EOL] client_tickets . append ( ticket ) [EOL] [EOL] def server_get_ticket ( label ) : [EOL] for t in server_tickets : [EOL] if t . ticket == label : [EOL] return t [EOL] return None [EOL] [EOL] def server_new_ticket ( ticket ) : [EOL] server_tickets . append ( ticket ) [EOL] [EOL] def first_handshake ( ) : [EOL] client = self . create_client ( ) [EOL] client . new_session_ticket_cb = client_new_ticket [EOL] [EOL] server = self . create_server ( ) [EOL] server . new_session_ticket_cb = server_new_ticket [EOL] [EOL] self . _handshake ( client , server ) [EOL] [EOL] [comment] [EOL] self . assertFalse ( client . session_resumed ) [EOL] self . assertFalse ( server . session_resumed ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( len ( client_tickets ) , [number] ) [EOL] self . assertEqual ( len ( server_tickets ) , [number] ) [EOL] self . assertEqual ( client_tickets [ [number] ] . ticket , server_tickets [ [number] ] . ticket ) [EOL] self . assertEqual ( client_tickets [ [number] ] . resumption_secret , server_tickets [ [number] ] . resumption_secret ) [EOL] [EOL] def second_handshake ( ) : [EOL] client = self . create_client ( ) [EOL] client . session_ticket = client_tickets [ [number] ] [EOL] [EOL] server = self . create_server ( ) [EOL] server . get_session_ticket_cb = server_get_ticket [EOL] [EOL] [comment] [EOL] client_buf = create_buffers ( ) [EOL] client . handle_message ( [string] , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_EXPECT_SERVER_HELLO ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] self . assertGreaterEqual ( len ( server_input ) , [number] ) [EOL] self . assertLessEqual ( len ( server_input ) , [number] ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] server_buf = create_buffers ( ) [EOL] server . handle_message ( server_input , server_buf ) [EOL] self . assertEqual ( server . state , State . SERVER_EXPECT_FINISHED ) [EOL] client_input = merge_buffers ( server_buf ) [EOL] self . assertEqual ( len ( client_input ) , [number] ) [EOL] reset_buffers ( server_buf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] client . handle_message ( client_input , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_POST_HANDSHAKE ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] self . assertEqual ( len ( server_input ) , [number] ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] server . handle_message ( server_input , server_buf ) [EOL] self . assertEqual ( server . state , State . SERVER_POST_HANDSHAKE ) [EOL] client_input = merge_buffers ( server_buf ) [EOL] self . assertEqual ( len ( client_input ) , [number] ) [EOL] reset_buffers ( server_buf ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( client . _dec_key , server . _enc_key ) [EOL] self . assertEqual ( client . _enc_key , server . _dec_key ) [EOL] [EOL] [comment] [EOL] self . assertTrue ( client . session_resumed ) [EOL] self . assertTrue ( server . session_resumed ) [EOL] [EOL] def second_handshake_bad_binder ( ) : [EOL] client = self . create_client ( ) [EOL] client . session_ticket = client_tickets [ [number] ] [EOL] [EOL] server = self . create_server ( ) [EOL] server . get_session_ticket_cb = server_get_ticket [EOL] [EOL] [comment] [EOL] client_buf = create_buffers ( ) [EOL] client . handle_message ( [string] , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_EXPECT_SERVER_HELLO ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] self . assertGreaterEqual ( len ( server_input ) , [number] ) [EOL] self . assertLessEqual ( len ( server_input ) , [number] ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] server_input = server_input [ : - [number] ] + bytes ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] server_buf = create_buffers ( ) [EOL] with self . assertRaises ( tls . AlertHandshakeFailure ) as cm : [EOL] server . handle_message ( server_input , server_buf ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] def second_handshake_bad_pre_shared_key ( ) : [EOL] client = self . create_client ( ) [EOL] client . session_ticket = client_tickets [ [number] ] [EOL] [EOL] server = self . create_server ( ) [EOL] server . get_session_ticket_cb = server_get_ticket [EOL] [EOL] [comment] [EOL] client_buf = create_buffers ( ) [EOL] client . handle_message ( [string] , client_buf ) [EOL] self . assertEqual ( client . state , State . CLIENT_EXPECT_SERVER_HELLO ) [EOL] server_input = merge_buffers ( client_buf ) [EOL] self . assertGreaterEqual ( len ( server_input ) , [number] ) [EOL] self . assertLessEqual ( len ( server_input ) , [number] ) [EOL] reset_buffers ( client_buf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] server_buf = create_buffers ( ) [EOL] server . handle_message ( server_input , server_buf ) [EOL] self . assertEqual ( server . state , State . SERVER_EXPECT_FINISHED ) [EOL] [EOL] [comment] [EOL] buf = server_buf [ tls . Epoch . INITIAL ] [EOL] buf . seek ( buf . tell ( ) - [number] ) [EOL] buf . push_uint8 ( [number] ) [EOL] client_input = merge_buffers ( server_buf ) [EOL] self . assertEqual ( len ( client_input ) , [number] ) [EOL] reset_buffers ( server_buf ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( tls . AlertIllegalParameter ) : [EOL] client . handle_message ( client_input , client_buf ) [EOL] [EOL] first_handshake ( ) [EOL] second_handshake ( ) [EOL] second_handshake_bad_binder ( ) [EOL] second_handshake_bad_pre_shared_key ( ) [EOL] [EOL] [EOL] class TlsTest ( TestCase ) : [EOL] def test_pull_client_hello ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] hello = pull_client_hello ( buf ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( hello . random , binascii . unhexlify ( [string] ) , ) [EOL] self . assertEqual ( hello . legacy_session_id , binascii . unhexlify ( [string] ) , ) [EOL] self . assertEqual ( hello . cipher_suites , [ tls . CipherSuite . AES_256_GCM_SHA384 , tls . CipherSuite . AES_128_GCM_SHA256 , tls . CipherSuite . CHACHA20_POLY1305_SHA256 , ] , ) [EOL] self . assertEqual ( hello . legacy_compression_methods , [ tls . CompressionMethod . NULL ] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( hello . alpn_protocols , None ) [EOL] self . assertEqual ( hello . key_share , [ ( tls . Group . SECP256R1 , binascii . unhexlify ( [string] [string] [string] ) , ) ] , ) [EOL] self . assertEqual ( hello . psk_key_exchange_modes , [ tls . PskKeyExchangeMode . PSK_DHE_KE ] ) [EOL] self . assertEqual ( hello . server_name , None ) [EOL] self . assertEqual ( hello . signature_algorithms , [ tls . SignatureAlgorithm . RSA_PSS_RSAE_SHA256 , tls . SignatureAlgorithm . ECDSA_SECP256R1_SHA256 , tls . SignatureAlgorithm . RSA_PKCS1_SHA256 , tls . SignatureAlgorithm . RSA_PKCS1_SHA1 , ] , ) [EOL] self . assertEqual ( hello . supported_groups , [ tls . Group . SECP256R1 ] ) [EOL] self . assertEqual ( hello . supported_versions , [ tls . TLS_VERSION_1_3 , tls . TLS_VERSION_1_3_DRAFT_28 , tls . TLS_VERSION_1_3_DRAFT_27 , tls . TLS_VERSION_1_3_DRAFT_26 , ] , ) [EOL] [EOL] self . assertEqual ( hello . other_extensions , [ ( tls . ExtensionType . QUIC_TRANSPORT_PARAMETERS , CLIENT_QUIC_TRANSPORT_PARAMETERS , ) ] , ) [EOL] [EOL] def test_pull_client_hello_with_alpn ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] hello = pull_client_hello ( buf ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( hello . random , binascii . unhexlify ( [string] ) , ) [EOL] self . assertEqual ( hello . legacy_session_id , [string] ) [EOL] self . assertEqual ( hello . cipher_suites , [ tls . CipherSuite . AES_128_GCM_SHA256 , tls . CipherSuite . AES_256_GCM_SHA384 , tls . CipherSuite . CHACHA20_POLY1305_SHA256 , tls . CipherSuite . EMPTY_RENEGOTIATION_INFO_SCSV , ] , ) [EOL] self . assertEqual ( hello . legacy_compression_methods , [ tls . CompressionMethod . NULL ] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( hello . alpn_protocols , [ [string] ] ) [EOL] self . assertEqual ( hello . early_data , False ) [EOL] self . assertEqual ( hello . key_share , [ ( tls . Group . SECP256R1 , binascii . unhexlify ( [string] [string] [string] ) , ) ] , ) [EOL] self . assertEqual ( hello . psk_key_exchange_modes , [ tls . PskKeyExchangeMode . PSK_DHE_KE ] ) [EOL] self . assertEqual ( hello . server_name , [string] ) [EOL] self . assertEqual ( hello . signature_algorithms , [ tls . SignatureAlgorithm . ECDSA_SECP256R1_SHA256 , tls . SignatureAlgorithm . ECDSA_SECP384R1_SHA384 , tls . SignatureAlgorithm . ECDSA_SECP521R1_SHA512 , tls . SignatureAlgorithm . ED25519 , tls . SignatureAlgorithm . ED448 , tls . SignatureAlgorithm . RSA_PSS_PSS_SHA256 , tls . SignatureAlgorithm . RSA_PSS_PSS_SHA384 , tls . SignatureAlgorithm . RSA_PSS_PSS_SHA512 , tls . SignatureAlgorithm . RSA_PSS_RSAE_SHA256 , tls . SignatureAlgorithm . RSA_PSS_RSAE_SHA384 , tls . SignatureAlgorithm . RSA_PSS_RSAE_SHA512 , tls . SignatureAlgorithm . RSA_PKCS1_SHA256 , tls . SignatureAlgorithm . RSA_PKCS1_SHA384 , tls . SignatureAlgorithm . RSA_PKCS1_SHA512 , ] , ) [EOL] self . assertEqual ( hello . supported_groups , [ tls . Group . SECP256R1 , tls . Group . X25519 , tls . Group . SECP384R1 , tls . Group . SECP521R1 , ] , ) [EOL] self . assertEqual ( hello . supported_versions , [ tls . TLS_VERSION_1_3 ] ) [EOL] [EOL] [comment] [EOL] buf = Buffer ( [number] ) [EOL] push_client_hello ( buf , hello ) [EOL] self . assertEqual ( len ( buf . data ) , len ( load ( [string] ) ) ) [EOL] [EOL] def test_pull_client_hello_with_psk ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] hello = pull_client_hello ( buf ) [EOL] [EOL] self . assertEqual ( hello . early_data , True ) [EOL] self . assertEqual ( hello . pre_shared_key , tls . OfferedPsks ( identities = [ ( binascii . unhexlify ( [string] [string] [string] [string] ) , [number] , ) ] , binders = [ binascii . unhexlify ( [string] [string] ) ] , ) , ) [EOL] [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] [comment] [EOL] buf = Buffer ( [number] ) [EOL] push_client_hello ( buf , hello ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] def test_pull_client_hello_with_sni ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] hello = pull_client_hello ( buf ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( hello . random , binascii . unhexlify ( [string] ) , ) [EOL] self . assertEqual ( hello . legacy_session_id , binascii . unhexlify ( [string] ) , ) [EOL] self . assertEqual ( hello . cipher_suites , [ tls . CipherSuite . AES_256_GCM_SHA384 , tls . CipherSuite . AES_128_GCM_SHA256 , tls . CipherSuite . CHACHA20_POLY1305_SHA256 , ] , ) [EOL] self . assertEqual ( hello . legacy_compression_methods , [ tls . CompressionMethod . NULL ] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( hello . alpn_protocols , None ) [EOL] self . assertEqual ( hello . key_share , [ ( tls . Group . SECP256R1 , binascii . unhexlify ( [string] [string] [string] ) , ) ] , ) [EOL] self . assertEqual ( hello . psk_key_exchange_modes , [ tls . PskKeyExchangeMode . PSK_DHE_KE ] ) [EOL] self . assertEqual ( hello . server_name , [string] ) [EOL] self . assertEqual ( hello . signature_algorithms , [ tls . SignatureAlgorithm . RSA_PSS_RSAE_SHA256 , tls . SignatureAlgorithm . ECDSA_SECP256R1_SHA256 , tls . SignatureAlgorithm . RSA_PKCS1_SHA256 , tls . SignatureAlgorithm . RSA_PKCS1_SHA1 , ] , ) [EOL] self . assertEqual ( hello . supported_groups , [ tls . Group . SECP256R1 ] ) [EOL] self . assertEqual ( hello . supported_versions , [ tls . TLS_VERSION_1_3 , tls . TLS_VERSION_1_3_DRAFT_28 , tls . TLS_VERSION_1_3_DRAFT_27 , tls . TLS_VERSION_1_3_DRAFT_26 , ] , ) [EOL] [EOL] self . assertEqual ( hello . other_extensions , [ ( tls . ExtensionType . QUIC_TRANSPORT_PARAMETERS , CLIENT_QUIC_TRANSPORT_PARAMETERS , ) ] , ) [EOL] [EOL] [comment] [EOL] buf = Buffer ( [number] ) [EOL] push_client_hello ( buf , hello ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] def test_push_client_hello ( self ) : [EOL] hello = ClientHello ( random = binascii . unhexlify ( [string] ) , legacy_session_id = binascii . unhexlify ( [string] ) , cipher_suites = [ tls . CipherSuite . AES_256_GCM_SHA384 , tls . CipherSuite . AES_128_GCM_SHA256 , tls . CipherSuite . CHACHA20_POLY1305_SHA256 , ] , legacy_compression_methods = [ tls . CompressionMethod . NULL ] , key_share = [ ( tls . Group . SECP256R1 , binascii . unhexlify ( [string] [string] [string] ) , ) ] , psk_key_exchange_modes = [ tls . PskKeyExchangeMode . PSK_DHE_KE ] , signature_algorithms = [ tls . SignatureAlgorithm . RSA_PSS_RSAE_SHA256 , tls . SignatureAlgorithm . ECDSA_SECP256R1_SHA256 , tls . SignatureAlgorithm . RSA_PKCS1_SHA256 , tls . SignatureAlgorithm . RSA_PKCS1_SHA1 , ] , supported_groups = [ tls . Group . SECP256R1 ] , supported_versions = [ tls . TLS_VERSION_1_3 , tls . TLS_VERSION_1_3_DRAFT_28 , tls . TLS_VERSION_1_3_DRAFT_27 , tls . TLS_VERSION_1_3_DRAFT_26 , ] , other_extensions = [ ( tls . ExtensionType . QUIC_TRANSPORT_PARAMETERS , CLIENT_QUIC_TRANSPORT_PARAMETERS , ) ] , ) [EOL] [EOL] buf = Buffer ( [number] ) [EOL] push_client_hello ( buf , hello ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] def test_pull_server_hello ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] hello = pull_server_hello ( buf ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( hello . random , binascii . unhexlify ( [string] ) , ) [EOL] self . assertEqual ( hello . legacy_session_id , binascii . unhexlify ( [string] ) , ) [EOL] self . assertEqual ( hello . cipher_suite , tls . CipherSuite . AES_256_GCM_SHA384 ) [EOL] self . assertEqual ( hello . compression_method , tls . CompressionMethod . NULL ) [EOL] self . assertEqual ( hello . key_share , ( tls . Group . SECP256R1 , binascii . unhexlify ( [string] [string] [string] ) , ) , ) [EOL] self . assertEqual ( hello . pre_shared_key , None ) [EOL] self . assertEqual ( hello . supported_version , tls . TLS_VERSION_1_3 ) [EOL] [EOL] def test_pull_server_hello_with_psk ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] hello = pull_server_hello ( buf ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( hello . random , binascii . unhexlify ( [string] ) , ) [EOL] self . assertEqual ( hello . legacy_session_id , binascii . unhexlify ( [string] ) , ) [EOL] self . assertEqual ( hello . cipher_suite , tls . CipherSuite . AES_256_GCM_SHA384 ) [EOL] self . assertEqual ( hello . compression_method , tls . CompressionMethod . NULL ) [EOL] self . assertEqual ( hello . key_share , ( tls . Group . SECP256R1 , binascii . unhexlify ( [string] [string] [string] ) , ) , ) [EOL] self . assertEqual ( hello . pre_shared_key , [number] ) [EOL] self . assertEqual ( hello . supported_version , tls . TLS_VERSION_1_3 ) [EOL] [EOL] [comment] [EOL] buf = Buffer ( [number] ) [EOL] push_server_hello ( buf , hello ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] def test_pull_server_hello_with_unknown_extension ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] hello = pull_server_hello ( buf ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( hello , ServerHello ( random = binascii . unhexlify ( [string] ) , legacy_session_id = binascii . unhexlify ( [string] ) , cipher_suite = tls . CipherSuite . AES_256_GCM_SHA384 , compression_method = tls . CompressionMethod . NULL , key_share = ( tls . Group . SECP256R1 , binascii . unhexlify ( [string] [string] [string] ) , ) , supported_version = tls . TLS_VERSION_1_3 , other_extensions = [ ( [number] , [string] ) ] , ) , ) [EOL] [EOL] [comment] [EOL] buf = Buffer ( [number] ) [EOL] push_server_hello ( buf , hello ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] def test_push_server_hello ( self ) : [EOL] hello = ServerHello ( random = binascii . unhexlify ( [string] ) , legacy_session_id = binascii . unhexlify ( [string] ) , cipher_suite = tls . CipherSuite . AES_256_GCM_SHA384 , compression_method = tls . CompressionMethod . NULL , key_share = ( tls . Group . SECP256R1 , binascii . unhexlify ( [string] [string] [string] ) , ) , supported_version = tls . TLS_VERSION_1_3 , ) [EOL] [EOL] buf = Buffer ( [number] ) [EOL] push_server_hello ( buf , hello ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] def test_pull_new_session_ticket ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] new_session_ticket = pull_new_session_ticket ( buf ) [EOL] self . assertIsNotNone ( new_session_ticket ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( new_session_ticket , NewSessionTicket ( ticket_lifetime = [number] , ticket_age_add = [number] , ticket_nonce = [string] , ticket = binascii . unhexlify ( [string] ) , max_early_data_size = [number] , ) , ) [EOL] [EOL] [comment] [EOL] buf = Buffer ( [number] ) [EOL] push_new_session_ticket ( buf , new_session_ticket ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] def test_pull_new_session_ticket_with_unknown_extension ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] new_session_ticket = pull_new_session_ticket ( buf ) [EOL] self . assertIsNotNone ( new_session_ticket ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( new_session_ticket , NewSessionTicket ( ticket_lifetime = [number] , ticket_age_add = [number] , ticket_nonce = [string] , ticket = binascii . unhexlify ( [string] ) , max_early_data_size = [number] , other_extensions = [ ( [number] , [string] ) ] , ) , ) [EOL] [EOL] [comment] [EOL] buf = Buffer ( [number] ) [EOL] push_new_session_ticket ( buf , new_session_ticket ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] def test_encrypted_extensions ( self ) : [EOL] data = load ( [string] ) [EOL] buf = Buffer ( data = data ) [EOL] extensions = pull_encrypted_extensions ( buf ) [EOL] self . assertIsNotNone ( extensions ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( extensions , EncryptedExtensions ( other_extensions = [ ( tls . ExtensionType . QUIC_TRANSPORT_PARAMETERS , SERVER_QUIC_TRANSPORT_PARAMETERS , ) ] ) , ) [EOL] [EOL] [comment] [EOL] buf = Buffer ( capacity = [number] ) [EOL] push_encrypted_extensions ( buf , extensions ) [EOL] self . assertEqual ( buf . data , data ) [EOL] [EOL] def test_encrypted_extensions_with_alpn ( self ) : [EOL] data = load ( [string] ) [EOL] buf = Buffer ( data = data ) [EOL] extensions = pull_encrypted_extensions ( buf ) [EOL] self . assertIsNotNone ( extensions ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( extensions , EncryptedExtensions ( alpn_protocol = [string] , other_extensions = [ ( tls . ExtensionType . SERVER_NAME , [string] ) , ( tls . ExtensionType . QUIC_TRANSPORT_PARAMETERS , SERVER_QUIC_TRANSPORT_PARAMETERS_2 , ) , ] , ) , ) [EOL] [EOL] [comment] [EOL] buf = Buffer ( [number] ) [EOL] push_encrypted_extensions ( buf , extensions ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] def test_pull_encrypted_extensions_with_alpn_and_early_data ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] extensions = pull_encrypted_extensions ( buf ) [EOL] self . assertIsNotNone ( extensions ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( extensions , EncryptedExtensions ( alpn_protocol = [string] , early_data = True , other_extensions = [ ( tls . ExtensionType . SERVER_NAME , [string] ) , ( tls . ExtensionType . QUIC_TRANSPORT_PARAMETERS , SERVER_QUIC_TRANSPORT_PARAMETERS_3 , ) , ] , ) , ) [EOL] [EOL] [comment] [EOL] buf = Buffer ( [number] ) [EOL] push_encrypted_extensions ( buf , extensions ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] def test_pull_certificate ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] certificate = pull_certificate ( buf ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( certificate . request_context , [string] ) [EOL] self . assertEqual ( certificate . certificates , [ ( CERTIFICATE_DATA , [string] ) ] ) [EOL] [EOL] def test_push_certificate ( self ) : [EOL] certificate = Certificate ( request_context = [string] , certificates = [ ( CERTIFICATE_DATA , [string] ) ] ) [EOL] [EOL] buf = Buffer ( [number] ) [EOL] push_certificate ( buf , certificate ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] def test_pull_certificate_verify ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] verify = pull_certificate_verify ( buf ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( verify . algorithm , tls . SignatureAlgorithm . RSA_PSS_RSAE_SHA256 ) [EOL] self . assertEqual ( verify . signature , CERTIFICATE_VERIFY_SIGNATURE ) [EOL] [EOL] def test_push_certificate_verify ( self ) : [EOL] verify = CertificateVerify ( algorithm = tls . SignatureAlgorithm . RSA_PSS_RSAE_SHA256 , signature = CERTIFICATE_VERIFY_SIGNATURE , ) [EOL] [EOL] buf = Buffer ( [number] ) [EOL] push_certificate_verify ( buf , verify ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] def test_pull_finished ( self ) : [EOL] buf = Buffer ( data = load ( [string] ) ) [EOL] finished = pull_finished ( buf ) [EOL] self . assertTrue ( buf . eof ( ) ) [EOL] [EOL] self . assertEqual ( finished . verify_data , binascii . unhexlify ( [string] ) , ) [EOL] [EOL] def test_push_finished ( self ) : [EOL] finished = Finished ( verify_data = binascii . unhexlify ( [string] ) ) [EOL] [EOL] buf = Buffer ( [number] ) [EOL] push_finished ( buf , finished ) [EOL] self . assertEqual ( buf . data , load ( [string] ) ) [EOL] [EOL] [EOL] class VerifyCertificateTest ( TestCase ) : [EOL] def test_verify_certificate_chain ( self ) : [EOL] with open ( SERVER_CERTFILE , [string] ) as fp : [EOL] certificate = load_pem_x509_certificates ( fp . read ( ) ) [ [number] ] [EOL] [EOL] with patch ( [string] ) as mock_utcnow : [EOL] mock_utcnow . return_value = certificate . not_valid_before [EOL] [EOL] [comment] [EOL] with self . assertRaises ( tls . AlertBadCertificate ) as cm : [EOL] verify_certificate ( certificate = certificate , server_name = [string] ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] [comment] [EOL] verify_certificate ( cafile = SERVER_CACERTFILE , certificate = certificate , server_name = [string] , ) [EOL] [EOL] def test_verify_certificate_chain_self_signed ( self ) : [EOL] certificate , _ = generate_ec_certificate ( common_name = [string] , curve = ec . SECP256R1 ) [EOL] [EOL] with patch ( [string] ) as mock_utcnow : [EOL] mock_utcnow . return_value = certificate . not_valid_before [EOL] [EOL] [comment] [EOL] with self . assertRaises ( tls . AlertBadCertificate ) as cm : [EOL] verify_certificate ( certificate = certificate , server_name = [string] ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] [comment] [EOL] verify_certificate ( cadata = certificate . public_bytes ( serialization . Encoding . PEM ) , certificate = certificate , server_name = [string] , ) [EOL] [EOL] @ patch ( [string] ) def test_verify_certificate_chain_internal_error ( self , mock_store_new ) : [EOL] mock_store_new . return_value = tls . ffi . NULL [EOL] [EOL] certificate , _ = generate_ec_certificate ( common_name = [string] , curve = ec . SECP256R1 ) [EOL] [EOL] with self . assertRaises ( tls . AlertInternalError ) as cm : [EOL] verify_certificate ( cadata = certificate . public_bytes ( serialization . Encoding . PEM ) , certificate = certificate , server_name = [string] , ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] def test_verify_dates ( self ) : [EOL] certificate , _ = generate_ec_certificate ( common_name = [string] , curve = ec . SECP256R1 ) [EOL] cadata = certificate . public_bytes ( serialization . Encoding . PEM ) [EOL] [EOL] [comment] [EOL] with patch ( [string] ) as mock_utcnow : [EOL] mock_utcnow . return_value = ( certificate . not_valid_before - datetime . timedelta ( seconds = [number] ) ) [EOL] with self . assertRaises ( tls . AlertCertificateExpired ) as cm : [EOL] verify_certificate ( cadata = cadata , certificate = certificate , server_name = [string] ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] [comment] [EOL] with patch ( [string] ) as mock_utcnow : [EOL] mock_utcnow . return_value = certificate . not_valid_before [EOL] verify_certificate ( cadata = cadata , certificate = certificate , server_name = [string] ) [EOL] [EOL] with patch ( [string] ) as mock_utcnow : [EOL] mock_utcnow . return_value = certificate . not_valid_after [EOL] verify_certificate ( cadata = cadata , certificate = certificate , server_name = [string] ) [EOL] [EOL] [comment] [EOL] with patch ( [string] ) as mock_utcnow : [EOL] mock_utcnow . return_value = certificate . not_valid_after + datetime . timedelta ( seconds = [number] ) [EOL] with self . assertRaises ( tls . AlertCertificateExpired ) as cm : [EOL] verify_certificate ( cadata = cadata , certificate = certificate , server_name = [string] ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] def test_verify_subject ( self ) : [EOL] certificate , _ = generate_ec_certificate ( common_name = [string] , curve = ec . SECP256R1 ) [EOL] cadata = certificate . public_bytes ( serialization . Encoding . PEM ) [EOL] [EOL] with patch ( [string] ) as mock_utcnow : [EOL] mock_utcnow . return_value = certificate . not_valid_before [EOL] [EOL] [comment] [EOL] verify_certificate ( cadata = cadata , certificate = certificate , server_name = [string] ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( tls . AlertBadCertificate ) as cm : [EOL] verify_certificate ( cadata = cadata , certificate = certificate , server_name = [string] , ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] , ) [EOL] [EOL] with self . assertRaises ( tls . AlertBadCertificate ) as cm : [EOL] verify_certificate ( cadata = cadata , certificate = certificate , server_name = [string] ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] ) [EOL] [EOL] def test_verify_subject_with_subjaltname ( self ) : [EOL] certificate , _ = generate_ec_certificate ( alternative_names = [ [string] , [string] ] , common_name = [string] , curve = ec . SECP256R1 , ) [EOL] cadata = certificate . public_bytes ( serialization . Encoding . PEM ) [EOL] [EOL] with patch ( [string] ) as mock_utcnow : [EOL] mock_utcnow . return_value = certificate . not_valid_before [EOL] [EOL] [comment] [EOL] verify_certificate ( cadata = cadata , certificate = certificate , server_name = [string] ) [EOL] verify_certificate ( cadata = cadata , certificate = certificate , server_name = [string] ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( tls . AlertBadCertificate ) as cm : [EOL] verify_certificate ( cadata = cadata , certificate = certificate , server_name = [string] ) [EOL] self . assertEqual ( str ( cm . exception ) , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from aioquic . quic . crypto import CryptoPair [EOL] from aioquic . quic . packet import ( PACKET_TYPE_HANDSHAKE , PACKET_TYPE_INITIAL , PACKET_TYPE_ONE_RTT , QuicFrameType , QuicProtocolVersion , ) [EOL] from aioquic . quic . packet_builder import ( QuicPacketBuilder , QuicPacketBuilderStop , QuicSentPacket , ) [EOL] from aioquic . tls import Epoch [EOL] [EOL] [EOL] def create_builder ( is_client = False ) : [EOL] return QuicPacketBuilder ( host_cid = bytes ( [number] ) , is_client = is_client , packet_number = [number] , peer_cid = bytes ( [number] ) , peer_token = [string] , spin_bit = False , version = QuicProtocolVersion . DRAFT_25 , ) [EOL] [EOL] [EOL] def create_crypto ( ) : [EOL] crypto = CryptoPair ( ) [EOL] crypto . setup_initial ( bytes ( [number] ) , is_client = True , version = QuicProtocolVersion . DRAFT_25 ) [EOL] return crypto [EOL] [EOL] [EOL] class QuicPacketBuilderTest ( TestCase ) : [EOL] def test_long_header_empty ( self ) : [EOL] builder = create_builder ( ) [EOL] crypto = create_crypto ( ) [EOL] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] self . assertTrue ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( packets , [ ] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_long_header_padding ( self ) : [EOL] builder = create_builder ( is_client = True ) [EOL] crypto = create_crypto ( ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( [number] ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertTrue ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( packets , [ QuicSentPacket ( epoch = Epoch . INITIAL , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_INITIAL , sent_bytes = [number] , ) ] , ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_long_header_initial_client_2 ( self ) : [EOL] builder = create_builder ( is_client = True ) [EOL] crypto = create_crypto ( ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( builder . remaining_flight_space ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( [number] ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertTrue ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( packets , [ QuicSentPacket ( epoch = Epoch . INITIAL , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_INITIAL , sent_bytes = [number] , ) , QuicSentPacket ( epoch = Epoch . INITIAL , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_INITIAL , sent_bytes = [number] , ) , ] , ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_long_header_initial_server ( self ) : [EOL] builder = create_builder ( ) [EOL] crypto = create_crypto ( ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( [number] ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertTrue ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( packets , [ QuicSentPacket ( epoch = Epoch . INITIAL , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_INITIAL , sent_bytes = [number] , ) ] , ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_long_header_then_short_header ( self ) : [EOL] builder = create_builder ( ) [EOL] crypto = create_crypto ( ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( builder . remaining_flight_space ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertTrue ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . STREAM_BASE ) [EOL] buf . push_bytes ( bytes ( builder . remaining_flight_space ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] self . assertTrue ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( packets , [ QuicSentPacket ( epoch = Epoch . INITIAL , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_INITIAL , sent_bytes = [number] , ) , QuicSentPacket ( epoch = Epoch . ONE_RTT , in_flight = True , is_ack_eliciting = True , is_crypto_packet = False , packet_number = [number] , packet_type = PACKET_TYPE_ONE_RTT , sent_bytes = [number] , ) , ] , ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_long_header_then_long_header ( self ) : [EOL] builder = create_builder ( ) [EOL] crypto = create_crypto ( ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_INITIAL , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( [number] ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_HANDSHAKE , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( [number] ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( [number] ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( packets , [ QuicSentPacket ( epoch = Epoch . INITIAL , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_INITIAL , sent_bytes = [number] , ) , QuicSentPacket ( epoch = Epoch . HANDSHAKE , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_HANDSHAKE , sent_bytes = [number] , ) , QuicSentPacket ( epoch = Epoch . ONE_RTT , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_ONE_RTT , sent_bytes = [number] , ) , ] , ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_short_header_empty ( self ) : [EOL] builder = create_builder ( ) [EOL] crypto = create_crypto ( ) [EOL] [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] self . assertTrue ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( datagrams , [ ] ) [EOL] self . assertEqual ( packets , [ ] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_short_header_padding ( self ) : [EOL] builder = create_builder ( ) [EOL] crypto = create_crypto ( ) [EOL] [EOL] [comment] [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( builder . remaining_flight_space ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( packets , [ QuicSentPacket ( epoch = Epoch . ONE_RTT , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_ONE_RTT , sent_bytes = [number] , ) ] , ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_short_header_max_flight_bytes ( self ) : [EOL] [docstring] [EOL] builder = create_builder ( ) [EOL] builder . max_flight_bytes = [number] [EOL] [EOL] crypto = create_crypto ( ) [EOL] [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( builder . remaining_flight_space ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] with self . assertRaises ( QuicPacketBuilderStop ) : [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( packets , [ QuicSentPacket ( epoch = Epoch . ONE_RTT , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_ONE_RTT , sent_bytes = [number] , ) , ] , ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_short_header_max_flight_bytes_zero ( self ) : [EOL] [docstring] [EOL] builder = create_builder ( ) [EOL] builder . max_flight_bytes = [number] [EOL] [EOL] crypto = create_crypto ( ) [EOL] [EOL] with self . assertRaises ( QuicPacketBuilderStop ) : [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_short_header_max_flight_bytes_zero_ack ( self ) : [EOL] [docstring] [EOL] builder = create_builder ( ) [EOL] builder . max_flight_bytes = [number] [EOL] [EOL] crypto = create_crypto ( ) [EOL] [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] buf = builder . start_frame ( QuicFrameType . ACK ) [EOL] buf . push_bytes ( bytes ( [number] ) ) [EOL] [EOL] with self . assertRaises ( QuicPacketBuilderStop ) : [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( packets , [ QuicSentPacket ( epoch = Epoch . ONE_RTT , in_flight = False , is_ack_eliciting = False , is_crypto_packet = False , packet_number = [number] , packet_type = PACKET_TYPE_ONE_RTT , sent_bytes = [number] , ) , ] , ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_short_header_max_total_bytes_1 ( self ) : [EOL] [docstring] [EOL] builder = create_builder ( ) [EOL] builder . max_total_bytes = [number] [EOL] [EOL] crypto = create_crypto ( ) [EOL] [EOL] with self . assertRaises ( QuicPacketBuilderStop ) : [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( datagrams , [ ] ) [EOL] self . assertEqual ( packets , [ ] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_short_header_max_total_bytes_2 ( self ) : [EOL] [docstring] [EOL] builder = create_builder ( ) [EOL] builder . max_total_bytes = [number] [EOL] [EOL] crypto = create_crypto ( ) [EOL] [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( builder . remaining_flight_space ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] with self . assertRaises ( QuicPacketBuilderStop ) : [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( packets , [ QuicSentPacket ( epoch = Epoch . ONE_RTT , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_ONE_RTT , sent_bytes = [number] , ) ] , ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL] [EOL] def test_short_header_max_total_bytes_3 ( self ) : [EOL] builder = create_builder ( ) [EOL] builder . max_total_bytes = [number] [EOL] [EOL] crypto = create_crypto ( ) [EOL] [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( builder . remaining_flight_space ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] self . assertEqual ( builder . remaining_flight_space , [number] ) [EOL] buf = builder . start_frame ( QuicFrameType . CRYPTO ) [EOL] buf . push_bytes ( bytes ( builder . remaining_flight_space ) ) [EOL] self . assertFalse ( builder . packet_is_empty ) [EOL] [EOL] with self . assertRaises ( QuicPacketBuilderStop ) : [EOL] builder . start_packet ( PACKET_TYPE_ONE_RTT , crypto ) [EOL] [EOL] [comment] [EOL] datagrams , packets = builder . flush ( ) [EOL] self . assertEqual ( len ( datagrams ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( len ( datagrams [ [number] ] ) , [number] ) [EOL] self . assertEqual ( packets , [ QuicSentPacket ( epoch = Epoch . ONE_RTT , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_ONE_RTT , sent_bytes = [number] , ) , QuicSentPacket ( epoch = Epoch . ONE_RTT , in_flight = True , is_ack_eliciting = True , is_crypto_packet = True , packet_number = [number] , packet_type = PACKET_TYPE_ONE_RTT , sent_bytes = [number] , ) , ] , ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( builder . packet_number , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from aioquic . h0 . connection import H0_ALPN , H0Connection [EOL] from aioquic . h3 . events import DataReceived , HeadersReceived [EOL] [EOL] from . test_connection import client_and_server , transfer [EOL] [EOL] [EOL] def h0_client_and_server ( ) : [EOL] return client_and_server ( client_options = { [string] : H0_ALPN } , server_options = { [string] : H0_ALPN } , ) [EOL] [EOL] [EOL] def h0_transfer ( quic_sender , h0_receiver ) : [EOL] quic_receiver = h0_receiver . _quic [EOL] transfer ( quic_sender , quic_receiver ) [EOL] [EOL] [comment] [EOL] http_events = [ ] [EOL] event = quic_receiver . next_event ( ) [EOL] while event is not None : [EOL] http_events . extend ( h0_receiver . handle_event ( event ) ) [EOL] event = quic_receiver . next_event ( ) [EOL] return http_events [EOL] [EOL] [EOL] class H0ConnectionTest ( TestCase ) : [EOL] def test_connect ( self ) : [EOL] with h0_client_and_server ( ) as ( quic_client , quic_server ) : [EOL] h0_client = H0Connection ( quic_client ) [EOL] h0_server = H0Connection ( quic_server ) [EOL] [EOL] [comment] [EOL] stream_id = quic_client . get_next_available_stream_id ( ) [EOL] h0_client . send_headers ( stream_id = stream_id , headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , ) [EOL] h0_client . send_data ( stream_id = stream_id , data = [string] , end_stream = True ) [EOL] [EOL] [comment] [EOL] events = h0_transfer ( quic_client , h0_server ) [EOL] self . assertEqual ( len ( events ) , [number] ) [EOL] [EOL] self . assertTrue ( isinstance ( events [ [number] ] , HeadersReceived ) ) [EOL] self . assertEqual ( events [ [number] ] . headers , [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] self . assertEqual ( events [ [number] ] . stream_id , stream_id ) [EOL] self . assertEqual ( events [ [number] ] . stream_ended , False ) [EOL] [EOL] self . assertTrue ( isinstance ( events [ [number] ] , DataReceived ) ) [EOL] self . assertEqual ( events [ [number] ] . data , [string] ) [EOL] self . assertEqual ( events [ [number] ] . stream_id , stream_id ) [EOL] self . assertEqual ( events [ [number] ] . stream_ended , True ) [EOL] [EOL] [comment] [EOL] h0_server . send_headers ( stream_id = stream_id , headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ] , ) [EOL] h0_server . send_data ( stream_id = stream_id , data = [string] , end_stream = True , ) [EOL] [EOL] [comment] [EOL] events = h0_transfer ( quic_server , h0_client ) [EOL] self . assertEqual ( len ( events ) , [number] ) [EOL] [EOL] self . assertTrue ( isinstance ( events [ [number] ] , HeadersReceived ) ) [EOL] self . assertEqual ( events [ [number] ] . headers , [ ] ) [EOL] self . assertEqual ( events [ [number] ] . stream_id , stream_id ) [EOL] self . assertEqual ( events [ [number] ] . stream_ended , False ) [EOL] [EOL] self . assertTrue ( isinstance ( events [ [number] ] , DataReceived ) ) [EOL] self . assertEqual ( events [ [number] ] . data , [string] ) [EOL] self . assertEqual ( events [ [number] ] . stream_id , stream_id ) [EOL] self . assertEqual ( events [ [number] ] . stream_ended , True ) [EOL] [EOL] def test_headers_only ( self ) : [EOL] with h0_client_and_server ( ) as ( quic_client , quic_server ) : [EOL] h0_client = H0Connection ( quic_client ) [EOL] h0_server = H0Connection ( quic_server ) [EOL] [EOL] [comment] [EOL] stream_id = quic_client . get_next_available_stream_id ( ) [EOL] h0_client . send_headers ( stream_id = stream_id , headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , end_stream = True , ) [EOL] [EOL] [comment] [EOL] events = h0_transfer ( quic_client , h0_server ) [EOL] self . assertEqual ( len ( events ) , [number] ) [EOL] [EOL] self . assertTrue ( isinstance ( events [ [number] ] , HeadersReceived ) ) [EOL] self . assertEqual ( events [ [number] ] . headers , [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] self . assertEqual ( events [ [number] ] . stream_id , stream_id ) [EOL] self . assertEqual ( events [ [number] ] . stream_ended , False ) [EOL] [EOL] self . assertTrue ( isinstance ( events [ [number] ] , DataReceived ) ) [EOL] self . assertEqual ( events [ [number] ] . data , [string] ) [EOL] self . assertEqual ( events [ [number] ] . stream_id , stream_id ) [EOL] self . assertEqual ( events [ [number] ] . stream_ended , True ) [EOL] [EOL] [comment] [EOL] h0_server . send_headers ( stream_id = stream_id , headers = [ ( [string] , [string] ) , ( [string] , [string] ) , ] , end_stream = True , ) [EOL] [EOL] [comment] [EOL] events = h0_transfer ( quic_server , h0_client ) [EOL] self . assertEqual ( len ( events ) , [number] ) [EOL] [EOL] self . assertTrue ( isinstance ( events [ [number] ] , HeadersReceived ) ) [EOL] self . assertEqual ( events [ [number] ] . headers , [ ] ) [EOL] self . assertEqual ( events [ [number] ] . stream_id , stream_id ) [EOL] self . assertEqual ( events [ [number] ] . stream_ended , False ) [EOL] [EOL] self . assertTrue ( isinstance ( events [ [number] ] , DataReceived ) ) [EOL] self . assertEqual ( events [ [number] ] . data , [string] ) [EOL] self . assertEqual ( events [ [number] ] . stream_id , stream_id ) [EOL] self . assertEqual ( events [ [number] ] . stream_ended , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from . about import __version__ [EOL]	0 0 0 0 0 0 0 0 0
__author__ = [string] [EOL] __email__ = [string] [EOL] __license__ = [string] [EOL] __summary__ = [string] [EOL] __title__ = [string] [EOL] __uri__ = [string] [EOL] __version__ = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from . client import connect [comment] [EOL] from . protocol import QuicConnectionProtocol [comment] [EOL] from . server import serve [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , List , Sequence , Tuple , Any , Optional [EOL] import logger [EOL] import buffer [EOL] import builtins [EOL] import crypto [EOL] import tests [EOL] import typing [EOL] from dataclasses import dataclass , field [EOL] from enum import Enum [EOL] from typing import Any , Callable , Dict , List , Optional , Sequence , Tuple [EOL] [EOL] from . . buffer import Buffer , size_uint_var [EOL] from . . tls import Epoch [EOL] from . crypto import CryptoPair [EOL] from . logger import QuicLoggerTrace [EOL] from . packet import ( NON_ACK_ELICITING_FRAME_TYPES , NON_IN_FLIGHT_FRAME_TYPES , PACKET_NUMBER_MAX_SIZE , PACKET_TYPE_HANDSHAKE , PACKET_TYPE_INITIAL , PACKET_TYPE_MASK , QuicFrameType , is_long_header , ) [EOL] [EOL] PACKET_MAX_SIZE = [number] [EOL] PACKET_LENGTH_SEND_SIZE = [number] [EOL] PACKET_NUMBER_SEND_SIZE = [number] [EOL] [EOL] [EOL] QuicDeliveryHandler = Callable [ ... , None ] [EOL] [EOL] [EOL] class QuicDeliveryState ( Enum ) : [EOL] ACKED = [number] [EOL] LOST = [number] [EOL] EXPIRED = [number] [EOL] [EOL] [EOL] @ dataclass class QuicSentPacket : [EOL] epoch = ... [EOL] in_flight = ... [EOL] is_ack_eliciting = ... [EOL] is_crypto_packet = ... [EOL] packet_number = ... [EOL] packet_type = ... [EOL] sent_time = None [EOL] sent_bytes = [number] [EOL] [EOL] delivery_handlers = field ( default_factory = list ) [EOL] quic_logger_frames = field ( default_factory = list ) [EOL] [EOL] [EOL] class QuicPacketBuilderStop ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class QuicPacketBuilder : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * , host_cid , peer_cid , version , is_client , packet_number = [number] , peer_token = [string] , quic_logger = None , spin_bit = False , ) : [EOL] self . max_flight_bytes = None [EOL] self . max_total_bytes = None [EOL] self . quic_logger_frames = None [EOL] [EOL] self . _host_cid = host_cid [EOL] self . _is_client = is_client [EOL] self . _peer_cid = peer_cid [EOL] self . _peer_token = peer_token [EOL] self . _quic_logger = quic_logger [EOL] self . _spin_bit = spin_bit [EOL] self . _version = version [EOL] [EOL] [comment] [EOL] self . _datagrams = [ ] [EOL] self . _datagram_flight_bytes = [number] [EOL] self . _datagram_init = True [EOL] self . _packets = [ ] [EOL] self . _flight_bytes = [number] [EOL] self . _total_bytes = [number] [EOL] [EOL] [comment] [EOL] self . _header_size = [number] [EOL] self . _packet = None [EOL] self . _packet_crypto = None [EOL] self . _packet_long_header = False [EOL] self . _packet_number = packet_number [EOL] self . _packet_start = [number] [EOL] self . _packet_type = [number] [EOL] [EOL] self . _buffer = Buffer ( PACKET_MAX_SIZE ) [EOL] self . _buffer_capacity = PACKET_MAX_SIZE [EOL] self . _flight_capacity = PACKET_MAX_SIZE [EOL] [EOL] @ property def packet_is_empty ( self ) : [EOL] [docstring] [EOL] assert self . _packet is not None [EOL] packet_size = self . _buffer . tell ( ) - self . _packet_start [EOL] return packet_size <= self . _header_size [EOL] [EOL] @ property def packet_number ( self ) : [EOL] [docstring] [EOL] return self . _packet_number [EOL] [EOL] @ property def remaining_buffer_space ( self ) : [EOL] [docstring] [EOL] return ( self . _buffer_capacity - self . _buffer . tell ( ) - self . _packet_crypto . aead_tag_size ) [EOL] [EOL] @ property def remaining_flight_space ( self ) : [EOL] [docstring] [EOL] return ( self . _flight_capacity - self . _buffer . tell ( ) - self . _packet_crypto . aead_tag_size ) [EOL] [EOL] def flush ( self ) : [EOL] [docstring] [EOL] if self . _packet is not None : [EOL] self . _end_packet ( ) [EOL] self . _flush_current_datagram ( ) [EOL] [EOL] datagrams = self . _datagrams [EOL] packets = self . _packets [EOL] self . _datagrams = [ ] [EOL] self . _packets = [ ] [EOL] return datagrams , packets [EOL] [EOL] def start_frame ( self , frame_type , capacity = [number] , handler = None , handler_args = [ ] , ) : [EOL] [docstring] [EOL] if self . remaining_buffer_space < capacity or ( frame_type not in NON_IN_FLIGHT_FRAME_TYPES [EOL] and self . remaining_flight_space < capacity ) : [EOL] raise QuicPacketBuilderStop [EOL] [EOL] self . _buffer . push_uint_var ( frame_type ) [EOL] if frame_type not in NON_ACK_ELICITING_FRAME_TYPES : [EOL] self . _packet . is_ack_eliciting = True [EOL] if frame_type not in NON_IN_FLIGHT_FRAME_TYPES : [EOL] self . _packet . in_flight = True [EOL] if frame_type == QuicFrameType . CRYPTO : [EOL] self . _packet . is_crypto_packet = True [EOL] if handler is not None : [EOL] self . _packet . delivery_handlers . append ( ( handler , handler_args ) ) [EOL] return self . _buffer [EOL] [EOL] def start_packet ( self , packet_type , crypto ) : [EOL] [docstring] [EOL] buf = self . _buffer [EOL] [EOL] [comment] [EOL] if self . _packet is not None : [EOL] self . _end_packet ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] packet_start = buf . tell ( ) [EOL] if self . _buffer_capacity - packet_start < [number] : [EOL] self . _flush_current_datagram ( ) [EOL] packet_start = [number] [EOL] [EOL] [comment] [EOL] if self . _datagram_init : [EOL] if self . max_total_bytes is not None : [EOL] remaining_total_bytes = self . max_total_bytes - self . _total_bytes [EOL] if remaining_total_bytes < self . _buffer_capacity : [EOL] self . _buffer_capacity = remaining_total_bytes [EOL] [EOL] self . _flight_capacity = self . _buffer_capacity [EOL] if self . max_flight_bytes is not None : [EOL] remaining_flight_bytes = self . max_flight_bytes - self . _flight_bytes [EOL] if remaining_flight_bytes < self . _flight_capacity : [EOL] self . _flight_capacity = remaining_flight_bytes [EOL] self . _datagram_flight_bytes = [number] [EOL] self . _datagram_init = False [EOL] [EOL] [comment] [EOL] packet_long_header = is_long_header ( packet_type ) [EOL] if packet_long_header : [EOL] header_size = [number] + len ( self . _peer_cid ) + len ( self . _host_cid ) [EOL] if ( packet_type & PACKET_TYPE_MASK ) == PACKET_TYPE_INITIAL : [EOL] token_length = len ( self . _peer_token ) [EOL] header_size += size_uint_var ( token_length ) + token_length [EOL] else : [EOL] header_size = [number] + len ( self . _peer_cid ) [EOL] [EOL] [comment] [EOL] if packet_start + header_size >= self . _buffer_capacity : [EOL] raise QuicPacketBuilderStop [EOL] [EOL] [comment] [EOL] if packet_type == PACKET_TYPE_INITIAL : [EOL] epoch = Epoch . INITIAL [EOL] elif packet_type == PACKET_TYPE_HANDSHAKE : [EOL] epoch = Epoch . HANDSHAKE [EOL] else : [EOL] epoch = Epoch . ONE_RTT [EOL] [EOL] self . _header_size = header_size [EOL] self . _packet = QuicSentPacket ( epoch = epoch , in_flight = False , is_ack_eliciting = False , is_crypto_packet = False , packet_number = self . _packet_number , packet_type = packet_type , ) [EOL] self . _packet_crypto = crypto [EOL] self . _packet_long_header = packet_long_header [EOL] self . _packet_start = packet_start [EOL] self . _packet_type = packet_type [EOL] self . quic_logger_frames = self . _packet . quic_logger_frames [EOL] [EOL] buf . seek ( self . _packet_start + self . _header_size ) [EOL] [EOL] def _end_packet ( self ) : [EOL] [docstring] [EOL] buf = self . _buffer [EOL] packet_size = buf . tell ( ) - self . _packet_start [EOL] if packet_size > self . _header_size : [EOL] [comment] [EOL] if ( self . _is_client [EOL] and self . _packet_type == PACKET_TYPE_INITIAL [EOL] and self . _packet . is_crypto_packet ) : [EOL] if self . remaining_flight_space : [EOL] buf . push_bytes ( bytes ( self . remaining_flight_space ) ) [EOL] packet_size = buf . tell ( ) - self . _packet_start [EOL] self . _packet . in_flight = True [EOL] [EOL] [comment] [EOL] if self . _quic_logger is not None : [EOL] self . _packet . quic_logger_frames . append ( self . _quic_logger . encode_padding_frame ( ) ) [EOL] [EOL] [comment] [EOL] if self . _packet_long_header : [EOL] length = ( packet_size - self . _header_size + PACKET_NUMBER_SEND_SIZE + self . _packet_crypto . aead_tag_size ) [EOL] [EOL] buf . seek ( self . _packet_start ) [EOL] buf . push_uint8 ( self . _packet_type | ( PACKET_NUMBER_SEND_SIZE - [number] ) ) [EOL] buf . push_uint32 ( self . _version ) [EOL] buf . push_uint8 ( len ( self . _peer_cid ) ) [EOL] buf . push_bytes ( self . _peer_cid ) [EOL] buf . push_uint8 ( len ( self . _host_cid ) ) [EOL] buf . push_bytes ( self . _host_cid ) [EOL] if ( self . _packet_type & PACKET_TYPE_MASK ) == PACKET_TYPE_INITIAL : [EOL] buf . push_uint_var ( len ( self . _peer_token ) ) [EOL] buf . push_bytes ( self . _peer_token ) [EOL] buf . push_uint16 ( length | [number] ) [EOL] buf . push_uint16 ( self . _packet_number & [number] ) [EOL] else : [EOL] buf . seek ( self . _packet_start ) [EOL] buf . push_uint8 ( self . _packet_type | ( self . _spin_bit << [number] ) | ( self . _packet_crypto . key_phase << [number] ) | ( PACKET_NUMBER_SEND_SIZE - [number] ) ) [EOL] buf . push_bytes ( self . _peer_cid ) [EOL] buf . push_uint16 ( self . _packet_number & [number] ) [EOL] [EOL] [comment] [EOL] padding_size = ( PACKET_NUMBER_MAX_SIZE - PACKET_NUMBER_SEND_SIZE + self . _header_size - packet_size ) [EOL] if padding_size > [number] : [EOL] buf . seek ( self . _packet_start + packet_size ) [EOL] buf . push_bytes ( bytes ( padding_size ) ) [EOL] packet_size += padding_size [EOL] self . _packet . in_flight = True [EOL] [EOL] [comment] [EOL] if self . _quic_logger is not None : [EOL] self . _packet . quic_logger_frames . append ( self . _quic_logger . encode_padding_frame ( ) ) [EOL] [EOL] [comment] [EOL] plain = buf . data_slice ( self . _packet_start , self . _packet_start + packet_size ) [EOL] buf . seek ( self . _packet_start ) [EOL] buf . push_bytes ( self . _packet_crypto . encrypt_packet ( plain [ [number] : self . _header_size ] , plain [ self . _header_size : packet_size ] , self . _packet_number , ) ) [EOL] self . _packet . sent_bytes = buf . tell ( ) - self . _packet_start [EOL] self . _packets . append ( self . _packet ) [EOL] if self . _packet . in_flight : [EOL] self . _datagram_flight_bytes += self . _packet . sent_bytes [EOL] [EOL] [comment] [EOL] if not self . _packet_long_header : [EOL] self . _flush_current_datagram ( ) [EOL] [EOL] self . _packet_number += [number] [EOL] else : [EOL] [comment] [EOL] buf . seek ( self . _packet_start ) [EOL] [EOL] self . _packet = None [EOL] self . quic_logger_frames = None [EOL] [EOL] def _flush_current_datagram ( self ) : [EOL] datagram_bytes = self . _buffer . tell ( ) [EOL] if datagram_bytes : [EOL] self . _datagrams . append ( self . _buffer . data ) [EOL] self . _flight_bytes += self . _datagram_flight_bytes [EOL] self . _total_bytes += datagram_bytes [EOL] self . _datagram_init = True [EOL] self . _buffer . seek ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tls.Epoch$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Dict[typing.Any,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Dict[typing.Any,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Dict[typing.Any,typing.Any]]]$ 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any , Dict [EOL] import aioquic [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , List [EOL] [EOL] from aioquic . h3 . events import DataReceived , H3Event , Headers , HeadersReceived [EOL] from aioquic . quic . connection import QuicConnection [EOL] from aioquic . quic . events import QuicEvent , StreamDataReceived [EOL] [EOL] H0_ALPN = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] class H0Connection : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , quic ) : [EOL] self . _headers_received = { } [EOL] self . _is_client = quic . configuration . is_client [EOL] self . _quic = quic [EOL] [EOL] def handle_event ( self , event ) : [EOL] http_events = [ ] [EOL] [EOL] if isinstance ( event , StreamDataReceived ) and ( event . stream_id % [number] ) == [number] : [EOL] data = event . data [EOL] if not self . _headers_received . get ( event . stream_id , False ) : [EOL] if self . _is_client : [EOL] http_events . append ( HeadersReceived ( headers = [ ] , stream_ended = False , stream_id = event . stream_id ) ) [EOL] else : [EOL] method , path = data . rstrip ( ) . split ( [string] , [number] ) [EOL] http_events . append ( HeadersReceived ( headers = [ ( [string] , method ) , ( [string] , path ) ] , stream_ended = False , stream_id = event . stream_id , ) ) [EOL] data = [string] [EOL] self . _headers_received [ event . stream_id ] = True [EOL] [EOL] http_events . append ( DataReceived ( data = data , stream_ended = event . end_stream , stream_id = event . stream_id ) ) [EOL] [EOL] return http_events [EOL] [EOL] def send_data ( self , stream_id , data , end_stream ) : [EOL] self . _quic . send_stream_data ( stream_id , data , end_stream ) [EOL] [EOL] def send_headers ( self , stream_id , headers , end_stream = False ) : [EOL] if self . _is_client : [EOL] headers_dict = dict ( headers ) [EOL] data = headers_dict [ [string] ] + [string] + headers_dict [ [string] ] + [string] [EOL] else : [EOL] data = [string] [EOL] self . _quic . send_stream_data ( stream_id , data , end_stream ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0
class H3Error ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class NoAvailablePushIDError ( H3Error ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from more_itertools . more import * [comment] [EOL] from more_itertools . recipes import * [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] from typing import Literal , Dict , List , Tuple , Any [EOL] import subprocess [EOL] import typing_extensions [EOL] import typing [EOL] import py [EOL] import pytest [EOL] import sys [EOL] [EOL] pytest_plugins = [string] , [string] [EOL] [EOL] collect_ignore = [ [string] , [string] ] [EOL] [EOL] [EOL] def pytest_addoption ( parser ) : [EOL] group = parser . getgroup ( [string] , [string] ) [EOL] group . addoption ( [string] , action = [string] , dest = [string] , default = False , help = ( [string] ) ) [EOL] [EOL] @ pytest . fixture def sshhost ( request ) : [EOL] val = request . config . getvalue ( [string] ) [EOL] if val : [EOL] return val [EOL] py . test . skip ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] winpymap = { [string] : [string] , } [EOL] [EOL] [EOL] def getexecutable ( name , cache = { } ) : [EOL] try : [EOL] return cache [ name ] [EOL] except KeyError : [EOL] executable = py . path . local . sysfind ( name ) [EOL] if executable : [EOL] if name == [string] : [EOL] import subprocess [EOL] popen = subprocess . Popen ( [ str ( executable ) , [string] ] , universal_newlines = True , stderr = subprocess . PIPE ) [EOL] out , err = popen . communicate ( ) [EOL] if not err or [string] not in err : [EOL] executable = None [EOL] cache [ name ] = executable [EOL] return executable [EOL] [EOL] [EOL] @ pytest . fixture ( params = ( [string] , [string] , [string] ) ) def anypython ( request ) : [EOL] name = request . param [EOL] executable = getexecutable ( name ) [EOL] if executable is None : [EOL] if sys . platform == [string] : [EOL] executable = winpymap . get ( name , None ) [EOL] if executable : [EOL] executable = py . path . local ( executable ) [EOL] if executable . check ( ) : [EOL] return executable [EOL] py . test . skip ( [string] % ( name , ) ) [EOL] return executable [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import sys [EOL] if __name__ == [string] : [EOL] import pytest [EOL] sys . exit ( pytest . main ( ) ) [EOL] else : [EOL] import sys , pytest [EOL] sys . modules [ [string] ] = pytest [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import py [EOL] pydir = py . path . local ( py . __file__ ) . dirpath ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Match , Dict , List , Type , Tuple , Any , Pattern , KeysView , Optional [EOL] import tests [EOL] import subprocess [EOL] import time [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os , sys , time , re , calendar [EOL] import py [EOL] import subprocess [EOL] from py . _path import common [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class cache : [EOL] proplist = { } [EOL] info = { } [EOL] entries = { } [EOL] prop = { } [EOL] [EOL] class RepoEntry : [EOL] def __init__ ( self , url , rev , timestamp ) : [EOL] self . url = url [EOL] self . rev = rev [EOL] self . timestamp = timestamp [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . url , self . rev , self . timestamp ) [EOL] [EOL] class RepoCache : [EOL] [docstring] [EOL] timeout = [number] [comment] [EOL] [EOL] def __init__ ( self ) : [EOL] self . repos = [ ] [EOL] [EOL] def clear ( self ) : [EOL] self . repos = [ ] [EOL] [EOL] def put ( self , url , rev , timestamp = None ) : [EOL] if rev is None : [EOL] return [EOL] if timestamp is None : [EOL] timestamp = time . time ( ) [EOL] [EOL] for entry in self . repos : [EOL] if url == entry . url : [EOL] entry . timestamp = timestamp [EOL] entry . rev = rev [EOL] [comment] [EOL] break [EOL] else : [EOL] entry = RepoEntry ( url , rev , timestamp ) [EOL] self . repos . append ( entry ) [EOL] [comment] [EOL] [EOL] def get ( self , url ) : [EOL] now = time . time ( ) [EOL] for entry in self . repos : [EOL] if url . startswith ( entry . url ) : [EOL] if now < entry . timestamp + self . timeout : [EOL] [comment] [EOL] return entry . url , entry . rev [EOL] return entry . url , - [number] [EOL] return url , - [number] [EOL] [EOL] repositories = RepoCache ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] ALLOWED_CHARS = [string] [comment] [EOL] if sys . platform == [string] : [EOL] ALLOWED_CHARS += [string] [EOL] ALLOWED_CHARS_HOST = ALLOWED_CHARS + [string] [EOL] [EOL] def _getsvnversion ( ver = [ ] ) : [EOL] try : [EOL] return ver [ [number] ] [EOL] except IndexError : [EOL] v = py . process . cmdexec ( [string] ) [EOL] v . strip ( ) [EOL] v = [string] . join ( v . split ( [string] ) [ : [number] ] ) [EOL] ver . append ( v ) [EOL] return v [EOL] [EOL] def _escape_helper ( text ) : [EOL] text = str ( text ) [EOL] if sys . platform != [string] : [EOL] text = str ( text ) . replace ( [string] , [string] ) [EOL] return text [EOL] [EOL] def _check_for_bad_chars ( text , allowed_chars = ALLOWED_CHARS ) : [EOL] for c in str ( text ) : [EOL] if c . isalnum ( ) : [EOL] continue [EOL] if c in allowed_chars : [EOL] continue [EOL] return True [EOL] return False [EOL] [EOL] def checkbadchars ( url ) : [EOL] [comment] [EOL] proto , uri = url . split ( [string] , [number] ) [EOL] if proto != [string] : [EOL] host , uripath = uri . split ( [string] , [number] ) [EOL] [comment] [EOL] if ( _check_for_bad_chars ( host , ALLOWED_CHARS_HOST ) or _check_for_bad_chars ( uripath , ALLOWED_CHARS ) ) : [EOL] raise ValueError ( [string] % ( url , ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class SvnPathBase ( common . PathBase ) : [EOL] [docstring] [EOL] sep = [string] [EOL] [EOL] def _geturl ( self ) : [EOL] return self . strpath [EOL] url = property ( _geturl , None , None , [string] ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return self . strpath [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . strpath ) [EOL] [EOL] def new ( self , ** kw ) : [EOL] [docstring] [EOL] obj = object . __new__ ( self . __class__ ) [EOL] obj . rev = kw . get ( [string] , self . rev ) [EOL] obj . auth = kw . get ( [string] , self . auth ) [EOL] dirname , basename , purebasename , ext = self . _getbyspec ( [string] ) [EOL] if [string] in kw : [EOL] if [string] in kw or [string] in kw : [EOL] raise ValueError ( [string] % kw ) [EOL] else : [EOL] pb = kw . setdefault ( [string] , purebasename ) [EOL] ext = kw . setdefault ( [string] , ext ) [EOL] if ext and not ext . startswith ( [string] ) : [EOL] ext = [string] + ext [EOL] kw [ [string] ] = pb + ext [EOL] [EOL] kw . setdefault ( [string] , dirname ) [EOL] kw . setdefault ( [string] , self . sep ) [EOL] if kw [ [string] ] : [EOL] obj . strpath = [string] % kw [EOL] else : [EOL] obj . strpath = [string] % kw [EOL] return obj [EOL] [EOL] def _getbyspec ( self , spec ) : [EOL] [docstring] [EOL] res = [ ] [EOL] parts = self . strpath . split ( self . sep ) [EOL] for name in spec . split ( [string] ) : [EOL] name = name . strip ( ) [EOL] if name == [string] : [EOL] res . append ( self . sep . join ( parts [ : - [number] ] ) ) [EOL] elif name == [string] : [EOL] res . append ( parts [ - [number] ] ) [EOL] else : [EOL] basename = parts [ - [number] ] [EOL] i = basename . rfind ( [string] ) [EOL] if i == - [number] : [EOL] purebasename , ext = basename , [string] [EOL] else : [EOL] purebasename , ext = basename [ : i ] , basename [ i : ] [EOL] if name == [string] : [EOL] res . append ( purebasename ) [EOL] elif name == [string] : [EOL] res . append ( ext ) [EOL] else : [EOL] raise NameError ( [string] % name ) [EOL] return res [EOL] [EOL] def __eq__ ( self , other ) : [EOL] [docstring] [EOL] return ( str ( self ) == str ( other ) and ( self . rev == other . rev or self . rev == other . rev ) ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self == other [EOL] [EOL] def join ( self , * args ) : [EOL] [docstring] [EOL] if not args : [EOL] return self [EOL] [EOL] args = tuple ( [ arg . strip ( self . sep ) for arg in args ] ) [EOL] parts = ( self . strpath , ) + args [EOL] newpath = self . __class__ ( self . sep . join ( parts ) , self . rev , self . auth ) [EOL] return newpath [EOL] [EOL] def propget ( self , name ) : [EOL] [docstring] [EOL] value = self . _propget ( name ) [EOL] return value [EOL] [EOL] def proplist ( self ) : [EOL] [docstring] [EOL] content = self . _proplist ( ) [EOL] return content [EOL] [EOL] def size ( self ) : [EOL] [docstring] [EOL] return self . info ( ) . size [EOL] [EOL] def mtime ( self ) : [EOL] [docstring] [EOL] return self . info ( ) . mtime [EOL] [EOL] [comment] [EOL] [EOL] def _escape ( self , cmd ) : [EOL] return _escape_helper ( cmd ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class Checkers ( common . Checkers ) : [EOL] def dir ( self ) : [EOL] try : [EOL] return self . path . info ( ) . kind == [string] [EOL] except py . error . Error : [EOL] return self . _listdirworks ( ) [EOL] [EOL] def _listdirworks ( self ) : [EOL] try : [EOL] self . path . listdir ( ) [EOL] except py . error . ENOENT : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] def file ( self ) : [EOL] try : [EOL] return self . path . info ( ) . kind == [string] [EOL] except py . error . ENOENT : [EOL] return False [EOL] [EOL] def exists ( self ) : [EOL] try : [EOL] return self . path . info ( ) [EOL] except py . error . ENOENT : [EOL] return self . _listdirworks ( ) [EOL] [EOL] def parse_apr_time ( timestr ) : [EOL] i = timestr . rfind ( [string] ) [EOL] if i == - [number] : [EOL] raise ValueError ( [string] % timestr ) [EOL] timestr = timestr [ : i ] [EOL] parsedtime = time . strptime ( timestr , [string] ) [EOL] return time . mktime ( parsedtime ) [EOL] [EOL] class PropListDict ( dict ) : [EOL] [docstring] [EOL] def __init__ ( self , path , keynames ) : [EOL] dict . __init__ ( self , [ ( x , None ) for x in keynames ] ) [EOL] self . path = path [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] value = dict . __getitem__ ( self , key ) [EOL] if value is None : [EOL] value = self . path . propget ( key ) [EOL] dict . __setitem__ ( self , key , value ) [EOL] return value [EOL] [EOL] def fixlocale ( ) : [EOL] if sys . platform != [string] : [EOL] return [string] [EOL] return [string] [EOL] [EOL] [comment] [EOL] ILLEGAL_CHARS = [string] . split ( [string] ) [EOL] if os . sep in ILLEGAL_CHARS : [EOL] ILLEGAL_CHARS . remove ( os . sep ) [EOL] ISWINDOWS = sys . platform == [string] [EOL] _reg_allow_disk = re . compile ( [string] , re . I ) [EOL] def _check_path ( path ) : [EOL] illegal = ILLEGAL_CHARS [ : ] [EOL] sp = path . strpath [EOL] if ISWINDOWS : [EOL] illegal . remove ( [string] ) [EOL] if not _reg_allow_disk . match ( sp ) : [EOL] raise ValueError ( [string] ) [EOL] for char in sp : [EOL] if char not in string . printable or char in illegal : [EOL] raise ValueError ( [string] % ( char , ) ) [EOL] [EOL] def path_to_fspath ( path , addat = True ) : [EOL] _check_path ( path ) [EOL] sp = path . strpath [EOL] if addat and path . rev != - [number] : [EOL] sp = [string] % ( sp , path . rev ) [EOL] elif addat : [EOL] sp = [string] % ( sp , ) [EOL] return sp [EOL] [EOL] def url_from_path ( path ) : [EOL] fspath = path_to_fspath ( path , False ) [EOL] from urllib import quote [EOL] if ISWINDOWS : [EOL] match = _reg_allow_disk . match ( fspath ) [EOL] fspath = fspath . replace ( [string] , [string] ) [EOL] if match . group ( [number] ) : [EOL] fspath = [string] % ( match . group ( [number] ) . replace ( [string] , [string] ) , quote ( fspath [ len ( match . group ( [number] ) ) : ] ) ) [EOL] else : [EOL] fspath = quote ( fspath ) [EOL] else : [EOL] fspath = quote ( fspath ) [EOL] if path . rev != - [number] : [EOL] fspath = [string] % ( fspath , path . rev ) [EOL] else : [EOL] fspath = [string] % ( fspath , ) [EOL] return [string] % ( fspath , ) [EOL] [EOL] class SvnAuth ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , username , password , cache_auth = True , interactive = True ) : [EOL] self . username = username [EOL] self . password = password [EOL] self . cache_auth = cache_auth [EOL] self . interactive = interactive [EOL] [EOL] def makecmdoptions ( self ) : [EOL] uname = self . username . replace ( [string] , [string] ) [EOL] passwd = self . password . replace ( [string] , [string] ) [EOL] ret = [ ] [EOL] if uname : [EOL] ret . append ( [string] % ( uname , ) ) [EOL] if passwd : [EOL] ret . append ( [string] % ( passwd , ) ) [EOL] if not self . cache_auth : [EOL] ret . append ( [string] ) [EOL] if not self . interactive : [EOL] ret . append ( [string] ) [EOL] return [string] . join ( ret ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . username , ) [EOL] [EOL] rex_blame = re . compile ( [string] ) [EOL] [EOL] class SvnWCCommandPath ( common . PathBase ) : [EOL] [docstring] [EOL] sep = os . sep [EOL] [EOL] def __new__ ( cls , wcpath = None , auth = None ) : [EOL] self = object . __new__ ( cls ) [EOL] if isinstance ( wcpath , cls ) : [EOL] if wcpath . __class__ == cls : [EOL] return wcpath [EOL] wcpath = wcpath . localpath [EOL] if _check_for_bad_chars ( str ( wcpath ) , ALLOWED_CHARS ) : [EOL] raise ValueError ( [string] % ( wcpath , ) ) [EOL] self . localpath = py . path . local ( wcpath ) [EOL] self . auth = auth [EOL] return self [EOL] [EOL] strpath = property ( lambda x : str ( x . localpath ) , None , None , [string] ) [EOL] rev = property ( lambda x : x . info ( usecache = [number] ) . rev , None , None , [string] ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . localpath == getattr ( other , [string] , None ) [EOL] [EOL] def _geturl ( self ) : [EOL] if getattr ( self , [string] , None ) is None : [EOL] info = self . info ( ) [EOL] self . _url = info . url [comment] [EOL] assert isinstance ( self . _url , py . builtin . _basestring ) [EOL] return self . _url [EOL] [EOL] url = property ( _geturl , None , None , [string] ) [EOL] [EOL] def _escape ( self , cmd ) : [EOL] return _escape_helper ( cmd ) [EOL] [EOL] def dump ( self , obj ) : [EOL] [docstring] [EOL] return self . localpath . dump ( obj ) [EOL] [EOL] def svnurl ( self ) : [EOL] [docstring] [EOL] info = self . info ( ) [EOL] return py . path . svnurl ( info . url ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . strpath ) [comment] [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . localpath ) [EOL] [EOL] def _makeauthoptions ( self ) : [EOL] if self . auth is None : [EOL] return [string] [EOL] return self . auth . makecmdoptions ( ) [EOL] [EOL] def _authsvn ( self , cmd , args = None ) : [EOL] args = args and list ( args ) or [ ] [EOL] args . append ( self . _makeauthoptions ( ) ) [EOL] return self . _svn ( cmd , * args ) [EOL] [EOL] def _svn ( self , cmd , * args ) : [EOL] l = [ [string] % cmd ] [EOL] args = [ self . _escape ( item ) for item in args ] [EOL] l . extend ( args ) [EOL] l . append ( [string] % self . _escape ( self . strpath ) ) [EOL] [comment] [EOL] string = fixlocale ( ) + [string] . join ( l ) [EOL] try : [EOL] try : [EOL] key = [string] [EOL] hold = os . environ . get ( key ) [EOL] os . environ [ key ] = [string] [EOL] out = py . process . cmdexec ( string ) [EOL] finally : [EOL] if hold : [EOL] os . environ [ key ] = hold [EOL] else : [EOL] del os . environ [ key ] [EOL] except py . process . cmdexec . Error : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] strerr = e . err . lower ( ) [EOL] if strerr . find ( [string] ) != - [number] : [EOL] raise py . error . ENOENT ( self ) [EOL] elif strerr . find ( [string] ) != - [number] : [EOL] raise py . error . ENOENT ( self ) [EOL] if ( strerr . find ( [string] ) != - [number] or strerr . find ( [string] ) != - [number] or strerr . find ( [string] ) != - [number] or strerr . find ( [string] ) != - [number] ) : [EOL] raise py . error . EEXIST ( strerr ) [comment] [EOL] raise [EOL] return out [EOL] [EOL] def switch ( self , url ) : [EOL] [docstring] [EOL] self . _authsvn ( [string] , [ url ] ) [EOL] [EOL] def checkout ( self , url = None , rev = None ) : [EOL] [docstring] [EOL] args = [ ] [EOL] if url is None : [EOL] url = self . url [EOL] if rev is None or rev == - [number] : [EOL] if ( sys . platform != [string] and _getsvnversion ( ) == [string] ) : [EOL] url += [string] [EOL] else : [EOL] if _getsvnversion ( ) == [string] : [EOL] url += [string] % rev [EOL] else : [EOL] args . append ( [string] + str ( rev ) ) [EOL] args . append ( url ) [EOL] self . _authsvn ( [string] , args ) [EOL] [EOL] def update ( self , rev = [string] , interactive = True ) : [EOL] [docstring] [EOL] opts = [ [string] , rev ] [EOL] if not interactive : [EOL] opts . append ( [string] ) [EOL] self . _authsvn ( [string] , opts ) [EOL] [EOL] def write ( self , content , mode = [string] ) : [EOL] [docstring] [EOL] self . localpath . write ( content , mode ) [EOL] [EOL] def dirpath ( self , * args ) : [EOL] [docstring] [EOL] return self . __class__ ( self . localpath . dirpath ( * args ) , auth = self . auth ) [EOL] [EOL] def _ensuredirs ( self ) : [EOL] parent = self . dirpath ( ) [EOL] if parent . check ( dir = [number] ) : [EOL] parent . _ensuredirs ( ) [EOL] if self . check ( dir = [number] ) : [EOL] self . mkdir ( ) [EOL] return self [EOL] [EOL] def ensure ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] p = self . join ( * args ) [EOL] if p . check ( ) : [EOL] if p . check ( versioned = False ) : [EOL] p . add ( ) [EOL] return p [EOL] if kwargs . get ( [string] , [number] ) : [EOL] return p . _ensuredirs ( ) [EOL] parent = p . dirpath ( ) [EOL] parent . _ensuredirs ( ) [EOL] p . write ( [string] ) [EOL] p . add ( ) [EOL] return p [EOL] [EOL] def mkdir ( self , * args ) : [EOL] [docstring] [EOL] if args : [EOL] return self . join ( * args ) . mkdir ( ) [EOL] else : [EOL] self . _svn ( [string] ) [EOL] return self [EOL] [EOL] def add ( self ) : [EOL] [docstring] [EOL] self . _svn ( [string] ) [EOL] [EOL] def remove ( self , rec = [number] , force = [number] ) : [EOL] [docstring] [EOL] assert rec , [string] [EOL] if not self . check ( versioned = True ) : [EOL] [comment] [EOL] py . path . local ( self ) . remove ( ) [EOL] return [EOL] flags = [ ] [EOL] if force : [EOL] flags . append ( [string] ) [EOL] self . _svn ( [string] , * flags ) [EOL] [EOL] def copy ( self , target ) : [EOL] [docstring] [EOL] py . process . cmdexec ( [string] % ( str ( self ) , str ( target ) ) ) [EOL] [EOL] def rename ( self , target ) : [EOL] [docstring] [EOL] py . process . cmdexec ( [string] % ( str ( self ) , str ( target ) ) ) [EOL] [EOL] def lock ( self ) : [EOL] [docstring] [EOL] out = self . _authsvn ( [string] ) . strip ( ) [EOL] if not out : [EOL] [comment] [EOL] raise ValueError ( [string] ) [EOL] [EOL] def unlock ( self ) : [EOL] [docstring] [EOL] out = self . _authsvn ( [string] ) . strip ( ) [EOL] if out . startswith ( [string] ) : [EOL] [comment] [EOL] raise Exception ( out [ [number] : ] ) [EOL] [EOL] def cleanup ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] self . unlock ( ) [EOL] except : [EOL] pass [EOL] [EOL] def status ( self , updates = [number] , rec = [number] , externals = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if externals : [EOL] raise ValueError ( [string] [string] ) [EOL] else : [EOL] [comment] [EOL] externals = [string] [EOL] if rec : [EOL] rec = [string] [EOL] else : [EOL] rec = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if updates : [EOL] updates = [string] [EOL] else : [EOL] updates = [string] [EOL] [EOL] try : [EOL] cmd = [string] % ( updates , rec , externals ) [EOL] out = self . _authsvn ( cmd ) [EOL] except py . process . cmdexec . Error : [EOL] cmd = [string] % ( updates , rec , externals ) [EOL] out = self . _authsvn ( cmd ) [EOL] rootstatus = WCStatus ( self ) . fromstring ( out , self ) [EOL] else : [EOL] rootstatus = XMLWCStatus ( self ) . fromstring ( out , self ) [EOL] return rootstatus [EOL] [EOL] def diff ( self , rev = None ) : [EOL] [docstring] [EOL] args = [ ] [EOL] if rev is not None : [EOL] args . append ( [string] % rev ) [EOL] out = self . _authsvn ( [string] , args ) [EOL] return out [EOL] [EOL] def blame ( self ) : [EOL] [docstring] [EOL] out = self . _svn ( [string] ) [EOL] result = [ ] [EOL] blamelines = out . splitlines ( ) [EOL] reallines = py . path . svnurl ( self . url ) . readlines ( ) [EOL] for i , ( blameline , line ) in enumerate ( zip ( blamelines , reallines ) ) : [EOL] m = rex_blame . match ( blameline ) [EOL] if not m : [EOL] raise ValueError ( [string] [string] % ( line , ) ) [EOL] rev , name , _ = m . groups ( ) [EOL] result . append ( ( int ( rev ) , name , line ) ) [EOL] return result [EOL] [EOL] _rex_commit = re . compile ( [string] , re . DOTALL ) [EOL] def commit ( self , msg = [string] , rec = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] cmd = [string] % ( msg . replace ( [string] , [string] ) , ) [EOL] if not rec : [EOL] cmd += [string] [EOL] out = self . _authsvn ( cmd ) [EOL] try : [EOL] del cache . info [ self ] [EOL] except KeyError : [EOL] pass [EOL] if out : [EOL] m = self . _rex_commit . match ( out ) [EOL] return int ( m . group ( [number] ) ) [EOL] [EOL] def propset ( self , name , value , * args ) : [EOL] [docstring] [EOL] d = py . path . local . mkdtemp ( ) [EOL] try : [EOL] p = d . join ( [string] ) [EOL] p . write ( value ) [EOL] self . _svn ( [string] , name , [string] , str ( p ) , * args ) [EOL] finally : [EOL] d . remove ( ) [EOL] [EOL] def propget ( self , name ) : [EOL] [docstring] [EOL] res = self . _svn ( [string] , name ) [EOL] return res [ : - [number] ] [comment] [EOL] [EOL] def propdel ( self , name ) : [EOL] [docstring] [EOL] res = self . _svn ( [string] , name ) [EOL] return res [ : - [number] ] [comment] [EOL] [EOL] def proplist ( self , rec = [number] ) : [EOL] [docstring] [EOL] if rec : [EOL] res = self . _svn ( [string] ) [EOL] return make_recursive_propdict ( self , res ) [EOL] else : [EOL] res = self . _svn ( [string] ) [EOL] lines = res . split ( [string] ) [EOL] lines = [ x . strip ( ) for x in lines [ [number] : ] ] [EOL] return PropListDict ( self , lines ) [EOL] [EOL] def revert ( self , rec = [number] ) : [EOL] [docstring] [EOL] if rec : [EOL] result = self . _svn ( [string] ) [EOL] else : [EOL] result = self . _svn ( [string] ) [EOL] return result [EOL] [EOL] def new ( self , ** kw ) : [EOL] [docstring] [EOL] if kw : [EOL] localpath = self . localpath . new ( ** kw ) [EOL] else : [EOL] localpath = self . localpath [EOL] return self . __class__ ( localpath , auth = self . auth ) [EOL] [EOL] def join ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] if not args : [EOL] return self [EOL] localpath = self . localpath . join ( * args , ** kwargs ) [EOL] return self . __class__ ( localpath , auth = self . auth ) [EOL] [EOL] def info ( self , usecache = [number] ) : [EOL] [docstring] [EOL] info = usecache and cache . info . get ( self ) [EOL] if not info : [EOL] try : [EOL] output = self . _svn ( [string] ) [EOL] except py . process . cmdexec . Error : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] if e . err . find ( [string] ) != - [number] : [EOL] raise py . error . ENOENT ( self , e . err ) [EOL] elif e . err . find ( [string] ) != - [number] : [EOL] raise py . error . ENOENT ( self , e . err ) [EOL] raise [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( output . strip ( ) == [string] or output . lower ( ) . find ( [string] ) != - [number] ) : [EOL] raise py . error . ENOENT ( self , output ) [EOL] info = InfoSvnWCCommand ( output ) [EOL] [EOL] [comment] [EOL] if sys . platform != [string] : [EOL] if info . path != self . localpath : [EOL] raise py . error . ENOENT ( self , [string] + [string] % ( info . path , self . localpath ) ) [EOL] cache . info [ self ] = info [EOL] return info [EOL] [EOL] def listdir ( self , fil = None , sort = None ) : [EOL] [docstring] [EOL] if isinstance ( fil , str ) : [EOL] fil = common . FNMatcher ( fil ) [EOL] [comment] [EOL] def notsvn ( path ) : [EOL] return path . basename != [string] [EOL] [EOL] paths = [ ] [EOL] for localpath in self . localpath . listdir ( notsvn ) : [EOL] p = self . __class__ ( localpath , auth = self . auth ) [EOL] if notsvn ( p ) and ( not fil or fil ( p ) ) : [EOL] paths . append ( p ) [EOL] self . _sortlist ( paths , sort ) [EOL] return paths [EOL] [EOL] def open ( self , mode = [string] ) : [EOL] [docstring] [EOL] return open ( self . strpath , mode ) [EOL] [EOL] def _getbyspec ( self , spec ) : [EOL] return self . localpath . _getbyspec ( spec ) [EOL] [EOL] class Checkers ( py . path . local . Checkers ) : [EOL] def __init__ ( self , path ) : [EOL] self . svnwcpath = path [EOL] self . path = path . localpath [EOL] def versioned ( self ) : [EOL] try : [EOL] s = self . svnwcpath . info ( ) [EOL] except ( py . error . ENOENT , py . error . EEXIST ) : [EOL] return False [EOL] except py . process . cmdexec . Error : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] if e . err . find ( [string] ) != - [number] : [EOL] return False [EOL] if e . err . lower ( ) . find ( [string] ) != - [number] : [EOL] return False [EOL] raise [EOL] else : [EOL] return True [EOL] [EOL] def log ( self , rev_start = None , rev_end = [number] , verbose = False ) : [EOL] [docstring] [EOL] assert self . check ( ) [comment] [EOL] rev_start = rev_start is None and [string] or rev_start [EOL] rev_end = rev_end is None and [string] or rev_end [EOL] if rev_start == [string] and rev_end == [number] : [EOL] rev_opt = [string] [EOL] else : [EOL] rev_opt = [string] % ( rev_start , rev_end ) [EOL] verbose_opt = verbose and [string] or [string] [EOL] locale_env = fixlocale ( ) [EOL] [comment] [EOL] auth_opt = self . _makeauthoptions ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cmd = locale_env + [string] % ( rev_opt , verbose_opt , auth_opt , self . strpath ) [EOL] [EOL] popen = subprocess . Popen ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = True , ) [EOL] stdout , stderr = popen . communicate ( ) [EOL] stdout = py . builtin . _totext ( stdout , sys . getdefaultencoding ( ) ) [EOL] minidom , ExpatError = importxml ( ) [EOL] try : [EOL] tree = minidom . parseString ( stdout ) [EOL] except ExpatError : [EOL] raise ValueError ( [string] ) [EOL] result = [ ] [EOL] for logentry in filter ( None , tree . firstChild . childNodes ) : [EOL] if logentry . nodeType == logentry . ELEMENT_NODE : [EOL] result . append ( LogEntry ( logentry ) ) [EOL] return result [EOL] [EOL] def size ( self ) : [EOL] [docstring] [EOL] return self . info ( ) . size [EOL] [EOL] def mtime ( self ) : [EOL] [docstring] [EOL] return self . info ( ) . mtime [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . strpath , self . __class__ , self . auth ) ) [EOL] [EOL] [EOL] class WCStatus : [EOL] attrnames = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , wcpath , rev = None , modrev = None , author = None ) : [EOL] self . wcpath = wcpath [EOL] self . rev = rev [EOL] self . modrev = modrev [EOL] self . author = author [EOL] [EOL] for name in self . attrnames : [EOL] setattr ( self , name , [ ] ) [EOL] [EOL] def allpath ( self , sort = True , ** kw ) : [EOL] d = { } [EOL] for name in self . attrnames : [EOL] if name not in kw or kw [ name ] : [EOL] for path in getattr ( self , name ) : [EOL] d [ path ] = [number] [EOL] l = d . keys ( ) [EOL] if sort : [EOL] l . sort ( ) [EOL] return l [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _rex_status = re . compile ( [string] ) [EOL] [EOL] def fromstring ( data , rootwcpath , rev = None , modrev = None , author = None ) : [EOL] [docstring] [EOL] rootstatus = WCStatus ( rootwcpath , rev , modrev , author ) [EOL] update_rev = None [EOL] for line in data . split ( [string] ) : [EOL] if not line . strip ( ) : [EOL] continue [EOL] [comment] [EOL] flags , rest = line [ : [number] ] , line [ [number] : ] [EOL] [comment] [EOL] c0 , c1 , c2 , c3 , c4 , c5 , x6 , c7 = flags [EOL] [comment] [EOL] [comment] [EOL] [EOL] if c0 in [string] : [EOL] fn = line . split ( None , [number] ) [ [number] ] [EOL] if c0 == [string] : [EOL] wcpath = rootwcpath . join ( fn , abs = [number] ) [EOL] rootstatus . unknown . append ( wcpath ) [EOL] elif c0 == [string] : [EOL] wcpath = rootwcpath . __class__ ( rootwcpath . localpath . join ( fn , abs = [number] ) , auth = rootwcpath . auth ) [EOL] rootstatus . external . append ( wcpath ) [EOL] elif c0 == [string] : [EOL] wcpath = rootwcpath . join ( fn , abs = [number] ) [EOL] rootstatus . ignored . append ( wcpath ) [EOL] [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] m = WCStatus . _rex_status . match ( rest ) [EOL] if not m : [EOL] if c7 == [string] : [EOL] fn = rest . strip ( ) [EOL] wcpath = rootwcpath . join ( fn , abs = [number] ) [EOL] rootstatus . update_available . append ( wcpath ) [EOL] continue [EOL] if line . lower ( ) . find ( [string] ) != - [number] : [EOL] update_rev = int ( rest . split ( [string] ) [ [number] ] . strip ( ) ) [EOL] continue [EOL] if line . lower ( ) . find ( [string] ) > - [number] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] [comment] [EOL] raise ValueError ( [string] % line ) [EOL] else : [EOL] rev , modrev , author , fn = m . groups ( ) [EOL] wcpath = rootwcpath . join ( fn , abs = [number] ) [EOL] [comment] [EOL] if c0 == [string] : [EOL] assert wcpath . check ( file = [number] ) , [string] [EOL] rootstatus . modified . append ( wcpath ) [EOL] elif c0 == [string] or c3 == [string] : [EOL] rootstatus . added . append ( wcpath ) [EOL] elif c0 == [string] : [EOL] rootstatus . deleted . append ( wcpath ) [EOL] elif c0 == [string] : [EOL] rootstatus . conflict . append ( wcpath ) [EOL] elif c0 == [string] : [EOL] rootstatus . kindmismatch . append ( wcpath ) [EOL] elif c0 == [string] : [EOL] rootstatus . incomplete . append ( wcpath ) [EOL] elif c0 == [string] : [EOL] rootstatus . replaced . append ( wcpath ) [EOL] elif not c0 . strip ( ) : [EOL] rootstatus . unchanged . append ( wcpath ) [EOL] else : [EOL] raise NotImplementedError ( [string] % c0 ) [EOL] [EOL] if c1 == [string] : [EOL] rootstatus . prop_modified . append ( wcpath ) [EOL] [comment] [EOL] if c2 == [string] or c5 == [string] : [EOL] rootstatus . locked . append ( wcpath ) [EOL] if c7 == [string] : [EOL] rootstatus . update_available . append ( wcpath ) [EOL] [EOL] if wcpath == rootwcpath : [EOL] rootstatus . rev = rev [EOL] rootstatus . modrev = modrev [EOL] rootstatus . author = author [EOL] if update_rev : [EOL] rootstatus . update_rev = update_rev [EOL] continue [EOL] return rootstatus [EOL] fromstring = staticmethod ( fromstring ) [EOL] [EOL] class XMLWCStatus ( WCStatus ) : [EOL] def fromstring ( data , rootwcpath , rev = None , modrev = None , author = None ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] rootstatus = WCStatus ( rootwcpath , rev , modrev , author ) [EOL] update_rev = None [EOL] minidom , ExpatError = importxml ( ) [EOL] try : [EOL] doc = minidom . parseString ( data ) [EOL] except ExpatError : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] raise ValueError ( str ( e ) ) [EOL] urevels = doc . getElementsByTagName ( [string] ) [EOL] if urevels : [EOL] rootstatus . update_rev = urevels [ - [number] ] . getAttribute ( [string] ) [EOL] for entryel in doc . getElementsByTagName ( [string] ) : [EOL] path = entryel . getAttribute ( [string] ) [EOL] statusel = entryel . getElementsByTagName ( [string] ) [ [number] ] [EOL] itemstatus = statusel . getAttribute ( [string] ) [EOL] [EOL] if itemstatus == [string] : [EOL] wcpath = rootwcpath . join ( path , abs = [number] ) [EOL] rootstatus . unknown . append ( wcpath ) [EOL] continue [EOL] elif itemstatus == [string] : [EOL] wcpath = rootwcpath . __class__ ( rootwcpath . localpath . join ( path , abs = [number] ) , auth = rootwcpath . auth ) [EOL] rootstatus . external . append ( wcpath ) [EOL] continue [EOL] elif itemstatus == [string] : [EOL] wcpath = rootwcpath . join ( path , abs = [number] ) [EOL] rootstatus . ignored . append ( wcpath ) [EOL] continue [EOL] elif itemstatus == [string] : [EOL] wcpath = rootwcpath . join ( path , abs = [number] ) [EOL] rootstatus . incomplete . append ( wcpath ) [EOL] continue [EOL] [EOL] rev = statusel . getAttribute ( [string] ) [EOL] if itemstatus == [string] or itemstatus == [string] : [EOL] rev = [string] [EOL] modrev = [string] [EOL] author = [string] [EOL] date = [string] [EOL] elif itemstatus == [string] : [EOL] pass [EOL] else : [EOL] [comment] [EOL] commitel = entryel . getElementsByTagName ( [string] ) [ [number] ] [EOL] if commitel : [EOL] modrev = commitel . getAttribute ( [string] ) [EOL] author = [string] [EOL] author_els = commitel . getElementsByTagName ( [string] ) [EOL] if author_els : [EOL] for c in author_els [ [number] ] . childNodes : [EOL] author += c . nodeValue [EOL] date = [string] [EOL] for c in commitel . getElementsByTagName ( [string] ) [ [number] ] . childNodes : [EOL] date += c . nodeValue [EOL] [EOL] wcpath = rootwcpath . join ( path , abs = [number] ) [EOL] [EOL] assert itemstatus != [string] or wcpath . check ( file = [number] ) , ( [string] ) [EOL] [EOL] itemattrname = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } . get ( itemstatus , itemstatus ) [EOL] [EOL] attr = getattr ( rootstatus , itemattrname ) [EOL] attr . append ( wcpath ) [EOL] [EOL] propsstatus = statusel . getAttribute ( [string] ) [EOL] if propsstatus not in ( [string] , [string] ) : [EOL] rootstatus . prop_modified . append ( wcpath ) [EOL] [EOL] if wcpath == rootwcpath : [EOL] rootstatus . rev = rev [EOL] rootstatus . modrev = modrev [EOL] rootstatus . author = author [EOL] rootstatus . date = date [EOL] [EOL] [comment] [EOL] rstatusels = entryel . getElementsByTagName ( [string] ) [EOL] if rstatusels : [EOL] rstatusel = rstatusels [ [number] ] [EOL] ritemstatus = rstatusel . getAttribute ( [string] ) [EOL] if ritemstatus in ( [string] , [string] ) : [EOL] rootstatus . update_available . append ( wcpath ) [EOL] [EOL] lockels = entryel . getElementsByTagName ( [string] ) [EOL] if len ( lockels ) : [EOL] rootstatus . locked . append ( wcpath ) [EOL] [EOL] return rootstatus [EOL] fromstring = staticmethod ( fromstring ) [EOL] [EOL] class InfoSvnWCCommand : [EOL] def __init__ ( self , output ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] d = { } [EOL] for line in output . split ( [string] ) : [EOL] if not line . strip ( ) : [EOL] continue [EOL] key , value = line . split ( [string] , [number] ) [EOL] key = key . lower ( ) . replace ( [string] , [string] ) [EOL] value = value . strip ( ) [EOL] d [ key ] = value [EOL] try : [EOL] self . url = d [ [string] ] [EOL] except KeyError : [EOL] raise ValueError ( [string] ) [EOL] [comment] [EOL] self . kind = d [ [string] ] == [string] and [string] or d [ [string] ] [EOL] try : [EOL] self . rev = int ( d [ [string] ] ) [EOL] except KeyError : [EOL] self . rev = None [EOL] [EOL] self . path = py . path . local ( d [ [string] ] ) [EOL] self . size = self . path . size ( ) [EOL] if [string] in d : [EOL] self . created_rev = int ( d [ [string] ] ) [EOL] if [string] in d : [EOL] self . last_author = d [ [string] ] [EOL] if [string] in d : [EOL] self . mtime = parse_wcinfotime ( d [ [string] ] ) [EOL] self . time = self . mtime * [number] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . __dict__ == other . __dict__ [EOL] [EOL] def parse_wcinfotime ( timestr ) : [EOL] [docstring] [EOL] [comment] [EOL] m = re . match ( [string] , timestr ) [EOL] if not m : [EOL] raise ValueError ( [string] % timestr ) [EOL] timestr , timezone = m . groups ( ) [EOL] [comment] [EOL] parsedtime = time . strptime ( timestr , [string] ) [EOL] return calendar . timegm ( parsedtime ) [EOL] [EOL] def make_recursive_propdict ( wcroot , output , rex = re . compile ( [string] ) ) : [EOL] [docstring] [EOL] lines = [ x for x in output . split ( [string] ) if x ] [EOL] pdict = { } [EOL] while lines : [EOL] line = lines . pop ( [number] ) [EOL] m = rex . match ( line ) [EOL] if not m : [EOL] raise ValueError ( [string] % line ) [EOL] path = m . groups ( ) [ [number] ] [EOL] wcpath = wcroot . join ( path , abs = [number] ) [EOL] propnames = [ ] [EOL] while lines and lines [ [number] ] . startswith ( [string] ) : [EOL] propname = lines . pop ( [number] ) . strip ( ) [EOL] propnames . append ( propname ) [EOL] assert propnames , [string] [EOL] pdict [ wcpath ] = PropListDict ( wcpath , propnames ) [EOL] return pdict [EOL] [EOL] [EOL] def importxml ( cache = [ ] ) : [EOL] if cache : [EOL] return cache [EOL] from xml . dom import minidom [EOL] from xml . parsers . expat import ExpatError [EOL] cache . extend ( [ minidom , ExpatError ] ) [EOL] return cache [EOL] [EOL] class LogEntry : [EOL] def __init__ ( self , logentry ) : [EOL] self . rev = int ( logentry . getAttribute ( [string] ) ) [EOL] for lpart in filter ( None , logentry . childNodes ) : [EOL] if lpart . nodeType == lpart . ELEMENT_NODE : [EOL] if lpart . nodeName == [string] : [EOL] self . author = lpart . firstChild . nodeValue [EOL] elif lpart . nodeName == [string] : [EOL] if lpart . firstChild : [EOL] self . msg = lpart . firstChild . nodeValue [EOL] else : [EOL] self . msg = [string] [EOL] elif lpart . nodeName == [string] : [EOL] [comment] [EOL] timestr = lpart . firstChild . nodeValue [EOL] self . date = parse_apr_time ( timestr ) [EOL] elif lpart . nodeName == [string] : [EOL] self . strpaths = [ ] [EOL] for ppart in filter ( None , lpart . childNodes ) : [EOL] if ppart . nodeType == ppart . ELEMENT_NODE : [EOL] self . strpaths . append ( PathEntry ( ppart ) ) [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . rev , self . author , self . date ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.KeysView[typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.KeysView[typing.Any]$ 0 0 0 0 0 0 $typing.KeysView[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 $builtins.staticmethod$ 0 0 0 $builtins.staticmethod$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.py.py._path.svnwc.WCStatus$ 0 $builtins.staticmethod$ 0 0 0 $builtins.staticmethod$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL]	0 0 0
[docstring] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Generator , Any , List [EOL] import typing [EOL] import types [EOL] [EOL] def format_exception_only ( etype , value ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( isinstance ( etype , BaseException ) or isinstance ( etype , types . InstanceType ) or etype is None or type ( etype ) is str ) : [EOL] return [ _format_final_exc_line ( etype , value ) ] [EOL] [EOL] stype = etype . __name__ [EOL] [EOL] if not issubclass ( etype , SyntaxError ) : [EOL] return [ _format_final_exc_line ( stype , value ) ] [EOL] [EOL] [comment] [EOL] lines = [ ] [EOL] try : [EOL] msg , ( filename , lineno , offset , badline ) = value . args [EOL] except Exception : [EOL] pass [EOL] else : [EOL] filename = filename or [string] [EOL] lines . append ( [string] % ( filename , lineno ) ) [EOL] if badline is not None : [EOL] lines . append ( [string] % badline . strip ( ) ) [EOL] if offset is not None : [EOL] caretspace = badline . rstrip ( [string] ) [ : offset ] . lstrip ( ) [EOL] [comment] [EOL] caretspace = ( ( c . isspace ( ) and c or [string] ) for c in caretspace ) [EOL] [comment] [EOL] lines . append ( [string] % [string] . join ( caretspace ) ) [EOL] value = msg [EOL] [EOL] lines . append ( _format_final_exc_line ( stype , value ) ) [EOL] return lines [EOL] [EOL] def _format_final_exc_line ( etype , value ) : [EOL] [docstring] [EOL] valuestr = _some_str ( value ) [EOL] if value is None or not valuestr : [EOL] line = [string] % etype [EOL] else : [EOL] line = [string] % ( etype , valuestr ) [EOL] return line [EOL] [EOL] def _some_str ( value ) : [EOL] try : [EOL] return unicode ( value ) [EOL] except Exception : [EOL] try : [EOL] return str ( value ) [EOL] except Exception : [EOL] pass [EOL] return [string] % type ( value ) . __name__ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[EOL] from typing import Tuple , Literal [EOL] import typing_extensions [EOL] import typing [EOL] pytest_plugins = [string] , [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[EOL] from typing import Any [EOL] import typing [EOL] import py [EOL] [EOL] import errno [EOL] [EOL] [EOL] def test_error_classes ( ) : [EOL] for name in errno . errorcode . values ( ) : [EOL] x = getattr ( py . error , name ) [EOL] assert issubclass ( x , py . error . Error ) [EOL] assert issubclass ( x , EnvironmentError ) [EOL] [EOL] [EOL] def test_has_name ( ) : [EOL] assert py . error . __name__ == [string] [EOL] [EOL] [EOL] def test_picklability_issue1 ( ) : [EOL] import pickle [EOL] e1 = py . error . ENOENT ( ) [EOL] s = pickle . dumps ( e1 ) [EOL] e2 = pickle . loads ( s ) [EOL] assert isinstance ( e2 , py . error . ENOENT ) [EOL] [EOL] [EOL] def test_unknown_error ( ) : [EOL] num = [number] [EOL] cls = py . error . _geterrnoclass ( num ) [EOL] assert cls . __name__ == [string] % ( num , ) [EOL] assert issubclass ( cls , py . error . Error ) [EOL] assert issubclass ( cls , EnvironmentError ) [EOL] cls2 = py . error . _geterrnoclass ( num ) [EOL] assert cls is cls2 [EOL] [EOL] [EOL] def test_error_conversion_ENOTDIR ( testdir ) : [EOL] p = testdir . makepyfile ( [string] ) [EOL] excinfo = py . test . raises ( py . error . Error , py . error . checked_call , p . listdir ) [EOL] assert isinstance ( excinfo . value , EnvironmentError ) [EOL] assert isinstance ( excinfo . value , py . error . Error ) [EOL] assert [string] in repr ( excinfo . value ) [EOL] [EOL] [EOL] def test_checked_call_supports_kwargs ( tmpdir ) : [EOL] import tempfile [EOL] py . error . checked_call ( tempfile . mkdtemp , dir = str ( tmpdir ) ) [EOL] [EOL] [EOL] try : [EOL] import unittest [EOL] unittest . TestCase . assertWarns [EOL] except ( ImportError , AttributeError ) : [EOL] pass [comment] [EOL] else : [EOL] import sys [EOL] import warnings [EOL] [EOL] class Case ( unittest . TestCase ) : [EOL] def test_assertWarns ( self ) : [EOL] [comment] [EOL] [comment] [EOL] for mod in tuple ( sys . modules . keys ( ) ) : [EOL] if mod and ( mod == [string] or mod . startswith ( [string] ) ) : [EOL] del sys . modules [ mod ] [EOL] import py [EOL] [EOL] with self . assertWarns ( UserWarning ) : [EOL] warnings . warn ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL]	0 0
from typing import Any [EOL] import tests [EOL] import typing [EOL] import pytest [EOL] import py , sys , os [EOL] [EOL] pytestmark = py . test . mark . skipif ( [string] ) [EOL] [EOL] [EOL] def test_waitfinish_removes_tempdir ( ) : [EOL] ff = py . process . ForkedFunc ( boxf1 ) [EOL] assert ff . tempdir . check ( ) [EOL] ff . waitfinish ( ) [EOL] assert not ff . tempdir . check ( ) [EOL] [EOL] def test_tempdir_gets_gc_collected ( monkeypatch ) : [EOL] monkeypatch . setattr ( os , [string] , lambda : os . getpid ( ) ) [EOL] ff = py . process . ForkedFunc ( boxf1 ) [EOL] assert ff . tempdir . check ( ) [EOL] ff . __del__ ( ) [EOL] assert not ff . tempdir . check ( ) [EOL] [EOL] def test_basic_forkedfunc ( ) : [EOL] result = py . process . ForkedFunc ( boxf1 ) . waitfinish ( ) [EOL] assert result . out == [string] [EOL] assert result . err == [string] [EOL] assert result . exitstatus == [number] [EOL] assert result . signal == [number] [EOL] assert result . retval == [number] [EOL] [EOL] def test_exitstatus ( ) : [EOL] def func ( ) : [EOL] os . _exit ( [number] ) [EOL] result = py . process . ForkedFunc ( func ) . waitfinish ( ) [EOL] assert result . exitstatus == [number] [EOL] assert result . signal == [number] [EOL] assert not result . out [EOL] assert not result . err [EOL] [EOL] def test_execption_in_func ( ) : [EOL] def fun ( ) : [EOL] raise ValueError ( [number] ) [EOL] ff = py . process . ForkedFunc ( fun ) [EOL] result = ff . waitfinish ( ) [EOL] assert result . exitstatus == ff . EXITSTATUS_EXCEPTION [EOL] assert result . err . find ( [string] ) != - [number] [EOL] assert result . signal == [number] [EOL] assert not result . retval [EOL] [EOL] def test_forkedfunc_on_fds ( ) : [EOL] result = py . process . ForkedFunc ( boxf2 ) . waitfinish ( ) [EOL] assert result . out == [string] [EOL] assert result . err == [string] [EOL] assert result . exitstatus == [number] [EOL] assert result . signal == [number] [EOL] assert result . retval == [number] [EOL] [EOL] def test_forkedfunc_on_fds_output ( ) : [EOL] result = py . process . ForkedFunc ( boxf3 ) . waitfinish ( ) [EOL] assert result . signal == [number] [EOL] assert result . out == [string] [EOL] [EOL] [EOL] def test_forkedfunc_on_stdout ( ) : [EOL] def boxf3 ( ) : [EOL] import sys [EOL] sys . stdout . write ( [string] ) [EOL] os . kill ( os . getpid ( ) , [number] ) [EOL] result = py . process . ForkedFunc ( boxf3 ) . waitfinish ( ) [EOL] assert result . signal == [number] [EOL] assert result . out == [string] [EOL] [EOL] def test_forkedfunc_signal ( ) : [EOL] result = py . process . ForkedFunc ( boxseg ) . waitfinish ( ) [EOL] assert result . retval is None [EOL] assert result . signal == [number] [EOL] [EOL] def test_forkedfunc_huge_data ( ) : [EOL] result = py . process . ForkedFunc ( boxhuge ) . waitfinish ( ) [EOL] assert result . out [EOL] assert result . exitstatus == [number] [EOL] assert result . signal == [number] [EOL] assert result . retval == [number] [EOL] [EOL] def test_box_seq ( ) : [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] result = py . process . ForkedFunc ( boxhuge ) . waitfinish ( ) [EOL] assert result . out [EOL] assert result . exitstatus == [number] [EOL] assert result . signal == [number] [EOL] assert result . retval == [number] [EOL] [EOL] def test_box_in_a_box ( ) : [EOL] def boxfun ( ) : [EOL] result = py . process . ForkedFunc ( boxf2 ) . waitfinish ( ) [EOL] print ( result . out ) [EOL] sys . stderr . write ( result . err + [string] ) [EOL] return result . retval [EOL] [EOL] result = py . process . ForkedFunc ( boxfun ) . waitfinish ( ) [EOL] assert result . out == [string] [EOL] assert result . err == [string] [EOL] assert result . exitstatus == [number] [EOL] assert result . signal == [number] [EOL] assert result . retval == [number] [EOL] [EOL] def test_kill_func_forked ( ) : [EOL] class A : [EOL] pass [EOL] info = A ( ) [EOL] import time [EOL] [EOL] def box_fun ( ) : [EOL] time . sleep ( [number] ) [comment] [EOL] [EOL] ff = py . process . ForkedFunc ( box_fun ) [EOL] os . kill ( ff . pid , [number] ) [EOL] result = ff . waitfinish ( ) [EOL] assert result . signal == [number] [EOL] [EOL] [EOL] def test_hooks ( monkeypatch ) : [EOL] def _boxed ( ) : [EOL] return [number] [EOL] [EOL] def _on_start ( ) : [EOL] sys . stdout . write ( [string] ) [EOL] sys . stdout . flush ( ) [EOL] [EOL] def _on_exit ( ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . stderr . flush ( ) [EOL] [EOL] result = py . process . ForkedFunc ( _boxed , child_on_start = _on_start , child_on_exit = _on_exit ) . waitfinish ( ) [EOL] assert result . out == [string] [EOL] assert result . err == [string] [EOL] assert result . exitstatus == [number] [EOL] assert result . signal == [number] [EOL] assert result . retval == [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def boxf1 ( ) : [EOL] sys . stdout . write ( [string] ) [EOL] sys . stderr . write ( [string] ) [EOL] return [number] [EOL] [EOL] def boxf2 ( ) : [EOL] os . write ( [number] , [string] . encode ( [string] ) ) [EOL] os . write ( [number] , [string] . encode ( [string] ) ) [EOL] return [number] [EOL] [EOL] def boxf3 ( ) : [EOL] os . write ( [number] , [string] . encode ( [string] ) ) [EOL] os . kill ( os . getpid ( ) , [number] ) [EOL] [EOL] def boxseg ( ) : [EOL] os . kill ( os . getpid ( ) , [number] ) [EOL] [EOL] def boxhuge ( ) : [EOL] s = [string] . encode ( [string] ) [EOL] os . write ( [number] , s * [number] ) [EOL] os . write ( [number] , s * [number] ) [EOL] os . write ( [number] , s * [number] ) [EOL] [EOL] os . write ( [number] , s * [number] ) [EOL] os . write ( [number] , s * [number] ) [EOL] os . write ( [number] , s * [number] ) [EOL] os . write ( [number] , s * [number] ) [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import py [EOL] import os , sys [EOL] import pytest [EOL] from py . _path . svnwc import InfoSvnWCCommand , XMLWCStatus , parse_wcinfotime [EOL] from py . _path import svnwc as svncommon [EOL] from svntestbase import CommonSvnTests [EOL] [EOL] [EOL] pytestmark = pytest . mark . xfail ( sys . platform . startswith ( [string] ) , reason = [string] , run = False ) [EOL] [EOL] [EOL] def test_make_repo ( path1 , tmpdir ) : [EOL] repo = tmpdir . join ( [string] ) [EOL] py . process . cmdexec ( [string] % repo ) [EOL] if sys . platform == [string] : [EOL] repo = [string] + str ( repo ) . replace ( [string] , [string] ) [EOL] repo = py . path . svnurl ( [string] % repo ) [EOL] wc = py . path . svnwc ( tmpdir . join ( [string] ) ) [EOL] wc . checkout ( repo ) [EOL] assert wc . rev == [number] [EOL] assert len ( wc . listdir ( ) ) == [number] [EOL] p = wc . join ( [string] ) [EOL] p . write ( [string] ) [EOL] p . add ( ) [EOL] rev = wc . commit ( [string] ) [EOL] assert p . info ( ) . rev == [number] [EOL] assert rev == [number] [EOL] rev = wc . commit ( ) [EOL] assert rev is None [EOL] [EOL] def pytest_funcarg__path1 ( request ) : [EOL] repo , repourl , wc = request . getfuncargvalue ( [string] ) [EOL] return wc [EOL] [EOL] class TestWCSvnCommandPath ( CommonSvnTests ) : [EOL] def test_status_attributes_simple ( self , path1 ) : [EOL] def assert_nochange ( p ) : [EOL] s = p . status ( ) [EOL] assert not s . modified [EOL] assert not s . prop_modified [EOL] assert not s . added [EOL] assert not s . deleted [EOL] assert not s . replaced [EOL] [EOL] dpath = path1 . join ( [string] ) [EOL] assert_nochange ( path1 . join ( [string] ) ) [EOL] assert_nochange ( path1 . join ( [string] ) ) [EOL] [EOL] def test_status_added ( self , path1 ) : [EOL] nf = path1 . join ( [string] ) [EOL] nf . write ( [string] ) [EOL] nf . add ( ) [EOL] try : [EOL] s = nf . status ( ) [EOL] assert s . added [EOL] assert not s . modified [EOL] assert not s . prop_modified [EOL] assert not s . replaced [EOL] finally : [EOL] nf . revert ( ) [EOL] [EOL] def test_status_change ( self , path1 ) : [EOL] nf = path1 . join ( [string] ) [EOL] try : [EOL] nf . write ( nf . read ( ) + [string] ) [EOL] s = nf . status ( ) [EOL] assert not s . added [EOL] assert s . modified [EOL] assert not s . prop_modified [EOL] assert not s . replaced [EOL] finally : [EOL] nf . revert ( ) [EOL] [EOL] def test_status_added_ondirectory ( self , path1 ) : [EOL] sampledir = path1 . join ( [string] ) [EOL] try : [EOL] t2 = sampledir . mkdir ( [string] ) [EOL] t1 = t2 . join ( [string] ) [EOL] t1 . write ( [string] ) [EOL] t1 . add ( ) [EOL] s = sampledir . status ( rec = [number] ) [EOL] [comment] [EOL] [comment] [EOL] assert t1 . basename in [ item . basename for item in s . added ] [EOL] assert t2 . basename in [ item . basename for item in s . added ] [EOL] finally : [EOL] t2 . revert ( rec = [number] ) [EOL] t2 . localpath . remove ( rec = [number] ) [EOL] [EOL] def test_status_unknown ( self , path1 ) : [EOL] t1 = path1 . join ( [string] ) [EOL] try : [EOL] t1 . write ( [string] ) [EOL] s = path1 . status ( ) [EOL] [comment] [EOL] [comment] [EOL] assert t1 . basename in [ item . basename for item in s . unknown ] [EOL] finally : [EOL] t1 . localpath . remove ( ) [EOL] [EOL] def test_status_unchanged ( self , path1 ) : [EOL] r = path1 [EOL] s = path1 . status ( rec = [number] ) [EOL] [comment] [EOL] [comment] [EOL] assert r . join ( [string] ) . basename in [ item . basename for item in s . unchanged ] [EOL] assert r . join ( [string] ) . basename in [ item . basename for item in s . unchanged ] [EOL] assert r . join ( [string] ) . basename in [ item . basename for item in s . unchanged ] [EOL] [EOL] def test_status_update ( self , path1 ) : [EOL] [comment] [EOL] pytest . xfail ( [string] ) [EOL] r = path1 [EOL] try : [EOL] r . update ( rev = [number] ) [EOL] s = r . status ( updates = [number] , rec = [number] ) [EOL] [comment] [EOL] [comment] [EOL] import pprint [EOL] pprint . pprint ( s . allpath ( ) ) [EOL] assert r . join ( [string] ) . basename in [ item . basename for item in s . update_available ] [EOL] [comment] [EOL] finally : [EOL] r . update ( ) [EOL] [EOL] def test_status_replaced ( self , path1 ) : [EOL] p = path1 . join ( [string] ) [EOL] p . remove ( ) [EOL] p . ensure ( dir = [number] ) [EOL] try : [EOL] s = path1 . status ( ) [EOL] assert p . basename in [ item . basename for item in s . replaced ] [EOL] finally : [EOL] path1 . revert ( rec = [number] ) [EOL] [EOL] def test_status_ignored ( self , path1 ) : [EOL] try : [EOL] d = path1 . join ( [string] ) [EOL] p = py . path . local ( d ) . join ( [string] ) [EOL] p . ensure ( file = True ) [EOL] s = d . status ( ) [EOL] assert [ x . basename for x in s . unknown ] == [ [string] ] [EOL] assert [ x . basename for x in s . ignored ] == [ ] [EOL] d . propset ( [string] , [string] ) [EOL] s = d . status ( ) [EOL] assert [ x . basename for x in s . unknown ] == [ ] [EOL] assert [ x . basename for x in s . ignored ] == [ [string] ] [EOL] finally : [EOL] path1 . revert ( rec = [number] ) [EOL] [EOL] def test_status_conflict ( self , path1 , tmpdir ) : [EOL] wc = path1 [EOL] wccopy = py . path . svnwc ( tmpdir . join ( [string] ) ) [EOL] wccopy . checkout ( wc . url ) [EOL] p = wc . ensure ( [string] , file = [number] ) [EOL] p . write ( [string] ) [EOL] wc . commit ( [string] ) [EOL] wccopy . update ( ) [EOL] assert wccopy . join ( [string] ) . check ( ) [EOL] p . write ( [string] ) [EOL] wc . commit ( [string] ) [EOL] wccopy . join ( [string] ) . write ( [string] ) [EOL] wccopy . update ( interactive = False ) [EOL] s = wccopy . status ( ) [EOL] assert [ x . basename for x in s . conflict ] == [ [string] ] [EOL] [EOL] def test_status_external ( self , path1 , repowc2 ) : [EOL] otherrepo , otherrepourl , otherwc = repowc2 [EOL] d = path1 . ensure ( [string] , dir = [number] ) [EOL] try : [EOL] d . update ( ) [EOL] d . propset ( [string] , [string] % ( otherwc . url , ) ) [EOL] d . update ( ) [EOL] s = d . status ( ) [EOL] assert [ x . basename for x in s . external ] == [ [string] ] [EOL] assert [string] not in [ x . basename for x in s . unchanged ] [EOL] s = d . status ( rec = [number] ) [EOL] assert [ x . basename for x in s . external ] == [ [string] ] [EOL] assert [string] in [ x . basename for x in s . unchanged ] [EOL] finally : [EOL] path1 . revert ( rec = [number] ) [EOL] [EOL] def test_status_deleted ( self , path1 ) : [EOL] d = path1 . ensure ( [string] , dir = [number] ) [EOL] d . remove ( ) [EOL] d . ensure ( dir = [number] ) [EOL] path1 . commit ( ) [EOL] d . ensure ( [string] , dir = [number] ) [EOL] d . commit ( ) [EOL] s = d . status ( ) [EOL] assert [string] in [ x . basename for x in s . unchanged ] [EOL] assert not s . deleted [EOL] p = d . join ( [string] ) [EOL] p . remove ( ) [EOL] s = d . status ( ) [EOL] assert [string] not in s . unchanged [EOL] assert [ x . basename for x in s . deleted ] == [ [string] ] [EOL] [EOL] def test_status_noauthor ( self , path1 ) : [EOL] [comment] [EOL] xml = [string] [EOL] XMLWCStatus . fromstring ( xml , path1 ) [EOL] [EOL] def test_status_wrong_xml ( self , path1 ) : [EOL] [comment] [EOL] xml = [string] [EOL] st = XMLWCStatus . fromstring ( xml , path1 ) [EOL] assert len ( st . incomplete ) == [number] [EOL] [EOL] def test_diff ( self , path1 ) : [EOL] p = path1 / [string] [EOL] out = p . diff ( rev = [number] ) [EOL] assert out . find ( [string] ) != - [number] [EOL] [EOL] def test_blame ( self , path1 ) : [EOL] p = path1 . join ( [string] ) [EOL] lines = p . blame ( ) [EOL] assert sum ( [ l [ [number] ] for l in lines ] ) == len ( lines ) [EOL] for l1 , l2 in zip ( p . readlines ( ) , [ l [ [number] ] for l in lines ] ) : [EOL] assert l1 == l2 [EOL] assert [ l [ [number] ] for l in lines ] == [ [string] ] * len ( lines ) [EOL] p = path1 . join ( [string] ) [EOL] lines = p . blame ( ) [EOL] assert sum ( [ l [ [number] ] for l in lines ] ) == len ( lines ) [EOL] for l1 , l2 in zip ( p . readlines ( ) , [ l [ [number] ] for l in lines ] ) : [EOL] assert l1 == l2 [EOL] assert [ l [ [number] ] for l in lines ] == [ [string] ] * len ( lines ) [EOL] [EOL] def test_join_abs ( self , path1 ) : [EOL] s = str ( path1 . localpath ) [EOL] n = path1 . join ( s , abs = [number] ) [EOL] assert path1 == n [EOL] [EOL] def test_join_abs2 ( self , path1 ) : [EOL] assert path1 . join ( [string] , abs = [number] ) == path1 . join ( [string] ) [EOL] [EOL] def test_str_gives_localpath ( self , path1 ) : [EOL] assert str ( path1 ) == str ( path1 . localpath ) [EOL] [EOL] def test_versioned ( self , path1 ) : [EOL] assert path1 . check ( versioned = [number] ) [EOL] [comment] [EOL] [comment] [EOL] assert path1 . join ( [string] ) . check ( versioned = [number] ) [EOL] assert not path1 . join ( [string] ) . check ( versioned = [number] ) [EOL] notexisting = path1 . join ( [string] ) . localpath [EOL] try : [EOL] notexisting . write ( [string] ) [EOL] assert path1 . join ( [string] ) . check ( versioned = [number] ) [EOL] finally : [EOL] notexisting . remove ( ) [EOL] [EOL] def test_listdir_versioned ( self , path1 ) : [EOL] assert path1 . check ( versioned = [number] ) [EOL] p = path1 . localpath . ensure ( [string] ) [EOL] l = [ x . localpath for x in path1 . listdir ( lambda x : x . check ( versioned = True ) ) ] [EOL] assert p not in l [EOL] [EOL] def test_nonversioned_remove ( self , path1 ) : [EOL] assert path1 . check ( versioned = [number] ) [EOL] somefile = path1 . join ( [string] ) [EOL] nonwc = py . path . local ( somefile ) [EOL] nonwc . ensure ( ) [EOL] assert somefile . check ( ) [EOL] assert not somefile . check ( versioned = True ) [EOL] somefile . remove ( ) [comment] [EOL] [EOL] def test_properties ( self , path1 ) : [EOL] try : [EOL] path1 . propset ( [string] , [string] ) [EOL] assert path1 . propget ( [string] ) == [string] [EOL] [comment] [EOL] [comment] [EOL] assert path1 . basename in [ item . basename for item in path1 . status ( ) . prop_modified ] [EOL] assert [string] in path1 . proplist ( ) [EOL] assert path1 . proplist ( ) [ [string] ] == [string] [EOL] [EOL] finally : [EOL] path1 . propdel ( [string] ) [EOL] [EOL] def test_proplist_recursive ( self , path1 ) : [EOL] s = path1 . join ( [string] ) [EOL] s . propset ( [string] , [string] ) [EOL] try : [EOL] p = path1 . proplist ( rec = [number] ) [EOL] [comment] [EOL] [comment] [EOL] assert ( path1 / [string] ) . basename in [ item . basename for item in p ] [EOL] finally : [EOL] s . propdel ( [string] ) [EOL] [EOL] def test_long_properties ( self , path1 ) : [EOL] value = [string] [EOL] try : [EOL] path1 . propset ( [string] , value ) [EOL] backvalue = path1 . propget ( [string] ) [EOL] assert backvalue == value [EOL] [comment] [EOL] finally : [EOL] path1 . propdel ( [string] ) [EOL] [EOL] [EOL] def test_ensure ( self , path1 ) : [EOL] newpath = path1 . ensure ( [string] , [string] , [string] ) [EOL] try : [EOL] assert newpath . check ( exists = [number] , versioned = [number] ) [EOL] newpath . write ( [string] ) [EOL] newpath . ensure ( ) [EOL] assert newpath . read ( ) == [string] [EOL] finally : [EOL] path1 . join ( [string] ) . remove ( force = [number] ) [EOL] [EOL] def test_not_versioned ( self , path1 ) : [EOL] p = path1 . localpath . mkdir ( [string] ) [EOL] f = path1 . localpath . ensure ( [string] ) [EOL] try : [EOL] assert path1 . join ( [string] ) . check ( versioned = [number] ) [EOL] assert path1 . join ( [string] ) . check ( versioned = [number] ) [EOL] assert not path1 . join ( [string] ) . check ( versioned = [number] ) [EOL] finally : [EOL] p . remove ( rec = [number] ) [EOL] f . remove ( ) [EOL] [EOL] def test_lock_unlock ( self , path1 ) : [EOL] root = path1 [EOL] somefile = root . join ( [string] ) [EOL] somefile . ensure ( file = True ) [EOL] [comment] [EOL] py . test . raises ( Exception , [string] ) [EOL] somefile . write ( [string] ) [EOL] somefile . commit ( [string] ) [EOL] assert somefile . check ( versioned = True ) [EOL] somefile . lock ( ) [EOL] try : [EOL] locked = root . status ( ) . locked [EOL] assert len ( locked ) == [number] [EOL] assert locked [ [number] ] . basename == somefile . basename [EOL] assert locked [ [number] ] . dirpath ( ) . basename == somefile . dirpath ( ) . basename [EOL] [comment] [EOL] py . test . raises ( Exception , [string] ) [EOL] finally : [EOL] somefile . unlock ( ) [EOL] [comment] [EOL] locked = root . status ( ) . locked [EOL] assert locked == [ ] [EOL] py . test . raises ( Exception , [string] ) [EOL] somefile . remove ( ) [EOL] [EOL] def test_commit_nonrecursive ( self , path1 ) : [EOL] somedir = path1 . join ( [string] ) [EOL] somedir . mkdir ( [string] ) [EOL] somedir . propset ( [string] , [string] ) [EOL] status = somedir . status ( ) [EOL] assert len ( status . prop_modified ) == [number] [EOL] assert len ( status . added ) == [number] [EOL] [EOL] somedir . commit ( [string] , rec = [number] ) [EOL] status = somedir . status ( ) [EOL] assert len ( status . prop_modified ) == [number] [EOL] assert len ( status . added ) == [number] [EOL] [EOL] somedir . commit ( [string] ) [EOL] status = somedir . status ( ) [EOL] assert len ( status . prop_modified ) == [number] [EOL] assert len ( status . added ) == [number] [EOL] [EOL] def test_commit_return_value ( self , path1 ) : [EOL] testfile = path1 . join ( [string] ) . ensure ( file = True ) [EOL] testfile . write ( [string] ) [EOL] rev = path1 . commit ( [string] ) [EOL] assert type ( rev ) == int [EOL] [EOL] anotherfile = path1 . join ( [string] ) . ensure ( file = True ) [EOL] anotherfile . write ( [string] ) [EOL] rev2 = path1 . commit ( [string] ) [EOL] assert type ( rev2 ) == int [EOL] assert rev2 == rev + [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class XTestWCSvnCommandPathSpecial : [EOL] [EOL] rooturl = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def test_parse_wcinfotime ( ) : [EOL] assert ( parse_wcinfotime ( [string] ) == [number] ) [EOL] assert ( parse_wcinfotime ( [string] ) == [number] ) [EOL] [EOL] class TestInfoSvnWCCommand : [EOL] [EOL] def test_svn_1_2 ( self , path1 ) : [EOL] output = [string] [EOL] path = py . path . local ( __file__ ) . dirpath ( ) . chdir ( ) [EOL] try : [EOL] info = InfoSvnWCCommand ( output ) [EOL] finally : [EOL] path . chdir ( ) [EOL] assert info . last_author == [string] [EOL] assert info . kind == [string] [EOL] assert info . mtime == [number] [EOL] assert info . url == [string] [EOL] assert info . time == [number] [EOL] assert info . rev == [number] [EOL] [EOL] [EOL] def test_svn_1_3 ( self , path1 ) : [EOL] output = [string] [EOL] path = py . path . local ( __file__ ) . dirpath ( ) . chdir ( ) [EOL] try : [EOL] info = InfoSvnWCCommand ( output ) [EOL] finally : [EOL] path . chdir ( ) [EOL] assert info . last_author == [string] [EOL] assert info . kind == [string] [EOL] assert info . mtime == [number] [EOL] assert info . url == [string] [EOL] assert info . rev == [number] [EOL] assert info . time == [number] [EOL] [EOL] [EOL] def test_characters_at ( ) : [EOL] py . test . raises ( ValueError , [string] ) [EOL] [EOL] def test_characters_tilde ( ) : [EOL] py . path . svnwc ( [string] ) [EOL] [EOL] [EOL] class TestRepo : [EOL] def test_trailing_slash_is_stripped ( self , path1 ) : [EOL] [comment] [EOL] url = path1 . join ( [string] ) [EOL] assert path1 == url [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def test_exists_svn_root ( self , path1 ) : [EOL] assert path1 . check ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def test_repocache_simple ( self , path1 ) : [EOL] repocache = svncommon . RepoCache ( ) [EOL] repocache . put ( path1 . strpath , [number] ) [EOL] url , rev = repocache . get ( path1 . join ( [string] ) . strpath ) [EOL] assert rev == [number] [EOL] assert url == path1 . strpath [EOL] [EOL] def test_repocache_notimeout ( self , path1 ) : [EOL] repocache = svncommon . RepoCache ( ) [EOL] repocache . timeout = [number] [EOL] repocache . put ( path1 . strpath , path1 . rev ) [EOL] url , rev = repocache . get ( path1 . strpath ) [EOL] assert rev == - [number] [EOL] assert url == path1 . strpath [EOL] [EOL] def test_repocache_outdated ( self , path1 ) : [EOL] repocache = svncommon . RepoCache ( ) [EOL] repocache . put ( path1 . strpath , [number] , timestamp = [number] ) [EOL] url , rev = repocache . get ( path1 . join ( [string] ) . strpath ) [EOL] assert rev == - [number] [EOL] assert url == path1 . strpath [EOL] [EOL] def _test_getreporev ( self ) : [EOL] [docstring] [EOL] old = svncommon . repositories . repos [EOL] try : [EOL] _repocache . clear ( ) [EOL] root = path1 . new ( rev = - [number] ) [EOL] url , rev = cache . repocache . get ( root . strpath ) [EOL] assert rev >= [number] [EOL] assert url == svnrepourl [EOL] finally : [EOL] repositories . repos = old [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] [EOL] class HTTP20Error ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class HPACKEncodingError ( HTTP20Error ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class HPACKDecodingError ( HTTP20Error ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class ConnectionError ( HTTP20Error ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class ProtocolError ( HTTP20Error ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class StreamResetError ( HTTP20Error ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Set , DefaultDict , Any , List [EOL] import typing [EOL] [docstring] [EOL] from collections import defaultdict [EOL] [EOL] [EOL] def combine_repeated_headers ( kvset ) : [EOL] [docstring] [EOL] def set_pop ( set , item ) : [EOL] set . remove ( item ) [EOL] return item [EOL] [EOL] headers = defaultdict ( list ) [EOL] keys = set ( ) [EOL] [EOL] for key , value in kvset : [EOL] headers [ key ] . append ( value ) [EOL] keys . add ( key ) [EOL] [EOL] return [ ( set_pop ( keys , k ) , [string] . join ( headers [ k ] ) ) for k , v in kvset if k in keys ] [EOL] [EOL] [EOL] def split_repeated_headers ( kvset ) : [EOL] [docstring] [EOL] headers = defaultdict ( list ) [EOL] [EOL] for key , value in kvset : [EOL] headers [ key ] = value . split ( [string] ) [EOL] [EOL] return dict ( headers ) [EOL] [EOL] [EOL] def h2_safe_headers ( headers ) : [EOL] [docstring] [EOL] stripped = { i . lower ( ) . strip ( ) for k , v in headers if k == [string] for i in v . split ( [string] ) } [EOL] stripped . add ( [string] ) [EOL] [EOL] return [ header for header in headers if header [ [number] ] not in stripped ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL]	0 0 0 0
[comment] [EOL] [docstring] [EOL]	0 0 0 0
[comment] [EOL] [docstring] [EOL]	0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import weakref [EOL] import zlib [EOL] [EOL] from . . common . decoder import DeflateDecoder [EOL] from . . common . exceptions import ChunkedDecodeError , InvalidResponseError [EOL] from . . common . exceptions import ConnectionResetError [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class HTTP11Response ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , code , reason , headers , sock , connection = None ) : [EOL] [comment] [EOL] self . reason = reason [EOL] [EOL] [comment] [EOL] self . status = code [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . headers = headers [EOL] [EOL] [comment] [EOL] self . trailers = None [EOL] [EOL] [comment] [EOL] self . _sock = sock [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _expect_close = False [EOL] if [string] in self . headers . get ( [string] , [ ] ) : [EOL] self . _expect_close = True [EOL] [EOL] [comment] [EOL] try : [EOL] self . _length = int ( self . headers [ [string] ] [ [number] ] ) [EOL] except KeyError : [EOL] self . _length = None [EOL] [EOL] [comment] [EOL] self . _chunked = ( [string] in self . headers . get ( [string] , [ ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert self . _expect_close or self . _length is not None or self . _chunked [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in self . headers . get ( [string] , [ ] ) : [EOL] self . _decompressobj = zlib . decompressobj ( [number] + zlib . MAX_WBITS ) [EOL] elif [string] in self . headers . get ( [string] , [ ] ) : [EOL] self . _decompressobj = DeflateDecoder ( ) [EOL] else : [EOL] self . _decompressobj = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if connection is not None : [EOL] self . _parent = weakref . ref ( connection ) [EOL] else : [EOL] self . _parent = None [EOL] [EOL] self . _buffered_data = [string] [EOL] self . _chunker = None [EOL] [EOL] def read ( self , amt = None , decode_content = True ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _sock is None : [EOL] return [string] [EOL] [EOL] if self . _chunked : [EOL] return self . _normal_read_chunked ( amt , decode_content ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if amt is None : [EOL] if self . _length is not None : [EOL] amt = self . _length [EOL] elif self . _expect_close : [EOL] return self . _read_expect_closed ( decode_content ) [EOL] else : [comment] [EOL] raise InvalidResponseError ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . _length is not None : [EOL] amt = min ( amt , self . _length ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] to_read = amt [EOL] chunks = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] while to_read > [number] : [EOL] chunk = self . _sock . recv ( amt ) . tobytes ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not chunk : [EOL] if self . _length is not None or not self . _expect_close : [EOL] self . close ( socket_close = True ) [EOL] raise ConnectionResetError ( [string] ) [EOL] [EOL] break [EOL] [EOL] to_read -= len ( chunk ) [EOL] chunks . append ( chunk ) [EOL] [EOL] data = [string] . join ( chunks ) [EOL] if self . _length is not None : [EOL] self . _length -= len ( data ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] end_of_request = ( self . _length == [number] or ( self . _expect_close and len ( data ) < amt ) ) [EOL] [EOL] [comment] [EOL] if decode_content and self . _decompressobj and data : [EOL] data = self . _decompressobj . decompress ( data ) [EOL] [EOL] if decode_content and self . _decompressobj and end_of_request : [EOL] data += self . _decompressobj . flush ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if end_of_request : [EOL] self . close ( socket_close = self . _expect_close ) [EOL] [EOL] return data [EOL] [EOL] def read_chunked ( self , decode_content = True ) : [EOL] [docstring] [EOL] if not self . _chunked : [EOL] raise ChunkedDecodeError ( [string] ) [EOL] [EOL] [comment] [EOL] if self . _sock is None : [EOL] return [EOL] [EOL] while True : [EOL] [comment] [EOL] [comment] [EOL] chunk_length = int ( self . _sock . readline ( ) . tobytes ( ) . strip ( ) , [number] ) [EOL] data = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not chunk_length : [EOL] self . _sock . readline ( ) [EOL] [EOL] if decode_content and self . _decompressobj : [EOL] yield self . _decompressobj . flush ( ) [EOL] [EOL] self . close ( socket_close = self . _expect_close ) [EOL] break [EOL] [EOL] [comment] [EOL] while chunk_length > [number] : [EOL] chunk = self . _sock . recv ( chunk_length ) . tobytes ( ) [EOL] data += chunk [EOL] chunk_length -= len ( chunk ) [EOL] [EOL] assert chunk_length == [number] [EOL] [EOL] [comment] [EOL] self . _sock . readline ( ) [EOL] [EOL] [comment] [EOL] if decode_content and self . _decompressobj and data : [EOL] data = self . _decompressobj . decompress ( data ) [EOL] [EOL] yield data [EOL] [EOL] return [EOL] [EOL] def close ( self , socket_close = False ) : [EOL] [docstring] [EOL] if socket_close and self . _parent is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parent = self . _parent ( ) [EOL] if parent is not None : [EOL] parent . close ( ) [EOL] [EOL] self . _sock = None [EOL] [EOL] def _read_expect_closed ( self , decode_content ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] chunks = [ ] [EOL] while True : [EOL] try : [EOL] chunk = self . _sock . recv ( [number] ) . tobytes ( ) [EOL] if not chunk : [EOL] break [EOL] except ConnectionResetError : [EOL] break [EOL] else : [EOL] chunks . append ( chunk ) [EOL] [EOL] self . close ( socket_close = True ) [EOL] [EOL] [comment] [EOL] data = [string] . join ( chunks ) [EOL] if decode_content and self . _decompressobj : [EOL] data = self . _decompressobj . decompress ( data ) [EOL] data += self . _decompressobj . flush ( ) [EOL] [EOL] return data [EOL] [EOL] def _normal_read_chunked ( self , amt , decode_content ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if amt is None : [EOL] return self . _buffered_data + [string] . join ( self . read_chunked ( ) ) [EOL] [EOL] if self . _chunker is None : [EOL] self . _chunker = self . read_chunked ( ) [EOL] [EOL] [comment] [EOL] current_amount = len ( self . _buffered_data ) [EOL] [EOL] extra_data = [ self . _buffered_data ] [EOL] while current_amount < amt : [EOL] try : [EOL] chunk = next ( self . _chunker ) [EOL] except StopIteration : [EOL] self . close ( socket_close = self . _expect_close ) [EOL] break [EOL] [EOL] current_amount += len ( chunk ) [EOL] extra_data . append ( chunk ) [EOL] [EOL] data = [string] . join ( extra_data ) [EOL] self . _buffered_data = data [ amt : ] [EOL] return data [ : amt ] [EOL] [EOL] [comment] [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , * args ) : [EOL] self . close ( ) [EOL] return False [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.bytes]$ 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import sys [EOL] [EOL] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] unicode = str [comment] [EOL] [EOL] [EOL] def to_str ( b , encoding ) : [EOL] if hasattr ( b , [string] ) and not isinstance ( b , unicode ) : [EOL] b = b . decode ( [string] ) [EOL] return b [EOL] [EOL] [EOL] def to_bytes ( s , encoding ) : [EOL] if hasattr ( s , [string] ) and not isinstance ( s , bytes ) : [EOL] s = s . encode ( [string] ) [EOL] return s [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from . uri import URIReference [EOL] from . parseresult import ParseResult [EOL] [EOL] [EOL] def uri_reference ( uri , encoding = [string] ) : [EOL] [docstring] [EOL] return URIReference . from_string ( uri , encoding ) [EOL] [EOL] [EOL] def is_valid_uri ( uri , encoding = [string] , ** kwargs ) : [EOL] [docstring] [EOL] return URIReference . from_string ( uri , encoding ) . is_valid ( ** kwargs ) [EOL] [EOL] [EOL] def normalize_uri ( uri , encoding = [string] ) : [EOL] [docstring] [EOL] normalized_reference = URIReference . from_string ( uri , encoding ) . normalize ( ) [EOL] return normalized_reference . unsplit ( ) [EOL] [EOL] [EOL] def urlparse ( uri , encoding = [string] ) : [EOL] [docstring] [EOL] return ParseResult . from_string ( uri , encoding , strict = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] __version__ = [string] [EOL]	0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] REQUEST_CODES = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL] [EOL] REQUEST_CODES_LENGTH = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] __version__ = [string] [EOL]	0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] class HTTP20Error ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class HPACKEncodingError ( HTTP20Error ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class HPACKDecodingError ( HTTP20Error ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class ConnectionError ( HTTP20Error ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class ProtocolError ( HTTP20Error ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Callable , Any [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import binascii [EOL] [EOL] from . settings import ChangedSetting , _setting_code_from_int [EOL] [EOL] [EOL] class Event ( object ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class RequestReceived ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . stream_id = None [EOL] [EOL] [comment] [EOL] self . headers = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . stream_ended = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . priority_updated = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . stream_id , self . headers ) [EOL] [EOL] [EOL] class ResponseReceived ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . stream_id = None [EOL] [EOL] [comment] [EOL] self . headers = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . stream_ended = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . priority_updated = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . stream_id , self . headers ) [EOL] [EOL] [EOL] class TrailersReceived ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . stream_id = None [EOL] [EOL] [comment] [EOL] self . headers = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . stream_ended = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . priority_updated = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . stream_id , self . headers ) [EOL] [EOL] [EOL] class _HeadersSent ( Event ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class _ResponseSent ( _HeadersSent ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class _RequestSent ( _HeadersSent ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class _TrailersSent ( _HeadersSent ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class _PushedRequestSent ( _HeadersSent ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class InformationalResponseReceived ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . stream_id = None [EOL] [EOL] [comment] [EOL] self . headers = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . priority_updated = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . stream_id , self . headers ) [EOL] [EOL] [EOL] class DataReceived ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . stream_id = None [EOL] [EOL] [comment] [EOL] self . data = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . flow_controlled_length = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . stream_ended = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( [string] [string] [string] % ( self . stream_id , self . flow_controlled_length , _bytes_representation ( self . data [ : [number] ] ) , ) ) [EOL] [EOL] [EOL] class WindowUpdated ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . stream_id = None [EOL] [EOL] [comment] [EOL] self . delta = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . stream_id , self . delta ) [EOL] [EOL] [EOL] class RemoteSettingsChanged ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . changed_settings = { } [EOL] [EOL] @ classmethod def from_settings ( cls , old_settings , new_settings ) : [EOL] [docstring] [EOL] e = cls ( ) [EOL] for setting , new_value in new_settings . items ( ) : [EOL] setting = _setting_code_from_int ( setting ) [EOL] original_value = old_settings . get ( setting ) [EOL] change = ChangedSetting ( setting , original_value , new_value ) [EOL] e . changed_settings [ setting ] = change [EOL] [EOL] return e [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( [string] . join ( repr ( cs ) for cs in self . changed_settings . values ( ) ) , ) [EOL] [EOL] [EOL] class PingAcknowledged ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . ping_data = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( _bytes_representation ( self . ping_data ) , ) [EOL] [EOL] [EOL] class StreamEnded ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . stream_id = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % self . stream_id [EOL] [EOL] [EOL] class StreamReset ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . stream_id = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . error_code = None [EOL] [EOL] [comment] [EOL] self . remote_reset = True [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . stream_id , self . error_code , self . remote_reset ) [EOL] [EOL] [EOL] class PushedStreamReceived ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . pushed_stream_id = None [EOL] [EOL] [comment] [EOL] self . parent_stream_id = None [EOL] [EOL] [comment] [EOL] self . headers = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( [string] [string] % ( self . pushed_stream_id , self . parent_stream_id , self . headers , ) ) [EOL] [EOL] [EOL] class SettingsAcknowledged ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . changed_settings = { } [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( [string] . join ( repr ( cs ) for cs in self . changed_settings . values ( ) ) , ) [EOL] [EOL] [EOL] class PriorityUpdated ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . stream_id = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . weight = None [EOL] [EOL] [comment] [EOL] self . depends_on = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . exclusive = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( [string] [string] % ( self . stream_id , self . weight , self . depends_on , self . exclusive ) ) [EOL] [EOL] [EOL] class ConnectionTerminated ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . error_code = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . last_stream_id = None [EOL] [EOL] [comment] [EOL] self . additional_data = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( [string] [string] % ( self . error_code , self . last_stream_id , _bytes_representation ( self . additional_data [ : [number] ] [EOL] if self . additional_data else None ) ) ) [EOL] [EOL] [EOL] class AlternativeServiceAvailable ( Event ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . origin = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . field_value = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( [string] % ( self . origin . decode ( [string] , [string] ) , self . field_value . decode ( [string] , [string] ) , ) ) [EOL] [EOL] [EOL] def _bytes_representation ( data ) : [EOL] [docstring] [EOL] if data is None : [EOL] return None [EOL] [EOL] hex = binascii . hexlify ( data ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not isinstance ( hex , str ) : [comment] [EOL] hex = hex . decode ( [string] ) [EOL] [EOL] return hex [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.hyper.hyper.h2.events.RemoteSettingsChanged$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.hyper.hyper.h2.events.RemoteSettingsChanged$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.hyper.hyper.h2.events.RemoteSettingsChanged$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] __version__ = [string] [EOL]	0 0 0 0 $builtins.str$ 0 0 0
from . core import where , old_where [EOL] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from certifi import where [EOL] print ( where ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Optional , Match , List [EOL] import typing [EOL] import itertools [EOL] import os [EOL] import re [EOL] import sys [EOL] [EOL] try : [EOL] from setuptools import setup [EOL] except ImportError : [EOL] from distutils . core import setup [EOL] [EOL] [comment] [EOL] version_regex = [string] [EOL] with open ( [string] , [string] ) as f : [EOL] text = f . read ( ) [EOL] match = re . search ( version_regex , text ) [EOL] [EOL] if match : [EOL] version = match . group ( [number] ) [EOL] else : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [comment] [EOL] if sys . argv [ - [number] ] == [string] : [EOL] os . system ( [string] ) [EOL] sys . exit ( ) [EOL] [EOL] [EOL] packages = [ [string] ] [EOL] [EOL] setup ( name = [string] , version = version , description = [string] , long_description = open ( [string] ) . read ( ) + [string] + open ( [string] ) . read ( ) , author = [string] , author_email = [string] , url = [string] , packages = packages , package_data = { [string] : [ [string] , [string] , [string] , [string] ] } , package_dir = { [string] : [string] } , include_package_data = True , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] [EOL] class UnknownFrameError ( ValueError ) : [EOL] [docstring] [EOL] def __init__ ( self , frame_type , length ) : [EOL] [comment] [EOL] self . frame_type = frame_type [EOL] [EOL] [comment] [EOL] self . length = length [EOL] [EOL] def __str__ ( self ) : [EOL] return ( [string] [string] % ( self . frame_type , self . length ) ) [EOL] [EOL] [EOL] class InvalidPaddingError ( ValueError ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class InvalidFrameError ( ValueError ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] __version__ = [string] [EOL]	0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from __future__ import with_statement [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] from setuptools import setup [EOL] except ImportError : [EOL] from distutils . core import setup [EOL] [EOL] import six [EOL] [EOL] six_classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] with open ( [string] , [string] ) as fp : [EOL] six_long_description = fp . read ( ) [EOL] [EOL] setup ( name = [string] , version = six . __version__ , author = [string] , author_email = [string] , url = [string] , tests_require = [ [string] ] , py_modules = [ [string] ] , description = [string] , long_description = six_long_description , license = [string] , classifiers = six_classifiers , python_requires = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] class HeaderTuple ( tuple ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] indexable = True [EOL] [EOL] def __new__ ( _cls , * args ) : [EOL] return tuple . __new__ ( _cls , args ) [EOL] [EOL] [EOL] class NeverIndexedHeaderTuple ( HeaderTuple ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] indexable = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] [EOL] class HPACKError ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class HPACKDecodingError ( HPACKError ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class InvalidTableIndex ( HPACKDecodingError ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class OversizedHeaderListError ( HPACKDecodingError ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class InvalidTableSizeError ( HPACKDecodingError ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] REQUEST_CODES = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL] [EOL] REQUEST_CODES_LENGTH = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] import builtins [EOL] from typing import Type , Tuple , Any [EOL] import tests [EOL] import typing [EOL] import logging [EOL] from collections import deque [EOL] import logging [EOL] [EOL] from . exceptions import InvalidTableIndex [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def table_entry_size ( name , value ) : [EOL] [docstring] [EOL] return [number] + len ( name ) + len ( value ) [EOL] [EOL] [EOL] class HeaderTable ( object ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] DEFAULT_SIZE = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] STATIC_TABLE = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) [comment] [EOL] [EOL] STATIC_TABLE_LENGTH = len ( STATIC_TABLE ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . _maxsize = HeaderTable . DEFAULT_SIZE [EOL] self . _current_size = [number] [EOL] self . resized = False [EOL] self . dynamic_entries = deque ( ) [EOL] [EOL] def get_by_index ( self , index ) : [EOL] [docstring] [EOL] original_index = index [EOL] index -= [number] [EOL] if [number] <= index : [EOL] if index < HeaderTable . STATIC_TABLE_LENGTH : [EOL] return HeaderTable . STATIC_TABLE [ index ] [EOL] [EOL] index -= HeaderTable . STATIC_TABLE_LENGTH [EOL] if index < len ( self . dynamic_entries ) : [EOL] return self . dynamic_entries [ index ] [EOL] [EOL] raise InvalidTableIndex ( [string] % original_index ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . _maxsize , self . resized , self . dynamic_entries ) [EOL] [EOL] def add ( self , name , value ) : [EOL] [docstring] [EOL] [comment] [EOL] size = table_entry_size ( name , value ) [EOL] if size > self . _maxsize : [EOL] self . dynamic_entries . clear ( ) [EOL] self . _current_size = [number] [EOL] else : [EOL] [comment] [EOL] self . dynamic_entries . appendleft ( ( name , value ) ) [EOL] self . _current_size += size [EOL] self . _shrink ( ) [EOL] [EOL] def search ( self , name , value ) : [EOL] [docstring] [EOL] offset = HeaderTable . STATIC_TABLE_LENGTH + [number] [EOL] partial = None [EOL] for ( i , ( n , v ) ) in enumerate ( HeaderTable . STATIC_TABLE ) : [EOL] if n == name : [EOL] if v == value : [EOL] return i + [number] , n , v [EOL] elif partial is None : [EOL] partial = ( i + [number] , n , None ) [EOL] for ( i , ( n , v ) ) in enumerate ( self . dynamic_entries ) : [EOL] if n == name : [EOL] if v == value : [EOL] return i + offset , n , v [EOL] elif partial is None : [EOL] partial = ( i + offset , n , None ) [EOL] return partial [EOL] [EOL] @ property def maxsize ( self ) : [EOL] return self . _maxsize [EOL] [EOL] @ maxsize . setter def maxsize ( self , newmax ) : [EOL] newmax = int ( newmax ) [EOL] log . debug ( [string] , newmax , self . _maxsize ) [EOL] oldmax = self . _maxsize [EOL] self . _maxsize = newmax [EOL] self . resized = ( newmax != oldmax ) [EOL] if newmax <= [number] : [EOL] self . dynamic_entries . clear ( ) [EOL] self . _current_size = [number] [EOL] elif oldmax > newmax : [EOL] self . _shrink ( ) [EOL] [EOL] def _shrink ( self ) : [EOL] [docstring] [EOL] cursize = self . _current_size [EOL] while cursize > self . _maxsize : [EOL] name , value = self . dynamic_entries . pop ( ) [EOL] cursize -= table_entry_size ( name , value ) [EOL] log . debug ( [string] , name , value ) [EOL] self . _current_size = cursize [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,typing.Any,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,typing.Any,None]$ 0 0 0 0 $typing.Tuple[builtins.int,typing.Any,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Tuple[builtins.int,typing.Any,None]$ 0 0 0 0 $typing.Tuple[builtins.int,typing.Any,None]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,typing.Any,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] class ConnectionTerminatedException ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidFrameException ( ConnectionTerminatedException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class BadOperationException ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class UnsupportedFrameException ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidUTF8Exception ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Pattern , Any , List [EOL] import unittest [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] import logging [EOL] import argparse [EOL] import os [EOL] import re [EOL] import six [EOL] import sys [EOL] import unittest [EOL] [EOL] _TEST_MODULE_PATTERN = re . compile ( [string] ) [EOL] [EOL] [EOL] def _list_test_modules ( directory ) : [EOL] module_names = [ ] [EOL] for filename in os . listdir ( directory ) : [EOL] match = _TEST_MODULE_PATTERN . search ( filename ) [EOL] if match : [EOL] module_names . append ( match . group ( [number] ) ) [EOL] return module_names [EOL] [EOL] [EOL] def _suite ( ) : [EOL] loader = unittest . TestLoader ( ) [EOL] return loader . loadTestsFromNames ( _list_test_modules ( os . path . dirname ( __file__ ) ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , type = six . text_type , dest = [string] , default = [string] , choices = [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] options , args = parser . parse_known_args ( ) [EOL] logging . basicConfig ( level = logging . getLevelName ( options . log_level . upper ( ) ) , format = [string] [string] [string] , datefmt = [string] ) [EOL] unittest . main ( defaultTest = [string] , argv = [ sys . argv [ [number] ] ] + args ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] import os [EOL] import sys [EOL] [EOL] [comment] [EOL] sys . path . insert ( [number] , os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from mod_pywebsocket import handshake [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] raise handshake . AbortedByUserException ( [string] ) [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] raise handshake . AbortedByUserException ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] if request . ws_origin == [string] : [EOL] return [EOL] raise ValueError ( [string] % request . ws_origin ) [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] message = [string] % ( request . ws_resource , request . ws_protocol ) [EOL] request . connection . write ( message . encode ( [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] web_socket_do_extra_handshake = True [EOL] web_socket_transfer_data = [number] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] message = [string] % ( request . ws_resource , request . ws_protocol ) [EOL] request . connection . write ( message . encode ( [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [EOL] [EOL] [EOL] def no_web_socket_transfer_data ( request ) : [EOL] message = [string] % ( request . ws_resource , request . ws_protocol ) [EOL] request . connection . write ( message . encode ( [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] message = [string] % ( request . ws_resource , request . ws_protocol ) [EOL] request . connection . write ( message . encode ( [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [EOL] def no_web_socket_do_extra_handshake ( request ) : [EOL] pass [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] message = [string] % ( request . ws_resource , request . ws_protocol ) [EOL] request . connection . write ( message . encode ( [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] raise Exception ( [string] % ( request . ws_resource , request . ws_protocol ) ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import [EOL] from mod_pywebsocket import handshake [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] raise handshake . AbortedByUserException ( [string] ) [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] request . extra_headers . append ( ( [string] , [string] ) ) [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] request . ws_stream . send_message ( [string] , binary = False ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from __future__ import absolute_import [EOL] import six [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] [comment] [EOL] request . ws_extension_processors = [ ] [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] data = [string] [EOL] [EOL] while True : [EOL] command = request . ws_stream . receive_message ( ) [EOL] if command is None : [EOL] return [EOL] [EOL] if not isinstance ( command , six . text_type ) : [EOL] raise ValueError ( [string] + command ) [EOL] commands = command . split ( [string] ) [EOL] if len ( commands ) == [number] : [EOL] raise ValueError ( [string] + command ) [EOL] [EOL] if commands [ [number] ] == [string] : [EOL] if len ( commands ) != [number] : [EOL] raise ValueError ( [string] + command ) [EOL] size = int ( commands [ [number] ] ) [EOL] [EOL] [comment] [EOL] if len ( data ) != size : [EOL] data = [string] * size [EOL] request . ws_stream . send_message ( data , binary = True ) [EOL] elif commands [ [number] ] == [string] : [EOL] if len ( commands ) != [number] : [EOL] raise ValueError ( [string] + command ) [EOL] verify_data = commands [ [number] ] == [string] [EOL] [EOL] data = request . ws_stream . receive_message ( ) [EOL] if data is None : [EOL] raise ValueError ( [string] ) [EOL] size = len ( data ) [EOL] [EOL] if verify_data : [EOL] if data != [string] * size : [EOL] raise ValueError ( [string] ) [EOL] [EOL] request . ws_stream . send_message ( str ( size ) ) [EOL] else : [EOL] raise ValueError ( [string] + commands [ [number] ] ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] if request . ws_origin == [string] : [EOL] return [EOL] raise ValueError ( [string] % request . ws_origin ) [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] request . connection . write ( [string] % ( request . ws_resource , request . ws_protocol ) ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import [EOL] from mod_pywebsocket import msgutil [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] raise msgutil . BadOperationException ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import [EOL] from mod_pywebsocket import handshake [EOL] [EOL] [EOL] def web_socket_do_extra_handshake ( request ) : [EOL] pass [EOL] [EOL] [EOL] def web_socket_transfer_data ( request ) : [EOL] raise handshake . AbortedByUserException ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , List [EOL] import pstats [EOL] import io [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import sys [EOL] import traceback [EOL] [EOL] from html5lib import html5parser [EOL] from html5lib import treebuilders , serializer , treewalkers [EOL] from html5lib import constants [EOL] from html5lib import _utils [EOL] [EOL] [EOL] def parse ( ) : [EOL] parser = get_parser ( ) [EOL] opts = parser . parse_args ( ) [EOL] encoding = [string] [EOL] [EOL] try : [EOL] f = opts . filename [EOL] [comment] [EOL] if f . startswith ( [string] ) : [EOL] try : [EOL] import urllib . request [EOL] import urllib . parse [EOL] import urllib . error [EOL] import cgi [EOL] f = urllib . request . urlopen ( f ) [EOL] contentType = f . headers . get ( [string] ) [EOL] if contentType : [EOL] ( mediaType , params ) = cgi . parse_header ( contentType ) [EOL] encoding = params . get ( [string] ) [EOL] except Exception : [EOL] pass [EOL] elif f == [string] : [EOL] f = sys . stdin [EOL] if sys . version_info [ [number] ] >= [number] : [EOL] encoding = None [EOL] else : [EOL] try : [EOL] [comment] [EOL] f = open ( f , [string] ) [EOL] except IOError as e : [EOL] sys . stderr . write ( [string] % e ) [EOL] sys . exit ( [number] ) [EOL] except IndexError : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] treebuilder = treebuilders . getTreeBuilder ( opts . treebuilder ) [EOL] [EOL] p = html5parser . HTMLParser ( tree = treebuilder , debug = opts . log ) [EOL] [EOL] if opts . fragment : [EOL] parseMethod = p . parseFragment [EOL] else : [EOL] parseMethod = p . parse [EOL] [EOL] if opts . profile : [EOL] import cProfile [EOL] import pstats [EOL] cProfile . runctx ( [string] , None , { [string] : run , [string] : parseMethod , [string] : f , [string] : encoding , [string] : opts . scripting } , [string] ) [EOL] [comment] [EOL] stats = pstats . Stats ( [string] ) [EOL] stats . strip_dirs ( ) [EOL] stats . sort_stats ( [string] ) [EOL] stats . print_stats ( ) [EOL] elif opts . time : [EOL] import time [EOL] t0 = time . time ( ) [EOL] document = run ( parseMethod , f , encoding , opts . scripting ) [EOL] t1 = time . time ( ) [EOL] if document : [EOL] printOutput ( p , document , opts ) [EOL] t2 = time . time ( ) [EOL] sys . stderr . write ( [string] % ( t1 - t0 , t2 - t1 ) ) [EOL] else : [EOL] sys . stderr . write ( [string] % ( t1 - t0 ) ) [EOL] else : [EOL] document = run ( parseMethod , f , encoding , opts . scripting ) [EOL] if document : [EOL] printOutput ( p , document , opts ) [EOL] [EOL] [EOL] def run ( parseMethod , f , encoding , scripting ) : [EOL] try : [EOL] document = parseMethod ( f , override_encoding = encoding , scripting = scripting ) [EOL] except Exception : [EOL] document = None [EOL] traceback . print_exc ( ) [EOL] return document [EOL] [EOL] [EOL] def printOutput ( parser , document , opts ) : [EOL] if opts . encoding : [EOL] print ( [string] , parser . tokenizer . stream . charEncoding ) [EOL] [EOL] for item in parser . log : [EOL] print ( item ) [EOL] [EOL] if document is not None : [EOL] if opts . xml : [EOL] tb = opts . treebuilder . lower ( ) [EOL] if tb == [string] : [EOL] document . writexml ( sys . stdout , encoding = [string] ) [EOL] elif tb == [string] : [EOL] import lxml . etree [EOL] sys . stdout . write ( lxml . etree . tostring ( document , encoding = [string] ) ) [EOL] elif tb == [string] : [EOL] sys . stdout . write ( _utils . default_etree . tostring ( document , encoding = [string] ) ) [EOL] elif opts . tree : [EOL] if not hasattr ( document , [string] ) : [EOL] document = [ document ] [EOL] for fragment in document : [EOL] print ( parser . tree . testSerializer ( fragment ) ) [EOL] elif opts . html : [EOL] kwargs = { } [EOL] for opt in serializer . HTMLSerializer . options : [EOL] try : [EOL] kwargs [ opt ] = getattr ( opts , opt ) [EOL] except Exception : [EOL] pass [EOL] if not kwargs [ [string] ] : [EOL] del kwargs [ [string] ] [EOL] [EOL] if opts . sanitize : [EOL] kwargs [ [string] ] = True [EOL] [EOL] tokens = treewalkers . getTreeWalker ( opts . treebuilder ) ( document ) [EOL] if sys . version_info [ [number] ] >= [number] : [EOL] encoding = None [EOL] else : [EOL] encoding = [string] [EOL] for text in serializer . HTMLSerializer ( ** kwargs ) . serialize ( tokens , encoding = encoding ) : [EOL] sys . stdout . write ( text ) [EOL] if not text . endswith ( [string] ) : [EOL] sys . stdout . write ( [string] ) [EOL] if opts . error : [EOL] errList = [ ] [EOL] for pos , errorcode , datavars in parser . errors : [EOL] errList . append ( [string] % pos + [string] + constants . E . get ( errorcode , [string] % errorcode ) % datavars ) [EOL] sys . stdout . write ( [string] + [string] . join ( errList ) + [string] ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( description = __doc__ ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , default = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] ) [EOL] [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parse ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from __future__ import absolute_import , division , unicode_literals [EOL] [EOL] from . py import Trie [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , division , unicode_literals [EOL] [EOL] import pytest [EOL] [EOL] from html5lib import constants , parseFragment , serialize [EOL] from html5lib . filters import sanitizer [EOL] [EOL] [EOL] def sanitize_html ( stream ) : [EOL] parsed = parseFragment ( stream ) [EOL] with pytest . deprecated_call ( ) : [EOL] serialized = serialize ( parsed , sanitize = True , omit_optional_tags = False , use_trailing_solidus = True , space_before_trailing_solidus = False , quote_attr_values = [string] , quote_char = [string] , alphabetical_attributes = True ) [EOL] return serialized [EOL] [EOL] [EOL] def test_should_handle_astral_plane_characters ( ) : [EOL] sanitized = sanitize_html ( [string] ) [EOL] expected = [string] [EOL] assert expected == sanitized [EOL] [EOL] [EOL] def test_should_allow_relative_uris ( ) : [EOL] sanitized = sanitize_html ( [string] ) [EOL] expected = [string] [EOL] assert expected == sanitized [EOL] [EOL] [EOL] def test_invalid_data_uri ( ) : [EOL] sanitized = sanitize_html ( [string] ) [EOL] expected = [string] [EOL] assert expected == sanitized [EOL] [EOL] [EOL] def test_invalid_ipv6_url ( ) : [EOL] sanitized = sanitize_html ( [string] ) [EOL] expected = [string] [EOL] assert expected == sanitized [EOL] [EOL] [EOL] def test_data_uri_disallowed_type ( ) : [EOL] sanitized = sanitize_html ( [string] ) [EOL] expected = [string] [EOL] assert expected == sanitized [EOL] [EOL] [EOL] def param_sanitizer ( ) : [EOL] for ns , tag_name in sanitizer . allowed_elements : [EOL] if ns != constants . namespaces [ [string] ] : [EOL] continue [EOL] if tag_name in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] continue [comment] [EOL] if tag_name == [string] : [EOL] yield ( [string] % tag_name , [string] , [string] % ( tag_name , tag_name ) ) [EOL] elif tag_name == [string] : [EOL] yield ( [string] % tag_name , [string] , [string] % ( tag_name , tag_name ) ) [EOL] elif tag_name in constants . voidElements : [EOL] yield ( [string] % tag_name , [string] % tag_name , [string] % ( tag_name , tag_name ) ) [EOL] else : [EOL] yield ( [string] % tag_name , [string] % ( tag_name , tag_name ) , [string] % ( tag_name , tag_name ) ) [EOL] [EOL] for ns , attribute_name in sanitizer . allowed_attributes : [EOL] if ns is not None : [EOL] continue [EOL] if attribute_name != attribute_name . lower ( ) : [EOL] continue [comment] [EOL] if attribute_name == [string] : [EOL] continue [EOL] attribute_value = [string] [EOL] if attribute_name in sanitizer . attr_val_is_uri : [EOL] attribute_value = [string] % sanitizer . allowed_protocols [ [number] ] [EOL] yield ( [string] % attribute_name , [string] % ( attribute_name , attribute_value ) , [string] % ( attribute_name , attribute_value ) ) [EOL] [EOL] for protocol in sanitizer . allowed_protocols : [EOL] rest_of_uri = [string] [EOL] if protocol == [string] : [EOL] rest_of_uri = [string] [EOL] yield ( [string] % protocol , [string] % ( protocol , rest_of_uri ) , [string] % ( protocol , rest_of_uri ) ) [EOL] [EOL] for protocol in sanitizer . allowed_protocols : [EOL] rest_of_uri = [string] [EOL] if protocol == [string] : [EOL] rest_of_uri = [string] [EOL] protocol = protocol . upper ( ) [EOL] yield ( [string] % protocol , [string] % ( protocol , rest_of_uri ) , [string] % ( protocol , rest_of_uri ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( pytest . param ( expected , input , id = id ) for id , expected , input in param_sanitizer ( ) ) ) def test_sanitizer ( expected , input ) : [EOL] parsed = parseFragment ( expected ) [EOL] expected = serialize ( parsed , omit_optional_tags = False , use_trailing_solidus = True , space_before_trailing_solidus = False , quote_attr_values = [string] , quote_char = [string] , alphabetical_attributes = True ) [EOL] assert expected == sanitize_html ( input ) [EOL] [EOL] [EOL] def test_lowercase_color_codes_in_style ( ) : [EOL] sanitized = sanitize_html ( [string] ) [EOL] expected = [string] [EOL] assert expected == sanitized [EOL] [EOL] [EOL] def test_uppercase_color_codes_in_style ( ) : [EOL] sanitized = sanitize_html ( [string] ) [EOL] expected = [string] [EOL] assert expected == sanitized [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import absolute_import , division , unicode_literals [EOL]	0 0 0 0 0 0 0 0 0
from typing import Union , List , Dict , Tuple , Any , Optional [EOL] import typing [EOL] from __future__ import absolute_import , division , unicode_literals [EOL] [EOL] from collections import OrderedDict [EOL] [EOL] import pytest [EOL] [EOL] import html5lib [EOL] from html5lib . filters . alphabeticalattributes import Filter [EOL] from html5lib . serializer import HTMLSerializer [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , { } , { } ) , ( [string] , { ( None , [string] ) : [string] } , OrderedDict ( [ ( ( None , [string] ) , [string] ) ] ) ) , ( [string] , { ( None , [string] ) : [string] , ( None , [string] ) : [string] , ( None , [string] ) : [string] } , OrderedDict ( [ ( ( None , [string] ) , [string] ) , ( ( None , [string] ) , [string] ) , ( ( None , [string] ) , [string] ) ] ) ) , ] ) def test_alphabetizing ( msg , attrs , expected_attrs ) : [EOL] tokens = [ { [string] : [string] , [string] : [string] , [string] : attrs } ] [EOL] output_tokens = list ( Filter ( tokens ) ) [EOL] [EOL] attrs = output_tokens [ [number] ] [ [string] ] [EOL] assert attrs == expected_attrs [EOL] [EOL] [EOL] def test_with_different_namespaces ( ) : [EOL] tokens = [ { [string] : [string] , [string] : [string] , [string] : { ( None , [string] ) : [string] , ( [string] , [string] ) : [string] } } ] [EOL] output_tokens = list ( Filter ( tokens ) ) [EOL] [EOL] attrs = output_tokens [ [number] ] [ [string] ] [EOL] assert attrs == OrderedDict ( [ ( ( None , [string] ) , [string] ) , ( ( [string] , [string] ) , [string] ) ] ) [EOL] [EOL] [EOL] def test_with_serializer ( ) : [EOL] [docstring] [EOL] parser = html5lib . HTMLParser ( ) [EOL] dom = parser . parseFragment ( [string] ) [EOL] walker = html5lib . getTreeWalker ( [string] ) [EOL] ser = HTMLSerializer ( alphabetical_attributes = True , quote_attr_values = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert ( ser . render ( walker ( dom ) ) == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import absolute_import , division , unicode_literals [EOL] [EOL] from html5lib . filters . optionaltags import Filter [EOL] [EOL] [EOL] def test_empty ( ) : [EOL] assert list ( Filter ( [ ] ) ) == [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import typing [EOL] from __future__ import absolute_import , division , unicode_literals [EOL] [EOL] import codecs [EOL] import json [EOL] [EOL] import pytest [EOL] [EOL] from html5lib import parseFragment , serialize [EOL] [EOL] [EOL] class SanitizerFile ( pytest . File ) : [EOL] def collect ( self ) : [EOL] with codecs . open ( str ( self . fspath ) , [string] , encoding = [string] ) as fp : [EOL] tests = json . load ( fp ) [EOL] for i , test in enumerate ( tests ) : [EOL] yield SanitizerTest ( str ( i ) , self , test = test ) [EOL] [EOL] [EOL] class SanitizerTest ( pytest . Item ) : [EOL] def __init__ ( self , name , parent , test ) : [EOL] super ( SanitizerTest , self ) . __init__ ( name , parent ) [EOL] self . obj = lambda : [number] [comment] [EOL] self . test = test [EOL] [EOL] def runtest ( self ) : [EOL] input = self . test [ [string] ] [EOL] expected = self . test [ [string] ] [EOL] [EOL] parsed = parseFragment ( input ) [EOL] with pytest . deprecated_call ( ) : [EOL] serialized = serialize ( parsed , sanitize = True , omit_optional_tags = False , use_trailing_solidus = True , space_before_trailing_solidus = False , quote_attr_values = [string] , quote_char = [string] , alphabetical_attributes = True ) [EOL] errorMsg = [string] . join ( [ [string] , input , [string] , expected , [string] , serialized ] ) [EOL] assert expected == serialized , errorMsg [EOL] [EOL] def repr_failure ( self , excinfo ) : [EOL] traceback = excinfo . traceback [EOL] ntraceback = traceback . cut ( path = __file__ ) [EOL] excinfo . traceback = ntraceback . filter ( ) [EOL] [EOL] return excinfo . getrepr ( funcargs = True , showlocals = False , style = [string] , tbfilter = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , division , print_function [EOL] import sys [EOL] import py [EOL] import pytest [EOL] [EOL] from _pytest . tmpdir import tmpdir [EOL] [EOL] [EOL] def test_funcarg ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] from _pytest . tmpdir import TempdirFactory [EOL] [EOL] reprec = testdir . inline_run ( ) [EOL] calls = reprec . getcalls ( [string] ) [EOL] item = calls [ [number] ] . item [EOL] config = item . config [EOL] tmpdirhandler = TempdirFactory ( config ) [EOL] item . _initrequest ( ) [EOL] p = tmpdir ( item . _request , tmpdirhandler ) [EOL] assert p . check ( ) [EOL] bn = p . basename . strip ( [string] ) [EOL] assert bn . endswith ( [string] ) [EOL] item . name = [string] [EOL] p = tmpdir ( item . _request , tmpdirhandler ) [EOL] assert p . check ( ) [EOL] bn = p . basename . strip ( [string] ) [EOL] assert bn == [string] [EOL] [EOL] [EOL] def test_ensuretemp ( recwarn ) : [EOL] d1 = pytest . ensuretemp ( [string] ) [EOL] d2 = pytest . ensuretemp ( [string] ) [EOL] assert d1 == d2 [EOL] assert d1 . check ( dir = [number] ) [EOL] [EOL] [EOL] class TestTempdirHandler ( object ) : [EOL] [EOL] def test_mktemp ( self , testdir ) : [EOL] from _pytest . tmpdir import TempdirFactory [EOL] [EOL] config = testdir . parseconfig ( ) [EOL] config . option . basetemp = testdir . mkdir ( [string] ) [EOL] t = TempdirFactory ( config ) [EOL] tmp = t . mktemp ( [string] ) [EOL] assert tmp . relto ( t . getbasetemp ( ) ) == [string] [EOL] tmp = t . mktemp ( [string] ) [EOL] assert tmp . relto ( t . getbasetemp ( ) ) . startswith ( [string] ) [EOL] tmp2 = t . mktemp ( [string] ) [EOL] assert tmp2 . relto ( t . getbasetemp ( ) ) . startswith ( [string] ) [EOL] assert tmp2 != tmp [EOL] [EOL] [EOL] class TestConfigTmpdir ( object ) : [EOL] [EOL] def test_getbasetemp_custom_removes_old ( self , testdir ) : [EOL] mytemp = testdir . tmpdir . join ( [string] ) [EOL] p = testdir . makepyfile ( [string] ) [EOL] testdir . runpytest ( p , [string] % mytemp ) [EOL] mytemp . check ( ) [EOL] mytemp . ensure ( [string] ) [EOL] [EOL] testdir . runpytest ( p , [string] % mytemp ) [EOL] mytemp . check ( ) [EOL] assert not mytemp . join ( [string] ) . check ( ) [EOL] [EOL] [EOL] def test_basetemp ( testdir ) : [EOL] mytemp = testdir . tmpdir . mkdir ( [string] ) [EOL] p = testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( p , [string] % mytemp ) [EOL] assert result . ret == [number] [EOL] assert mytemp . join ( [string] ) . check ( ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not hasattr ( py . path . local , [string] ) , reason = [string] , ) def test_tmpdir_always_is_realpath ( testdir ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] realtemp = testdir . tmpdir . mkdir ( [string] ) [EOL] linktemp = testdir . tmpdir . join ( [string] ) [EOL] linktemp . mksymlinkto ( realtemp ) [EOL] p = testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( [string] , p , [string] % linktemp ) [EOL] assert not result . ret [EOL] [EOL] [EOL] def test_tmpdir_too_long_on_parametrization ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] [EOL] def test_tmpdir_factory ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] [EOL] def test_tmpdir_fallback_tox_env ( testdir , monkeypatch ) : [EOL] [docstring] [EOL] monkeypatch . delenv ( [string] , raising = False ) [EOL] monkeypatch . delenv ( [string] , raising = False ) [EOL] testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] [EOL] @ pytest . fixture def break_getuser ( monkeypatch ) : [EOL] monkeypatch . setattr ( [string] , lambda : - [number] ) [EOL] [comment] [EOL] for envvar in ( [string] , [string] , [string] , [string] ) : [EOL] monkeypatch . delenv ( envvar , raising = False ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) @ pytest . mark . skipif ( sys . platform . startswith ( [string] ) , reason = [string] ) def test_tmpdir_fallback_uid_not_found ( testdir ) : [EOL] [docstring] [EOL] [EOL] testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) @ pytest . mark . skipif ( sys . platform . startswith ( [string] ) , reason = [string] ) def test_get_user_uid_not_found ( ) : [EOL] [docstring] [EOL] from _pytest . tmpdir import get_user [EOL] [EOL] assert get_user ( ) is None [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not sys . platform . startswith ( [string] ) , reason = [string] ) def test_get_user ( monkeypatch ) : [EOL] [docstring] [EOL] from _pytest . tmpdir import get_user [EOL] [EOL] monkeypatch . delenv ( [string] , raising = False ) [EOL] monkeypatch . delenv ( [string] , raising = False ) [EOL] assert get_user ( ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any , List [EOL] import tests [EOL] import typing [EOL] from __future__ import absolute_import , division , print_function [EOL] import subprocess [EOL] import sys [EOL] import pytest [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def equal_with_bash ( prefix , ffc , fc , out = None ) : [EOL] res = ffc ( prefix ) [EOL] res_bash = set ( fc ( prefix ) ) [EOL] retval = set ( res ) == res_bash [EOL] if out : [EOL] out . write ( [string] % ( retval , res ) ) [EOL] if not retval : [EOL] out . write ( [string] % ( set ( res ) - res_bash ) ) [EOL] out . write ( [string] % ( res_bash - set ( res ) ) ) [EOL] return retval [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def _wrapcall ( * args , ** kargs ) : [EOL] try : [EOL] if sys . version_info > ( [number] , [number] ) : [EOL] return subprocess . check_output ( * args , ** kargs ) . decode ( ) . splitlines ( ) [EOL] if [string] in kargs : [EOL] raise ValueError ( [string] ) [EOL] process = subprocess . Popen ( stdout = subprocess . PIPE , * args , ** kargs ) [EOL] output , unused_err = process . communicate ( ) [EOL] retcode = process . poll ( ) [EOL] if retcode : [EOL] cmd = kargs . get ( [string] ) [EOL] if cmd is None : [EOL] cmd = args [ [number] ] [EOL] raise subprocess . CalledProcessError ( retcode , cmd ) [EOL] return output . decode ( ) . splitlines ( ) [EOL] except subprocess . CalledProcessError : [EOL] return [ ] [EOL] [EOL] [EOL] class FilesCompleter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , allowednames = ( ) , directories = True ) : [EOL] [comment] [EOL] if type ( allowednames ) is str : [EOL] allowednames = [ allowednames ] [EOL] [EOL] self . allowednames = [ x . lstrip ( [string] ) . lstrip ( [string] ) for x in allowednames ] [EOL] self . directories = directories [EOL] [EOL] def __call__ ( self , prefix , ** kwargs ) : [EOL] completion = [ ] [EOL] if self . allowednames : [EOL] if self . directories : [EOL] files = _wrapcall ( [ [string] , [string] , [string] . format ( p = prefix ) ] ) [EOL] completion += [ f + [string] for f in files ] [EOL] for x in self . allowednames : [EOL] completion += _wrapcall ( [ [string] , [string] , [string] . format ( x , p = prefix ) , ] ) [EOL] else : [EOL] completion += _wrapcall ( [ [string] , [string] , [string] . format ( p = prefix ) ] ) [EOL] [EOL] anticomp = _wrapcall ( [ [string] , [string] , [string] . format ( p = prefix ) ] ) [EOL] [EOL] completion = list ( set ( completion ) - set ( anticomp ) ) [EOL] [EOL] if self . directories : [EOL] completion += [ f + [string] for f in anticomp ] [EOL] return completion [EOL] [EOL] [EOL] class TestArgComplete ( object ) : [EOL] [EOL] @ pytest . mark . skipif ( [string] ) def test_compare_with_compgen ( self ) : [EOL] from _pytest . _argcomplete import FastFilesCompleter [EOL] [EOL] ffc = FastFilesCompleter ( ) [EOL] fc = FilesCompleter ( ) [EOL] for x in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] assert equal_with_bash ( x , ffc , fc , out = sys . stdout ) [EOL] [EOL] @ pytest . mark . skipif ( [string] ) def test_remove_dir_prefix ( self ) : [EOL] [docstring] [EOL] from _pytest . _argcomplete import FastFilesCompleter [EOL] [EOL] ffc = FastFilesCompleter ( ) [EOL] fc = FilesCompleter ( ) [EOL] for x in [string] . split ( ) : [EOL] assert not equal_with_bash ( x , ffc , fc , out = sys . stdout ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.testing.test_argcomplete.FilesCompleter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.testing.test_argcomplete.FilesCompleter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.testing.test_argcomplete.FilesCompleter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.testing.test_argcomplete.FilesCompleter$ 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] from __future__ import absolute_import , division , print_function [EOL] import os [EOL] import sys [EOL] import textwrap [EOL] [EOL] import pytest [EOL] from _pytest . monkeypatch import MonkeyPatch [EOL] [EOL] [EOL] @ pytest . fixture def mp ( ) : [EOL] cwd = os . getcwd ( ) [EOL] sys_path = list ( sys . path ) [EOL] yield MonkeyPatch ( ) [EOL] sys . path [ : ] = sys_path [EOL] os . chdir ( cwd ) [EOL] [EOL] [EOL] def test_setattr ( ) : [EOL] [EOL] class A ( object ) : [EOL] x = [number] [EOL] [EOL] monkeypatch = MonkeyPatch ( ) [EOL] pytest . raises ( AttributeError , [string] ) [EOL] monkeypatch . setattr ( A , [string] , [number] , raising = False ) [EOL] assert A . y == [number] [EOL] monkeypatch . undo ( ) [EOL] assert not hasattr ( A , [string] ) [EOL] [EOL] monkeypatch = MonkeyPatch ( ) [EOL] monkeypatch . setattr ( A , [string] , [number] ) [EOL] assert A . x == [number] [EOL] monkeypatch . setattr ( A , [string] , [number] ) [EOL] assert A . x == [number] [EOL] monkeypatch . undo ( ) [EOL] assert A . x == [number] [EOL] [EOL] A . x = [number] [EOL] monkeypatch . undo ( ) [comment] [EOL] assert A . x == [number] [EOL] [EOL] [EOL] class TestSetattrWithImportPath ( object ) : [EOL] [EOL] def test_string_expression ( self , monkeypatch ) : [EOL] monkeypatch . setattr ( [string] , lambda x : [string] ) [EOL] assert os . path . abspath ( [string] ) == [string] [EOL] [EOL] def test_string_expression_class ( self , monkeypatch ) : [EOL] monkeypatch . setattr ( [string] , [number] ) [EOL] import _pytest [EOL] [EOL] assert _pytest . config . Config == [number] [EOL] [EOL] def test_unicode_string ( self , monkeypatch ) : [EOL] monkeypatch . setattr ( [string] , [number] ) [EOL] import _pytest [EOL] [EOL] assert _pytest . config . Config == [number] [EOL] monkeypatch . delattr ( [string] ) [EOL] [EOL] def test_wrong_target ( self , monkeypatch ) : [EOL] pytest . raises ( TypeError , lambda : monkeypatch . setattr ( None , None ) ) [EOL] [EOL] def test_unknown_import ( self , monkeypatch ) : [EOL] pytest . raises ( ImportError , lambda : monkeypatch . setattr ( [string] , None ) ) [EOL] [EOL] def test_unknown_attr ( self , monkeypatch ) : [EOL] pytest . raises ( AttributeError , lambda : monkeypatch . setattr ( [string] , None ) ) [EOL] [EOL] def test_unknown_attr_non_raising ( self , monkeypatch ) : [EOL] [comment] [EOL] monkeypatch . setattr ( [string] , [number] , raising = False ) [EOL] assert os . path . qweqwe == [number] [EOL] [EOL] def test_delattr ( self , monkeypatch ) : [EOL] monkeypatch . delattr ( [string] ) [EOL] assert not hasattr ( os . path , [string] ) [EOL] monkeypatch . undo ( ) [EOL] assert os . path . abspath [EOL] [EOL] [EOL] def test_delattr ( ) : [EOL] [EOL] class A ( object ) : [EOL] x = [number] [EOL] [EOL] monkeypatch = MonkeyPatch ( ) [EOL] monkeypatch . delattr ( A , [string] ) [EOL] assert not hasattr ( A , [string] ) [EOL] monkeypatch . undo ( ) [EOL] assert A . x == [number] [EOL] [EOL] monkeypatch = MonkeyPatch ( ) [EOL] monkeypatch . delattr ( A , [string] ) [EOL] pytest . raises ( AttributeError , [string] ) [EOL] monkeypatch . delattr ( A , [string] , raising = False ) [EOL] monkeypatch . setattr ( A , [string] , [number] , raising = False ) [EOL] assert A . x == [number] [EOL] monkeypatch . undo ( ) [EOL] assert A . x == [number] [EOL] [EOL] [EOL] def test_setitem ( ) : [EOL] d = { [string] : [number] } [EOL] monkeypatch = MonkeyPatch ( ) [EOL] monkeypatch . setitem ( d , [string] , [number] ) [EOL] monkeypatch . setitem ( d , [string] , [number] ) [EOL] monkeypatch . setitem ( d , [string] , [number] ) [EOL] assert d [ [string] ] == [number] [EOL] assert d [ [string] ] == [number] [EOL] monkeypatch . setitem ( d , [string] , [number] ) [EOL] assert d [ [string] ] == [number] [EOL] monkeypatch . undo ( ) [EOL] assert d [ [string] ] == [number] [EOL] assert [string] not in d [EOL] d [ [string] ] = [number] [EOL] monkeypatch . undo ( ) [EOL] assert d [ [string] ] == [number] [EOL] [EOL] [EOL] def test_setitem_deleted_meanwhile ( ) : [EOL] d = { } [EOL] monkeypatch = MonkeyPatch ( ) [EOL] monkeypatch . setitem ( d , [string] , [number] ) [EOL] del d [ [string] ] [EOL] monkeypatch . undo ( ) [EOL] assert not d [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_setenv_deleted_meanwhile ( before ) : [EOL] key = [string] [EOL] if before : [EOL] os . environ [ key ] = [string] [EOL] monkeypatch = MonkeyPatch ( ) [EOL] monkeypatch . setenv ( key , [string] ) [EOL] del os . environ [ key ] [EOL] monkeypatch . undo ( ) [EOL] if before : [EOL] assert os . environ [ key ] == [string] [EOL] del os . environ [ key ] [EOL] else : [EOL] assert key not in os . environ [EOL] [EOL] [EOL] def test_delitem ( ) : [EOL] d = { [string] : [number] } [EOL] monkeypatch = MonkeyPatch ( ) [EOL] monkeypatch . delitem ( d , [string] ) [EOL] assert [string] not in d [EOL] monkeypatch . delitem ( d , [string] , raising = False ) [EOL] pytest . raises ( KeyError , [string] ) [EOL] assert not d [EOL] monkeypatch . setitem ( d , [string] , [number] ) [EOL] assert d [ [string] ] == [number] [EOL] d [ [string] ] = [string] [EOL] monkeypatch . setitem ( d , [string] , [number] ) [EOL] assert d [ [string] ] == [number] [EOL] monkeypatch . undo ( ) [EOL] assert d == { [string] : [string] , [string] : [number] } [EOL] [EOL] [EOL] def test_setenv ( ) : [EOL] monkeypatch = MonkeyPatch ( ) [EOL] monkeypatch . setenv ( [string] , [number] ) [EOL] import os [EOL] [EOL] assert os . environ [ [string] ] == [string] [EOL] monkeypatch . undo ( ) [EOL] assert [string] not in os . environ [EOL] [EOL] [EOL] def test_delenv ( ) : [EOL] name = [string] [EOL] assert name not in os . environ [EOL] monkeypatch = MonkeyPatch ( ) [EOL] pytest . raises ( KeyError , [string] % name ) [EOL] monkeypatch . delenv ( name , raising = False ) [EOL] monkeypatch . undo ( ) [EOL] os . environ [ name ] = [string] [EOL] try : [EOL] monkeypatch = MonkeyPatch ( ) [EOL] monkeypatch . delenv ( name ) [EOL] assert name not in os . environ [EOL] monkeypatch . setenv ( name , [string] ) [EOL] assert os . environ [ name ] == [string] [EOL] monkeypatch . undo ( ) [EOL] assert os . environ [ name ] == [string] [EOL] finally : [EOL] if name in os . environ : [EOL] del os . environ [ name ] [EOL] [EOL] [EOL] def test_setenv_prepend ( ) : [EOL] import os [EOL] [EOL] monkeypatch = MonkeyPatch ( ) [EOL] monkeypatch . setenv ( [string] , [number] , prepend = [string] ) [EOL] assert os . environ [ [string] ] == [string] [EOL] monkeypatch . setenv ( [string] , [number] , prepend = [string] ) [EOL] assert os . environ [ [string] ] == [string] [EOL] monkeypatch . undo ( ) [EOL] assert [string] not in os . environ [EOL] [EOL] [EOL] def test_monkeypatch_plugin ( testdir ) : [EOL] reprec = testdir . inline_runsource ( [string] ) [EOL] res = reprec . countoutcomes ( ) [EOL] assert tuple ( res ) == ( [number] , [number] , [number] ) , res [EOL] [EOL] [EOL] def test_syspath_prepend ( mp ) : [EOL] old = list ( sys . path ) [EOL] mp . syspath_prepend ( [string] ) [EOL] mp . syspath_prepend ( [string] ) [EOL] assert sys . path [ [number] ] == [string] [EOL] assert sys . path [ [number] ] == [string] [EOL] mp . undo ( ) [EOL] assert sys . path == old [EOL] mp . undo ( ) [EOL] assert sys . path == old [EOL] [EOL] [EOL] def test_syspath_prepend_double_undo ( mp ) : [EOL] mp . syspath_prepend ( [string] ) [EOL] mp . undo ( ) [EOL] sys . path . append ( [string] ) [EOL] mp . undo ( ) [EOL] assert sys . path [ - [number] ] == [string] [EOL] [EOL] [EOL] def test_chdir_with_path_local ( mp , tmpdir ) : [EOL] mp . chdir ( tmpdir ) [EOL] assert os . getcwd ( ) == tmpdir . strpath [EOL] [EOL] [EOL] def test_chdir_with_str ( mp , tmpdir ) : [EOL] mp . chdir ( tmpdir . strpath ) [EOL] assert os . getcwd ( ) == tmpdir . strpath [EOL] [EOL] [EOL] def test_chdir_undo ( mp , tmpdir ) : [EOL] cwd = os . getcwd ( ) [EOL] mp . chdir ( tmpdir ) [EOL] mp . undo ( ) [EOL] assert os . getcwd ( ) == cwd [EOL] [EOL] [EOL] def test_chdir_double_undo ( mp , tmpdir ) : [EOL] mp . chdir ( tmpdir . strpath ) [EOL] mp . undo ( ) [EOL] tmpdir . chdir ( ) [EOL] mp . undo ( ) [EOL] assert os . getcwd ( ) == tmpdir . strpath [EOL] [EOL] [EOL] def test_issue185_time_breaks ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [string] ) [EOL] [EOL] [EOL] def test_importerror ( testdir ) : [EOL] p = testdir . mkpydir ( [string] ) [EOL] p . join ( [string] ) . write ( textwrap . dedent ( [string] ) ) [EOL] testdir . tmpdir . join ( [string] ) . write ( textwrap . dedent ( [string] ) ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [string] . format ( [string] if sys . version_info > ( [number] , [number] ) else [string] ) ) [EOL] [EOL] [EOL] class SampleNew ( object ) : [EOL] [EOL] @ staticmethod def hello ( ) : [EOL] return True [EOL] [EOL] [EOL] class SampleNewInherit ( SampleNew ) : [EOL] pass [EOL] [EOL] [EOL] class SampleOld ( object ) : [EOL] [comment] [EOL] @ staticmethod def hello ( ) : [EOL] return True [EOL] [EOL] [EOL] class SampleOldInherit ( SampleOld ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ SampleNew , SampleNewInherit , SampleOld , SampleOldInherit ] , ids = [ [string] , [string] , [string] , [string] ] , ) def test_issue156_undo_staticmethod ( Sample ) : [EOL] monkeypatch = MonkeyPatch ( ) [EOL] [EOL] monkeypatch . setattr ( Sample , [string] , None ) [EOL] assert Sample . hello is None [EOL] [EOL] monkeypatch . undo ( ) [EOL] assert Sample . hello ( ) [EOL] [EOL] [EOL] def test_issue1338_name_resolving ( ) : [EOL] pytest . importorskip ( [string] ) [EOL] monkeypatch = MonkeyPatch ( ) [EOL] try : [EOL] monkeypatch . delattr ( [string] ) [EOL] finally : [EOL] monkeypatch . undo ( ) [EOL] [EOL] [EOL] def test_context ( ) : [EOL] monkeypatch = MonkeyPatch ( ) [EOL] [EOL] import functools [EOL] import inspect [EOL] [EOL] with monkeypatch . context ( ) as m : [EOL] m . setattr ( functools , [string] , [number] ) [EOL] assert not inspect . isclass ( functools . partial ) [EOL] assert inspect . isclass ( functools . partial ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , division , print_function [EOL] from _pytest . main import EXIT_NOTESTSCOLLECTED [EOL] import pytest [EOL] [EOL] [EOL] def test_version ( testdir , pytestconfig ) : [EOL] result = testdir . runpytest ( [string] ) [EOL] assert result . ret == [number] [EOL] [comment] [EOL] result . stderr . fnmatch_lines ( [ [string] % ( pytest . __version__ , ) ] ) [EOL] if pytestconfig . pluginmanager . list_plugin_distinfo ( ) : [EOL] result . stderr . fnmatch_lines ( [ [string] , [string] ] ) [EOL] [EOL] [EOL] def test_help ( testdir ) : [EOL] result = testdir . runpytest ( [string] ) [EOL] assert result . ret == [number] [EOL] result . stdout . fnmatch_lines ( [string] ) [EOL] [EOL] [EOL] def test_hookvalidation_unknown ( testdir ) : [EOL] testdir . makeconftest ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert result . ret != [number] [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] [EOL] def test_hookvalidation_optional ( testdir ) : [EOL] testdir . makeconftest ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert result . ret == EXIT_NOTESTSCOLLECTED [EOL] [EOL] [EOL] def test_traceconfig ( testdir ) : [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] [EOL] [EOL] def test_debug ( testdir , monkeypatch ) : [EOL] result = testdir . runpytest_subprocess ( [string] ) [EOL] assert result . ret == EXIT_NOTESTSCOLLECTED [EOL] p = testdir . tmpdir . join ( [string] ) [EOL] assert [string] in p . read ( ) [EOL] [EOL] [EOL] def test_PYTEST_DEBUG ( testdir , monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] result = testdir . runpytest_subprocess ( ) [EOL] assert result . ret == EXIT_NOTESTSCOLLECTED [EOL] result . stderr . fnmatch_lines ( [ [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Set , Literal , List , Tuple , Any [EOL] import typing_extensions [EOL] import typing [EOL] from __future__ import absolute_import , division , print_function [EOL] import sys [EOL] import _pytest . _code [EOL] from _pytest . compat import MODULE_NOT_FOUND_ERROR [EOL] from _pytest . doctest import DoctestItem , DoctestModule , DoctestTextfile [EOL] import pytest [EOL] [EOL] [EOL] class TestDoctests ( object ) : [EOL] [EOL] def test_collect_testtextfile ( self , testdir ) : [EOL] w = testdir . maketxtfile ( whatever = [string] ) [EOL] checkfile = testdir . maketxtfile ( test_something = [string] ) [EOL] [EOL] for x in ( testdir . tmpdir , checkfile ) : [EOL] [comment] [EOL] items , reprec = testdir . inline_genitems ( x ) [EOL] assert len ( items ) == [number] [EOL] assert isinstance ( items [ [number] ] , DoctestItem ) [EOL] assert isinstance ( items [ [number] ] . parent , DoctestTextfile ) [EOL] [comment] [EOL] items , reprec = testdir . inline_genitems ( w ) [EOL] assert len ( items ) == [number] [EOL] [EOL] def test_collect_module_empty ( self , testdir ) : [EOL] path = testdir . makepyfile ( whatever = [string] ) [EOL] for p in ( path , testdir . tmpdir ) : [EOL] items , reprec = testdir . inline_genitems ( p , [string] ) [EOL] assert len ( items ) == [number] [EOL] [EOL] def test_collect_module_single_modulelevel_doctest ( self , testdir ) : [EOL] path = testdir . makepyfile ( whatever = [string] ) [EOL] for p in ( path , testdir . tmpdir ) : [EOL] items , reprec = testdir . inline_genitems ( p , [string] ) [EOL] assert len ( items ) == [number] [EOL] assert isinstance ( items [ [number] ] , DoctestItem ) [EOL] assert isinstance ( items [ [number] ] . parent , DoctestModule ) [EOL] [EOL] def test_collect_module_two_doctest_one_modulelevel ( self , testdir ) : [EOL] path = testdir . makepyfile ( whatever = [string] ) [EOL] for p in ( path , testdir . tmpdir ) : [EOL] items , reprec = testdir . inline_genitems ( p , [string] ) [EOL] assert len ( items ) == [number] [EOL] assert isinstance ( items [ [number] ] , DoctestItem ) [EOL] assert isinstance ( items [ [number] ] , DoctestItem ) [EOL] assert isinstance ( items [ [number] ] . parent , DoctestModule ) [EOL] assert items [ [number] ] . parent is items [ [number] ] . parent [EOL] [EOL] def test_collect_module_two_doctest_no_modulelevel ( self , testdir ) : [EOL] path = testdir . makepyfile ( whatever = [string] ) [EOL] for p in ( path , testdir . tmpdir ) : [EOL] items , reprec = testdir . inline_genitems ( p , [string] ) [EOL] assert len ( items ) == [number] [EOL] assert isinstance ( items [ [number] ] , DoctestItem ) [EOL] assert isinstance ( items [ [number] ] , DoctestItem ) [EOL] assert isinstance ( items [ [number] ] . parent , DoctestModule ) [EOL] assert items [ [number] ] . parent is items [ [number] ] . parent [EOL] [EOL] def test_simple_doctestfile ( self , testdir ) : [EOL] p = testdir . maketxtfile ( test_doc = [string] ) [EOL] reprec = testdir . inline_run ( p ) [EOL] reprec . assertoutcome ( failed = [number] ) [EOL] [EOL] def test_new_pattern ( self , testdir ) : [EOL] p = testdir . maketxtfile ( xdoc = [string] ) [EOL] reprec = testdir . inline_run ( p , [string] ) [EOL] reprec . assertoutcome ( failed = [number] ) [EOL] [EOL] def test_multiple_patterns ( self , testdir ) : [EOL] [docstring] [EOL] testdir . maketxtfile ( xdoc = [string] ) [EOL] testdir . makefile ( [string] , test = [string] , ) [EOL] testdir . maketxtfile ( test_normal = [string] ) [EOL] expected = { [string] , [string] , [string] } [EOL] assert { x . basename for x in testdir . tmpdir . listdir ( ) } == expected [EOL] args = [ [string] , [string] ] [EOL] result = testdir . runpytest ( * args ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] ] ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , ) def test_encoding ( self , testdir , test_string , encoding ) : [EOL] [docstring] [EOL] testdir . makeini ( [string] . format ( encoding ) ) [EOL] doctest = [string] . format ( test_string , repr ( test_string ) ) [EOL] testdir . _makefile ( [string] , [ doctest ] , { } , encoding = encoding ) [EOL] [EOL] result = testdir . runpytest ( ) [EOL] [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_doctest_unexpected_exception ( self , testdir ) : [EOL] testdir . maketxtfile ( [string] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_docstring_partial_context_around_error ( self , testdir ) : [EOL] [docstring] [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [comment] [EOL] assert [string] not in result . stdout . str ( ) [EOL] assert [string] not in result . stdout . str ( ) [EOL] [EOL] def test_docstring_full_context_around_error ( self , testdir ) : [EOL] [docstring] [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_doctest_linedata_missing ( self , testdir ) : [EOL] testdir . tmpdir . join ( [string] ) . write ( _pytest . _code . Source ( [string] ) ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_doctest_unex_importerror_only_txt ( self , testdir ) : [EOL] testdir . maketxtfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] [comment] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] . format ( e = MODULE_NOT_FOUND_ERROR ) , [string] . format ( e = MODULE_NOT_FOUND_ERROR ) , ] ) [EOL] [EOL] def test_doctest_unex_importerror_with_module ( self , testdir ) : [EOL] testdir . tmpdir . join ( [string] ) . write ( _pytest . _code . Source ( [string] ) ) [EOL] testdir . maketxtfile ( [string] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] [comment] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] . format ( e = MODULE_NOT_FOUND_ERROR ) , [string] , ] ) [EOL] [EOL] def test_doctestmodule ( self , testdir ) : [EOL] p = testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( p , [string] ) [EOL] reprec . assertoutcome ( failed = [number] ) [EOL] [EOL] def test_doctestmodule_external_and_issue116 ( self , testdir ) : [EOL] p = testdir . mkpydir ( [string] ) [EOL] p . join ( [string] ) . write ( _pytest . _code . Source ( [string] ) ) [EOL] result = testdir . runpytest ( p , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_txtfile_failing ( self , testdir ) : [EOL] p = testdir . maketxtfile ( [string] ) [EOL] result = testdir . runpytest ( p , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_txtfile_with_fixtures ( self , testdir ) : [EOL] p = testdir . maketxtfile ( [string] ) [EOL] reprec = testdir . inline_run ( p ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] def test_txtfile_with_usefixtures_in_ini ( self , testdir ) : [EOL] testdir . makeini ( [string] ) [EOL] testdir . makeconftest ( [string] ) [EOL] [EOL] p = testdir . maketxtfile ( [string] ) [EOL] reprec = testdir . inline_run ( p ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] def test_doctestmodule_with_fixtures ( self , testdir ) : [EOL] p = testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( p , [string] ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] def test_doctestmodule_three_tests ( self , testdir ) : [EOL] p = testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( p , [string] ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] def test_doctestmodule_two_tests_one_fail ( self , testdir ) : [EOL] p = testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( p , [string] ) [EOL] reprec . assertoutcome ( failed = [number] , passed = [number] ) [EOL] [EOL] def test_ignored_whitespace ( self , testdir ) : [EOL] testdir . makeini ( [string] ) [EOL] p = testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( p , [string] ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] def test_non_ignored_whitespace ( self , testdir ) : [EOL] testdir . makeini ( [string] ) [EOL] p = testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( p , [string] ) [EOL] reprec . assertoutcome ( failed = [number] , passed = [number] ) [EOL] [EOL] def test_ignored_whitespace_glob ( self , testdir ) : [EOL] testdir . makeini ( [string] ) [EOL] p = testdir . maketxtfile ( xdoc = [string] ) [EOL] reprec = testdir . inline_run ( p , [string] ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] def test_non_ignored_whitespace_glob ( self , testdir ) : [EOL] testdir . makeini ( [string] ) [EOL] p = testdir . maketxtfile ( xdoc = [string] ) [EOL] reprec = testdir . inline_run ( p , [string] ) [EOL] reprec . assertoutcome ( failed = [number] , passed = [number] ) [EOL] [EOL] def test_contains_unicode ( self , testdir ) : [EOL] [docstring] [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] [EOL] def test_ignore_import_errors_on_doctest ( self , testdir ) : [EOL] p = testdir . makepyfile ( [string] ) [EOL] [EOL] reprec = testdir . inline_run ( p , [string] , [string] ) [EOL] reprec . assertoutcome ( skipped = [number] , failed = [number] , passed = [number] ) [EOL] [EOL] def test_junit_report_for_doctest ( self , testdir ) : [EOL] [docstring] [EOL] p = testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( p , [string] , [string] ) [EOL] reprec . assertoutcome ( failed = [number] ) [EOL] [EOL] def test_unicode_doctest ( self , testdir ) : [EOL] [docstring] [EOL] p = testdir . maketxtfile ( test_unicode_doctest = [string] ) [EOL] result = testdir . runpytest ( p ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] [EOL] def test_unicode_doctest_module ( self , testdir ) : [EOL] [docstring] [EOL] p = testdir . makepyfile ( test_unicode_doctest_module = [string] ) [EOL] result = testdir . runpytest ( p , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_print_unicode_value ( self , testdir ) : [EOL] [docstring] [EOL] p = testdir . maketxtfile ( test_print_unicode_value = [string] ) [EOL] result = testdir . runpytest ( p ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_reportinfo ( self , testdir ) : [EOL] [docstring] [EOL] p = testdir . makepyfile ( test_reportinfo = [string] ) [EOL] items , reprec = testdir . inline_genitems ( p , [string] ) [EOL] reportinfo = items [ [number] ] . reportinfo ( ) [EOL] assert reportinfo [ [number] ] == [number] [EOL] [EOL] def test_valid_setup_py ( self , testdir ) : [EOL] [docstring] [EOL] p = testdir . makepyfile ( setup = [string] ) [EOL] result = testdir . runpytest ( p , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_invalid_setup_py ( self , testdir ) : [EOL] [docstring] [EOL] p = testdir . makepyfile ( setup = [string] ) [EOL] result = testdir . runpytest ( p , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] [EOL] class TestLiterals ( object ) : [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_allow_unicode ( self , testdir , config_mode ) : [EOL] [docstring] [EOL] if config_mode == [string] : [EOL] testdir . makeini ( [string] ) [EOL] comment = [string] [EOL] else : [EOL] comment = [string] [EOL] [EOL] testdir . maketxtfile ( test_doc = [string] . format ( comment = comment ) ) [EOL] testdir . makepyfile ( foo = [string] . format ( comment = comment ) ) [EOL] reprec = testdir . inline_run ( [string] ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_allow_bytes ( self , testdir , config_mode ) : [EOL] [docstring] [EOL] if config_mode == [string] : [EOL] testdir . makeini ( [string] ) [EOL] comment = [string] [EOL] else : [EOL] comment = [string] [EOL] [EOL] testdir . maketxtfile ( test_doc = [string] . format ( comment = comment ) ) [EOL] testdir . makepyfile ( foo = [string] . format ( comment = comment ) ) [EOL] reprec = testdir . inline_run ( [string] ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] def test_unicode_string ( self , testdir ) : [EOL] [docstring] [EOL] testdir . maketxtfile ( test_doc = [string] ) [EOL] reprec = testdir . inline_run ( ) [EOL] passed = int ( sys . version_info [ [number] ] >= [number] ) [EOL] reprec . assertoutcome ( passed = passed , failed = int ( not passed ) ) [EOL] [EOL] def test_bytes_literal ( self , testdir ) : [EOL] [docstring] [EOL] testdir . maketxtfile ( test_doc = [string] ) [EOL] reprec = testdir . inline_run ( ) [EOL] passed = int ( sys . version_info [ [number] ] == [number] ) [EOL] reprec . assertoutcome ( passed = passed , failed = int ( not passed ) ) [EOL] [EOL] [EOL] class TestDoctestSkips ( object ) : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture ( params = [ [string] , [string] ] ) def makedoctest ( self , testdir , request ) : [EOL] [EOL] def makeit ( doctest ) : [EOL] mode = request . param [EOL] if mode == [string] : [EOL] testdir . maketxtfile ( doctest ) [EOL] else : [EOL] assert mode == [string] [EOL] testdir . makepyfile ( [string] % doctest ) [EOL] [EOL] return makeit [EOL] [EOL] def test_one_skipped ( self , testdir , makedoctest ) : [EOL] makedoctest ( [string] ) [EOL] reprec = testdir . inline_run ( [string] ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] def test_one_skipped_failed ( self , testdir , makedoctest ) : [EOL] makedoctest ( [string] ) [EOL] reprec = testdir . inline_run ( [string] ) [EOL] reprec . assertoutcome ( failed = [number] ) [EOL] [EOL] def test_all_skipped ( self , testdir , makedoctest ) : [EOL] makedoctest ( [string] ) [EOL] reprec = testdir . inline_run ( [string] ) [EOL] reprec . assertoutcome ( skipped = [number] ) [EOL] [EOL] def test_vacuous_all_skipped ( self , testdir , makedoctest ) : [EOL] makedoctest ( [string] ) [EOL] reprec = testdir . inline_run ( [string] ) [EOL] reprec . assertoutcome ( passed = [number] , skipped = [number] ) [EOL] [EOL] def test_continue_on_failure ( self , testdir ) : [EOL] testdir . maketxtfile ( test_something = [string] ) [EOL] result = testdir . runpytest ( [string] , [string] ) [EOL] result . assert_outcomes ( passed = [number] , failed = [number] ) [EOL] [comment] [EOL] [comment] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] class TestDoctestAutoUseFixtures ( object ) : [EOL] [EOL] SCOPES = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def test_doctest_module_session_fixture ( self , testdir ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] testdir . makeconftest ( [string] ) [EOL] testdir . makepyfile ( foo = [string] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [string] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , SCOPES ) @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_fixture_scopes ( self , testdir , scope , enable_doctest ) : [EOL] [docstring] [EOL] testdir . makeconftest ( [string] . format ( scope = scope ) ) [EOL] testdir . makepyfile ( test_1 = [string] ) [EOL] params = ( [string] , ) if enable_doctest else ( ) [EOL] passes = [number] if enable_doctest else [number] [EOL] result = testdir . runpytest ( * params ) [EOL] result . stdout . fnmatch_lines ( [ [string] % passes ] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , SCOPES ) @ pytest . mark . parametrize ( [string] , [ True , False ] ) @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_fixture_module_doctest_scopes ( self , testdir , scope , autouse , use_fixture_in_doctest ) : [EOL] [docstring] [EOL] testdir . makeconftest ( [string] . format ( scope = scope , autouse = autouse ) ) [EOL] if use_fixture_in_doctest : [EOL] testdir . maketxtfile ( test_doc = [string] ) [EOL] else : [EOL] testdir . maketxtfile ( test_doc = [string] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] assert [string] not in str ( result . stdout . str ( ) ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , SCOPES ) def test_auto_use_request_attributes ( self , testdir , scope ) : [EOL] [docstring] [EOL] testdir . makeconftest ( [string] . format ( scope = scope ) ) [EOL] testdir . maketxtfile ( test_doc = [string] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] assert [string] not in str ( result . stdout . str ( ) ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] [EOL] class TestDoctestNamespaceFixture ( object ) : [EOL] [EOL] SCOPES = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , SCOPES ) def test_namespace_doctestfile ( self , testdir , scope ) : [EOL] [docstring] [EOL] testdir . makeconftest ( [string] . format ( scope = scope ) ) [EOL] p = testdir . maketxtfile ( [string] ) [EOL] reprec = testdir . inline_run ( p ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , SCOPES ) def test_namespace_pyfile ( self , testdir , scope ) : [EOL] [docstring] [EOL] testdir . makeconftest ( [string] . format ( scope = scope ) ) [EOL] p = testdir . makepyfile ( [string] ) [EOL] reprec = testdir . inline_run ( p , [string] ) [EOL] reprec . assertoutcome ( passed = [number] ) [EOL] [EOL] [EOL] class TestDoctestReportingOption ( object ) : [EOL] [EOL] def _run_doctest_report ( self , testdir , format ) : [EOL] testdir . makepyfile ( [string] ) [EOL] return testdir . runpytest ( [string] , [string] , format ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] ] ) def test_doctest_report_udiff ( self , testdir , format ) : [EOL] result = self . _run_doctest_report ( testdir , format ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_doctest_report_cdiff ( self , testdir ) : [EOL] result = self . _run_doctest_report ( testdir , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_doctest_report_ndiff ( self , testdir ) : [EOL] result = self . _run_doctest_report ( testdir , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_doctest_report_none_or_only_first_failure ( self , testdir , format ) : [EOL] result = self . _run_doctest_report ( testdir , format ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_doctest_report_invalid ( self , testdir ) : [EOL] result = self . _run_doctest_report ( testdir , [string] ) [EOL] result . stderr . fnmatch_lines ( [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.tuple,typing.Tuple[typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Union[typing.tuple,typing.Tuple[typing_extensions.Literal]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import tests [EOL] import typing [EOL] from __future__ import absolute_import , division , print_function [EOL] import sys [EOL] [EOL] import pytest [EOL] from _pytest . compat import is_generator , get_real_func , safe_getattr [EOL] from _pytest . outcomes import OutcomeException [EOL] [EOL] [EOL] def test_is_generator ( ) : [EOL] [EOL] def zap ( ) : [EOL] yield [EOL] [EOL] def foo ( ) : [EOL] pass [EOL] [EOL] assert is_generator ( zap ) [EOL] assert not is_generator ( foo ) [EOL] [EOL] [EOL] def test_real_func_loop_limit ( ) : [EOL] [EOL] class Evil ( object ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . left = [number] [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( left = self . left ) [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] if not self . left : [EOL] raise RuntimeError ( [string] ) [EOL] self . left -= [number] [EOL] return self [EOL] [EOL] evil = Evil ( ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] res = get_real_func ( evil ) [EOL] print ( res ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( sys . version_info < ( [number] , [number] ) , reason = [string] ) def test_is_generator_asyncio ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] result = testdir . runpytest_subprocess ( ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( sys . version_info < ( [number] , [number] ) , reason = [string] ) def test_is_generator_async_syntax ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] [EOL] class ErrorsHelper ( object ) : [EOL] [EOL] @ property def raise_exception ( self ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] @ property def raise_fail ( self ) : [EOL] pytest . fail ( [string] ) [EOL] [EOL] [EOL] def test_helper_failures ( ) : [EOL] helper = ErrorsHelper ( ) [EOL] with pytest . raises ( Exception ) : [EOL] helper . raise_exception [EOL] with pytest . raises ( OutcomeException ) : [EOL] helper . raise_fail [EOL] [EOL] [EOL] def test_safe_getattr ( ) : [EOL] helper = ErrorsHelper ( ) [EOL] assert safe_getattr ( helper , [string] , [string] ) == [string] [EOL] assert safe_getattr ( helper , [string] , [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from _pytest import nodes [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ) , ) def test_ischildnode ( baseid , nodeid , expected ) : [EOL] result = nodes . ischildnode ( baseid , nodeid ) [EOL] assert result is expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Tuple , Literal , Any [EOL] import typing_extensions [EOL] import typing [EOL] from __future__ import absolute_import , division , print_function [EOL] import sys [EOL] import py [EOL] import _pytest [EOL] import pytest [EOL] import os [EOL] import shutil [EOL] [EOL] pytest_plugins = [string] , [EOL] [EOL] [EOL] class TestNewAPI ( object ) : [EOL] [EOL] def test_config_cache_makedir ( self , testdir ) : [EOL] testdir . makeini ( [string] ) [EOL] config = testdir . parseconfigure ( ) [EOL] with pytest . raises ( ValueError ) : [EOL] config . cache . makedir ( [string] ) [EOL] [EOL] p = config . cache . makedir ( [string] ) [EOL] assert p . check ( ) [EOL] [EOL] def test_config_cache_dataerror ( self , testdir ) : [EOL] testdir . makeini ( [string] ) [EOL] config = testdir . parseconfigure ( ) [EOL] cache = config . cache [EOL] pytest . raises ( TypeError , lambda : cache . set ( [string] , cache ) ) [EOL] config . cache . set ( [string] , [number] ) [EOL] config . cache . _getvaluepath ( [string] ) . write ( [string] ) [EOL] val = config . cache . get ( [string] , - [number] ) [EOL] assert val == - [number] [EOL] [EOL] def test_cache_writefail_cachfile_silent ( self , testdir ) : [EOL] testdir . makeini ( [string] ) [EOL] testdir . tmpdir . join ( [string] ) . write ( [string] ) [EOL] config = testdir . parseconfigure ( ) [EOL] cache = config . cache [EOL] cache . set ( [string] , [ ] ) [EOL] [EOL] @ pytest . mark . skipif ( sys . platform . startswith ( [string] ) , reason = [string] ) def test_cache_writefail_permissions ( self , testdir ) : [EOL] testdir . makeini ( [string] ) [EOL] testdir . tmpdir . ensure_dir ( [string] ) . chmod ( [number] ) [EOL] config = testdir . parseconfigure ( ) [EOL] cache = config . cache [EOL] cache . set ( [string] , [ ] ) [EOL] [EOL] @ pytest . mark . skipif ( sys . platform . startswith ( [string] ) , reason = [string] ) def test_cache_failure_warns ( self , testdir ) : [EOL] testdir . tmpdir . ensure_dir ( [string] ) . chmod ( [number] ) [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] assert result . ret == [number] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] [EOL] def test_config_cache ( self , testdir ) : [EOL] testdir . makeconftest ( [string] ) [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert result . ret == [number] [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_cachefuncarg ( self , testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert result . ret == [number] [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_custom_rel_cache_dir ( self , testdir ) : [EOL] rel_cache_dir = os . path . join ( [string] , [string] ) [EOL] testdir . makeini ( [string] . format ( cache_dir = rel_cache_dir ) ) [EOL] testdir . makepyfile ( test_errored = [string] ) [EOL] testdir . runpytest ( ) [EOL] assert testdir . tmpdir . join ( rel_cache_dir ) . isdir ( ) [EOL] [EOL] def test_custom_abs_cache_dir ( self , testdir , tmpdir_factory ) : [EOL] tmp = str ( tmpdir_factory . mktemp ( [string] ) ) [EOL] abs_cache_dir = os . path . join ( tmp , [string] ) [EOL] testdir . makeini ( [string] . format ( cache_dir = abs_cache_dir ) ) [EOL] testdir . makepyfile ( test_errored = [string] ) [EOL] testdir . runpytest ( ) [EOL] assert py . path . local ( abs_cache_dir ) . isdir ( ) [EOL] [EOL] def test_custom_cache_dir_with_env_var ( self , testdir , monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] testdir . makeini ( [string] . format ( cache_dir = [string] ) ) [EOL] testdir . makepyfile ( test_errored = [string] ) [EOL] testdir . runpytest ( ) [EOL] assert testdir . tmpdir . join ( [string] ) . isdir ( ) [EOL] [EOL] [EOL] def test_cache_reportheader ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] [EOL] def test_cache_show ( testdir ) : [EOL] result = testdir . runpytest ( [string] ) [EOL] assert result . ret == [number] [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] testdir . makeconftest ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert result . ret == [number] [comment] [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines_random ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] [EOL] class TestLastFailed ( object ) : [EOL] [EOL] def test_lastfailed_usecase ( self , testdir , monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [number] ) [EOL] p = testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] p . write ( _pytest . _code . Source ( [string] ) ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] [comment] [EOL] if os . path . isdir ( [string] ) : [EOL] shutil . rmtree ( [string] ) [EOL] result = testdir . runpytest ( [string] , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_failedfirst_order ( self , testdir ) : [EOL] testdir . tmpdir . join ( [string] ) . write ( _pytest . _code . Source ( [string] ) ) [EOL] testdir . tmpdir . join ( [string] ) . write ( _pytest . _code . Source ( [string] ) ) [EOL] result = testdir . runpytest ( ) [EOL] [comment] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] [comment] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] [EOL] def test_lastfailed_failedfirst_order ( self , testdir ) : [EOL] testdir . makepyfile ( ** { [string] : [string] , [string] : [string] , } ) [EOL] result = testdir . runpytest ( ) [EOL] [comment] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] result = testdir . runpytest ( [string] , [string] ) [EOL] [comment] [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] assert [string] not in result . stdout . str ( ) [EOL] [EOL] def test_lastfailed_difference_invocations ( self , testdir , monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [number] ) [EOL] testdir . makepyfile ( test_a = [string] , test_b = [string] , ) [EOL] p = testdir . tmpdir . join ( [string] ) [EOL] p2 = testdir . tmpdir . join ( [string] ) [EOL] [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] , p2 ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] p2 . write ( _pytest . _code . Source ( [string] ) ) [EOL] result = testdir . runpytest ( [string] , p2 ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] , p ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_lastfailed_usecase_splice ( self , testdir , monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [number] ) [EOL] testdir . makepyfile ( [string] ) [EOL] p2 = testdir . tmpdir . join ( [string] ) [EOL] p2 . write ( _pytest . _code . Source ( [string] ) ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] , p2 ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_lastfailed_xpass ( self , testdir ) : [EOL] testdir . inline_runsource ( [string] ) [EOL] config = testdir . parseconfigure ( ) [EOL] lastfailed = config . cache . get ( [string] , - [number] ) [EOL] assert lastfailed == - [number] [EOL] [EOL] def test_non_serializable_parametrize ( self , testdir ) : [EOL] [docstring] [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [string] ) [EOL] [EOL] def test_terminal_report_lastfailed ( self , testdir ) : [EOL] test_a = testdir . makepyfile ( test_a = [string] ) [EOL] test_b = testdir . makepyfile ( test_b = [string] ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] result = testdir . runpytest ( test_a , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] result = testdir . runpytest ( test_b , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] result = testdir . runpytest ( [string] , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] def test_terminal_report_failedfirst ( self , testdir ) : [EOL] testdir . makepyfile ( test_a = [string] ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] def test_lastfailed_collectfailure ( self , testdir , monkeypatch ) : [EOL] [EOL] testdir . makepyfile ( test_maybe = [string] ) [EOL] [EOL] def rlf ( fail_import , fail_run ) : [EOL] monkeypatch . setenv ( [string] , fail_import ) [EOL] monkeypatch . setenv ( [string] , fail_run ) [EOL] [EOL] testdir . runpytest ( [string] ) [EOL] config = testdir . parseconfigure ( ) [EOL] lastfailed = config . cache . get ( [string] , - [number] ) [EOL] return lastfailed [EOL] [EOL] lastfailed = rlf ( fail_import = [number] , fail_run = [number] ) [EOL] assert lastfailed == - [number] [EOL] [EOL] lastfailed = rlf ( fail_import = [number] , fail_run = [number] ) [EOL] assert list ( lastfailed ) == [ [string] ] [EOL] [EOL] lastfailed = rlf ( fail_import = [number] , fail_run = [number] ) [EOL] assert list ( lastfailed ) == [ [string] ] [EOL] [EOL] def test_lastfailed_failure_subset ( self , testdir , monkeypatch ) : [EOL] [EOL] testdir . makepyfile ( test_maybe = [string] ) [EOL] [EOL] testdir . makepyfile ( test_maybe2 = [string] ) [EOL] [EOL] def rlf ( fail_import , fail_run , args = ( ) ) : [EOL] monkeypatch . setenv ( [string] , fail_import ) [EOL] monkeypatch . setenv ( [string] , fail_run ) [EOL] [EOL] result = testdir . runpytest ( [string] , [string] , * args ) [EOL] config = testdir . parseconfigure ( ) [EOL] lastfailed = config . cache . get ( [string] , - [number] ) [EOL] return result , lastfailed [EOL] [EOL] result , lastfailed = rlf ( fail_import = [number] , fail_run = [number] ) [EOL] assert lastfailed == - [number] [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] result , lastfailed = rlf ( fail_import = [number] , fail_run = [number] ) [EOL] assert sorted ( list ( lastfailed ) ) == [ [string] , [string] ] [EOL] [EOL] result , lastfailed = rlf ( fail_import = [number] , fail_run = [number] , args = ( [string] , ) ) [EOL] assert list ( lastfailed ) == [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] result , lastfailed = rlf ( fail_import = [number] , fail_run = [number] , args = ( [string] , ) ) [EOL] assert list ( lastfailed ) == [ [string] ] [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_lastfailed_creates_cache_when_needed ( self , testdir ) : [EOL] [comment] [EOL] testdir . makepyfile ( test_empty = [string] ) [EOL] testdir . runpytest ( [string] , [string] ) [EOL] assert not os . path . exists ( [string] ) [EOL] [EOL] testdir . makepyfile ( test_successful = [string] ) [EOL] testdir . runpytest ( [string] , [string] ) [EOL] assert not os . path . exists ( [string] ) [EOL] [EOL] testdir . makepyfile ( test_errored = [string] ) [EOL] testdir . runpytest ( [string] , [string] ) [EOL] assert os . path . exists ( [string] ) [EOL] [EOL] def test_xfail_not_considered_failure ( self , testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [string] ) [EOL] assert self . get_cached_last_failed ( testdir ) == [ ] [EOL] [EOL] def test_xfail_strict_considered_failure ( self , testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [string] ) [EOL] assert ( self . get_cached_last_failed ( testdir ) == [ [string] ] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_failed_changed_to_xfail_or_skip ( self , testdir , mark ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert ( self . get_cached_last_failed ( testdir ) == [ [string] ] ) [EOL] assert result . ret == [number] [EOL] [EOL] testdir . makepyfile ( [string] . format ( mark = mark ) ) [EOL] result = testdir . runpytest ( ) [EOL] assert result . ret == [number] [EOL] assert self . get_cached_last_failed ( testdir ) == [ ] [EOL] assert result . ret == [number] [EOL] [EOL] def get_cached_last_failed ( self , testdir ) : [EOL] config = testdir . parseconfigure ( ) [EOL] return sorted ( config . cache . get ( [string] , { } ) ) [EOL] [EOL] def test_cache_cumulative ( self , testdir ) : [EOL] [docstring] [EOL] [comment] [EOL] test_bar = testdir . makepyfile ( test_bar = [string] ) [EOL] test_foo = testdir . makepyfile ( test_foo = [string] ) [EOL] testdir . runpytest ( ) [EOL] assert ( self . get_cached_last_failed ( testdir ) == [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] testdir . makepyfile ( test_bar = [string] ) [EOL] result = testdir . runpytest ( test_bar ) [EOL] result . stdout . fnmatch_lines ( [string] ) [EOL] [comment] [EOL] assert self . get_cached_last_failed ( testdir ) == [ [string] ] [EOL] [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [string] ) [EOL] assert self . get_cached_last_failed ( testdir ) == [ [string] ] [EOL] [EOL] [comment] [EOL] test_foo = testdir . makepyfile ( test_foo = [string] ) [EOL] result = testdir . runpytest ( test_foo , [string] ) [EOL] result . stdout . fnmatch_lines ( [string] ) [EOL] assert self . get_cached_last_failed ( testdir ) == [ ] [EOL] [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [string] ) [EOL] assert self . get_cached_last_failed ( testdir ) == [ ] [EOL] [EOL] def test_lastfailed_no_failures_behavior_all_passed ( self , testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] , [string] , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] , [string] , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] def test_lastfailed_no_failures_behavior_empty_cache ( self , testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( [string] , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] , [string] , [string] , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] result = testdir . runpytest ( [string] , [string] , [string] , [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] [EOL] class TestNewFirst ( object ) : [EOL] [EOL] def test_newfirst_usecase ( self , testdir ) : [EOL] testdir . makepyfile ( ** { [string] : [string] , [string] : [string] , } ) [EOL] [EOL] testdir . tmpdir . join ( [string] ) . setmtime ( [number] ) [EOL] [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] result = testdir . runpytest ( [string] , [string] ) [EOL] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] testdir . tmpdir . join ( [string] ) . write ( [string] [string] [string] [string] ) [EOL] testdir . tmpdir . join ( [string] ) . setmtime ( [number] ) [EOL] [EOL] result = testdir . runpytest ( [string] , [string] ) [EOL] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_newfirst_parametrize ( self , testdir ) : [EOL] testdir . makepyfile ( ** { [string] : [string] , [string] : [string] , } ) [EOL] [EOL] testdir . tmpdir . join ( [string] ) . setmtime ( [number] ) [EOL] [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] result = testdir . runpytest ( [string] , [string] ) [EOL] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] testdir . tmpdir . join ( [string] ) . write ( [string] [string] [string] ) [EOL] testdir . tmpdir . join ( [string] ) . setmtime ( [number] ) [EOL] [EOL] result = testdir . runpytest ( [string] , [string] ) [EOL] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] if __name__ == [string] : [EOL] import sys [EOL] import pytest [EOL] [EOL] sys . exit ( pytest . main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def test_upper ( ) : [EOL] assert [string] . upper ( ) == [string] [EOL] [EOL] [EOL] def test_lower ( ) : [EOL] assert [string] . lower ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] import pytest [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] sublogger = logging . getLogger ( __name__ + [string] ) [EOL] [EOL] [EOL] def test_fixture_help ( testdir ) : [EOL] result = testdir . runpytest ( [string] ) [EOL] result . stdout . fnmatch_lines ( [ [string] ] ) [EOL] [EOL] [EOL] def test_change_level ( caplog ) : [EOL] caplog . set_level ( logging . INFO ) [EOL] logger . debug ( [string] ) [EOL] logger . info ( [string] ) [EOL] [EOL] caplog . set_level ( logging . CRITICAL , logger = sublogger . name ) [EOL] sublogger . warning ( [string] ) [EOL] sublogger . critical ( [string] ) [EOL] [EOL] assert [string] not in caplog . text [EOL] assert [string] in caplog . text [EOL] assert [string] not in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_change_level_undo ( testdir ) : [EOL] [docstring] [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest_subprocess ( ) [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] ] ) [EOL] assert [string] not in result . stdout . str ( ) [EOL] [EOL] [EOL] def test_with_statement ( caplog ) : [EOL] with caplog . at_level ( logging . INFO ) : [EOL] logger . debug ( [string] ) [EOL] logger . info ( [string] ) [EOL] [EOL] with caplog . at_level ( logging . CRITICAL , logger = sublogger . name ) : [EOL] sublogger . warning ( [string] ) [EOL] sublogger . critical ( [string] ) [EOL] [EOL] assert [string] not in caplog . text [EOL] assert [string] in caplog . text [EOL] assert [string] not in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_log_access ( caplog ) : [EOL] caplog . set_level ( logging . INFO ) [EOL] logger . info ( [string] , [string] ) [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . msg == [string] [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_record_tuples ( caplog ) : [EOL] caplog . set_level ( logging . INFO ) [EOL] logger . info ( [string] , [string] ) [EOL] [EOL] assert caplog . record_tuples == [ ( __name__ , logging . INFO , [string] ) ] [EOL] [EOL] [EOL] def test_unicode ( caplog ) : [EOL] caplog . set_level ( logging . INFO ) [EOL] logger . info ( [string] ) [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . msg == [string] [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_clear ( caplog ) : [EOL] caplog . set_level ( logging . INFO ) [EOL] logger . info ( [string] ) [EOL] assert len ( caplog . records ) [EOL] assert caplog . text [EOL] caplog . clear ( ) [EOL] assert not len ( caplog . records ) [EOL] assert not caplog . text [EOL] [EOL] [EOL] @ pytest . fixture def logging_during_setup_and_teardown ( caplog ) : [EOL] caplog . set_level ( [string] ) [EOL] logger . info ( [string] ) [EOL] yield [EOL] logger . info ( [string] ) [EOL] assert [ x . message for x in caplog . get_records ( [string] ) ] == [ [string] ] [EOL] [EOL] [EOL] def test_caplog_captures_for_all_stages ( caplog , logging_during_setup_and_teardown ) : [EOL] assert not caplog . records [EOL] assert not caplog . get_records ( [string] ) [EOL] logger . info ( [string] ) [EOL] assert [ x . message for x in caplog . get_records ( [string] ) ] == [ [string] ] [EOL] [EOL] assert [ x . message for x in caplog . get_records ( [string] ) ] == [ [string] ] [EOL] [EOL] [comment] [EOL] assert set ( caplog . _item . catch_log_handlers . keys ( ) ) == { [string] , [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $logging.Logger$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $logging.Logger$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def test_show_fixtures_and_test ( testdir ) : [EOL] [docstring] [EOL] p = testdir . makepyfile ( [string] ) [EOL] [EOL] result = testdir . runpytest ( [string] , p ) [EOL] assert result . ret == [number] [EOL] [EOL] result . stdout . fnmatch_lines ( [ [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tests [EOL] [docstring] [EOL] from __future__ import absolute_import , division , print_function [EOL] [EOL] [EOL] class RemovedInPytest4Warning ( DeprecationWarning ) : [EOL] [docstring] [EOL] [EOL] [EOL] MAIN_STR_ARGS = [string] [string] [EOL] [EOL] YIELD_TESTS = [string] [EOL] [EOL] FUNCARG_PREFIX = ( [string] [string] [string] ) [EOL] [EOL] CFG_PYTEST_SECTION = [string] [EOL] [EOL] GETFUNCARGVALUE = [string] [EOL] [EOL] RESULT_LOG = ( [string] [string] ) [EOL] [EOL] MARK_INFO_ATTRIBUTE = RemovedInPytest4Warning ( [string] [string] [string] ) [EOL] [EOL] MARK_PARAMETERSET_UNPACKING = RemovedInPytest4Warning ( [string] [string] [string] ) [EOL] [EOL] RECORD_XML_PROPERTY = ( [string] [string] [string] ) [EOL] [EOL] COLLECTOR_MAKEITEM = RemovedInPytest4Warning ( [string] [string] ) [EOL] [EOL] METAFUNC_ADD_CALL = ( [string] [string] ) [EOL] [EOL] PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST = RemovedInPytest4Warning ( [string] [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , division , print_function [EOL] [EOL] import pytest [EOL] [EOL] [EOL] def pytest_addoption ( parser ) : [EOL] group = parser . getgroup ( [string] ) [EOL] group . addoption ( [string] , [string] , action = [string] , help = [string] [string] , ) [EOL] [EOL] [EOL] @ pytest . hookimpl ( tryfirst = True ) def pytest_fixture_setup ( fixturedef , request ) : [EOL] [comment] [EOL] if request . config . option . setupplan : [EOL] fixturedef . cached_result = ( None , None , None ) [EOL] return fixturedef . cached_result [EOL] [EOL] [EOL] @ pytest . hookimpl ( tryfirst = True ) def pytest_cmdline_main ( config ) : [EOL] if config . option . setupplan : [EOL] config . option . setuponly = True [EOL] config . option . setupshow = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] __all__ = [ [string] ] [EOL] [EOL] try : [EOL] from . _version import version as __version__ [EOL] except ImportError : [EOL] [comment] [EOL] [comment] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Union , Set , List , Dict , Type , Any [EOL] import tests [EOL] import argparse [EOL] import typing [EOL] import six [EOL] import warnings [EOL] import argparse [EOL] [EOL] FILE_OR_DIR = [string] [EOL] [EOL] [EOL] class Parser ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , usage = None , processopt = None ) : [EOL] self . _anonymous = OptionGroup ( [string] , parser = self ) [EOL] self . _groups = [ ] [EOL] self . _processopt = processopt [EOL] self . _usage = usage [EOL] self . _inidict = { } [EOL] self . _ininames = [ ] [EOL] self . extra_info = { } [EOL] [EOL] def processoption ( self , option ) : [EOL] if self . _processopt : [EOL] if option . dest : [EOL] self . _processopt ( option ) [EOL] [EOL] def getgroup ( self , name , description = [string] , after = None ) : [EOL] [docstring] [EOL] for group in self . _groups : [EOL] if group . name == name : [EOL] return group [EOL] group = OptionGroup ( name , description , parser = self ) [EOL] i = [number] [EOL] for i , grp in enumerate ( self . _groups ) : [EOL] if grp . name == after : [EOL] break [EOL] self . _groups . insert ( i + [number] , group ) [EOL] return group [EOL] [EOL] def addoption ( self , * opts , ** attrs ) : [EOL] [docstring] [EOL] self . _anonymous . addoption ( * opts , ** attrs ) [EOL] [EOL] def parse ( self , args , namespace = None ) : [EOL] from _pytest . _argcomplete import try_argcomplete [EOL] [EOL] self . optparser = self . _getparser ( ) [EOL] try_argcomplete ( self . optparser ) [EOL] return self . optparser . parse_args ( [ str ( x ) for x in args ] , namespace = namespace ) [EOL] [EOL] def _getparser ( self ) : [EOL] from _pytest . _argcomplete import filescompleter [EOL] [EOL] optparser = MyOptionParser ( self , self . extra_info ) [EOL] groups = self . _groups + [ self . _anonymous ] [EOL] for group in groups : [EOL] if group . options : [EOL] desc = group . description or group . name [EOL] arggroup = optparser . add_argument_group ( desc ) [EOL] for option in group . options : [EOL] n = option . names ( ) [EOL] a = option . attrs ( ) [EOL] arggroup . add_argument ( * n , ** a ) [EOL] [comment] [EOL] optparser . add_argument ( FILE_OR_DIR , nargs = [string] ) . completer = filescompleter [EOL] return optparser [EOL] [EOL] def parse_setoption ( self , args , option , namespace = None ) : [EOL] parsedoption = self . parse ( args , namespace = namespace ) [EOL] for name , value in parsedoption . __dict__ . items ( ) : [EOL] setattr ( option , name , value ) [EOL] return getattr ( parsedoption , FILE_OR_DIR ) [EOL] [EOL] def parse_known_args ( self , args , namespace = None ) : [EOL] [docstring] [EOL] return self . parse_known_and_unknown_args ( args , namespace = namespace ) [ [number] ] [EOL] [EOL] def parse_known_and_unknown_args ( self , args , namespace = None ) : [EOL] [docstring] [EOL] optparser = self . _getparser ( ) [EOL] args = [ str ( x ) for x in args ] [EOL] return optparser . parse_known_args ( args , namespace = namespace ) [EOL] [EOL] def addini ( self , name , help , type = None , default = None ) : [EOL] [docstring] [EOL] assert type in ( None , [string] , [string] , [string] , [string] ) [EOL] self . _inidict [ name ] = ( help , type , default ) [EOL] self . _ininames . append ( name ) [EOL] [EOL] [EOL] class ArgumentError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg , option ) : [EOL] self . msg = msg [EOL] self . option_id = str ( option ) [EOL] [EOL] def __str__ ( self ) : [EOL] if self . option_id : [EOL] return [string] % ( self . option_id , self . msg ) [EOL] else : [EOL] return self . msg [EOL] [EOL] [EOL] class Argument ( object ) : [EOL] [docstring] [EOL] _typ_map = { [string] : int , [string] : str , [string] : float , [string] : complex } [EOL] [EOL] def __init__ ( self , * names , ** attrs ) : [EOL] [docstring] [EOL] self . _attrs = attrs [EOL] self . _short_opts = [ ] [EOL] self . _long_opts = [ ] [EOL] self . dest = attrs . get ( [string] ) [EOL] if [string] in ( attrs . get ( [string] ) or [string] ) : [EOL] warnings . warn ( [string] [string] , DeprecationWarning , stacklevel = [number] , ) [EOL] try : [EOL] typ = attrs [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] [comment] [EOL] if isinstance ( typ , six . string_types ) : [EOL] if typ == [string] : [EOL] warnings . warn ( [string] [string] [string] [string] % ( typ , names ) , DeprecationWarning , stacklevel = [number] , ) [EOL] [comment] [EOL] [comment] [EOL] attrs [ [string] ] = type ( attrs [ [string] ] [ [number] ] ) [EOL] else : [EOL] warnings . warn ( [string] [string] [string] % ( typ , names ) , DeprecationWarning , stacklevel = [number] , ) [EOL] attrs [ [string] ] = Argument . _typ_map [ typ ] [EOL] [comment] [EOL] self . type = attrs [ [string] ] [EOL] else : [EOL] self . type = typ [EOL] try : [EOL] [comment] [EOL] self . default = attrs [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] self . _set_opt_strings ( names ) [EOL] if not self . dest : [EOL] if self . _long_opts : [EOL] self . dest = self . _long_opts [ [number] ] [ [number] : ] . replace ( [string] , [string] ) [EOL] else : [EOL] try : [EOL] self . dest = self . _short_opts [ [number] ] [ [number] : ] [EOL] except IndexError : [EOL] raise ArgumentError ( [string] , self ) [EOL] [EOL] def names ( self ) : [EOL] return self . _short_opts + self . _long_opts [EOL] [EOL] def attrs ( self ) : [EOL] [comment] [EOL] attrs = [string] . split ( ) [EOL] if self . dest : [EOL] attrs . append ( self . dest ) [EOL] for attr in attrs : [EOL] try : [EOL] self . _attrs [ attr ] = getattr ( self , attr ) [EOL] except AttributeError : [EOL] pass [EOL] if self . _attrs . get ( [string] ) : [EOL] a = self . _attrs [ [string] ] [EOL] a = a . replace ( [string] , [string] ) [EOL] [comment] [EOL] self . _attrs [ [string] ] = a [EOL] return self . _attrs [EOL] [EOL] def _set_opt_strings ( self , opts ) : [EOL] [docstring] [EOL] for opt in opts : [EOL] if len ( opt ) < [number] : [EOL] raise ArgumentError ( [string] [string] % opt , self , ) [EOL] elif len ( opt ) == [number] : [EOL] if not ( opt [ [number] ] == [string] and opt [ [number] ] != [string] ) : [EOL] raise ArgumentError ( [string] [string] % opt , self , ) [EOL] self . _short_opts . append ( opt ) [EOL] else : [EOL] if not ( opt [ [number] : [number] ] == [string] and opt [ [number] ] != [string] ) : [EOL] raise ArgumentError ( [string] [string] % opt , self , ) [EOL] self . _long_opts . append ( opt ) [EOL] [EOL] def __repr__ ( self ) : [EOL] args = [ ] [EOL] if self . _short_opts : [EOL] args += [ [string] + repr ( self . _short_opts ) ] [EOL] if self . _long_opts : [EOL] args += [ [string] + repr ( self . _long_opts ) ] [EOL] args += [ [string] + repr ( self . dest ) ] [EOL] if hasattr ( self , [string] ) : [EOL] args += [ [string] + repr ( self . type ) ] [EOL] if hasattr ( self , [string] ) : [EOL] args += [ [string] + repr ( self . default ) ] [EOL] return [string] . format ( [string] . join ( args ) ) [EOL] [EOL] [EOL] class OptionGroup ( object ) : [EOL] [EOL] def __init__ ( self , name , description = [string] , parser = None ) : [EOL] self . name = name [EOL] self . description = description [EOL] self . options = [ ] [EOL] self . parser = parser [EOL] [EOL] def addoption ( self , * optnames , ** attrs ) : [EOL] [docstring] [EOL] conflict = set ( optnames ) . intersection ( name for opt in self . options for name in opt . names ( ) ) [EOL] if conflict : [EOL] raise ValueError ( [string] % conflict ) [EOL] option = Argument ( * optnames , ** attrs ) [EOL] self . _addoption_instance ( option , shortupper = False ) [EOL] [EOL] def _addoption ( self , * optnames , ** attrs ) : [EOL] option = Argument ( * optnames , ** attrs ) [EOL] self . _addoption_instance ( option , shortupper = True ) [EOL] [EOL] def _addoption_instance ( self , option , shortupper = False ) : [EOL] if not shortupper : [EOL] for opt in option . _short_opts : [EOL] if opt [ [number] ] == [string] and opt [ [number] ] . islower ( ) : [EOL] raise ValueError ( [string] ) [EOL] if self . parser : [EOL] self . parser . processoption ( option ) [EOL] self . options . append ( option ) [EOL] [EOL] [EOL] class MyOptionParser ( argparse . ArgumentParser ) : [EOL] [EOL] def __init__ ( self , parser , extra_info = None ) : [EOL] if not extra_info : [EOL] extra_info = { } [EOL] self . _parser = parser [EOL] argparse . ArgumentParser . __init__ ( self , usage = parser . _usage , add_help = False , formatter_class = DropShorterLongHelpFormatter , ) [EOL] [comment] [EOL] [comment] [EOL] self . extra_info = extra_info [EOL] [EOL] def parse_args ( self , args = None , namespace = None ) : [EOL] [docstring] [EOL] args , argv = self . parse_known_args ( args , namespace ) [EOL] if argv : [EOL] for arg in argv : [EOL] if arg and arg [ [number] ] == [string] : [EOL] lines = [ [string] % ( [string] . join ( argv ) ) ] [EOL] for k , v in sorted ( self . extra_info . items ( ) ) : [EOL] lines . append ( [string] % ( k , v ) ) [EOL] self . error ( [string] . join ( lines ) ) [EOL] getattr ( args , FILE_OR_DIR ) . extend ( argv ) [EOL] return args [EOL] [EOL] [EOL] class DropShorterLongHelpFormatter ( argparse . HelpFormatter ) : [EOL] [docstring] [EOL] [EOL] def _format_action_invocation ( self , action ) : [EOL] orgstr = argparse . HelpFormatter . _format_action_invocation ( self , action ) [EOL] if orgstr and orgstr [ [number] ] != [string] : [comment] [EOL] return orgstr [EOL] res = getattr ( action , [string] , None ) [EOL] if res : [EOL] return res [EOL] options = orgstr . split ( [string] ) [EOL] if len ( options ) == [number] and ( len ( options [ [number] ] ) == [number] or len ( options [ [number] ] ) == [number] ) : [EOL] [comment] [EOL] action . _formatted_action_invocation = orgstr [EOL] return orgstr [EOL] return_list = [ ] [EOL] option_map = getattr ( action , [string] , { } ) [EOL] if option_map is None : [EOL] option_map = { } [EOL] short_long = { } [EOL] for option in options : [EOL] if len ( option ) == [number] or option [ [number] ] == [string] : [EOL] continue [EOL] if not option . startswith ( [string] ) : [EOL] raise ArgumentError ( [string] % (option) , self ) [EOL] xxoption = option [ [number] : ] [EOL] if xxoption . split ( ) [ [number] ] not in option_map : [EOL] shortened = xxoption . replace ( [string] , [string] ) [EOL] if ( shortened not in short_long or len ( short_long [ shortened ] ) < len ( xxoption ) ) : [EOL] short_long [ shortened ] = xxoption [EOL] [comment] [EOL] [comment] [EOL] for option in options : [EOL] if len ( option ) == [number] or option [ [number] ] == [string] : [EOL] return_list . append ( option ) [EOL] if option [ [number] : ] == short_long . get ( option . replace ( [string] , [string] ) ) : [EOL] return_list . append ( option . replace ( [string] , [string] , [number] ) ) [EOL] action . _formatted_action_invocation = [string] . join ( return_list ) [EOL] return action . _formatted_action_invocation [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.OptionGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.OptionGroup$ 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.OptionGroup$ 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.OptionGroup$ 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.OptionGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.OptionGroup$ 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.OptionGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.MyOptionParser$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.MyOptionParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.MyOptionParser$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.MyOptionParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[typing.Union[builtins.complex,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.Argument$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.Argument$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.Argument$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.third_party.pytest.src._pytest.config.argparsing.Argument$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0
class UsageError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class PrintHelp ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] ) ) def foo ( request ) : [EOL] return request . param [EOL] [EOL] [EOL] def test_it ( foo ) : [EOL] pass [EOL] [EOL] [EOL] def test_it2 ( foo ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import py [EOL] [EOL] for i in range ( [number] ) : [EOL] py . builtin . exec_ ( [string] % i ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from six . moves import range [EOL] import pytest [EOL] [EOL] [EOL] SKIP = True [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , range ( [number] ) ) def test_foo ( x ) : [EOL] if SKIP : [EOL] pytest . skip ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import timeit [EOL] [EOL] imports = [ [string] , [string] , ] [EOL] [EOL] count = [number] [comment] [EOL] setup = [string] [EOL] run = [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( timeit . timeit ( run , setup = setup % imports [ [number] ] , number = count ) ) [EOL] print ( ( timeit . timeit ( run , setup = setup % imports [ [number] ] , number = count ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0
import sys [EOL] from distutils . core import setup [EOL] [EOL] if __name__ == [string] : [EOL] if [string] not in sys . argv [ [number] : ] : [EOL] raise ValueError ( [string] ) [EOL] setup ( name = [string] , version = [string] , description = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] collect_ignore = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_function ( ) : [EOL] pass [EOL] [EOL] [EOL] class TestClass ( object ) : [EOL] [EOL] def test_method ( self ) : [EOL] pass [EOL] [EOL] def test_anothermethod ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] collect_ignore = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
	0
[EOL] hello = [string] [EOL] [EOL] def test_func ( ) : [EOL] pass [EOL]	0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
def test_exception_syntax ( ) : [EOL] try : [EOL] [number] / [number] [EOL] except ZeroDivisionError as e : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def test_quick ( setup ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL]	0 0
def test_something ( setup ) : [EOL] assert setup . timecostly == [number] [EOL] [EOL] [EOL] def test_something_more ( setup ) : [EOL] assert setup . timecostly == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Dict , Any , List [EOL] import subprocess [EOL] import argparse [EOL] import logging [EOL] import typing [EOL] import argparse [EOL] import os [EOL] import platform [EOL] import shutil [EOL] import subprocess [EOL] [EOL] import requests [EOL] [EOL] android_device = None [EOL] [EOL] here = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] wpt_root = os . path . abspath ( os . path . join ( here , os . pardir , os . pardir ) ) [EOL] [EOL] [EOL] def do_delayed_imports ( ) : [EOL] global android_device [EOL] from mozrunner . devices import android_device [EOL] android_device . TOOLTOOL_PATH = os . path . join ( os . path . dirname ( __file__ ) , os . pardir , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def get_parser_install ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , action = [string] , default = False , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] def get_parser_start ( ) : [EOL] return get_parser_install ( ) [EOL] [EOL] [EOL] def get_sdk_path ( dest ) : [EOL] if dest is None : [EOL] [comment] [EOL] dest = os . path . join ( wpt_root , [string] ) [EOL] dest = os . path . join ( dest , [string] ) [EOL] return os . path . abspath ( os . environ . get ( [string] , dest ) ) [EOL] [EOL] [EOL] def uninstall_sdk ( dest = None ) : [EOL] path = get_sdk_path ( dest ) [EOL] if os . path . exists ( path ) and os . path . isdir ( path ) : [EOL] shutil . rmtree ( path ) [EOL] [EOL] [EOL] def install_sdk ( logger , dest = None ) : [EOL] sdk_path = get_sdk_path ( dest ) [EOL] if os . path . isdir ( sdk_path ) : [EOL] logger . info ( [string] % sdk_path ) [EOL] return sdk_path , False [EOL] [EOL] if not os . path . exists ( sdk_path ) : [EOL] os . makedirs ( sdk_path ) [EOL] [EOL] os_name = platform . system ( ) . lower ( ) [EOL] if os_name not in [ [string] , [string] , [string] ] : [EOL] logger . critical ( [string] % os_name ) [EOL] raise NotImplementedError [EOL] [EOL] os_name = [string] if os_name == [string] else os_name [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] url = [string] % ( os_name , ) [EOL] [EOL] logger . info ( [string] % url ) [EOL] temp_path = os . path . join ( sdk_path , url . rsplit ( [string] , [number] ) [ [number] ] ) [EOL] try : [EOL] with open ( temp_path , [string] ) as f : [EOL] with requests . get ( url , stream = True ) as resp : [EOL] shutil . copyfileobj ( resp . raw , f ) [EOL] [EOL] [comment] [EOL] subprocess . check_call ( [ [string] , temp_path ] , cwd = sdk_path ) [EOL] finally : [EOL] os . unlink ( temp_path ) [EOL] [EOL] return sdk_path , True [EOL] [EOL] [EOL] def install_android_packages ( logger , sdk_path , no_prompt = False ) : [EOL] sdk_manager_path = os . path . join ( sdk_path , [string] , [string] , [string] ) [EOL] if not os . path . exists ( sdk_manager_path ) : [EOL] raise OSError ( [string] % sdk_manager_path ) [EOL] [EOL] [comment] [EOL] packages = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] logger . info ( [string] ) [EOL] cmd = [ sdk_manager_path ] + packages [EOL] [EOL] proc = subprocess . Popen ( cmd , stdin = subprocess . PIPE ) [EOL] if no_prompt : [EOL] data = [string] * [number] if no_prompt else None [EOL] proc . communicate ( data ) [EOL] else : [EOL] proc . wait ( ) [EOL] if proc . returncode != [number] : [EOL] raise subprocess . CalledProcessError ( proc . returncode , cmd ) [EOL] [EOL] [EOL] def get_emulator ( sdk_path ) : [EOL] if android_device is None : [EOL] do_delayed_imports ( ) [EOL] if [string] not in os . environ : [EOL] os . environ [ [string] ] = sdk_path [EOL] substs = { [string] : wpt_root , [string] : [string] } [EOL] emulator = android_device . AndroidEmulator ( [string] , substs = substs ) [EOL] emulator . emulator_path = os . path . join ( sdk_path , [string] , [string] ) [EOL] emulator . avd_info . tooltool_manifest = os . path . join ( wpt_root , [string] , [string] , [string] ) [EOL] return emulator [EOL] [EOL] [EOL] def install ( logger , reinstall = False , no_prompt = False ) : [EOL] if reinstall : [EOL] uninstall_sdk ( ) [EOL] [EOL] dest , new_install = install_sdk ( logger ) [EOL] if new_install : [EOL] install_android_packages ( logger , dest , no_prompt ) [EOL] [EOL] if [string] not in os . environ : [EOL] os . environ [ [string] ] = dest [EOL] [EOL] emulator = get_emulator ( dest ) [EOL] emulator . update_avd ( ) [EOL] return emulator [EOL] [EOL] [EOL] def start ( logger , emulator = None , reinstall = False ) : [EOL] if reinstall : [EOL] install ( reinstall = True ) [EOL] [EOL] sdk_path = get_sdk_path ( None ) [EOL] [EOL] if emulator is None : [EOL] emulator = get_emulator ( sdk_path ) [EOL] [EOL] if not emulator . check_avd ( ) : [EOL] emulator . update_avd ( ) [EOL] [EOL] emulator . start ( ) [EOL] emulator . wait_for_start ( ) [EOL] return emulator [EOL] [EOL] [EOL] def run_install ( venv , ** kwargs ) : [EOL] try : [EOL] import logging [EOL] logging . basicConfig ( ) [EOL] logger = logging . getLogger ( ) [EOL] [EOL] install ( logger , ** kwargs ) [EOL] except Exception : [EOL] import traceback [EOL] traceback . print_exc ( ) [EOL] import pdb [EOL] pdb . post_mortem ( ) [EOL] [EOL] [EOL] def run_start ( venv , ** kwargs ) : [EOL] try : [EOL] import logging [EOL] logging . basicConfig ( ) [EOL] logger = logging . getLogger ( ) [EOL] [EOL] start ( logger , ** kwargs ) [EOL] except Exception : [EOL] import traceback [EOL] traceback . print_exc ( ) [EOL] import pdb [EOL] pdb . post_mortem ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import argparse [EOL] import logging [EOL] import typing [EOL] import argparse [EOL] import base64 [EOL] import logging [EOL] import subprocess [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] CHROME_SPKI_CERTS_CONTENT = [string] [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] def check_cert ( certificate , checkend_seconds ) : [EOL] [docstring] [EOL] cmd = [ [string] , [string] , [string] , str ( checkend_seconds ) , [string] , [string] , certificate ] [EOL] logger . info ( [string] % [string] . join ( cmd ) ) [EOL] return subprocess . call ( cmd ) [EOL] [EOL] [EOL] def regen_certs ( ) : [EOL] [docstring] [EOL] cmd = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] logger . info ( [string] % [string] . join ( cmd ) ) [EOL] subprocess . check_call ( cmd ) [EOL] [EOL] [EOL] def regen_chrome_spki ( ) : [EOL] [docstring] [EOL] wpt_spki = calculate_spki ( [string] ) [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( CHROME_SPKI_CERTS_CONTENT . format ( wpt_fingerprint = wpt_spki ) ) [EOL] [EOL] [EOL] def calculate_spki ( cert_path ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] cmd = ( [string] . format ( cert_path = cert_path ) + [string] + [string] ) [EOL] dgst_output = subprocess . check_output ( cmd , shell = True ) [EOL] [EOL] return base64 . b64encode ( dgst_output ) . decode ( [string] ) [EOL] [EOL] [EOL] def run ( ** kwargs ) : [EOL] logging . basicConfig ( ) [EOL] [EOL] if kwargs [ [string] ] : [EOL] logger . info ( [string] ) [EOL] checkend_seconds = kwargs [ [string] ] [EOL] if ( kwargs [ [string] ] or check_cert ( [string] , checkend_seconds ) or check_cert ( [string] , checkend_seconds ) ) : [EOL] regen_certs ( ) [EOL] regen_chrome_spki ( ) [EOL] else : [EOL] logger . info ( [string] % checkend_seconds ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
	0
import builtins [EOL] import tests [EOL] MYPY = False [EOL] if MYPY : [EOL] [comment] [EOL] from typing import Any [EOL] from typing import Optional [EOL] from typing import Text [EOL] [EOL] class GitHubChecksOutputter ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , path ) : [EOL] [comment] [EOL] self . path = path [EOL] [EOL] def output ( self , line ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with open ( self . path , [string] ) as f : [EOL] f . write ( line ) [EOL] f . write ( [string] ) [EOL] [EOL] [EOL] __outputter = None [EOL] def get_gh_checks_outputter ( filepath ) : [EOL] [comment] [EOL] [docstring] [EOL] global __outputter [EOL] if filepath and __outputter is None : [EOL] __outputter = GitHubChecksOutputter ( filepath ) [EOL] return __outputter [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import mock [EOL] import pytest [EOL] [EOL] from tools . ci . tc import decision [EOL] from six import iteritems [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ ] , { [string] : { } } , [ [string] ] ) , ( [ ] , { [string] : { [string] : { } } } , [ ] ) , ( [ [string] ] , { [string] : { [string] : { [string] : [ [string] , [string] ] } } } , [ [string] ] ) , ( [ [string] ] , { [string] : { [string] : { [string] : [ [string] ] } } } , [ ] ) , ( [ [string] ] , { [string] : { [string] : { [string] : [ [string] ] } } } , [ [string] ] ) , ( [ [string] ] , { [string] : { [string] : { [string] : [ [string] ] } } , [string] : { [string] : { [string] : [ [string] ] } } } , [ [string] ] ) , ] ) def test_filter_schedule_if ( run_jobs , tasks , expected ) : [EOL] with mock . patch ( [string] , return_value = run_jobs ) as get_run_jobs : [EOL] assert ( decision . filter_schedule_if ( { } , tasks ) == { name : tasks [ name ] for name in expected } ) [EOL] get_run_jobs . call_count in ( [number] , [number] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , { [string] , [string] } ) , ( [string] , { [string] , [string] } ) , ( [string] , { [string] , [string] } ) , ( [string] , { [string] } ) , ( [string] , set ( ) ) , ( [string] , { [string] } ) ] ) @ pytest . mark . parametrize ( [string] , [ { [string] : [ { [string] : [string] } ] } , { [string] : { [string] : [string] } } ] ) def test_extra_jobs_pr ( msg , expected , event ) : [EOL] def sub ( obj ) : [EOL] [docstring] [EOL] if isinstance ( obj , dict ) : [EOL] return { key : sub ( value ) for ( key , value ) in iteritems ( obj ) } [EOL] elif isinstance ( obj , list ) : [EOL] return [ sub ( value ) for value in obj ] [EOL] elif obj == [string] : [EOL] return msg [EOL] return obj [EOL] [EOL] event = sub ( event ) [EOL] [EOL] assert decision . get_extra_jobs ( event ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import requests [EOL] import typing [EOL] import json [EOL] import os [EOL] from io import open [EOL] [EOL] import jsone [EOL] import mock [EOL] import pytest [EOL] import requests [EOL] import yaml [EOL] from jsonschema import validate [EOL] [EOL] from tools . ci . tc import decision [EOL] [EOL] here = os . path . dirname ( __file__ ) [EOL] root = os . path . abspath ( os . path . join ( here , [string] , [string] , [string] , [string] ) ) [EOL] [EOL] [EOL] def data_path ( filename ) : [EOL] return os . path . join ( here , [string] , [string] , filename ) [EOL] [EOL] [EOL] def test_verify_taskcluster_yml ( ) : [EOL] [docstring] [EOL] with open ( os . path . join ( root , [string] ) , encoding = [string] ) as f : [EOL] template = yaml . safe_load ( f ) [EOL] [EOL] events = [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] [EOL] [EOL] for filename , tasks_for , title in events : [EOL] with open ( data_path ( filename ) , encoding = [string] ) as f : [EOL] event = json . load ( f ) [EOL] [EOL] context = { [string] : tasks_for , [string] : event , [string] : lambda x : x } [EOL] [EOL] jsone . render ( template , context ) [EOL] [EOL] [EOL] def test_verify_payload ( ) : [EOL] [docstring] [EOL] from tools . ci . tc . decision import decide [EOL] [EOL] r = requests . get ( [string] ) [EOL] r . raise_for_status ( ) [EOL] create_task_schema = r . json ( ) [EOL] [EOL] r = requests . get ( [string] ) [EOL] r . raise_for_status ( ) [EOL] payload_schema = r . json ( ) [EOL] [EOL] jobs = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] for filename in [ [string] , [string] ] : [EOL] with open ( data_path ( filename ) , encoding = [string] ) as f : [EOL] event = json . load ( f ) [EOL] [EOL] with mock . patch ( [string] , return_value = ( None , event [ [string] ] , None ) ) : [EOL] with mock . patch ( [string] , return_value = set ( jobs ) ) : [EOL] task_id_map = decide ( event ) [EOL] for name , ( task_id , task_data ) in task_id_map . items ( ) : [EOL] try : [EOL] validate ( instance = task_data , schema = create_task_schema ) [EOL] validate ( instance = task_data [ [string] ] , schema = payload_schema ) [EOL] except Exception as e : [EOL] print ( [string] % ( name , json . dumps ( task_data , indent = [number] ) ) ) [EOL] raise e [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , False , None , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , ( [string] , True , { [string] , [string] , [string] } , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , ( [string] , True , { [string] , [string] } , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , ( [string] , False , None , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) ] ) def test_schedule_tasks ( event_path , is_pr , files_changed , expected ) : [EOL] with mock . patch ( [string] , return_value = ( None , None , None ) ) : [EOL] with mock . patch ( [string] , return_value = files_changed ) : [EOL] with open ( data_path ( event_path ) , encoding = [string] ) as event_file : [EOL] event = json . load ( event_file ) [EOL] scheduled = decision . decide ( event ) [EOL] assert list ( scheduled . keys ( ) ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import typing [EOL] from tools . ci import jobs [EOL] [EOL] all_jobs = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] default_jobs = { [string] , [string] } [EOL] [EOL] [EOL] def test_all ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] , all = True ) == all_jobs [EOL] [EOL] [EOL] def test_default ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] ) == default_jobs [EOL] [EOL] [EOL] def test_testharness ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] ) == default_jobs | { [string] , [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] [EOL] [EOL] def test_stability ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] , [string] ] , includes = [ [string] ] ) == { [string] } [EOL] [EOL] def test_affected_tests ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] , [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] [EOL] def test_tools_unittest ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] [EOL] [EOL] def test_wptrunner_unittest ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] [EOL] [EOL] def test_build_css ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == set ( ) [EOL] [EOL] [EOL] def test_update_built ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] [EOL] [EOL] def test_wpt_integration ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] [EOL] [EOL] def test_wpt_infrastructure ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL] [EOL] def test_wdspec_support ( ) : [EOL] assert jobs . get_jobs ( [ [string] ] , includes = [ [string] ] ) == { [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] import pytest [EOL] [EOL] from wptserve . pipes import ReplacementTokenizer [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ [string] , [ ( [string] , [string] ) ] ] , [ [string] , [ ( [string] , [string] ) , ( [string] , [ ] ) ] ] , [ [string] , [ ( [string] , [string] ) , ( [string] , [ [string] , [string] ] ) ] ] , [ [string] , [ ( [string] , [string] ) , ( [string] , [string] ) ] ] , [ [string] , [ ( [string] , [string] ) ] ] , [ [string] , [ ( [string] , [string] ) , ( [string] , [number] ) ] ] , [ [string] , [ ( [string] , [string] ) , ( [string] , [string] ) ] ] , [ [string] , [ ( [string] , [string] ) ] ] , [ [string] , [ ( [string] , [string] ) , ( [string] , [string] ) ] ] , [ [string] , [ ( [string] , [string] ) , ( [string] , [string] ) ] ] , [ [string] , [ ( [string] , [string] ) ] ] , [ [string] , [ ( [string] , [string] ) ] ] , ] ) def test_tokenizer ( content , expected ) : [EOL] tokenizer = ReplacementTokenizer ( ) [EOL] tokens = tokenizer . tokenize ( content ) [EOL] assert expected == tokens [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ [string] , [ ] ] , [ [string] , [ ( [string] , [string] ) ] ] , ] ) def test_tokenizer_errors ( content , expected ) : [EOL] tokenizer = ReplacementTokenizer ( ) [EOL] tokens = tokenizer . tokenize ( content ) [EOL] assert expected == tokens [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import logging [EOL] import typing [EOL] import json [EOL] import logging [EOL] import pickle [EOL] [EOL] from distutils . spawn import find_executable [EOL] from logging import handlers [EOL] [EOL] import pytest [EOL] [EOL] config = pytest . importorskip ( [string] ) [EOL] [EOL] [EOL] def test_renamed_are_renamed ( ) : [EOL] assert len ( set ( config . _renamed_props . keys ( ) ) & set ( config . ConfigBuilder . _default . keys ( ) ) ) == [number] [EOL] [EOL] [EOL] def test_renamed_exist ( ) : [EOL] assert set ( config . _renamed_props . values ( ) ) . issubset ( set ( config . ConfigBuilder . _default . keys ( ) ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( { [string] : [number] } , { [string] : [number] } , { [string] : [number] } ) , ( { [string] : [number] } , { [string] : [number] } , { [string] : [number] } ) , ( { [string] : { [string] : [number] } } , { [string] : { } } , { [string] : { [string] : [number] } } ) , ( { [string] : { [string] : [number] } } , { [string] : { [string] : [number] } } , { [string] : { [string] : [number] } } ) , ( { [string] : { [string] : [number] } } , { [string] : { [string] : [number] , [string] : [number] } } , { [string] : { [string] : [number] } } ) , pytest . param ( { [string] : { [string] : [number] } } , { [string] : [number] } , { [string] : [number] } , marks = pytest . mark . xfail ) , pytest . param ( { [string] : [number] } , { [string] : { [string] : [number] } } , { [string] : [number] } , marks = pytest . mark . xfail ) , ] ) def test_merge_dict ( base , override , expected ) : [EOL] assert expected == config . _merge_dict ( base , override ) [EOL] [EOL] [EOL] def test_logger_created ( ) : [EOL] with config . ConfigBuilder ( ) as c : [EOL] assert c . logger is not None [EOL] [EOL] [EOL] def test_logger_preserved ( ) : [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] with config . ConfigBuilder ( logger = logger ) as c : [EOL] assert c . logger is logger [EOL] [EOL] [EOL] def test_as_dict ( ) : [EOL] with config . ConfigBuilder ( ) as c : [EOL] assert c . as_dict ( ) is not None [EOL] [EOL] [EOL] def test_as_dict_is_json ( ) : [EOL] with config . ConfigBuilder ( ) as c : [EOL] assert json . dumps ( c . as_dict ( ) ) is not None [EOL] [EOL] [EOL] def test_init_basic_prop ( ) : [EOL] with config . ConfigBuilder ( browser_host = [string] ) as c : [EOL] assert c . browser_host == [string] [EOL] [EOL] [EOL] def test_init_prefixed_prop ( ) : [EOL] with config . ConfigBuilder ( doc_root = [string] ) as c : [EOL] assert c . doc_root == [string] [EOL] [EOL] [EOL] def test_init_renamed_host ( ) : [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] handler = handlers . BufferingHandler ( [number] ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] with config . ConfigBuilder ( logger = logger , host = [string] ) as c : [EOL] assert c . logger is logger [EOL] assert len ( handler . buffer ) == [number] [EOL] assert [string] in handler . buffer [ [number] ] . getMessage ( ) [comment] [EOL] assert not hasattr ( c , [string] ) [EOL] assert c . browser_host == [string] [EOL] [EOL] [EOL] def test_init_bogus ( ) : [EOL] with pytest . raises ( TypeError ) as e : [EOL] config . ConfigBuilder ( foo = [number] , bar = [number] ) [EOL] message = e . value . args [ [number] ] [EOL] assert [string] in message [EOL] assert [string] in message [EOL] [EOL] [EOL] def test_getitem ( ) : [EOL] with config . ConfigBuilder ( browser_host = [string] ) as c : [EOL] assert c [ [string] ] == [string] [EOL] [EOL] [EOL] def test_no_setitem ( ) : [EOL] with config . ConfigBuilder ( ) as c : [EOL] with pytest . raises ( TypeError ) : [EOL] c [ [string] ] = [string] [EOL] [EOL] [EOL] def test_iter ( ) : [EOL] with config . ConfigBuilder ( ) as c : [EOL] s = set ( iter ( c ) ) [EOL] assert [string] in s [EOL] assert [string] not in s [EOL] assert [string] not in s [EOL] assert [string] not in s [EOL] [EOL] [EOL] def test_assignment ( ) : [EOL] cb = config . ConfigBuilder ( ) [EOL] cb . browser_host = [string] [EOL] with cb as c : [EOL] assert c . browser_host == [string] [EOL] [EOL] [EOL] def test_update_basic ( ) : [EOL] cb = config . ConfigBuilder ( ) [EOL] cb . update ( { [string] : [string] } ) [EOL] with cb as c : [EOL] assert c . browser_host == [string] [EOL] [EOL] [EOL] def test_update_prefixed ( ) : [EOL] cb = config . ConfigBuilder ( ) [EOL] cb . update ( { [string] : [string] } ) [EOL] with cb as c : [EOL] assert c . doc_root == [string] [EOL] [EOL] [EOL] def test_update_renamed_host ( ) : [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] handler = handlers . BufferingHandler ( [number] ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] cb = config . ConfigBuilder ( logger = logger ) [EOL] assert cb . logger is logger [EOL] assert len ( handler . buffer ) == [number] [EOL] [EOL] cb . update ( { [string] : [string] } ) [EOL] [EOL] with cb as c : [EOL] assert len ( handler . buffer ) == [number] [EOL] assert [string] in handler . buffer [ [number] ] . getMessage ( ) [comment] [EOL] assert not hasattr ( c , [string] ) [EOL] assert c . browser_host == [string] [EOL] [EOL] [EOL] def test_update_bogus ( ) : [EOL] cb = config . ConfigBuilder ( ) [EOL] with pytest . raises ( KeyError ) : [EOL] cb . update ( { [string] : [number] } ) [EOL] [EOL] [EOL] def test_ports_auto ( ) : [EOL] with config . ConfigBuilder ( ports = { [string] : [ [string] ] } , ssl = { [string] : [string] } ) as c : [EOL] ports = c . ports [EOL] assert set ( ports . keys ( ) ) == { [string] } [EOL] assert len ( ports [ [string] ] ) == [number] [EOL] assert isinstance ( ports [ [string] ] [ [number] ] , int ) [EOL] [EOL] [EOL] def test_ports_auto_mutate ( ) : [EOL] cb = config . ConfigBuilder ( ports = { [string] : [ [number] ] } , ssl = { [string] : [string] } ) [EOL] cb . ports = { [string] : [ [string] ] } [EOL] with cb as c : [EOL] new_ports = c . ports [EOL] assert set ( new_ports . keys ( ) ) == { [string] } [EOL] assert len ( new_ports [ [string] ] ) == [number] [EOL] assert isinstance ( new_ports [ [string] ] [ [number] ] , int ) [EOL] [EOL] [EOL] def test_ports_explicit ( ) : [EOL] with config . ConfigBuilder ( ports = { [string] : [ [number] ] } , ssl = { [string] : [string] } ) as c : [EOL] ports = c . ports [EOL] assert set ( ports . keys ( ) ) == { [string] } [EOL] assert ports [ [string] ] == [ [number] ] [EOL] [EOL] [EOL] def test_ports_no_ssl ( ) : [EOL] with config . ConfigBuilder ( ports = { [string] : [ [number] ] , [string] : [ [number] ] , [string] : [ [number] ] , [string] : [ [number] ] } , ssl = { [string] : [string] } ) as c : [EOL] ports = c . ports [EOL] assert set ( ports . keys ( ) ) == { [string] , [string] } [EOL] assert ports [ [string] ] == [ [number] ] [EOL] assert ports [ [string] ] == [ [number] ] [EOL] [EOL] [EOL] @ pytest . mark . skipif ( find_executable ( [string] ) is None , reason = [string] ) def test_ports_openssl ( ) : [EOL] with config . ConfigBuilder ( ports = { [string] : [ [number] ] , [string] : [ [number] ] , [string] : [ [number] ] , [string] : [ [number] ] } , ssl = { [string] : [string] } ) as c : [EOL] ports = c . ports [EOL] assert set ( ports . keys ( ) ) == { [string] , [string] , [string] , [string] } [EOL] assert ports [ [string] ] == [ [number] ] [EOL] assert ports [ [string] ] == [ [number] ] [EOL] assert ports [ [string] ] == [ [number] ] [EOL] assert ports [ [string] ] == [ [number] ] [EOL] [EOL] [EOL] def test_init_doc_root ( ) : [EOL] with config . ConfigBuilder ( doc_root = [string] ) as c : [EOL] assert c . doc_root == [string] [EOL] [EOL] [EOL] def test_set_doc_root ( ) : [EOL] cb = config . ConfigBuilder ( ) [EOL] cb . doc_root = [string] [EOL] with cb as c : [EOL] assert c . doc_root == [string] [EOL] [EOL] [EOL] def test_server_host_from_browser_host ( ) : [EOL] with config . ConfigBuilder ( browser_host = [string] ) as c : [EOL] assert c . server_host == [string] [EOL] [EOL] [EOL] def test_init_server_host ( ) : [EOL] with config . ConfigBuilder ( server_host = [string] ) as c : [EOL] assert c . browser_host == [string] [comment] [EOL] assert c . server_host == [string] [EOL] [EOL] [EOL] def test_set_server_host ( ) : [EOL] cb = config . ConfigBuilder ( ) [EOL] cb . server_host = [string] [EOL] with cb as c : [EOL] assert c . browser_host == [string] [comment] [EOL] assert c . server_host == [string] [EOL] [EOL] [EOL] def test_domains ( ) : [EOL] with config . ConfigBuilder ( browser_host = [string] , alternate_hosts = { [string] : [string] } , subdomains = { [string] , [string] } , not_subdomains = { [string] , [string] } ) as c : [EOL] assert c . domains == { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , } [EOL] [EOL] [EOL] def test_not_domains ( ) : [EOL] with config . ConfigBuilder ( browser_host = [string] , alternate_hosts = { [string] : [string] } , subdomains = { [string] , [string] } , not_subdomains = { [string] , [string] } ) as c : [EOL] not_domains = c . not_domains [EOL] assert not_domains == { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , } [EOL] [EOL] [EOL] def test_domains_not_domains_intersection ( ) : [EOL] with config . ConfigBuilder ( browser_host = [string] , alternate_hosts = { [string] : [string] } , subdomains = { [string] , [string] } , not_subdomains = { [string] , [string] } ) as c : [EOL] domains = c . domains [EOL] not_domains = c . not_domains [EOL] assert len ( set ( domains . keys ( ) ) ^ set ( not_domains . keys ( ) ) ) == [number] [EOL] for host in domains . keys ( ) : [EOL] host_domains = domains [ host ] [EOL] host_not_domains = not_domains [ host ] [EOL] assert len ( set ( host_domains . keys ( ) ) & set ( host_not_domains . keys ( ) ) ) == [number] [EOL] assert len ( set ( host_domains . values ( ) ) & set ( host_not_domains . values ( ) ) ) == [number] [EOL] [EOL] [EOL] def test_all_domains ( ) : [EOL] with config . ConfigBuilder ( browser_host = [string] , alternate_hosts = { [string] : [string] } , subdomains = { [string] , [string] } , not_subdomains = { [string] , [string] } ) as c : [EOL] all_domains = c . all_domains [EOL] assert all_domains == { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , } [EOL] [EOL] [EOL] def test_domains_set ( ) : [EOL] with config . ConfigBuilder ( browser_host = [string] , alternate_hosts = { [string] : [string] } , subdomains = { [string] , [string] } , not_subdomains = { [string] , [string] } ) as c : [EOL] domains_set = c . domains_set [EOL] assert domains_set == { [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] [EOL] def test_not_domains_set ( ) : [EOL] with config . ConfigBuilder ( browser_host = [string] , alternate_hosts = { [string] : [string] } , subdomains = { [string] , [string] } , not_subdomains = { [string] , [string] } ) as c : [EOL] not_domains_set = c . not_domains_set [EOL] assert not_domains_set == { [string] , [string] , [string] , [string] , } [EOL] [EOL] [EOL] def test_all_domains_set ( ) : [EOL] with config . ConfigBuilder ( browser_host = [string] , alternate_hosts = { [string] : [string] } , subdomains = { [string] , [string] } , not_subdomains = { [string] , [string] } ) as c : [EOL] all_domains_set = c . all_domains_set [EOL] assert all_domains_set == { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] [EOL] def test_ssl_env_none ( ) : [EOL] with config . ConfigBuilder ( ssl = { [string] : [string] } ) as c : [EOL] assert c . ssl_config is None [EOL] [EOL] [EOL] def test_ssl_env_openssl ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] def test_ssl_env_bogus ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] with config . ConfigBuilder ( ssl = { [string] : [string] } ) : [EOL] pass [EOL] [EOL] [EOL] def test_pickle ( ) : [EOL] [comment] [EOL] with config . ConfigBuilder ( ) as c : [EOL] pickle . dumps ( c ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Literal , Any , Dict [EOL] import tests [EOL] import typing_extensions [EOL] import typing [EOL] import unittest [EOL] [EOL] import pytest [EOL] from six . moves . urllib . error import HTTPError [EOL] [EOL] wptserve = pytest . importorskip ( [string] ) [EOL] from . base import TestUsingServer , TestUsingH2Server [EOL] [EOL] [EOL] class TestFileHandler ( TestUsingServer ) : [EOL] def test_not_handled ( self ) : [EOL] with self . assertRaises ( HTTPError ) as cm : [EOL] self . request ( [string] ) [EOL] [EOL] self . assertEqual ( cm . exception . code , [number] ) [EOL] [EOL] [EOL] class TestRewriter ( TestUsingServer ) : [EOL] def test_rewrite ( self ) : [EOL] @ wptserve . handlers . handler def handler ( request , response ) : [EOL] return request . request_path [EOL] [EOL] route = ( [string] , [string] , handler ) [EOL] self . server . rewriter . register ( [string] , [string] , route [ [number] ] ) [EOL] self . server . router . register ( * route ) [EOL] resp = self . request ( [string] ) [EOL] self . assertEqual ( [number] , resp . getcode ( ) ) [EOL] self . assertEqual ( [string] , resp . read ( ) ) [EOL] [EOL] [EOL] class TestRequestHandler ( TestUsingServer ) : [EOL] def test_exception ( self ) : [EOL] @ wptserve . handlers . handler def handler ( request , response ) : [EOL] raise Exception [EOL] [EOL] route = ( [string] , [string] , handler ) [EOL] self . server . router . register ( * route ) [EOL] with self . assertRaises ( HTTPError ) as cm : [EOL] self . request ( [string] ) [EOL] [EOL] self . assertEqual ( cm . exception . code , [number] ) [EOL] [EOL] def test_many_headers ( self ) : [EOL] headers = { [string] % i : str ( i ) for i in range ( [number] ) } [EOL] [EOL] @ wptserve . handlers . handler def handler ( request , response ) : [EOL] [comment] [EOL] assert len ( request . headers ) > len ( headers ) [EOL] for k , v in headers . items ( ) : [EOL] assert request . headers . get ( k ) == wptserve . utils . isomorphic_encode ( v ) [EOL] return [string] [EOL] [EOL] route = ( [string] , [string] , handler ) [EOL] self . server . router . register ( * route ) [EOL] resp = self . request ( [string] , headers = headers ) [EOL] self . assertEqual ( [number] , resp . getcode ( ) ) [EOL] [EOL] [EOL] class TestFileHandlerH2 ( TestUsingH2Server ) : [EOL] def test_not_handled ( self ) : [EOL] self . conn . request ( [string] , [string] ) [EOL] resp = self . conn . get_response ( ) [EOL] [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] class TestRewriterH2 ( TestUsingH2Server ) : [EOL] def test_rewrite ( self ) : [EOL] @ wptserve . handlers . handler def handler ( request , response ) : [EOL] return request . request_path [EOL] [EOL] route = ( [string] , [string] , handler ) [EOL] self . server . rewriter . register ( [string] , [string] , route [ [number] ] ) [EOL] self . server . router . register ( * route ) [EOL] self . conn . request ( [string] , [string] ) [EOL] resp = self . conn . get_response ( ) [EOL] assert resp . status == [number] [EOL] assert resp . read ( ) == [string] [EOL] [EOL] [EOL] class TestRequestHandlerH2 ( TestUsingH2Server ) : [EOL] def test_exception ( self ) : [EOL] @ wptserve . handlers . handler def handler ( request , response ) : [EOL] raise Exception [EOL] [EOL] route = ( [string] , [string] , handler ) [EOL] self . server . router . register ( * route ) [EOL] self . conn . request ( [string] , [string] ) [EOL] resp = self . conn . get_response ( ) [EOL] [EOL] assert resp . status == [number] [EOL] [EOL] def test_frame_handler_exception ( self ) : [EOL] class handler_cls : [EOL] def frame_handler ( self , request ) : [EOL] raise Exception [EOL] [EOL] route = ( [string] , [string] , handler_cls ( ) ) [EOL] self . server . router . register ( * route ) [EOL] self . conn . request ( [string] , [string] ) [EOL] resp = self . conn . get_response ( ) [EOL] [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,tests.wpt.web-platform-tests.tools.wptserve.tests.functional.test_server.TestRequestHandlerH2.test_frame_handler_exception.handler_cls]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,tests.wpt.web-platform-tests.tools.wptserve.tests.functional.test_server.TestRequestHandlerH2.test_frame_handler_exception.handler_cls]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Literal , Any , Dict [EOL] import typing_extensions [EOL] import typing [EOL] import unittest [EOL] [EOL] import pytest [EOL] [EOL] wptserve = pytest . importorskip ( [string] ) [EOL] from . base import TestUsingServer [EOL] [EOL] [EOL] class TestResponseSetCookie ( TestUsingServer ) : [EOL] def test_name_value ( self ) : [EOL] @ wptserve . handlers . handler def handler ( request , response ) : [EOL] response . set_cookie ( [string] , [string] ) [EOL] return [string] [EOL] [EOL] route = ( [string] , [string] , handler ) [EOL] self . server . router . register ( * route ) [EOL] resp = self . request ( route [ [number] ] ) [EOL] [EOL] self . assertEqual ( resp . info ( ) [ [string] ] , [string] ) [EOL] [EOL] def test_unset ( self ) : [EOL] @ wptserve . handlers . handler def handler ( request , response ) : [EOL] response . set_cookie ( [string] , [string] ) [EOL] response . unset_cookie ( [string] ) [EOL] return [string] [EOL] [EOL] route = ( [string] , [string] , handler ) [EOL] self . server . router . register ( * route ) [EOL] resp = self . request ( route [ [number] ] ) [EOL] [EOL] self . assertTrue ( [string] not in resp . info ( ) ) [EOL] [EOL] def test_delete ( self ) : [EOL] @ wptserve . handlers . handler def handler ( request , response ) : [EOL] response . delete_cookie ( [string] ) [EOL] return [string] [EOL] [EOL] route = ( [string] , [string] , handler ) [EOL] self . server . router . register ( * route ) [EOL] resp = self . request ( route [ [number] ] ) [EOL] [EOL] parts = dict ( item . split ( [string] ) for item in resp . info ( ) [ [string] ] . split ( [string] ) if item ) [EOL] [EOL] self . assertEqual ( parts [ [string] ] , [string] ) [EOL] self . assertEqual ( parts [ [string] ] , [string] ) [EOL] [comment] [EOL] [EOL] [EOL] class TestRequestCookies ( TestUsingServer ) : [EOL] def test_set_cookie ( self ) : [EOL] @ wptserve . handlers . handler def handler ( request , response ) : [EOL] return request . cookies [ [string] ] . value [EOL] [EOL] route = ( [string] , [string] , handler ) [EOL] self . server . router . register ( * route ) [EOL] resp = self . request ( route [ [number] ] , headers = { [string] : [string] } ) [EOL] self . assertEqual ( resp . read ( ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] def mian ( request , response ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return [ ( [string] , [string] ) , ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def handle_headers ( frame , request , response ) : [EOL] response . status = [number] [EOL] response . headers . update ( [ ( [string] , [string] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] return ( [number] , [string] ) , [ ( [string] , [string] ) , ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def handle_data ( frame , request , response ) : [EOL] response . content = frame . data [ : : - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def main ( request , response ) : [EOL] response . headers . set ( [string] , [string] ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def handle_headers ( frame , request , response ) : [EOL] response . status = [number] [EOL] response . headers . update ( [ ( [string] , [string] ) ] ) [EOL] [EOL] def handle_data ( frame , request , response ) : [EOL] response . content = frame . data [ : : - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import example_module [EOL] [EOL] [EOL] def main ( request , response ) : [EOL] return example_module . module_function ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def module_function ( ) : [EOL] return [ ( [string] , [string] ) ] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
class Client ( object ) : [EOL] def __init__ ( self , session_token ) : [EOL] self . session_token = session_token [EOL] [EOL] def send_message ( self , message ) : [EOL] raise Exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from __future__ import absolute_import [EOL] from __future__ import unicode_literals [EOL] from . . testing . test_loader import MANUAL , AUTOMATIC [EOL] [EOL] PAUSED = [string] [EOL] RUNNING = [string] [EOL] COMPLETED = [string] [EOL] ABORTED = [string] [EOL] PENDING = [string] [EOL] UNKNOWN = [string] [EOL] [EOL] [EOL] class Session ( object ) : [EOL] def __init__ ( self , token = None , types = None , user_agent = None , labels = None , tests = None , pending_tests = None , running_tests = None , timeouts = None , status = None , test_state = None , last_completed_test = None , recent_completed_count = None , date_started = None , date_finished = None , is_public = None , reference_tokens = None , browser = None , webhook_urls = None , expiration_date = None , malfunctioning_tests = None ) : [EOL] if token is None : [EOL] token = [string] [EOL] self . token = token [EOL] if types is None : [EOL] types = [ AUTOMATIC , MANUAL ] [EOL] self . types = types [EOL] if user_agent is None : [EOL] user_agent = [string] [EOL] self . user_agent = user_agent [EOL] if labels is None : [EOL] labels = [ ] [EOL] self . labels = labels [EOL] if tests is None : [EOL] tests = { } [EOL] self . tests = tests [EOL] if pending_tests is None : [EOL] pending_tests = { } [EOL] self . pending_tests = pending_tests [EOL] if running_tests is None : [EOL] running_tests = { } [EOL] self . running_tests = running_tests [EOL] if timeouts is None : [EOL] timeouts = { } [EOL] self . timeouts = timeouts [EOL] if status is None : [EOL] status = UNKNOWN [EOL] self . status = status [EOL] if test_state is None : [EOL] test_state = { } [EOL] self . test_state = test_state [EOL] self . last_completed_test = last_completed_test [EOL] if recent_completed_count is None : [EOL] recent_completed_count = [number] [EOL] self . recent_completed_count = recent_completed_count [EOL] self . date_started = date_started [EOL] self . date_finished = date_finished [EOL] if is_public is None : [EOL] is_public = False [EOL] self . is_public = is_public [EOL] if reference_tokens is None : [EOL] reference_tokens = [ ] [EOL] self . reference_tokens = reference_tokens [EOL] self . browser = browser [EOL] if webhook_urls is None : [EOL] webhook_urls = [ ] [EOL] self . webhook_urls = webhook_urls [EOL] self . expiration_date = expiration_date [EOL] if malfunctioning_tests is None : [EOL] malfunctioning_tests = [ ] [EOL] self . malfunctioning_tests = malfunctioning_tests [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class NotFoundException ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
class InvalidDataException ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
	0
class DuplicateException ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
class PermissionDeniedException ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any , Dict [EOL] import tests [EOL] import typing [EOL] from __future__ import division [EOL] from __future__ import absolute_import [EOL] from __future__ import unicode_literals [EOL] import uuid [EOL] import time [EOL] import os [EOL] import json [EOL] [EOL] from threading import Timer [EOL] [EOL] from . test_loader import AUTOMATIC , MANUAL [EOL] from . . data . session import Session , PENDING , PAUSED , RUNNING , ABORTED , COMPLETED [EOL] from . . utils . user_agent_parser import parse_user_agent [EOL] from . event_dispatcher import STATUS_EVENT , RESUME_EVENT [EOL] from . . data . exceptions . not_found_exception import NotFoundException [EOL] from . . data . exceptions . invalid_data_exception import InvalidDataException [EOL] from . . utils . deserializer import deserialize_session [EOL] [EOL] DEFAULT_TEST_TYPES = [ AUTOMATIC , MANUAL ] [EOL] DEFAULT_TEST_PATHS = [ [string] ] [EOL] DEFAULT_TEST_AUTOMATIC_TIMEOUT = [number] [EOL] DEFAULT_TEST_MANUAL_TIMEOUT = [number] [EOL] [EOL] [EOL] class SessionsManager ( object ) : [EOL] def initialize ( self , test_loader , event_dispatcher , tests_manager , results_directory , results_manager ) : [EOL] self . _test_loader = test_loader [EOL] self . _sessions = { } [EOL] self . _expiration_timeout = None [EOL] self . _event_dispatcher = event_dispatcher [EOL] self . _tests_manager = tests_manager [EOL] self . _results_directory = results_directory [EOL] self . _results_manager = results_manager [EOL] [EOL] def create_session ( self , tests = None , types = None , timeouts = None , reference_tokens = None , webhook_urls = None , user_agent = None , labels = None , expiration_date = None ) : [EOL] if tests is None : [EOL] tests = { } [EOL] if timeouts is None : [EOL] timeouts = { } [EOL] if reference_tokens is None : [EOL] reference_tokens = [ ] [EOL] if webhook_urls is None : [EOL] webhook_urls = [ ] [EOL] if user_agent is None : [EOL] user_agent = [string] [EOL] if labels is None : [EOL] labels = [ ] [EOL] [EOL] if [string] not in tests : [EOL] tests [ [string] ] = DEFAULT_TEST_PATHS [EOL] if [string] not in tests : [EOL] tests [ [string] ] = [ ] [EOL] if [string] not in timeouts : [EOL] timeouts [ [string] ] = DEFAULT_TEST_AUTOMATIC_TIMEOUT [EOL] if [string] not in timeouts : [EOL] timeouts [ [string] ] = DEFAULT_TEST_MANUAL_TIMEOUT [EOL] if types is None : [EOL] types = DEFAULT_TEST_TYPES [EOL] [EOL] for type in types : [EOL] if type != [string] and type != [string] : [EOL] raise InvalidDataException ( [string] . format ( type ) ) [EOL] [EOL] token = str ( uuid . uuid1 ( ) ) [EOL] pending_tests = self . _test_loader . get_tests ( types , include_list = tests [ [string] ] , exclude_list = tests [ [string] ] , reference_tokens = reference_tokens ) [EOL] [EOL] browser = parse_user_agent ( user_agent ) [EOL] [EOL] test_files_count = self . _tests_manager . calculate_test_files_count ( pending_tests ) [EOL] [EOL] test_state = { } [EOL] for api in test_files_count : [EOL] test_state [ api ] = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : test_files_count [ api ] , [string] : [number] } [EOL] [EOL] session = Session ( token = token , tests = tests , user_agent = user_agent , browser = browser , types = types , timeouts = timeouts , pending_tests = pending_tests , running_tests = { } , test_state = test_state , status = PENDING , reference_tokens = reference_tokens , webhook_urls = webhook_urls , labels = labels , expiration_date = expiration_date ) [EOL] [EOL] self . _push_to_cache ( session ) [EOL] if expiration_date is not None : [EOL] self . _set_expiration_timer ( ) [EOL] [EOL] return session [EOL] [EOL] def read_session ( self , token ) : [EOL] if token is None : [EOL] return None [EOL] session = self . _read_from_cache ( token ) [EOL] if session is None or session . test_state is None : [EOL] session = self . load_session ( token ) [EOL] if session is not None : [EOL] self . _push_to_cache ( session ) [EOL] return session [EOL] [EOL] def read_session_status ( self , token ) : [EOL] if token is None : [EOL] return None [EOL] session = self . _read_from_cache ( token ) [EOL] if session is None : [EOL] session = self . load_session_info ( token ) [EOL] if session is None : [EOL] return None [EOL] if session . test_state is None : [EOL] session = self . load_session ( token ) [EOL] if session is not None : [EOL] self . _push_to_cache ( session ) [EOL] return session [EOL] [EOL] def read_public_sessions ( self ) : [EOL] self . load_all_sessions_info ( ) [EOL] session_tokens = [ ] [EOL] for token in self . _sessions : [EOL] session = self . _sessions [ token ] [EOL] if not session . is_public : [EOL] continue [EOL] session_tokens . append ( token ) [EOL] [EOL] return session_tokens [EOL] [EOL] def update_session ( self , session ) : [EOL] self . _push_to_cache ( session ) [EOL] [EOL] def update_session_configuration ( self , token , tests , types , timeouts , reference_tokens , webhook_urls ) : [EOL] session = self . read_session ( token ) [EOL] if session is None : [EOL] raise NotFoundException ( [string] ) [EOL] if session . status != PENDING : [EOL] return [EOL] [EOL] if tests is not None : [EOL] if [string] not in tests : [EOL] tests [ [string] ] = session . tests [ [string] ] [EOL] if [string] not in tests : [EOL] tests [ [string] ] = session . tests [ [string] ] [EOL] if reference_tokens is None : [EOL] reference_tokens = session . reference_tokens [EOL] if types is None : [EOL] types = session . types [EOL] [EOL] pending_tests = self . _test_loader . get_tests ( include_list = tests [ [string] ] , exclude_list = tests [ [string] ] , reference_tokens = reference_tokens , types = types ) [EOL] session . pending_tests = pending_tests [EOL] session . tests = tests [EOL] test_files_count = self . _tests_manager . calculate_test_files_count ( pending_tests ) [EOL] test_state = { } [EOL] for api in test_files_count : [EOL] test_state [ api ] = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : test_files_count [ api ] , [string] : [number] , } [EOL] session . test_state = test_state [EOL] [EOL] if types is not None : [EOL] session . types = types [EOL] if timeouts is not None : [EOL] if AUTOMATIC not in timeouts : [EOL] timeouts [ AUTOMATIC ] = session . timeouts [ AUTOMATIC ] [EOL] if MANUAL not in timeouts : [EOL] timeouts [ MANUAL ] = session . timeouts [ MANUAL ] [EOL] session . timeouts = timeouts [EOL] if reference_tokens is not None : [EOL] session . reference_tokens = reference_tokens [EOL] if webhook_urls is not None : [EOL] session . webhook_urls = webhook_urls [EOL] [EOL] self . _push_to_cache ( session ) [EOL] return session [EOL] [EOL] def update_labels ( self , token , labels ) : [EOL] if token is None or labels is None : [EOL] return [EOL] session = self . read_session ( token ) [EOL] if session is None : [EOL] return [EOL] if session . is_public : [EOL] return [EOL] session . labels = labels [EOL] self . _push_to_cache ( session ) [EOL] [EOL] def delete_session ( self , token ) : [EOL] session = self . read_session ( token ) [EOL] if session is None : [EOL] return [EOL] if session . is_public is True : [EOL] return [EOL] del self . _sessions [ token ] [EOL] [EOL] def add_session ( self , session ) : [EOL] if session is None : [EOL] return [EOL] self . _push_to_cache ( session ) [EOL] [EOL] def load_all_sessions ( self ) : [EOL] if not os . path . isdir ( self . _results_directory ) : [EOL] return [EOL] tokens = os . listdir ( self . _results_directory ) [EOL] for token in tokens : [EOL] self . load_session ( token ) [EOL] [EOL] def load_all_sessions_info ( self ) : [EOL] if not os . path . isdir ( self . _results_directory ) : [EOL] return [EOL] tokens = os . listdir ( self . _results_directory ) [EOL] for token in tokens : [EOL] if token in self . _sessions : [EOL] continue [EOL] self . load_session_info ( token ) [EOL] [EOL] def load_session ( self , token ) : [EOL] session = self . load_session_info ( token ) [EOL] if session is None : [EOL] return None [EOL] [EOL] if session . test_state is None : [EOL] results = self . _results_manager . load_results ( token ) [EOL] test_state = self . _results_manager . parse_test_state ( results ) [EOL] session . test_state = test_state [EOL] self . _results_manager . create_info_file ( session ) [EOL] [EOL] self . _push_to_cache ( session ) [EOL] return session [EOL] [EOL] def load_session_info ( self , token ) : [EOL] result_directory = os . path . join ( self . _results_directory , token ) [EOL] if not os . path . isdir ( result_directory ) : [EOL] return None [EOL] info_file = os . path . join ( result_directory , [string] ) [EOL] if not os . path . isfile ( info_file ) : [EOL] return None [EOL] [EOL] info_data = None [EOL] with open ( info_file , [string] ) as file : [EOL] info_data = file . read ( ) [EOL] parsed_info_data = json . loads ( info_data ) [EOL] [EOL] session = deserialize_session ( parsed_info_data ) [EOL] self . _push_to_cache ( session ) [EOL] return session [EOL] [EOL] def _push_to_cache ( self , session ) : [EOL] self . _sessions [ session . token ] = session [EOL] [EOL] def _read_from_cache ( self , token ) : [EOL] if token not in self . _sessions : [EOL] return None [EOL] return self . _sessions [ token ] [EOL] [EOL] def _set_expiration_timer ( self ) : [EOL] expiring_sessions = self . _read_expiring_sessions ( ) [EOL] if len ( expiring_sessions ) == [number] : [EOL] return [EOL] [EOL] next_session = expiring_sessions [ [number] ] [EOL] for session in expiring_sessions : [EOL] if next_session . expiration_date > session . expiration_date : [EOL] next_session = session [EOL] [EOL] if self . _expiration_timeout is not None : [EOL] self . _expiration_timeout . cancel ( ) [EOL] [EOL] timeout = next_session . expiration_date / [number] - int ( time . time ( ) ) [EOL] if timeout < [number] : [EOL] timeout = [number] [EOL] [EOL] def handle_timeout ( self ) : [EOL] self . _delete_expired_sessions ( ) [EOL] self . _set_expiration_timer ( ) [EOL] [EOL] self . _expiration_timeout = Timer ( timeout , handle_timeout , [ self ] ) [EOL] self . _expiration_timeout . start ( ) [EOL] [EOL] def _delete_expired_sessions ( self ) : [EOL] expiring_sessions = self . _read_expiring_sessions ( ) [EOL] now = int ( time . time ( ) ) [EOL] [EOL] for session in expiring_sessions : [EOL] if session . expiration_date / [number] < now : [EOL] self . delete_session ( session . token ) [EOL] [EOL] def _read_expiring_sessions ( self ) : [EOL] expiring_sessions = [ ] [EOL] for token in self . _sessions : [EOL] session = self . _sessions [ token ] [EOL] if session . expiration_date is None : [EOL] continue [EOL] expiring_sessions . append ( session ) [EOL] return expiring_sessions [EOL] [EOL] def start_session ( self , token ) : [EOL] session = self . read_session ( token ) [EOL] [EOL] if session is None : [EOL] return [EOL] [EOL] if session . status != PENDING and session . status != PAUSED : [EOL] return [EOL] [EOL] if session . status == PENDING : [EOL] session . date_started = int ( time . time ( ) ) * [number] [EOL] session . expiration_date = None [EOL] [EOL] session . status = RUNNING [EOL] self . update_session ( session ) [EOL] [EOL] self . _event_dispatcher . dispatch_event ( token , event_type = STATUS_EVENT , data = session . status ) [EOL] [EOL] def pause_session ( self , token ) : [EOL] session = self . read_session ( token ) [EOL] if session . status != RUNNING : [EOL] return [EOL] session . status = PAUSED [EOL] self . update_session ( session ) [EOL] self . _event_dispatcher . dispatch_event ( token , event_type = STATUS_EVENT , data = session . status ) [EOL] self . _results_manager . persist_session ( session ) [EOL] [EOL] def stop_session ( self , token ) : [EOL] session = self . read_session ( token ) [EOL] if session . status == ABORTED or session . status == COMPLETED : [EOL] return [EOL] session . status = ABORTED [EOL] session . date_finished = time . time ( ) * [number] [EOL] self . update_session ( session ) [EOL] self . _event_dispatcher . dispatch_event ( token , event_type = STATUS_EVENT , data = session . status ) [EOL] [EOL] def resume_session ( self , token , resume_token ) : [EOL] session = self . read_session ( token ) [EOL] if session . status != PENDING : [EOL] return [EOL] self . _event_dispatcher . dispatch_event ( token , event_type = RESUME_EVENT , data = resume_token ) [EOL] self . delete_session ( token ) [EOL] [EOL] def complete_session ( self , token ) : [EOL] session = self . read_session ( token ) [EOL] if session . status == COMPLETED or session . status == ABORTED : [EOL] return [EOL] session . status = COMPLETED [EOL] session . date_finished = time . time ( ) * [number] [EOL] self . update_session ( session ) [EOL] self . _event_dispatcher . dispatch_event ( token , event_type = STATUS_EVENT , data = session . status ) [EOL] [EOL] def test_in_session ( self , test , session ) : [EOL] return self . _test_list_contains_test ( test , session . pending_tests ) or self . _test_list_contains_test ( test , session . running_tests ) [EOL] [EOL] def is_test_complete ( self , test , session ) : [EOL] return not self . _test_list_contains_test ( test , session . pending_tests ) \ [EOL] and not self . _test_list_contains_test ( test , session . running_tests ) [EOL] [EOL] def is_test_running ( self , test , session ) : [EOL] return self . _test_list_contains_test ( test , session . running_tests ) [EOL] [EOL] def _test_list_contains_test ( self , test , test_list ) : [EOL] for api in list ( test_list . keys ( ) ) : [EOL] if test in test_list [ api ] : [EOL] return True [EOL] return False [EOL] [EOL] def is_api_complete ( self , api , session ) : [EOL] return api not in session . pending_tests \ [EOL] and api not in session . running_tests [EOL] [EOL] def find_token ( self , fragment ) : [EOL] if len ( fragment ) < [number] : [EOL] return None [EOL] tokens = [ ] [EOL] for token in self . _sessions : [EOL] if token . startswith ( fragment ) : [EOL] tokens . append ( token ) [EOL] if len ( tokens ) != [number] : [EOL] return None [EOL] return tokens [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wave.data.session.Session$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wave.data.session.Session$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.wpt.web-platform-tests.tools.wave.data.session.Session$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0
from typing import Pattern , Dict , Any , List [EOL] import threading [EOL] import typing [EOL] from __future__ import division [EOL] from __future__ import absolute_import [EOL] from __future__ import unicode_literals [EOL] import re [EOL] from threading import Timer [EOL] [EOL] from . event_dispatcher import TEST_COMPLETED_EVENT [EOL] [EOL] from . . data . exceptions . not_found_exception import NotFoundException [EOL] from . . data . session import COMPLETED , ABORTED [EOL] [EOL] [EOL] class TestsManager ( object ) : [EOL] def initialize ( self , test_loader , sessions_manager , results_manager , event_dispatcher ) : [EOL] self . _test_loader = test_loader [EOL] self . _sessions_manager = sessions_manager [EOL] self . _results_manager = results_manager [EOL] self . _event_dispatcher = event_dispatcher [EOL] [EOL] self . _timeouts = [ ] [EOL] [EOL] def next_test ( self , session ) : [EOL] if session . status == COMPLETED or session . status == ABORTED : [EOL] return None [EOL] [EOL] pending_tests = session . pending_tests [EOL] running_tests = session . running_tests [EOL] token = session . token [EOL] [EOL] if pending_tests is None : [EOL] pending_tests = self . load_tests ( session ) [EOL] session . pending_tests = pending_tests [EOL] self . _sessions_manager . update_session ( session ) [EOL] [EOL] if running_tests is None : [EOL] running_tests = { } [EOL] [EOL] test = self . _get_next_test_from_list ( pending_tests ) [EOL] if test is None : [EOL] return None [EOL] [EOL] pending_tests = self . remove_test_from_list ( pending_tests , test ) [EOL] running_tests = self . add_test_to_list ( running_tests , test ) [EOL] [EOL] test_timeout = self . get_test_timeout ( test , session ) / [number] [EOL] [EOL] def handler ( self , token , test ) : [EOL] self . _on_test_timeout ( token , test ) [EOL] [EOL] timer = Timer ( test_timeout , handler , [ self , token , test ] ) [EOL] self . _timeouts . append ( { [string] : test , [string] : timer } ) [EOL] [EOL] session . pending_tests = pending_tests [EOL] session . running_tests = running_tests [EOL] self . _sessions_manager . update_session ( session ) [EOL] [EOL] timer . start ( ) [EOL] return test [EOL] [EOL] def read_last_completed_tests ( self , token , count ) : [EOL] results = self . _results_manager . read_results ( token ) [EOL] [EOL] results_tests = { } [EOL] for api in list ( results . keys ( ) ) : [EOL] results_tests [ api ] = [ ] [EOL] for result in results [ api ] : [EOL] results_tests [ api ] . append ( result [ [string] ] ) [EOL] [EOL] sorted_results_tests = self . _sort_tests_by_execution ( results_tests ) [EOL] sorted_results_tests . reverse ( ) [EOL] [EOL] tests = { [string] : [ ] , [string] : [ ] , [string] : [ ] } [EOL] [EOL] for test in sorted_results_tests : [EOL] api = None [EOL] for part in test . split ( [string] ) : [EOL] if part != [string] : [EOL] api = part [EOL] break [EOL] [EOL] result = None [EOL] for potential_result in results [ api ] : [EOL] if potential_result [ [string] ] == test : [EOL] result = potential_result [EOL] break [EOL] [EOL] if result [ [string] ] == [string] : [EOL] if len ( tests [ [string] ] ) < count : [EOL] tests [ [string] ] . append ( result [ [string] ] ) [EOL] elif result [ [string] ] == [string] : [EOL] if len ( tests [ [string] ] ) < count : [EOL] tests [ [string] ] . append ( result [ [string] ] ) [EOL] passes = True [EOL] for test in result [ [string] ] : [EOL] if test [ [string] ] != [string] : [EOL] passes = False [EOL] break [EOL] [EOL] if passes and len ( tests [ [string] ] ) < count : [EOL] tests [ [string] ] . append ( result [ [string] ] ) [EOL] if not passes and len ( tests [ [string] ] ) < count : [EOL] tests [ [string] ] . append ( result [ [string] ] ) [EOL] if len ( tests [ [string] ] ) == count and len ( tests [ [string] ] ) == count \ [EOL] and len ( tests [ [string] ] ) == count : [EOL] return tests [EOL] return tests [EOL] [EOL] def _sort_tests_by_execution ( self , tests ) : [EOL] sorted_tests = [ ] [EOL] [EOL] for api in list ( tests . keys ( ) ) : [EOL] for test in tests [ api ] : [EOL] sorted_tests . append ( test ) [EOL] [EOL] def compare ( tests_manager , test_a , test_b ) : [EOL] micro_test_list = { } [EOL] api_a = [string] [EOL] for part in test_a . split ( [string] ) : [EOL] if part != [string] : [EOL] api_a = part [EOL] break [EOL] api_b = [string] [EOL] for part in test_b . split ( [string] ) : [EOL] if part != [string] : [EOL] api_b = part [EOL] break [EOL] if api_a == api_b : [EOL] micro_test_list [ api_a ] = [ test_a , test_b ] [EOL] else : [EOL] micro_test_list [ api_a ] = [ test_a ] [EOL] micro_test_list [ api_b ] = [ test_b ] [EOL] next_test = tests_manager . _get_next_test_from_list ( micro_test_list ) [EOL] if next_test == test_a : [EOL] return - [number] [EOL] return [number] [EOL] [EOL] sorted_tests . sort ( cmp = lambda test_a , test_b : compare ( self , test_a , test_b ) ) [EOL] return sorted_tests [EOL] [EOL] def _get_next_test_from_list ( self , tests ) : [EOL] test = None [EOL] api = None [EOL] has_http = True [EOL] has_manual = True [EOL] current_api = [number] [EOL] current_test = [number] [EOL] [EOL] apis = list ( tests . keys ( ) ) [EOL] apis . sort ( key = lambda api : api . lower ( ) ) [EOL] [EOL] for api in apis : [EOL] tests [ api ] . sort ( key = lambda api : api . replace ( [string] , [string] ) . lower ( ) ) [EOL] [EOL] while test is None : [EOL] if len ( apis ) <= current_api : [EOL] return None [EOL] api = apis [ current_api ] [EOL] [EOL] if len ( tests [ api ] ) <= current_test : [EOL] current_api = current_api + [number] [EOL] current_test = [number] [EOL] [EOL] if current_api == len ( apis ) : [EOL] if has_http : [EOL] has_http = False [EOL] current_api = [number] [EOL] test = None [EOL] continue [EOL] [EOL] if has_manual : [EOL] has_manual = False [EOL] current_api = [number] [EOL] test = None [EOL] has_http = True [EOL] continue [EOL] [EOL] return None [EOL] [EOL] test = None [EOL] continue [EOL] test = tests [ api ] [ current_test ] [EOL] [EOL] if [string] in test and [string] not in test : [EOL] return test [EOL] [EOL] if [string] in test and [string] in test : [EOL] if not has_http : [EOL] return test [EOL] [EOL] if [string] not in test and [string] not in test : [EOL] if not has_manual : [EOL] return test [EOL] [EOL] if [string] not in test and [string] in test : [EOL] if not has_manual and not has_http : [EOL] return test [EOL] [EOL] current_test = current_test + [number] [EOL] test = None [EOL] [EOL] return test [EOL] [EOL] def skip_to ( self , test_list , test ) : [EOL] sorted_tests = self . _sort_tests_by_execution ( test_list ) [EOL] if test not in sorted_tests : [EOL] return test_list [EOL] index = sorted_tests . index ( test ) [EOL] remaining_tests = sorted_tests [ index + [number] : ] [EOL] remaining_tests_by_api = { } [EOL] current_api = [string] [EOL] for test in remaining_tests : [EOL] if not test . startswith ( [string] + current_api ) and not test . startswith ( current_api ) : [EOL] current_api = next ( ( p for p in test . split ( [string] ) if p != [string] ) , None ) [EOL] if current_api not in remaining_tests_by_api : [EOL] remaining_tests_by_api [ current_api ] = [ ] [EOL] remaining_tests_by_api [ current_api ] . append ( test ) [EOL] return remaining_tests_by_api [EOL] [EOL] def remove_test_from_list ( self , test_list , test ) : [EOL] api = None [EOL] for part in test . split ( [string] ) : [EOL] if part is None or part == [string] : [EOL] continue [EOL] api = part [EOL] break [EOL] if api not in test_list : [EOL] return test_list [EOL] if test not in test_list [ api ] : [EOL] return test_list [EOL] test_list [ api ] . remove ( test ) [EOL] if len ( test_list [ api ] ) == [number] : [EOL] del test_list [ api ] [EOL] [EOL] return test_list [EOL] [EOL] def add_test_to_list ( self , test_list , test ) : [EOL] api = None [EOL] for part in test . split ( [string] ) : [EOL] if part is None or part == [string] : [EOL] continue [EOL] api = part [EOL] break [EOL] if api in test_list and test in test_list [ api ] : [EOL] return test_list [EOL] if api not in test_list : [EOL] test_list [ api ] = [ ] [EOL] test_list [ api ] . append ( test ) [EOL] return test_list [EOL] [EOL] def get_test_timeout ( self , test , session ) : [EOL] timeouts = session . timeouts [EOL] test_timeout = None [EOL] [EOL] for path in list ( timeouts . keys ( ) ) : [EOL] pattern = re . compile ( [string] + path . replace ( [string] , [string] ) ) [EOL] if pattern . match ( test . replace ( [string] , [string] ) ) is not None : [EOL] test_timeout = timeouts [ path ] [EOL] break [EOL] [EOL] if test_timeout is None : [EOL] if [string] in test : [EOL] test_timeout = timeouts [ [string] ] [EOL] else : [EOL] test_timeout = timeouts [ [string] ] [EOL] [EOL] return test_timeout [EOL] [EOL] def _on_test_timeout ( self , token , test ) : [EOL] data = { [string] : test , [string] : [string] , [string] : None , [string] : [ { [string] : [string] , [string] : [string] } ] } [EOL] [EOL] self . _results_manager . create_result ( token , data ) [EOL] [EOL] def read_tests ( self ) : [EOL] return self . _test_loader . get_tests ( ) [EOL] [EOL] def complete_test ( self , test , session ) : [EOL] running_tests = session . running_tests [EOL] [EOL] running_tests = self . remove_test_from_list ( running_tests , test ) [EOL] session . running_tests = running_tests [EOL] [EOL] timeout = next ( ( t for t in self . _timeouts if t [ [string] ] == test ) , None ) [EOL] timeout [ [string] ] . cancel ( ) [EOL] self . _timeouts . remove ( timeout ) [EOL] [EOL] self . update_tests ( running_tests = running_tests , session = session ) [EOL] [EOL] self . _event_dispatcher . dispatch_event ( token = session . token , event_type = TEST_COMPLETED_EVENT , data = test ) [EOL] [EOL] def update_tests ( self , pending_tests = None , running_tests = None , session = None ) : [EOL] if pending_tests is not None : [EOL] session . pending_tests = pending_tests [EOL] [EOL] if running_tests is not None : [EOL] session . running_tests = running_tests [EOL] [EOL] self . _sessions_manager . update_session ( session ) [EOL] [EOL] def calculate_test_files_count ( self , tests ) : [EOL] count = { } [EOL] for api in tests : [EOL] count [ api ] = len ( tests [ api ] ) [EOL] return count [EOL] [EOL] def read_malfunctioning_tests ( self , token ) : [EOL] session = self . _sessions_manager . read_session ( token ) [EOL] return session . malfunctioning_tests [EOL] [EOL] def update_malfunctioning_tests ( self , token , tests ) : [EOL] if token is None : [EOL] return [EOL] if tests is None : [EOL] return [EOL] [EOL] session = self . _sessions_manager . read_session ( token ) [EOL] if session is None : [EOL] raise NotFoundException ( [string] + token ) [EOL] if session . is_public : [EOL] return [EOL] session . malfunctioning_tests = tests [EOL] self . _sessions_manager . update_session ( session ) [EOL] [EOL] def load_tests ( self , session ) : [EOL] pending_tests = self . _test_loader . get_tests ( session . types , include_list = session . tests [ [string] ] , exclude_list = session . tests [ [string] ] , reference_tokens = session . reference_tokens ) [EOL] [EOL] last_completed_test = session . last_completed_test [EOL] if last_completed_test is not None : [EOL] pending_tests = self . skip_to ( pending_tests , last_completed_test ) [EOL] [EOL] return pending_tests [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Timer$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $threading.Timer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Timer$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $None$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0
	0
from typing import Union , List , Type , Tuple , Any [EOL] import types [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] import subprocess [EOL] import os [EOL] import ntpath [EOL] import sys [EOL] from shutil import copyfile [EOL] [EOL] [EOL] def generate_report ( input_json_directory_path = None , output_html_directory_path = None , spec_name = None , is_multi = None , reference_dir = None ) : [EOL] if is_multi is None : [EOL] is_multi = False [EOL] try : [EOL] command = [ [string] , [string] , input_json_directory_path , [string] , output_html_directory_path , [string] , spec_name , [string] , [string] , [string] , [string] , [string] , [string] if is_multi else [string] , [string] , [string] , [string] , reference_dir if reference_dir is not None else [string] ] [EOL] whole_command = [string] [EOL] for command_part in command : [EOL] whole_command += command_part + [string] [EOL] subprocess . call ( command , shell = False ) [EOL] except subprocess . CalledProcessError as e : [EOL] info = sys . exc_info ( ) [EOL] raise Exception ( [string] + str ( info [ [number] ] . __name__ ) + [string] + e . output ) [EOL] [EOL] [EOL] def generate_multi_report ( output_html_directory_path = None , spec_name = None , result_json_files = None , reference_dir = None ) : [EOL] for file in result_json_files : [EOL] if not os . path . isfile ( file [ [string] ] ) : [EOL] continue [EOL] file_name = ntpath . basename ( file [ [string] ] ) [EOL] copyfile ( file [ [string] ] , os . path . join ( output_html_directory_path , file [ [string] ] + [string] + file_name ) ) [EOL] [EOL] generate_report ( input_json_directory_path = output_html_directory_path , output_html_directory_path = output_html_directory_path , spec_name = spec_name , is_multi = True , reference_dir = reference_dir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import subprocess [EOL] import socket [EOL] import typing [EOL] import errno [EOL] import os [EOL] import socket [EOL] import subprocess [EOL] import time [EOL] [EOL] try : [EOL] from urllib . request import urlopen [EOL] from urllib . error import URLError [EOL] except ImportError : [EOL] from urllib2 import urlopen , URLError [EOL] [EOL] import pytest [EOL] [EOL] from tools . wpt import wpt [EOL] [EOL] def is_port_8000_in_use ( ) : [EOL] s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] try : [EOL] s . bind ( ( [string] , [number] ) ) [EOL] except socket . error as e : [EOL] if e . errno == errno . EADDRINUSE : [EOL] return True [EOL] else : [EOL] raise e [EOL] finally : [EOL] s . close ( ) [EOL] return False [EOL] [EOL] def test_serve ( ) : [EOL] if is_port_8000_in_use ( ) : [EOL] pytest . skip ( [string] ) [EOL] [EOL] p = subprocess . Popen ( [ os . path . join ( wpt . localpaths . repo_root , [string] ) , [string] ] , preexec_fn = os . setsid ) [EOL] [EOL] start = time . time ( ) [EOL] try : [EOL] while True : [EOL] if p . poll ( ) is not None : [EOL] assert False , [string] [EOL] if time . time ( ) - start > [number] * [number] : [EOL] assert False , [string] [EOL] try : [EOL] resp = urlopen ( [string] ) [EOL] print ( resp ) [EOL] except URLError : [EOL] print ( [string] ) [EOL] time . sleep ( [number] ) [EOL] else : [EOL] assert resp . code == [number] [EOL] break [EOL] finally : [EOL] os . killpg ( p . pid , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type , Any [EOL] import threading [EOL] import typing [EOL] from __future__ import absolute_import [EOL] from __future__ import unicode_literals [EOL] import json [EOL] import threading [EOL] [EOL] from . api_handler import ApiHandler [EOL] [EOL] from . . . utils . serializer import serialize_session [EOL] from . . . data . exceptions . not_found_exception import NotFoundException [EOL] from . . . data . exceptions . invalid_data_exception import InvalidDataException [EOL] from . . . data . http_polling_client import HttpPollingClient [EOL] [EOL] TOKEN_LENGTH = [number] [EOL] [EOL] [EOL] class SessionsApiHandler ( ApiHandler ) : [EOL] def __init__ ( self , sessions_manager , results_manager , event_dispatcher , web_root ) : [EOL] super ( SessionsApiHandler , self ) . __init__ ( web_root ) [EOL] self . _sessions_manager = sessions_manager [EOL] self . _results_manager = results_manager [EOL] self . _event_dispatcher = event_dispatcher [EOL] [EOL] def create_session ( self , request , response ) : [EOL] try : [EOL] config = { } [EOL] body = request . body . decode ( [string] ) [EOL] if body != [string] : [EOL] config = json . loads ( body ) [EOL] tests = { } [EOL] if [string] in config : [EOL] tests = config [ [string] ] [EOL] types = None [EOL] if [string] in config : [EOL] types = config [ [string] ] [EOL] timeouts = { } [EOL] if [string] in config : [EOL] timeouts = config [ [string] ] [EOL] reference_tokens = [ ] [EOL] if [string] in config : [EOL] reference_tokens = config [ [string] ] [EOL] webhook_urls = [ ] [EOL] if [string] in config : [EOL] webhook_urls = config [ [string] ] [EOL] user_agent = request . headers [ [string] ] . decode ( [string] ) [EOL] labels = [ ] [EOL] if [string] in config : [EOL] labels = config [ [string] ] [EOL] expiration_date = None [EOL] if [string] in config : [EOL] expiration_date = config [ [string] ] [EOL] [EOL] session = self . _sessions_manager . create_session ( tests , types , timeouts , reference_tokens , webhook_urls , user_agent , labels , expiration_date ) [EOL] [EOL] self . send_json ( { [string] : session . token } , response ) [EOL] except InvalidDataException : [EOL] self . handle_exception ( [string] ) [EOL] self . send_json ( { [string] : [string] } , response , [number] ) [EOL] [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def read_session ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] token = uri_parts [ [number] ] [EOL] [EOL] session = self . _sessions_manager . read_session ( token ) [EOL] if session is None : [EOL] response . status = [number] [EOL] return [EOL] [EOL] data = serialize_session ( session ) [EOL] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] [EOL] self . send_json ( data , response ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def read_session_status ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] token = uri_parts [ [number] ] [EOL] [EOL] session = self . _sessions_manager . read_session_status ( token ) [EOL] if session is None : [EOL] response . status = [number] [EOL] return [EOL] data = serialize_session ( session ) [EOL] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] del data [ [string] ] [EOL] [EOL] self . send_json ( data , response ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def read_public_sessions ( self , request , response ) : [EOL] try : [EOL] session_tokens = self . _sessions_manager . read_public_sessions ( ) [EOL] [EOL] self . send_json ( session_tokens , response ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def update_session_configuration ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] token = uri_parts [ [number] ] [EOL] [EOL] config = { } [EOL] body = request . body . decode ( [string] ) [EOL] if body != [string] : [EOL] config = json . loads ( body ) [EOL] [EOL] tests = { } [EOL] if [string] in config : [EOL] tests = config [ [string] ] [EOL] types = None [EOL] if [string] in config : [EOL] types = config [ [string] ] [EOL] timeouts = { } [EOL] if [string] in config : [EOL] timeouts = config [ [string] ] [EOL] reference_tokens = [ ] [EOL] if [string] in config : [EOL] reference_tokens = config [ [string] ] [EOL] webhook_urls = [ ] [EOL] if [string] in config : [EOL] webhook_urls = config [ [string] ] [EOL] [EOL] self . _sessions_manager . update_session_configuration ( token , tests , types , timeouts , reference_tokens , webhook_urls ) [EOL] except NotFoundException : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def update_labels ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] [comment] [EOL] token = uri_parts [ [number] ] [EOL] body = request . body . decode ( [string] ) [EOL] labels = None [EOL] if body != [string] : [EOL] labels = json . loads ( body ) [EOL] if [string] in labels : [EOL] labels = labels [ [string] ] [EOL] [EOL] self . _sessions_manager . update_labels ( token = token , labels = labels ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def delete_session ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] token = uri_parts [ [number] ] [EOL] [EOL] session = self . _sessions_manager . read_session ( token ) [EOL] if session is None : [EOL] response . status = [number] [EOL] return [EOL] [EOL] self . _sessions_manager . delete_session ( token ) [EOL] self . _results_manager . delete_results ( token ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def start_session ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] token = uri_parts [ [number] ] [EOL] [EOL] self . _sessions_manager . start_session ( token ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def pause_session ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] token = uri_parts [ [number] ] [EOL] [EOL] self . _sessions_manager . pause_session ( token ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def stop_session ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] token = uri_parts [ [number] ] [EOL] [EOL] self . _sessions_manager . stop_session ( token ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def resume_session ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] token = uri_parts [ [number] ] [EOL] [EOL] resume_token = None [EOL] body = request . body . decode ( [string] ) [EOL] if body != [string] : [EOL] resume_token = json . loads ( body ) [ [string] ] [EOL] [EOL] self . _sessions_manager . resume_session ( token , resume_token ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def find_session ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] fragment = uri_parts [ [number] ] [EOL] token = self . _sessions_manager . find_token ( fragment ) [EOL] if token is None : [EOL] response . status = [number] [EOL] return [EOL] self . send_json ( { [string] : token } , response ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def register_event_listener ( self , request , response ) : [EOL] try : [EOL] uri_parts = self . parse_uri ( request ) [EOL] token = uri_parts [ [number] ] [EOL] [EOL] event = threading . Event ( ) [EOL] http_polling_client = HttpPollingClient ( token , event ) [EOL] self . _event_dispatcher . add_session_client ( http_polling_client ) [EOL] [EOL] event . wait ( ) [EOL] [EOL] message = http_polling_client . message [EOL] self . send_json ( data = message , response = response ) [EOL] except Exception : [EOL] self . handle_exception ( [string] ) [EOL] response . status = [number] [EOL] [EOL] def handle_request ( self , request , response ) : [EOL] method = request . method [EOL] uri_parts = self . parse_uri ( request ) [EOL] [EOL] [comment] [EOL] if len ( uri_parts ) == [number] : [EOL] if method == [string] : [EOL] self . create_session ( request , response ) [EOL] return [EOL] [EOL] [comment] [EOL] if len ( uri_parts ) == [number] : [EOL] function = uri_parts [ [number] ] [EOL] if method == [string] : [EOL] if function == [string] : [EOL] self . read_public_sessions ( request , response ) [EOL] return [EOL] if len ( function ) != TOKEN_LENGTH : [EOL] self . find_session ( request , response ) [EOL] return [EOL] self . read_session ( request , response ) [EOL] return [EOL] if method == [string] : [EOL] self . update_session_configuration ( request , response ) [EOL] return [EOL] if method == [string] : [EOL] self . delete_session ( request , response ) [EOL] return [EOL] [EOL] [comment] [EOL] if len ( uri_parts ) == [number] : [EOL] function = uri_parts [ [number] ] [EOL] if method == [string] : [EOL] if function == [string] : [EOL] self . read_session_status ( request , response ) [EOL] return [EOL] if function == [string] : [EOL] self . register_event_listener ( request , response ) [EOL] return [EOL] if method == [string] : [EOL] if function == [string] : [EOL] self . start_session ( request , response ) [EOL] return [EOL] if function == [string] : [EOL] self . pause_session ( request , response ) [EOL] return [EOL] if function == [string] : [EOL] self . stop_session ( request , response ) [EOL] return [EOL] if function == [string] : [EOL] self . resume_session ( request , response ) [EOL] return [EOL] if method == [string] : [EOL] if function == [string] : [EOL] self . update_labels ( request , response ) [EOL] return [EOL] [EOL] response . status = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $threading.Event$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Type[function]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[function]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[function]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Type[function]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[function]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[function]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[function]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[function]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[function]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[function]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[function]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Union , Set , List , Dict , Any [EOL] import io [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] import os [EOL] import sys [EOL] [EOL] import mock [EOL] import six [EOL] [EOL] from . . . localpaths import repo_root [EOL] from . . import lint as lint_mod [EOL] from . . lint import filter_ignorelist_errors , parse_ignorelist , lint , create_parser [EOL] [EOL] _dummy_repo = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] [EOL] def _mock_lint ( name , ** kwargs ) : [EOL] wrapped = getattr ( lint_mod , name ) [EOL] return mock . patch ( lint_mod . __name__ + [string] + name , wraps = wrapped , ** kwargs ) [EOL] [EOL] [EOL] def test_filter_ignorelist_errors ( ) : [EOL] ignorelist = { [string] : { [string] : { [number] } } , [string] : { [string] : { None } } } [EOL] [comment] [EOL] ignorelist = { e : { os . path . normcase ( k ) : v for k , v in p . items ( ) } for e , p in ignorelist . items ( ) } [EOL] [comment] [EOL] filteredfile = [string] [EOL] unfilteredfile = [string] [EOL] [comment] [EOL] filtered = filter_ignorelist_errors ( ignorelist , [ ] ) [EOL] assert filtered == [ ] [EOL] filtered = filter_ignorelist_errors ( ignorelist , [ ] ) [EOL] assert filtered == [ ] [EOL] [comment] [EOL] filtered = filter_ignorelist_errors ( ignorelist , [ [ [string] , [string] , filteredfile , [number] ] ] ) [EOL] assert filtered == [ ] [EOL] filtered = filter_ignorelist_errors ( ignorelist , [ [ [string] , [string] , unfilteredfile , [number] ] ] ) [EOL] assert filtered == [ [ [string] , [string] , unfilteredfile , [number] ] ] [EOL] filtered = filter_ignorelist_errors ( ignorelist , [ [ [string] , [string] , filteredfile , [number] ] ] ) [EOL] assert filtered == [ [ [string] , [string] , filteredfile , [number] ] ] [EOL] [comment] [EOL] filtered = filter_ignorelist_errors ( ignorelist , [ [ [string] , [string] , filteredfile , [number] ] ] ) [EOL] assert filtered == [ ] [EOL] filtered = filter_ignorelist_errors ( ignorelist , [ [ [string] , [string] , filteredfile , [number] ] ] ) [EOL] assert filtered == [ ] [EOL] filtered = filter_ignorelist_errors ( ignorelist , [ [ [string] , [string] , unfilteredfile , [number] ] ] ) [EOL] assert filtered == [ [ [string] , [string] , unfilteredfile , [number] ] ] [EOL] [EOL] [EOL] def test_parse_ignorelist ( ) : [EOL] input_buffer = six . StringIO ( [string] ) [EOL] [EOL] expected_data = { [string] : { [string] : { None } , [string] : { None } , [string] : { None } , [string] : { None } , [string] : { [number] } , } , [string] : { [string] : { None } , } , [string] : { [string] : { [number] } , } , [string] : { [string] : { None } , [string] : { None } , [string] : { None } , [string] : { [number] } , } } [EOL] expected_data = { e : { os . path . normcase ( k ) : v for k , v in p . items ( ) } for e , p in expected_data . items ( ) } [EOL] expected_skipped = { os . path . normcase ( x ) for x in { [string] , [string] , [string] } } [EOL] data , skipped_files = parse_ignorelist ( input_buffer ) [EOL] assert data == expected_data [EOL] assert skipped_files == expected_skipped [EOL] [EOL] [EOL] def test_lint_no_files ( caplog ) : [EOL] rv = lint ( _dummy_repo , [ ] , [string] ) [EOL] assert rv == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_lint_ignored_file ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert not mocked_check_path . called [EOL] assert not mocked_check_file_contents . called [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_lint_not_existing_file ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] [comment] [EOL] name = [string] * [number] + [string] [EOL] rv = lint ( _dummy_repo , [ name ] , [string] ) [EOL] assert rv == [number] [EOL] assert not mocked_check_path . called [EOL] assert not mocked_check_file_contents . called [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_lint_passing ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_lint_failing ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_ref_existent_relative ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_ref_existent_root_relative ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_ref_non_existent_relative ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_ref_non_existent_root_relative ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] [EOL] def test_ref_absolute_url ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_about_blank_as_ref ( caplog ) : [EOL] with _mock_lint ( [string] ) : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_ref_same_file_empty ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_ref_same_file_path ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_manual_path_testharness ( caplog ) : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_css_visual_path_testharness ( caplog ) : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_css_manual_path_testharness ( caplog ) : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_lint_passing_and_failing ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] assert [string] not in caplog . text [EOL] [EOL] [EOL] def test_check_css_globally_unique_identical_test ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_css_globally_unique_different_test ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_check_css_globally_unique_different_spec_test ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_css_globally_unique_support_ignored ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_css_globally_unique_support_identical ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_css_globally_unique_support_different ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_check_css_globally_unique_test_support ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_css_globally_unique_ref_identical ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_css_globally_unique_ref_different ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_check_css_globally_unique_test_ref ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_css_globally_unique_ignored ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_css_globally_unique_ignored_dir ( caplog ) : [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_unique_testharness_basename_same_basename ( caplog ) : [EOL] [comment] [EOL] assert os . path . exists ( os . path . join ( _dummy_repo , [string] , [string] , [string] ) ) [EOL] assert os . path . exists ( os . path . join ( _dummy_repo , [string] , [string] , [string] ) ) [EOL] [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] [comment] [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_check_unique_testharness_basename_different_name ( caplog ) : [EOL] [comment] [EOL] [comment] [EOL] assert os . path . exists ( os . path . join ( _dummy_repo , [string] , [string] , [string] ) ) [EOL] assert os . path . exists ( os . path . join ( _dummy_repo , [string] , [string] , [string] ) ) [EOL] [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_unique_testharness_basename_different_dir ( caplog ) : [EOL] [comment] [EOL] [comment] [EOL] assert os . path . exists ( os . path . join ( _dummy_repo , [string] , [string] , [string] ) ) [EOL] assert os . path . exists ( os . path . join ( _dummy_repo , [string] , [string] , [string] ) ) [EOL] [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_check_unique_testharness_basename_not_testharness ( caplog ) : [EOL] [comment] [EOL] assert os . path . exists ( os . path . join ( _dummy_repo , [string] , [string] , [string] ) ) [EOL] assert os . path . exists ( os . path . join ( _dummy_repo , [string] , [string] , [string] ) ) [EOL] [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [EOL] [EOL] def test_ignore_glob ( caplog ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] , [string] ] , [string] , [ [string] , [string] ] ) [EOL] assert rv == [number] [EOL] [comment] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert caplog . text == [string] [EOL] [comment] [EOL] with _mock_lint ( [string] ) as mocked_check_path : [EOL] with _mock_lint ( [string] ) as mocked_check_file_contents : [EOL] rv = lint ( _dummy_repo , [ [string] , [string] , [string] ] , [string] ) [EOL] assert rv == [number] [EOL] assert mocked_check_path . call_count == [number] [EOL] assert mocked_check_file_contents . call_count == [number] [EOL] assert [string] in caplog . text [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_all_filesystem_paths ( ) : [EOL] with mock . patch ( [string] , return_value = [ ( [string] , [ ( [string] , None ) , ( [string] , None ) ] , [ ( [string] , None ) , ( [string] , None ) ] ) , ( [string] , [ ] , [ ( [string] , None ) , ( [string] , None ) ] ) ] ) : [EOL] got = list ( lint_mod . all_filesystem_paths ( [string] ) ) [EOL] assert got == [ [string] , [string] , os . path . join ( [string] , [string] ) , os . path . join ( [string] , [string] ) ] [EOL] [EOL] [EOL] def test_filesystem_paths_subdir ( ) : [EOL] with mock . patch ( [string] , return_value = [ ( [string] , [ ( [string] , None ) , ( [string] , None ) ] , [ ( [string] , None ) , ( [string] , None ) ] ) , ( [string] , [ ] , [ ( [string] , None ) , ( [string] , None ) ] ) ] ) : [EOL] got = list ( lint_mod . all_filesystem_paths ( [string] , [string] ) ) [EOL] assert got == [ os . path . join ( [string] , [string] ) , os . path . join ( [string] , [string] ) , os . path . join ( [string] , [string] , [string] ) , os . path . join ( [string] , [string] , [string] ) ] [EOL] [EOL] [EOL] def test_main_with_args ( ) : [EOL] orig_argv = sys . argv [EOL] try : [EOL] sys . argv = [ [string] , [string] , [string] , [string] ] [EOL] with mock . patch ( lint_mod . __name__ + [string] ) as mock_isfile : [EOL] mock_isfile . return_value = True [EOL] with _mock_lint ( [string] , return_value = True ) as m : [EOL] lint_mod . main ( ** vars ( create_parser ( ) . parse_args ( ) ) ) [EOL] m . assert_called_once_with ( repo_root , [ os . path . relpath ( os . path . join ( os . getcwd ( ) , x ) , repo_root ) for x in [ [string] , [string] , [string] ] ] , [string] , None , None ) [EOL] finally : [EOL] sys . argv = orig_argv [EOL] [EOL] [EOL] def test_main_no_args ( ) : [EOL] orig_argv = sys . argv [EOL] try : [EOL] sys . argv = [ [string] ] [EOL] with _mock_lint ( [string] , return_value = True ) as m : [EOL] with _mock_lint ( [string] , return_value = [ [string] , [string] ] ) : [EOL] lint_mod . main ( ** vars ( create_parser ( ) . parse_args ( ) ) ) [EOL] m . assert_called_once_with ( repo_root , [ [string] , [string] ] , [string] , None , None ) [EOL] finally : [EOL] sys . argv = orig_argv [EOL] [EOL] [EOL] def test_main_all ( ) : [EOL] orig_argv = sys . argv [EOL] try : [EOL] sys . argv = [ [string] , [string] ] [EOL] with _mock_lint ( [string] , return_value = True ) as m : [EOL] with _mock_lint ( [string] , return_value = [ [string] , [string] ] ) : [EOL] lint_mod . main ( ** vars ( create_parser ( ) . parse_args ( ) ) ) [EOL] m . assert_called_once_with ( repo_root , [ [string] , [string] ] , [string] , None , None ) [EOL] finally : [EOL] sys . argv = orig_argv [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] [EOL] def main ( request , response ) : [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] response . headers . set ( [string] , [string] ) ; [EOL] response . headers . set ( [string] , [string] ) ; [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import aioquic [EOL] import asyncio [EOL] import builtins [EOL] import typing [EOL] import asyncio [EOL] import logging [EOL] [EOL] from aioquic . asyncio import QuicConnectionProtocol [EOL] from aioquic . quic . events import QuicEvent [EOL] from typing import Dict [EOL] [EOL] [EOL] async def notify_pass ( connection ) : [EOL] _ , writer = await connection . create_stream ( is_unidirectional = True ) [EOL] writer . write ( [string] ) [EOL] writer . write_eof ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def handle_client_indication ( connection , origin , query ) : [EOL] logging . log ( logging . INFO , [string] % ( origin , query ) ) [EOL] if [string] not in query or query [ [string] ] != origin : [EOL] logging . log ( logging . WARN , [string] ) [EOL] connection . close ( ) [EOL] return [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . create_task ( notify_pass ( connection ) ) [EOL] [EOL] [EOL] def handle_event ( connection , event ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0
from wptserve . utils import isomorphic_encode [EOL] [EOL] def main ( request , response ) : [EOL] content = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] response . add_required_headers = False [EOL] output = [string] [EOL] output += [string] + isomorphic_encode ( str ( len ( content ) ) ) + [string] [EOL] output += [string] + request . GET . first ( [string] ) + [string] [EOL] output += [string] [EOL] output += content [EOL] response . writer . write ( output ) [EOL] response . close_connection = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os . path [EOL] import time [EOL] [EOL] from wptserve . utils import isomorphic_encode [EOL] [EOL] def main ( request , response ) : [EOL] name = request . GET . first ( [string] ) [EOL] sleepTime = float ( request . GET . first ( [string] ) ) / [number] [EOL] [EOL] time . sleep ( sleepTime ) [EOL] [EOL] path = os . path . join ( os . path . dirname ( isomorphic_encode ( __file__ ) ) , name ) [EOL] body = open ( path , [string] ) . read ( ) [EOL] [EOL] response . headers . set ( [string] , [string] ) [EOL] response . headers . set ( [string] , len ( body ) ) [EOL] response . headers . set ( [string] , [string] ) [EOL] [EOL] response . content = body ; [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] import BaseHTTPServer [EOL] import SimpleHTTPServer [EOL] import urlparse [EOL] import json [EOL] [EOL] [EOL] [comment] [EOL] TEST_SERVER_PORT = [number] [EOL] [EOL] [EOL] [comment] [EOL] def run_servo ( servo_exe , tests ) : [EOL] url = [string] . format ( TEST_SERVER_PORT , tests ) [EOL] args = [ servo_exe , url , [string] , [string] ] [EOL] return subprocess . Popen ( args ) [EOL] [EOL] [EOL] [comment] [EOL] def print_usage ( ) : [EOL] print ( [string] . format ( sys . argv [ [number] ] ) ) [EOL] [EOL] [EOL] [comment] [EOL] class RequestHandler ( SimpleHTTPServer . SimpleHTTPRequestHandler ) : [EOL] def do_POST ( self ) : [EOL] self . send_response ( [number] ) [EOL] self . end_headers ( ) [EOL] self . wfile . write ( [string] ) [EOL] length = int ( self . headers . getheader ( [string] ) ) [EOL] parameters = urlparse . parse_qs ( self . rfile . read ( length ) ) [EOL] self . server . got_post = True [EOL] self . server . post_data = parameters [ [string] ] [EOL] [EOL] def log_message ( self , format , * args ) : [EOL] return [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) == [number] : [EOL] tests = sys . argv [ [number] ] [EOL] servo_exe = sys . argv [ [number] ] [EOL] base_dir = sys . argv [ [number] ] [EOL] os . chdir ( base_dir ) [EOL] [EOL] [comment] [EOL] if not os . path . isfile ( servo_exe ) : [EOL] print ( [string] . format ( servo_exe ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [comment] [EOL] server = BaseHTTPServer . HTTPServer ( ( [string] , TEST_SERVER_PORT ) , RequestHandler ) [EOL] [EOL] print ( [string] ) [EOL] proc = run_servo ( servo_exe , tests ) [EOL] server . got_post = False [EOL] while not server . got_post : [EOL] server . handle_request ( ) [EOL] data = json . loads ( server . post_data [ [number] ] ) [EOL] number = [number] [EOL] length = [number] [EOL] for test in data : [EOL] number = max ( number , len ( data [ test ] ) ) [EOL] length = max ( length , len ( test ) ) [EOL] print ( [string] . format ( [string] * ( length - len ( [string] ) ) ) ) [EOL] print ( [string] . format ( [string] * length , [string] * number ) ) [EOL] for test in data : [EOL] print ( [string] . format ( test , [string] * ( length - len ( test ) ) , data [ test ] ) ) [EOL] proc . kill ( ) [EOL] else : [EOL] print_usage ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import io [EOL] import argparse [EOL] import typing [EOL] from __future__ import print_function , unicode_literals [EOL] [EOL] import os [EOL] from os import path [EOL] import time [EOL] import argparse [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] TOP_DIR = path . join ( [string] , [string] ) [EOL] [EOL] [EOL] def PowerCollector ( OutputDir , Benchmarks , LayoutThreads , Renderer ) : [EOL] print ( [string] ) [EOL] power_dir = path . join ( OutputDir , [string] ) [EOL] time_dir = path . join ( OutputDir , [string] ) [EOL] etc_dir = path . join ( OutputDir , [string] ) [EOL] for d in [ power_dir , time_dir , etc_dir ] : [EOL] os . mkdir ( d ) [EOL] SleepTime = [number] [EOL] GuardTime = [number] [EOL] powerTiming = [number] [EOL] ExperimentNum = [number] [EOL] for ExpNum in range ( [number] , ExperimentNum ) : [EOL] for layoutT in range ( [number] , LayoutThreads + [number] ) : [EOL] print ( [string] % ( layoutT , ExpNum ) ) [EOL] PowerFiles = path . join ( power_dir , [string] % ( layoutT , ExpNum ) ) [EOL] TimeFiles = path . join ( time_dir , [string] % ( layoutT , ExpNum ) ) [EOL] ServoCmd = [string] % ( layoutT , Renderer , Benchmarks , TimeFiles ) [EOL] Metrics = path . join ( etc_dir , [string] % ( layoutT , ExpNum ) ) [EOL] cmd = [string] [string] % ( powerTiming , PowerFiles , Metrics ) [EOL] time . sleep ( SleepTime ) [EOL] os . system ( cmd ) [EOL] time . sleep ( GuardTime ) [EOL] os . system ( ServoCmd ) [EOL] time . sleep ( GuardTime ) [EOL] os . system ( [string] ) [EOL] time . sleep ( SleepTime ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def PowerParser ( OutputDir , LayoutThreads ) : [EOL] print ( [string] ) [EOL] ExperimentNum = [number] [EOL] ResultTable = OutputDir + [string] [EOL] ResultFile = open ( ResultTable , [string] ) [EOL] ResultFile . write ( [string] [string] ) [EOL] [EOL] for layoutT in range ( [number] , LayoutThreads + [number] ) : [EOL] MaxTime = [number] [EOL] MinTime = [number] [EOL] MaxPower = [number] [EOL] MinPower = [number] [EOL] TotalPower = [number] [EOL] TotalTime = [number] [EOL] TimeGen = [number] [EOL] PowerGen = [number] [EOL] for ExpNum in range ( [number] , ExperimentNum ) : [EOL] print ( [string] % ( layoutT , ExpNum ) ) [EOL] Files = path . join ( OutputDir , [string] , [string] % ( layoutT , ExpNum ) ) [EOL] NewFile = path . join ( OutputDir , [string] , [string] % ( layoutT , ExpNum ) ) [EOL] File = open ( Files , [string] ) [EOL] PowerFile = open ( NewFile , [string] ) [EOL] TimeFiles = path . join ( OutputDir , [string] , [string] % ( layoutT , ExpNum ) ) [EOL] [comment] [EOL] [EOL] for line in File : [EOL] words = line . split ( ) [EOL] if words [ [number] ] == [string] : [EOL] insertingWord = words [ [number] ] [ [number] : - [number] ] + [string] [EOL] elif words [ [number] ] == [string] : [EOL] insertingWord += words [ [number] ] [ : - [number] ] [EOL] insertingWord += [string] [EOL] PowerFile . write ( insertingWord ) [EOL] File . close ( ) [EOL] PowerFile . close ( ) [EOL] [EOL] [comment] [EOL] [EOL] TempFile = open ( NewFile , [string] ) [EOL] Power = [number] [EOL] for line in TempFile : [EOL] words2 = line . split ( ) [EOL] Power += float ( words2 [ [number] ] ) * float ( words2 [ [number] ] ) [EOL] TotalPower = float ( Power / [number] ) [EOL] if TotalPower > MaxPower : [EOL] MaxPower = TotalPower [EOL] if TotalPower < MinPower : [EOL] MinPower = TotalPower [EOL] [EOL] [comment] [EOL] [EOL] TempFile2 = open ( TimeFiles , [string] ) [EOL] for line in TempFile2 : [EOL] words3 = line . split ( ) [EOL] if line != [string] and words3 [ [number] ] == [string] : [EOL] TotalTime = ( float ( words3 [ [number] ] [ [number] ] ) * [number] ) + float ( words3 [ [number] ] [ [number] : - [number] ] ) [EOL] if TotalTime > MaxTime : [EOL] MaxTime = TotalTime [EOL] if TotalTime < MinTime : [EOL] MinTime = TotalTime [EOL] TimeGen = TimeGen + TotalTime [EOL] PowerGen = PowerGen + TotalPower [EOL] [EOL] TotalPower = PowerGen / float ( ExperimentNum - [number] ) [EOL] TotalTime = TimeGen / float ( ExperimentNum - [number] ) [EOL] ResultFile . write ( str ( layoutT ) + [string] + str ( TotalPower ) + [string] + str ( MaxPower ) + [string] + str ( MinPower ) + [string] + str ( TotalTime ) + [string] + str ( MaxTime ) + [string] + str ( MinTime ) + [string] ) [EOL] ResultFile . close ( ) [EOL] Opener = ResultFile = open ( ResultTable , [string] ) [EOL] for line in Opener : [EOL] print ( line ) [EOL] [EOL] print ( [string] [string] , ResultTable ) [EOL] [EOL] [EOL] [comment] [EOL] def main ( ) : [EOL] LayoutThreads = [number] [comment] [EOL] Benchmarks = path . join ( TOP_DIR , [string] , [string] , [string] ) [EOL] OutputDir = [string] [EOL] os . mkdir ( OutputDir ) [EOL] Renderer = [string] [EOL] [EOL] [comment] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] if args . benchmark : [EOL] Benchmarks = args . benchmark [EOL] if args . CPU : [EOL] Renderer = [string] [EOL] if args . LayoutThreads : [EOL] LayoutThreads = int ( args . LayoutThreads ) [EOL] if args . Output : [EOL] OutputDir = args . Output [EOL] [EOL] PowerCollector ( OutputDir , Benchmarks , LayoutThreads , Renderer ) [EOL] PowerParser ( OutputDir , LayoutThreads ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Match , Dict , List , Any , Optional [EOL] import tests [EOL] import subprocess [EOL] import threading [EOL] import typing [EOL] from __future__ import absolute_import [EOL] from __future__ import print_function [EOL] import os [EOL] import re [EOL] import subprocess [EOL] import sys [EOL] import six . moves . BaseHTTPServer [EOL] import six . moves . SimpleHTTPServer [EOL] import six . moves . socketserver [EOL] import threading [EOL] import six . moves . urllib . parse [EOL] import six [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] JQUERY_MODULES = [ [string] , ] [EOL] [EOL] [comment] [EOL] TEST_SERVER_PORT = [number] [EOL] [EOL] [comment] [EOL] REGEX_PATTERN = [string] [EOL] [EOL] [EOL] [comment] [EOL] class TestResult : [EOL] def __init__ ( self , success , fail , total , text ) : [EOL] self . success = int ( success ) [EOL] self . fail = int ( fail ) [EOL] self . total = int ( total ) [EOL] self . text = text [EOL] [EOL] def __key ( self ) : [EOL] return ( self . success , self . fail , self . total , self . text ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . __key ( ) == other . __key ( ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return self . __key ( ) != other . __key ( ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . __key ( ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . success , self . fail , self . total ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def parse_line_to_result ( line ) : [EOL] match = re . match ( REGEX_PATTERN , line ) [EOL] success , fail , total , name = match . groups ( ) [EOL] return name , TestResult ( success , fail , total , line ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def parse_string_to_results ( buffer ) : [EOL] test_results = { } [EOL] lines = buffer . splitlines ( ) [EOL] for line in lines : [EOL] name , test_result = parse_line_to_result ( line ) [EOL] test_results [ name ] = test_result [EOL] return test_results [EOL] [EOL] [EOL] [comment] [EOL] def run_servo ( servo_exe , module ) : [EOL] url = [string] . format ( TEST_SERVER_PORT , module ) [EOL] args = [ servo_exe , url , [string] , [string] ] [EOL] proc = subprocess . Popen ( args , stdout = subprocess . PIPE ) [EOL] while True : [EOL] line = proc . stdout . readline ( ) [EOL] if len ( line ) == [number] : [EOL] break [EOL] line = line . rstrip ( ) [EOL] try : [EOL] name , test_result = parse_line_to_result ( line . decode ( [string] ) ) [EOL] yield name , test_result [EOL] except AttributeError : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] def module_filename ( module ) : [EOL] return [string] . format ( module ) [EOL] [EOL] [EOL] [comment] [EOL] def read_existing_results ( module ) : [EOL] with open ( module_filename ( module ) , [string] ) as file : [EOL] buffer = file . read ( ) [EOL] return parse_string_to_results ( buffer ) [EOL] [EOL] [EOL] [comment] [EOL] def write_results ( module , results ) : [EOL] with open ( module_filename ( module ) , [string] ) as file : [EOL] for result in six . itervalues ( test_results ) : [EOL] file . write ( result . text + [string] ) [EOL] [EOL] [EOL] [comment] [EOL] def print_usage ( ) : [EOL] print ( [string] . format ( sys . argv [ [number] ] ) ) [EOL] [EOL] [EOL] [comment] [EOL] def run_http_server ( ) : [EOL] class ThreadingSimpleServer ( six . moves . socketserver . ThreadingMixIn , six . moves . BaseHTTPServer . HTTPServer ) : [EOL] allow_reuse_address = True [EOL] [EOL] class RequestHandler ( six . moves . SimpleHTTPServer . SimpleHTTPRequestHandler ) : [EOL] [comment] [EOL] [comment] [EOL] def send_head ( self ) : [EOL] path = self . translate_path ( self . path ) [EOL] f = None [EOL] if os . path . isdir ( path ) : [EOL] parts = six . moves . urllib . parse . urlsplit ( self . path ) [EOL] if not parts . path . endswith ( [string] ) : [EOL] [comment] [EOL] self . send_response ( [number] ) [EOL] new_parts = ( parts [ [number] ] , parts [ [number] ] , parts [ [number] ] + [string] , parts [ [number] ] , parts [ [number] ] ) [EOL] new_url = six . moves . urllib . parse . urlunsplit ( new_parts ) [EOL] self . send_header ( [string] , new_url ) [EOL] self . end_headers ( ) [EOL] return None [EOL] for index in [string] , [string] : [EOL] index = os . path . join ( path , index ) [EOL] if os . path . exists ( index ) : [EOL] path = index [EOL] break [EOL] else : [EOL] return self . list_directory ( path ) [EOL] ctype = self . guess_type ( path ) [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] f = open ( path , [string] ) [EOL] except IOError : [EOL] self . send_error ( [number] , [string] ) [EOL] return None [EOL] try : [EOL] self . send_response ( [number] ) [EOL] self . send_header ( [string] , ctype ) [EOL] fs = os . fstat ( f . fileno ( ) ) [EOL] self . send_header ( [string] , str ( fs [ [number] ] ) ) [EOL] self . send_header ( [string] , self . date_time_string ( fs . st_mtime ) ) [EOL] self . end_headers ( ) [EOL] return f [EOL] except IOError : [EOL] f . close ( ) [EOL] raise [EOL] [EOL] def log_message ( self , format , * args ) : [EOL] return [EOL] [EOL] server = ThreadingSimpleServer ( ( [string] , TEST_SERVER_PORT ) , RequestHandler ) [EOL] while True : [EOL] sys . stdout . flush ( ) [EOL] server . handle_request ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) == [number] : [EOL] cmd = sys . argv [ [number] ] [EOL] servo_exe = sys . argv [ [number] ] [EOL] base_dir = sys . argv [ [number] ] [EOL] os . chdir ( base_dir ) [EOL] [EOL] [comment] [EOL] if not os . path . isfile ( servo_exe ) : [EOL] print ( [string] . format ( servo_exe ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [comment] [EOL] httpd_thread = threading . Thread ( target = run_http_server ) [EOL] httpd_thread . setDaemon ( True ) [EOL] httpd_thread . start ( ) [EOL] [EOL] if cmd == [string] : [EOL] print ( [string] ) [EOL] test_count = [number] [EOL] unexpected_count = [number] [EOL] [EOL] individual_success = [number] [EOL] individual_total = [number] [EOL] [EOL] [comment] [EOL] for module in JQUERY_MODULES : [EOL] print ( [string] . format ( module ) ) [EOL] [EOL] prev_test_results = read_existing_results ( module ) [EOL] for name , current_result in run_servo ( servo_exe , module ) : [EOL] test_count += [number] [EOL] individual_success += current_result . success [EOL] individual_total += current_result . total [EOL] [EOL] [comment] [EOL] if name in prev_test_results : [EOL] prev_result = prev_test_results [ name ] [EOL] if prev_result == current_result : [EOL] print ( [string] . format ( name ) ) [EOL] else : [EOL] unexpected_count += [number] [EOL] print ( [string] . format ( name , prev_result , current_result ) ) [EOL] del prev_test_results [ name ] [EOL] else : [EOL] [comment] [EOL] unexpected_count += [number] [EOL] print ( [string] . format ( current_result . text ) ) [EOL] [EOL] [comment] [EOL] for name in prev_test_results : [EOL] test_count += [number] [EOL] unexpected_count += [number] [EOL] print ( [string] . format ( prev_test_results [ name ] . text ) ) [EOL] [EOL] print ( [string] . format ( test_count , unexpected_count ) ) [EOL] print ( [string] . format ( individual_success , individual_total , [number] * individual_success / individual_total ) ) [EOL] [EOL] if unexpected_count > [number] : [EOL] sys . exit ( [number] ) [EOL] elif cmd == [string] : [EOL] print ( [string] ) [EOL] for module in JQUERY_MODULES : [EOL] print ( [string] . format ( module ) ) [EOL] test_results = { } [EOL] for name , test_result in run_servo ( servo_exe , module ) : [EOL] print ( [string] . format ( name , test_result ) ) [EOL] test_results [ name ] = test_result [EOL] write_results ( module , test_results ) [EOL] else : [EOL] print_usage ( ) [EOL] else : [EOL] print_usage ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , Dict [EOL] import typing [EOL] import json [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] [EOL] [EOL] def main ( crate = None ) : [EOL] os . chdir ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] meta = json . loads ( subprocess . check_output ( [ [string] , [string] , [string] , [string] ] ) ) [EOL] graph = { } [EOL] for package in meta [ [string] ] : [EOL] if package [ [string] ] is None : [comment] [EOL] for dependency in package [ [string] ] : [EOL] if dependency [ [string] ] is None : [comment] [EOL] graph . setdefault ( package [ [string] ] , [ ] ) . append ( dependency [ [string] ] ) [EOL] [EOL] if crate : [EOL] filtered = { } [EOL] seen = set ( ) [EOL] [EOL] def traverse ( name ) : [EOL] if name not in seen : [EOL] seen . add ( name ) [EOL] for dependency in graph . get ( name , [ ] ) : [EOL] filtered . setdefault ( name , [ ] ) . append ( dependency ) [EOL] traverse ( dependency ) [EOL] traverse ( crate ) [EOL] else : [EOL] filtered = graph [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] for package , dependencies in filtered . items ( ) : [EOL] for dependency in dependencies : [EOL] print ( [string] % ( package , dependency ) ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( * sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] [EOL] test_root = os . path . join ( [string] , [string] , [string] ) [EOL] meta_root = os . path . join ( [string] , [string] , [string] ) [EOL] [EOL] missing_dirs = [ ] [EOL] [EOL] for base_dir , dir_names , files in os . walk ( meta_root ) : [EOL] [comment] [EOL] if base_dir in missing_dirs : [EOL] [comment] [EOL] missing_dirs += map ( lambda x : os . path . join ( base_dir , x ) , dir_names ) [EOL] continue [EOL] [EOL] for dir_name in dir_names : [EOL] meta_dir = os . path . join ( base_dir , dir_name ) [EOL] [EOL] [comment] [EOL] if dir_name == [string] : [EOL] missing_dirs += [ meta_dir ] [EOL] continue [EOL] [EOL] [comment] [EOL] test_dir = os . path . join ( test_root , os . path . relpath ( meta_dir , meta_root ) ) [EOL] if not os . path . exists ( test_dir ) : [EOL] missing_dirs += [ meta_dir ] [EOL] print ( meta_dir ) [EOL] [EOL] for fname in files : [EOL] [comment] [EOL] if fname in [ [string] , [string] , [string] ] : [EOL] continue [EOL] [EOL] [comment] [EOL] test_dir = os . path . join ( test_root , os . path . relpath ( base_dir , meta_root ) ) [EOL] test_file = os . path . join ( test_dir , fname ) [EOL] if not os . path . exists ( os . path . splitext ( test_file ) [ [number] ] ) : [EOL] print ( os . path . join ( base_dir , fname ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , DefaultDict , Any , Dict [EOL] import _csv [EOL] import typing [EOL] import sys [EOL] import json [EOL] import collections [EOL] import csv [EOL] [EOL] [EOL] def process_log ( data ) : [EOL] tests = { } [EOL] test_results = collections . defaultdict ( list ) [EOL] [EOL] for entry in data : [EOL] entry = json . loads ( entry ) [EOL] if [string] in entry : [EOL] if entry [ [string] ] == [string] : [EOL] tests [ entry [ [string] ] ] = { [string] : int ( entry [ [string] ] ) , [string] : [number] , } [EOL] elif entry [ [string] ] == [string] : [EOL] test = tests [ entry [ [string] ] ] [EOL] test [ [string] ] = int ( entry [ [string] ] ) [EOL] test_results [ entry [ [string] ] ] += [ ( entry [ [string] ] , test [ [string] ] - test [ [string] ] ) ] [EOL] [EOL] return test_results [EOL] [EOL] [EOL] test_results = { [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , } [EOL] for log_path in sys . argv [ [number] : ] : [EOL] with open ( log_path ) as f : [EOL] data = f . readlines ( ) [EOL] for k , v in process_log ( data ) . items ( ) : [EOL] test_results [ k ] += v [EOL] [EOL] print ( [string] % len ( test_results [ [string] ] ) ) [EOL] print ( [string] % len ( test_results [ [string] ] ) ) [EOL] [EOL] longest_crash = sorted ( test_results [ [string] ] , key = lambda x : x [ [number] ] , reverse = True ) [EOL] print ( [string] % ( longest_crash [ [number] ] [ [number] ] , longest_crash [ [number] ] [ [number] ] ) ) [EOL] [EOL] longest_ok = sorted ( test_results [ [string] ] + test_results [ [string] ] , key = lambda x : x [ [number] ] , reverse = True ) [EOL] csv_data = [ [ [string] , [string] ] ] [EOL] with open ( [string] , [string] ) as csv_file : [EOL] writer = csv . writer ( csv_file ) [EOL] writer . writerows ( csv_data + longest_ok ) [EOL] [EOL] longest_fail = sorted ( test_results [ [string] ] + test_results [ [string] ] , key = lambda x : x [ [number] ] , reverse = True ) [EOL] with open ( [string] , [string] ) as csv_file : [EOL] writer = csv . writer ( csv_file ) [EOL] writer . writerows ( csv_data + longest_fail ) [EOL] [EOL] longest_timeout = sorted ( test_results [ [string] ] , key = lambda x : x [ [number] ] , reverse = True ) [EOL] with open ( [string] , [string] ) as csv_file : [EOL] writer = csv . writer ( csv_file ) [EOL] writer . writerows ( csv_data + longest_timeout ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._writer$ 0 0 0 $_csv._writer$ 0 0 0 0 $_csv._writer$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._writer$ 0 0 0 $_csv._writer$ 0 0 0 0 $_csv._writer$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._writer$ 0 0 0 $_csv._writer$ 0 0 0 0 $_csv._writer$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $typing.List[typing.Any]$ 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Any , List [EOL] import subprocess [EOL] import typing [EOL] import contextlib [EOL] import json [EOL] import os [EOL] import signal [EOL] import subprocess [EOL] import sys [EOL] import time [EOL] [EOL] [EOL] def main ( avd_name , apk_path , * args ) : [EOL] emulator_port = [string] [EOL] emulator_args = [ tool_path ( [string] , [string] ) , [string] + avd_name , [string] , [string] , [string] , [string] , [string] , [string] , [string] , emulator_port , ] [EOL] with terminate_on_exit ( emulator_args , stdout = sys . stderr ) as emulator_process : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] if emulator_process . poll ( ) is not None : [EOL] [comment] [EOL] [comment] [EOL] print ( [string] ) [EOL] return [number] [EOL] [EOL] adb = [ tool_path ( [string] , [string] ) , [string] , [string] + emulator_port ] [EOL] [EOL] with terminate_on_exit ( adb + [ [string] ] ) as wait_for_device : [EOL] wait_for_device . wait ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] wait_for_boot ( adb ) [EOL] [EOL] [comment] [EOL] check_call ( adb + [ [string] , [string] , apk_path ] ) [EOL] args = list ( args ) [EOL] write_user_stylesheets ( adb , args ) [EOL] write_hosts_file ( adb ) [EOL] [EOL] json_params = shell_quote ( json . dumps ( args ) ) [EOL] extra = [string] + json_params [EOL] cmd = [string] + extra + [string] [EOL] check_call ( adb + [ [string] , cmd ] , stdout = sys . stderr ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] logcat_args = [ [string] , [string] , [string] , ] [EOL] with terminate_on_exit ( adb + [ [string] ] + logcat_args ) as logcat : [EOL] [EOL] [comment] [EOL] forward_webdriver ( adb , args ) [EOL] [EOL] [comment] [EOL] logcat . wait ( ) [EOL] [EOL] [EOL] def tool_path ( directory , bin_name ) : [EOL] if [string] in os . environ : [EOL] path = os . path . join ( os . environ [ [string] ] , directory , bin_name ) [EOL] if os . path . exists ( path ) : [EOL] return path [EOL] [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] , [string] , directory , bin_name ) [EOL] if os . path . exists ( path ) : [EOL] return path [EOL] [EOL] return bin_name [EOL] [EOL] [EOL] @ contextlib . contextmanager def terminate_on_exit ( * args , ** kwargs ) : [EOL] process = subprocess . Popen ( * args , ** kwargs ) [EOL] try : [EOL] yield process [EOL] finally : [EOL] if process . poll ( ) is None : [EOL] [comment] [EOL] process . terminate ( ) [EOL] [EOL] [EOL] [comment] [EOL] def wait_for_boot ( adb ) : [EOL] while [number] : [EOL] with terminate_on_exit ( adb + [ [string] , [string] , [string] ] , stdout = subprocess . PIPE , ) as getprop : [EOL] stdout , stderr = getprop . communicate ( ) [EOL] if [string] in stdout : [EOL] return [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def call ( * args , ** kwargs ) : [EOL] with terminate_on_exit ( * args , ** kwargs ) as process : [EOL] return process . wait ( ) [EOL] [EOL] [EOL] def check_call ( * args , ** kwargs ) : [EOL] exit_code = call ( * args , ** kwargs ) [EOL] if exit_code != [number] : [EOL] sys . exit ( exit_code ) [EOL] [EOL] [EOL] def write_user_stylesheets ( adb , args ) : [EOL] data_dir = [string] [EOL] check_call ( adb + [ [string] , [string] % data_dir ] ) [EOL] for i , ( pos , path ) in enumerate ( extract_args ( [string] , args ) ) : [EOL] remote_path = [string] % ( data_dir , i ) [EOL] args [ pos ] = remote_path [EOL] check_call ( adb + [ [string] , path , remote_path ] , stdout = sys . stderr ) [EOL] [EOL] [EOL] def write_hosts_file ( adb ) : [EOL] hosts_file = os . environ . get ( [string] ) [EOL] if hosts_file : [EOL] data_dir = [string] [EOL] check_call ( adb + [ [string] , [string] % data_dir ] ) [EOL] remote_path = data_dir + [string] [EOL] check_call ( adb + [ [string] , hosts_file , remote_path ] , stdout = sys . stderr ) [EOL] [EOL] [EOL] def forward_webdriver ( adb , args ) : [EOL] webdriver_port = extract_arg ( [string] , args ) [EOL] if webdriver_port is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] wait_for_tcp_server ( adb , webdriver_port ) [EOL] [EOL] port = [string] % webdriver_port [EOL] check_call ( adb + [ [string] , port , port ] ) [EOL] sys . stderr . write ( [string] % webdriver_port ) [EOL] [EOL] split = os . environ . get ( [string] , [string] ) . split ( [string] ) [EOL] ports = [ int ( part ) for part in split if part ] [EOL] for port in ports : [EOL] port = [string] % port [EOL] check_call ( adb + [ [string] , port , port ] ) [EOL] if ports : [EOL] sys . stderr . write ( [string] % [string] . join ( map ( str , ports ) ) ) [EOL] [EOL] [EOL] def extract_arg ( name , args ) : [EOL] for _ , arg in extract_args ( name , args ) : [EOL] return arg [EOL] [EOL] [EOL] def extract_args ( name , args ) : [EOL] assert [string] not in name [EOL] previous_arg_matches = False [EOL] for i , arg in enumerate ( args ) : [EOL] if previous_arg_matches : [EOL] yield i , arg [EOL] previous_arg_matches = arg == name [EOL] [EOL] arg , sep , value = arg . partition ( [string] ) [EOL] if arg == name and sep == [string] : [EOL] yield i , value [EOL] [EOL] [EOL] def wait_for_tcp_server ( adb , port ) : [EOL] while call ( adb + [ [string] , [string] % port ] , stdout = sys . stderr ) != [number] : [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] [comment] [EOL] def shell_quote ( arg ) : [EOL] [comment] [EOL] [comment] [EOL] return [string] + arg . replace ( [string] , [string] ) + [string] [EOL] [EOL] [EOL] def interrupt ( _signum , _frame ) : [EOL] raise KeyboardInterrupt [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) < [number] : [EOL] print ( [string] % sys . argv [ [number] ] ) [EOL] print ( [string] % sys . argv [ [number] ] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] signal . signal ( signal . SIGTERM , interrupt ) [EOL] sys . exit ( main ( * sys . argv [ [number] : ] ) ) [EOL] except KeyboardInterrupt : [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , List [EOL] import typing [EOL] import os [EOL] [EOL] test_root = os . path . join ( [string] , [string] , [string] ) [EOL] meta_root = os . path . join ( [string] , [string] , [string] ) [EOL] [EOL] test_counts = { } [EOL] meta_counts = { } [EOL] [EOL] for base_dir , dir_names , files in os . walk ( test_root ) : [EOL] if base_dir == test_root : [EOL] continue [EOL] [EOL] rel_base = os . path . relpath ( base_dir , test_root ) [EOL] if not os . path . exists ( os . path . join ( meta_root , rel_base ) ) : [EOL] continue [EOL] [EOL] test_files = [ ] [EOL] exts = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] for f in files : [EOL] for ext in exts : [EOL] if f . endswith ( ext ) : [EOL] test_files += [ f ] [EOL] test_counts [ rel_base ] = len ( test_files ) [EOL] [EOL] for base_dir , dir_names , files in os . walk ( meta_root ) : [EOL] if base_dir == meta_root : [EOL] continue [EOL] [EOL] rel_base = os . path . relpath ( base_dir , meta_root ) [EOL] num_files = len ( files ) [EOL] if [string] in files : [EOL] num_files -= [number] [EOL] meta_counts [ rel_base ] = num_files [EOL] [EOL] final_counts = [ ] [EOL] for ( test_dir , test_count ) in test_counts . items ( ) : [EOL] if not test_count : [EOL] continue [EOL] meta_count = meta_counts . get ( test_dir , [number] ) [EOL] final_counts += [ ( test_dir , test_count , meta_count ) ] [EOL] [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] s = sorted ( final_counts , key = lambda x : x [ [number] ] / x [ [number] ] ) [EOL] for ( test_dir , test_count , meta_count ) in reversed ( sorted ( s , key = lambda x : x [ [number] ] ) ) : [EOL] if not meta_count : [EOL] continue [EOL] print ( [string] % ( test_dir , meta_count / test_count * [number] , test_count , meta_count ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import subprocess [EOL] import typing [EOL] [docstring] [EOL] import subprocess [EOL] [EOL] [EOL] def start_servo ( port , resolution ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] cmds = [string] + port + [string] + resolution [EOL] process = subprocess . Popen ( cmds , shell = True , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] return process [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , List , Type , Tuple , Any [EOL] import etc [EOL] import typing [EOL] [docstring] [EOL] [EOL] import gdb [EOL] [EOL] [EOL] [comment] [EOL] class AuPrinter : [EOL] def __init__ ( self , val ) : [EOL] self . val = val [EOL] [EOL] def to_string ( self ) : [EOL] i32_type = gdb . lookup_type ( [string] ) [EOL] au = self . val . cast ( i32_type ) [EOL] return [string] . format ( au / [number] ) [EOL] [EOL] [EOL] [comment] [EOL] class BitFieldU8Printer : [EOL] def __init__ ( self , val ) : [EOL] self . val = val [EOL] [EOL] def to_string ( self ) : [EOL] u8_type = gdb . lookup_type ( [string] ) [EOL] value = self . val . cast ( u8_type ) [EOL] return [string] . format ( int ( value ) ) [EOL] [EOL] [EOL] [comment] [EOL] class ChildPrinter : [EOL] def __init__ ( self , val ) : [EOL] self . val = val [EOL] [EOL] def children ( self ) : [EOL] children = [ ] [EOL] for f in self . val . type . fields ( ) : [EOL] children . append ( ( f . name , self . val [ f . name ] ) ) [EOL] return children [EOL] [EOL] def to_string ( self ) : [EOL] return None [EOL] [EOL] [EOL] [comment] [EOL] class TrustedNodeAddressPrinter : [EOL] def __init__ ( self , val ) : [EOL] self . val = val [EOL] [EOL] def children ( self ) : [EOL] node_type = gdb . lookup_type ( [string] ) . pointer ( ) [EOL] value = self . val . cast ( node_type ) [EOL] return [ ( [string] , value ) ] [EOL] [EOL] def to_string ( self ) : [EOL] return self . val . address [EOL] [EOL] [EOL] [comment] [EOL] class NodeTypeIdPrinter : [EOL] def __init__ ( self , val ) : [EOL] self . val = val [EOL] [EOL] def to_string ( self ) : [EOL] u8_ptr_type = gdb . lookup_type ( [string] ) . pointer ( ) [EOL] enum_0 = self . val . address . cast ( u8_ptr_type ) . dereference ( ) [EOL] enum_type = self . val . type . fields ( ) [ int ( enum_0 ) ] . type [EOL] return str ( enum_type ) . lstrip ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] class OptionPrinter : [EOL] def __init__ ( self , val ) : [EOL] self . val = val [EOL] [EOL] def is_some ( self ) : [EOL] [comment] [EOL] d_size = self . val . type . fields ( ) [ [number] ] . type . sizeof [EOL] [EOL] if d_size > [number] and d_size <= [number] : [EOL] [comment] [EOL] ptr = self . val . address . cast ( gdb . lookup_type ( [string] ) . pointer ( ) ) [EOL] discriminator = int ( ptr . dereference ( ) ) [EOL] return discriminator != [number] [EOL] [EOL] raise [string] [EOL] [EOL] def children ( self ) : [EOL] if self . is_some ( ) : [EOL] option_type = self . val . type [EOL] [EOL] [comment] [EOL] ptr = self . val . address . cast ( gdb . lookup_type ( [string] ) . pointer ( ) ) [EOL] t_size = option_type . sizeof [EOL] value_type = option_type . fields ( ) [ [number] ] . type . fields ( ) [ [number] ] . type [EOL] v_size = value_type . sizeof [EOL] data_ptr = ( ptr + t_size - v_size ) . cast ( value_type . pointer ( ) ) . dereference ( ) [EOL] return [ ( [string] , data_ptr ) ] [EOL] return [ ( [string] , None ) ] [EOL] [EOL] def to_string ( self ) : [EOL] return None [EOL] [EOL] [EOL] [comment] [EOL] class TestPrinter : [EOL] def __init__ ( self , val ) : [EOL] self . val = val [EOL] [EOL] def to_string ( self ) : [EOL] return [string] . format ( str ( self . val . type ) ) [EOL] [EOL] [EOL] type_map = [ ( [string] , AuPrinter ) , ( [string] , BitFieldU8Printer ) , ( [string] , ChildPrinter ) , ( [string] , ChildPrinter ) , ( [string] , TrustedNodeAddressPrinter ) , ( [string] , NodeTypeIdPrinter ) , ( [string] , OptionPrinter ) , ] [EOL] [EOL] [EOL] def lookup_servo_type ( val ) : [EOL] val_type = str ( val . type ) [EOL] for ( type_name , printer ) in type_map : [EOL] if val_type == type_name or val_type . endswith ( [string] + type_name ) : [EOL] return printer ( val ) [EOL] return None [EOL] [comment] [EOL] [EOL] [EOL] def register_printers ( obj ) : [EOL] gdb . pretty_printers . append ( lookup_servo_type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[typing.Union[etc.servo_gdb.AuPrinter,etc.servo_gdb.BitFieldU8Printer,etc.servo_gdb.ChildPrinter,etc.servo_gdb.NodeTypeIdPrinter,etc.servo_gdb.OptionPrinter,etc.servo_gdb.TrustedNodeAddressPrinter]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Type[typing.Union[etc.servo_gdb.AuPrinter,etc.servo_gdb.BitFieldU8Printer,etc.servo_gdb.ChildPrinter,etc.servo_gdb.NodeTypeIdPrinter,etc.servo_gdb.OptionPrinter,etc.servo_gdb.TrustedNodeAddressPrinter]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import requests [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import json [EOL] import requests [EOL] import start_servo [EOL] import time [EOL] import base64 [EOL] import sys [EOL] import getopt [EOL] [EOL] [EOL] def print_help ( ) : [EOL] [EOL] print ( [string] ) [EOL] print ( [string] + [string] + [string] ) [EOL] [EOL] [EOL] def servo_ready_to_accept ( url , payload , headers ) : [EOL] while (True) : [EOL] [EOL] try : [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] session_request = requests . post ( url , data = payload , headers = headers ) [EOL] json_string = session_request . json ( ) [EOL] [comment] [EOL] break [EOL] except Exception as e : [EOL] time . sleep ( [number] ) [EOL] print ( [string] , e ) [EOL] return json_string [EOL] [EOL] [EOL] def ensure_screenshots_directory_exists ( ) : [EOL] if not os . path . exists ( [string] ) : [EOL] os . makedirs ( [string] ) [EOL] [EOL] [EOL] def render_html_files ( num_of_files , url , file_url , json_string , headers , cwd ) : [EOL] for x in range ( num_of_files ) : [EOL] [EOL] json_data = { } [EOL] json_data [ [string] ] = [string] . format ( file_url , str ( x ) ) [EOL] print ( json_data [ [string] ] ) [EOL] json_data = json . dumps ( json_data ) [EOL] requests . post ( [string] . format ( url , json_string [ [string] ] [ [string] ] ) , data = json_data , headers = headers ) [EOL] screenshot_request = requests . get ( [string] . format ( url , json_string [ [string] ] [ [string] ] ) ) [EOL] image_data_encoded = screenshot_request . json ( ) [ [string] ] [EOL] with open ( [string] . format ( str ( x ) ) , [string] ) as image_file : [EOL] image_file . write ( base64 . decodebytes ( image_data_encoded . encode ( [string] ) ) ) [EOL] print ( [string] ) [EOL] print ( [string] [string] . format ( cwd , str ( x ) ) ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def main ( argv ) : [comment] [EOL] [EOL] [comment] [EOL] port = [string] [EOL] resolution = [string] [EOL] file_url = [string] [EOL] num_of_files = [string] [EOL] cwd = os . getcwd ( ) [EOL] url = [string] [EOL] payload = [string] [EOL] headers = { [string] : [string] , [string] : [string] } [EOL] json_string = [string] [EOL] try : [EOL] [comment] [EOL] opts , args = getopt . getopt ( argv , [string] , [ [string] , [string] , [string] , [string] ] ) [EOL] except getopt . GetoptError : [EOL] [comment] [EOL] [comment] [EOL] print_help ( ) [EOL] sys . exit ( [number] ) [EOL] for opt , arg in opts : [EOL] if opt == [string] : [comment] [EOL] print_help ( ) [EOL] sys . exit ( ) [EOL] elif opt in ( [string] , [string] ) : [comment] [EOL] port = arg [EOL] elif opt in ( [string] , [string] ) : [comment] [EOL] file_url = arg [EOL] elif opt in ( [string] , [string] ) : [comment] [EOL] resolution = arg [EOL] elif opt in ( [string] , [string] ) : [comment] [EOL] num_of_files = arg [EOL] [EOL] url = [string] . format ( port ) [EOL] num_of_files = int ( num_of_files ) [EOL] [EOL] [comment] [EOL] start_servo . start_servo ( port , resolution ) [EOL] [EOL] [comment] [EOL] json_string = servo_ready_to_accept ( url , payload , headers ) [EOL] [EOL] [comment] [EOL] ensure_screenshots_directory_exists ( ) [EOL] [EOL] [comment] [EOL] render_html_files ( num_of_files , url , file_url , json_string , headers , cwd ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) < [number] : [EOL] print_help ( ) [EOL] sys . exit ( ) [EOL] else : [EOL] main ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] import boto3 [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( description = ( [string] [string] [string] ) ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] s3 = boto3 . client ( [string] ) [EOL] BUCKET = [string] [EOL] s3 . upload_file ( args . perf_file , BUCKET , args . perf_key ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , List , Dict , Tuple , Any [EOL] import typing [EOL] import runner [EOL] import pytest [EOL] [EOL] [EOL] def test_log_parser ( ) : [EOL] mock_url = [string] [EOL] mock_log = [string] [EOL] [EOL] expected = [ { [string] : [string] , [string] : [number] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : None , [string] : None } ] [EOL] result = runner . parse_log ( mock_log , mock_url ) [EOL] assert ( expected == list ( result ) ) [EOL] [EOL] [EOL] def test_log_parser_complex ( ) : [EOL] mock_log = [string] [EOL] mock_url = [string] [EOL] expected = [ { [string] : [string] , [string] : [number] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : None , [string] : None } ] [EOL] result = runner . parse_log ( mock_log , mock_url ) [EOL] assert ( expected == list ( result ) ) [EOL] [EOL] [EOL] def test_log_parser_empty ( ) : [EOL] mock_log = [string] [EOL] mock_testcase = [string] [EOL] [EOL] expected = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] } ] [EOL] result = runner . parse_log ( mock_log , mock_testcase ) [EOL] assert ( expected == list ( result ) ) [EOL] [EOL] [EOL] def test_log_parser_error ( ) : [EOL] mock_log = [string] [EOL] mock_testcase = [string] [EOL] [EOL] expected = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] } ] [EOL] result = runner . parse_log ( mock_log , mock_testcase ) [EOL] assert ( expected == list ( result ) ) [EOL] [EOL] [EOL] def test_log_parser_bad_testcase_name ( ) : [EOL] mock_testcase = [string] [EOL] [comment] [EOL] mock_log = [string] [EOL] [EOL] expected = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] } ] [EOL] result = runner . parse_log ( mock_log , mock_testcase ) [EOL] assert ( expected == list ( result ) ) [EOL] [EOL] [EOL] def test_manifest_loader ( ) : [EOL] [EOL] text = [string] [EOL] expected = [ ( [string] , False ) , ( [string] , False ) , ( [string] , False ) ] [EOL] assert ( expected == list ( runner . parse_manifest ( text ) ) ) [EOL] [EOL] [EOL] def test_manifest_loader_async ( ) : [EOL] [EOL] text = [string] [EOL] expected = [ ( [string] , False ) , ( [string] , True ) , ] [EOL] assert ( expected == list ( runner . parse_manifest ( text ) ) ) [EOL] [EOL] [EOL] def test_filter_result_by_manifest ( ) : [EOL] input_json = [ { [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [number] , } ] [EOL] [EOL] expected = [ { [string] : [string] , [string] : [number] , } ] [EOL] [EOL] manifest = [ ( [string] , False ) ] [EOL] [EOL] assert ( expected == runner . filter_result_by_manifest ( input_json , manifest ) ) [EOL] [EOL] [EOL] def test_filter_result_by_manifest_error ( ) : [EOL] input_json = [ { [string] : [string] , [string] : [number] , } ] [EOL] [EOL] manifest = [ ( [string] , False ) , ( [string] , False ) ] [EOL] [EOL] with pytest . raises ( Exception ) as execinfo : [EOL] runner . filter_result_by_manifest ( input_json , manifest ) [EOL] assert [string] in str ( execinfo . value ) [EOL] [EOL] [EOL] def test_take_result_median_odd ( ) : [EOL] input_json = [ { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [number] } ] [EOL] [EOL] expected = [ { [string] : [string] , [string] : [number] , [string] : [number] } ] [EOL] [EOL] assert ( expected == runner . take_result_median ( input_json , len ( input_json ) ) ) [EOL] [EOL] [EOL] def test_take_result_median_even ( ) : [EOL] input_json = [ { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [number] } ] [EOL] [EOL] expected = [ { [string] : [string] , [string] : [number] , [string] : [number] } ] [EOL] [EOL] assert ( expected == runner . take_result_median ( input_json , len ( input_json ) ) ) [EOL] [EOL] [EOL] def test_take_result_median_error ( ) : [EOL] input_json = [ { [string] : [string] , [string] : None , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [number] } ] [EOL] [EOL] expected = [ { [string] : [string] , [string] : [number] , [string] : [number] } ] [EOL] [EOL] assert ( expected == runner . take_result_median ( input_json , len ( input_json ) ) ) [EOL] [EOL] [EOL] def test_log_result ( ) : [EOL] results = [ { [string] : [string] , [string] : - [number] } , { [string] : [string] , [string] : - [number] } , { [string] : [string] , [string] : [number] } ] [EOL] [EOL] expected = [string] [EOL] assert ( expected == runner . format_result_summary ( results ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Iterator , Dict , Any , List [EOL] import functools [EOL] import csv [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] import csv [EOL] import itertools [EOL] import json [EOL] import os [EOL] import platform [EOL] import subprocess [EOL] from datetime import datetime [EOL] from functools import partial [EOL] from statistics import median , StatisticsError [EOL] from urllib . parse import urlsplit , urlunsplit , urljoin [EOL] [EOL] [EOL] DATE = datetime . now ( ) . strftime ( [string] ) [EOL] MACHINE = platform . machine ( ) [EOL] SYSTEM = platform . system ( ) [EOL] [EOL] [EOL] def load_manifest ( filename ) : [EOL] with open ( filename , [string] ) as f : [EOL] text = f . read ( ) [EOL] return list ( parse_manifest ( text ) ) [EOL] [EOL] [EOL] def parse_manifest ( text ) : [EOL] lines = filter ( lambda x : x != [string] and not x . startswith ( [string] ) , map ( lambda x : x . strip ( ) , text . splitlines ( ) ) ) [EOL] output = [ ] [EOL] for line in lines : [EOL] if line . split ( [string] ) [ [number] ] == [string] : [EOL] output . append ( ( line . split ( [string] ) [ [number] ] , True ) ) [EOL] else : [EOL] output . append ( ( line . split ( [string] ) [ [number] ] , False ) ) [EOL] return output [EOL] [EOL] [EOL] def testcase_url ( base , testcase ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ( scheme , netloc , path , query , fragment ) = urlsplit ( testcase ) [EOL] relative_url = urlunsplit ( ( [string] , [string] , [string] + path , query , fragment ) ) [EOL] absolute_url = urljoin ( base , relative_url ) [EOL] return absolute_url [EOL] [EOL] [EOL] def execute_test ( url , command , timeout ) : [EOL] try : [EOL] return subprocess . check_output ( command , stderr = subprocess . STDOUT , timeout = timeout ) [EOL] except subprocess . CalledProcessError as e : [EOL] print ( [string] ) [EOL] print ( e ) [EOL] print ( [string] . format ( [string] . join ( command ) ) ) [EOL] except subprocess . TimeoutExpired : [EOL] print ( [string] . format ( url ) ) [EOL] return [string] [EOL] [EOL] [EOL] def run_servo_test ( testcase , url , date , timeout , is_async ) : [EOL] if is_async : [EOL] print ( [string] ) [EOL] [comment] [EOL] return parse_log ( [string] , testcase , url , date ) [EOL] [EOL] ua_script_path = [string] . format ( os . getcwd ( ) ) [EOL] command = [ [string] , url , [string] + ua_script_path , [string] , [string] , [string] , [string] ] [EOL] log = [string] [EOL] try : [EOL] log = subprocess . check_output ( command , stderr = subprocess . STDOUT , timeout = timeout ) [EOL] except subprocess . CalledProcessError as e : [EOL] print ( [string] ) [EOL] print ( e ) [EOL] print ( [string] . format ( [string] . join ( command ) ) ) [EOL] except subprocess . TimeoutExpired : [EOL] print ( [string] . format ( testcase ) ) [EOL] return parse_log ( log , testcase , url , date ) [EOL] [EOL] [EOL] def parse_log ( log , testcase , url , date ) : [EOL] blocks = [ ] [EOL] block = [ ] [EOL] copy = False [EOL] for line_bytes in log . splitlines ( ) : [EOL] line = line_bytes . decode ( [string] ) [EOL] [EOL] if line . strip ( ) == ( [string] ) : [EOL] copy = True [EOL] elif line . strip ( ) == ( [string] ) : [EOL] copy = False [EOL] blocks . append ( block ) [EOL] block = [ ] [EOL] elif copy and line . strip ( ) . startswith ( [string] ) : [EOL] block . append ( line ) [EOL] [EOL] def parse_block ( block ) : [EOL] timing = { } [EOL] for line in block : [EOL] try : [EOL] ( _ , key , value ) = line . split ( [string] ) [EOL] except ValueError : [EOL] print ( [string] ) [EOL] print ( line ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( log ) [EOL] print ( [string] ) [EOL] return None [EOL] [EOL] if key == [string] or key == [string] : [EOL] timing [ key ] = value [EOL] else : [EOL] timing [ key ] = None if ( value == [string] ) else int ( value ) [EOL] [EOL] return timing [EOL] [EOL] def valid_timing ( timing , url = None ) : [EOL] if ( timing is None or testcase is None or timing . get ( [string] ) == [string] or timing . get ( [string] ) != url ) : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def create_placeholder ( testcase ) : [EOL] return { [string] : SYSTEM , [string] : MACHINE , [string] : date , [string] : testcase , [string] : [string] , [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] def set_testcase ( timing , testcase = None , date = None ) : [EOL] timing [ [string] ] = testcase [EOL] timing [ [string] ] = SYSTEM [EOL] timing [ [string] ] = MACHINE [EOL] timing [ [string] ] = date [EOL] return timing [EOL] [EOL] valid_timing_for_case = partial ( valid_timing , url = url ) [EOL] set_testcase_for_case = partial ( set_testcase , testcase = testcase , date = date ) [EOL] timings = list ( map ( set_testcase_for_case , filter ( valid_timing_for_case , map ( parse_block , blocks ) ) ) ) [EOL] [EOL] if len ( timings ) == [number] : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( log ) [EOL] print ( [string] ) [EOL] [EOL] return [ create_placeholder ( testcase ) ] [EOL] else : [EOL] return timings [EOL] [EOL] [EOL] def filter_result_by_manifest ( result_json , manifest , base ) : [EOL] filtered = [ ] [EOL] for name , is_async in manifest : [EOL] url = testcase_url ( base , name ) [EOL] match = [ tc for tc in result_json if tc [ [string] ] == url ] [EOL] if len ( match ) == [number] : [EOL] raise Exception ( ( [string] [string] [string] ) . format ( name ) ) [EOL] filtered += match [EOL] return filtered [EOL] [EOL] [EOL] def take_result_median ( result_json , expected_runs ) : [EOL] median_results = [ ] [EOL] for k , g in itertools . groupby ( result_json , lambda x : x [ [string] ] ) : [EOL] group = list ( g ) [EOL] if len ( group ) != expected_runs : [EOL] print ( ( [string] [string] ) . format ( k ) ) [EOL] [EOL] median_result = { } [EOL] for k , _ in group [ [number] ] . items ( ) : [EOL] if k == [string] or k == [string] : [EOL] median_result [ k ] = group [ [number] ] [ k ] [EOL] else : [EOL] try : [EOL] median_result [ k ] = median ( [ x [ k ] for x in group if x [ k ] is not None ] ) [EOL] except StatisticsError : [EOL] median_result [ k ] = - [number] [EOL] median_results . append ( median_result ) [EOL] return median_results [EOL] [EOL] [EOL] def save_result_json ( results , filename , manifest , expected_runs , base ) : [EOL] [EOL] results = filter_result_by_manifest ( results , manifest , base ) [EOL] results = take_result_median ( results , expected_runs ) [EOL] [EOL] if len ( results ) == [number] : [EOL] with open ( filename , [string] ) as f : [EOL] json . dump ( [string] , f , indent = [number] ) [EOL] else : [EOL] with open ( filename , [string] ) as f : [EOL] json . dump ( results , f , indent = [number] ) [EOL] print ( [string] . format ( filename ) ) [EOL] [EOL] [EOL] def save_result_csv ( results , filename , manifest , expected_runs , base ) : [EOL] [EOL] fieldnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] successes = [ r for r in results if r [ [string] ] != - [number] ] [EOL] [EOL] with open ( filename , [string] , encoding = [string] ) as csvfile : [EOL] writer = csv . DictWriter ( csvfile , fieldnames ) [EOL] writer . writeheader ( ) [EOL] writer . writerows ( successes ) [EOL] [EOL] [EOL] def format_result_summary ( results ) : [EOL] failures = list ( filter ( lambda x : x [ [string] ] == - [number] , results ) ) [EOL] result_log = [string] . format ( total = len ( results ) , suc = len ( list ( filter ( lambda x : x [ [string] ] != - [number] , results ) ) ) , fail = len ( failures ) ) [EOL] uniq_failures = list ( set ( map ( lambda x : x [ [string] ] , failures ) ) ) [EOL] for failure in uniq_failures : [EOL] result_log += [string] . format ( failure ) [EOL] [EOL] result_log += [string] [EOL] [EOL] return result_log [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = ( [string] [string] ) ) [EOL] parser . add_argument ( [string] , type = str , default = None , help = ( [string] ) ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = ( [string] [string] ) ) [EOL] args = parser . parse_args ( ) [EOL] if args . engine == [string] : [EOL] run_test = run_servo_test [EOL] elif args . engine == [string] : [EOL] import gecko_driver [comment] [EOL] run_test = gecko_driver . run_gecko_test [EOL] date = args . date or DATE [EOL] try : [EOL] [comment] [EOL] testcases = load_manifest ( args . tp5_manifest ) [EOL] results = [ ] [EOL] for testcase , is_async in testcases : [EOL] url = testcase_url ( args . base , testcase ) [EOL] for run in range ( args . runs ) : [EOL] print ( [string] . format ( run + [number] , args . runs , url ) ) [EOL] [comment] [EOL] [comment] [EOL] results += run_test ( testcase , url , date , args . timeout , is_async ) [EOL] print ( [string] ) [EOL] [comment] [EOL] [EOL] print ( format_result_summary ( results ) ) [EOL] if args . output_file . endswith ( [string] ) : [EOL] save_result_csv ( results , args . output_file , testcases , args . runs , args . base ) [EOL] else : [EOL] save_result_json ( results , args . output_file , testcases , args . runs , args . base ) [EOL] [EOL] except KeyboardInterrupt : [EOL] print ( [string] ) [EOL] save_result_json ( results , args . output_file , testcases , args . runs ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , List [EOL] import typing [EOL] from contextlib import contextmanager [EOL] import json [EOL] import os [EOL] from selenium import webdriver [EOL] from selenium . common . exceptions import TimeoutException [EOL] import sys [EOL] [EOL] [EOL] @ contextmanager def create_gecko_session ( ) : [EOL] try : [EOL] firefox_binary = os . environ [ [string] ] [EOL] except KeyError : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] sys . exit ( ) [EOL] [EOL] driver = webdriver . Firefox ( firefox_binary = firefox_binary ) [EOL] yield driver [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] driver . quit ( ) [EOL] [EOL] [EOL] def generate_placeholder ( testcase ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] timings = { [string] : testcase , [string] : [string] } [EOL] [EOL] timing_names = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] for name in timing_names : [EOL] timings [ name ] = [number] if name == [string] else - [number] [EOL] [EOL] return [ timings ] [EOL] [EOL] [EOL] def run_gecko_test ( testcase , url , date , timeout , is_async ) : [EOL] with create_gecko_session ( ) as driver : [EOL] driver . set_page_load_timeout ( timeout ) [EOL] try : [EOL] driver . get ( url ) [EOL] except TimeoutException : [EOL] print ( [string] ) [EOL] return generate_placeholder ( testcase ) [EOL] [EOL] try : [EOL] timings = { [string] : testcase , [string] : driver . title . replace ( [string] , [string] ) } [EOL] [EOL] timings . update ( json . loads ( driver . execute_script ( [string] ) ) ) [EOL] except Exception : [EOL] [comment] [EOL] [comment] [EOL] print ( [string] ) [EOL] return generate_placeholder ( testcase ) [EOL] [EOL] if is_async : [EOL] [comment] [EOL] driver . implicitly_wait ( [number] ) [comment] [EOL] driver . find_element_by_id ( [string] ) [EOL] timings . update ( json . loads ( driver . execute_script ( [string] ) ) ) [EOL] [EOL] return [ timings ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] from pprint import pprint [EOL] url = [string] [EOL] pprint ( run_gecko_test ( url , [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Dict [EOL] import functools [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] from functools import partial , reduce [EOL] import json [EOL] import operator [EOL] import os [EOL] import random [EOL] import string [EOL] from thclient import ( TreeherderClient , TreeherderResultSetCollection , TreeherderJobCollection ) [EOL] import time [EOL] [EOL] from runner import format_result_summary [EOL] [EOL] [EOL] def geometric_mean ( iterable ) : [EOL] filtered = list ( filter ( lambda x : x > [number] , iterable ) ) [EOL] return ( reduce ( operator . mul , filtered ) ) ** ( [number] / len ( filtered ) ) [EOL] [EOL] [EOL] def format_testcase_name ( name ) : [EOL] temp = name . replace ( [string] , [string] ) [EOL] temp = temp . replace ( [string] , [string] ) [EOL] temp = temp . split ( [string] ) [ [number] ] [EOL] temp = temp [ [number] : [number] ] [EOL] return temp [EOL] [EOL] [EOL] def format_perf_data ( perf_json , engine = [string] ) : [EOL] suites = [ ] [EOL] measurement = [string] [comment] [EOL] [EOL] def get_time_from_nav_start ( timings , measurement ) : [EOL] return timings [ measurement ] - timings [ [string] ] [EOL] [EOL] measurementFromNavStart = partial ( get_time_from_nav_start , measurement = measurement ) [EOL] [EOL] if ( engine == [string] ) : [EOL] name = [string] . format ( measurement ) [EOL] else : [EOL] name = measurement [EOL] [EOL] suite = { [string] : name , [string] : geometric_mean ( map ( measurementFromNavStart , perf_json ) ) , [string] : [ ] } [EOL] for testcase in perf_json : [EOL] if measurementFromNavStart ( testcase ) < [number] : [EOL] value = - [number] [EOL] [comment] [EOL] else : [EOL] value = measurementFromNavStart ( testcase ) [EOL] [EOL] suite [ [string] ] . append ( { [string] : format_testcase_name ( testcase [ [string] ] ) , [string] : value } ) [EOL] [EOL] suites . append ( suite ) [EOL] [EOL] return { [string] : { [string] : { [string] : [string] } , [string] : suites } } [EOL] [EOL] [EOL] def create_resultset_collection ( dataset ) : [EOL] print ( [string] ) [EOL] print ( dataset ) [EOL] trsc = TreeherderResultSetCollection ( ) [EOL] [EOL] for data in dataset : [EOL] trs = trsc . get_resultset ( ) [EOL] [EOL] trs . add_push_timestamp ( data [ [string] ] ) [EOL] trs . add_revision ( data [ [string] ] ) [EOL] trs . add_author ( data [ [string] ] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] revisions = [ ] [EOL] for rev in data [ [string] ] : [EOL] tr = trs . get_revision ( ) [EOL] [EOL] tr . add_revision ( rev [ [string] ] ) [EOL] tr . add_author ( rev [ [string] ] ) [EOL] tr . add_comment ( rev [ [string] ] ) [EOL] tr . add_repository ( rev [ [string] ] ) [EOL] [EOL] revisions . append ( tr ) [EOL] trs . add_revisions ( revisions ) [EOL] [EOL] trsc . add ( trs ) [EOL] [EOL] return trsc [EOL] [EOL] [EOL] def create_job_collection ( dataset ) : [EOL] print ( [string] ) [EOL] print ( dataset ) [EOL] [EOL] tjc = TreeherderJobCollection ( ) [EOL] [EOL] for data in dataset : [EOL] tj = tjc . get_job ( ) [EOL] [EOL] tj . add_revision ( data [ [string] ] ) [EOL] tj . add_project ( data [ [string] ] ) [EOL] tj . add_coalesced_guid ( data [ [string] ] [ [string] ] ) [EOL] tj . add_job_guid ( data [ [string] ] [ [string] ] ) [EOL] tj . add_job_name ( data [ [string] ] [ [string] ] ) [EOL] tj . add_job_symbol ( data [ [string] ] [ [string] ] ) [EOL] tj . add_group_name ( data [ [string] ] [ [string] ] ) [EOL] tj . add_group_symbol ( data [ [string] ] [ [string] ] ) [EOL] tj . add_description ( data [ [string] ] [ [string] ] ) [EOL] tj . add_product_name ( data [ [string] ] [ [string] ] ) [EOL] tj . add_state ( data [ [string] ] [ [string] ] ) [EOL] tj . add_result ( data [ [string] ] [ [string] ] ) [EOL] tj . add_reason ( data [ [string] ] [ [string] ] ) [EOL] tj . add_who ( data [ [string] ] [ [string] ] ) [EOL] tj . add_tier ( data [ [string] ] [ [string] ] ) [EOL] tj . add_submit_timestamp ( data [ [string] ] [ [string] ] ) [EOL] tj . add_start_timestamp ( data [ [string] ] [ [string] ] ) [EOL] tj . add_end_timestamp ( data [ [string] ] [ [string] ] ) [EOL] tj . add_machine ( data [ [string] ] [ [string] ] ) [EOL] [EOL] tj . add_build_info ( data [ [string] ] [ [string] ] [ [string] ] , data [ [string] ] [ [string] ] [ [string] ] , data [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] tj . add_machine_info ( data [ [string] ] [ [string] ] [ [string] ] , data [ [string] ] [ [string] ] [ [string] ] , data [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] tj . add_option_collection ( data [ [string] ] [ [string] ] ) [EOL] [EOL] for artifact_data in data [ [string] ] [ [string] ] : [EOL] tj . add_artifact ( artifact_data [ [string] ] , artifact_data [ [string] ] , artifact_data [ [string] ] ) [EOL] tjc . add ( tj ) [EOL] [EOL] return tjc [EOL] [EOL] [EOL] [comment] [EOL] def submit ( perf_data , failures , revision , summary , engine ) : [EOL] [EOL] print ( [string] ) [EOL] print ( list ( map ( lambda x : x [ [string] ] , failures ) ) ) [EOL] [EOL] author = [string] . format ( revision [ [string] ] [ [string] ] , revision [ [string] ] [ [string] ] ) [EOL] [EOL] dataset = [ { [string] : revision [ [string] ] , [string] : author , [string] : int ( revision [ [string] ] [ [string] ] ) , [string] : [string] , [string] : [ { [string] : revision [ [string] ] , [string] : revision [ [string] ] , [string] : [string] , [string] : author } ] } ] [EOL] [EOL] trsc = create_resultset_collection ( dataset ) [EOL] [EOL] result = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] hashlen = len ( revision [ [string] ] ) [EOL] job_guid = [string] . join ( random . choice ( string . ascii_letters + string . digits ) for i in range ( hashlen ) ) [EOL] [EOL] if ( engine == [string] ) : [EOL] project = [string] [EOL] job_symbol = [string] [EOL] group_symbol = [string] [EOL] group_name = [string] [EOL] else : [EOL] project = [string] [EOL] job_symbol = [string] [EOL] group_symbol = [string] [EOL] group_name = [string] [EOL] [EOL] dataset = [ { [string] : project , [string] : revision [ [string] ] , [string] : { [string] : job_guid , [string] : project , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : job_symbol , [string] : group_symbol , [string] : group_name , [string] : str ( int ( time . time ( ) ) ) , [string] : str ( int ( time . time ( ) ) ) , [string] : str ( int ( time . time ( ) ) ) , [string] : [string] , [string] : result , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : True } , [string] : [number] , [string] : [ { [string] : [string] , [string] : [string] } ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : perf_data } , { [string] : [string] , [string] : [string] , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : summary } ] } } ] , [string] : [ ] } } ] [EOL] [EOL] tjc = create_job_collection ( dataset ) [EOL] [EOL] [comment] [EOL] cred = { [string] : os . environ [ [string] ] , [string] : os . environ [ [string] ] } [EOL] [EOL] client = TreeherderClient ( server_url = [string] , client_id = cred [ [string] ] , secret = cred [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] client . post_collection ( [string] , trsc ) [EOL] client . post_collection ( [string] , tjc ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( description = ( [string] [string] [string] [string] ) ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = ( [string] [string] ) ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] with open ( args . perf_json , [string] ) as f : [EOL] result_json = json . load ( f ) [EOL] [EOL] with open ( args . revision_json , [string] ) as f : [EOL] revision = json . load ( f ) [EOL] [EOL] perf_data = format_perf_data ( result_json , args . engine ) [EOL] failures = list ( filter ( lambda x : x [ [string] ] == - [number] , result_json ) ) [EOL] summary = format_result_summary ( result_json ) . replace ( [string] , [string] ) [EOL] [EOL] submit ( perf_data , failures , revision , summary , args . engine ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , List , Any , Dict [EOL] import typing [EOL] import submit_to_perfherder [EOL] [EOL] [EOL] def test_format_testcase_name ( ) : [EOL] assert ( [string] == submit_to_perfherder . format_testcase_name ( [string] ) ) [EOL] assert ( [string] == submit_to_perfherder . format_testcase_name ( ( [string] [string] ) ) ) [EOL] assert ( ( [string] [string] ) == submit_to_perfherder . format_testcase_name ( ( [string] [string] ) ) ) [EOL] assert ( [string] == submit_to_perfherder . format_testcase_name ( [string] ) ) [EOL] [EOL] [EOL] def test_format_perf_data ( ) : [EOL] mock_result = [ { [string] : None , [string] : [number] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [number] , [string] : None , [string] : None , [string] : None , [string] : [number] , [string] : None , [string] : [number] , [string] : [number] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [string] , [string] : [number] } , { [string] : None , [string] : [number] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [number] , [string] : None , [string] : None , [string] : None , [string] : [number] , [string] : None , [string] : [number] , [string] : [number] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : ( [string] [string] [string] ) , [string] : [number] } ] [EOL] [EOL] expected = { [string] : { [string] : { [string] : [string] } , [string] : [ { [string] : [string] , [string] : [number] , [string] : [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , ] } ] } } [EOL] result = submit_to_perfherder . format_perf_data ( mock_result ) [EOL] assert ( expected == result ) [EOL] [EOL] [EOL] def test_format_bad_perf_data ( ) : [EOL] mock_result = [ { [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [number] , [string] : ( [string] [string] [string] ) , [string] : [number] } ] [EOL] [EOL] expected = { [string] : { [string] : { [string] : [string] } , [string] : [ { [string] : [string] , [string] : [number] , [string] : [ { [string] : [string] , [string] : - [number] } , { [string] : [string] , [string] : [number] } , ] } ] } } [EOL] result = submit_to_perfherder . format_perf_data ( mock_result ) [EOL] assert ( expected == result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] import boto3 [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( description = ( [string] [string] [string] ) ) [EOL] parser . parse_args ( ) [EOL] [EOL] s3 = boto3 . resource ( [string] ) [EOL] BUCKET = [string] [EOL] POLICY = [string] [EOL] [EOL] s3 . BucketPolicy ( BUCKET ) . put ( Policy = POLICY ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Set , List , Dict , Type , Any [EOL] import etc [EOL] import typing [EOL] [docstring] [EOL] [EOL] import base64 [EOL] import contextlib [EOL] import datetime [EOL] import hashlib [EOL] import json [EOL] import os [EOL] import re [EOL] import subprocess [EOL] import sys [EOL] import taskcluster [EOL] [EOL] [EOL] [comment] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] class Config : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] self . task_name_template = [string] [EOL] self . index_prefix = [string] [EOL] self . index_read_only = False [EOL] self . scopes_for_all_subtasks = [ ] [EOL] self . routes_for_all_subtasks = [ ] [EOL] self . docker_image_build_worker_type = None [EOL] self . docker_images_expire_in = [string] [EOL] self . repacked_msi_files_expire_in = [string] [EOL] self . treeherder_repository_name = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . decision_task_id = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] self . task_owner = os . environ . get ( [string] ) [EOL] self . task_source = os . environ . get ( [string] ) [EOL] self . git_url = os . environ . get ( [string] ) [EOL] self . git_ref = os . environ . get ( [string] ) [EOL] self . git_sha = os . environ . get ( [string] ) [EOL] self . git_bundle_shallow_ref = [string] [EOL] [EOL] self . tc_root_url = os . environ . get ( [string] ) [EOL] self . default_provisioner_id = [string] [EOL] [EOL] [EOL] def tree_hash ( self ) : [EOL] if not hasattr ( self , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] output = subprocess . check_output ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . _tree_hash = output . decode ( [string] ) . strip ( ) [EOL] return self . _tree_hash [EOL] [EOL] def git_sha_is_current_head ( self ) : [EOL] output = subprocess . check_output ( [ [string] , [string] , [string] ] ) [EOL] self . git_sha = output . decode ( [string] ) . strip ( ) [EOL] [EOL] [EOL] class Shared : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] self . now = datetime . datetime . utcnow ( ) [EOL] self . found_or_created_indexed_tasks = { } [EOL] [EOL] options = { [string] : os . environ [ [string] ] } [EOL] self . queue_service = taskcluster . Queue ( options ) [EOL] self . index_service = taskcluster . Index ( options ) [EOL] [EOL] def from_now_json ( self , offset ) : [EOL] [docstring] [EOL] return taskcluster . stringDate ( taskcluster . fromNow ( offset , dateObj = self . now ) ) [EOL] [EOL] [EOL] CONFIG = Config ( ) [EOL] SHARED = Shared ( ) [EOL] [EOL] [EOL] def chaining ( op , attr ) : [EOL] def method ( self , * args , ** kwargs ) : [EOL] op ( self , attr , * args , ** kwargs ) [EOL] return self [EOL] return method [EOL] [EOL] [EOL] def append_to_attr ( self , attr , * args ) : getattr ( self , attr ) . extend ( args ) [EOL] def prepend_to_attr ( self , attr , * args ) : getattr ( self , attr ) [ [number] : [number] ] = list ( args ) [EOL] def update_attr ( self , attr , ** kwargs ) : getattr ( self , attr ) . update ( kwargs ) [EOL] [EOL] [EOL] class Task : [EOL] [docstring] [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] self . description = [string] [EOL] self . scheduler_id = [string] [EOL] self . provisioner_id = CONFIG . default_provisioner_id [EOL] self . worker_type = [string] [EOL] self . deadline_in = [string] [EOL] self . expires_in = [string] [EOL] self . index_and_artifacts_expire_in = self . expires_in [EOL] self . dependencies = [ ] [EOL] self . scopes = [ ] [EOL] self . routes = [ ] [EOL] self . extra = { } [EOL] self . treeherder_required = False [EOL] self . priority = None [comment] [EOL] self . git_fetch_url = CONFIG . git_url [EOL] self . git_fetch_ref = CONFIG . git_ref [EOL] self . git_checkout_sha = CONFIG . git_sha [EOL] [EOL] [comment] [EOL] with_description = chaining ( setattr , [string] ) [EOL] with_scheduler_id = chaining ( setattr , [string] ) [EOL] with_provisioner_id = chaining ( setattr , [string] ) [EOL] with_worker_type = chaining ( setattr , [string] ) [EOL] with_deadline_in = chaining ( setattr , [string] ) [EOL] with_expires_in = chaining ( setattr , [string] ) [EOL] with_index_and_artifacts_expire_in = chaining ( setattr , [string] ) [EOL] with_priority = chaining ( setattr , [string] ) [EOL] [EOL] with_dependencies = chaining ( append_to_attr , [string] ) [EOL] with_scopes = chaining ( append_to_attr , [string] ) [EOL] with_routes = chaining ( append_to_attr , [string] ) [EOL] [EOL] with_extra = chaining ( update_attr , [string] ) [EOL] [EOL] def with_index_at ( self , index_path ) : [EOL] self . routes . append ( [string] % ( CONFIG . index_prefix , index_path ) ) [EOL] return self [EOL] [EOL] def with_treeherder_required ( self ) : [EOL] self . treeherder_required = True [EOL] return self [EOL] [EOL] def with_treeherder ( self , category , symbol , group_name = None , group_symbol = None ) : [EOL] assert len ( symbol ) <= [number] , symbol [EOL] self . name = [string] % ( category , self . name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parts = category . split ( [string] ) [EOL] platform = parts [ [number] ] [EOL] labels = parts [ [number] : ] or [ [string] ] [EOL] [EOL] [comment] [EOL] self . with_extra ( treeherder = dict_update_if_truthy ( { [string] : { [string] : platform } , [string] : labels , [string] : symbol , } , groupName = group_name , groupSymbol = group_symbol , ) ) [EOL] [EOL] if CONFIG . treeherder_repository_name : [EOL] assert CONFIG . git_sha [EOL] suffix = [string] % ( CONFIG . treeherder_repository_name , CONFIG . git_sha ) [EOL] self . with_routes ( [string] + suffix , [string] + suffix , ) [EOL] [EOL] self . treeherder_required = False [comment] [EOL] return self [EOL] [EOL] def build_worker_payload ( self ) : [comment] [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] def create ( self ) : [EOL] [docstring] [EOL] worker_payload = self . build_worker_payload ( ) [EOL] assert not self . treeherder_required , [string] % self . name [EOL] [EOL] assert CONFIG . decision_task_id [EOL] assert CONFIG . task_owner [EOL] assert CONFIG . task_source [EOL] [EOL] def dedup ( xs ) : [EOL] seen = set ( ) [EOL] return [ x for x in xs if not ( x in seen or seen . add ( x ) ) ] [EOL] [EOL] queue_payload = { [string] : CONFIG . decision_task_id , [string] : dedup ( [ CONFIG . decision_task_id ] + self . dependencies ) , [string] : self . scheduler_id , [string] : self . provisioner_id , [string] : self . worker_type , [string] : SHARED . from_now_json ( [string] ) , [string] : SHARED . from_now_json ( self . deadline_in ) , [string] : SHARED . from_now_json ( self . expires_in ) , [string] : { [string] : CONFIG . task_name_template % self . name , [string] : self . description , [string] : CONFIG . task_owner , [string] : CONFIG . task_source , } , [string] : worker_payload , } [EOL] scopes = self . scopes + CONFIG . scopes_for_all_subtasks [EOL] routes = self . routes + CONFIG . routes_for_all_subtasks [EOL] if any ( r . startswith ( [string] ) for r in routes ) : [EOL] self . extra . setdefault ( [string] , { } ) [ [string] ] = SHARED . from_now_json ( self . index_and_artifacts_expire_in ) [EOL] dict_update_if_truthy ( queue_payload , scopes = scopes , routes = routes , extra = self . extra , priority = self . priority , ) [EOL] [EOL] task_id = taskcluster . slugId ( ) [EOL] SHARED . queue_service . createTask ( task_id , queue_payload ) [EOL] print ( [string] % ( task_id , self . name ) ) [EOL] return task_id [EOL] [EOL] @ staticmethod def find ( index_path ) : [EOL] full_index_path = [string] % ( CONFIG . index_prefix , index_path ) [EOL] task_id = SHARED . index_service . findTask ( full_index_path ) [ [string] ] [EOL] print ( [string] % ( task_id , full_index_path ) ) [EOL] return task_id [EOL] [EOL] def find_or_create ( self , index_path ) : [EOL] [docstring] [EOL] task_id = SHARED . found_or_created_indexed_tasks . get ( index_path ) [EOL] if task_id is not None : [EOL] return task_id [EOL] [EOL] try : [EOL] task_id = Task . find ( index_path ) [EOL] except taskcluster . TaskclusterRestFailure as e : [EOL] if e . status_code != [number] : [comment] [EOL] raise [EOL] if not CONFIG . index_read_only : [EOL] self . with_index_at ( index_path ) [EOL] task_id = self . create ( ) [EOL] [EOL] SHARED . found_or_created_indexed_tasks [ index_path ] = task_id [EOL] return task_id [EOL] [EOL] def with_curl_script ( self , url , file_path ) : [EOL] return self . with_script ( [string] % ( url , file_path ) ) [EOL] [EOL] def with_curl_artifact_script ( self , task_id , artifact_name , out_directory = [string] ) : [EOL] queue_service = CONFIG . tc_root_url + [string] [EOL] return self . with_dependencies ( task_id ) . with_curl_script ( queue_service + [string] % ( task_id , artifact_name ) , os . path . join ( out_directory , url_basename ( artifact_name ) ) , ) [EOL] [EOL] def with_repo_bundle ( self , ** kwargs ) : [EOL] self . git_fetch_url = [string] [EOL] self . git_fetch_ref = CONFIG . git_bundle_shallow_ref [EOL] self . git_checkout_sha = [string] [EOL] return self . with_curl_artifact_script ( CONFIG . decision_task_id , [string] ) . with_repo ( ** kwargs ) [EOL] [EOL] [EOL] class GenericWorkerTask ( Task ) : [EOL] [docstring] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . max_run_time_minutes = [number] [EOL] self . env = { } [EOL] self . features = { } [EOL] self . mounts = [ ] [EOL] self . artifacts = [ ] [EOL] [EOL] with_max_run_time_minutes = chaining ( setattr , [string] ) [EOL] with_mounts = chaining ( append_to_attr , [string] ) [EOL] with_env = chaining ( update_attr , [string] ) [EOL] [EOL] def build_command ( self ) : [comment] [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] def build_worker_payload ( self ) : [EOL] [docstring] [EOL] worker_payload = { [string] : self . build_command ( ) , [string] : self . max_run_time_minutes * [number] } [EOL] return dict_update_if_truthy ( worker_payload , env = self . env , mounts = self . mounts , features = self . features , artifacts = [ { [string] : type_ , [string] : path , [string] : [string] + url_basename ( path ) , [string] : SHARED . from_now_json ( self . index_and_artifacts_expire_in ) , } for type_ , path in self . artifacts ] , ) [EOL] [EOL] def with_artifacts ( self , * paths , type = [string] ) : [EOL] [docstring] [EOL] self . artifacts . extend ( ( type , path ) for path in paths ) [EOL] return self [EOL] [EOL] def with_features ( self , * names ) : [EOL] [docstring] [EOL] self . features . update ( { name : True for name in names } ) [EOL] return self [EOL] [EOL] def _mount_content ( self , url_or_artifact_name , task_id , sha256 ) : [EOL] if task_id : [EOL] content = { [string] : task_id , [string] : url_or_artifact_name } [EOL] else : [EOL] content = { [string] : url_or_artifact_name } [EOL] if sha256 : [EOL] content [ [string] ] = sha256 [EOL] return content [EOL] [EOL] def with_file_mount ( self , url_or_artifact_name , task_id = None , sha256 = None , path = None ) : [EOL] [docstring] [EOL] return self . with_mounts ( { [string] : path or url_basename ( url_or_artifact_name ) , [string] : self . _mount_content ( url_or_artifact_name , task_id , sha256 ) , } ) [EOL] [EOL] def with_directory_mount ( self , url_or_artifact_name , task_id = None , sha256 = None , path = None ) : [EOL] [docstring] [EOL] supported_formats = [ [string] , [string] , [string] , [string] ] [EOL] for fmt in supported_formats : [EOL] suffix = [string] + fmt [EOL] if url_or_artifact_name . endswith ( suffix ) : [EOL] return self . with_mounts ( { [string] : path or url_basename ( url_or_artifact_name [ : - len ( suffix ) ] ) , [string] : self . _mount_content ( url_or_artifact_name , task_id , sha256 ) , [string] : fmt , } ) [EOL] raise ValueError ( [string] % ( url_or_artifact_name , [string] . join ( supported_formats ) ) ) [comment] [EOL] [EOL] [EOL] class WindowsGenericWorkerTask ( GenericWorkerTask ) : [EOL] [docstring] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . scripts = [ ] [EOL] self . rdp_info_artifact_name = None [EOL] [EOL] with_script = chaining ( append_to_attr , [string] ) [EOL] with_early_script = chaining ( prepend_to_attr , [string] ) [EOL] [EOL] def build_worker_payload ( self ) : [EOL] if self . rdp_info_artifact_name : [EOL] rdp_scope = [string] % ( self . provisioner_id , self . worker_type ) [EOL] self . scopes . append ( rdp_scope ) [EOL] return dict_update_if_truthy ( super ( ) . build_worker_payload ( ) , rdpInfo = self . rdp_info_artifact_name , ) [EOL] [EOL] def with_rdp_info ( self , * , artifact_name ) : [EOL] [docstring] [EOL] assert not artifact_name . startswith ( [string] ) [EOL] self . rdp_info_artifact_name = artifact_name [EOL] [EOL] def build_command ( self ) : [EOL] return [ deindent ( s ) for s in self . scripts ] [EOL] [EOL] def with_path_from_homedir ( self , * paths ) : [EOL] [docstring] [EOL] for p in paths : [EOL] self . with_early_script ( [string] . format ( p ) ) [EOL] return self [EOL] [EOL] def with_repo ( self , sparse_checkout = None ) : [EOL] [docstring] [EOL] git = [string] [EOL] if sparse_checkout : [EOL] self . with_mounts ( { [string] : [string] , [string] : { [string] : [string] . join ( sparse_checkout ) } , } ) [EOL] git += [string] [EOL] git += [string] . format ( assert_truthy ( self . git_fetch_url ) , assert_truthy ( self . git_fetch_ref ) , assert_truthy ( self . git_checkout_sha ) , ) [EOL] return self . with_git ( ) . with_script ( git ) [EOL] [EOL] def with_git ( self ) : [EOL] [docstring] [EOL] return self . with_path_from_homedir ( [string] ) . with_directory_mount ( [string] + [string] , sha256 = [string] , path = [string] , ) [EOL] [EOL] def with_curl_script ( self , url , file_path ) : [EOL] self . with_curl ( ) [EOL] return super ( ) . with_curl_script ( url , file_path ) [EOL] [EOL] def with_curl ( self ) : [EOL] return self . with_path_from_homedir ( [string] ) . with_directory_mount ( [string] , sha256 = [string] , path = [string] , ) [EOL] [EOL] def with_rustup ( self ) : [EOL] [docstring] [EOL] return self . with_path_from_homedir ( [string] ) . with_early_script ( [string] ) . with_file_mount ( [string] , path = [string] ) [EOL] [EOL] def with_repacked_msi ( self , url , sha256 , path ) : [EOL] [docstring] [EOL] repack_task = ( WindowsGenericWorkerTask ( [string] + url ) . with_worker_type ( self . worker_type ) . with_max_run_time_minutes ( [number] ) . with_file_mount ( url , sha256 = sha256 , path = [string] ) . with_directory_mount ( [string] + [string] , sha256 = [string] , path = [string] ) . with_directory_mount ( [string] , sha256 = [string] , path = [string] , ) . with_path_from_homedir ( [string] , [string] ) . with_script ( [string] ) . with_artifacts ( [string] ) . with_index_and_artifacts_expire_in ( CONFIG . repacked_msi_files_expire_in ) . find_or_create ( [string] + sha256 ) ) [EOL] return self . with_dependencies ( repack_task ) . with_directory_mount ( [string] , task_id = repack_task , path = path ) [EOL] [EOL] def with_python2 ( self ) : [EOL] [docstring] [EOL] return self . with_repacked_msi ( [string] , sha256 = [string] , path = [string] ) . with_early_script ( [string] ) . with_path_from_homedir ( [string] , [string] ) [EOL] [EOL] [EOL] class UnixTaskMixin ( Task ) : [EOL] def with_repo ( self , alternate_object_dir = [string] ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] return self . with_script ( [string] . format ( assert_truthy ( self . git_fetch_url ) , assert_truthy ( self . git_fetch_ref ) , assert_truthy ( self . git_checkout_sha ) , alternate = alternate_object_dir , ) ) [EOL] [EOL] [EOL] class MacOsGenericWorkerTask ( UnixTaskMixin , GenericWorkerTask ) : [EOL] [docstring] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . scripts = [ ] [EOL] [EOL] with_script = chaining ( append_to_attr , [string] ) [EOL] with_early_script = chaining ( prepend_to_attr , [string] ) [EOL] [EOL] def build_command ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [ [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , deindent ( [string] . join ( self . scripts ) ) ] ] [EOL] [EOL] def with_python2 ( self ) : [EOL] return self . with_early_script ( [string] ) [EOL] [EOL] def with_python3 ( self ) : [EOL] return self . with_early_script ( [string] ) [EOL] [EOL] def with_rustup ( self ) : [EOL] return self . with_early_script ( [string] ) [EOL] [EOL] [EOL] class DockerWorkerTask ( UnixTaskMixin , Task ) : [EOL] [docstring] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . docker_image = [string] [EOL] self . max_run_time_minutes = [number] [EOL] self . scripts = [ ] [EOL] self . env = { } [EOL] self . caches = { } [EOL] self . features = { } [EOL] self . capabilities = { } [EOL] self . artifacts = [ ] [EOL] [EOL] with_docker_image = chaining ( setattr , [string] ) [EOL] with_max_run_time_minutes = chaining ( setattr , [string] ) [EOL] with_artifacts = chaining ( append_to_attr , [string] ) [EOL] with_script = chaining ( append_to_attr , [string] ) [EOL] with_early_script = chaining ( prepend_to_attr , [string] ) [EOL] with_caches = chaining ( update_attr , [string] ) [EOL] with_env = chaining ( update_attr , [string] ) [EOL] with_capabilities = chaining ( update_attr , [string] ) [EOL] [EOL] def build_worker_payload ( self ) : [EOL] [docstring] [EOL] worker_payload = { [string] : self . docker_image , [string] : self . max_run_time_minutes * [number] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , deindent ( [string] . join ( self . scripts ) ) ] , } [EOL] return dict_update_if_truthy ( worker_payload , env = self . env , cache = self . caches , features = self . features , capabilities = self . capabilities , artifacts = { [string] + url_basename ( path ) : { [string] : [string] , [string] : path , [string] : SHARED . from_now_json ( self . index_and_artifacts_expire_in ) , } for path in self . artifacts } , ) [EOL] [EOL] def with_features ( self , * names ) : [EOL] [docstring] [EOL] self . features . update ( { name : True for name in names } ) [EOL] return self [EOL] [EOL] def with_dockerfile ( self , dockerfile ) : [EOL] [docstring] [EOL] basename = os . path . basename ( dockerfile ) [EOL] suffix = [string] [EOL] assert basename . endswith ( suffix ) [EOL] image_name = basename [ : - len ( suffix ) ] [EOL] [EOL] dockerfile_contents = expand_dockerfile ( dockerfile ) [EOL] digest = hashlib . sha256 ( dockerfile_contents ) . hexdigest ( ) [EOL] [EOL] image_build_task = ( DockerWorkerTask ( [string] + image_name ) . with_worker_type ( CONFIG . docker_image_build_worker_type or self . worker_type ) . with_max_run_time_minutes ( [number] ) . with_index_and_artifacts_expire_in ( CONFIG . docker_images_expire_in ) . with_features ( [string] ) . with_env ( DOCKERFILE = dockerfile_contents ) . with_artifacts ( [string] ) . with_script ( [string] ) . with_docker_image ( [string] [string] ) . find_or_create ( [string] + digest ) ) [EOL] [EOL] return self . with_dependencies ( image_build_task ) . with_docker_image ( { [string] : [string] , [string] : [string] , [string] : image_build_task , } ) [EOL] [EOL] [EOL] def expand_dockerfile ( dockerfile ) : [EOL] [docstring] [EOL] with open ( dockerfile , [string] ) as f : [EOL] dockerfile_contents = f . read ( ) [EOL] [EOL] include_marker = [string] [EOL] if not dockerfile_contents . startswith ( include_marker ) : [EOL] return dockerfile_contents [EOL] [EOL] include_line , _ , rest = dockerfile_contents . partition ( [string] ) [EOL] included = include_line [ len ( include_marker ) : ] . strip ( ) . decode ( [string] ) [EOL] path = os . path . join ( os . path . dirname ( dockerfile ) , included ) [EOL] return [string] . join ( [ expand_dockerfile ( path ) , rest ] ) [EOL] [EOL] [EOL] def assert_truthy ( x ) : [EOL] assert x [EOL] return x [EOL] [EOL] [EOL] def dict_update_if_truthy ( d , ** kwargs ) : [EOL] for key , value in kwargs . items ( ) : [EOL] if value : [EOL] d [ key ] = value [EOL] return d [EOL] [EOL] [EOL] def deindent ( string ) : [EOL] return re . sub ( [string] , [string] , string ) . strip ( ) [EOL] [EOL] [EOL] def url_basename ( url ) : [EOL] return url . rpartition ( [string] ) [ - [number] ] [EOL] [EOL] [EOL] @ contextlib . contextmanager def make_repo_bundle ( ) : [EOL] subprocess . check_call ( [ [string] , [string] , [string] , [string] ] ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] , [string] ] ) [EOL] tree = subprocess . check_output ( [ [string] , [string] , CONFIG . git_sha , [string] , [string] ] ) [EOL] message = [string] + CONFIG . git_sha [EOL] commit = subprocess . check_output ( [ [string] , [string] , tree . strip ( ) , [string] , message ] ) [EOL] subprocess . check_call ( [ [string] , [string] , CONFIG . git_bundle_shallow_ref , commit . strip ( ) ] ) [EOL] subprocess . check_call ( [ [string] , [string] ] ) [EOL] create = [ [string] , [string] , [string] , [string] , CONFIG . git_bundle_shallow_ref ] [EOL] with subprocess . Popen ( create ) as p : [EOL] yield [EOL] exit_code = p . wait ( ) [EOL] if exit_code : [EOL] sys . exit ( exit_code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.Task]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 $builtins.str$ 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 $typing.Any$ 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.GenericWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.GenericWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.GenericWorkerTask]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.WindowsGenericWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.WindowsGenericWorkerTask]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.MacOsGenericWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.MacOsGenericWorkerTask]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.DockerWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.DockerWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.DockerWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.DockerWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.DockerWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.DockerWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.DockerWorkerTask]$ 0 0 0 0 0 0 0 0 $typing.Type[etc.taskcluster.decisionlib.DockerWorkerTask]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Shared$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $etc.taskcluster.decisionlib.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0