from typing import Coroutine , Tuple , Dict , Any [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] import msgpack [EOL] import uuid [EOL] [EOL] [EOL] class EchoClientProtocol ( asyncio . StreamReaderProtocol ) : [EOL] [EOL] def __init__ ( self , loop ) : [EOL] self . loop = loop [EOL] self . _connection_lost = None [EOL] self . _paused = None [EOL] self . _stream_writer = None [EOL] self . _stream_reader = asyncio . StreamReader ( loop = self . loop ) [EOL] self . tasks = { } [EOL] [EOL] def connection_made ( self , transport ) : [EOL] peername = transport . get_extra_info ( [string] ) [EOL] print ( [string] . format ( peername ) ) [EOL] self . transport = transport [EOL] self . _connection_lost = False [EOL] self . _paused = False [EOL] self . _stream_writer = asyncio . StreamWriter ( transport , self , self . _stream_reader , self . loop ) [EOL] asyncio . ensure_future ( self . init_connection ( ) ) [EOL] asyncio . ensure_future ( self . get_response ( ) ) [EOL] [EOL] async def get_response ( self ) : [EOL] while True : [EOL] data = await self . _stream_reader . readuntil ( [string] ) [EOL] data = data [ : - [number] ] [EOL] response = msgpack . unpackb ( data , encoding = [string] ) [EOL] print ( [string] ) [EOL] print ( response ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] async def init_connection ( self ) : [EOL] request = { [string] : [number] , [string] : True } [EOL] print ( [string] ) [EOL] self . _stream_writer . write ( msgpack . packb ( request ) + [string] ) [EOL] await self . _stream_writer . drain ( ) [EOL] [EOL] def connection_lost ( self , exc ) : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] self . _connection_lost = True [EOL] self . loop . stop ( ) [EOL] [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] coro = loop . create_connection ( lambda : EchoClientProtocol ( loop ) , [string] , [number] ) [EOL] loop . run_until_complete ( coro ) [EOL] loop . run_forever ( ) [EOL] loop . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.streams.StreamReader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $typing.Coroutine[typing.Any,typing.Any,typing.Tuple[asyncio.transports.BaseTransport,asyncio.protocols.BaseProtocol]]$ 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $typing.Coroutine[typing.Any,typing.Any,typing.Tuple[asyncio.transports.BaseTransport,asyncio.protocols.BaseProtocol]]$ 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import platform [EOL] if platform . system ( ) == [string] : [EOL] try : [EOL] import aio_windows_patch as asyncio [EOL] except : [EOL] import warnings [EOL] warnings . warn ( [string] , RuntimeWarning , stacklevel = [number] ) [EOL] import asyncio [EOL] [EOL] else : [EOL] import asyncio [EOL] [EOL] import time [EOL] from aio_tcpserver import tcp_server , listener [EOL] [EOL] [EOL] @ listener ( [string] ) async def beat ( loop ) : [EOL] print ( time . time ( ) ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] class EchoServerClientProtocol ( asyncio . Protocol ) : [EOL] def connection_made ( self , transport ) : [EOL] peername = transport . get_extra_info ( [string] ) [EOL] print ( [string] . format ( peername ) ) [EOL] self . transport = transport [EOL] [EOL] def data_received ( self , data ) : [EOL] message = data . decode ( ) [EOL] print ( [string] . format ( message ) ) [EOL] [EOL] print ( [string] . format ( message ) ) [EOL] self . transport . write ( data ) [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] self . transport . close ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] tcp_server ( EchoServerClientProtocol , signal = None , worker = [number] , port = [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from codecs import open [EOL] from setuptools import setup , find_packages [EOL] from os import path [EOL] [EOL] REQUIREMETS_DEV_FILE = [string] [EOL] REQUIREMETS_TEST_FILE = [string] [EOL] REQUIREMETS_FILE = [string] [EOL] PROJECTNAME = [string] [EOL] VERSION = [string] [EOL] DESCRIPTION = [string] [EOL] URL = [string] [EOL] AUTHOR = [string] [EOL] AUTHOR_EMAIL = [string] [EOL] LICENSE = [string] [EOL] CLASSIFIERS = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] KEYWORDS = [ [string] , [string] ] [EOL] PACKAGES = find_packages ( exclude = [ [string] , [string] , [string] ] ) [EOL] ZIP_SAFE = False [EOL] [EOL] HERE = path . abspath ( path . dirname ( __file__ ) ) [EOL] with open ( path . join ( HERE , [string] ) , encoding = [string] ) as f : [EOL] LONG_DESCRIPTION = f . read ( ) [EOL] REQUIREMETS_DIR = path . join ( HERE , [string] ) [EOL] [EOL] with open ( path . join ( REQUIREMETS_DIR , REQUIREMETS_FILE ) , encoding = [string] ) as f : [EOL] REQUIREMETS = f . readlines ( ) [EOL] [EOL] with open ( path . join ( REQUIREMETS_DIR , REQUIREMETS_DEV_FILE ) , encoding = [string] ) as f : [EOL] REQUIREMETS_DEV = f . readlines ( ) [EOL] [EOL] with open ( path . join ( REQUIREMETS_DIR , REQUIREMETS_TEST_FILE ) , encoding = [string] ) as f : [EOL] REQUIREMETS_TEST = f . readlines ( ) [EOL] [EOL] setup ( name = PROJECTNAME , version = VERSION , description = DESCRIPTION , long_description = LONG_DESCRIPTION , url = URL , author = AUTHOR , author_email = AUTHOR_EMAIL , license = LICENSE , classifiers = CLASSIFIERS , keywords = KEYWORDS , packages = PACKAGES , include_package_data = True , install_requires = REQUIREMETS , extras_require = { [string] : REQUIREMETS_DEV , [string] : REQUIREMETS_TEST } , zip_safe = ZIP_SAFE , data_files = [ ( [string] , [ [string] , [string] , [string] ] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Coroutine , Tuple , Any [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] [EOL] [EOL] class EchoClientProtocol ( asyncio . Protocol ) : [EOL] def __init__ ( self , message , loop ) : [EOL] self . message = message [EOL] self . loop = loop [EOL] [EOL] def connection_made ( self , transport ) : [EOL] transport . write ( self . message . encode ( ) ) [EOL] print ( [string] . format ( self . message ) ) [EOL] transport . write ( self . message . encode ( ) ) [EOL] print ( [string] . format ( self . message ) ) [EOL] [EOL] def data_received ( self , data ) : [EOL] print ( [string] . format ( data . decode ( ) ) ) [EOL] [EOL] def connection_lost ( self , exc ) : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] self . loop . stop ( ) [EOL] [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] message = [string] [EOL] coro = loop . create_connection ( lambda : EchoClientProtocol ( message , loop ) , [string] , [number] ) [EOL] loop . run_until_complete ( coro ) [EOL] loop . run_forever ( ) [EOL] loop . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Coroutine[typing.Any,typing.Any,typing.Tuple[asyncio.transports.BaseTransport,asyncio.protocols.BaseProtocol]]$ 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $builtins.str$ 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $typing.Coroutine[typing.Any,typing.Any,typing.Tuple[asyncio.transports.BaseTransport,asyncio.protocols.BaseProtocol]]$ 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] import msgpack [EOL] import time [EOL] from aio_tcpserver import tcp_server , listener [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class EchoServerProtocol ( asyncio . StreamReaderProtocol ) : [EOL] def __init__ ( self ) : [EOL] self . loop = asyncio . get_event_loop ( ) [EOL] self . _connection_lost = None [EOL] self . _paused = None [EOL] self . _stream_writer = None [EOL] self . _stream_reader = asyncio . StreamReader ( loop = self . loop ) [EOL] [EOL] def connection_made ( self , transport ) : [EOL] peername = transport . get_extra_info ( [string] ) [EOL] print ( [string] . format ( peername ) ) [EOL] self . transport = transport [EOL] self . _connection_lost = False [EOL] self . _paused = False [EOL] self . _stream_writer = asyncio . StreamWriter ( transport , self , self . _stream_reader , self . loop ) [EOL] asyncio . ensure_future ( self . get_request ( ) ) [EOL] [EOL] async def get_request ( self ) : [EOL] while True : [EOL] data = await self . _stream_reader . readuntil ( [string] ) [EOL] data = data [ : - [number] ] [EOL] response = msgpack . unpackb ( data , encoding = [string] ) [EOL] print ( [string] ) [EOL] print ( response ) [EOL] print ( [string] ) [EOL] self . _stream_writer . write ( msgpack . packb ( response ) + [string] ) [EOL] await self . _stream_writer . drain ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] tcp_server ( EchoServerProtocol , worker = [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.streams.StreamReader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Awaitable , Tuple , Dict , List , Any [EOL] import typing [EOL] import builtins [EOL] import asyncio [EOL] [docstring] [EOL] import inspect [EOL] import platform [EOL] from typing import ( List , Awaitable , Callable ) [EOL] from . errors import ListenerError [EOL] if platform . system ( ) == [string] : [EOL] try : [EOL] import aio_windows_patch as asyncio [EOL] except : [EOL] import warnings [EOL] warnings . warn ( [string] , RuntimeWarning , stacklevel = [number] ) [EOL] import asyncio [EOL] [EOL] else : [EOL] import asyncio [EOL] LISTENERS = { [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] } [EOL] HOOK_REVERSE = ( ( [string] , False ) , ( [string] , False ) , ( [string] , True ) , ( [string] , True ) , ) [EOL] [EOL] [EOL] def listener ( event ) : [EOL] [docstring] [EOL] if event not in LISTENERS . keys ( ) : [EOL] raise ListenerError ( [string] ) [EOL] [EOL] def decorator ( listener ) : [EOL] [docstring] [EOL] if not inspect . iscoroutinefunction ( listener ) : [EOL] raise ListenerError ( [string] [string] ) [EOL] LISTENERS [ event ] . append ( listener ) [EOL] return listener [EOL] [EOL] return decorator [EOL] [EOL] [EOL] def trigger_events ( events , loop ) : [EOL] [docstring] [EOL] for event in events : [EOL] result = event ( loop ) [EOL] if inspect . isawaitable ( result ) : [EOL] loop . run_until_complete ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import inspect [EOL] import asyncio [EOL] [docstring] [EOL] import asyncio [EOL] import inspect [EOL] from time import time [EOL] from functools import partial [EOL] from typing import Callable [EOL] CURRENT_TIME = None [EOL] [EOL] [EOL] def update_current_time ( loop ) : [EOL] [docstring] [EOL] global CURRENT_TIME [EOL] CURRENT_TIME = time ( ) [EOL] loop . call_later ( [number] , partial ( update_current_time , loop ) ) [EOL] [EOL] [EOL] class Signal : [EOL] [docstring] [EOL] [EOL] stopped = False [EOL] [EOL] [EOL] def get_protocol_params ( protocol ) : [EOL] [docstring] [EOL] if hasattr ( protocol , [string] ) : [EOL] s = inspect . signature ( protocol . func ) [EOL] else : [EOL] if inspect . isclass ( protocol ) : [EOL] s = inspect . signature ( protocol . __init__ ) [EOL] else : [EOL] s = inspect . signature ( protocol ) [EOL] result_dict = dict ( s . parameters ) [EOL] if result_dict . get ( [string] ) : [EOL] result_dict . pop ( [string] ) [EOL] return tuple ( result_dict . keys ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Protocol , Dict , Tuple , Set , Any , Union [EOL] import typing [EOL] import socket [EOL] import builtins [EOL] import signal [EOL] import aio_windows_patch [EOL] import functools [EOL] import asyncio [EOL] import ssl [EOL] import utils [EOL] [docstring] [EOL] import os [EOL] import platform [EOL] from ssl import SSLContext [EOL] from socket import socket [EOL] from functools import partial [EOL] import warnings [EOL] from typing import ( Optional ) [EOL] from . log import server_logger as logger [EOL] from . utils import ( Signal , update_current_time , get_protocol_params ) [EOL] from . hook import ( LISTENERS , HOOK_REVERSE , trigger_events ) [EOL] from signal import ( SIGTERM , SIGINT , SIG_IGN , signal as signal_func ) [EOL] [EOL] if platform . system ( ) == [string] : [EOL] try : [EOL] import aio_windows_patch as asyncio [EOL] except : [EOL] import warnings [EOL] warnings . warn ( [string] , RuntimeWarning , stacklevel = [number] ) [EOL] import asyncio [EOL] [EOL] else : [EOL] import asyncio [EOL] try : [EOL] import uvloop [EOL] asyncio . set_event_loop_policy ( uvloop . EventLoopPolicy ( ) ) [EOL] except ImportError : [EOL] pass [EOL] [EOL] [EOL] def tcp_serve ( host , port , serv_protocol , * , signal = None , loop = None , ssl = None , reuse_port = False , sock = None , backlog = [number] , debug = False , run_multiple = False , connections = None , run_async = False , graceful_shutdown_timeout = [number] , current_time = True ) : [EOL] [docstring] [EOL] if not run_async : [EOL] [comment] [EOL] loop = asyncio . new_event_loop ( ) [EOL] asyncio . set_event_loop ( loop ) [EOL] [EOL] if debug : [EOL] loop . set_debug ( debug ) [EOL] listeners = { } [EOL] for event_name , reverse in HOOK_REVERSE : [EOL] listeners [ event_name ] = LISTENERS [ event_name ] . copy ( ) [EOL] if reverse : [EOL] listeners [ event_name ] . reverse ( ) [EOL] [EOL] [comment] [EOL] connections = connections if connections is not None else set ( ) [EOL] [comment] [EOL] protocol_params = get_protocol_params ( serv_protocol ) [EOL] if connections : [EOL] if [string] in protocol_params : [EOL] serv_protocol = partial ( serv_protocol , connections = connections ) [EOL] if signal : [EOL] if [string] in protocol_params : [EOL] serv_protocol = partial ( serv_protocol , signal = signal ) [EOL] else : [EOL] warnings . warn ( [string] , RuntimeWarning , stacklevel = [number] ) [EOL] [EOL] server_coroutine = loop . create_server ( serv_protocol , host , port , ssl = ssl , reuse_port = reuse_port , sock = sock , backlog = backlog ) [EOL] [EOL] [comment] [EOL] if current_time : [EOL] loop . call_soon ( partial ( update_current_time , loop ) ) [EOL] [EOL] if run_async : [EOL] return server_coroutine [EOL] [comment] [EOL] trigger_events ( listeners [ [string] ] , loop ) [EOL] [EOL] try : [EOL] rpc_server = loop . run_until_complete ( server_coroutine ) [EOL] except BaseException : [EOL] logger . exception ( [string] ) [EOL] return [EOL] [comment] [EOL] trigger_events ( listeners [ [string] ] , loop ) [EOL] [EOL] [comment] [EOL] if run_multiple : [EOL] signal_func ( SIGINT , SIG_IGN ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _singals = ( SIGTERM , ) if run_multiple else ( SIGINT , SIGTERM ) [EOL] for _signal in _singals : [EOL] try : [EOL] loop . add_signal_handler ( _signal , loop . stop ) [EOL] except NotImplementedError as ni : [EOL] print ( str ( ni ) ) [EOL] logger . warning ( [string] [string] ) [EOL] [comment] [EOL] pid = os . getpid ( ) [EOL] try : [EOL] [comment] [EOL] logger . info ( [string] , pid ) [EOL] loop . run_forever ( ) [EOL] finally : [EOL] [comment] [EOL] logger . info ( [string] , pid ) [EOL] [comment] [EOL] trigger_events ( listeners [ [string] ] , loop ) [EOL] [comment] [EOL] rpc_server . close ( ) [EOL] loop . run_until_complete ( rpc_server . wait_closed ( ) ) [EOL] [comment] [EOL] [comment] [EOL] if signal : [EOL] signal . stopped = True [EOL] for connection in connections : [EOL] connection . close_if_idle ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] start_shutdown = [number] [EOL] while connections and ( start_shutdown < graceful_shutdown_timeout ) : [EOL] loop . run_until_complete ( asyncio . sleep ( [number] ) ) [EOL] start_shutdown = start_shutdown + [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for conn in connections : [EOL] conn . close ( ) [EOL] [comment] [EOL] loop . run_until_complete ( loop . shutdown_asyncgens ( ) ) [EOL] [comment] [EOL] trigger_events ( listeners [ [string] ] , loop ) [EOL] [comment] [EOL] loop . close ( ) [EOL] logger . info ( [string] , pid ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Union [EOL] import typing [EOL] [docstring] [EOL] [EOL] SERVER_CONFIG = { [string] : [string] , [string] : [number] , [string] : None , [string] : None , [string] : False , [string] : None , [string] : [number] , [string] : False , [string] : False , [string] : None , [string] : False , [string] : [number] , [string] : True } [EOL] [EOL] SERVER_LOGGING_CONFIG = { [string] : [number] , [string] : False , [string] : { [string] : { [string] : [string] , [string] : [ [string] ] } } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] server_logger = logging . getLogger ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
from typing import Optional , Protocol , Tuple , Dict , List , Any , Union [EOL] import typing [EOL] import builtins [EOL] import aio_windows_patch [EOL] import utils [EOL] [docstring] [EOL] import platform [EOL] import logging . config [EOL] from typing import Optional , Dict , Any [EOL] from . server_single import tcp_serve [EOL] from . serve_multiple import multiple_tcp_serve [EOL] from . utils import Signal , CURRENT_TIME [EOL] from . hook import listener [EOL] from . log import server_logger as logger [EOL] from . config import SERVER_CONFIG , SERVER_LOGGING_CONFIG [EOL] [EOL] if platform . system ( ) == [string] : [EOL] try : [EOL] import aio_windows_patch as asyncio [EOL] except : [EOL] import warnings [EOL] warnings . warn ( [string] , RuntimeWarning , stacklevel = [number] ) [EOL] import asyncio [EOL] [EOL] else : [EOL] import asyncio [EOL] [EOL] SETABLE = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def tcp_server ( serv_protocol , * , signal = Signal ( ) , worker = None , costume_config = None , ** kwargs ) : [EOL] [docstring] [EOL] server_config = SERVER_CONFIG [EOL] server_logging_config = SERVER_LOGGING_CONFIG [EOL] [EOL] if costume_config : [EOL] if costume_config . get ( [string] ) : [EOL] server_config . update ( costume_config . get ( [string] ) ) [EOL] if costume_config . get ( [string] ) : [EOL] server_logging_config . update ( costume_config . get ( [string] ) ) [EOL] [EOL] logging . config . dictConfig ( server_logging_config ) [EOL] server_config . update ( { [string] : serv_protocol , [string] : signal , } ) [EOL] [EOL] for i in SETABLE : [EOL] if kwargs . get ( i ) is not None : [EOL] server_config . update ( { i : kwargs . get ( i ) } ) [EOL] [EOL] if worker is not None and worker > [number] : [EOL] logger . info ( [string] . format ( server_config [ [string] ] , server_config [ [string] ] ) ) [EOL] multiple_tcp_serve ( server_config , worker ) [EOL] else : [EOL] [EOL] logger . info ( [string] . format ( server_config [ [string] ] , server_config [ [string] ] ) ) [EOL] tcp_serve ( ** server_config ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import socket [EOL] import multiprocessing [EOL] import builtins [EOL] [docstring] [EOL] import os [EOL] from multiprocessing import Process [EOL] from typing import Dict , Any [EOL] from socket import ( socket , SOL_SOCKET , SO_REUSEADDR ) [EOL] from signal import ( SIGTERM , SIGINT , signal as signal_func , Signals ) [EOL] from . errors import MultipleProcessDone [EOL] from . server_single import tcp_serve [EOL] from . log import server_logger as logger [EOL] [EOL] [EOL] def multiple_tcp_serve ( server_settings , workers ) : [EOL] [docstring] [EOL] server_settings [ [string] ] = True [EOL] server_settings [ [string] ] = True [EOL] [EOL] [comment] [EOL] if server_settings . get ( [string] ) is None : [EOL] sock = socket ( ) [EOL] sock . setsockopt ( SOL_SOCKET , SO_REUSEADDR , [number] ) [EOL] sock . bind ( ( server_settings [ [string] ] , server_settings [ [string] ] ) ) [EOL] sock . set_inheritable ( True ) [EOL] server_settings [ [string] ] = sock [EOL] server_settings [ [string] ] = None [EOL] server_settings [ [string] ] = None [EOL] [EOL] def sig_handler ( signal , frame ) : [EOL] [docstring] [EOL] status = [ ] [EOL] for process in processes : [EOL] statu = process . is_alive ( ) [EOL] status . append ( statu ) [EOL] if statu : [EOL] os . kill ( process . pid , SIGTERM ) [EOL] [EOL] if any ( status ) : [EOL] logger . info ( [string] . format ( Signals ( signal ) . name ) ) [EOL] else : [EOL] raise MultipleProcessDone ( [string] ) [EOL] [EOL] signal_func ( SIGINT , sig_handler ) [EOL] signal_func ( SIGTERM , sig_handler ) [EOL] [EOL] processes = [ ] [EOL] [EOL] for _ in range ( workers ) : [EOL] process = Process ( target = tcp_serve , kwargs = server_settings ) [EOL] process . daemon = True [EOL] process . start ( ) [EOL] processes . append ( process ) [EOL] try : [EOL] while True : [EOL] pass [EOL] except MultipleProcessDone as done : [EOL] logger . info ( str ( done ) ) [EOL] except Exception as e : [EOL] raise e [EOL] finally : [EOL] for process in processes : [EOL] process . join ( ) [EOL] [EOL] [comment] [EOL] for process in processes : [EOL] process . terminate ( ) [EOL] server_settings . get ( [string] ) . close ( ) [EOL] logger . info ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class ListenerError ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class MultipleProcessDone ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0