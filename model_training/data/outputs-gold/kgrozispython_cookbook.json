[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , List , Mapping , Sequence [EOL] [EOL] def add_one ( input ) : [EOL] return input + [number] [EOL] [EOL] def print_seven ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] five = [string] [EOL] seven = add_one ( add_one ( five ) ) [EOL] print ( seven ) [EOL] [EOL] print ( add_one ( [number] ) ) [EOL] print_seven ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment]	0
[comment]	0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import datetime [EOL] import typing [EOL] from datetime import date [EOL] [EOL] [comment] [EOL] _formats = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] class Date : [EOL] def __init__ ( self , year , month , day ) : [EOL] self . year = year [EOL] self . month = month [EOL] self . day = day [EOL] [comment] [EOL] [comment] [EOL] def __format__ ( self , code ) : [EOL] if code == [string] : [EOL] code = [string] [EOL] fmt = _formats [ code ] [EOL] return fmt . format ( d = self ) [EOL] d = Date ( [number] , [number] , [number] ) [EOL] print ( format ( d ) ) [EOL] print ( format ( d , [string] ) ) [EOL] print ( [string] . format ( d ) ) [EOL] print ( [string] . format ( d ) ) [EOL] [EOL] [comment] [EOL] d = date ( [number] , [number] , [number] ) [EOL] print ( format ( d ) ) [EOL] print ( format ( d , [string] ) ) [EOL] print ( [string] . format ( d ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $datetime.date$ 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class Pair : [EOL] def __init__ ( self , x , y ) : [EOL] self . x = x [EOL] self . y = y [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self ) [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self ) [EOL] [EOL] p = Pair ( [number] , [number] ) [EOL] p [comment] [EOL] print ( p ) [comment] [EOL] print ( [string] . format ( p ) ) [comment] [EOL] print ( [string] . format ( p ) ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class Pair : [EOL] def __init__ ( self , x , y ) : [EOL] self . x = x [EOL] self . y = y [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . x , self . y ) [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . x , self . y ) [EOL] [EOL] p = Pair ( [number] , [number] ) [EOL] p [comment] [EOL] print ( p ) [comment] [EOL] print ( [string] . format ( p ) ) [comment] [EOL] print ( [string] . format ( p ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from socket import socket , AF_INET , SOCK_STREAM [EOL] from functools import partial [EOL] [EOL] [comment] [EOL] class LazyConnection : [EOL] def __init__ ( self , address , family = AF_INET , type = SOCK_STREAM ) : [EOL] self . address = address [EOL] self . family = family [EOL] self . type = type [EOL] self . sock = None [EOL] [comment] [EOL] def __enter__ ( self ) : [EOL] print ( [string] ) [EOL] if self . sock is not None : [EOL] raise RuntimeError ( [string] ) [EOL] self . sock = socket ( self . family , self . type ) [EOL] self . sock . connect ( self . address ) [EOL] return self . sock [EOL] [comment] [EOL] def __exit__ ( self , exc_ty , exc_val , tb ) : [EOL] print ( [string] ) [EOL] self . sock . close ( ) [EOL] self . sock = None [EOL] [EOL] conn = LazyConnection ( ( [string] , [number] ) ) [EOL] [comment] [EOL] with conn as s : [EOL] [comment] [EOL] s . send ( [string] ) [EOL] s . send ( [string] ) [EOL] s . send ( [string] ) [EOL] resp = [string] . join ( iter ( partial ( s . recv , [number] ) , [string] ) ) [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
def testA ( ) : [EOL] print ( [string] )	0 0 0 0 0 0 0 0 0 0
def testB ( ) : [EOL] print ( [string] )	0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List [EOL] import decimal [EOL] import typing [EOL] from decimal import Decimal , localcontext [EOL] import math [EOL] [EOL] [comment] [EOL] a = [number] [EOL] b = [number] [EOL] [EOL] print ( a + b ) [comment] [EOL] print ( ( a + b ) == [number] ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] c = Decimal ( [string] ) [EOL] d = Decimal ( [string] ) [EOL] [EOL] print ( c + d ) [comment] [EOL] print ( ( c + d ) == [number] ) [comment] [EOL] [EOL] [comment] [EOL] e = Decimal ( [string] ) [EOL] f = Decimal ( [string] ) [EOL] [EOL] with localcontext ( ) as ctx : [EOL] [comment] [EOL] ctx . prec = [number] [EOL] print ( e / f ) [EOL] with localcontext ( ) as ctx : [EOL] [comment] [EOL] ctx . prec = [number] [EOL] print ( e / f ) [EOL] print ( e / f ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] nums = [ [number] , [number] , - [number] ] [EOL] print ( sum ( nums ) ) [EOL] [comment] [EOL] print ( math . fsum ( nums ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( round ( [number] , [number] ) ) [comment] [EOL] print ( round ( [number] , [number] ) ) [comment] [EOL] [EOL] a = [number] [EOL] print ( round ( a , - [number] ) ) [comment] [EOL] print ( round ( a , - [number] ) ) [comment] [EOL] print ( round ( a , - [number] ) ) [comment] [EOL] [EOL] [comment] [EOL] x = [number] [EOL] print ( format ( x , [string] ) ) [comment] [EOL] print ( format ( x , [string] ) ) [comment] [EOL] print ( [string] . format ( x ) ) [comment] [EOL] [EOL] [comment] [EOL] a = [number] [EOL] b = [number] [EOL] c = a + b [EOL] print ( [string] % c ) [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict [EOL] import typing [EOL] x = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] print ( format ( x , [string] ) ) [EOL] [comment] [EOL] print ( format ( x , [string] ) ) [EOL] [comment] [EOL] print ( format ( x , [string] ) ) [EOL] [comment] [EOL] print ( format ( x , [string] ) ) [EOL] [comment] [EOL] print ( format ( x , [string] ) ) [EOL] [comment] [EOL] print ( format ( x , [string] ) ) [EOL] [comment] [EOL] print ( format ( x , [string] ) ) [EOL] [comment] [EOL] print ( format ( - x , [string] ) ) [EOL] [comment] [EOL] swap_separators = { ord ( [string] ) : [string] , ord ( [string] ) : [string] } [EOL] print ( format ( x , [string] ) . translate ( swap_separators ) ) [EOL] [EOL] [comment] [EOL] print ( [string] . format ( x ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] print ( [string] % x ) [EOL] [comment] [EOL] print ( [string] % x ) [EOL] [comment] [EOL] print ( [string] % x )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import re [EOL] [EOL] line = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] output = re . split ( [string] , line ) [EOL] print ( output ) [EOL] fields = re . split ( [string] , line ) [comment] [EOL] print ( fields ) [EOL] values = fields [ : : [number] ] [comment] [EOL] print ( values ) [EOL] deliminters = fields [ [number] : : [number] ] + [ [string] ] [comment] [EOL] print ( deliminters )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from fnmatch import fnmatch , fnmatchcase [EOL] [EOL] [comment] [EOL] print ( fnmatch ( [string] , [string] ) ) [EOL] [comment] [EOL] print ( fnmatch ( [string] , [string] ) ) [EOL] [comment] [EOL] print ( fnmatch ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] names = [ [string] , [string] , [string] , [string] ] [EOL] [comment] [EOL] print ( [ name for name in names if fnmatch ( name , [string] ) ] ) [EOL] [EOL] [comment] [EOL] print ( fnmatchcase ( [string] , [string] ) ) [comment] [EOL] addresses = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [comment] [EOL] print ( [ addr for addr in addresses if fnmatchcase ( addr , [string] ) ] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import datetime [EOL] import datetime [EOL] [EOL] user = [string] [EOL] action = [string] [EOL] [EOL] name = [string] [EOL] age = [number] [EOL] anniversary = datetime . date ( [number] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] log_message = [string] . format ( user , action ) [EOL] print ( log_message ) [EOL] [EOL] [comment] [EOL] print ( f" [string] { user } [string] { action } [string] " ) [EOL] print ( f" [string] { name } [string] { age + [number] } [string] { anniversary : [string] }" ) [EOL] print ( f" [string] { name !r}" ) [EOL] [EOL] [comment] [EOL] value = [number] [EOL] print ( f' [string] { value : [string] }' ) [EOL] [EOL] [comment] [EOL] print ( f'{ [string] }' ) [EOL] [comment] [EOL] print ( f' [string] { [number] * [number] } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List [EOL] import typing [EOL] import os [EOL] from urllib . request import urlopen [EOL] [EOL] [comment] [EOL] filename = [string] [EOL] print ( filename . endswith ( [string] ) ) [EOL] print ( filename . startswith ( [string] ) ) [EOL] [EOL] [comment] [EOL] url = [string] [EOL] print ( url . startswith ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] filenames = os . listdir ( [string] ) [EOL] print ( filenames ) [EOL] print ( [ name for name in filenames if name . endswith ( ( [string] , [string] , [string] ) ) ] ) [EOL] print ( any ( name . endswith ( [string] ) for name in filenames ) ) [EOL] [EOL] choices = [ [string] , [string] ] [comment] [EOL] print ( url . startswith ( tuple ( choices ) ) ) [comment] [EOL] [EOL] [comment] [EOL] def read_data ( names ) : [EOL] if name . startwith ( ( [string] , [string] , [string] ) ) : [EOL] return urlopen ( name ) . read ( ) [EOL] else : [EOL] with open ( name ) as f : [EOL] return f . read ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import html [EOL] [EOL] [comment] [EOL] def avg ( first , * rest ) : [EOL] return ( first + sum ( rest ) ) / ( [number] + len ( rest ) ) [EOL] [EOL] print ( avg ( [number] , [number] ) ) [EOL] print ( avg ( [number] , [number] , [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def make_element ( name , value , ** attrs ) : [EOL] keyvals = [ [string] % item for item in attrs . items ( ) ] [EOL] attr_str = [string] . join ( keyvals ) [EOL] element = [string] . format ( name = name , attrs = attr_str , value = html . escape ( value ) ) [EOL] return element [EOL] print ( make_element ( [string] , [string] , size = [string] , quantity = [number] ) ) [EOL] print ( make_element ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] def anyargs ( * args , ** kwargs ) : [EOL] print ( args ) [comment] [EOL] print ( kwargs ) [comment] [EOL] print ( anyargs ( [number] , [number] , [number] , [number] , test1 = [number] , test2 = [number] ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import fileinput [EOL] [EOL] with fileinput . input ( ) as f : [EOL] for line in f : [EOL] [comment] [EOL] print ( f . filename ( ) , f . lineno ( ) , line , end = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import sys [EOL] [EOL] [comment] [EOL] sys . stderr . write ( [string] ) [EOL] [comment] [EOL] raise SystemExit ( [number] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Generator , List [EOL] import typing [EOL] import pathlib [EOL] from pathlib import Path [EOL] from shutil import copyfile [EOL] from os import chdir [EOL] [EOL] [comment] [EOL] BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent [EOL] print ( BASE_DIR ) [EOL] [EOL] [comment] [EOL] TEST_DIR = BASE_DIR . joinpath ( [string] ) [EOL] print ( TEST_DIR ) [EOL] [EOL] [comment] [EOL] Path ( [string] ) . mkdir ( parents = True , exist_ok = True ) [EOL] [comment] [EOL] Path ( [string] ) . rename ( [string] ) [EOL] [EOL] [comment] [EOL] top_level_py_files = Path . cwd ( ) . glob ( [string] ) [EOL] for top_level_py_file in top_level_py_files : [EOL] print ( top_level_py_file ) [EOL] all_py_files = Path . cwd ( ) . rglob ( [string] ) [EOL] for all_py_file in all_py_files : [EOL] print ( all_py_file ) [EOL] [EOL] [comment] [EOL] file_contents = [ path . read_text ( ) for path in Path . cwd ( ) . rglob ( [string] ) ] [EOL] print ( file_contents ) [EOL] [EOL] [comment] [EOL] path = Path ( [string] ) [EOL] with path . open ( mode = [string] ) as config : [EOL] config . write ( [string] ) [EOL] [EOL] [comment] [EOL] with open ( path , mode = [string] ) as config : [EOL] config . write ( [string] ) [EOL] [EOL] [comment] [EOL] source = Path ( [string] ) [EOL] destination = Path ( [string] ) [EOL] copyfile ( source , destination ) [EOL] [EOL] [comment] [EOL] parent = Path ( [string] ) [EOL] chdir ( parent ) [EOL] [EOL] [comment] [EOL] print ( Path ( [string] ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[pathlib.Path,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[pathlib.Path,None,None]$ 0 0 0 0 0 0 0 $typing.Generator[pathlib.Path,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[pathlib.Path,None,None]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import argparse [EOL] import argparse [EOL] [EOL] [comment] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parser . add_argument ( dest = [string] , metavar = [string] , nargs = [string] ) [EOL] [comment] [EOL] [comment] [EOL] parser . add_argument ( [string] , [string] , metavar = [string] , required = True , dest = [string] , action = [string] , help = [string] ) [EOL] [comment] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] [comment] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] [comment] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , choices = { [string] , [string] } , default = [string] , help = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] args = parser . parse_args ( ) [EOL] [EOL] [comment] [EOL] print ( args . filenames ) [EOL] print ( args . patterns ) [EOL] print ( args . verbose ) [EOL] print ( args . outfile ) [EOL] print ( args . speed )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] , [number] , [number] ) [EOL] print ( [string] , [number] , [number] , sep = [string] ) [EOL] print ( [string] , [number] , [number] , sep = [string] , end = [string] ) [EOL] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] print ( i ) [EOL] for i in range ( [number] ) : [EOL] print ( i , end = [string] ) [EOL] [EOL] [comment] [EOL] print ( [string] . join ( [string] , [string] , [string] ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import io [EOL] with open ( [string] , [string] ) as f : [EOL] data = f . read ( ) [EOL] print ( data ) [EOL] [EOL] [comment] [EOL] with open ( [string] , [string] ) as f : [EOL] for line in f : [EOL] print ( line ) [EOL] [EOL] [comment] [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( [string] ) [EOL] f . write ( [string] ) [EOL] [EOL] [comment] [EOL] with open ( [string] , [string] ) as f : [EOL] print ( [string] , file = f ) [EOL] print ( [string] , file = f ) [EOL] [EOL] [comment] [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with open ( [string] , [string] , encoding = [string] ) as f : [EOL] data = f . read ( ) [EOL] print ( data ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] f = open ( [string] , [string] ) [EOL] data = f . read ( ) [EOL] print ( data ) [EOL] f . close ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with open ( [string] , [string] , newline = [string] ) as f : [EOL] data = f . read ( ) [EOL] print ( data ) [EOL] [EOL] [comment] [EOL] f = open ( [string] , [string] , encoding = [string] , errors = [string] ) [EOL] data = f . read ( ) [EOL] print ( data ) [EOL] f . close ( ) [EOL] [EOL] [comment] [EOL] f = open ( [string] , [string] , encoding = [string] , errors = [string] ) [EOL] data = f . read ( ) [EOL] print ( data ) [EOL] f . close ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $builtins.str$ 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $builtins.str$ 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $builtins.str$ 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $io.TextIOWrapper$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] with open ( [string] , [string] ) as f : [EOL] print ( [string] , file = f ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from functools import wraps [EOL] [EOL] def decorator1 ( func ) : [EOL] @ wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] print ( [string] ) [EOL] return func ( * args , ** kwargs ) [EOL] return wrapper [EOL] [EOL] def decorator2 ( func ) : [EOL] @ wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] print ( [string] ) [EOL] return func ( * args , ** kwargs ) [EOL] return wrapper [EOL] [EOL] @ decorator1 @ decorator2 def add ( x , y ) : [EOL] return x + y [EOL] [EOL] print ( add ( [number] , [number] ) ) [EOL] print ( add . __wrapped__ ( [number] , [number] ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from functools import wraps [EOL] [EOL] def timethis ( func ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] @ wraps ( func ) [comment] [EOL] [comment] [EOL] [comment] [EOL] def wrapper ( * args , ** kwargs ) : [EOL] print ( [string] ) [EOL] start = time . time ( ) [EOL] [comment] [EOL] result = func ( * args , ** kwargs ) [EOL] end = time . time ( ) [EOL] print ( func . __name__ , end - start ) [EOL] return result [EOL] [EOL] return wrapper [EOL] [EOL] @ timethis def countdown ( n ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] while n > [number] : [EOL] n -= [number] [EOL] [EOL] countdown ( [number] ) [EOL] countdown ( [number] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import builtins [EOL] import time [EOL] from functools import wraps [EOL] from inspect import signature [EOL] [EOL] def timethis ( func ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] [comment] [EOL] @ wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] print ( [string] ) [EOL] start = time . time ( ) [EOL] result = func ( * args , ** kwargs ) [EOL] end = time . time ( ) [EOL] print ( func . __name__ , end - start ) [EOL] return result [EOL] return wrapper [EOL] [EOL] @ timethis def countdown ( n ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] while n > [number] : [EOL] n -= [number] [EOL] [EOL] countdown ( [number] ) [EOL] print ( countdown . __name__ ) [comment] [EOL] print ( countdown . __doc__ ) [comment] [EOL] print ( countdown . __annotations__ ) [comment] [EOL] [EOL] [comment] [EOL] print ( countdown . __wrapped__ ( [number] ) ) [EOL] print ( signature ( countdown ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import socketserver [EOL] from socketserver import BaseRequestHandler , UDPServer [EOL] import time [EOL] [EOL] class TimeHandler ( BaseRequestHandler ) : [EOL] def handle ( self ) : [EOL] print ( f' [string] { self . client_address }' ) [EOL] [comment] [EOL] msg , sock = self . request [EOL] resp = time . ctime ( ) [EOL] sock . sendto ( resp . encoe ( [string] ) , self . client_address ) [EOL] [EOL] if __name__ == [string] : [EOL] serv = UDPServer ( ( [string] , [number] ) , TimeHandler ) [EOL] serv . serve_forever	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socketserver.UDPServer$ 0 0 0 0 0 0 0 0 0 0 0 0 $socketserver.UDPServer$ 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import socketserver [EOL] from socketserver import BaseRequestHandler , TCPServer [EOL] [EOL] class EchoHandler ( BaseRequestHandler ) : [EOL] def handle ( self ) : [EOL] print ( [string] , self . client_address ) [EOL] while True : [EOL] msg = self . request . recv ( [number] ) [EOL] if not msg : [EOL] break [EOL] self . request . send ( msg ) [EOL] [EOL] if __name__ == [string] : [EOL] serv = TCPServer ( ( [string] , [number] ) , EchoHandler ) [EOL] serv . serve_forever ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $socketserver.TCPServer$ 0 0 0 0 0 0 0 0 0 0 0 0 $socketserver.TCPServer$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import threading [EOL] from threading import Thread , Event , Condition , Semaphore [EOL] import time [EOL] [EOL] [comment] [EOL] def countdown ( n , started_evt ) : [EOL] print ( [string] ) [EOL] started_evt . set ( ) [EOL] while n > [number] : [EOL] print ( [string] , n ) [EOL] n -= [number] [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] started_evt = Event ( ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] t = Thread ( target = countdown , args = ( [number] , started_evt ) ) [EOL] t . start ( ) [EOL] [EOL] [comment] [EOL] started_evt . wait ( ) [EOL] [comment] [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] class PeriodicTimer : [EOL] def __init__ ( self , interval ) : [EOL] self . _interval = interval [EOL] self . _flag = [number] [EOL] self . _cv = Condition ( ) [EOL] def start ( self ) : [EOL] t = Thread ( target = self . run ) [EOL] t . daemon = True [EOL] t . start ( ) [EOL] def run ( self ) : [EOL] [docstring] [EOL] while True : [EOL] time . sleep ( self . _interval ) [EOL] with self . _cv : [EOL] self . _flag ^= [number] [EOL] self . _cv . notify_all ( ) [EOL] def wait_for_tick ( self ) : [EOL] [docstring] [EOL] with self . _cv : [EOL] last_flag = self . _flag [EOL] while last_flag == self . _flag : [EOL] self . _cv . wait ( ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] ptimer = PeriodicTimer ( [number] ) [EOL] ptimer . start ( ) [EOL] [EOL] [comment] [EOL] def pcountdown ( nticks ) : [EOL] while nticks > [number] : [EOL] ptimer . wait_for_tick ( ) [EOL] print ( [string] , nticks ) [EOL] nticks -= [number] [EOL] [EOL] def pcountup ( last ) : [EOL] n = [number] [EOL] while n < last : [EOL] ptimer . wait_for_tick ( ) [EOL] print ( [string] , n ) [EOL] n += [number] [EOL] [EOL] Thread ( target = pcountdown , args = ( [number] , ) ) . start ( ) [EOL] Thread ( target = pcountup , args = ( [number] , ) ) . start ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def worker ( n , sema ) : [EOL] [comment] [EOL] sema . acquire ( ) [EOL] [comment] [EOL] print ( [string] , n ) [EOL] [EOL] [comment] [EOL] sema = Semaphore ( [number] ) [EOL] nworkers = [number] [EOL] for n in range ( nworkers ) : [EOL] t = Thread ( target = worker , args = ( n , sema , ) ) [EOL] t . start ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] sema . release ( ) [EOL] sema . release ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $threading.Condition$ 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 $builtins.bool$ 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Semaphore$ 0 0 0 0 0 $threading.Semaphore$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Semaphore$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Semaphore$ 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $threading.Semaphore$ 0 0 0 0 0 $threading.Semaphore$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import threading [EOL] import datetime [EOL] import queue [EOL] import typing [EOL] from queue import Queue [EOL] from threading import Thread , Event [EOL] import datetime [EOL] [EOL] [comment] [EOL] _sentinel = object ( ) [EOL] [EOL] running = True [EOL] [EOL] [comment] [EOL] def producer ( out_q , running ) : [EOL] run_counter = [number] [EOL] while running : [EOL] [comment] [EOL] data = datetime . datetime . now ( ) [EOL] out_q . put ( data ) [EOL] run_counter += [number] [EOL] if run_counter > [number] : [EOL] running = False [EOL] [comment] [EOL] out_q . put ( _sentinel ) [EOL] [EOL] [comment] [EOL] def consumer ( in_q ) : [EOL] while True : [EOL] [comment] [EOL] data = in_q . get ( ) [EOL] [comment] [EOL] if data is _sentinel : [EOL] in_q . put ( _sentinel ) [EOL] break [EOL] [comment] [EOL] print ( f" [string] { data }" ) [EOL] [EOL] [comment] [EOL] q = Queue ( ) [EOL] t1 = Thread ( target = consumer , args = ( q , ) ) [EOL] t2 = Thread ( target = producer , args = ( q , running ) ) [EOL] t1 . start ( ) [EOL] t2 . start ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def producer2 ( out_q ) : [EOL] while running : [EOL] data = datetime . datetime . now ( ) [EOL] [comment] [EOL] evt = Event ( ) [EOL] out_q . put ( data , evt ) [EOL] [comment] [EOL] evt . wait ( ) [EOL] [EOL] def consumer2 ( in_q ) : [EOL] while True : [EOL] data , evt = in_q . get ( ) [EOL] print ( f" [string] { data }" ) [EOL] [comment] [EOL] evt . set ( ) [EOL] [EOL] running = True [EOL] q2 = Queue ( ) [EOL] t2_1 = Thread ( target = consumer2 , args = ( q2 , ) ) [EOL] t2_2 = Thread ( target = producer2 , args = ( q2 , running ) ) [EOL] t2_1 . start ( ) [EOL] t2_2 . start ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 $builtins.str$ 0 0 0 $threading.Thread$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 $builtins.str$ 0 0 0 $threading.Thread$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import threading [EOL] import multiprocessing [EOL] import typing [EOL] import time [EOL] import multiprocessing [EOL] [comment] [EOL] from threading import Thread [EOL] [EOL] [comment] [EOL] [comment] [EOL] class CountdownTask : [EOL] def __init__ ( self ) : [EOL] self . _running = True [EOL] def terminate ( self ) : [EOL] self . _running = False [EOL] def run ( self , n ) : [EOL] while self . _running and n > [number] : [EOL] print ( [string] , n ) [EOL] n -= [number] [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class IOTask : [EOL] def terminate ( self ) : [EOL] self . _running = False [EOL] def run ( self , sock ) : [EOL] [comment] [EOL] sock . settimeout ( [number] ) [comment] [EOL] while self . _running : [EOL] [comment] [EOL] try : [EOL] data = sock . resv ( [number] ) [EOL] break [EOL] except sock . timeout : [EOL] continue [EOL] [comment] [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class CountdownThread ( Thread ) : [EOL] def __init__ ( self , n ) : [EOL] super ( ) . __init__ ( ) [EOL] self . n = n [EOL] def run ( self ) : [EOL] while self . n > [number] : [EOL] print ( [string] , self . n ) [EOL] self . n -= [number] [EOL] time . sleep ( [number] ) [EOL] [EOL] def countdown ( n ) : [EOL] while n > [number] : [EOL] print ( [string] , n ) [EOL] n -= [number] [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] t = Thread ( target = countdown , args = ( [number] , ) , daemon = True ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] t . start ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if t . is_alive ( ) : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] t . join ( ) [EOL] [EOL] c = CountdownTask ( ) [EOL] t2 = Thread ( target = c . run , args = ( [number] , ) ) [EOL] t2 . start ( ) [EOL] time . sleep ( [number] ) [EOL] c . terminate ( ) [comment] [EOL] [comment] [EOL] [EOL] c2 = CountdownThread ( [number] ) [EOL] c2 . start ( ) [EOL] [EOL] c3 = CountdownTask ( ) [EOL] p = multiprocessing . Process ( target = c3 . run , args = ( [number] , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multiprocessing.context.Process$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Iterator , List [EOL] import typing [EOL] with open ( [string] ) as f : [EOL] try : [EOL] while True : [EOL] line = next ( f ) [EOL] print ( line , end = [string] ) [EOL] except StopIteration : [comment] [EOL] pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] items = [ [number] , [number] , [number] ] [EOL] it = iter ( items ) [comment] [EOL] print ( next ( it ) ) [comment] [EOL] print ( next ( it ) ) [EOL] print ( next ( it ) ) [EOL] print ( next ( it ) ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class Node : [EOL] def __init__ ( self , value ) : [EOL] self . _value = value [EOL] self . _children = [ ] [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . _value ) [EOL] [EOL] def add_child ( self , node ) : [EOL] self . _children . append ( node ) [EOL] [EOL] def __iter__ ( self ) : [EOL] [comment] [EOL] return iter ( self . _children ) [EOL] [EOL] [comment] [EOL] if __name__ == [string] : [EOL] root = Node ( [number] ) [EOL] print ( [string] % root ) [EOL] child1 = Node ( [number] ) [EOL] print ( [string] % child1 ) [EOL] child2 = Node ( [number] ) [EOL] print ( [string] % child2 ) [EOL] root . add_child ( child1 ) [EOL] print ( [string] % root ) [EOL] root . add_child ( child2 ) [EOL] print ( [string] % root ) [EOL] [EOL] for ch in root : [EOL] print ( ch )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] def frange ( start , stop , increment ) : [EOL] x = start [EOL] while x < stop : [EOL] [comment] [EOL] [comment] [EOL] yield x [EOL] x += increment [EOL] [comment] [EOL] [comment] [EOL] for n in frange ( [number] , [number] , [number] ) : [EOL] print ( n ) [EOL] print ( list ( frange ( [number] , [number] , [number] ) ) ) [EOL] [EOL] def countdown ( n ) : [EOL] print ( [string] , n ) [EOL] while n > [number] : [EOL] yield n [EOL] n -= [number] [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] c = countdown ( [number] ) [EOL] print ( c ) [EOL] [comment] [EOL] print ( next ( c ) ) [EOL] print ( next ( c ) ) [EOL] print ( next ( c ) ) [EOL] print ( next ( c ) ) [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from unittest . mock import patch [EOL] import example [EOL] [EOL] @ patch ( [string] ) def test1 ( x , mock_func ) : [EOL] example . func ( x ) [comment] [EOL] mock_func . assert_called_with ( x )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from io import StringIO [EOL] from unittest import TestCase [EOL] from unittest . mock import patch [EOL] import mymodule [EOL] [EOL] class TestURLPrint ( TestCase ) : [EOL] def test_url_gets_to_stdout ( self ) : [EOL] protocol = [string] [EOL] host = [string] [EOL] domain = [string] [EOL] expected_url = [string] . format ( protocol , host , domain ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with patch ( [string] , new = StringIO ( ) ) as fake_out : [EOL] mymodule . urlprint ( protocol , host , domain ) [EOL] self . assertEqual ( fake_out . getvalue ( ) , expected_url ) [EOL] [EOL] t = TestURLPrint ( ) [EOL] t . test_url_gets_to_stdout [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0
def urlprint ( protocol , host , domain ) : [EOL] url = [string] . format ( protocol , host , domain ) [EOL] [comment] [EOL] print ( url )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def myFunction ( ) : [EOL] print ( f" [string] { __name__ }" ) [EOL] [EOL] def main ( ) : [EOL] myFunction ( ) [EOL] [EOL] [comment] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import nameScript as ns [EOL] [EOL] ns . myFunction ( )	0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] from collections import deque [EOL] import typing [EOL] import collections [EOL] from collections import deque [EOL] [EOL] def search ( lines , pattern , history = [number] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] previous_lines = deque ( maxlen = history ) [EOL] for line in lines : [EOL] if pattern in line : [EOL] [comment] [EOL] yield line , previous_lines [EOL] [comment] [EOL] previous_lines . append ( line ) [EOL] [EOL] [comment] [EOL] if __name__ == [string] : [EOL] with open ( [string] ) as f : [EOL] for line , prevlines in search ( f , [string] , [number] ) : [EOL] for pline in prevlines : [EOL] print ( pline , end = [string] ) [EOL] print ( line , end = [string] ) [EOL] print ( [string] * [number] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Union , Tuple , List [EOL] import typing [EOL] def drop_first_last ( grades ) : [EOL] [comment] [EOL] first , * middle , last = grades [EOL] return avg ( middle ) [EOL] [EOL] def avg ( middle ) : [EOL] i = [number] [EOL] grade_total = [number] [EOL] for grade in middle : [EOL] i += [number] [EOL] grade_total += grade [EOL] return grade_total / i [EOL] [EOL] print ( drop_first_last ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] record = ( [string] , [string] , [string] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] name , email , * phone_numbers = record [EOL] print ( name ) [EOL] print ( email ) [EOL] print ( phone_numbers ) [EOL] [EOL] [comment] [EOL] records = [ ( [string] , [number] , [number] ) , ( [string] , [string] ) , ( [string] , [number] , [number] ) , ] [EOL] [EOL] def do_foo ( x , y ) : [EOL] print ( [string] , x , y ) [EOL] def do_bar ( s ) : [EOL] print ( [string] , s ) [EOL] for tag , * args in records : [EOL] if tag == [string] : [EOL] do_foo ( * args ) [EOL] elif tag == [string] : [EOL] do_bar ( * args ) [EOL] [EOL] [comment] [EOL] line = [string] [EOL] uname , * fields , homedir , sh = line . split ( [string] ) [EOL] print ( uname ) [comment] [EOL] print ( homedir ) [comment] [EOL] print ( sh ) [comment] [EOL] [EOL] [comment] [EOL] items = [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] def sum ( items ) : [EOL] head , * tail = items [EOL] return head + sum ( tail ) if tail else head [EOL] print ( sum ( items ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0