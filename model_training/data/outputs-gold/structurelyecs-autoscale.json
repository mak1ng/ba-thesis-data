from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pytest [EOL] [EOL] from ecsautoscale . services import Service [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def service ( ) : [EOL] service = Service ( [string] , None , None , [number] ) [EOL] service . state = { [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] return service [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict [EOL] import typing [EOL] from ecsautoscale . metric_sources import third_party [EOL] [EOL] [EOL] def test_nested_get ( ) : [EOL] data = { [string] : [number] , [string] : { [string] : [number] } } [EOL] assert third_party . _get_nested_field ( data , [string] ) == [number] [EOL] assert third_party . _get_nested_field ( data , [string] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union , Optional , Dict , Tuple [EOL] import builtins [EOL] import typing [EOL] import ecsautoscale [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] [EOL] import pytest [EOL] [EOL] from ecsautoscale . services import Service [EOL] [EOL] [EOL] def test_metric_arithmetic1 ( service ) : [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] assert service . _get_metric ( [string] ) == [number] [EOL] [EOL] [EOL] cases = [ ( [ { [string] : [string] , [string] : [number] , [string] : [number] , [string] : None , } ] , None , [number] , [number] ) , ( [ { [string] : [string] , [string] : [number] , [string] : [number] , [string] : None , } ] , None , [number] , [number] ) , ( [ { [string] : [string] , [string] : [number] , [string] : [number] , [string] : None , } ] , [number] , [number] , [number] ) ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , cases ) def test_pretend_scale ( service , events , max_tasks , desired_tasks_check , task_diff_check ) : [EOL] if max_tasks is not None : [EOL] service . max_tasks = max_tasks [EOL] service . events = events [EOL] service . pretend_scale ( ) [EOL] assert service . desired_tasks == desired_tasks_check [EOL] assert service . task_diff == task_diff_check [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.List[typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]],typing.Optional[builtins.int],builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.List[typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]],typing.Optional[builtins.int],builtins.int,builtins.int]]$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import argparse [EOL] [docstring] [EOL] [EOL] import inspect [EOL] import logging [EOL] import os [EOL] import re [EOL] import sys [EOL] from typing import List [EOL] [EOL] BASE_PATH = os . path . dirname ( os . path . abspath ( inspect . stack ( ) [ [number] ] [ [number] ] ) ) [EOL] sys . path . append ( os . path . join ( BASE_PATH , [string] ) ) [EOL] [EOL] import yaml [EOL] [EOL] from ecsautoscale import asg_client , ecs_client , LOG_LEVEL [EOL] from ecsautoscale . instances import scale_ec2_instances [EOL] from ecsautoscale . services import gather_services , Service [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( LOG_LEVEL ) [EOL] [EOL] [EOL] def load_yaml ( path ) : [EOL] [docstring] [EOL] with open ( path , [string] ) as yamlfile : [EOL] raw = yamlfile . read ( ) [EOL] [comment] [EOL] for match , env_var in re . findall ( [string] , raw ) : [EOL] raw = raw . replace ( match , os . environ [ env_var ] ) [EOL] data = yaml . load ( raw ) [EOL] return data [EOL] [EOL] [EOL] def load_cluster_defs ( ) : [EOL] [docstring] [EOL] cluster_defs = { } [EOL] clusters_defs_path = os . path . join ( BASE_PATH , [string] ) [EOL] for fname in os . listdir ( clusters_defs_path ) : [EOL] if not fname . endswith ( [string] ) : [EOL] continue [EOL] path = os . path . join ( clusters_defs_path , fname ) [EOL] cluster_name = os . path . splitext ( fname ) [ [number] ] [EOL] data = load_yaml ( path ) [EOL] cluster_defs [ cluster_name ] = data [EOL] return cluster_defs [EOL] [EOL] [EOL] def clusters ( ) : [EOL] [docstring] [EOL] response = ecs_client . list_clusters ( ) [EOL] if not response [ [string] ] : [EOL] logger . warning ( [string] ) [EOL] return [ ] [EOL] return response [ [string] ] [EOL] [EOL] [EOL] def lambda_handler ( event , context ) : [EOL] [docstring] [EOL] [comment] [EOL] logger . info ( event ) [EOL] [EOL] is_test_run = event == [string] [EOL] if is_test_run : [EOL] logger . warning ( [string] ) [EOL] [EOL] [comment] [EOL] cluster_defs = load_cluster_defs ( ) [EOL] cluster_list = clusters ( ) [EOL] asg_data = asg_client . describe_auto_scaling_groups ( ) [EOL] if [string] in asg_data : [EOL] asg_data [ [string] ] += asg_client . describe_auto_scaling_groups ( NextToken = asg_data [ [string] ] ) [ [string] ] [EOL] [EOL] for cluster_name in cluster_defs : [EOL] try : [EOL] cluster_def = cluster_defs [ cluster_name ] [EOL] [EOL] [comment] [EOL] if not cluster_def [ [string] ] : [EOL] logger . warning ( [string] . format ( cluster_name ) ) [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] services = gather_services ( cluster_name , cluster_def ) [EOL] n_services = len ( services ) [EOL] logger . info ( [string] . format ( cluster_name , n_services ) ) [EOL] [EOL] [comment] [EOL] if cluster_def [ [string] ] > [number] or cluster_def [ [string] ] > [number] : [EOL] logger . info ( [string] [string] [string] . format ( cluster_name , cluster_def [ [string] ] , cluster_def [ [string] ] ) ) [EOL] buffer_service = Service ( cluster_name , None , None , [number] , min_tasks = [number] , max_tasks = [number] ) [EOL] buffer_service . task_cpu = cluster_def [ [string] ] [EOL] buffer_service . task_mem = cluster_def [ [string] ] [EOL] buffer_service . task_diff = [number] [EOL] services . append ( buffer_service ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] res = scale_ec2_instances ( cluster_name , cluster_def , asg_data , cluster_list , services , is_test_run = is_test_run , ) [EOL] if res == - [number] : [EOL] if n_services > [number] : [EOL] logger . warning ( [string] [string] . format ( cluster_name ) ) [EOL] [comment] [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] for service in sorted ( services , key = lambda x : x . task_diff ) : [EOL] service . scale ( is_test_run = is_test_run ) [EOL] [EOL] except Exception as ex : [EOL] logger . exception ( ex ) [EOL] [EOL] [EOL] def run_test ( ) : [EOL] [docstring] [EOL] import argparse [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , action = [string] ) [EOL] opts = parser . parse_args ( ) [EOL] if opts . test : [EOL] test_event = [string] [EOL] else : [EOL] test_event = [number] [EOL] lambda_handler ( test_event , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] run_test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import os [EOL] [EOL] import boto3 [EOL] [EOL] [EOL] LOG_LEVEL_STR = os . environ . get ( [string] , [string] ) [EOL] LOG_LEVEL = getattr ( logging , LOG_LEVEL_STR . upper ( ) ) [EOL] [EOL] logging . basicConfig ( level = LOG_LEVEL ) [EOL] [EOL] [comment] [EOL] ecs_client = boto3 . client ( [string] ) [EOL] asg_client = boto3 . client ( [string] ) [EOL] cdw_client = boto3 . client ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class Error ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ClusterARNError ( Error ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cluster_name ) : [EOL] self . cluster_name = cluster_name [EOL] message = f" [string] { cluster_name }" [EOL] super ( ClusterARNError , self ) . __init__ ( message ) [EOL] [EOL] [EOL] class ASGGroupError ( Error ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , asg_group_name ) : [EOL] self . asg_group_name = asg_group_name [EOL] message = f" [string] { asg_group_name }" [EOL] super ( ASGGroupError , self ) . __init__ ( message ) [EOL] [EOL] [EOL] class MissingResourceValueError ( Error ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , resource ) : [EOL] self . resource = resource [EOL] message = f" [string] { resource }" [EOL] super ( MissingResourceValueError , self ) . __init__ ( message ) [EOL] [EOL] [EOL] class CloudWatchError ( Error ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , namespace , metric_name , dimensions , period , statistics ) : [EOL] self . namespace = namespace [EOL] self . metric_name = metric_name [EOL] self . dimensions = dimensions [EOL] self . period = period [EOL] self . statistics = statistics [EOL] message = [string] [string] [string] [string] [string] [string] . format ( namespace , metric_name , dimensions , period , statistics ) [EOL] super ( CloudWatchError , self ) . __init__ ( message ) [EOL] [EOL] [EOL] class ThirdPartyError ( Error ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , status_code , url ) : [EOL] self . status_code = status_code [EOL] self . url = url [EOL] message = [string] [string] [string] . format ( status_code , url ) [EOL] super ( ThirdPartyError , self ) . __init__ ( message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] from typing import List [EOL] [EOL] import ecsautoscale . metric_sources . third_party [EOL] import ecsautoscale . metric_sources . cloudwatch [EOL] from . import ecs_client , LOG_LEVEL [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( LOG_LEVEL ) [EOL] [EOL] class Service : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cluster_name , service_name , task_name , task_count , events = None , metric_sources = None , min_tasks = [number] , max_tasks = [number] , state = None ) : [EOL] self . cluster_name = cluster_name [EOL] self . service_name = service_name [EOL] self . task_count = task_count [EOL] self . task_name = task_name [EOL] self . min_tasks = min_tasks [EOL] self . max_tasks = max_tasks [EOL] self . events = events or [ ] [EOL] self . metric_sources = metric_sources or { } [EOL] [EOL] if task_name : [EOL] task_definition_data = ecs_client . describe_task_definition ( taskDefinition = task_name ) [EOL] self . task_cpu = [number] [EOL] self . task_mem = [number] [EOL] containers = task_definition_data [ [string] ] [ [string] ] [EOL] for container in containers : [EOL] self . task_cpu += container [ [string] ] [EOL] self . task_mem += container [ [string] ] [EOL] else : [EOL] self . task_cpu = [number] [EOL] self . task_mem = [number] [EOL] [EOL] [comment] [EOL] self . state = state or { } [EOL] for source_name in self . metric_sources : [EOL] source = getattr ( ecsautoscale . metric_sources , source_name ) [EOL] for item in self . metric_sources [ source_name ] : [EOL] res = source . get_data ( ** item ) [EOL] if res : [EOL] self . state . update ( res ) [EOL] [EOL] self . desired_tasks = [number] [EOL] self . task_diff = [number] [EOL] [EOL] if self . service_name is not None : [EOL] logger . info ( [string] [string] [string] [string] . format ( self . cluster_name , self . service_name , self . task_count , self . min_tasks , self . max_tasks , ) ) [EOL] [EOL] def _get_metric ( self , metric_str ) : [EOL] for metric_name in self . state : [EOL] metric_str = metric_str . replace ( metric_name , str ( self . state [ metric_name ] ) ) [EOL] return eval ( metric_str ) [EOL] [EOL] def pretend_scale ( self ) : [EOL] [docstring] [EOL] if self . task_count < self . min_tasks : [EOL] self . task_diff = self . min_tasks - self . task_count [EOL] self . desired_tasks = self . min_tasks [EOL] return True [EOL] [EOL] if self . task_count > self . max_tasks : [EOL] self . task_diff = self . task_count - self . max_tasks [EOL] self . desired_tasks = self . max_tasks [EOL] return True [EOL] [EOL] for event in self . events : [EOL] metric_name = event [ [string] ] [EOL] metric = self . _get_metric ( metric_name ) [EOL] if metric is None : [EOL] return False [EOL] [EOL] if event [ [string] ] is not None and metric > event [ [string] ] : [EOL] continue [EOL] [EOL] if event [ [string] ] is not None and metric < event [ [string] ] : [EOL] continue [EOL] [EOL] desired_tasks = self . task_count + event [ [string] ] [EOL] if desired_tasks < self . min_tasks : [EOL] if self . task_count == self . min_tasks : [EOL] continue [EOL] desired_tasks = self . min_tasks [EOL] [EOL] elif desired_tasks > self . max_tasks : [EOL] if self . task_count == self . max_tasks : [EOL] continue [EOL] desired_tasks = self . max_tasks [EOL] [EOL] self . desired_tasks = desired_tasks [EOL] self . task_diff = self . desired_tasks - self . task_count [EOL] logger . info ( [string] [string] [string] [string] [string] [string] , self . cluster_name , self . service_name , metric_name , metric , event [ [string] ] , event [ [string] ] , event [ [string] ] , ) [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def scale ( self , is_test_run = False ) : [EOL] [docstring] [EOL] if self . desired_tasks is not None and self . task_diff != [number] and self . service_name is not None : [EOL] logger . info ( [string] . format ( self . cluster_name , self . service_name , self . desired_tasks , ) ) [EOL] if not is_test_run : [EOL] ecs_client . update_service ( cluster = self . cluster_name , service = self . service_name , desiredCount = self . desired_tasks , ) [EOL] [EOL] def chunks ( l , n ) : [EOL] [docstring] [EOL] for i in range ( [number] , len ( l ) , n ) : [EOL] yield l [ i : i + n ] [EOL] [EOL] def get_services ( cluster_name , cluster_def ) : [EOL] out = { } [EOL] service_names = cluster_def [ [string] ] . keys ( ) [EOL] if not service_names : [EOL] return out [EOL] for service_names_chunk in chunks ( list ( service_names ) , [number] ) : [EOL] res = ecs_client . describe_services ( cluster = cluster_name , services = service_names_chunk ) [EOL] for item in res [ [string] ] : [EOL] name = item [ [string] ] [EOL] out [ name ] = { [string] : item [ [string] ] , [string] : item [ [string] ] , } [EOL] return out [EOL] [EOL] [EOL] def gather_services ( cluster_name , cluster_def ) : [EOL] logger . info ( [string] . format ( cluster_name ) ) [EOL] [EOL] services_data = get_services ( cluster_name , cluster_def ) [EOL] services = [ ] [EOL] for service_name in services_data : [EOL] logger . info ( [string] . format ( cluster_name , service_name ) ) [EOL] if not cluster_def [ [string] ] [ service_name ] [ [string] ] : [EOL] logger . info ( [string] . format ( cluster_name , service_name ) ) [EOL] continue [EOL] service = cluster_def [ [string] ] [ service_name ] [EOL] task_name = services_data [ service_name ] [ [string] ] [EOL] task_count = services_data [ service_name ] [ [string] ] [EOL] service = Service ( cluster_name , service_name , task_name , task_count , events = service [ [string] ] , metric_sources = service [ [string] ] , min_tasks = service [ [string] ] , max_tasks = service [ [string] ] ) [EOL] should_scale = service . pretend_scale ( ) [EOL] if should_scale : [EOL] services . append ( service ) [EOL] [EOL] return services [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Service]$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] [EOL] from datetime import datetime , timedelta [EOL] import logging [EOL] from typing import List [EOL] [EOL] from ecsautoscale import cdw_client [EOL] from ecsautoscale . exceptions import CloudWatchError [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] def _format_dimensions ( dimensions ) : [EOL] out = [ ] [EOL] for item in dimensions : [EOL] out . append ( { [string] : item [ [string] ] , [string] : item [ [string] ] , } ) [EOL] return out [EOL] [EOL] [EOL] def get_data ( metric_name = [string] , dimensions = None , statistics = None , namespace = [string] , period = [number] ) : [EOL] [docstring] [EOL] statistics = statistics or [ ] [EOL] dimensions = dimensions or [ ] [EOL] [EOL] out = { x [ [string] ] : None for x in statistics } [EOL] [EOL] dimensions_ = _format_dimensions ( dimensions ) [EOL] statistics_ = [ x [ [string] ] for x in statistics ] [EOL] now = datetime . now ( ) [EOL] res = cdw_client . get_metric_statistics ( Namespace = namespace , MetricName = metric_name , Dimensions = dimensions_ , StartTime = now - timedelta ( seconds = period ) , EndTime = now , Period = period , Statistics = statistics_ , ) [EOL] datapoints = res [ [string] ] [EOL] if not datapoints : [EOL] raise CloudWatchError ( namespace , metric_name , dimensions_ , period , statistics_ ) [EOL] [EOL] log_messages = [ [string] ] [EOL] for stat in statistics : [EOL] key = stat [ [string] ] [EOL] val = datapoints [ [number] ] . get ( stat [ [string] ] ) [EOL] out [ key ] = val [EOL] log_messages . append ( [string] . format ( key , val ) ) [EOL] [EOL] if out : [EOL] logger . debug ( [string] . join ( log_messages ) ) [EOL] [EOL] return out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] import logging [EOL] [EOL] import requests [EOL] [EOL] from ecsautoscale . exceptions import ThirdPartyError [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] def _get_nested_field ( data , field ) : [EOL] subdata = data [EOL] levels = field . split ( [string] ) [EOL] for level in levels : [EOL] subdata = subdata [ level ] [EOL] return subdata [EOL] [EOL] [EOL] def get_data ( url = None , statistics = None , method = [string] , payload = None ) : [EOL] [docstring] [EOL] [comment] [EOL] assert method in [ [string] , [string] ] [EOL] [EOL] statistics = statistics or [ ] [EOL] [EOL] out = { x [ [string] ] : None for x in statistics } [EOL] [EOL] method_ = getattr ( requests , method . lower ( ) ) [EOL] resp = method_ ( url , json = payload ) [EOL] if resp . status_code != [number] : [EOL] raise ThirdPartyError ( resp . status_code , url ) [EOL] [EOL] data = resp . json ( ) [EOL] log_messages = [ [string] ] [EOL] for stat in statistics : [EOL] key = stat [ [string] ] [EOL] val = _get_nested_field ( data , stat [ [string] ] ) [EOL] out [ key ] = val [EOL] log_messages . append ( [string] . format ( key , val ) ) [EOL] if out : [EOL] logger . debug ( [string] . join ( log_messages ) ) [EOL] [EOL] return out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0