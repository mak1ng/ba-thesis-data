[comment] [EOL] from dotenv import load_dotenv [EOL] [EOL] if __name__ == [string] : [EOL] load_dotenv ( [string] ) [EOL] import txmaker [EOL] txmaker . run_app ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] from . config import ConfigurationError [EOL] from . server import run_app [EOL] [EOL] __all__ = ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] from typing import Any [EOL] [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import TestClient [EOL] [EOL] [EOL] async def test_create_transaction_invalid_request ( client ) : [EOL] response = await client . post ( [string] , data = [string] ) [EOL] assert response . status == [number] [EOL] [EOL] [EOL] async def test_create_transaction_with_negative_amounts ( client ) : [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : [number] } ) [EOL] assert response . status == [number] [EOL] response_data = await response . json ( ) [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_create_transaction_with_negative_fee ( client ) : [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] , } , [string] : - [number] } ) [EOL] assert response . status == [number] [EOL] response_data = await response . json ( ) [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_create_transaction_with_invalid_amount_precision_input ( client ) : [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : [number] } ) [EOL] assert response . status == [number] [EOL] response_data = await response . json ( ) [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_create_transaction_with_empty_outputs ( client ) : [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { } , [string] : [number] , } ) [EOL] assert response . status == [number] [EOL] response_data = await response . json ( ) [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_create_if_no_available_utxos ( client , mock_unspent_response ) : [EOL] await mock_unspent_response ( web . Response ( body = [string] , status = [number] ) ) [EOL] [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] } , [string] : [number] } ) [EOL] [EOL] assert response . status == [number] [EOL] response_data = await response . json ( ) [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_create_if_no_available_confirmed_utxos ( client , mock_unspent_response ) : [EOL] await mock_unspent_response ( web . json_response ( { [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } ] } ) ) [EOL] [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] } , [string] : [number] } ) [EOL] [EOL] response_data = await response . json ( ) [EOL] assert response . status == [number] [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_create_transaction_if_invalid_source_address ( client ) : [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] } , [string] : [number] } ) [EOL] response_data = await response . json ( ) [EOL] assert response . status == [number] [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_create_transaction_if_invalid_output_address ( client ) : [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [number] } ) [EOL] response_data = await response . json ( ) [EOL] assert response . status == [number] [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] assert response_data [ [string] ] [ [string] ] [ [string] ] == [ [string] , [string] ] [EOL] [EOL] [EOL] async def test_create_transaction_if_insufficient_funds ( client , mock_unspent_response ) : [EOL] await mock_unspent_response ( web . json_response ( { [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , } , ] } ) ) [EOL] [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] } , [string] : [number] } ) [EOL] [EOL] assert response . status == [number] [EOL] response_data = await response . json ( ) [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_create_transaction_with_p2sh_input ( client ) : [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : [number] } ) [EOL] assert response . status == [number] [EOL] response_data = await response . json ( ) [EOL] assert response_data [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_create_transaction_if_both_p2sh_and_p2pkh_outputs ( client , mock_unspent_response ) : [EOL] await mock_unspent_response ( web . json_response ( { [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } ] } ) ) [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : [number] } ) [EOL] [EOL] assert response . status == [number] [EOL] response_data = await response . json ( ) [EOL] assert response_data == { [string] : [string] [string] [string] [string] [string] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } ] } [EOL] [EOL] [EOL] async def test_create_transaction_if_no_change ( client , mock_unspent_response ) : [EOL] await mock_unspent_response ( web . json_response ( { [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , ] } ) ) [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] , } , [string] : [number] } ) [EOL] [EOL] assert response . status == [number] [EOL] response_data = await response . json ( ) [EOL] assert response_data == { [string] : [string] [string] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } ] } [EOL] [EOL] [EOL] async def test_create_transaction_with_many_inputs ( client , mock_unspent_response ) : [EOL] await mock_unspent_response ( web . json_response ( { [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } ] , } ) ) [EOL] [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : [number] } ) [EOL] [EOL] response_data = await response . json ( ) [EOL] assert response_data == { [string] : [string] [string] [string] [string] [string] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , } ] } [EOL] [EOL] assert response . status == [number] [EOL] [EOL] [EOL] async def test_create_transaction_with_p2pkh_output ( client , mock_unspent_response ) : [EOL] await mock_unspent_response ( web . json_response ( { [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } ] } ) ) [EOL] [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : [number] } ) [EOL] [EOL] assert response . status == [number] [EOL] response_data = await response . json ( ) [EOL] [EOL] assert response_data == { [string] : [string] [string] [string] [string] [string] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Callable , Dict , Any , Iterable , Type [EOL] import _pytest [EOL] import builtins [EOL] import txmaker [EOL] import typing [EOL] import asyncio [EOL] import aiohttp [EOL] from asyncio import AbstractEventLoop [EOL] from typing import Any , Awaitable , Callable , Iterable , List , Type [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] from _pytest . monkeypatch import MonkeyPatch [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import TestClient [EOL] from aiohttp . web import AbstractRouteDef [EOL] from aiohttp . web_app import Application [EOL] [EOL] from . bitcoin import is_valid_address [EOL] from . server import make_app [EOL] from . testing import mocks [EOL] [EOL] AIOHTTP_CLIENT_FIXTURE = Callable [ [ Application ] , Awaitable [ TestClient ] ] [EOL] [EOL] [EOL] @ pytest . fixture def loop ( event_loop ) : [EOL] return event_loop [EOL] [EOL] [EOL] @ pytest . fixture async def app ( loop ) : [EOL] yield await make_app ( ) [EOL] [EOL] [EOL] @ pytest . fixture async def client ( app , aiohttp_client ) : [EOL] yield await aiohttp_client ( app ) [EOL] [EOL] [EOL] @ pytest . fixture async def mock_unspent_response ( fake_server_client_factory , monkeypatch ) : [EOL] async def mock ( mock_response ) : [EOL] def mock_handler ( request ) : [EOL] assert [string] in request . query [EOL] assert is_valid_address ( request . query [ [string] ] ) [EOL] [EOL] return mock_response [EOL] fake_server_client = await fake_server_client_factory ( hosts = [ [string] ] , routes = [ web . get ( [string] , mock_handler ) ] , ) [EOL] monkeypatch . setattr ( [string] , fake_server_client ) [EOL] yield mock [EOL] [EOL] [EOL] @ pytest . fixture async def fake_server_client_factory ( ) : [EOL] running_server = None [EOL] [EOL] async def factory ( hosts , routes ) : [EOL] nonlocal running_server [EOL] running_server = mocks . FakeServer ( hosts ) [EOL] running_server . add_routes ( routes ) [EOL] info = await running_server . start ( ) [EOL] resolver = mocks . FakeResolver ( info ) [EOL] connector = aiohttp . TCPConnector ( resolver = resolver , verify_ssl = False ) [EOL] [EOL] class FakeClientSession ( aiohttp . ClientSession ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] kwargs [ [string] ] = connector [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] return FakeClientSession [EOL] [EOL] yield factory [EOL] [EOL] if running_server is not None : [EOL] await running_server . stop ( ) [EOL] [EOL] [EOL] def pytest_configure ( config ) : [EOL] import sys [EOL] [EOL] setattr ( sys , [string] , True ) [EOL] [EOL] [EOL] def pytest_unconfigure ( config ) : [EOL] import sys [EOL] [EOL] delattr ( sys , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import txmaker [EOL] import sys [EOL] [EOL] from pydantic import BaseSettings , ValidationError [EOL] [EOL] [EOL] class Settings ( BaseSettings ) : [EOL] port = [number] [EOL] testnet = False [EOL] [EOL] @ property def min_confirmations ( self ) : [EOL] if self . testnet and not hasattr ( sys , [string] ) : [EOL] return [number] [EOL] return [number] [EOL] [EOL] @ property def blockchain_info_base_url ( self ) : [EOL] if self . testnet : [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ property def btc_network ( self ) : [EOL] if self . testnet : [EOL] return [string] [EOL] return [string] [EOL] [EOL] class Config : [EOL] env_prefix = [string] [EOL] case_insensitive = True [EOL] [EOL] [EOL] class ConfigurationError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] try : [EOL] settings = Settings ( ) [EOL] except ValidationError as e : [EOL] msg = f" [string] { e } [string] " [EOL] raise ConfigurationError ( msg ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( settings ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $txmaker.config.Settings$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $txmaker.config.Settings$ 0 0
from typing import List , Tuple , Dict , Type , Any [EOL] import builtins [EOL] import decimal [EOL] import txmaker [EOL] import typing [EOL] import aiohttp [EOL] import math [EOL] from decimal import Decimal [EOL] from typing import Dict , List , Tuple [EOL] [EOL] import aiohttp [EOL] import bit . exceptions [EOL] from bit . constants import LOCK_TIME , VERSION_2 [EOL] from bit . format import get_version [EOL] from bit . transaction import TxIn , address_to_scriptpubkey , construct_outputs , int_to_unknown_bytes [EOL] from bit . utils import hex_to_bytes [EOL] [EOL] from . config import settings [EOL] [EOL] DUST_THRESHOLD = [number] [EOL] SATOSHI_MULTIPLIER = Decimal ( [string] ) [EOL] MIN_RELAY_FEE = [number] [EOL] MIN_OUTPUT_SIZE = Decimal ( [string] ) [EOL] [EOL] [EOL] def estimate_tx_size ( n_in , in_size , n_out , out_size ) : [EOL] [docstring] [EOL] return ( in_size + len ( int_to_unknown_bytes ( n_in , byteorder = [string] ) ) + out_size + len ( int_to_unknown_bytes ( n_out , byteorder = [string] ) ) + [number] ) [EOL] [EOL] [EOL] def calc_in_size ( n_in ) : [EOL] [docstring] [EOL] return [number] * n_in [EOL] [EOL] [EOL] def calc_out_size ( addresses ) : [EOL] [docstring] [EOL] return sum ( len ( address_to_scriptpubkey ( o ) ) + [number] for o in addresses ) [EOL] [EOL] [EOL] def estimate_tx_fee ( n_in , in_size , n_out , out_size , fee_kb ) : [EOL] [docstring] [EOL] assert fee_kb >= MIN_RELAY_FEE [EOL] size = estimate_tx_size ( n_in , in_size , n_out , out_size ) [EOL] return math . ceil ( size * fee_kb * [number] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class Unspent ( bit . wallet . Unspent ) : [EOL] pass [EOL] [EOL] [EOL] class TxObj ( bit . transaction . TxObj ) : [EOL] pass [EOL] [EOL] [EOL] class InsufficientFunds ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] Output = Tuple [ str , int ] [EOL] [EOL] [EOL] def select_unspents ( source_address , unspents , outputs , fee_kb ) : [EOL] [docstring] [EOL] out_addresses = [ ] [EOL] out_amount = [number] [EOL] [EOL] for addr , amount in outputs : [EOL] out_addresses . append ( addr ) [EOL] out_amount += amount [EOL] [EOL] n_out = len ( out_addresses ) + [number] [EOL] out_size = calc_out_size ( out_addresses + [ source_address ] ) [EOL] [EOL] selected_inputs = [ ] [EOL] spending_amount = [number] [EOL] [EOL] for u in unspents : [EOL] spending_amount += u . amount [EOL] selected_inputs . append ( u ) [EOL] n_in = len ( selected_inputs ) [EOL] in_size = calc_in_size ( n_in ) [EOL] fee = estimate_tx_fee ( n_in , in_size , n_out , out_size , fee_kb ) [EOL] if out_amount + fee <= spending_amount : [EOL] break [EOL] else : [EOL] raise InsufficientFunds ( f' [string] { spending_amount } [string] { out_amount + fee } [string] ' ) [EOL] [EOL] return selected_inputs , spending_amount - ( out_amount + fee ) [EOL] [EOL] [EOL] async def create_unsigned_transaction ( source_address , outputs_dict , fee_kb ) : [EOL] all_utxos = await get_unspent ( source_address ) [EOL] confirmed_utxos = [ u for u in all_utxos if u . confirmations >= settings . min_confirmations ] [EOL] [EOL] if not confirmed_utxos : [EOL] raise InsufficientFunds ( [string] ) [EOL] [EOL] outputs = [ ( addr , int ( amount * SATOSHI_MULTIPLIER ) ) for addr , amount in outputs_dict . items ( ) ] [EOL] inputs , change_amount = select_unspents ( source_address , confirmed_utxos , outputs , fee_kb ) [EOL] [EOL] if change_amount > DUST_THRESHOLD : [EOL] outputs . append ( ( source_address , change_amount ) ) [EOL] [EOL] version = VERSION_2 [EOL] lock_time = LOCK_TIME [EOL] raw_outputs = construct_outputs ( outputs ) [EOL] raw_inputs = [ ] [EOL] [EOL] for unspent in inputs : [EOL] script_sig = [string] [EOL] txid = hex_to_bytes ( unspent . txid ) [ : : - [number] ] [EOL] txindex = unspent . txindex . to_bytes ( [number] , byteorder = [string] ) [EOL] amount = int ( unspent . amount ) . to_bytes ( [number] , byteorder = [string] ) [EOL] raw_inputs . append ( TxIn ( script_sig , txid , txindex , amount = amount ) ) [EOL] [EOL] tx_unsigned = TxObj ( version , raw_inputs , raw_outputs , lock_time ) [EOL] return tx_unsigned , inputs [EOL] [EOL] [EOL] async def get_unspent ( address ) : [EOL] url = settings . blockchain_info_base_url + [string] [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] resp = await session . get ( url , params = { [string] : address } ) [EOL] if resp . status == [number] : [EOL] return [ ] [EOL] elif resp . status != [number] : [EOL] raise ConnectionError [EOL] resp_data = await resp . json ( ) [EOL] return [ Unspent ( amount = tx [ [string] ] , confirmations = tx [ [string] ] , script = tx [ [string] ] , txid = tx [ [string] ] , txindex = tx [ [string] ] ) for tx in resp_data [ [string] ] ] [ : : - [number] ] [comment] [EOL] [EOL] [EOL] def is_valid_address ( bitcoin_address ) : [EOL] try : [EOL] return get_version ( bitcoin_address ) == settings . btc_network [EOL] except ValueError : [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[TxObj,typing.List[Unspent]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Unspent]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Optional , Dict , Any , Type [EOL] import functools [EOL] import pydantic [EOL] import builtins [EOL] import typing [EOL] import aiohttp [EOL] import json [EOL] from decimal import Decimal [EOL] from functools import partial , wraps [EOL] from typing import Any , Awaitable , Callable , Dict , Optional , Type [EOL] [EOL] from aiohttp import web [EOL] from pydantic import BaseModel , ValidationError [EOL] [EOL] [EOL] class DecimalJsonEncoder ( json . JSONEncoder ) : [EOL] def default ( self , obj ) : [EOL] if isinstance ( obj , Decimal ) : [EOL] return str ( obj ) [EOL] return super ( ) . default ( obj ) [EOL] [EOL] [EOL] json_dumps = partial ( json . dumps , cls = DecimalJsonEncoder , indent = [number] ) [EOL] json_response = partial ( web . json_response , dumps = json_dumps ) [EOL] [EOL] [EOL] def error_response ( code , message = None , * , details = None , status_code = [number] ) : [EOL] error = { [string] : code , [string] : message , } [EOL] if details is not None : [EOL] error [ [string] ] = details [comment] [EOL] return json_response ( { [string] : error } , status = status_code ) [EOL] [EOL] [EOL] AIOHTTP_HANDLER = Callable [ [ web . Request , BaseModel ] , Awaitable [ web . Response ] ] [EOL] [EOL] [EOL] def validate_request ( req_model ) : [EOL] def decorator ( handler ) : [EOL] async def wrapped_handler ( request ) : [EOL] body = await request . read ( ) if request . can_read_body else [string] [EOL] try : [EOL] req_obj = req_model . parse_raw ( body , content_type = [string] ) [EOL] except ValidationError as e : [EOL] return error_response ( [string] , [string] , details = { [string] : e . errors ( ) , [string] : req_model . schema ( ) } ) [EOL] return await handler ( request , req_obj ) [EOL] return wraps ( handler ) ( wrapped_handler ) [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[AIOHTTP_HANDLER],AIOHTTP_HANDLER]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Dict , Any , Iterable , Type [EOL] import socket [EOL] import builtins [EOL] import txmaker [EOL] import typing [EOL] import asyncio [EOL] import aiohttp [EOL] import os . path [EOL] import socket [EOL] import ssl [EOL] from asyncio import AbstractEventLoop , get_event_loop [EOL] from typing import Any , Dict , Iterable , List , Optional [EOL] [EOL] from aiohttp import web [EOL] from aiohttp . resolver import DefaultResolver [EOL] from aiohttp . test_utils import unused_port [EOL] from aiohttp . web import AbstractRouteDef [EOL] [EOL] [EOL] class FakeResolver : [EOL] _LOCAL_HOST = { [number] : [string] , socket . AF_INET : [string] , socket . AF_INET6 : [string] } [EOL] [EOL] def __init__ ( self , fakes , * , loop = None ) : [EOL] [docstring] [EOL] loop = loop or get_event_loop ( ) [EOL] self . _fakes = fakes [EOL] self . _resolver = DefaultResolver ( loop = loop ) [EOL] [EOL] async def resolve ( self , host , port = [number] , family = socket . AF_INET ) : [EOL] fake_port = self . _fakes . get ( host ) [EOL] if fake_port is not None : [EOL] return [ { [string] : host , [string] : self . _LOCAL_HOST [ family ] , [string] : fake_port , [string] : family , [string] : [number] , [string] : socket . AI_NUMERICHOST } ] [EOL] else : [EOL] return await self . _resolver . resolve ( host , port , family ) [EOL] [EOL] [EOL] class FakeServer : [EOL] def __init__ ( self , hosts , loop = None ) : [EOL] self . hosts = hosts [EOL] self . loop = loop or get_event_loop ( ) [EOL] self . app = web . Application ( loop = loop ) [EOL] self . runner = web . AppRunner ( self . app ) [EOL] cert_dir = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] ssl_cert = os . path . join ( cert_dir , [string] ) [EOL] ssl_key = os . path . join ( cert_dir , [string] ) [EOL] self . ssl_context = ssl . create_default_context ( ssl . Purpose . CLIENT_AUTH ) [EOL] self . ssl_context . load_cert_chain ( str ( ssl_cert ) , str ( ssl_key ) ) [EOL] [EOL] def add_routes ( self , routes ) : [EOL] self . app . router . add_routes ( routes ) [EOL] [EOL] async def start ( self ) : [EOL] port = unused_port ( ) [EOL] await self . runner . setup ( ) [EOL] site = web . TCPSite ( self . runner , [string] , port , ssl_context = self . ssl_context ) [EOL] await site . start ( ) [EOL] return { h : port for h in self . hosts } [EOL] [EOL] async def stop ( self ) : [EOL] await self . runner . cleanup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.Optional[asyncio.events.AbstractEventLoop]$ 0 0 0 0 0 0 0 $typing.Optional[asyncio.events.AbstractEventLoop]$ 0 $typing.Optional[asyncio.events.AbstractEventLoop]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Optional[asyncio.events.AbstractEventLoop]$ 0 $typing.Optional[asyncio.events.AbstractEventLoop]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $socket.AddressFamily$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $socket.AddressFamily$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $socket.AddressFamily$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $socket.AddressFamily$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[aiohttp.web.AbstractRouteDef]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[aiohttp.web.AbstractRouteDef]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0