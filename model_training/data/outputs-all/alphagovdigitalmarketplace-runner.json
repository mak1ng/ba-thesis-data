[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from distutils . core import setup [EOL] [EOL] with open ( [string] ) as reqfile : [EOL] requirements = reqfile . read ( ) . split ( ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , author = [string] , author_email = [string] , packages = [ [string] ] , install_requires = requirements , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0
[comment] [EOL] [EOL] import argparse [EOL] import dmrunner [EOL] import argparse [EOL] from dmrunner . runner import DMRunner , RUNNER_COMMANDS [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] [string] , ) [EOL] parser . add_argument ( [string] , [string] , type = str , default = [string] , help = [string] [string] , ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , choices = RUNNER_COMMANDS , help = [string] [string] [string] [string] , ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] runner = DMRunner ( command = args . command . lower ( ) , rebuild = args . rebuild , config_path = args . config_path ) [EOL] runner . run ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any , Union , Literal , List , Dict [EOL] import builtins [EOL] import distutils [EOL] import multiprocessing [EOL] import typing_extensions [EOL] import typing [EOL] import subprocess [EOL] [docstring] [EOL] from distutils . version import LooseVersion [EOL] import docker [EOL] import errno [EOL] import glob [EOL] import gzip [EOL] import itertools [EOL] import multiprocessing [EOL] import os [EOL] from pathlib import Path [EOL] import psutil [EOL] import requests [EOL] import subprocess [EOL] import threading [EOL] import time [EOL] from typing import Callable , Dict [EOL] import webbrowser [EOL] [EOL] from dmrunner . utils import ( APP_COMMAND_RESTART , EXITCODE_BAD_SERVICES , EXITCODE_BOOTSTRAP_FAILED , EXITCODE_CONFIG_NO_EXIST , EXITCODE_DOCKER_NOT_AVAILABLE , EXITCODE_GIT_AUTH_FAILED , EXITCODE_GIT_NOT_AVAILABLE , EXITCODE_NODE_NOT_IN_PATH , EXITCODE_NODE_VERSION_NOT_SUITABLE , EXITCODE_SETUP_ABORT , RUNNER_COMMAND_DATA , RUNNER_COMMAND_RUN , group_by_key , get_app_info , get_yes_no_input , nologger , red , yellow , green , bold , load_config , save_config , ) [EOL] from dmrunner . process import DMServices , DMProcess , background_services , blank_context [EOL] [EOL] MINIMUM_DOCKER_VERSION = LooseVersion ( [string] ) [EOL] [comment] [EOL] SPECIFIC_NODE_VERSION = LooseVersion ( Path ( [string] ) . read_text ( ) . strip ( ) ) [EOL] [EOL] [EOL] def _setup_config_modifications ( logger , config , config_path ) : [EOL] exitcode , interim_config = load_config ( config_path ) [EOL] [EOL] if not exitcode : [EOL] default_code_directory = os . path . realpath ( interim_config [ [string] ] [ [string] ] ) [EOL] logger ( [string] [string] ) [EOL] logger ( [string] [string] ) [EOL] logger ( [string] . format ( yellow ( default_code_directory ) ) , end = [string] ) [EOL] requested_code_directory = os . path . realpath ( input ( [string] ) . strip ( ) or default_code_directory ) [EOL] os . makedirs ( requested_code_directory , exist_ok = True ) [EOL] [EOL] logger ( [string] + yellow ( requested_code_directory ) ) [EOL] interim_config [ [string] ] [ [string] ] = requested_code_directory [EOL] [EOL] current_decryption = interim_config [ [string] ] [ [string] ] [EOL] logger ( [string] ) [EOL] logger ( [string] ) [EOL] logger ( [string] . format ( yellow ( [string] if current_decryption is True else [string] ) ) , end = [string] ) [EOL] cleaned_input = input ( [string] ) . strip ( ) . lower ( ) [EOL] decrypt_credentials = current_decryption if not cleaned_input else True if cleaned_input == [string] else False [EOL] [EOL] logger ( [string] + ( green ( [string] ) if decrypt_credentials else red ( [string] ) ) + [string] ) [EOL] interim_config [ [string] ] [ [string] ] = decrypt_credentials [EOL] [EOL] save_config ( interim_config , config_path ) [EOL] [EOL] [comment] [EOL] config . update ( interim_config ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] def _setup_logging_directory ( config ) : [EOL] [comment] [EOL] try : [EOL] os . makedirs ( os . path . join ( os . path . realpath ( [string] ) , config [ [string] ] [ [string] ] ) ) [EOL] [EOL] except OSError as e : [EOL] if e . errno != errno . EEXIST : [EOL] return e . errno [EOL] [EOL] return [number] [EOL] [EOL] [EOL] def _setup_check_git_available ( logger ) : [EOL] logger ( bold ( [string] ) ) [EOL] [EOL] try : [EOL] subprocess . check_call ( [ [string] , [string] ] , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL ) [EOL] logger ( green ( [string] ) ) [EOL] [EOL] except Exception : [comment] [EOL] logger ( red ( [string] ) ) [EOL] return EXITCODE_GIT_NOT_AVAILABLE [EOL] [EOL] return [number] [EOL] [EOL] [EOL] def _setup_check_docker_available ( logger ) : [EOL] logger ( bold ( [string] ) ) [EOL] [EOL] try : [EOL] docker_client = docker . from_env ( ) [EOL] [EOL] except requests . exceptions . ConnectionError : [EOL] logger ( red ( [string] [string] ) ) [EOL] return EXITCODE_DOCKER_NOT_AVAILABLE [EOL] [EOL] except docker . errors . APIError as e : [EOL] logger ( red ( [string] [string] . format ( e ) ) ) [EOL] return EXITCODE_DOCKER_NOT_AVAILABLE [EOL] [EOL] except Exception as e : [EOL] logger ( red ( [string] [string] . format ( e ) ) ) [EOL] return EXITCODE_DOCKER_NOT_AVAILABLE [EOL] [EOL] try : [EOL] docker_version = LooseVersion ( docker_client . version ( ) [ [string] ] ) [EOL] assert docker_version >= MINIMUM_DOCKER_VERSION [EOL] [EOL] except AssertionError : [EOL] logger ( yellow ( [string] [string] . format ( docker_version , MINIMUM_DOCKER_VERSION ) ) ) [EOL] [EOL] else : [EOL] logger ( green ( [string] . format ( docker_version ) ) ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] def _setup_check_node_version ( logger ) : [EOL] exitcode = [number] [EOL] logger ( bold ( [string] ) ) [EOL] [EOL] try : [EOL] node_version = LooseVersion ( subprocess . check_output ( [ [string] , [string] ] , universal_newlines = True ) . strip ( ) ) [EOL] [EOL] except Exception : [EOL] logger ( red ( [string] ) ) [EOL] exitcode = EXITCODE_NODE_NOT_IN_PATH [EOL] [EOL] else : [EOL] try : [EOL] assert node_version == SPECIFIC_NODE_VERSION [EOL] logger ( green ( [string] . format ( node_version ) ) ) [EOL] [EOL] except AssertionError : [EOL] logger ( red ( [string] . format ( node_version , SPECIFIC_NODE_VERSION ) ) ) [EOL] exitcode = EXITCODE_NODE_VERSION_NOT_SUITABLE [EOL] [EOL] return exitcode [EOL] [EOL] [EOL] def _setup_download_repos ( logger , config , settings ) : [EOL] exitcode = [number] [EOL] logger ( bold ( [string] ) ) [EOL] [EOL] try : [EOL] retcode = subprocess . call ( [ [string] , [string] , [string] ] , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL ) [EOL] [EOL] if retcode != [number] : [EOL] logger ( red ( * [string] ) ) [EOL] return EXITCODE_GIT_AUTH_FAILED [EOL] [EOL] else : [EOL] logger ( green ( [string] ) ) [EOL] [EOL] code_directory = os . path . realpath ( os . path . join ( [string] , config [ [string] ] [ [string] ] ) ) [EOL] [EOL] logger ( bold ( f" [string] { code_directory } [string] " ) ) [EOL] [EOL] os . makedirs ( code_directory , exist_ok = True ) [EOL] [EOL] nested_repositories = group_by_key ( settings [ [string] ] , [string] , include_missing = True ) [EOL] for repo_name in itertools . chain . from_iterable ( nested_repositories ) : [EOL] repo_path = os . path . join ( code_directory , repo_name ) [EOL] [EOL] if os . path . isdir ( repo_path ) : [EOL] continue [EOL] [EOL] logger ( green ( [string] ) + [string] + settings [ [string] ] [ repo_name ] . get ( [string] , repo_name ) + [string] ) [EOL] process = subprocess . run ( [ [string] , [string] , os . path . join ( settings [ [string] ] , repo_name ) ] , cwd = code_directory , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = True , ) [EOL] [EOL] if process . returncode != [number] : [EOL] logger ( red ( process . stdout ) ) [EOL] return process . returncode [EOL] [EOL] if not exitcode : [EOL] logger ( green ( [string] ) ) [EOL] [EOL] except KeyboardInterrupt : [EOL] exitcode = EXITCODE_SETUP_ABORT [EOL] [EOL] return exitcode [EOL] [EOL] [EOL] def _setup_check_background_services ( logger ) : [EOL] use_docker_services = False [EOL] [EOL] logger ( bold ( [string] ) ) [EOL] healthcheck_passed , healthcheck_results = DMServices . services_healthcheck ( threading . Event ( ) , check_once = True ) [EOL] first_result = next ( iter ( healthcheck_results . values ( ) ) ) [comment] [EOL] [EOL] if not healthcheck_passed and not all ( map ( lambda x : x is first_result , healthcheck_results . values ( ) ) ) : [EOL] services_up = [ x [ [number] ] . title ( ) for x in list ( filter ( lambda y : y [ [number] ] is True , healthcheck_results . items ( ) ) ) ] [EOL] services_down = [ x . title ( ) for x in set ( healthcheck_results . keys ( ) ) - set ( [ x . lower ( ) for x in services_up ] ) ] [EOL] logger ( red ( [string] . format ( [string] . join ( services_up ) , [string] . join ( services_down ) ) ) ) [EOL] logger ( red ( [string] [string] ) ) [EOL] return EXITCODE_BAD_SERVICES , False [EOL] [EOL] elif healthcheck_passed : [EOL] logger ( green ( [string] ) ) [EOL] [EOL] else : [EOL] logger ( green ( [string] ) ) [EOL] use_docker_services = True [EOL] [EOL] return [number] , use_docker_services [EOL] [EOL] [EOL] def _setup_check_postgres_data_if_required ( logger , settings , use_docker_services , prompt_delete_existing = False ) : [EOL] exitcode = [number] [EOL] logger ( bold ( [string] ) ) [EOL] [EOL] if use_docker_services : [EOL] data_path = os . path . join ( os . path . realpath ( [string] ) , settings [ [string] ] ) [EOL] os . makedirs ( data_path , exist_ok = True ) [EOL] [EOL] if prompt_delete_existing : [EOL] prompt = [string] [EOL] if get_yes_no_input ( logger , prompt , default = [string] ) == [string] : [EOL] sql_files = glob . glob ( os . path . join ( data_path , [string] ) ) + glob . glob ( os . path . join ( data_path , [string] ) ) [EOL] for sql_file in sql_files : [EOL] logger ( f" [string] { sql_file } [string] " ) [EOL] os . remove ( sql_file ) [EOL] [EOL] def data_available ( ) : [EOL] return glob . glob ( os . path . join ( data_path , [string] ) ) or glob . glob ( os . path . join ( data_path , [string] ) ) [EOL] [EOL] while not data_available ( ) : [EOL] logger ( red ( [string] ) + [string] [string] [string] . format ( data_path = data_path ) , end = [string] , ) [EOL] input ( [string] ) [EOL] webbrowser . open ( settings [ [string] ] ) [EOL] logger ( [string] ) [EOL] logger ( [string] [string] . format ( data_path = data_path ) , end = [string] , ) [EOL] user_input = input ( [string] ) . strip ( ) [EOL] if user_input : [EOL] raise KeyboardInterrupt [EOL] [EOL] if not exitcode : [EOL] gzip_sql_files = glob . glob ( os . path . join ( data_path , [string] ) ) [EOL] for gzip_sql_file in gzip_sql_files : [EOL] target_sql_file = gzip_sql_file [ : - [number] ] [comment] [EOL] [EOL] if not os . path . isfile ( target_sql_file ) : [EOL] logger ( [string] . format ( gzip_sql_file ) ) [EOL] [EOL] try : [EOL] with open ( target_sql_file , [string] ) as outfile , gzip . open ( gzip_sql_file , [string] ) as infile : [EOL] before_read = - [number] [EOL] while before_read < infile . tell ( ) : [EOL] before_read = infile . tell ( ) [EOL] [EOL] [comment] [EOL] outfile . write ( infile . read ( [number] ** [number] ) ) [EOL] outfile . flush ( ) [EOL] [EOL] except KeyboardInterrupt : [EOL] os . remove ( target_sql_file ) [EOL] exitcode = EXITCODE_SETUP_ABORT [EOL] [EOL] else : [EOL] os . remove ( gzip_sql_file ) [EOL] logger ( [string] ) [EOL] [EOL] if not exitcode : [EOL] logger ( green ( [string] ) ) [EOL] [EOL] return exitcode [EOL] [EOL] [EOL] def _setup_bootstrap_repositories ( logger , config , settings ) : [EOL] exitcode = [number] [EOL] logger ( bold ( [string] ) ) [EOL] [EOL] try : [EOL] nested_repositories = group_by_key ( settings [ [string] ] , [string] , include_missing = True ) [EOL] for repo_name in itertools . chain . from_iterable ( nested_repositories ) : [EOL] if [string] in settings [ [string] ] [ repo_name ] : [EOL] app_info = get_app_info ( repo_name , config , settings , { } ) [EOL] [EOL] logger ( green ( [string] ) + [string] + app_info [ [string] ] + [string] , log_name = [string] ) [EOL] [EOL] bootstrap_command = settings [ [string] ] [ repo_name ] [ [string] ] [EOL] exitcode = DMProcess ( app = app_info , logger = logger , app_command = bootstrap_command ) . wait ( ) [EOL] [EOL] if exitcode : [EOL] logger ( red ( [string] ) + app_info [ [string] ] + red ( [string] ) . format ( exitcode ) ) [EOL] exitcode = EXITCODE_BOOTSTRAP_FAILED [EOL] break [EOL] [EOL] else : [EOL] logger ( green ( [string] ) + [string] + app_info [ [string] ] + [string] , log_name = [string] ) [EOL] [EOL] except KeyboardInterrupt : [EOL] exitcode = EXITCODE_SETUP_ABORT [EOL] [EOL] return exitcode [EOL] [EOL] [EOL] def _setup_indices ( logger , config , settings ) : [EOL] exitcode = [number] [EOL] manager = multiprocessing . Manager ( ) [EOL] [EOL] logger ( bold ( [string] ) ) [EOL] [EOL] dependencies = [ ] [EOL] for dependency in settings [ [string] ] [ [string] ] : [EOL] dependency_app_info = get_app_info ( dependency , config , settings , manager . dict ( ) ) [EOL] dependencies . append ( ( DMProcess ( app = dependency_app_info , logger = nologger , app_command = APP_COMMAND_RESTART ) , dependency_app_info ) ) [EOL] [EOL] time . sleep ( [number] ) [EOL] [EOL] for index in settings [ [string] ] [ [string] ] : [EOL] index_name = index [ [string] ] [ [string] ] [EOL] [EOL] app_info = get_app_info ( settings [ [string] ] [ [string] ] , config , settings , manager . dict ( ) ) [EOL] try : [EOL] assert requests . get ( settings [ [string] ] [ [string] ] . format ( index = index_name ) ) . status_code == [number] [EOL] [EOL] except Exception : [EOL] index_command = [string] . format ( command = settings [ [string] ] [ [string] ] , keyword = [string] . join ( [ [string] . format ( k = k , v = v ) for k , v in index [ [string] ] . items ( ) ] ) , positional = [string] . join ( index [ [string] ] ) , ) [EOL] [EOL] logger ( [string] . format ( index_name ) ) [EOL] [EOL] exitcode = DMProcess ( app = app_info , logger = logger , app_command = index_command ) . wait ( ) [EOL] if exitcode : [EOL] logger ( red ( [string] [string] . format ( index_name , exitcode ) ) ) [EOL] exitcode = EXITCODE_BOOTSTRAP_FAILED [EOL] break [EOL] [EOL] else : [EOL] logger ( green ( [string] . format ( index_name ) ) ) [EOL] [EOL] else : [EOL] logger ( green ( [string] . format ( index_name ) ) ) [EOL] [EOL] for dependency , dependency_app_info in dependencies : [EOL] try : [EOL] p = psutil . Process ( dependency_app_info [ [string] ] ) [EOL] [EOL] for child in p . children ( recursive = True ) : [EOL] child . kill ( ) [EOL] [EOL] p . kill ( ) [EOL] [EOL] except Exception as e : [EOL] logger ( str ( e ) ) [EOL] exitcode = EXITCODE_BOOTSTRAP_FAILED [EOL] [EOL] return exitcode [EOL] [EOL] [EOL] def setup_and_check_requirements ( logger , config , config_path , settings , command ) : [EOL] [docstring] [EOL] exitcode = [number] [EOL] use_docker_services = False [EOL] only_check_services = True if command == RUNNER_COMMAND_RUN else False [EOL] only_setup_data = True if command == RUNNER_COMMAND_DATA else False [EOL] [EOL] if only_check_services : [EOL] exitcode , interim_config = load_config ( config_path , must_exist = True ) [EOL] config . update ( interim_config ) [EOL] [EOL] logger ( bold ( [string] ) ) [EOL] if not exitcode : [EOL] exitcode , use_docker_services = _setup_check_background_services ( logger ) [EOL] [EOL] elif only_setup_data : [EOL] exitcode , interim_config = load_config ( config_path , must_exist = True ) [EOL] config . update ( interim_config ) [EOL] [EOL] if only_setup_data : [EOL] logger ( bold ( [string] ) ) [EOL] logger ( red ( [string] ) + [string] + bold ( [string] ) + [string] [string] ) [EOL] [EOL] if get_yes_no_input ( logger , [string] , default = [string] ) != [string] : [EOL] exitcode = EXITCODE_SETUP_ABORT [EOL] [EOL] else : [EOL] exitcode , use_docker_services = ( _setup_check_background_services ( logger ) if not exitcode else ( exitcode , False ) ) [EOL] [EOL] if not use_docker_services : [EOL] logger ( bold ( [string] ) ) [EOL] exitcode = EXITCODE_SETUP_ABORT [EOL] [EOL] exitcode = exitcode or _setup_check_postgres_data_if_required ( logger , settings , use_docker_services , prompt_delete_existing = True ) [EOL] [EOL] with ( background_services ( logger , docker_compose_folder = settings [ [string] ] , clean = True ) [EOL] if use_docker_services and not exitcode [EOL] else blank_context ( ) ) : [EOL] exitcode = exitcode or _setup_indices ( logger , config , settings ) [EOL] [EOL] else : [EOL] logger ( bold ( [string] ) ) [EOL] [EOL] try : [EOL] exitcode = _setup_config_modifications ( logger , config , config_path ) [EOL] exitcode = exitcode or _setup_logging_directory ( config ) [EOL] exitcode = exitcode or _setup_check_git_available ( logger ) [EOL] exitcode = exitcode or _setup_check_docker_available ( logger ) [EOL] exitcode = exitcode or _setup_check_node_version ( logger ) [EOL] exitcode = exitcode or _setup_download_repos ( logger , config , settings ) [EOL] [EOL] exitcode , use_docker_services = ( _setup_check_background_services ( logger ) if not exitcode else ( exitcode , False ) ) [EOL] exitcode = exitcode or _setup_check_postgres_data_if_required ( logger , settings , use_docker_services ) [EOL] [EOL] with ( background_services ( logger , docker_compose_folder = settings [ [string] ] ) [EOL] if use_docker_services and not exitcode [EOL] else blank_context ( ) ) : [EOL] exitcode = exitcode or _setup_bootstrap_repositories ( logger , config , settings ) [EOL] exitcode = exitcode or _setup_indices ( logger , config , settings ) [EOL] [EOL] except BaseException : [EOL] exitcode = EXITCODE_SETUP_ABORT [EOL] [EOL] if exitcode : [EOL] if only_check_services : [EOL] if exitcode == EXITCODE_CONFIG_NO_EXIST : [EOL] logger ( red ( [string] ) ) [EOL] [EOL] else : [EOL] logger ( red ( [string] . format ( exitcode ) ) ) [EOL] [EOL] else : [EOL] logger ( red ( [string] ) ) [EOL] [EOL] elif not only_check_services : [EOL] logger ( bold ( [string] ) ) [EOL] [EOL] return exitcode , use_docker_services , config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $distutils.version.LooseVersion$ 0 0 0 0 0 0 0 0 $distutils.version.LooseVersion$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $distutils.version.LooseVersion$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $distutils.version.LooseVersion$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $distutils.version.LooseVersion$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $distutils.version.LooseVersion$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Set , Callable , Iterable , Any , Sequence , Union , List , Dict , Optional , Tuple [EOL] import builtins [EOL] import signal [EOL] import types [EOL] import threading [EOL] import datetime [EOL] import requests [EOL] import pathlib [EOL] import typing [EOL] import ansiwrap [EOL] import atexit [EOL] import colored [EOL] import datetime [EOL] import itertools [EOL] import json [EOL] import multiprocessing [EOL] import os [EOL] import pathlib [EOL] import prettytable [EOL] import psutil [EOL] import re [EOL] import gnureadline as readline [comment] [EOL] import requests [EOL] import shutil [EOL] import signal [EOL] import subprocess [EOL] import sys [EOL] import textwrap [EOL] import time [EOL] import threading [EOL] from typing import Any , Dict , Iterable , List , Optional , Set , Sequence , Tuple , cast [EOL] import yaml [EOL] [EOL] from . process import DMProcess , DMServices [EOL] from . setup import setup_and_check_requirements [EOL] from . utils import ( RUNNER_COMMAND_RUN , RUNNER_COMMANDS , PROCESS_TERMINATED , PROCESS_NOEXIST , APP_COMMAND_RESTART , APP_COMMAND_REBUILD , APP_COMMAND_FRONTEND , group_by_key , get_app_info , yellow , ) [EOL] [EOL] TERMINAL_CARRIAGE_RETURN = [string] [EOL] TERMINAL_ESCAPE_CLEAR_LINE = [string] [EOL] [EOL] SETTINGS_PATH = os . path . join ( os . path . realpath ( [string] ) , [string] , [string] ) [EOL] STATUS_OK = [string] [EOL] STATUS_DOWN = [string] [EOL] STATUS_ATTACHED = [string] [EOL] [EOL] [EOL] class DMRunner : [EOL] INPUT_STRING = [string] [EOL] [EOL] HELP_SYNTAX = [string] [EOL] [EOL] def __init__ ( self , command , rebuild , config_path , nix = False , settings_path = SETTINGS_PATH ) : [EOL] self . _command = command [EOL] self . _rebuild = rebuild [EOL] self . _nix = nix [comment] [EOL] self . _config_path = config_path [EOL] self . _settings_path = settings_path [EOL] [EOL] assert command in RUNNER_COMMANDS [EOL] [EOL] [comment] [EOL] self . _primary_attached_app = None [EOL] self . _shutdown = threading . Event ( ) [EOL] self . _awaiting_input = False [EOL] self . _suppress_log_printing = False [EOL] self . _filter_logs = [ ] [EOL] self . _use_docker_services = False [EOL] self . _processes = { } [EOL] self . _dmservices = None [EOL] self . _main_log_name = [string] [EOL] self . config = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] curr_signal = signal . getsignal ( signal . SIGINT ) [EOL] signal . signal ( signal . SIGINT , signal . SIG_IGN ) [EOL] [EOL] self . _manager = multiprocessing . Manager ( ) [EOL] self . _apps = self . _manager . dict ( ) [EOL] [EOL] signal . signal ( signal . SIGINT , curr_signal ) [comment] [EOL] [comment] [EOL] [EOL] with open ( self . _settings_path ) as settings_file : [EOL] self . settings = yaml . safe_load ( settings_file . read ( ) ) [EOL] [EOL] self . _main_log_name = [string] [EOL] [comment] [EOL] exitcode , self . _use_docker_services , self . config = setup_and_check_requirements ( logger = self . logger , config = self . config , config_path = self . _config_path , settings = self . settings , command = self . _command , ) [EOL] [EOL] if exitcode or self . _command != RUNNER_COMMAND_RUN : [EOL] self . shutdown ( ) [EOL] sys . exit ( exitcode ) [EOL] [EOL] self . _inject_credentials ( ) [EOL] [EOL] self . _main_log_name = [string] [EOL] [EOL] self . _populate_multiprocessing_components ( ) [EOL] [EOL] [comment] [EOL] readline . parse_and_bind ( [string] ) [EOL] readline . set_completer ( self . _app_name_completer ) [EOL] readline . set_completer_delims ( [string] ) [EOL] [EOL] @ property def _app_repositories ( self ) : [EOL] [docstring] [EOL] return group_by_key ( self . settings [ [string] ] , [string] ) [EOL] [EOL] @ property def _app_name_width ( self ) : [EOL] [docstring] [EOL] try : [EOL] if not self . _app_repositories : [EOL] return [number] [EOL] [EOL] except AttributeError : [EOL] return [number] [EOL] [EOL] return max ( len ( self . _get_app_name ( r ) ) for r in itertools . chain . from_iterable ( self . _app_repositories ) ) [EOL] [EOL] @ property def _prompt_string ( self ) : [EOL] [docstring] [EOL] prompt = DMRunner . INPUT_STRING [EOL] [EOL] if self . _attached_app : [EOL] prompt = self . _get_cleaned_wrapped_and_styled_text ( [string] , self . _attached_app [ [string] ] ) [ [number] ] [EOL] [EOL] return prompt [EOL] [EOL] @ property def _attached_app ( self ) : [EOL] if self . _primary_attached_app : [EOL] if self . _primary_attached_app [ [string] ] is True : [EOL] return self . _primary_attached_app [EOL] [EOL] for app in self . _apps . values ( ) : [EOL] if app [ [string] ] : [EOL] self . _primary_attached_app = app [EOL] return app [EOL] [EOL] return None [EOL] [EOL] def _inject_credentials ( self ) : [EOL] if self . config . get ( [string] , { } ) . get ( [string] , False ) : [EOL] path_to_credentials = os . getenv ( [string] ) [EOL] if not path_to_credentials : [EOL] print ( [string] [string] ) [EOL] self . shutdown ( ) [EOL] sys . exit ( [number] ) [EOL] [EOL] aws_access_key_id = subprocess . check_output ( [string] . split ( ) , universal_newlines = True ) [EOL] aws_secret_access_key = subprocess . check_output ( [string] . split ( ) , universal_newlines = True ) [EOL] [EOL] self . print_out ( [string] [string] ) [EOL] all_creds = yaml . safe_load ( subprocess . check_output ( f"{ path_to_credentials } [string] " f" [string] { path_to_credentials } [string] " . split ( ) , universal_newlines = True , ) ) [EOL] [EOL] mandrill_key = all_creds [ [string] ] [ [string] ] [EOL] notify_key = all_creds [ [string] ] [EOL] [EOL] os . environ [ [string] ] = aws_access_key_id . strip ( ) [EOL] os . environ [ [string] ] = aws_secret_access_key . strip ( ) [EOL] os . environ [ [string] ] = mandrill_key . strip ( ) [EOL] os . environ [ [string] ] = notify_key . strip ( ) [EOL] [EOL] def _get_input_and_pipe_to_target ( self ) : [EOL] [docstring] [EOL] try : [EOL] while not self . _shutdown . is_set ( ) : [EOL] print ( [string] . format ( TERMINAL_CARRIAGE_RETURN , TERMINAL_ESCAPE_CLEAR_LINE , self . _prompt_string ) , flush = True , end = [string] , ) [EOL] [EOL] self . _awaiting_input = True [EOL] user_input = input ( [string] ) [EOL] self . _awaiting_input = False [EOL] [EOL] if self . _attached_app : [EOL] self . _processes [ self . _attached_app [ [string] ] ] . process_input ( user_input ) [EOL] [EOL] else : [EOL] self . process_input ( user_input ) [EOL] [EOL] except KeyboardInterrupt : [EOL] pass [EOL] [EOL] def _get_app_name ( self , repository ) : [EOL] return cast ( str , self . settings [ [string] ] [ repository ] [ [string] ] ) [EOL] [EOL] def _app_name_completer ( self , text , state ) : [EOL] [docstring] [EOL] options = [ name for name in self . _apps . keys ( ) if text in name ] [EOL] if state < len ( options ) : [EOL] return options [ state ] [EOL] else : [EOL] return None [EOL] [EOL] def _populate_multiprocessing_components ( self ) : [EOL] [docstring] [EOL] for repository_name in itertools . chain . from_iterable ( self . _app_repositories ) : [EOL] app_name = self . settings [ [string] ] [ repository_name ] [ [string] ] [EOL] [EOL] self . _apps [ app_name ] = get_app_info ( repository_name , self . config , self . settings , self . _manager . dict ( ) ) [EOL] [EOL] def _check_app_status ( self , app , loop = False ) : [EOL] checked = False [EOL] status = [string] [EOL] error_msg = [string] [EOL] [EOL] while loop or not checked : [EOL] if app [ [string] ] == PROCESS_NOEXIST : [EOL] time . sleep ( [number] ) [EOL] continue [EOL] [EOL] elif app [ [string] ] == PROCESS_TERMINATED : [EOL] error_msg = [string] [EOL] break [EOL] [EOL] elif self . _attached_app and self . _attached_app [ [string] ] == app [ [string] ] : [EOL] status = STATUS_ATTACHED [EOL] [EOL] else : [EOL] try : [EOL] status_endpoint = [string] . format ( server = self . settings [ [string] ] , port = self . settings [ [string] ] [ app [ [string] ] ] [ [string] ] [ [string] ] , endpoint = self . settings [ [string] ] [ app [ [string] ] ] [ [string] ] [ [string] ] , ) [EOL] [EOL] [comment] [EOL] res = requests . get ( status_endpoint ) [EOL] data = json . loads ( res . text ) [EOL] [EOL] return data [ [string] ] , data [EOL] [EOL] except requests . exceptions . ConnectionError : [EOL] time . sleep ( [number] ) [EOL] [EOL] except json . decoder . JSONDecodeError : [EOL] status = [string] [EOL] error_msg = [string] [EOL] break [EOL] [EOL] checked = True [EOL] [EOL] return status , { [string] : error_msg } [EOL] [EOL] def _ensure_apps_up ( self , repository_names , quiet = False ) : [EOL] down_apps = set ( ) [EOL] [EOL] for repository_name in repository_names : [EOL] app_name = self . _get_app_name ( repository_name ) [EOL] [EOL] if self . _attached_app and self . _attached_app [ [string] ] == app_name : [EOL] continue [EOL] [EOL] if not quiet : [EOL] self . print_out ( [string] . format ( app_name ) ) [EOL] [EOL] self . _suppress_log_printing = quiet [EOL] result , data = self . _check_app_status ( self . _apps [ app_name ] , loop = True ) [EOL] self . _suppress_log_printing = False [EOL] [EOL] if not data or [string] not in data or data [ [string] ] != [string] : [EOL] self . print_out ( [string] . format ( app_name , data [ [string] ] ) ) [EOL] [EOL] down_apps . add ( app_name ) [EOL] [EOL] time . sleep ( [number] ) [comment] [EOL] [EOL] return down_apps [EOL] [EOL] def logger ( self , log_entry , log_name = None , log_attach = None , end = os . linesep ) : [EOL] if self . _suppress_log_printing : [EOL] return [EOL] [EOL] if not log_name or log_attach is not None : [EOL] log_name = self . _main_log_name [EOL] [EOL] if self . _filter_logs and log_name and log_name not in self . _filter_logs : [EOL] return [EOL] [EOL] if self . config . get ( [string] , { } ) . get ( [string] , False ) : [EOL] for f in [ [string] , [string] . format ( log_name ) ] : [EOL] filepath = os . path . join ( os . path . realpath ( [string] ) , self . config [ [string] ] [ [string] ] , f ) [EOL] with open ( filepath , [string] ) as log_file : [EOL] log_file . write ( [string] . format ( repr ( log_entry ) , end ) ) [EOL] [EOL] self . print_out ( log_entry , app_name = log_name , end = end ) [EOL] [EOL] def _find_matching_apps ( self , selectors = None ) : [EOL] found_apps = ... [EOL] [EOL] if not selectors : [EOL] found_apps = self . _apps . keys ( ) [EOL] else : [EOL] found_apps = [ ] [EOL] for selector in selectors : [EOL] found_app = None [EOL] for app_name , app_process in self . _apps . items ( ) : [EOL] if selector in app_name and app_name not in found_apps : [EOL] found_app = app_name if not found_app or len ( app_name ) < len ( found_app ) else found_app [EOL] [EOL] if found_app : [EOL] found_apps . append ( found_app ) [EOL] elif selectors : [EOL] self . print_out ( [string] . format ( selector ) ) [EOL] [EOL] return tuple ( found_apps ) [EOL] [EOL] def _start_services ( self ) : [EOL] docker_compose_folder = pathlib . Path ( pathlib . Path . cwd ( ) , self . settings [ [string] ] ) [EOL] self . _dmservices = DMServices ( logger = self . logger , docker_compose_folder = docker_compose_folder ) [EOL] self . _dmservices . blocking_healthcheck ( self . _shutdown ) [EOL] [EOL] def _stylize ( self , text , ** styles ) : [EOL] style_string = [string] . join ( getattr ( colored , key ) ( val ) for key , val in styles . items ( ) ) [EOL] return colored . stylize ( text , style_string ) [EOL] [EOL] def _get_cleaned_wrapped_and_styled_text ( self , text , app_name ) : [EOL] [docstring] [EOL] [EOL] def pad_name ( name ) : [EOL] return [string] . format ( self . _app_name_width ) . format ( name ) [EOL] [EOL] if type ( text ) != str : [EOL] text = repr ( text ) [EOL] [EOL] cleaned_lines = [ ] [EOL] wrapped_lines = [ ] [EOL] styled_lines = [ ] [EOL] timestamp = datetime . datetime . now ( ) . strftime ( [string] ) [EOL] padded_app_name = pad_name ( app_name ) [EOL] log_styling = self . config . get ( [string] , { } ) . get ( [string] , { } ) [EOL] colored_app_name = re . sub ( app_name , self . _stylize ( app_name , ** log_styling . get ( app_name , { } ) ) , padded_app_name ) [EOL] [EOL] for line in text . split ( [string] ) : [EOL] datetime_prefixed_log_pattern = [string] . format ( app_name ) [EOL] [EOL] if re . match ( datetime_prefixed_log_pattern , line ) : [EOL] line = re . sub ( datetime_prefixed_log_pattern , [string] , line ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . _attached_app and self . _attached_app [ [string] ] == app_name : [EOL] self . _attached_app [ [string] ] = False [EOL] cleaned_lines . append ( ( pad_name ( self . _main_log_name ) , [string] . format ( app_name ) ) ) [EOL] [EOL] cleaned_lines . append ( ( colored_app_name , line ) ) [EOL] [EOL] for log_name , line in cleaned_lines : [EOL] [comment] [EOL] [comment] [EOL] for key in sorted ( log_styling . keys ( ) , key = lambda x : len ( x ) , reverse = True ) : [EOL] line = re . sub ( [string] . format ( key ) , [string] . format ( self . _stylize ( key , ** log_styling . get ( key , { } ) ) ) , line ) [EOL] [EOL] line = re . sub ( [string] , self . _stylize ( [string] , fg = [string] ) , line ) [EOL] line = re . sub ( [string] , [string] . format ( self . _stylize ( [string] , fg = [string] ) ) , line ) [EOL] [EOL] styled_lines . append ( ( log_name , line ) ) [EOL] [EOL] for log_name , line in styled_lines : [EOL] terminal_width = shutil . get_terminal_size ( ) . columns - ( len ( timestamp ) + self . _app_name_width + [number] ) [EOL] [EOL] try : [EOL] lines = ansiwrap . ansi_terminate_lines ( ansiwrap . wrap ( line , width = terminal_width , subsequent_indent = [string] * self . config . get ( [string] , { } ) . get ( [string] , [number] ) , drop_whitespace = False , ) ) [EOL] [EOL] except ValueError : [comment] [EOL] lines = textwrap . wrap ( line , width = terminal_width , subsequent_indent = [string] * self . config . get ( [string] , { } ) . get ( [string] , [number] ) , drop_whitespace = False , ) [EOL] [EOL] log_prefix = [string] . format ( timestamp , log_name ) [EOL] lines = [ [string] . format ( log_prefix , line ) for line in lines ] [EOL] [EOL] wrapped_lines . extend ( lines ) [EOL] [EOL] return wrapped_lines [EOL] [EOL] def print_out ( self , text , app_name = None , end = os . linesep ) : [EOL] if not app_name : [EOL] app_name = self . _main_log_name [EOL] [EOL] if self . _awaiting_input or self . _attached_app : [EOL] [comment] [EOL] sys . stdout . write ( [string] . format ( TERMINAL_CARRIAGE_RETURN , TERMINAL_ESCAPE_CLEAR_LINE ) ) [EOL] [EOL] lines = self . _get_cleaned_wrapped_and_styled_text ( text , app_name ) [EOL] for i , line in enumerate ( lines , start = [number] ) : [EOL] [comment] [EOL] print ( [string] . format ( TERMINAL_CARRIAGE_RETURN , line ) , flush = True , end = end if i == len ( lines ) else os . linesep ) [EOL] [EOL] [comment] [EOL] if not self . _shutdown . is_set ( ) and ( self . _attached_app or self . _awaiting_input ) : [EOL] sys . stdout . write ( [string] . format ( self . _prompt_string , readline . get_line_buffer ( ) ) ) [EOL] sys . stdout . flush ( ) [EOL] [EOL] def run ( self ) : [EOL] [comment] [EOL] atexit . register ( self . shutdown ) [EOL] [EOL] try : [EOL] if self . _use_docker_services : [EOL] self . _start_services ( ) [EOL] [EOL] if not self . _shutdown . is_set ( ) : [EOL] down_apps = set ( ) [EOL] [EOL] app_command = APP_COMMAND_REBUILD if self . _rebuild else APP_COMMAND_RESTART [EOL] [EOL] for repositories in self . _app_repositories : [EOL] for repository in repositories : [EOL] app_name = self . _get_app_name ( repository ) [EOL] self . _processes [ app_name ] = DMProcess ( self . _apps [ app_name ] , logger = self . logger , app_command = app_command ) [EOL] [EOL] down_apps . update ( self . _ensure_apps_up ( repositories ) ) [EOL] [EOL] if not down_apps : [EOL] self . print_out ( [string] . format ( [string] . join ( self . _apps . keys ( ) ) ) ) [EOL] else : [EOL] self . print_out ( [string] ) [EOL] [EOL] self . cmd_apps_status ( ) [EOL] [EOL] except KeyboardInterrupt : [EOL] self . shutdown ( ) [EOL] [EOL] else : [EOL] self . _get_input_and_pipe_to_target ( ) [EOL] self . shutdown ( ) [EOL] [EOL] def cmd_switch_logs ( self , selectors ) : [EOL] if not selectors : [EOL] self . _filter_logs = [ ] [EOL] self . print_out ( [string] ) [EOL] [EOL] else : [EOL] self . _filter_logs = self . _find_matching_apps ( selectors ) [EOL] self . print_out ( [string] . format ( [string] . join ( self . _filter_logs ) ) ) [EOL] [EOL] def cmd_apps_status ( self ) : [EOL] status_table = prettytable . PrettyTable ( ) [EOL] status_table . field_names = [ [string] , [string] , [string] , [string] , [string] ] [EOL] status_table . align [ [string] ] = [string] [EOL] status_table . align [ [string] ] = [string] [EOL] status_table . align [ [string] ] = [string] [EOL] status_table . align [ [string] ] = [string] [EOL] status_table . align [ [string] ] = [string] [EOL] [EOL] self . _suppress_log_printing = True [EOL] [EOL] for app_name , app in self . _apps . items ( ) : [EOL] status , data = self . _check_app_status ( app ) [EOL] [EOL] ppid = str ( app [ [string] ] ) if app [ [string] ] > [number] else [string] [EOL] status = status . upper ( ) [EOL] logging = [string] if not self . _filter_logs or app_name in self . _filter_logs else [string] [EOL] notes = data . get ( [string] , data ) if status != [string] else [string] [EOL] [EOL] styling = self . config [ [string] ] [EOL] status_style = styling [ [string] ] [ status ] if status in styling [ [string] ] . keys ( ) else { } [EOL] logging_style = styling [ [string] ] [ logging ] if logging in styling [ [string] ] . keys ( ) else { } [EOL] [EOL] status = self . _stylize ( status , ** status_style ) [EOL] logging = self . _stylize ( logging , ** logging_style ) [EOL] [EOL] status_table . add_row ( [ app_name , ppid , status , logging , notes ] ) [EOL] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] self . _suppress_log_printing = False [EOL] [EOL] self . print_out ( status_table . get_string ( ) ) [EOL] [EOL] def cmd_apps_branches ( self ) : [EOL] branches_table = prettytable . PrettyTable ( ) [EOL] branches_table . field_names = [ [string] , [string] , [string] ] [EOL] branches_table . align [ [string] ] = [string] [EOL] branches_table . align [ [string] ] = [string] [EOL] branches_table . align [ [string] ] = [string] [EOL] [EOL] for app_name , app in self . _apps . items ( ) : [EOL] try : [EOL] branch_name = subprocess . check_output ( [ [string] , [string] , [string] , [string] ] , cwd = app [ [string] ] , universal_newlines = True ) . strip ( ) [EOL] except : [EOL] branch_name = [string] [EOL] [EOL] try : [EOL] last_commit = subprocess . check_output ( [ [string] , [string] , [string] , [string] , [string] ] , cwd = app [ [string] ] , universal_newlines = True ) . strip ( ) [EOL] last_commit_datetime = datetime . datetime . strptime ( last_commit , [string] ) [EOL] last_commit_days_old = max ( [number] , ( datetime . datetime . utcnow ( ) - last_commit_datetime ) . days ) [EOL] age = ( [string] . format ( last_commit_days_old ) [EOL] if last_commit_days_old != [number] [EOL] else [string] . format ( last_commit_days_old ) ) [EOL] except : [EOL] age = [string] [EOL] [EOL] branches_table . add_row ( [ app_name , branch_name , age ] ) [EOL] [EOL] self . print_out ( branches_table . get_string ( ) ) [EOL] [EOL] def cmd_restart_down_apps ( self , selectors , rebuild = False ) : [EOL] matched_apps = self . _find_matching_apps ( selectors ) [EOL] recovered_apps = set ( ) [EOL] failed_apps = set ( ) [EOL] [EOL] for repos in self . _app_repositories : [EOL] for repo in repos : [EOL] need_restart = False [EOL] app_name = self . _get_app_name ( repo ) [EOL] app = self . _apps [ app_name ] [EOL] [EOL] if app_name not in matched_apps : [EOL] continue [EOL] [EOL] try : [EOL] p = psutil . Process ( app [ [string] ] ) [EOL] assert p . cwd ( ) == app [ [string] ] [EOL] [EOL] if rebuild and selectors : [EOL] self . cmd_kill_apps ( selectors , silent_fail = True ) [EOL] need_restart = True [EOL] [EOL] except ( ProcessLookupError , psutil . NoSuchProcess , KeyError , AssertionError , ValueError ) : [EOL] need_restart = True [EOL] [EOL] if need_restart : [EOL] try : [EOL] self . print_out ( [string] . format ( [string] if rebuild else [string] , app_name ) ) [EOL] self . _processes [ app_name ] . run ( APP_COMMAND_REBUILD if rebuild else APP_COMMAND_RESTART ) [EOL] recovered_apps . add ( app_name ) [EOL] [EOL] except Exception as e : [EOL] self . print_out ( [string] . format ( [string] if rebuild else [string] , app_name , e ) ) [EOL] [EOL] failed_apps . update ( self . _ensure_apps_up ( filter ( lambda x : self . _get_app_name ( x ) in recovered_apps , repos ) ) ) [EOL] [EOL] recovered_apps -= failed_apps [EOL] [EOL] if failed_apps : [EOL] self . print_out ( [string] . format ( [string] . join ( failed_apps ) ) ) [EOL] [EOL] if not rebuild : [EOL] self . print_out ( yellow ( [string] ) ) [EOL] [EOL] if recovered_apps and len ( recovered_apps ) < len ( self . _apps . keys ( ) ) : [EOL] self . print_out ( [string] . format ( [string] . join ( recovered_apps ) ) ) [EOL] [EOL] if not failed_apps and len ( recovered_apps ) == len ( self . _apps . keys ( ) ) : [EOL] self . print_out ( [string] . format ( [string] . join ( recovered_apps ) ) ) [EOL] [EOL] def cmd_kill_apps ( self , selectors = None , silent_fail = False ) : [EOL] procs = [ ] [EOL] [EOL] for app_name in self . _find_matching_apps ( selectors ) : [EOL] try : [EOL] if self . _apps [ app_name ] [ [string] ] in ( PROCESS_TERMINATED , PROCESS_NOEXIST ) : [EOL] continue [EOL] [EOL] p = psutil . Process ( self . _apps [ app_name ] [ [string] ] ) [EOL] procs . append ( p ) [EOL] [EOL] children = [ ] [EOL] for child in p . children ( recursive = True ) : [EOL] children . append ( child ) [EOL] procs . append ( child ) [EOL] [EOL] for child in children : [EOL] child . kill ( ) [EOL] [EOL] p . kill ( ) [EOL] [EOL] self . print_out ( [string] . format ( app_name ) ) [EOL] [EOL] except ( ProcessLookupError , psutil . NoSuchProcess , KeyError , ValueError ) : [EOL] if not silent_fail : [EOL] self . print_out ( [string] . format ( app_name ) ) [EOL] [EOL] for proc in procs : [EOL] proc . wait ( ) [EOL] [EOL] def cmd_kill_services ( self ) : [EOL] if not self . _dmservices : [EOL] return [EOL] [EOL] healthcheck_result , service_results = self . _dmservices . services_healthcheck ( self . _shutdown , check_once = True ) [EOL] [EOL] if self . _use_docker_services and healthcheck_result is True : [EOL] self . print_out ( [string] ) [EOL] self . _dmservices . wait ( interrupt = True ) [EOL] self . print_out ( [string] ) [EOL] [EOL] def cmd_frontend_build ( self , selectors = None ) : [EOL] for app_name in self . _find_matching_apps ( selectors ) : [EOL] if app_name . endswith ( [string] ) : [EOL] app_build_name = app_name . replace ( [string] , [string] ) [EOL] app_build = self . _apps [ app_name ] . copy ( ) [EOL] app_build [ [string] ] = app_build_name [EOL] [EOL] colorize = self . config [ [string] ] [ [string] ] [EOL] if app_name in colorize . keys ( ) and app_build_name not in colorize . keys ( ) : [EOL] colorize [ app_build_name ] = colorize [ app_name ] [EOL] [EOL] [comment] [EOL] DMProcess ( app_build , logger = self . logger , app_command = APP_COMMAND_FRONTEND ) [EOL] [EOL] self . print_out ( [string] . format ( app_name ) ) [EOL] [EOL] def cmd_environment ( self , command , name , value ) : [EOL] command = command . lower ( ) [EOL] name = name . upper ( ) [EOL] [EOL] if command == [string] or command == [string] or command == [string] : [EOL] del os . environ [ name ] [EOL] self . print_out ( [string] ) [EOL] [EOL] elif command == [string] or command == [string] or command == [string] or command == [string] : [EOL] os . environ [ name ] = value [EOL] self . print_out ( f" [string] { name } [string] { value } [string] " ) [EOL] [EOL] elif command == [string] or command == [string] : [EOL] self . print_out ( [string] ) [EOL] self . print_out ( [string] . join ( [string] . format ( key , value ) for key , value in os . environ . items ( ) ) ) [EOL] [EOL] else : [EOL] self . print_out ( [string] ) [EOL] [EOL] def shutdown ( self ) : [EOL] [comment] [EOL] [comment] [EOL] signal . signal ( signal . SIGINT , signal . SIG_IGN ) [EOL] [EOL] shutdown_set = self . _shutdown . is_set ( ) [EOL] self . _shutdown . set ( ) [EOL] [EOL] if not shutdown_set : [EOL] self . print_out ( [string] ) [EOL] [EOL] self . cmd_kill_apps ( [ ] ) [EOL] self . cmd_kill_services ( ) [EOL] [EOL] if not shutdown_set : [EOL] self . print_out ( [string] ) [EOL] [EOL] def process_input ( self , user_input ) : [EOL] [docstring] [EOL] try : [EOL] words = user_input . split ( [string] ) [EOL] verb = words [ [number] ] . lower ( ) [EOL] [EOL] if verb == [string] or verb == [string] : [EOL] print ( DMRunner . HELP_SYNTAX , flush = True ) [EOL] print ( [string] ) [EOL] [EOL] elif verb == [string] or verb == [string] : [EOL] self . cmd_apps_status ( ) [EOL] [EOL] elif verb == [string] or verb == [string] or verb == [string] : [EOL] self . cmd_apps_branches ( ) [EOL] [EOL] elif verb == [string] or verb == [string] : [EOL] self . cmd_restart_down_apps ( words [ [number] : ] ) [EOL] [EOL] elif verb == [string] or verb == [string] : [EOL] self . cmd_restart_down_apps ( words [ [number] : ] , rebuild = True ) [EOL] [EOL] elif verb == [string] or verb == [string] : [EOL] self . cmd_kill_apps ( words [ [number] : ] ) [EOL] [EOL] elif verb == [string] or verb == [string] : [EOL] self . shutdown ( ) [EOL] [EOL] elif verb == [string] or verb == [string] : [EOL] self . cmd_switch_logs ( words [ [number] : ] ) [EOL] [EOL] elif verb == [string] or verb == [string] : [EOL] self . cmd_frontend_build ( words [ [number] : ] ) [EOL] [EOL] elif verb == [string] or verb == [string] or verb == [string] : [EOL] words . extend ( [ [string] , [string] , [string] ] ) [comment] [EOL] self . cmd_environment ( words [ [number] ] , words [ [number] ] , [string] . join ( words [ [number] : ] ) ) [EOL] [EOL] else : [EOL] self . print_out ( [string] ) [EOL] [EOL] except Exception as e : [EOL] self . print_out ( [string] ) [EOL] self . print_out ( e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict]$ 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Callable[[signal.Signals,types.FrameType],typing.Any],None,builtins.int,signal.Handlers]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Callable[[signal.Signals,types.FrameType],typing.Any],None,builtins.int,signal.Handlers]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 $builtins.dict$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[typing.Dict]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 $typing.Optional[typing.List]$ 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[typing.List]$ 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[typing.List]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Iterable[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.List]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 $builtins.list$ 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.list$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 $builtins.list$ 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.list$ 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.List]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.List]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
from typing import Iterator , Any , Union , Literal , List , Dict , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] import builtins [EOL] import colored [EOL] import itertools [EOL] import os [EOL] import ruamel . yaml [EOL] from typing import Dict , List , Tuple [EOL] [EOL] APP_COMMAND_RESTART = [string] [EOL] APP_COMMAND_REBUILD = [string] [EOL] APP_COMMAND_FRONTEND = [string] [EOL] [EOL] EXITCODE_DOCKER_NOT_AVAILABLE = [number] [EOL] EXITCODE_BAD_SERVICES = [number] [EOL] EXITCODE_DOCKER_BUILD_FAILED = [number] [EOL] EXITCODE_GIT_NOT_AVAILABLE = [number] [EOL] EXITCODE_GIT_AUTH_FAILED = [number] [EOL] EXITCODE_NO_POSTGRES_DATA = [number] [EOL] EXITCODE_NOT_ANTICIPATED_EXECUTION = [number] [EOL] EXITCODE_NODE_NOT_IN_PATH = [number] [EOL] EXITCODE_NODE_VERSION_NOT_SUITABLE = [number] [EOL] EXITCODE_BOOTSTRAP_FAILED = [number] [EOL] EXITCODE_SETUP_ABORT = [number] [EOL] EXITCODE_CONFIG_NO_EXIST = [number] [EOL] [EOL] PROCESS_NOEXIST = - [number] [EOL] PROCESS_TERMINATED = - [number] [EOL] [EOL] RUNNER_COMMAND_SETUP = [string] [EOL] RUNNER_COMMAND_DATA = [string] [EOL] RUNNER_COMMAND_RUN = [string] [EOL] RUNNER_COMMANDS = [ RUNNER_COMMAND_SETUP , RUNNER_COMMAND_DATA , RUNNER_COMMAND_RUN ] [EOL] [EOL] EXAMPLE_CONFIG_PATH = os . path . join ( os . path . realpath ( [string] ) , [string] , [string] ) [EOL] [EOL] [EOL] def bold ( text ) : [EOL] return colored . stylize ( text , colored . attr ( [string] ) ) [EOL] [EOL] [EOL] def red ( text ) : [EOL] return bold ( colored . stylize ( text , colored . fg ( [string] ) ) ) [EOL] [EOL] [EOL] def yellow ( text ) : [EOL] return bold ( colored . stylize ( text , colored . fg ( [string] ) ) ) [EOL] [EOL] [EOL] def green ( text ) : [EOL] return colored . stylize ( text , colored . fg ( [string] ) ) [EOL] [EOL] [EOL] def get_yes_no_input ( logger , text , default = None ) : [EOL] [docstring] [EOL] if default : [EOL] default = default . strip ( ) . lower ( ) [EOL] [EOL] y = [string] if default == [string] else [string] [EOL] n = [string] if default == [string] else [string] [EOL] [EOL] prompt = f"{ text } [string] { yellow ( y ) } [string] { yellow ( n ) } [string] " [EOL] user_input = [string] [EOL] [EOL] while not user_input : [EOL] logger ( prompt , end = [string] ) [EOL] user_input = input ( [string] ) . strip ( ) . lower ( ) [EOL] if user_input == [string] and default : [EOL] user_input = default [EOL] [EOL] return user_input [EOL] [EOL] [EOL] def group_by_key ( dictionary , key , include_missing = False ) : [EOL] [docstring] [EOL] items = filter ( lambda x : key in x [ [number] ] , dictionary . items ( ) ) [EOL] [EOL] [comment] [EOL] grouped_items = [ [ y [ [number] ] for y in x [ [number] ] ] for x in itertools . groupby ( items , lambda x : x [ [number] ] [ key ] ) ] [EOL] [EOL] if include_missing : [EOL] grouped_items . append ( [ x [ [number] ] for x in sorted ( dictionary . items ( ) , key = lambda x : x [ [number] ] ) if key not in x [ [number] ] ] ) [EOL] [EOL] return grouped_items [EOL] [EOL] [EOL] def get_app_info ( repo_name , config , settings , container ) : [EOL] [docstring] [EOL] [EOL] container [ [string] ] = settings [ [string] ] [ repo_name ] [ [string] ] [EOL] container [ [string] ] = settings [ [string] ] [ repo_name ] . get ( [string] , { } ) . copy ( ) [EOL] container [ [string] ] = os . path . join ( os . path . realpath ( [string] ) , config [ [string] ] [ [string] ] , repo_name ) [EOL] container [ [string] ] = repo_name [EOL] container [ [string] ] = False [EOL] container [ [string] ] = PROCESS_NOEXIST [EOL] [EOL] return container [EOL] [EOL] [EOL] def nologger ( * args , ** kwargs ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def load_config ( config_path , must_exist = False ) : [EOL] exitcode = [number] [EOL] interim_config = { } [EOL] [EOL] try : [EOL] with open ( config_path , [string] ) as config_file : [EOL] interim_config = ruamel . yaml . round_trip_load ( config_file . read ( ) ) [EOL] [EOL] except OSError : [EOL] if must_exist : [EOL] exitcode = EXITCODE_CONFIG_NO_EXIST [EOL] [EOL] try : [EOL] with open ( EXAMPLE_CONFIG_PATH , [string] ) as example_config_file : [EOL] example_config = example_config_file . read ( ) [EOL] example_config = example_config . split ( [string] + ( [string] * [number] ) ) [ [number] ] [EOL] interim_config = ruamel . yaml . round_trip_load ( example_config ) [EOL] [EOL] except OSError as e : [EOL] exitcode = exitcode or e . errno [EOL] [EOL] return exitcode , interim_config [EOL] [EOL] [EOL] def save_config ( config , config_path ) : [EOL] with open ( config_path , [string] ) as config_file : [EOL] dump = str ( ruamel . yaml . round_trip_dump ( config ) ) [EOL] config_file . write ( dump ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0