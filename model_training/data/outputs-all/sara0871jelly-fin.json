[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from . aiohttp import AiohttpClientMocker [EOL] [EOL] import pytest [EOL] [EOL] [EOL] async def test_matching_url ( ) : [EOL] [docstring] [EOL] mocker = AiohttpClientMocker ( ) [EOL] mocker . get ( [string] ) [EOL] await mocker . match_request ( [string] , [string] ) [EOL] [EOL] mocker . clear_requests ( ) [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] await mocker . match_request ( [string] , [string] ) [EOL] [EOL] mocker . clear_requests ( ) [EOL] [EOL] mocker . get ( [string] ) [EOL] await mocker . match_request ( [string] , [string] , params = { [string] : [number] , [string] : [number] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . helpers import entity_registry [EOL] [EOL] from tests . common import mock_registry [EOL] [EOL] [EOL] YAML__OPEN_PATH = [string] [EOL] [EOL] [EOL] @ pytest . fixture def registry ( hass ) : [EOL] [docstring] [EOL] return mock_registry ( hass ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_or_create_returns_same_entry ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] entry2 = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] [EOL] assert len ( registry . entities ) == [number] [EOL] assert entry is entry2 [EOL] assert entry . entity_id == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_or_create_suggested_object_id ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] , suggested_object_id = [string] ) [EOL] [EOL] assert entry . entity_id == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_or_create_suggested_object_id_conflict_register ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] , suggested_object_id = [string] ) [EOL] entry2 = registry . async_get_or_create ( [string] , [string] , [string] , suggested_object_id = [string] ) [EOL] [EOL] assert entry . entity_id == [string] [EOL] assert entry2 . entity_id == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_or_create_suggested_object_id_conflict_existing ( hass , registry ) : [EOL] [docstring] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert entry . entity_id == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_create_triggers_save ( hass , registry ) : [EOL] [docstring] [EOL] with patch . object ( registry , [string] ) as mock_schedule_save : [EOL] registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] [EOL] assert len ( mock_schedule_save . mock_calls ) == [number] [EOL] [EOL] [EOL] async def test_loading_saving_data ( hass , registry ) : [EOL] [docstring] [EOL] orig_entry1 = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] orig_entry2 = registry . async_get_or_create ( [string] , [string] , [string] , config_entry_id = [string] ) [EOL] [EOL] assert len ( registry . entities ) == [number] [EOL] [EOL] [comment] [EOL] registry2 = entity_registry . EntityRegistry ( hass ) [EOL] registry2 . _store = registry . _store [EOL] [EOL] await registry2 . async_load ( ) [EOL] [EOL] [comment] [EOL] assert list ( registry . entities ) == list ( registry2 . entities ) [EOL] new_entry1 = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] new_entry2 = registry . async_get_or_create ( [string] , [string] , [string] , config_entry_id = [string] ) [EOL] [EOL] assert orig_entry1 == new_entry1 [EOL] assert orig_entry2 == new_entry2 [EOL] [EOL] [EOL] @ asyncio . coroutine def test_generate_entity_considers_registered_entities ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert entry . entity_id == [string] [EOL] assert registry . async_generate_entity_id ( [string] , [string] ) == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_generate_entity_considers_existing_entities ( hass , registry ) : [EOL] [docstring] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] assert registry . async_generate_entity_id ( [string] , [string] ) == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_is_registered ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert registry . async_is_registered ( entry . entity_id ) [EOL] assert not registry . async_is_registered ( [string] ) [EOL] [EOL] [EOL] async def test_loading_extra_values ( hass , hass_storage ) : [EOL] [docstring] [EOL] hass_storage [ entity_registry . STORAGE_KEY ] = { [string] : entity_registry . STORAGE_VERSION , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } } [EOL] [EOL] registry = await entity_registry . async_get_registry ( hass ) [EOL] [EOL] entry_with_name = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] entry_without_name = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert entry_with_name . name == [string] [EOL] assert entry_without_name . name is None [EOL] assert not entry_with_name . disabled [EOL] [EOL] entry_disabled_hass = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] entry_disabled_user = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert entry_disabled_hass . disabled [EOL] assert entry_disabled_hass . disabled_by == entity_registry . DISABLED_HASS [EOL] assert entry_disabled_user . disabled [EOL] assert entry_disabled_user . disabled_by == entity_registry . DISABLED_USER [EOL] [EOL] [EOL] @ asyncio . coroutine def test_async_get_entity_id ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert entry . entity_id == [string] [EOL] assert registry . async_get_entity_id ( [string] , [string] , [string] ) == [string] [EOL] assert registry . async_get_entity_id ( [string] , [string] , [string] ) is None [EOL] [EOL] [EOL] async def test_updating_config_entry_id ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] , config_entry_id = [string] ) [EOL] entry2 = registry . async_get_or_create ( [string] , [string] , [string] , config_entry_id = [string] ) [EOL] assert entry . entity_id == entry2 . entity_id [EOL] assert entry2 . config_entry_id == [string] [EOL] [EOL] [EOL] async def test_migration ( hass ) : [EOL] [docstring] [EOL] old_conf = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } } [EOL] with patch ( [string] , return_value = True ) , patch ( [string] ) , patch ( [string] , return_value = old_conf ) : [EOL] registry = await entity_registry . async_get_registry ( hass ) [EOL] [EOL] assert registry . async_is_registered ( [string] ) [EOL] entry = registry . async_get_or_create ( domain = [string] , platform = [string] , unique_id = [string] , config_entry_id = [string] , ) [EOL] assert entry . name == [string] [EOL] assert entry . disabled_by == [string] [EOL] assert entry . config_entry_id == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import List , Union , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import asyncio [EOL] import unittest [EOL] [EOL] from homeassistant . core import CoreState , State , Context [EOL] from homeassistant . setup import setup_component , async_setup_component [EOL] from homeassistant . components . input_text import ( DOMAIN , set_value ) [EOL] [EOL] from tests . common import get_test_home_assistant , mock_restore_cache [EOL] [EOL] [EOL] class TestInputText ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] [comment] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_config ( self ) : [EOL] [docstring] [EOL] invalid_configs = [ None , { } , { [string] : None } , { [string] : { [string] : [number] , [string] : [number] , } } , ] [EOL] for cfg in invalid_configs : [EOL] self . assertFalse ( setup_component ( self . hass , DOMAIN , { DOMAIN : cfg } ) ) [EOL] [EOL] def test_set_value ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , DOMAIN , { DOMAIN : { [string] : { [string] : [string] , [string] : [number] , [string] : [number] , } , } } ) ) [EOL] entity_id = [string] [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] self . assertEqual ( [string] , str ( state . state ) ) [EOL] [EOL] set_value ( self . hass , entity_id , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] self . assertEqual ( [string] , str ( state . state ) ) [EOL] [EOL] set_value ( self . hass , entity_id , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] self . assertEqual ( [string] , str ( state . state ) ) [EOL] [EOL] def test_mode ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , DOMAIN , { DOMAIN : { [string] : { [string] : [string] , [string] : [number] , [string] : [number] , } , [string] : { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , } , } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state [EOL] self . assertEqual ( [string] , state . attributes [ [string] ] ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state [EOL] self . assertEqual ( [string] , state . attributes [ [string] ] ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state [EOL] self . assertEqual ( [string] , state . attributes [ [string] ] ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_restore_state ( hass ) : [EOL] [docstring] [EOL] mock_restore_cache ( hass , ( State ( [string] , [string] ) , State ( [string] , [string] ) , ) ) [EOL] [EOL] hass . state = CoreState . starting [EOL] [EOL] yield from async_setup_component ( hass , DOMAIN , { DOMAIN : { [string] : { [string] : [number] , [string] : [number] , } , [string] : { [string] : [number] , [string] : [number] , } , } } ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert str ( state . state ) == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert str ( state . state ) == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_initial_state_overrules_restore_state ( hass ) : [EOL] [docstring] [EOL] mock_restore_cache ( hass , ( State ( [string] , [string] ) , State ( [string] , [string] ) , ) ) [EOL] [EOL] hass . state = CoreState . starting [EOL] [EOL] yield from async_setup_component ( hass , DOMAIN , { DOMAIN : { [string] : { [string] : [string] , [string] : [number] , [string] : [number] , } , [string] : { [string] : [string] , [string] : [number] , [string] : [number] , } , } } ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert str ( state . state ) == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert str ( state . state ) == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_no_initial_state_and_no_restore_state ( hass ) : [EOL] [docstring] [EOL] hass . state = CoreState . starting [EOL] [EOL] yield from async_setup_component ( hass , DOMAIN , { DOMAIN : { [string] : { [string] : [number] , [string] : [number] , } , } } ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert str ( state . state ) == [string] [EOL] [EOL] [EOL] async def test_input_text_context ( hass ) : [EOL] [docstring] [EOL] assert await async_setup_component ( hass , [string] , { [string] : { [string] : { [string] : [string] , } } } ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] [EOL] await hass . services . async_call ( [string] , [string] , { [string] : state . entity_id , [string] : [string] , } , True , Context ( user_id = [string] ) ) [EOL] [EOL] state2 = hass . states . get ( [string] ) [EOL] assert state2 is not None [EOL] assert state . state != state2 . state [EOL] assert state2 . context . user_id == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,None],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,None],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import List , Union , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . const import ( STATE_UNKNOWN , ATTR_UNIT_OF_MEASUREMENT , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class TestMinMaxSensor ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . values = [ [number] , [number] , [number] ] [EOL] self . count = len ( self . values ) [EOL] self . min = min ( self . values ) [EOL] self . max = max ( self . values ) [EOL] self . mean = round ( sum ( self . values ) / self . count , [number] ) [EOL] self . mean_1_digit = round ( sum ( self . values ) / self . count , [number] ) [EOL] self . mean_4_digits = round ( sum ( self . values ) / self . count , [number] ) [EOL] [EOL] def teardown_method ( self , method ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_min_sensor ( self ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , ] } } [EOL] [EOL] assert setup_component ( self . hass , [string] , config ) [EOL] [EOL] entity_ids = config [ [string] ] [ [string] ] [EOL] [EOL] for entity_id , value in dict ( zip ( entity_ids , self . values ) ) . items ( ) : [EOL] self . hass . states . set ( entity_id , value ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( str ( float ( self . min ) ) , state . state ) [EOL] self . assertEqual ( self . max , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( self . mean , state . attributes . get ( [string] ) ) [EOL] [EOL] def test_max_sensor ( self ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , ] } } [EOL] [EOL] assert setup_component ( self . hass , [string] , config ) [EOL] [EOL] entity_ids = config [ [string] ] [ [string] ] [EOL] [EOL] for entity_id , value in dict ( zip ( entity_ids , self . values ) ) . items ( ) : [EOL] self . hass . states . set ( entity_id , value ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( str ( float ( self . max ) ) , state . state ) [EOL] self . assertEqual ( self . min , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( self . mean , state . attributes . get ( [string] ) ) [EOL] [EOL] def test_mean_sensor ( self ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , ] } } [EOL] [EOL] assert setup_component ( self . hass , [string] , config ) [EOL] [EOL] entity_ids = config [ [string] ] [ [string] ] [EOL] [EOL] for entity_id , value in dict ( zip ( entity_ids , self . values ) ) . items ( ) : [EOL] self . hass . states . set ( entity_id , value ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( str ( float ( self . mean ) ) , state . state ) [EOL] self . assertEqual ( self . min , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( self . max , state . attributes . get ( [string] ) ) [EOL] [EOL] def test_mean_1_digit_sensor ( self ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] , [string] , ] } } [EOL] [EOL] assert setup_component ( self . hass , [string] , config ) [EOL] [EOL] entity_ids = config [ [string] ] [ [string] ] [EOL] [EOL] for entity_id , value in dict ( zip ( entity_ids , self . values ) ) . items ( ) : [EOL] self . hass . states . set ( entity_id , value ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( str ( float ( self . mean_1_digit ) ) , state . state ) [EOL] self . assertEqual ( self . min , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( self . max , state . attributes . get ( [string] ) ) [EOL] [EOL] def test_mean_4_digit_sensor ( self ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] , [string] , ] } } [EOL] [EOL] assert setup_component ( self . hass , [string] , config ) [EOL] [EOL] entity_ids = config [ [string] ] [ [string] ] [EOL] [EOL] for entity_id , value in dict ( zip ( entity_ids , self . values ) ) . items ( ) : [EOL] self . hass . states . set ( entity_id , value ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( str ( float ( self . mean_4_digits ) ) , state . state ) [EOL] self . assertEqual ( self . min , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( self . max , state . attributes . get ( [string] ) ) [EOL] [EOL] def test_not_enough_sensor_value ( self ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , ] } } [EOL] [EOL] assert setup_component ( self . hass , [string] , config ) [EOL] [EOL] entity_ids = config [ [string] ] [ [string] ] [EOL] [EOL] self . hass . states . set ( entity_ids [ [number] ] , STATE_UNKNOWN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] self . hass . states . set ( entity_ids [ [number] ] , self . values [ [number] ] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] self . hass . states . set ( entity_ids [ [number] ] , STATE_UNKNOWN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] self . hass . states . set ( entity_ids [ [number] ] , STATE_UNKNOWN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] def test_different_unit_of_measurement ( self ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , ] } } [EOL] [EOL] assert setup_component ( self . hass , [string] , config ) [EOL] [EOL] entity_ids = config [ [string] ] [ [string] ] [EOL] [EOL] self . hass . states . set ( entity_ids [ [number] ] , self . values [ [number] ] , { ATTR_UNIT_OF_MEASUREMENT : TEMP_CELSIUS } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( str ( float ( self . values [ [number] ] ) ) , state . state ) [EOL] self . assertEqual ( [string] , state . attributes . get ( [string] ) ) [EOL] [EOL] self . hass . states . set ( entity_ids [ [number] ] , self . values [ [number] ] , { ATTR_UNIT_OF_MEASUREMENT : TEMP_FAHRENHEIT } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] self . assertEqual ( [string] , state . attributes . get ( [string] ) ) [EOL] [EOL] self . hass . states . set ( entity_ids [ [number] ] , self . values [ [number] ] , { ATTR_UNIT_OF_MEASUREMENT : [string] } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] self . assertEqual ( [string] , state . attributes . get ( [string] ) ) [EOL] [EOL] def test_last_sensor ( self ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , ] } } [EOL] [EOL] assert setup_component ( self . hass , [string] , config ) [EOL] [EOL] entity_ids = config [ [string] ] [ [string] ] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] for entity_id , value in dict ( zip ( entity_ids , self . values ) ) . items ( ) : [EOL] self . hass . states . set ( entity_id , value ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( str ( float ( value ) ) , state . state ) [EOL] [EOL] self . assertEqual ( self . min , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( self . max , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( self . mean , state . attributes . get ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]]$ 0 0 0 $typing.Union[typing.List[builtins.str],builtins.int,builtins.str]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]]$ 0 0 0 $typing.Union[typing.List[builtins.str],builtins.int,builtins.str]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Generator , Union , Any , Dict , List [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from homeassistant . bootstrap import async_setup_component [EOL] from homeassistant . components . sensor . startca import StartcaData [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] [EOL] [EOL] @ asyncio . coroutine def test_capped_setup ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] } [EOL] [EOL] result = [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [EOL] aioclient_mock . get ( [string] [string] , text = result ) [EOL] [EOL] yield from async_setup_component ( hass , [string] , { [string] : config } ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_unlimited_setup ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] } [EOL] [EOL] result = [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [EOL] aioclient_mock . get ( [string] [string] , text = result ) [EOL] [EOL] yield from async_setup_component ( hass , [string] , { [string] : config } ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_bad_return_code ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] [string] , status = [number] ) [EOL] [EOL] scd = StartcaData ( hass . loop , async_get_clientsession ( hass ) , [string] , [number] ) [EOL] [EOL] result = yield from scd . async_update ( ) [EOL] assert result is False [EOL] [EOL] [EOL] @ asyncio . coroutine def test_bad_json_decode ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] [string] , text = [string] ) [EOL] [EOL] scd = StartcaData ( hass . loop , async_get_clientsession ( hass ) , [string] , [number] ) [EOL] [EOL] result = yield from scd . async_update ( ) [EOL] assert result is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import MagicMock [EOL] [EOL] from homeassistant . components . cover import zwave , SUPPORT_OPEN , SUPPORT_CLOSE [EOL] from homeassistant . components . zwave import const [EOL] [EOL] from tests . mock . zwave import ( MockNode , MockValue , MockEntityValues , value_changed ) [EOL] [EOL] [EOL] def test_get_device_detects_none ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = [number] , node = node ) [EOL] values = MockEntityValues ( primary = value , node = node ) [EOL] [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] assert device is None [EOL] [EOL] [EOL] def test_get_device_detects_rollershutter ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] hass . data [ zwave . zwave . DATA_NETWORK ] = MagicMock ( ) [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = [number] , node = node , command_class = const . COMMAND_CLASS_SWITCH_MULTILEVEL ) [EOL] values = MockEntityValues ( primary = value , open = None , close = None , node = node ) [EOL] [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] assert isinstance ( device , zwave . ZwaveRollershutter ) [EOL] [EOL] [EOL] def test_get_device_detects_garagedoor_switch ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = False , node = node , command_class = const . COMMAND_CLASS_SWITCH_BINARY ) [EOL] values = MockEntityValues ( primary = value , node = node ) [EOL] [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] assert isinstance ( device , zwave . ZwaveGarageDoorSwitch ) [EOL] assert device . device_class == [string] [EOL] assert device . supported_features == SUPPORT_OPEN | SUPPORT_CLOSE [EOL] [EOL] [EOL] def test_get_device_detects_garagedoor_barrier ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = [string] , node = node , command_class = const . COMMAND_CLASS_BARRIER_OPERATOR ) [EOL] values = MockEntityValues ( primary = value , node = node ) [EOL] [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] assert isinstance ( device , zwave . ZwaveGarageDoorBarrier ) [EOL] assert device . device_class == [string] [EOL] assert device . supported_features == SUPPORT_OPEN | SUPPORT_CLOSE [EOL] [EOL] [EOL] def test_roller_no_position_workaround ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] hass . data [ zwave . zwave . DATA_NETWORK ] = MagicMock ( ) [EOL] node = MockNode ( manufacturer_id = [string] , product_type = [string] ) [EOL] value = MockValue ( data = [number] , node = node , command_class = const . COMMAND_CLASS_SWITCH_MULTILEVEL ) [EOL] values = MockEntityValues ( primary = value , open = None , close = None , node = node ) [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] [EOL] assert device . current_cover_position is None [EOL] [EOL] [EOL] def test_roller_value_changed ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] hass . data [ zwave . zwave . DATA_NETWORK ] = MagicMock ( ) [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = None , node = node , command_class = const . COMMAND_CLASS_SWITCH_MULTILEVEL ) [EOL] values = MockEntityValues ( primary = value , open = None , close = None , node = node ) [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] [EOL] assert device . current_cover_position is None [EOL] assert device . is_closed is None [EOL] [EOL] value . data = [number] [EOL] value_changed ( value ) [EOL] [EOL] assert device . current_cover_position == [number] [EOL] assert device . is_closed [EOL] [EOL] value . data = [number] [EOL] value_changed ( value ) [EOL] [EOL] assert device . current_cover_position == [number] [EOL] assert not device . is_closed [EOL] [EOL] value . data = [number] [EOL] value_changed ( value ) [EOL] [EOL] assert device . current_cover_position == [number] [EOL] assert not device . is_closed [EOL] [EOL] [EOL] def test_roller_commands ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] mock_network = hass . data [ zwave . zwave . DATA_NETWORK ] = MagicMock ( ) [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = [number] , node = node , command_class = const . COMMAND_CLASS_SWITCH_MULTILEVEL ) [EOL] open_value = MockValue ( data = False , node = node ) [EOL] close_value = MockValue ( data = False , node = node ) [EOL] values = MockEntityValues ( primary = value , open = open_value , close = close_value , node = node ) [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] [EOL] device . set_cover_position ( position = [number] ) [EOL] assert node . set_dimmer . called [EOL] value_id , brightness = node . set_dimmer . mock_calls [ [number] ] [ [number] ] [EOL] assert value_id == value . value_id [EOL] assert brightness == [number] [EOL] [EOL] device . open_cover ( ) [EOL] assert mock_network . manager . pressButton . called [EOL] value_id , = mock_network . manager . pressButton . mock_calls . pop ( [number] ) [ [number] ] [EOL] assert value_id == open_value . value_id [EOL] [EOL] device . close_cover ( ) [EOL] assert mock_network . manager . pressButton . called [EOL] value_id , = mock_network . manager . pressButton . mock_calls . pop ( [number] ) [ [number] ] [EOL] assert value_id == close_value . value_id [EOL] [EOL] device . stop_cover ( ) [EOL] assert mock_network . manager . releaseButton . called [EOL] value_id , = mock_network . manager . releaseButton . mock_calls . pop ( [number] ) [ [number] ] [EOL] assert value_id == open_value . value_id [EOL] [EOL] [EOL] def test_roller_reverse_open_close ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] mock_network = hass . data [ zwave . zwave . DATA_NETWORK ] = MagicMock ( ) [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = [number] , node = node , command_class = const . COMMAND_CLASS_SWITCH_MULTILEVEL ) [EOL] open_value = MockValue ( data = False , node = node ) [EOL] close_value = MockValue ( data = False , node = node ) [EOL] values = MockEntityValues ( primary = value , open = open_value , close = close_value , node = node ) [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { zwave . zwave . CONF_INVERT_OPENCLOSE_BUTTONS : True } ) [EOL] [EOL] device . open_cover ( ) [EOL] assert mock_network . manager . pressButton . called [EOL] value_id , = mock_network . manager . pressButton . mock_calls . pop ( [number] ) [ [number] ] [EOL] assert value_id == close_value . value_id [EOL] [EOL] device . close_cover ( ) [EOL] assert mock_network . manager . pressButton . called [EOL] value_id , = mock_network . manager . pressButton . mock_calls . pop ( [number] ) [ [number] ] [EOL] assert value_id == open_value . value_id [EOL] [EOL] device . stop_cover ( ) [EOL] assert mock_network . manager . releaseButton . called [EOL] value_id , = mock_network . manager . releaseButton . mock_calls . pop ( [number] ) [ [number] ] [EOL] assert value_id == close_value . value_id [EOL] [EOL] [EOL] def test_switch_garage_value_changed ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = False , node = node , command_class = const . COMMAND_CLASS_SWITCH_BINARY ) [EOL] values = MockEntityValues ( primary = value , node = node ) [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] [EOL] assert device . is_closed [EOL] [EOL] value . data = True [EOL] value_changed ( value ) [EOL] assert not device . is_closed [EOL] [EOL] [EOL] def test_switch_garage_commands ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = False , node = node , command_class = const . COMMAND_CLASS_SWITCH_BINARY ) [EOL] values = MockEntityValues ( primary = value , node = node ) [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] [EOL] assert value . data is False [EOL] device . open_cover ( ) [EOL] assert value . data is True [EOL] device . close_cover ( ) [EOL] assert value . data is False [EOL] [EOL] [EOL] def test_barrier_garage_value_changed ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = [string] , node = node , command_class = const . COMMAND_CLASS_BARRIER_OPERATOR ) [EOL] values = MockEntityValues ( primary = value , node = node ) [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] [EOL] assert device . is_closed [EOL] assert not device . is_opening [EOL] assert not device . is_closing [EOL] [EOL] value . data = [string] [EOL] value_changed ( value ) [EOL] assert not device . is_closed [EOL] assert device . is_opening [EOL] assert not device . is_closing [EOL] [EOL] value . data = [string] [EOL] value_changed ( value ) [EOL] assert not device . is_closed [EOL] assert not device . is_opening [EOL] assert not device . is_closing [EOL] [EOL] value . data = [string] [EOL] value_changed ( value ) [EOL] assert not device . is_closed [EOL] assert not device . is_opening [EOL] assert device . is_closing [EOL] [EOL] [EOL] def test_barrier_garage_commands ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = [string] , node = node , command_class = const . COMMAND_CLASS_BARRIER_OPERATOR ) [EOL] values = MockEntityValues ( primary = value , node = node ) [EOL] device = zwave . get_device ( hass = hass , node = node , values = values , node_config = { } ) [EOL] [EOL] assert value . data == [string] [EOL] device . open_cover ( ) [EOL] assert value . data == [string] [EOL] device . close_cover ( ) [EOL] assert value . data == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Type , Union , List , Dict [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import unittest [EOL] import requests_mock [EOL] [EOL] from homeassistant . components . binary_sensor import ring [EOL] from homeassistant . components import ring as base_ring [EOL] [EOL] from tests . components . test_ring import ATTRIBUTION , VALID_CONFIG [EOL] from tests . common import ( get_test_config_dir , get_test_home_assistant , load_fixture ) [EOL] [EOL] [EOL] class TestRingBinarySensorSetup ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] DEVICES = [ ] [EOL] [EOL] def add_entities ( self , devices , action ) : [EOL] [docstring] [EOL] for device in devices : [EOL] self . DEVICES . append ( device ) [EOL] [EOL] def cleanup ( self ) : [EOL] [docstring] [EOL] if os . path . isfile ( self . cache ) : [EOL] os . remove ( self . cache ) [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . cache = get_test_config_dir ( base_ring . DEFAULT_CACHEDB ) [EOL] self . config = { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , } [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] self . cleanup ( ) [EOL] [EOL] @ requests_mock . Mocker ( ) def test_binary_sensor ( self , mock ) : [EOL] [docstring] [EOL] mock . post ( [string] , text = load_fixture ( [string] ) ) [EOL] mock . post ( [string] , text = load_fixture ( [string] ) ) [EOL] mock . get ( [string] , text = load_fixture ( [string] ) ) [EOL] mock . get ( [string] , text = load_fixture ( [string] ) ) [EOL] mock . get ( [string] , text = load_fixture ( [string] ) ) [EOL] [EOL] base_ring . setup ( self . hass , VALID_CONFIG ) [EOL] ring . setup_platform ( self . hass , self . config , self . add_entities , None ) [EOL] [EOL] for device in self . DEVICES : [EOL] device . update ( ) [EOL] if device . name == [string] : [EOL] self . assertEqual ( [string] , device . state ) [EOL] self . assertEqual ( [string] , device . device_state_attributes [ [string] ] ) [EOL] elif device . name == [string] : [EOL] self . assertEqual ( [string] , device . state ) [EOL] self . assertEqual ( [string] , device . device_class ) [EOL] [EOL] self . assertIsNone ( device . entity_picture ) [EOL] self . assertEqual ( ATTRIBUTION , device . device_state_attributes [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 $builtins.int$ 0 0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import List , Tuple , Set , Any [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] from itertools import chain [EOL] [EOL] from homeassistant import config as conf_util [EOL] from homeassistant . setup import async_prepare_setup_platform [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , CONF_SCAN_INTERVAL , CONF_ENTITY_NAMESPACE ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] from homeassistant . helpers import config_per_platform , discovery [EOL] from homeassistant . helpers . service import extract_entity_ids [EOL] from homeassistant . util import slugify [EOL] from . entity_platform import EntityPlatform [EOL] [EOL] DEFAULT_SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] class EntityComponent : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , logger , domain , hass , scan_interval = DEFAULT_SCAN_INTERVAL , group_name = None ) : [EOL] [docstring] [EOL] self . logger = logger [EOL] self . hass = hass [EOL] self . domain = domain [EOL] self . scan_interval = scan_interval [EOL] self . group_name = group_name [EOL] [EOL] self . config = None [EOL] [EOL] self . _platforms = { domain : self . _async_init_entity_platform ( domain , None ) } [EOL] self . async_add_entities = self . _platforms [ domain ] . async_add_entities [EOL] self . add_entities = self . _platforms [ domain ] . add_entities [EOL] [EOL] @ property def entities ( self ) : [EOL] [docstring] [EOL] return chain . from_iterable ( platform . entities . values ( ) for platform in self . _platforms . values ( ) ) [EOL] [EOL] def get_entity ( self , entity_id ) : [EOL] [docstring] [EOL] for platform in self . _platforms . values ( ) : [EOL] entity = platform . entities . get ( entity_id ) [EOL] if entity is not None : [EOL] return entity [EOL] return None [EOL] [EOL] def setup ( self , config ) : [EOL] [docstring] [EOL] self . hass . add_job ( self . async_setup ( config ) ) [EOL] [EOL] async def async_setup ( self , config ) : [EOL] [docstring] [EOL] self . config = config [EOL] [EOL] [comment] [EOL] tasks = [ ] [EOL] for p_type , p_config in config_per_platform ( config , self . domain ) : [EOL] tasks . append ( self . _async_setup_platform ( p_type , p_config ) ) [EOL] [EOL] if tasks : [EOL] await asyncio . wait ( tasks , loop = self . hass . loop ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] async def component_platform_discovered ( platform , info ) : [EOL] [docstring] [EOL] await self . _async_setup_platform ( platform , { } , info ) [EOL] [EOL] discovery . async_listen_platform ( self . hass , self . domain , component_platform_discovered ) [EOL] [EOL] async def async_setup_entry ( self , config_entry ) : [EOL] [docstring] [EOL] platform_type = config_entry . domain [EOL] platform = await async_prepare_setup_platform ( self . hass , self . config , self . domain , platform_type ) [EOL] [EOL] if platform is None : [EOL] return False [EOL] [EOL] key = config_entry . entry_id [EOL] [EOL] if key in self . _platforms : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . _platforms [ key ] = self . _async_init_entity_platform ( platform_type , platform , scan_interval = getattr ( platform , [string] , None ) , ) [EOL] [EOL] return await self . _platforms [ key ] . async_setup_entry ( config_entry ) [EOL] [EOL] async def async_unload_entry ( self , config_entry ) : [EOL] [docstring] [EOL] key = config_entry . entry_id [EOL] [EOL] platform = self . _platforms . pop ( key , None ) [EOL] [EOL] if platform is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] await platform . async_reset ( ) [EOL] return True [EOL] [EOL] @ callback def async_extract_from_service ( self , service , expand_group = True ) : [EOL] [docstring] [EOL] if ATTR_ENTITY_ID not in service . data : [EOL] return [ entity for entity in self . entities if entity . available ] [EOL] [EOL] entity_ids = set ( extract_entity_ids ( self . hass , service , expand_group ) ) [EOL] return [ entity for entity in self . entities if entity . available and entity . entity_id in entity_ids ] [EOL] [EOL] @ callback def async_register_entity_service ( self , name , schema , func ) : [EOL] [docstring] [EOL] async def handle_service ( call ) : [EOL] [docstring] [EOL] await self . hass . helpers . service . entity_service_call ( self . _platforms . values ( ) , func , call ) [EOL] [EOL] self . hass . services . async_register ( self . domain , name , handle_service , schema ) [EOL] [EOL] async def _async_setup_platform ( self , platform_type , platform_config , discovery_info = None ) : [EOL] [docstring] [EOL] platform = await async_prepare_setup_platform ( self . hass , self . config , self . domain , platform_type ) [EOL] [EOL] if platform is None : [EOL] return [EOL] [EOL] [comment] [EOL] scan_interval = platform_config . get ( CONF_SCAN_INTERVAL , getattr ( platform , [string] , None ) ) [EOL] entity_namespace = platform_config . get ( CONF_ENTITY_NAMESPACE ) [EOL] [EOL] key = ( platform_type , scan_interval , entity_namespace ) [EOL] [EOL] if key not in self . _platforms : [EOL] self . _platforms [ key ] = self . _async_init_entity_platform ( platform_type , platform , scan_interval , entity_namespace ) [EOL] [EOL] await self . _platforms [ key ] . async_setup ( platform_config , discovery_info ) [EOL] [EOL] @ callback def _async_update_group ( self ) : [EOL] [docstring] [EOL] if self . group_name is None : [EOL] return [EOL] [EOL] ids = [ entity . entity_id for entity in sorted ( self . entities , key = lambda entity : entity . name or entity . entity_id ) ] [EOL] [EOL] self . hass . components . group . async_set_group ( slugify ( self . group_name ) , name = self . group_name , visible = False , entity_ids = ids ) [EOL] [EOL] async def _async_reset ( self ) : [EOL] [docstring] [EOL] tasks = [ platform . async_reset ( ) for platform in self . _platforms . values ( ) ] [EOL] [EOL] if tasks : [EOL] await asyncio . wait ( tasks , loop = self . hass . loop ) [EOL] [EOL] self . _platforms = { self . domain : self . _platforms [ self . domain ] } [EOL] self . config = None [EOL] [EOL] if self . group_name is not None : [EOL] self . hass . components . group . async_remove ( slugify ( self . group_name ) ) [EOL] [EOL] async def async_remove_entity ( self , entity_id ) : [EOL] [docstring] [EOL] for platform in self . _platforms . values ( ) : [EOL] if entity_id in platform . entities : [EOL] await platform . async_remove_entity ( entity_id ) [EOL] [EOL] async def async_prepare_reload ( self ) : [EOL] [docstring] [EOL] try : [EOL] conf = await conf_util . async_hass_config_yaml ( self . hass ) [EOL] except HomeAssistantError as err : [EOL] self . logger . error ( err ) [EOL] return None [EOL] [EOL] conf = conf_util . async_process_component_config ( self . hass , conf , self . domain ) [EOL] [EOL] if conf is None : [EOL] return None [EOL] [EOL] await self . _async_reset ( ) [EOL] return conf [EOL] [EOL] def _async_init_entity_platform ( self , platform_type , platform , scan_interval = None , entity_namespace = None ) : [EOL] [docstring] [EOL] if scan_interval is None : [EOL] scan_interval = self . scan_interval [EOL] [EOL] return EntityPlatform ( hass = self . hass , logger = self . logger , domain = self . domain , platform_name = platform_type , platform = platform , scan_interval = scan_interval , entity_namespace = entity_namespace , async_entities_added_callback = self . _async_update_group , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import json [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_DOMAINS , CONF_ENTITIES , CONF_EXCLUDE , CONF_INCLUDE , MATCH_ALL ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . mqtt import valid_publish_topic [EOL] from homeassistant . helpers . entityfilter import generate_filter [EOL] from homeassistant . helpers . event import async_track_state_change [EOL] from homeassistant . helpers . json import JSONEncoder [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] CONF_BASE_TOPIC = [string] [EOL] CONF_PUBLISH_ATTRIBUTES = [string] [EOL] CONF_PUBLISH_TIMESTAMPS = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] DOMAIN = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Optional ( CONF_EXCLUDE , default = { } ) : vol . Schema ( { vol . Optional ( CONF_ENTITIES , default = [ ] ) : cv . entity_ids , vol . Optional ( CONF_DOMAINS , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) } ) , vol . Optional ( CONF_INCLUDE , default = { } ) : vol . Schema ( { vol . Optional ( CONF_ENTITIES , default = [ ] ) : cv . entity_ids , vol . Optional ( CONF_DOMAINS , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) } ) , vol . Required ( CONF_BASE_TOPIC ) : valid_publish_topic , vol . Optional ( CONF_PUBLISH_ATTRIBUTES , default = False ) : cv . boolean , vol . Optional ( CONF_PUBLISH_TIMESTAMPS , default = False ) : cv . boolean } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config . get ( DOMAIN , { } ) [EOL] base_topic = conf . get ( CONF_BASE_TOPIC ) [EOL] pub_include = conf . get ( CONF_INCLUDE , { } ) [EOL] pub_exclude = conf . get ( CONF_EXCLUDE , { } ) [EOL] publish_attributes = conf . get ( CONF_PUBLISH_ATTRIBUTES ) [EOL] publish_timestamps = conf . get ( CONF_PUBLISH_TIMESTAMPS ) [EOL] publish_filter = generate_filter ( pub_include . get ( CONF_DOMAINS , [ ] ) , pub_include . get ( CONF_ENTITIES , [ ] ) , pub_exclude . get ( CONF_DOMAINS , [ ] ) , pub_exclude . get ( CONF_ENTITIES , [ ] ) ) [EOL] if not base_topic . endswith ( [string] ) : [EOL] base_topic = base_topic + [string] [EOL] [EOL] @ callback def _state_publisher ( entity_id , old_state , new_state ) : [EOL] if new_state is None : [EOL] return [EOL] [EOL] if not publish_filter ( entity_id ) : [EOL] return [EOL] [EOL] payload = new_state . state [EOL] [EOL] mybase = base_topic + entity_id . replace ( [string] , [string] ) + [string] [EOL] hass . components . mqtt . async_publish ( mybase + [string] , payload , [number] , True ) [EOL] [EOL] if publish_timestamps : [EOL] if new_state . last_updated : [EOL] hass . components . mqtt . async_publish ( mybase + [string] , new_state . last_updated . isoformat ( ) , [number] , True ) [EOL] if new_state . last_changed : [EOL] hass . components . mqtt . async_publish ( mybase + [string] , new_state . last_changed . isoformat ( ) , [number] , True ) [EOL] [EOL] if publish_attributes : [EOL] for key , val in new_state . attributes . items ( ) : [EOL] encoded_val = json . dumps ( val , cls = JSONEncoder ) [EOL] hass . components . mqtt . async_publish ( mybase + key , encoded_val , [number] , True ) [EOL] [EOL] async_track_state_change ( hass , MATCH_ALL , _state_publisher ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , config ) : [EOL] [docstring] [EOL] _LOGGER . warning ( [string] [string] ) [EOL] _LOGGER . warning ( [string] ) [EOL] [EOL] hass . components . persistent_notification . create ( [string] [string] , title = [string] , notification_id = [string] ) [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Generator , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ATTR_ENTITY_ID , CONF_ICON , CONF_NAME [EOL] from homeassistant . loader import bind_hass [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . restore_state import async_get_last_state [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] CONF_INITIAL = [string] [EOL] CONF_OPTIONS = [string] [EOL] [EOL] ATTR_OPTION = [string] [EOL] ATTR_OPTIONS = [string] [EOL] [EOL] SERVICE_SELECT_OPTION = [string] [EOL] [EOL] SERVICE_SELECT_OPTION_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_OPTION ) : cv . string , } ) [EOL] [EOL] SERVICE_SELECT_NEXT = [string] [EOL] [EOL] SERVICE_SELECT_NEXT_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] SERVICE_SELECT_PREVIOUS = [string] [EOL] [EOL] SERVICE_SELECT_PREVIOUS_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] [EOL] SERVICE_SET_OPTIONS = [string] [EOL] [EOL] SERVICE_SET_OPTIONS_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_OPTIONS ) : vol . All ( cv . ensure_list , vol . Length ( min = [number] ) , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def _cv_input_select ( cfg ) : [EOL] [docstring] [EOL] options = cfg [ CONF_OPTIONS ] [EOL] initial = cfg . get ( CONF_INITIAL ) [EOL] if initial is not None and initial not in options : [EOL] raise vol . Invalid ( [string] . format ( initial , [string] . join ( options ) ) ) [EOL] return cfg [EOL] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { cv . slug : vol . All ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Required ( CONF_OPTIONS ) : vol . All ( cv . ensure_list , vol . Length ( min = [number] ) , [ cv . string ] ) , vol . Optional ( CONF_INITIAL ) : cv . string , vol . Optional ( CONF_ICON ) : cv . icon , } , _cv_input_select ) } ) } , required = True , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ bind_hass def select_option ( hass , entity_id , option ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_SELECT_OPTION , { ATTR_ENTITY_ID : entity_id , ATTR_OPTION : option , } ) [EOL] [EOL] [EOL] @ bind_hass def select_next ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_SELECT_NEXT , { ATTR_ENTITY_ID : entity_id , } ) [EOL] [EOL] [EOL] @ bind_hass def select_previous ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_SELECT_PREVIOUS , { ATTR_ENTITY_ID : entity_id , } ) [EOL] [EOL] [EOL] @ bind_hass def set_options ( hass , entity_id , options ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_SET_OPTIONS , { ATTR_ENTITY_ID : entity_id , ATTR_OPTIONS : options , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass ) [EOL] [EOL] entities = [ ] [EOL] [EOL] for object_id , cfg in config [ DOMAIN ] . items ( ) : [EOL] name = cfg . get ( CONF_NAME ) [EOL] options = cfg . get ( CONF_OPTIONS ) [EOL] initial = cfg . get ( CONF_INITIAL ) [EOL] icon = cfg . get ( CONF_ICON ) [EOL] entities . append ( InputSelect ( object_id , name , initial , options , icon ) ) [EOL] [EOL] if not entities : [EOL] return False [EOL] [EOL] component . async_register_entity_service ( SERVICE_SELECT_OPTION , SERVICE_SELECT_OPTION_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_SELECT_NEXT , SERVICE_SELECT_NEXT_SCHEMA , lambda entity , call : entity . async_offset_index ( [number] ) ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_SELECT_PREVIOUS , SERVICE_SELECT_PREVIOUS_SCHEMA , lambda entity , call : entity . async_offset_index ( - [number] ) ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_SET_OPTIONS , SERVICE_SET_OPTIONS_SCHEMA , [string] ) [EOL] [EOL] yield from component . async_add_entities ( entities ) [EOL] return True [EOL] [EOL] [EOL] class InputSelect ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , object_id , name , initial , options , icon ) : [EOL] [docstring] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( object_id ) [EOL] self . _name = name [EOL] self . _current_option = initial [EOL] self . _options = options [EOL] self . _icon = icon [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] if self . _current_option is not None : [EOL] return [EOL] [EOL] state = yield from async_get_last_state ( self . hass , self . entity_id ) [EOL] if not state or state . state not in self . _options : [EOL] self . _current_option = self . _options [ [number] ] [EOL] else : [EOL] self . _current_option = state . state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _current_option [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_OPTIONS : self . _options , } [EOL] [EOL] @ asyncio . coroutine def async_select_option ( self , option ) : [EOL] [docstring] [EOL] if option not in self . _options : [EOL] _LOGGER . warning ( [string] , option , [string] . join ( self . _options ) ) [EOL] return [EOL] self . _current_option = option [EOL] yield from self . async_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_offset_index ( self , offset ) : [EOL] [docstring] [EOL] current_index = self . _options . index ( self . _current_option ) [EOL] new_index = ( current_index + offset ) % len ( self . _options ) [EOL] self . _current_option = self . _options [ new_index ] [EOL] yield from self . async_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_set_options ( self , options ) : [EOL] [docstring] [EOL] self . _current_option = options [ [number] ] [EOL] self . _options = options [EOL] yield from self . async_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 $typing.Generator[typing.Any,None,None]$ 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . const import ( EVENT_HOMEASSISTANT_START , EVENT_HOMEASSISTANT_STOP ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] [comment] [EOL] from Adafruit_BBIO import GPIO [EOL] [EOL] def cleanup_gpio ( event ) : [EOL] [docstring] [EOL] GPIO . cleanup ( ) [EOL] [EOL] def prepare_gpio ( event ) : [EOL] [docstring] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , cleanup_gpio ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , prepare_gpio ) [EOL] return True [EOL] [EOL] [EOL] def setup_output ( pin ) : [EOL] [docstring] [EOL] [comment] [EOL] from Adafruit_BBIO import GPIO [EOL] GPIO . setup ( pin , GPIO . OUT ) [EOL] [EOL] [EOL] def setup_input ( pin , pull_mode ) : [EOL] [docstring] [EOL] [comment] [EOL] from Adafruit_BBIO import GPIO [EOL] GPIO . setup ( pin , GPIO . IN , GPIO . PUD_DOWN if pull_mode == [string] [EOL] else GPIO . PUD_UP ) [EOL] [EOL] [EOL] def write_output ( pin , value ) : [EOL] [docstring] [EOL] [comment] [EOL] from Adafruit_BBIO import GPIO [EOL] GPIO . output ( pin , value ) [EOL] [EOL] [EOL] def read_input ( pin ) : [EOL] [docstring] [EOL] [comment] [EOL] from Adafruit_BBIO import GPIO [EOL] return GPIO . input ( pin ) is GPIO . HIGH [EOL] [EOL] [EOL] def edge_detect ( pin , event_callback , bounce ) : [EOL] [docstring] [EOL] [comment] [EOL] from Adafruit_BBIO import GPIO [EOL] GPIO . add_event_detect ( pin , GPIO . BOTH , callback = event_callback , bouncetime = bounce ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_USERNAME , CONF_PASSWORD , CONF_DEVICES [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers import discovery [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_DEVICES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] import nuheat [EOL] [EOL] conf = config [ DOMAIN ] [EOL] username = conf . get ( CONF_USERNAME ) [EOL] password = conf . get ( CONF_PASSWORD ) [EOL] devices = conf . get ( CONF_DEVICES ) [EOL] [EOL] api = nuheat . NuHeat ( username , password ) [EOL] api . authenticate ( ) [EOL] hass . data [ DOMAIN ] = ( api , devices ) [EOL] [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , ENTITY_ID_FORMAT , PLATFORM_SCHEMA , DEVICE_CLASSES_SCHEMA ) [EOL] from homeassistant . const import ( ATTR_FRIENDLY_NAME , ATTR_ENTITY_ID , CONF_VALUE_TEMPLATE , CONF_ICON_TEMPLATE , CONF_ENTITY_PICTURE_TEMPLATE , CONF_SENSORS , CONF_DEVICE_CLASS , EVENT_HOMEASSISTANT_START ) [EOL] from homeassistant . exceptions import TemplateError [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import async_generate_entity_id [EOL] from homeassistant . helpers . event import ( async_track_state_change , async_track_same_state ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DELAY_ON = [string] [EOL] CONF_DELAY_OFF = [string] [EOL] [EOL] SENSOR_SCHEMA = vol . Schema ( { vol . Required ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_ICON_TEMPLATE ) : cv . template , vol . Optional ( CONF_ENTITY_PICTURE_TEMPLATE ) : cv . template , vol . Optional ( ATTR_FRIENDLY_NAME ) : cv . string , vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Optional ( CONF_DEVICE_CLASS ) : DEVICE_CLASSES_SCHEMA , vol . Optional ( CONF_DELAY_ON ) : vol . All ( cv . time_period , cv . positive_timedelta ) , vol . Optional ( CONF_DELAY_OFF ) : vol . All ( cv . time_period , cv . positive_timedelta ) , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SENSORS ) : vol . Schema ( { cv . slug : SENSOR_SCHEMA } ) , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] sensors = [ ] [EOL] [EOL] for device , device_config in config [ CONF_SENSORS ] . items ( ) : [EOL] value_template = device_config [ CONF_VALUE_TEMPLATE ] [EOL] icon_template = device_config . get ( CONF_ICON_TEMPLATE ) [EOL] entity_picture_template = device_config . get ( CONF_ENTITY_PICTURE_TEMPLATE ) [EOL] entity_ids = ( device_config . get ( ATTR_ENTITY_ID ) or value_template . extract_entities ( ) ) [EOL] friendly_name = device_config . get ( ATTR_FRIENDLY_NAME , device ) [EOL] device_class = device_config . get ( CONF_DEVICE_CLASS ) [EOL] delay_on = device_config . get ( CONF_DELAY_ON ) [EOL] delay_off = device_config . get ( CONF_DELAY_OFF ) [EOL] [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] if icon_template is not None : [EOL] icon_template . hass = hass [EOL] [EOL] if entity_picture_template is not None : [EOL] entity_picture_template . hass = hass [EOL] [EOL] sensors . append ( BinarySensorTemplate ( hass , device , friendly_name , device_class , value_template , icon_template , entity_picture_template , entity_ids , delay_on , delay_off ) ) [EOL] if not sensors : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] async_add_entities ( sensors ) [EOL] return True [EOL] [EOL] [EOL] class BinarySensorTemplate ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device , friendly_name , device_class , value_template , icon_template , entity_picture_template , entity_ids , delay_on , delay_off ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . entity_id = async_generate_entity_id ( ENTITY_ID_FORMAT , device , hass = hass ) [EOL] self . _name = friendly_name [EOL] self . _device_class = device_class [EOL] self . _template = value_template [EOL] self . _state = None [EOL] self . _icon_template = icon_template [EOL] self . _entity_picture_template = entity_picture_template [EOL] self . _icon = None [EOL] self . _entity_picture = None [EOL] self . _entities = entity_ids [EOL] self . _delay_on = delay_on [EOL] self . _delay_off = delay_off [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] @ callback def template_bsensor_state_listener ( entity , old_state , new_state ) : [EOL] [docstring] [EOL] self . async_check_state ( ) [EOL] [EOL] @ callback def template_bsensor_startup ( event ) : [EOL] [docstring] [EOL] async_track_state_change ( self . hass , self . _entities , template_bsensor_state_listener ) [EOL] [EOL] self . hass . async_add_job ( self . async_check_state ) [EOL] [EOL] self . hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_START , template_bsensor_startup ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def entity_picture ( self ) : [EOL] [docstring] [EOL] return self . _entity_picture [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ callback def _async_render ( self ) : [EOL] [docstring] [EOL] state = None [EOL] try : [EOL] state = ( self . _template . async_render ( ) . lower ( ) == [string] ) [EOL] except TemplateError as ex : [EOL] if ex . args and ex . args [ [number] ] . startswith ( [string] ) : [EOL] [comment] [EOL] _LOGGER . warning ( [string] [string] , self . _name ) [EOL] return [EOL] _LOGGER . error ( [string] , self . _name , ex ) [EOL] [EOL] for property_name , template in ( ( [string] , self . _icon_template ) , ( [string] , self . _entity_picture_template ) ) : [EOL] if template is None : [EOL] continue [EOL] [EOL] try : [EOL] setattr ( self , property_name , template . async_render ( ) ) [EOL] except TemplateError as ex : [EOL] friendly_property_name = property_name [ [number] : ] . replace ( [string] , [string] ) [EOL] if ex . args and ex . args [ [number] ] . startswith ( [string] ) : [EOL] [comment] [EOL] _LOGGER . warning ( [string] [string] , friendly_property_name , self . _name ) [EOL] else : [EOL] _LOGGER . error ( [string] , friendly_property_name , self . _name , ex ) [EOL] return state [EOL] [EOL] return state [EOL] [EOL] @ callback def async_check_state ( self ) : [EOL] [docstring] [EOL] state = self . _async_render ( ) [EOL] [EOL] [comment] [EOL] if state is None or state == self . state : [EOL] return [EOL] [EOL] @ callback def set_state ( ) : [EOL] [docstring] [EOL] self . _state = state [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] [comment] [EOL] if ( state and not self . _delay_on ) or ( not state and not self . _delay_off ) : [EOL] set_state ( ) [EOL] return [EOL] [EOL] period = self . _delay_on if state else self . _delay_off [EOL] async_track_same_state ( self . hass , period , set_state , entity_ids = self . _entities , async_check_same_func = lambda * args : self . _async_render ( ) == state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Optional , Dict [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components import mysensors [EOL] from homeassistant . components . binary_sensor import ( DEVICE_CLASSES , DOMAIN , BinarySensorDevice ) [EOL] from homeassistant . const import STATE_ON [EOL] [EOL] SENSORS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] mysensors . setup_mysensors_platform ( hass , DOMAIN , discovery_info , MySensorsBinarySensor , async_add_entities = async_add_entities ) [EOL] [EOL] [EOL] class MySensorsBinarySensor ( mysensors . device . MySensorsEntity , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _values . get ( self . value_type ) == STATE_ON [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] pres = self . gateway . const . Presentation [EOL] device_class = SENSORS . get ( pres ( self . child_type ) . name ) [EOL] if device_class in DEVICE_CLASSES : [EOL] return device_class [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . digital_ocean import ( CONF_DROPLETS , ATTR_CREATED_AT , ATTR_DROPLET_ID , ATTR_DROPLET_NAME , ATTR_FEATURES , ATTR_IPV4_ADDRESS , ATTR_IPV6_ADDRESS , ATTR_MEMORY , ATTR_REGION , ATTR_VCPUS , CONF_ATTRIBUTION , DATA_DIGITAL_OCEAN ) [EOL] from homeassistant . const import ATTR_ATTRIBUTION [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_DEVICE_CLASS = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DROPLETS ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] digital = hass . data . get ( DATA_DIGITAL_OCEAN ) [EOL] if not digital : [EOL] return False [EOL] [EOL] droplets = config . get ( CONF_DROPLETS ) [EOL] [EOL] dev = [ ] [EOL] for droplet in droplets : [EOL] droplet_id = digital . get_droplet_id ( droplet ) [EOL] if droplet_id is None : [EOL] _LOGGER . error ( [string] , droplet ) [EOL] return False [EOL] dev . append ( DigitalOceanBinarySensor ( digital , droplet_id ) ) [EOL] [EOL] add_entities ( dev , True ) [EOL] [EOL] [EOL] class DigitalOceanBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , do , droplet_id ) : [EOL] [docstring] [EOL] self . _digital_ocean = do [EOL] self . _droplet_id = droplet_id [EOL] self . _state = None [EOL] self . data = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . data . name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . data . status == [string] [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEFAULT_DEVICE_CLASS [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , ATTR_CREATED_AT : self . data . created_at , ATTR_DROPLET_ID : self . data . id , ATTR_DROPLET_NAME : self . data . name , ATTR_FEATURES : self . data . features , ATTR_IPV4_ADDRESS : self . data . ip_address , ATTR_IPV6_ADDRESS : self . data . ip_v6_address , ATTR_MEMORY : self . data . memory , ATTR_REGION : self . data . region [ [string] ] , ATTR_VCPUS : self . data . vcpus , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _digital_ocean . update ( ) [EOL] [EOL] for droplet in self . _digital_ocean . data : [EOL] if droplet . id == self . _droplet_id : [EOL] self . data = droplet [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import datetime [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] from homeassistant . components import pilight [EOL] from homeassistant . components . binary_sensor import ( PLATFORM_SCHEMA , BinarySensorDevice , ) [EOL] from homeassistant . const import ( CONF_DISARM_AFTER_TRIGGER , CONF_NAME , CONF_PAYLOAD , CONF_PAYLOAD_OFF , CONF_PAYLOAD_ON ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . event import track_point_in_time [EOL] from homeassistant . util import dt as dt_util [EOL] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_VARIABLE = [string] [EOL] CONF_RESET_DELAY_SEC = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_VARIABLE ) : cv . string , vol . Required ( CONF_PAYLOAD ) : vol . Schema ( dict ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PAYLOAD_ON , default = [string] ) : cv . string , vol . Optional ( CONF_PAYLOAD_OFF , default = [string] ) : cv . string , vol . Optional ( CONF_DISARM_AFTER_TRIGGER , default = False ) : cv . boolean , vol . Optional ( CONF_RESET_DELAY_SEC , default = [number] ) : cv . positive_int } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] disarm = config . get ( CONF_DISARM_AFTER_TRIGGER ) [EOL] if disarm : [EOL] add_entities ( [ PilightTriggerSensor ( hass = hass , name = config . get ( CONF_NAME ) , variable = config . get ( CONF_VARIABLE ) , payload = config . get ( CONF_PAYLOAD ) , on_value = config . get ( CONF_PAYLOAD_ON ) , off_value = config . get ( CONF_PAYLOAD_OFF ) , rst_dly_sec = config . get ( CONF_RESET_DELAY_SEC ) , ) ] ) [EOL] else : [EOL] add_entities ( [ PilightBinarySensor ( hass = hass , name = config . get ( CONF_NAME ) , variable = config . get ( CONF_VARIABLE ) , payload = config . get ( CONF_PAYLOAD ) , on_value = config . get ( CONF_PAYLOAD_ON ) , off_value = config . get ( CONF_PAYLOAD_OFF ) , ) ] ) [EOL] [EOL] [EOL] class PilightBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , variable , payload , on_value , off_value ) : [EOL] [docstring] [EOL] self . _state = False [EOL] self . _hass = hass [EOL] self . _name = name [EOL] self . _variable = variable [EOL] self . _payload = payload [EOL] self . _on_value = on_value [EOL] self . _off_value = off_value [EOL] [EOL] hass . bus . listen ( pilight . EVENT , self . _handle_code ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def _handle_code ( self , call ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] payload_ok = True [EOL] for key in self . _payload : [EOL] if key not in call . data : [EOL] payload_ok = False [EOL] continue [EOL] if self . _payload [ key ] != call . data [ key ] : [EOL] payload_ok = False [EOL] [comment] [EOL] if payload_ok : [EOL] if self . _variable not in call . data : [EOL] return [EOL] value = call . data [ self . _variable ] [EOL] self . _state = ( value == self . _on_value ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] [EOL] class PilightTriggerSensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , variable , payload , on_value , off_value , rst_dly_sec = [number] ) : [EOL] [docstring] [EOL] self . _state = False [EOL] self . _hass = hass [EOL] self . _name = name [EOL] self . _variable = variable [EOL] self . _payload = payload [EOL] self . _on_value = on_value [EOL] self . _off_value = off_value [EOL] self . _reset_delay_sec = rst_dly_sec [EOL] self . _delay_after = None [EOL] self . _hass = hass [EOL] [EOL] hass . bus . listen ( pilight . EVENT , self . _handle_code ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def _reset_state ( self , call ) : [EOL] self . _state = False [EOL] self . _delay_after = None [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def _handle_code ( self , call ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] payload_ok = True [EOL] for key in self . _payload : [EOL] if key not in call . data : [EOL] payload_ok = False [EOL] continue [EOL] if self . _payload [ key ] != call . data [ key ] : [EOL] payload_ok = False [EOL] [comment] [EOL] if payload_ok : [EOL] if self . _variable not in call . data : [EOL] return [EOL] value = call . data [ self . _variable ] [EOL] self . _state = ( value == self . _on_value ) [EOL] if self . _delay_after is None : [EOL] self . _delay_after = dt_util . utcnow ( ) + datetime . timedelta ( seconds = self . _reset_delay_sec ) [EOL] track_point_in_time ( self . _hass , self . _reset_state , self . _delay_after ) [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from collections import deque [EOL] import logging [EOL] import math [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . binary_sensor import ( DEVICE_CLASSES_SCHEMA , ENTITY_ID_FORMAT , PLATFORM_SCHEMA , BinarySensorDevice ) [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_FRIENDLY_NAME , CONF_DEVICE_CLASS , CONF_ENTITY_ID , CONF_FRIENDLY_NAME , STATE_UNKNOWN ) [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import generate_entity_id [EOL] from homeassistant . helpers . event import async_track_state_change [EOL] from homeassistant . util import utcnow [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_ATTRIBUTE = [string] [EOL] ATTR_GRADIENT = [string] [EOL] ATTR_MIN_GRADIENT = [string] [EOL] ATTR_INVERT = [string] [EOL] ATTR_SAMPLE_DURATION = [string] [EOL] ATTR_SAMPLE_COUNT = [string] [EOL] [EOL] CONF_ATTRIBUTE = [string] [EOL] CONF_INVERT = [string] [EOL] CONF_MAX_SAMPLES = [string] [EOL] CONF_MIN_GRADIENT = [string] [EOL] CONF_SAMPLE_DURATION = [string] [EOL] CONF_SENSORS = [string] [EOL] [EOL] SENSOR_SCHEMA = vol . Schema ( { vol . Required ( CONF_ENTITY_ID ) : cv . entity_id , vol . Optional ( CONF_ATTRIBUTE ) : cv . string , vol . Optional ( CONF_DEVICE_CLASS ) : DEVICE_CLASSES_SCHEMA , vol . Optional ( CONF_FRIENDLY_NAME ) : cv . string , vol . Optional ( CONF_INVERT , default = False ) : cv . boolean , vol . Optional ( CONF_MAX_SAMPLES , default = [number] ) : cv . positive_int , vol . Optional ( CONF_MIN_GRADIENT , default = [number] ) : vol . Coerce ( float ) , vol . Optional ( CONF_SAMPLE_DURATION , default = [number] ) : cv . positive_int , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SENSORS ) : vol . Schema ( { cv . slug : SENSOR_SCHEMA } ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] sensors = [ ] [EOL] [EOL] for device_id , device_config in config [ CONF_SENSORS ] . items ( ) : [EOL] entity_id = device_config [ ATTR_ENTITY_ID ] [EOL] attribute = device_config . get ( CONF_ATTRIBUTE ) [EOL] device_class = device_config . get ( CONF_DEVICE_CLASS ) [EOL] friendly_name = device_config . get ( ATTR_FRIENDLY_NAME , device_id ) [EOL] invert = device_config [ CONF_INVERT ] [EOL] max_samples = device_config [ CONF_MAX_SAMPLES ] [EOL] min_gradient = device_config [ CONF_MIN_GRADIENT ] [EOL] sample_duration = device_config [ CONF_SAMPLE_DURATION ] [EOL] [EOL] sensors . append ( SensorTrend ( hass , device_id , friendly_name , entity_id , attribute , device_class , invert , max_samples , min_gradient , sample_duration ) ) [EOL] if not sensors : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] add_entities ( sensors ) [EOL] return True [EOL] [EOL] [EOL] class SensorTrend ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device_id , friendly_name , entity_id , attribute , device_class , invert , max_samples , min_gradient , sample_duration ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . entity_id = generate_entity_id ( ENTITY_ID_FORMAT , device_id , hass = hass ) [EOL] self . _name = friendly_name [EOL] self . _entity_id = entity_id [EOL] self . _attribute = attribute [EOL] self . _device_class = device_class [EOL] self . _invert = invert [EOL] self . _sample_duration = sample_duration [EOL] self . _min_gradient = min_gradient [EOL] self . _gradient = None [EOL] self . _state = None [EOL] self . samples = deque ( maxlen = max_samples ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ENTITY_ID : self . _entity_id , ATTR_FRIENDLY_NAME : self . _name , ATTR_GRADIENT : self . _gradient , ATTR_INVERT : self . _invert , ATTR_MIN_GRADIENT : self . _min_gradient , ATTR_SAMPLE_COUNT : len ( self . samples ) , ATTR_SAMPLE_DURATION : self . _sample_duration , } [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] @ callback def trend_sensor_state_listener ( entity , old_state , new_state ) : [EOL] [docstring] [EOL] try : [EOL] if self . _attribute : [EOL] state = new_state . attributes . get ( self . _attribute ) [EOL] else : [EOL] state = new_state . state [EOL] if state != STATE_UNKNOWN : [EOL] sample = ( utcnow ( ) . timestamp ( ) , float ( state ) ) [EOL] self . samples . append ( sample ) [EOL] self . async_schedule_update_ha_state ( True ) [EOL] except ( ValueError , TypeError ) as ex : [EOL] _LOGGER . error ( ex ) [EOL] [EOL] async_track_state_change ( self . hass , self . _entity_id , trend_sensor_state_listener ) [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _sample_duration > [number] : [EOL] cutoff = utcnow ( ) . timestamp ( ) - self . _sample_duration [EOL] while self . samples and self . samples [ [number] ] [ [number] ] < cutoff : [EOL] self . samples . popleft ( ) [EOL] [EOL] if len ( self . samples ) < [number] : [EOL] return [EOL] [EOL] [comment] [EOL] yield from self . hass . async_add_job ( self . _calculate_gradient ) [EOL] [EOL] [comment] [EOL] self . _state = ( abs ( self . _gradient ) > abs ( self . _min_gradient ) and math . copysign ( self . _gradient , self . _min_gradient ) == self . _gradient ) [EOL] [EOL] if self . _invert : [EOL] self . _state = not self . _state [EOL] [EOL] def _calculate_gradient ( self ) : [EOL] [docstring] [EOL] import numpy as np [EOL] timestamps = np . array ( [ t for t , _ in self . samples ] ) [EOL] values = np . array ( [ s for _ , s in self . samples ] ) [EOL] coeffs = np . polyfit ( timestamps , values , [number] ) [EOL] self . _gradient = coeffs [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . abode import AbodeDevice , DOMAIN as ABODE_DOMAIN [EOL] from homeassistant . components . cover import CoverDevice [EOL] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import abodepy . helpers . constants as CONST [EOL] [EOL] data = hass . data [ ABODE_DOMAIN ] [EOL] [EOL] devices = [ ] [EOL] for device in data . abode . get_devices ( generic_type = CONST . TYPE_COVER ) : [EOL] if data . is_excluded ( device ) : [EOL] continue [EOL] [EOL] devices . append ( AbodeCover ( data , device ) ) [EOL] [EOL] data . devices . extend ( devices ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class AbodeCover ( AbodeDevice , CoverDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] return not self . _device . is_open [EOL] [EOL] def close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _device . close_cover ( ) [EOL] [EOL] def open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _device . open_cover ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . rflink import ( DATA_ENTITY_GROUP_LOOKUP , DATA_ENTITY_LOOKUP , DEVICE_DEFAULTS_SCHEMA , EVENT_KEY_COMMAND , RflinkCommand ) [EOL] from homeassistant . components . cover import ( CoverDevice , PLATFORM_SCHEMA ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import CONF_NAME [EOL] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] CONF_ALIASES = [string] [EOL] CONF_GROUP_ALIASES = [string] [EOL] CONF_GROUP = [string] [EOL] CONF_NOGROUP_ALIASES = [string] [EOL] CONF_DEVICE_DEFAULTS = [string] [EOL] CONF_DEVICES = [string] [EOL] CONF_AUTOMATIC_ADD = [string] [EOL] CONF_FIRE_EVENT = [string] [EOL] CONF_IGNORE_DEVICES = [string] [EOL] CONF_RECONNECT_INTERVAL = [string] [EOL] CONF_SIGNAL_REPETITIONS = [string] [EOL] CONF_WAIT_FOR_ACK = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_DEVICE_DEFAULTS , default = DEVICE_DEFAULTS_SCHEMA ( { } ) ) : DEVICE_DEFAULTS_SCHEMA , vol . Optional ( CONF_DEVICES , default = { } ) : vol . Schema ( { cv . string : { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_ALIASES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_GROUP_ALIASES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_NOGROUP_ALIASES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_FIRE_EVENT , default = False ) : cv . boolean , vol . Optional ( CONF_SIGNAL_REPETITIONS ) : vol . Coerce ( int ) , vol . Optional ( CONF_GROUP , default = True ) : cv . boolean , } , } ) , } ) [EOL] [EOL] [EOL] def devices_from_config ( domain_config , hass = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] for device_id , config in domain_config [ CONF_DEVICES ] . items ( ) : [EOL] device_config = dict ( domain_config [ CONF_DEVICE_DEFAULTS ] , ** config ) [EOL] device = RflinkCover ( device_id , hass , ** device_config ) [EOL] devices . append ( device ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] hass . data [ DATA_ENTITY_LOOKUP ] [ EVENT_KEY_COMMAND ] [ device_id ] . append ( device ) [EOL] if config [ CONF_GROUP ] : [EOL] hass . data [ DATA_ENTITY_GROUP_LOOKUP ] [ EVENT_KEY_COMMAND ] [ device_id ] . append ( device ) [EOL] for _id in config [ CONF_ALIASES ] : [EOL] hass . data [ DATA_ENTITY_LOOKUP ] [ EVENT_KEY_COMMAND ] [ _id ] . append ( device ) [EOL] hass . data [ DATA_ENTITY_GROUP_LOOKUP ] [ EVENT_KEY_COMMAND ] [ _id ] . append ( device ) [EOL] return devices [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] async_add_entities ( devices_from_config ( config , hass ) ) [EOL] [EOL] [EOL] class RflinkCover ( RflinkCommand , CoverDevice ) : [EOL] [docstring] [EOL] [EOL] def _handle_event ( self , event ) : [EOL] [docstring] [EOL] self . cancel_queued_send_commands ( ) [EOL] [EOL] command = event [ [string] ] [EOL] if command in [ [string] , [string] ] : [EOL] self . _state = True [EOL] elif command in [ [string] , [string] ] : [EOL] self . _state = False [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def async_close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . _async_handle_command ( [string] ) [EOL] [EOL] def async_open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . _async_handle_command ( [string] ) [EOL] [EOL] def async_stop_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . _async_handle_command ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Dict , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import os [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] [EOL] from homeassistant . components . http import ( CONF_API_PASSWORD , CONF_SERVER_HOST , CONF_SERVER_PORT , CONF_SSL_CERTIFICATE ) [EOL] from homeassistant . const import CONF_TIME_ZONE , SERVER_PORT [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] X_HASSIO = [string] [EOL] [EOL] [EOL] def _api_bool ( funct ) : [EOL] [docstring] [EOL] async def _wrapper ( * argv , ** kwargs ) : [EOL] [docstring] [EOL] data = await funct ( * argv , ** kwargs ) [EOL] return data and data [ [string] ] == [string] [EOL] [EOL] return _wrapper [EOL] [EOL] [EOL] def _api_data ( funct ) : [EOL] [docstring] [EOL] async def _wrapper ( * argv , ** kwargs ) : [EOL] [docstring] [EOL] data = await funct ( * argv , ** kwargs ) [EOL] if data and data [ [string] ] == [string] : [EOL] return data [ [string] ] [EOL] return None [EOL] [EOL] return _wrapper [EOL] [EOL] [EOL] class HassIO : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , loop , websession , ip ) : [EOL] [docstring] [EOL] self . loop = loop [EOL] self . websession = websession [EOL] self . _ip = ip [EOL] [EOL] @ _api_bool def is_connected ( self ) : [EOL] [docstring] [EOL] return self . send_command ( [string] , method = [string] ) [EOL] [EOL] @ _api_data def get_homeassistant_info ( self ) : [EOL] [docstring] [EOL] return self . send_command ( [string] , method = [string] ) [EOL] [EOL] @ _api_bool def restart_homeassistant ( self ) : [EOL] [docstring] [EOL] return self . send_command ( [string] ) [EOL] [EOL] @ _api_bool def stop_homeassistant ( self ) : [EOL] [docstring] [EOL] return self . send_command ( [string] ) [EOL] [EOL] def check_homeassistant_config ( self ) : [EOL] [docstring] [EOL] return self . send_command ( [string] , timeout = [number] ) [EOL] [EOL] @ _api_bool async def update_hass_api ( self , http_config , refresh_token ) : [EOL] [docstring] [EOL] port = http_config . get ( CONF_SERVER_PORT ) or SERVER_PORT [EOL] options = { [string] : CONF_SSL_CERTIFICATE in http_config , [string] : port , [string] : http_config . get ( CONF_API_PASSWORD ) , [string] : True , [string] : refresh_token , } [EOL] [EOL] if CONF_SERVER_HOST in http_config : [EOL] options [ [string] ] = False [EOL] _LOGGER . warning ( [string] ) [EOL] [EOL] return await self . send_command ( [string] , payload = options ) [EOL] [EOL] @ _api_bool def update_hass_timezone ( self , core_config ) : [EOL] [docstring] [EOL] return self . send_command ( [string] , payload = { [string] : core_config . get ( CONF_TIME_ZONE ) } ) [EOL] [EOL] @ asyncio . coroutine def send_command ( self , command , method = [string] , payload = None , timeout = [number] ) : [EOL] [docstring] [EOL] try : [EOL] with async_timeout . timeout ( timeout , loop = self . loop ) : [EOL] request = yield from self . websession . request ( method , [string] . format ( self . _ip , command ) , json = payload , headers = { X_HASSIO : os . environ . get ( [string] , [string] ) } ) [EOL] [EOL] if request . status not in ( [number] , [number] ) : [EOL] _LOGGER . error ( [string] , command , request . status ) [EOL] return None [EOL] [EOL] answer = yield from request . json ( ) [EOL] return answer [EOL] [EOL] except asyncio . TimeoutError : [EOL] _LOGGER . error ( [string] , command ) [EOL] [EOL] except aiohttp . ClientError as err : [EOL] _LOGGER . error ( [string] , command , err ) [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import List , Tuple , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import time [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components import remote [EOL] from homeassistant . components . remote import ( ATTR_ACTIVITY , ATTR_DELAY_SECS , ATTR_DEVICE , ATTR_NUM_REPEATS , DEFAULT_DELAY_SECS , DOMAIN , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , CONF_HOST , CONF_NAME , CONF_PORT , EVENT_HOMEASSISTANT_STOP ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] from homeassistant . util import slugify [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_PORT = [number] [EOL] DEVICES = [ ] [EOL] CONF_DEVICE_CACHE = [string] [EOL] [EOL] SERVICE_SYNC = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( ATTR_ACTIVITY ) : cv . string , vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( ATTR_DELAY_SECS , default = DEFAULT_DELAY_SECS ) : vol . Coerce ( float ) , vol . Optional ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] HARMONY_SYNC_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] host = None [EOL] activity = None [EOL] [EOL] if CONF_DEVICE_CACHE not in hass . data : [EOL] hass . data [ CONF_DEVICE_CACHE ] = [ ] [EOL] [EOL] if discovery_info : [EOL] [comment] [EOL] override = next ( ( c for c in hass . data [ CONF_DEVICE_CACHE ] if c . get ( CONF_NAME ) == discovery_info . get ( CONF_NAME ) ) , False ) [EOL] [EOL] port = DEFAULT_PORT [EOL] delay_secs = DEFAULT_DELAY_SECS [EOL] if override : [EOL] activity = override . get ( ATTR_ACTIVITY ) [EOL] delay_secs = override . get ( ATTR_DELAY_SECS ) [EOL] port = override . get ( CONF_PORT , DEFAULT_PORT ) [EOL] [EOL] host = ( discovery_info . get ( CONF_NAME ) , discovery_info . get ( CONF_HOST ) , port ) [EOL] [EOL] [comment] [EOL] if host [ [number] : ] in ( ( h . host , h . port ) for h in DEVICES ) : [EOL] _LOGGER . debug ( [string] , host ) [EOL] return [EOL] elif CONF_HOST in config : [EOL] host = ( config . get ( CONF_NAME ) , config . get ( CONF_HOST ) , config . get ( CONF_PORT ) , ) [EOL] activity = config . get ( ATTR_ACTIVITY ) [EOL] delay_secs = config . get ( ATTR_DELAY_SECS ) [EOL] else : [EOL] hass . data [ CONF_DEVICE_CACHE ] . append ( config ) [EOL] return [EOL] [EOL] name , address , port = host [EOL] _LOGGER . info ( [string] , name , address , port , activity ) [EOL] [EOL] harmony_conf_file = hass . config . path ( [string] . format ( [string] , slugify ( name ) , [string] ) ) [EOL] try : [EOL] device = HarmonyRemote ( name , address , port , activity , harmony_conf_file , delay_secs ) [EOL] DEVICES . append ( device ) [EOL] add_entities ( [ device ] ) [EOL] register_services ( hass ) [EOL] except ( ValueError , AttributeError ) : [EOL] raise PlatformNotReady [EOL] [EOL] [EOL] def register_services ( hass ) : [EOL] [docstring] [EOL] hass . services . register ( DOMAIN , SERVICE_SYNC , _sync_service , schema = HARMONY_SYNC_SCHEMA ) [EOL] [EOL] [EOL] def _apply_service ( service , service_func , * service_func_args ) : [EOL] [docstring] [EOL] entity_ids = service . data . get ( [string] ) [EOL] [EOL] if entity_ids : [EOL] _devices = [ device for device in DEVICES if device . entity_id in entity_ids ] [EOL] else : [EOL] _devices = DEVICES [EOL] [EOL] for device in _devices : [EOL] service_func ( device , * service_func_args ) [EOL] device . schedule_update_ha_state ( True ) [EOL] [EOL] [EOL] def _sync_service ( service ) : [EOL] _apply_service ( service , HarmonyRemote . sync ) [EOL] [EOL] [EOL] class HarmonyRemote ( remote . RemoteDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , host , port , activity , out_path , delay_secs ) : [EOL] [docstring] [EOL] import pyharmony [EOL] from pathlib import Path [EOL] [EOL] _LOGGER . debug ( [string] , name ) [EOL] self . _name = name [EOL] self . host = host [EOL] self . port = port [EOL] self . _state = None [EOL] self . _current_activity = None [EOL] self . _default_activity = activity [EOL] self . _client = pyharmony . get_client ( host , port , self . new_activity ) [EOL] self . _config_path = out_path [EOL] self . _config = self . _client . get_config ( ) [EOL] if not Path ( self . _config_path ) . is_file ( ) : [EOL] _LOGGER . debug ( [string] , out_path ) [EOL] pyharmony . ha_write_config_file ( self . _config , self . _config_path ) [EOL] self . _delay_secs = delay_secs [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , lambda event : self . _client . disconnect ( wait = True ) ) [EOL] [EOL] [comment] [EOL] self . new_activity ( self . _client . get_current_activity ( ) ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _current_activity } [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _current_activity not in [ None , [string] ] [EOL] [EOL] def new_activity ( self , activity_id ) : [EOL] [docstring] [EOL] import pyharmony [EOL] activity_name = pyharmony . activity_name ( self . _config , activity_id ) [EOL] _LOGGER . debug ( [string] , self . _name , activity_name ) [EOL] self . _current_activity = activity_name [EOL] self . _state = bool ( self . _current_activity != [string] ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] import pyharmony [EOL] activity = kwargs . get ( ATTR_ACTIVITY , self . _default_activity ) [EOL] [EOL] if activity : [EOL] activity_id = pyharmony . activity_id ( self . _config , activity ) [EOL] self . _client . start_activity ( activity_id ) [EOL] self . _state = True [EOL] else : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _client . power_off ( ) [EOL] [EOL] [comment] [EOL] def send_command ( self , commands , ** kwargs ) : [EOL] [docstring] [EOL] device = kwargs . get ( ATTR_DEVICE ) [EOL] if device is None : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] num_repeats = kwargs . get ( ATTR_NUM_REPEATS ) [EOL] delay_secs = kwargs . get ( ATTR_DELAY_SECS , self . _delay_secs ) [EOL] [EOL] for _ in range ( num_repeats ) : [EOL] for command in commands : [EOL] self . _client . send_command ( device , command ) [EOL] time . sleep ( delay_secs ) [EOL] [EOL] def sync ( self ) : [EOL] [docstring] [EOL] import pyharmony [EOL] _LOGGER . debug ( [string] ) [EOL] self . _client . sync ( ) [EOL] self . _config = self . _client . get_config ( ) [EOL] _LOGGER . debug ( [string] , self . _config_path ) [EOL] pyharmony . ha_write_config_file ( self . _config , self . _config_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Generator , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . media_player import ( SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_SELECT_SOURCE , MediaPlayerDevice , PLATFORM_SCHEMA , MEDIA_TYPE_MUSIC ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PORT , STATE_OFF , STATE_ON , CONF_NAME , EVENT_HOMEASSISTANT_STOP ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_RUSSOUND = SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_SET | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = [number] ) : cv . port , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] from russound_rio import Russound [EOL] [EOL] russ = Russound ( hass . loop , host , port ) [EOL] [EOL] yield from russ . connect ( ) [EOL] [EOL] [comment] [EOL] sources = yield from russ . enumerate_sources ( ) [EOL] [EOL] [comment] [EOL] valid_zones = yield from russ . enumerate_zones ( ) [EOL] [EOL] devices = [ ] [EOL] for zone_id , name in valid_zones : [EOL] yield from russ . watch_zone ( zone_id ) [EOL] dev = RussoundZoneDevice ( russ , zone_id , name , sources ) [EOL] devices . append ( dev ) [EOL] [EOL] @ callback def on_stop ( event ) : [EOL] [docstring] [EOL] hass . loop . create_task ( russ . close ( ) ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , on_stop ) [EOL] [EOL] async_add_entities ( devices ) [EOL] [EOL] [EOL] class RussoundZoneDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , russ , zone_id , name , sources ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _name = name [EOL] self . _russ = russ [EOL] self . _zone_id = zone_id [EOL] self . _sources = sources [EOL] [EOL] def _zone_var ( self , name , default = None ) : [EOL] return self . _russ . get_cached_zone_variable ( self . _zone_id , name , default ) [EOL] [EOL] def _source_var ( self , name , default = None ) : [EOL] current = int ( self . _zone_var ( [string] , [number] ) ) [EOL] if current : [EOL] return self . _russ . get_cached_source_variable ( current , name , default ) [EOL] return default [EOL] [EOL] def _source_na_var ( self , name ) : [EOL] [docstring] [EOL] current = int ( self . _zone_var ( [string] , [number] ) ) [EOL] if current : [EOL] value = self . _russ . get_cached_source_variable ( current , name , None ) [EOL] if value in ( None , [string] , [string] ) : [EOL] return None [EOL] return value [EOL] return None [EOL] [EOL] def _zone_callback_handler ( self , zone_id , * args ) : [EOL] if zone_id == self . _zone_id : [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def _source_callback_handler ( self , source_id , * args ) : [EOL] current = int ( self . _zone_var ( [string] , [number] ) ) [EOL] if source_id == current : [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _russ . add_zone_callback ( self . _zone_callback_handler ) [EOL] self . _russ . add_source_callback ( self . _source_callback_handler ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _zone_var ( [string] , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] status = self . _zone_var ( [string] , [string] ) [EOL] if status == [string] : [EOL] return STATE_ON [EOL] if status == [string] : [EOL] return STATE_OFF [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_RUSSOUND [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _source_na_var ( [string] ) [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return [ x [ [number] ] for x in self . _sources ] [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_MUSIC [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _source_na_var ( [string] ) [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . _source_na_var ( [string] ) [EOL] [EOL] @ property def media_album_name ( self ) : [EOL] [docstring] [EOL] return self . _source_na_var ( [string] ) [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] return self . _source_na_var ( [string] ) [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return float ( self . _zone_var ( [string] , [number] ) ) / [number] [EOL] [EOL] def async_turn_off ( self ) : [EOL] [docstring] [EOL] return self . _russ . send_zone_event ( self . _zone_id , [string] ) [EOL] [EOL] def async_turn_on ( self ) : [EOL] [docstring] [EOL] return self . _russ . send_zone_event ( self . _zone_id , [string] ) [EOL] [EOL] def async_set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] rvol = int ( volume * [number] ) [EOL] return self . _russ . send_zone_event ( self . _zone_id , [string] , [string] , rvol ) [EOL] [EOL] def async_select_source ( self , source ) : [EOL] [docstring] [EOL] for source_id , name in self . _sources : [EOL] if name . lower ( ) != source . lower ( ) : [EOL] continue [EOL] return self . _russ . send_zone_event ( self . _zone_id , [string] , source_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] [EOL] STEPS = [ STEP_USER ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0
from typing import List , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . components . alarm_control_panel as alarm [EOL] from homeassistant . components . alarmdecoder import DATA_AD , SIGNAL_PANEL_MESSAGE [EOL] from homeassistant . const import ( ATTR_CODE , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_ALARM_TRIGGERED ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SERVICE_ALARM_TOGGLE_CHIME = [string] [EOL] ALARM_TOGGLE_CHIME_SCHEMA = vol . Schema ( { vol . Required ( ATTR_CODE ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] device = AlarmDecoderAlarmPanel ( ) [EOL] add_entities ( [ device ] ) [EOL] [EOL] def alarm_toggle_chime_handler ( service ) : [EOL] [docstring] [EOL] code = service . data . get ( ATTR_CODE ) [EOL] device . alarm_toggle_chime ( code ) [EOL] [EOL] hass . services . register ( alarm . DOMAIN , SERVICE_ALARM_TOGGLE_CHIME , alarm_toggle_chime_handler , schema = ALARM_TOGGLE_CHIME_SCHEMA ) [EOL] [EOL] [EOL] class AlarmDecoderAlarmPanel ( alarm . AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _display = [string] [EOL] self . _name = [string] [EOL] self . _state = None [EOL] self . _ac_power = None [EOL] self . _backlight_on = None [EOL] self . _battery_low = None [EOL] self . _check_zone = None [EOL] self . _chime = None [EOL] self . _entry_delay_off = None [EOL] self . _programming_mode = None [EOL] self . _ready = None [EOL] self . _zone_bypassed = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( SIGNAL_PANEL_MESSAGE , self . _message_callback ) [EOL] [EOL] def _message_callback ( self , message ) : [EOL] [docstring] [EOL] if message . alarm_sounding or message . fire_alarm : [EOL] self . _state = STATE_ALARM_TRIGGERED [EOL] elif message . armed_away : [EOL] self . _state = STATE_ALARM_ARMED_AWAY [EOL] elif message . armed_home : [EOL] self . _state = STATE_ALARM_ARMED_HOME [EOL] else : [EOL] self . _state = STATE_ALARM_DISARMED [EOL] [EOL] self . _ac_power = message . ac_power [EOL] self . _backlight_on = message . backlight_on [EOL] self . _battery_low = message . battery_low [EOL] self . _check_zone = message . check_zone [EOL] self . _chime = message . chime_on [EOL] self . _entry_delay_off = message . entry_delay_off [EOL] self . _programming_mode = message . programming_mode [EOL] self . _ready = message . ready [EOL] self . _zone_bypassed = message . zone_bypassed [EOL] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def code_format ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _ac_power , [string] : self . _backlight_on , [string] : self . _battery_low , [string] : self . _check_zone , [string] : self . _chime , [string] : self . _entry_delay_off , [string] : self . _programming_mode , [string] : self . _ready , [string] : self . _zone_bypassed , } [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_AD ] . send ( [string] . format ( code ) ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_AD ] . send ( [string] . format ( code ) ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_AD ] . send ( [string] . format ( code ) ) [EOL] [EOL] def alarm_toggle_chime ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_AD ] . send ( [string] . format ( code ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import re [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . components . alarm_control_panel as alarm [EOL] from homeassistant . components . alarm_control_panel import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_CODE , CONF_NAME , CONF_PASSWORD , CONF_USERNAME , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_UNKNOWN ) [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_CODE ) : cv . positive_int , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] code = config . get ( CONF_CODE ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] alarmdotcom = AlarmDotCom ( hass , name , code , username , password ) [EOL] yield from alarmdotcom . async_login ( ) [EOL] async_add_entities ( [ alarmdotcom ] ) [EOL] [EOL] [EOL] class AlarmDotCom ( alarm . AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , code , username , password ) : [EOL] [docstring] [EOL] from pyalarmdotcom import Alarmdotcom [EOL] _LOGGER . debug ( [string] ) [EOL] self . _hass = hass [EOL] self . _name = name [EOL] self . _code = str ( code ) if code else None [EOL] self . _username = username [EOL] self . _password = password [EOL] self . _websession = async_get_clientsession ( self . _hass ) [EOL] self . _state = STATE_UNKNOWN [EOL] self . _alarm = Alarmdotcom ( username , password , self . _websession , hass . loop ) [EOL] [EOL] @ asyncio . coroutine def async_login ( self ) : [EOL] [docstring] [EOL] yield from self . _alarm . async_login ( ) [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] yield from self . _alarm . async_update ( ) [EOL] return self . _alarm . state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def code_format ( self ) : [EOL] [docstring] [EOL] if self . _code is None : [EOL] return None [EOL] if isinstance ( self . _code , str ) and re . search ( [string] , self . _code ) : [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _alarm . state . lower ( ) == [string] : [EOL] return STATE_ALARM_DISARMED [EOL] if self . _alarm . state . lower ( ) == [string] : [EOL] return STATE_ALARM_ARMED_HOME [EOL] if self . _alarm . state . lower ( ) == [string] : [EOL] return STATE_ALARM_ARMED_AWAY [EOL] return STATE_UNKNOWN [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _alarm . sensor_status } [EOL] [EOL] @ asyncio . coroutine def async_alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] if self . _validate_code ( code ) : [EOL] yield from self . _alarm . async_alarm_disarm ( ) [EOL] [EOL] @ asyncio . coroutine def async_alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] if self . _validate_code ( code ) : [EOL] yield from self . _alarm . async_alarm_arm_home ( ) [EOL] [EOL] @ asyncio . coroutine def async_alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] if self . _validate_code ( code ) : [EOL] yield from self . _alarm . async_alarm_arm_away ( ) [EOL] [EOL] def _validate_code ( self , code ) : [EOL] [docstring] [EOL] check = self . _code is None or code == self . _code [EOL] if not check : [EOL] _LOGGER . warning ( [string] ) [EOL] return check [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0
import builtins [EOL] from typing import List , Dict , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import re [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . components . alarm_control_panel as alarm [EOL] from homeassistant . components . alarm_control_panel import ( DOMAIN , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . ifttt import ( ATTR_EVENT , DOMAIN as IFTTT_DOMAIN , SERVICE_TRIGGER ) [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_STATE , CONF_NAME , CONF_CODE , CONF_OPTIMISTIC , STATE_ALARM_DISARMED , STATE_ALARM_ARMED_NIGHT , STATE_ALARM_ARMED_HOME , STATE_ALARM_ARMED_AWAY ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ALLOWED_STATES = [ STATE_ALARM_DISARMED , STATE_ALARM_ARMED_NIGHT , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME ] [EOL] [EOL] DATA_IFTTT_ALARM = [string] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] CONF_EVENT_AWAY = [string] [EOL] CONF_EVENT_HOME = [string] [EOL] CONF_EVENT_NIGHT = [string] [EOL] CONF_EVENT_DISARM = [string] [EOL] [EOL] DEFAULT_EVENT_AWAY = [string] [EOL] DEFAULT_EVENT_HOME = [string] [EOL] DEFAULT_EVENT_NIGHT = [string] [EOL] DEFAULT_EVENT_DISARM = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_CODE ) : cv . string , vol . Optional ( CONF_EVENT_AWAY , default = DEFAULT_EVENT_AWAY ) : cv . string , vol . Optional ( CONF_EVENT_HOME , default = DEFAULT_EVENT_HOME ) : cv . string , vol . Optional ( CONF_EVENT_NIGHT , default = DEFAULT_EVENT_NIGHT ) : cv . string , vol . Optional ( CONF_EVENT_DISARM , default = DEFAULT_EVENT_DISARM ) : cv . string , vol . Optional ( CONF_OPTIMISTIC , default = False ) : cv . boolean , } ) [EOL] [EOL] SERVICE_PUSH_ALARM_STATE = [string] [EOL] [EOL] PUSH_ALARM_STATE_SERVICE_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_STATE ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if DATA_IFTTT_ALARM not in hass . data : [EOL] hass . data [ DATA_IFTTT_ALARM ] = [ ] [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] code = config . get ( CONF_CODE ) [EOL] event_away = config . get ( CONF_EVENT_AWAY ) [EOL] event_home = config . get ( CONF_EVENT_HOME ) [EOL] event_night = config . get ( CONF_EVENT_NIGHT ) [EOL] event_disarm = config . get ( CONF_EVENT_DISARM ) [EOL] optimistic = config . get ( CONF_OPTIMISTIC ) [EOL] [EOL] alarmpanel = IFTTTAlarmPanel ( name , code , event_away , event_home , event_night , event_disarm , optimistic ) [EOL] hass . data [ DATA_IFTTT_ALARM ] . append ( alarmpanel ) [EOL] add_entities ( [ alarmpanel ] ) [EOL] [EOL] async def push_state_update ( service ) : [EOL] [docstring] [EOL] entity_ids = service . data . get ( ATTR_ENTITY_ID ) [EOL] state = service . data . get ( ATTR_STATE ) [EOL] devices = hass . data [ DATA_IFTTT_ALARM ] [EOL] if entity_ids : [EOL] devices = [ d for d in devices if d . entity_id in entity_ids ] [EOL] [EOL] for device in devices : [EOL] device . push_alarm_state ( state ) [EOL] device . async_schedule_update_ha_state ( ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_PUSH_ALARM_STATE , push_state_update , schema = PUSH_ALARM_STATE_SERVICE_SCHEMA ) [EOL] [EOL] [EOL] class IFTTTAlarmPanel ( alarm . AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , code , event_away , event_home , event_night , event_disarm , optimistic ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _code = code [EOL] self . _event_away = event_away [EOL] self . _event_home = event_home [EOL] self . _event_night = event_night [EOL] self . _event_disarm = event_disarm [EOL] self . _optimistic = optimistic [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def code_format ( self ) : [EOL] [docstring] [EOL] if self . _code is None : [EOL] return None [EOL] if isinstance ( self . _code , str ) and re . search ( [string] , self . _code ) : [EOL] return [string] [EOL] return [string] [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _check_code ( code ) : [EOL] return [EOL] self . set_alarm_state ( self . _event_disarm , STATE_ALARM_DISARMED ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _check_code ( code ) : [EOL] return [EOL] self . set_alarm_state ( self . _event_away , STATE_ALARM_ARMED_AWAY ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _check_code ( code ) : [EOL] return [EOL] self . set_alarm_state ( self . _event_home , STATE_ALARM_ARMED_HOME ) [EOL] [EOL] def alarm_arm_night ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _check_code ( code ) : [EOL] return [EOL] self . set_alarm_state ( self . _event_night , STATE_ALARM_ARMED_NIGHT ) [EOL] [EOL] def set_alarm_state ( self , event , state ) : [EOL] [docstring] [EOL] data = { ATTR_EVENT : event } [EOL] [EOL] self . hass . services . call ( IFTTT_DOMAIN , SERVICE_TRIGGER , data ) [EOL] _LOGGER . debug ( [string] , event ) [EOL] if self . _optimistic : [EOL] self . _state = state [EOL] [EOL] def push_alarm_state ( self , value ) : [EOL] [docstring] [EOL] if value in ALLOWED_STATES : [EOL] _LOGGER . debug ( [string] , value ) [EOL] self . _state = value [EOL] [EOL] def _check_code ( self , code ) : [EOL] return self . _code is None or self . _code == code [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import mimetypes [EOL] import os [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . components . camera import ( Camera , CAMERA_SERVICE_SCHEMA , DOMAIN , PLATFORM_SCHEMA ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_FILE_PATH = [string] [EOL] DEFAULT_NAME = [string] [EOL] SERVICE_UPDATE_FILE_PATH = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_FILE_PATH ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string } ) [EOL] [EOL] CAMERA_SERVICE_UPDATE_FILE_PATH = CAMERA_SERVICE_SCHEMA . extend ( { vol . Required ( CONF_FILE_PATH ) : cv . string } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] file_path = config [ CONF_FILE_PATH ] [EOL] camera = LocalFile ( config [ CONF_NAME ] , file_path ) [EOL] [EOL] def update_file_path_service ( call ) : [EOL] [docstring] [EOL] file_path = call . data . get ( CONF_FILE_PATH ) [EOL] camera . update_file_path ( file_path ) [EOL] return True [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_UPDATE_FILE_PATH , update_file_path_service , schema = CAMERA_SERVICE_UPDATE_FILE_PATH ) [EOL] [EOL] add_entities ( [ camera ] ) [EOL] [EOL] [EOL] class LocalFile ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , file_path ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _name = name [EOL] self . check_file_path_access ( file_path ) [EOL] self . _file_path = file_path [EOL] [comment] [EOL] content , _ = mimetypes . guess_type ( file_path ) [EOL] if content is not None : [EOL] self . content_type = content [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] try : [EOL] with open ( self . _file_path , [string] ) as file : [EOL] return file . read ( ) [EOL] except FileNotFoundError : [EOL] _LOGGER . warning ( [string] , self . _name , self . _file_path ) [EOL] [EOL] def check_file_path_access ( self , file_path ) : [EOL] [docstring] [EOL] if not os . access ( file_path , os . R_OK ) : [EOL] _LOGGER . warning ( [string] , self . _name , file_path ) [EOL] [EOL] def update_file_path ( self , file_path ) : [EOL] [docstring] [EOL] self . check_file_path_access ( file_path ) [EOL] self . _file_path = file_path [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _file_path , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any [EOL] import logging [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from contextlib import closing [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] import requests [EOL] from requests . auth import HTTPBasicAuth , HTTPDigestAuth [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_USERNAME , CONF_PASSWORD , CONF_AUTHENTICATION , HTTP_BASIC_AUTHENTICATION , HTTP_DIGEST_AUTHENTICATION ) [EOL] from homeassistant . components . camera import ( PLATFORM_SCHEMA , Camera ) [EOL] from homeassistant . helpers . aiohttp_client import ( async_get_clientsession , async_aiohttp_proxy_web ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_MJPEG_URL = [string] [EOL] CONF_STILL_IMAGE_URL = [string] [EOL] CONTENT_TYPE_HEADER = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MJPEG_URL ) : cv . url , vol . Optional ( CONF_STILL_IMAGE_URL ) : cv . url , vol . Optional ( CONF_AUTHENTICATION , default = HTTP_BASIC_AUTHENTICATION ) : vol . In ( [ HTTP_BASIC_AUTHENTICATION , HTTP_DIGEST_AUTHENTICATION ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_USERNAME ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info : [EOL] config = PLATFORM_SCHEMA ( discovery_info ) [EOL] async_add_entities ( [ MjpegCamera ( hass , config ) ] ) [EOL] [EOL] [EOL] def extract_image_from_mjpeg ( stream ) : [EOL] [docstring] [EOL] data = [string] [EOL] for chunk in stream : [EOL] data += chunk [EOL] jpg_start = data . find ( [string] ) [EOL] jpg_end = data . find ( [string] ) [EOL] if jpg_start != - [number] and jpg_end != - [number] : [EOL] jpg = data [ jpg_start : jpg_end + [number] ] [EOL] return jpg [EOL] [EOL] [EOL] class MjpegCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device_info ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _name = device_info . get ( CONF_NAME ) [EOL] self . _authentication = device_info . get ( CONF_AUTHENTICATION ) [EOL] self . _username = device_info . get ( CONF_USERNAME ) [EOL] self . _password = device_info . get ( CONF_PASSWORD ) [EOL] self . _mjpeg_url = device_info [ CONF_MJPEG_URL ] [EOL] self . _still_image_url = device_info . get ( CONF_STILL_IMAGE_URL ) [EOL] [EOL] self . _auth = None [EOL] if self . _username and self . _password : [EOL] if self . _authentication == HTTP_BASIC_AUTHENTICATION : [EOL] self . _auth = aiohttp . BasicAuth ( self . _username , password = self . _password ) [EOL] [EOL] @ asyncio . coroutine def async_camera_image ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _authentication == HTTP_DIGEST_AUTHENTICATION or self . _still_image_url is None : [EOL] image = yield from self . hass . async_add_job ( self . camera_image ) [EOL] return image [EOL] [EOL] websession = async_get_clientsession ( self . hass ) [EOL] try : [EOL] with async_timeout . timeout ( [number] , loop = self . hass . loop ) : [EOL] response = yield from websession . get ( self . _still_image_url , auth = self . _auth ) [EOL] [EOL] image = yield from response . read ( ) [EOL] return image [EOL] [EOL] except asyncio . TimeoutError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] except aiohttp . ClientError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] if self . _username and self . _password : [EOL] if self . _authentication == HTTP_DIGEST_AUTHENTICATION : [EOL] auth = HTTPDigestAuth ( self . _username , self . _password ) [EOL] else : [EOL] auth = HTTPBasicAuth ( self . _username , self . _password ) [EOL] req = requests . get ( self . _mjpeg_url , auth = auth , stream = True , timeout = [number] ) [EOL] else : [EOL] req = requests . get ( self . _mjpeg_url , stream = True , timeout = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with closing ( req ) as response : [EOL] return extract_image_from_mjpeg ( response . iter_content ( [number] ) ) [EOL] [EOL] async def handle_async_mjpeg_stream ( self , request ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _authentication == HTTP_DIGEST_AUTHENTICATION : [EOL] await super ( ) . handle_async_mjpeg_stream ( request ) [EOL] return [EOL] [EOL] [comment] [EOL] websession = async_get_clientsession ( self . hass ) [EOL] stream_coro = websession . get ( self . _mjpeg_url , auth = self . _auth ) [EOL] [EOL] return await async_aiohttp_proxy_web ( self . hass , request , stream_coro ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.auth.HTTPBasicAuth$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.auth.HTTPBasicAuth$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $requests.auth.HTTPBasicAuth$ 0 $requests.auth.HTTPBasicAuth$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from collections import deque [EOL] from datetime import timedelta [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . camera import Camera , PLATFORM_SCHEMA , STATE_IDLE , STATE_RECORDING [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . http . view import HomeAssistantView [EOL] from homeassistant . const import CONF_NAME , CONF_TIMEOUT , HTTP_BAD_REQUEST [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . event import async_track_point_in_utc_time [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_BUFFER_SIZE = [string] [EOL] CONF_IMAGE_FIELD = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] ATTR_FILENAME = [string] [EOL] ATTR_LAST_TRIP = [string] [EOL] [EOL] PUSH_CAMERA_DATA = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_BUFFER_SIZE , default = [number] ) : cv . positive_int , vol . Optional ( CONF_TIMEOUT , default = timedelta ( seconds = [number] ) ) : vol . All ( cv . time_period , cv . positive_timedelta ) , vol . Optional ( CONF_IMAGE_FIELD , default = [string] ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if PUSH_CAMERA_DATA not in hass . data : [EOL] hass . data [ PUSH_CAMERA_DATA ] = { } [EOL] [EOL] cameras = [ PushCamera ( config [ CONF_NAME ] , config [ CONF_BUFFER_SIZE ] , config [ CONF_TIMEOUT ] ) ] [EOL] [EOL] hass . http . register_view ( CameraPushReceiver ( hass , config [ CONF_IMAGE_FIELD ] ) ) [EOL] [EOL] async_add_entities ( cameras ) [EOL] [EOL] [EOL] class CameraPushReceiver ( HomeAssistantView ) : [EOL] [docstring] [EOL] [EOL] url = [string] [EOL] name = [string] [EOL] [EOL] def __init__ ( self , hass , image_field ) : [EOL] [docstring] [EOL] self . _cameras = hass . data [ PUSH_CAMERA_DATA ] [EOL] self . _image = image_field [EOL] [EOL] async def post ( self , request , entity_id ) : [EOL] [docstring] [EOL] _camera = self . _cameras . get ( entity_id ) [EOL] [EOL] if _camera is None : [EOL] _LOGGER . error ( [string] , entity_id ) [EOL] return self . json_message ( [string] . format ( entity_id ) , HTTP_BAD_REQUEST ) [EOL] [EOL] try : [EOL] data = await request . post ( ) [EOL] _LOGGER . debug ( [string] , data [ self . _image ] ) [EOL] await _camera . update_image ( data [ self . _image ] . file . read ( ) , data [ self . _image ] . filename ) [EOL] except ValueError as value_error : [EOL] _LOGGER . error ( [string] , value_error ) [EOL] return self . json_message ( [string] , HTTP_BAD_REQUEST ) [EOL] except KeyError as key_error : [EOL] _LOGGER . error ( [string] , key_error ) [EOL] return self . json_message ( [string] . format ( self . _image ) , HTTP_BAD_REQUEST ) [EOL] [EOL] [EOL] class PushCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , buffer_size , timeout ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _name = name [EOL] self . _last_trip = None [EOL] self . _filename = None [EOL] self . _expired_listener = None [EOL] self . _state = STATE_IDLE [EOL] self . _timeout = timeout [EOL] self . queue = deque ( [ ] , buffer_size ) [EOL] self . _current_image = None [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . data [ PUSH_CAMERA_DATA ] [ self . entity_id ] = self [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] async def update_image ( self , image , filename ) : [EOL] [docstring] [EOL] if self . _state == STATE_IDLE : [EOL] self . _state = STATE_RECORDING [EOL] self . _last_trip = dt_util . utcnow ( ) [EOL] self . queue . clear ( ) [EOL] [EOL] self . _filename = filename [EOL] self . queue . appendleft ( image ) [EOL] [EOL] @ callback def reset_state ( now ) : [EOL] [docstring] [EOL] self . _state = STATE_IDLE [EOL] self . _expired_listener = None [EOL] _LOGGER . debug ( [string] ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] if self . _expired_listener : [EOL] self . _expired_listener ( ) [EOL] [EOL] self . _expired_listener = async_track_point_in_utc_time ( self . hass , reset_state , dt_util . utcnow ( ) + self . _timeout ) [EOL] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] async def async_camera_image ( self ) : [EOL] [docstring] [EOL] if self . queue : [EOL] if self . _state == STATE_IDLE : [EOL] self . queue . rotate ( [number] ) [EOL] self . _current_image = self . queue [ [number] ] [EOL] [EOL] return self . _current_image [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def motion_detection_enabled ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { name : value for name , value in ( ( ATTR_LAST_TRIP , self . _last_trip ) , ( ATTR_FILENAME , self . _filename ) , ) if value is not None } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import requests [EOL] [EOL] from homeassistant . components . camera import Camera [EOL] from homeassistant . components . skybell import ( DOMAIN as SKYBELL_DOMAIN , SkybellDevice ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] skybell = hass . data . get ( SKYBELL_DOMAIN ) [EOL] [EOL] sensors = [ ] [EOL] for device in skybell . get_devices ( ) : [EOL] sensors . append ( SkybellCamera ( device ) ) [EOL] [EOL] add_entities ( sensors , True ) [EOL] [EOL] [EOL] class SkybellCamera ( SkybellDevice , Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] SkybellDevice . __init__ ( self , device ) [EOL] Camera . __init__ ( self ) [EOL] self . _name = self . _device . name [EOL] self . _url = None [EOL] self . _response = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] super ( ) . update ( ) [EOL] [EOL] if self . _url != self . _device . image : [EOL] self . _url = self . _device . image [EOL] [EOL] try : [EOL] self . _response = requests . get ( self . _url , stream = True , timeout = [number] ) [EOL] except requests . HTTPError as err : [EOL] _LOGGER . warning ( [string] , err ) [EOL] self . _response = None [EOL] [EOL] if not self . _response : [EOL] return None [EOL] [EOL] return self . _response . content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import asyncio [EOL] [EOL] import voluptuous as vol [EOL] import async_timeout [EOL] import aiohttp [EOL] [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import CONF_PASSWORD , CONF_USERNAME , CONF_TOKEN [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] HOOK_ENDPOINT = [string] [EOL] TIMEOUT = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Exclusive ( CONF_PASSWORD , [string] , msg = [string] + [string] ) : cv . string , vol . Exclusive ( CONF_TOKEN , [string] , msg = [string] + [string] ) : cv . string , vol . Inclusive ( CONF_USERNAME , [string] ) : cv . string , vol . Inclusive ( CONF_PASSWORD , [string] ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] token = config . get ( CONF_TOKEN ) [EOL] websession = async_get_clientsession ( hass ) [EOL] [comment] [EOL] if username is not None and password is not None : [EOL] try : [EOL] with async_timeout . timeout ( TIMEOUT , loop = hass . loop ) : [EOL] response = yield from websession . post ( [string] . format ( HOOK_ENDPOINT , [string] ) , data = { [string] : username , [string] : password } ) [EOL] [comment] [EOL] [comment] [EOL] data = yield from response . json ( content_type = None ) [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] return False [EOL] [EOL] try : [EOL] token = data [ [string] ] [ [string] ] [EOL] except KeyError : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] try : [EOL] with async_timeout . timeout ( TIMEOUT , loop = hass . loop ) : [EOL] response = yield from websession . get ( [string] . format ( HOOK_ENDPOINT , [string] ) , params = { [string] : token } ) [EOL] data = yield from response . json ( content_type = None ) [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] return False [EOL] [EOL] async_add_entities ( HookSmartHome ( hass , token , d [ [string] ] , d [ [string] ] ) for lst in data [ [string] ] for d in lst ) [EOL] [EOL] [EOL] class HookSmartHome ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , token , device_id , device_name ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _token = token [EOL] self . _state = False [EOL] self . _id = device_id [EOL] self . _name = device_name [EOL] _LOGGER . debug ( [string] , self . _id , self . _name ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ asyncio . coroutine def _send ( self , url ) : [EOL] [docstring] [EOL] try : [EOL] _LOGGER . debug ( [string] , url ) [EOL] websession = async_get_clientsession ( self . hass ) [EOL] with async_timeout . timeout ( TIMEOUT , loop = self . hass . loop ) : [EOL] response = yield from websession . get ( url , params = { [string] : self . _token } ) [EOL] data = yield from response . json ( content_type = None ) [EOL] [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] return False [EOL] [EOL] _LOGGER . debug ( [string] , data ) [EOL] return data [ [string] ] == [string] [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] url = [string] . format ( HOOK_ENDPOINT , [string] , self . _id , [string] ) [EOL] success = yield from self . _send ( url ) [EOL] self . _state = success [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] url = [string] . format ( HOOK_ENDPOINT , [string] , self . _id , [string] ) [EOL] success = yield from self . _send ( url ) [EOL] [comment] [EOL] self . _state = not success [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Generator[typing.Any,None,None]$ 0
from typing import List , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components import scsgate [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_STATE , CONF_NAME , CONF_DEVICES ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] ATTR_SCENARIO_ID = [string] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_TRADITIONAL = [string] [EOL] CONF_SCENARIO = [string] [EOL] [EOL] CONF_SCS_ID = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DEVICES ) : vol . Schema ( { cv . slug : scsgate . SCSGATE_SCHEMA } ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] _setup_traditional_switches ( logger = logger , config = config , add_entities_callback = add_entities ) [EOL] [EOL] _setup_scenario_switches ( logger = logger , config = config , hass = hass ) [EOL] [EOL] [EOL] def _setup_traditional_switches ( logger , config , add_entities_callback ) : [EOL] [docstring] [EOL] traditional = config . get ( CONF_TRADITIONAL ) [EOL] switches = [ ] [EOL] [EOL] if traditional : [EOL] for _ , entity_info in traditional . items ( ) : [EOL] if entity_info [ scsgate . CONF_SCS_ID ] in scsgate . SCSGATE . devices : [EOL] continue [EOL] [EOL] name = entity_info [ CONF_NAME ] [EOL] scs_id = entity_info [ scsgate . CONF_SCS_ID ] [EOL] [EOL] logger . info ( [string] , name ) [EOL] [EOL] switch = SCSGateSwitch ( name = name , scs_id = scs_id , logger = logger ) [EOL] switches . append ( switch ) [EOL] [EOL] add_entities_callback ( switches ) [EOL] scsgate . SCSGATE . add_devices_to_register ( switches ) [EOL] [EOL] [EOL] def _setup_scenario_switches ( logger , config , hass ) : [EOL] [docstring] [EOL] scenario = config . get ( CONF_SCENARIO ) [EOL] [EOL] if scenario : [EOL] for _ , entity_info in scenario . items ( ) : [EOL] if entity_info [ scsgate . CONF_SCS_ID ] in scsgate . SCSGATE . devices : [EOL] continue [EOL] [EOL] name = entity_info [ CONF_NAME ] [EOL] scs_id = entity_info [ scsgate . CONF_SCS_ID ] [EOL] [EOL] logger . info ( [string] , name ) [EOL] [EOL] switch = SCSGateScenarioSwitch ( name = name , scs_id = scs_id , logger = logger , hass = hass ) [EOL] scsgate . SCSGATE . add_device ( switch ) [EOL] [EOL] [EOL] class SCSGateSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , scs_id , name , logger ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _scs_id = scs_id [EOL] self . _toggled = False [EOL] self . _logger = logger [EOL] [EOL] @ property def scs_id ( self ) : [EOL] [docstring] [EOL] return self . _scs_id [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _toggled [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] from scsgate . tasks import ToggleStatusTask [EOL] [EOL] scsgate . SCSGATE . append_task ( ToggleStatusTask ( target = self . _scs_id , toggled = True ) ) [EOL] [EOL] self . _toggled = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] from scsgate . tasks import ToggleStatusTask [EOL] [EOL] scsgate . SCSGATE . append_task ( ToggleStatusTask ( target = self . _scs_id , toggled = False ) ) [EOL] [EOL] self . _toggled = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def process_event ( self , message ) : [EOL] [docstring] [EOL] if self . _toggled == message . toggled : [EOL] self . _logger . info ( [string] , self . _scs_id , message ) [EOL] [comment] [EOL] return [EOL] [EOL] self . _toggled = message . toggled [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] command = [string] [EOL] if self . _toggled : [EOL] command = [string] [EOL] [EOL] self . hass . bus . fire ( [string] , { ATTR_ENTITY_ID : self . _scs_id , ATTR_STATE : command } ) [EOL] [EOL] [EOL] class SCSGateScenarioSwitch : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , scs_id , name , logger , hass ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _scs_id = scs_id [EOL] self . _logger = logger [EOL] self . _hass = hass [EOL] [EOL] @ property def scs_id ( self ) : [EOL] [docstring] [EOL] return self . _scs_id [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def process_event ( self , message ) : [EOL] [docstring] [EOL] from scsgate . messages import StateMessage , ScenarioTriggeredMessage [EOL] [EOL] if isinstance ( message , StateMessage ) : [EOL] scenario_id = message . bytes [ [number] ] [EOL] elif isinstance ( message , ScenarioTriggeredMessage ) : [EOL] scenario_id = message . scenario [EOL] else : [EOL] self . _logger . warn ( [string] , message ) [EOL] return [EOL] [EOL] self . _hass . bus . fire ( [string] , { ATTR_ENTITY_ID : int ( self . _scs_id ) , ATTR_SCENARIO_ID : int ( scenario_id , [number] ) } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Dict , Any [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . loader import bind_hass [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] from homeassistant . helpers . config_validation import PLATFORM_SCHEMA [comment] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( STATE_ON , SERVICE_TURN_ON , SERVICE_TURN_OFF , SERVICE_TOGGLE , ATTR_ENTITY_ID ) [EOL] from homeassistant . components import group [EOL] [EOL] DOMAIN = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] GROUP_NAME_ALL_SWITCHES = [string] [EOL] ENTITY_ID_ALL_SWITCHES = group . ENTITY_ID_FORMAT . format ( [string] ) [EOL] [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] ATTR_TODAY_ENERGY_KWH = [string] [EOL] ATTR_CURRENT_POWER_W = [string] [EOL] [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] PROP_TO_ATTR = { [string] : ATTR_CURRENT_POWER_W , [string] : ATTR_TODAY_ENERGY_KWH , } [EOL] [EOL] SWITCH_SERVICE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ bind_hass def is_on ( hass , entity_id = None ) : [EOL] [docstring] [EOL] entity_id = entity_id or ENTITY_ID_ALL_SWITCHES [EOL] return hass . states . is_state ( entity_id , STATE_ON ) [EOL] [EOL] [EOL] @ bind_hass def turn_on ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_turn_on , hass , entity_id ) [EOL] [EOL] [EOL] @ callback @ bind_hass def async_turn_on ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_ON , data ) ) [EOL] [EOL] [EOL] @ bind_hass def turn_off ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_turn_off , hass , entity_id ) [EOL] [EOL] [EOL] @ callback @ bind_hass def async_turn_off ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_OFF , data ) ) [EOL] [EOL] [EOL] @ bind_hass def toggle ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] hass . services . call ( DOMAIN , SERVICE_TOGGLE , data ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = hass . data [ DOMAIN ] = EntityComponent ( _LOGGER , DOMAIN , hass , SCAN_INTERVAL , GROUP_NAME_ALL_SWITCHES ) [EOL] await component . async_setup ( config ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_TURN_OFF , SWITCH_SERVICE_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_TURN_ON , SWITCH_SERVICE_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_TOGGLE , SWITCH_SERVICE_SCHEMA , [string] ) [EOL] [EOL] return True [EOL] [EOL] [EOL] async def async_setup_entry ( hass , entry ) : [EOL] [docstring] [EOL] return await hass . data [ DOMAIN ] . async_setup_entry ( entry ) [EOL] [EOL] [EOL] async def async_unload_entry ( hass , entry ) : [EOL] [docstring] [EOL] return await hass . data [ DOMAIN ] . async_unload_entry ( entry ) [EOL] [EOL] [EOL] class SwitchDevice ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] @ property def current_power_w ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] @ property def today_energy_kwh ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] @ property def is_standby ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] data = { } [EOL] [EOL] for prop , attr in PROP_TO_ATTR . items ( ) : [EOL] value = getattr ( self , prop ) [EOL] if value : [EOL] data [ attr ] = value [EOL] [EOL] return data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import List , Generator , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import asyncio [EOL] from base64 import b64decode , b64encode [EOL] import binascii [EOL] from datetime import timedelta [EOL] import logging [EOL] import socket [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( DOMAIN , PLATFORM_SCHEMA , SwitchDevice , ENTITY_ID_FORMAT ) [EOL] from homeassistant . const import ( CONF_COMMAND_OFF , CONF_COMMAND_ON , CONF_FRIENDLY_NAME , CONF_HOST , CONF_MAC , CONF_SWITCHES , CONF_TIMEOUT , CONF_TYPE ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle , slugify [EOL] from homeassistant . util . dt import utcnow [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_TIMEOUT = [number] [EOL] DEFAULT_RETRY = [number] [EOL] SERVICE_LEARN = [string] [EOL] SERVICE_SEND = [string] [EOL] CONF_SLOTS = [string] [EOL] [EOL] RM_TYPES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] SP1_TYPES = [ [string] ] [EOL] SP2_TYPES = [ [string] , [string] , [string] , [string] , [string] ] [EOL] MP1_TYPES = [ [string] ] [EOL] [EOL] SWITCH_TYPES = RM_TYPES + SP1_TYPES + SP2_TYPES + MP1_TYPES [EOL] [EOL] SWITCH_SCHEMA = vol . Schema ( { vol . Optional ( CONF_COMMAND_OFF ) : cv . string , vol . Optional ( CONF_COMMAND_ON ) : cv . string , vol . Optional ( CONF_FRIENDLY_NAME ) : cv . string , } ) [EOL] [EOL] MP1_SWITCH_SLOT_SCHEMA = vol . Schema ( { vol . Optional ( [string] ) : cv . string , vol . Optional ( [string] ) : cv . string , vol . Optional ( [string] ) : cv . string , vol . Optional ( [string] ) : cv . string } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_SWITCHES , default = { } ) : vol . Schema ( { cv . slug : SWITCH_SCHEMA } ) , vol . Optional ( CONF_SLOTS , default = { } ) : MP1_SWITCH_SLOT_SCHEMA , vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_MAC ) : cv . string , vol . Optional ( CONF_FRIENDLY_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_TYPE , default = SWITCH_TYPES [ [number] ] ) : vol . In ( SWITCH_TYPES ) , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import broadlink [EOL] devices = config . get ( CONF_SWITCHES ) [EOL] slots = config . get ( [string] , { } ) [EOL] ip_addr = config . get ( CONF_HOST ) [EOL] friendly_name = config . get ( CONF_FRIENDLY_NAME ) [EOL] mac_addr = binascii . unhexlify ( config . get ( CONF_MAC ) . encode ( ) . replace ( [string] , [string] ) ) [EOL] switch_type = config . get ( CONF_TYPE ) [EOL] [EOL] @ asyncio . coroutine def _learn_command ( call ) : [EOL] [docstring] [EOL] try : [EOL] auth = yield from hass . async_add_job ( broadlink_device . auth ) [EOL] except socket . timeout : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] if not auth : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] yield from hass . async_add_job ( broadlink_device . enter_learning ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] start_time = utcnow ( ) [EOL] while ( utcnow ( ) - start_time ) < timedelta ( seconds = [number] ) : [EOL] packet = yield from hass . async_add_job ( broadlink_device . check_data ) [EOL] if packet : [EOL] log_msg = [string] . format ( b64encode ( packet ) . decode ( [string] ) ) [EOL] _LOGGER . info ( log_msg ) [EOL] hass . components . persistent_notification . async_create ( log_msg , title = [string] ) [EOL] return [EOL] yield from asyncio . sleep ( [number] , loop = hass . loop ) [EOL] _LOGGER . error ( [string] ) [EOL] hass . components . persistent_notification . async_create ( [string] , title = [string] ) [EOL] [EOL] @ asyncio . coroutine def _send_packet ( call ) : [EOL] [docstring] [EOL] packets = call . data . get ( [string] , [ ] ) [EOL] for packet in packets : [EOL] for retry in range ( DEFAULT_RETRY ) : [EOL] try : [EOL] extra = len ( packet ) % [number] [EOL] if extra > [number] : [EOL] packet = packet + ( [string] * ( [number] - extra ) ) [EOL] payload = b64decode ( packet ) [EOL] yield from hass . async_add_job ( broadlink_device . send_data , payload ) [EOL] break [EOL] except ( socket . timeout , ValueError ) : [EOL] try : [EOL] yield from hass . async_add_job ( broadlink_device . auth ) [EOL] except socket . timeout : [EOL] if retry == DEFAULT_RETRY - [number] : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def _get_mp1_slot_name ( switch_friendly_name , slot ) : [EOL] [docstring] [EOL] if not slots [ [string] . format ( slot ) ] : [EOL] return [string] . format ( switch_friendly_name , slot ) [EOL] return slots [ [string] . format ( slot ) ] [EOL] [EOL] if switch_type in RM_TYPES : [EOL] broadlink_device = broadlink . rm ( ( ip_addr , [number] ) , mac_addr , None ) [EOL] hass . services . register ( DOMAIN , SERVICE_LEARN + [string] + ip_addr . replace ( [string] , [string] ) , _learn_command ) [EOL] hass . services . register ( DOMAIN , SERVICE_SEND + [string] + ip_addr . replace ( [string] , [string] ) , _send_packet , vol . Schema ( { [string] : cv . ensure_list } ) ) [EOL] switches = [ ] [EOL] for object_id , device_config in devices . items ( ) : [EOL] switches . append ( BroadlinkRMSwitch ( object_id , device_config . get ( CONF_FRIENDLY_NAME , object_id ) , broadlink_device , device_config . get ( CONF_COMMAND_ON ) , device_config . get ( CONF_COMMAND_OFF ) ) ) [EOL] elif switch_type in SP1_TYPES : [EOL] broadlink_device = broadlink . sp1 ( ( ip_addr , [number] ) , mac_addr , None ) [EOL] switches = [ BroadlinkSP1Switch ( friendly_name , broadlink_device ) ] [EOL] elif switch_type in SP2_TYPES : [EOL] broadlink_device = broadlink . sp2 ( ( ip_addr , [number] ) , mac_addr , None ) [EOL] switches = [ BroadlinkSP2Switch ( friendly_name , broadlink_device ) ] [EOL] elif switch_type in MP1_TYPES : [EOL] switches = [ ] [EOL] broadlink_device = broadlink . mp1 ( ( ip_addr , [number] ) , mac_addr , None ) [EOL] parent_device = BroadlinkMP1Switch ( broadlink_device ) [EOL] for i in range ( [number] , [number] ) : [EOL] slot = BroadlinkMP1Slot ( _get_mp1_slot_name ( friendly_name , i ) , broadlink_device , i , parent_device ) [EOL] switches . append ( slot ) [EOL] [EOL] broadlink_device . timeout = config . get ( CONF_TIMEOUT ) [EOL] try : [EOL] broadlink_device . auth ( ) [EOL] except socket . timeout : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] add_entities ( switches ) [EOL] [EOL] [EOL] class BroadlinkRMSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , friendly_name , device , command_on , command_off ) : [EOL] [docstring] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( slugify ( name ) ) [EOL] self . _name = friendly_name [EOL] self . _state = False [EOL] self . _command_on = b64decode ( command_on ) if command_on else None [EOL] self . _command_off = b64decode ( command_off ) if command_off else None [EOL] self . _device = device [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _sendpacket ( self . _command_on ) : [EOL] self . _state = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _sendpacket ( self . _command_off ) : [EOL] self . _state = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def _sendpacket ( self , packet , retry = [number] ) : [EOL] [docstring] [EOL] if packet is None : [EOL] _LOGGER . debug ( [string] ) [EOL] return True [EOL] try : [EOL] self . _device . send_data ( packet ) [EOL] except ( socket . timeout , ValueError ) as error : [EOL] if retry < [number] : [EOL] _LOGGER . error ( error ) [EOL] return False [EOL] if not self . _auth ( ) : [EOL] return False [EOL] return self . _sendpacket ( packet , retry - [number] ) [EOL] return True [EOL] [EOL] def _auth ( self , retry = [number] ) : [EOL] try : [EOL] auth = self . _device . auth ( ) [EOL] except socket . timeout : [EOL] auth = False [EOL] if not auth and retry > [number] : [EOL] return self . _auth ( retry - [number] ) [EOL] return auth [EOL] [EOL] [EOL] class BroadlinkSP1Switch ( BroadlinkRMSwitch ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , friendly_name , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( friendly_name , friendly_name , device , None , None ) [EOL] self . _command_on = [number] [EOL] self . _command_off = [number] [EOL] [EOL] def _sendpacket ( self , packet , retry = [number] ) : [EOL] [docstring] [EOL] try : [EOL] self . _device . set_power ( packet ) [EOL] except ( socket . timeout , ValueError ) as error : [EOL] if retry < [number] : [EOL] _LOGGER . error ( error ) [EOL] return False [EOL] if not self . _auth ( ) : [EOL] return False [EOL] return self . _sendpacket ( packet , retry - [number] ) [EOL] return True [EOL] [EOL] [EOL] class BroadlinkSP2Switch ( BroadlinkSP1Switch ) : [EOL] [docstring] [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _update ( ) [EOL] [EOL] def _update ( self , retry = [number] ) : [EOL] [docstring] [EOL] try : [EOL] state = self . _device . check_power ( ) [EOL] except ( socket . timeout , ValueError ) as error : [EOL] if retry < [number] : [EOL] _LOGGER . error ( error ) [EOL] return [EOL] if not self . _auth ( ) : [EOL] return [EOL] return self . _update ( retry - [number] ) [EOL] if state is None and retry > [number] : [EOL] return self . _update ( retry - [number] ) [EOL] self . _state = state [EOL] [EOL] [EOL] class BroadlinkMP1Slot ( BroadlinkRMSwitch ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , friendly_name , device , slot , parent_device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( friendly_name , friendly_name , device , None , None ) [EOL] self . _command_on = [number] [EOL] self . _command_off = [number] [EOL] self . _slot = slot [EOL] self . _parent_device = parent_device [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] def _sendpacket ( self , packet , retry = [number] ) : [EOL] [docstring] [EOL] try : [EOL] self . _device . set_power ( self . _slot , packet ) [EOL] except ( socket . timeout , ValueError ) as error : [EOL] if retry < [number] : [EOL] _LOGGER . error ( error ) [EOL] return False [EOL] if not self . _auth ( ) : [EOL] return False [EOL] return self . _sendpacket ( packet , max ( [number] , retry - [number] ) ) [EOL] return True [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _parent_device . update ( ) [EOL] self . _state = self . _parent_device . get_outlet_status ( self . _slot ) [EOL] [EOL] [EOL] class BroadlinkMP1Switch : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] self . _device = device [EOL] self . _states = None [EOL] [EOL] def get_outlet_status ( self , slot ) : [EOL] [docstring] [EOL] return self . _states [ [string] . format ( slot ) ] [EOL] [EOL] @ Throttle ( TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] self . _update ( ) [EOL] [EOL] def _update ( self , retry = [number] ) : [EOL] [docstring] [EOL] try : [EOL] states = self . _device . check_power ( ) [EOL] except ( socket . timeout , ValueError ) as error : [EOL] if retry < [number] : [EOL] _LOGGER . error ( error ) [EOL] return [EOL] if not self . _auth ( ) : [EOL] return [EOL] return self . _update ( max ( [number] , retry - [number] ) ) [EOL] if states is None and retry > [number] : [EOL] return self . _update ( max ( [number] , retry - [number] ) ) [EOL] self . _states = states [EOL] [EOL] def _auth ( self , retry = [number] ) : [EOL] [docstring] [EOL] try : [EOL] auth = self . _device . auth ( ) [EOL] except socket . timeout : [EOL] auth = False [EOL] if not auth and retry > [number] : [EOL] return self . _auth ( retry - [number] ) [EOL] return auth [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
from typing import List , Callable , Any [EOL] import logging [EOL] import homeassistant [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from typing import Callable [EOL] [EOL] from homeassistant . components . switch import SwitchDevice , DOMAIN [EOL] from homeassistant . components . isy994 import ( ISY994_NODES , ISY994_PROGRAMS , ISYDevice ) [EOL] from homeassistant . helpers . typing import ConfigType [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] for node in hass . data [ ISY994_NODES ] [ DOMAIN ] : [EOL] if not node . dimmable : [EOL] devices . append ( ISYSwitchDevice ( node ) ) [EOL] [EOL] for name , status , actions in hass . data [ ISY994_PROGRAMS ] [ DOMAIN ] : [EOL] devices . append ( ISYSwitchProgram ( name , status , actions ) ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class ISYSwitchDevice ( ISYDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return bool ( self . value ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _node . off ( ) : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _node . on ( ) : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [EOL] class ISYSwitchProgram ( ISYSwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , node , actions ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( node ) [EOL] self . _name = name [EOL] self . _actions = actions [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return bool ( self . value ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _actions . runThen ( ) : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _actions . runElse ( ) : [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import datetime [EOL] import telnetlib [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] import telnetlib [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( ENTITY_ID_FORMAT , PLATFORM_SCHEMA , SwitchDevice ) [EOL] from homeassistant . const import ( CONF_COMMAND_OFF , CONF_COMMAND_ON , CONF_COMMAND_STATE , CONF_NAME , CONF_PORT , CONF_RESOURCE , CONF_SWITCHES , CONF_VALUE_TEMPLATE ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] SWITCH_SCHEMA = vol . Schema ( { vol . Required ( CONF_COMMAND_OFF ) : cv . string , vol . Required ( CONF_COMMAND_ON ) : cv . string , vol . Required ( CONF_RESOURCE ) : cv . string , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_COMMAND_STATE ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SWITCHES ) : vol . Schema ( { cv . slug : SWITCH_SCHEMA } ) , } ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devices = config . get ( CONF_SWITCHES , { } ) [EOL] switches = [ ] [EOL] [EOL] for object_id , device_config in devices . items ( ) : [EOL] value_template = device_config . get ( CONF_VALUE_TEMPLATE ) [EOL] [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] switches . append ( TelnetSwitch ( hass , object_id , device_config . get ( CONF_RESOURCE ) , device_config . get ( CONF_PORT ) , device_config . get ( CONF_NAME , object_id ) , device_config . get ( CONF_COMMAND_ON ) , device_config . get ( CONF_COMMAND_OFF ) , device_config . get ( CONF_COMMAND_STATE ) , value_template ) ) [EOL] [EOL] if not switches : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] add_entities ( switches ) [EOL] [EOL] [EOL] class TelnetSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , object_id , resource , port , friendly_name , command_on , command_off , command_state , value_template ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( object_id ) [EOL] self . _resource = resource [EOL] self . _port = port [EOL] self . _name = friendly_name [EOL] self . _state = False [EOL] self . _command_on = command_on [EOL] self . _command_off = command_off [EOL] self . _command_state = command_state [EOL] self . _value_template = value_template [EOL] [EOL] def _telnet_command ( self , command ) : [EOL] try : [EOL] telnet = telnetlib . Telnet ( self . _resource , self . _port ) [EOL] telnet . write ( command . encode ( [string] ) + [string] ) [EOL] response = telnet . read_until ( [string] , timeout = [number] ) [EOL] return response . decode ( [string] ) . strip ( ) [EOL] except IOError as error : [EOL] _LOGGER . error ( [string] , command , repr ( error ) ) [EOL] return None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return self . _command_state is not None [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return self . _command_state is None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] response = self . _telnet_command ( self . _command_state ) [EOL] if response : [EOL] rendered = self . _value_template . render_with_possible_json_value ( response ) [EOL] self . _state = rendered == [string] [EOL] else : [EOL] _LOGGER . warning ( [string] , self . _command_state ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _telnet_command ( self . _command_on ) [EOL] if self . assumed_state : [EOL] self . _state = True [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _telnet_command ( self . _command_off ) [EOL] if self . assumed_state : [EOL] self . _state = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Union , Any , List , Dict , Optional [EOL] import logging [EOL] import datetime [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_MONITORED_VARIABLES , CONF_NAME , CONF_PASSWORD , CONF_PORT , CONF_USERNAME , STATE_IDLE ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_MONITORED_VARIABLES , default = [ [string] ] ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_USERNAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import transmissionrpc [EOL] from transmissionrpc . error import TransmissionError [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] try : [EOL] transmission = transmissionrpc . Client ( host , port = port , user = username , password = password ) [EOL] transmission_api = TransmissionData ( transmission ) [EOL] except TransmissionError as error : [EOL] if str ( error ) . find ( [string] ) : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] _LOGGER . warning ( [string] , host , port ) [EOL] raise PlatformNotReady [EOL] [EOL] dev = [ ] [EOL] for variable in config [ CONF_MONITORED_VARIABLES ] : [EOL] dev . append ( TransmissionSensor ( variable , transmission_api , name ) ) [EOL] [EOL] add_entities ( dev , True ) [EOL] [EOL] [EOL] class TransmissionSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor_type , transmission_api , client_name ) : [EOL] [docstring] [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _state = None [EOL] self . _transmission_api = transmission_api [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _data = None [EOL] self . client_name = client_name [EOL] self . type = sensor_type [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _transmission_api . available [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _transmission_api . update ( ) [EOL] self . _data = self . _transmission_api . data [EOL] [EOL] if self . type == [string] : [EOL] if self . _data : [EOL] upload = self . _data . uploadSpeed [EOL] download = self . _data . downloadSpeed [EOL] if upload > [number] and download > [number] : [EOL] self . _state = [string] [EOL] elif upload > [number] and download == [number] : [EOL] self . _state = [string] [EOL] elif upload == [number] and download > [number] : [EOL] self . _state = [string] [EOL] else : [EOL] self . _state = STATE_IDLE [EOL] else : [EOL] self . _state = None [EOL] [EOL] if self . _data : [EOL] if self . type == [string] : [EOL] mb_spd = float ( self . _data . downloadSpeed ) [EOL] mb_spd = mb_spd / [number] / [number] [EOL] self . _state = round ( mb_spd , [number] if mb_spd < [number] else [number] ) [EOL] elif self . type == [string] : [EOL] mb_spd = float ( self . _data . uploadSpeed ) [EOL] mb_spd = mb_spd / [number] / [number] [EOL] self . _state = round ( mb_spd , [number] if mb_spd < [number] else [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = self . _data . activeTorrentCount [EOL] elif self . type == [string] : [EOL] self . _state = self . _data . pausedTorrentCount [EOL] elif self . type == [string] : [EOL] self . _state = self . _data . torrentCount [EOL] [EOL] [EOL] class TransmissionData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api ) : [EOL] [docstring] [EOL] self . data = None [EOL] self . available = True [EOL] self . _api = api [EOL] [EOL] @ Throttle ( SCAN_INTERVAL ) def update ( self ) : [EOL] [docstring] [EOL] from transmissionrpc . error import TransmissionError [EOL] [EOL] try : [EOL] self . data = self . _api . session_stats ( ) [EOL] self . available = True [EOL] except TransmissionError : [EOL] self . available = False [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from datetime import timedelta [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . tradfri import KEY_GATEWAY , KEY_API [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] gateway_id = discovery_info [ [string] ] [EOL] api = hass . data [ KEY_API ] [ gateway_id ] [EOL] gateway = hass . data [ KEY_GATEWAY ] [ gateway_id ] [EOL] [EOL] devices_command = gateway . get_devices ( ) [EOL] devices_commands = await api ( devices_command ) [EOL] all_devices = await api ( devices_commands ) [EOL] devices = [ dev for dev in all_devices if not dev . has_light_control ] [EOL] async_add_entities ( TradfriDevice ( device , api ) for device in devices ) [EOL] [EOL] [EOL] class TradfriDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , api ) : [EOL] [docstring] [EOL] self . _api = api [EOL] self . _device = None [EOL] self . _name = None [EOL] [EOL] self . _refresh ( device ) [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _async_start_observe ( ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] info = self . _device . device_info [EOL] attrs = { [string] : info . manufacturer , [string] : info . model_number , [string] : info . serial , [string] : info . firmware_version , [string] : info . power_source_str , [string] : info . battery_level } [EOL] return attrs [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . device_info . battery_level [EOL] [EOL] @ callback def _async_start_observe ( self , exc = None ) : [EOL] [docstring] [EOL] [comment] [EOL] from pytradfri . error import PytradfriError [EOL] if exc : [EOL] _LOGGER . warning ( [string] , self . _name , exc_info = exc ) [EOL] [EOL] try : [EOL] cmd = self . _device . observe ( callback = self . _observe_update , err_callback = self . _async_start_observe , duration = [number] ) [EOL] self . hass . async_add_job ( self . _api ( cmd ) ) [EOL] except PytradfriError as err : [EOL] _LOGGER . warning ( [string] , exc_info = err ) [EOL] self . _async_start_observe ( ) [EOL] [EOL] def _refresh ( self , device ) : [EOL] [docstring] [EOL] self . _device = device [EOL] self . _name = device . name [EOL] [EOL] def _observe_update ( self , tradfri_device ) : [EOL] [docstring] [EOL] self . _refresh ( tradfri_device ) [EOL] [EOL] self . hass . async_add_job ( self . async_update_ha_state ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . const import ATTR_ATTRIBUTION [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] ATTR_NATIVE_BALANCE = [string] [EOL] [EOL] BTC_ICON = [string] [EOL] [EOL] COIN_ICON = [string] [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] [EOL] DATA_COINBASE = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] ETH_ICON = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] if [string] in discovery_info : [EOL] account = discovery_info [ [string] ] [EOL] sensor = AccountSensor ( hass . data [ DATA_COINBASE ] , account [ [string] ] , account [ [string] ] [ [string] ] ) [EOL] if [string] in discovery_info : [EOL] sensor = ExchangeRateSensor ( hass . data [ DATA_COINBASE ] , discovery_info [ [string] ] , discovery_info [ [string] ] ) [EOL] [EOL] add_entities ( [ sensor ] , True ) [EOL] [EOL] [EOL] class AccountSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , coinbase_data , name , currency ) : [EOL] [docstring] [EOL] self . _coinbase_data = coinbase_data [EOL] self . _name = [string] . format ( name ) [EOL] self . _state = None [EOL] self . _unit_of_measurement = currency [EOL] self . _native_balance = None [EOL] self . _native_currency = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . _name == [string] : [EOL] return BTC_ICON [EOL] if self . _name == [string] : [EOL] return ETH_ICON [EOL] return COIN_ICON [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , ATTR_NATIVE_BALANCE : [string] . format ( self . _native_balance , self . _native_currency ) , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _coinbase_data . update ( ) [EOL] for account in self . _coinbase_data . accounts [ [string] ] : [EOL] if self . _name == [string] . format ( account [ [string] ] ) : [EOL] self . _state = account [ [string] ] [ [string] ] [EOL] self . _native_balance = account [ [string] ] [ [string] ] [EOL] self . _native_currency = account [ [string] ] [ [string] ] [EOL] [EOL] [EOL] class ExchangeRateSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , coinbase_data , exchange_currency , native_currency ) : [EOL] [docstring] [EOL] self . _coinbase_data = coinbase_data [EOL] self . currency = exchange_currency [EOL] self . _name = [string] . format ( exchange_currency ) [EOL] self . _state = None [EOL] self . _unit_of_measurement = native_currency [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . _name == [string] : [EOL] return BTC_ICON [EOL] if self . _name == [string] : [EOL] return ETH_ICON [EOL] return COIN_ICON [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _coinbase_data . update ( ) [EOL] rate = self . _coinbase_data . exchange_rates . rates [ self . currency ] [EOL] self . _state = round ( [number] / float ( rate ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import List , Generator , Any [EOL] import homeassistant [EOL] import builtins [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] from functools import partial [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import CONF_NAME , TEMP_FAHRENHEIT [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . util . temperature import celsius_to_fahrenheit [EOL] [EOL] REQUIREMENTS = [ [string] , [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_I2C_BUS = [string] [EOL] DEFAULT_I2C_BUS = [number] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] SENSOR_TEMPERATURE = [string] [EOL] SENSOR_HUMIDITY = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_I2C_BUS , default = DEFAULT_I2C_BUS ) : vol . Coerce ( int ) , } ) [EOL] [EOL] [EOL] [comment] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import smbus [EOL] from i2csense . htu21d import HTU21D [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] bus_number = config . get ( CONF_I2C_BUS ) [EOL] temp_unit = hass . config . units . temperature_unit [EOL] [EOL] bus = smbus . SMBus ( config . get ( CONF_I2C_BUS ) ) [EOL] sensor = yield from hass . async_add_job ( partial ( HTU21D , bus , logger = _LOGGER ) ) [EOL] if not sensor . sample_ok : [EOL] _LOGGER . error ( [string] , bus_number ) [EOL] return False [EOL] [EOL] sensor_handler = yield from hass . async_add_job ( HTU21DHandler , sensor ) [EOL] [EOL] dev = [ HTU21DSensor ( sensor_handler , name , SENSOR_TEMPERATURE , temp_unit ) , HTU21DSensor ( sensor_handler , name , SENSOR_HUMIDITY , [string] ) ] [EOL] [EOL] async_add_entities ( dev ) [EOL] [EOL] [EOL] class HTU21DHandler : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor ) : [EOL] [docstring] [EOL] self . sensor = sensor [EOL] self . sensor . update ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] self . sensor . update ( ) [EOL] [EOL] [EOL] class HTU21DSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , htu21d_client , name , variable , unit ) : [EOL] [docstring] [EOL] self . _name = [string] . format ( name , variable ) [EOL] self . _variable = variable [EOL] self . _unit_of_measurement = unit [EOL] self . _client = htu21d_client [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] yield from self . hass . async_add_job ( self . _client . update ) [EOL] if self . _client . sensor . sample_ok : [EOL] if self . _variable == SENSOR_TEMPERATURE : [EOL] value = round ( self . _client . sensor . temperature , [number] ) [EOL] if self . unit_of_measurement == TEMP_FAHRENHEIT : [EOL] value = celsius_to_fahrenheit ( value ) [EOL] else : [EOL] value = round ( self . _client . sensor . humidity , [number] ) [EOL] self . _state = value [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import List , Any [EOL] import homeassistant [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] import datetime [EOL] import json [EOL] from urllib . parse import urljoin [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SCAN_INTERVAL = datetime . timedelta ( seconds = [number] ) [EOL] API_URL = [string] [EOL] CONF_API_LOGIN = [string] [EOL] CONF_API_PASSWORD = [string] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_LOGIN ) : cv . string , vol . Required ( CONF_API_PASSWORD ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] api_login = config [ CONF_API_LOGIN ] [EOL] api_password = config [ CONF_API_PASSWORD ] [EOL] name = config [ CONF_NAME ] [EOL] try : [EOL] sigfox = SigfoxAPI ( api_login , api_password ) [EOL] except ValueError : [EOL] return False [EOL] auth = sigfox . auth [EOL] devices = sigfox . devices [EOL] [EOL] sensors = [ ] [EOL] for device in devices : [EOL] sensors . append ( SigfoxDevice ( device , auth , name ) ) [EOL] add_entities ( sensors , True ) [EOL] [EOL] [EOL] def epoch_to_datetime ( epoch_time ) : [EOL] [docstring] [EOL] return datetime . datetime . fromtimestamp ( epoch_time ) . isoformat ( ) [EOL] [EOL] [EOL] class SigfoxAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_login , api_password ) : [EOL] [docstring] [EOL] self . _auth = requests . auth . HTTPBasicAuth ( api_login , api_password ) [EOL] if self . check_credentials ( ) : [EOL] device_types = self . get_device_types ( ) [EOL] self . _devices = self . get_devices ( device_types ) [EOL] [EOL] def check_credentials ( self ) : [EOL] [docstring] [EOL] url = urljoin ( API_URL , [string] ) [EOL] response = requests . get ( url , auth = self . _auth , timeout = [number] ) [EOL] if response . status_code != [number] : [EOL] if response . status_code == [number] : [EOL] _LOGGER . error ( [string] ) [EOL] else : [EOL] _LOGGER . error ( [string] , str ( response . status_code ) ) [EOL] raise ValueError ( [string] ) [EOL] return True [EOL] [EOL] def get_device_types ( self ) : [EOL] [docstring] [EOL] url = urljoin ( API_URL , [string] ) [EOL] response = requests . get ( url , auth = self . _auth , timeout = [number] ) [EOL] device_types = [ ] [EOL] for device in json . loads ( response . text ) [ [string] ] : [EOL] device_types . append ( device [ [string] ] ) [EOL] return device_types [EOL] [EOL] def get_devices ( self , device_types ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] for unique_type in device_types : [EOL] location_url = [string] . format ( unique_type ) [EOL] url = urljoin ( API_URL , location_url ) [EOL] response = requests . get ( url , auth = self . _auth , timeout = [number] ) [EOL] devices_data = json . loads ( response . text ) [ [string] ] [EOL] for device in devices_data : [EOL] devices . append ( device [ [string] ] ) [EOL] return devices [EOL] [EOL] @ property def auth ( self ) : [EOL] [docstring] [EOL] return self . _auth [EOL] [EOL] @ property def devices ( self ) : [EOL] [docstring] [EOL] return self . _devices [EOL] [EOL] [EOL] class SigfoxDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device_id , auth , name ) : [EOL] [docstring] [EOL] self . _device_id = device_id [EOL] self . _auth = auth [EOL] self . _message_data = { } [EOL] self . _name = [string] . format ( name , device_id ) [EOL] self . _state = None [EOL] [EOL] def get_last_message ( self ) : [EOL] [docstring] [EOL] device_url = [string] . format ( self . _device_id ) [EOL] url = urljoin ( API_URL , device_url ) [EOL] response = requests . get ( url , auth = self . _auth , timeout = [number] ) [EOL] data = json . loads ( response . text ) [ [string] ] [ [number] ] [EOL] payload = bytes . fromhex ( data [ [string] ] ) . decode ( [string] ) [EOL] lat = data [ [string] ] [ [number] ] [ [string] ] [EOL] lng = data [ [string] ] [ [number] ] [ [string] ] [EOL] snr = data [ [string] ] [EOL] epoch_time = data [ [string] ] [EOL] return { [string] : lat , [string] : lng , [string] : payload , [string] : snr , [string] : epoch_to_datetime ( epoch_time ) } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _message_data = self . get_last_message ( ) [EOL] self . _state = self . _message_data [ [string] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _message_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.auth.HTTPBasicAuth$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . components . tahoma import ( DOMAIN as TAHOMA_DOMAIN , TahomaDevice ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] controller = hass . data [ TAHOMA_DOMAIN ] [ [string] ] [EOL] devices = [ ] [EOL] for device in hass . data [ TAHOMA_DOMAIN ] [ [string] ] [ [string] ] : [EOL] devices . append ( TahomaSensor ( device , controller ) ) [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class TahomaSensor ( TahomaDevice , Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tahoma_device , controller ) : [EOL] [docstring] [EOL] self . current_value = None [EOL] super ( ) . __init__ ( tahoma_device , controller ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . current_value [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] if self . tahoma_device . type == [string] : [EOL] return None [EOL] if self . tahoma_device . type == [string] : [EOL] return None [EOL] if self . tahoma_device . type == [string] : [EOL] return [string] [EOL] if self . tahoma_device . type == [string] : [EOL] return [string] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . controller . get_states ( [ self . tahoma_device ] ) [EOL] if self . tahoma_device . type == [string] : [EOL] self . current_value = self . tahoma_device . active_states [ [string] ] [EOL] if self . tahoma_device . type == [string] : [EOL] self . current_value = self . tahoma_device . active_states [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import logging [EOL] import datetime [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_DISPLAY_OPTIONS [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . helpers . event import async_track_point_in_utc_time [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] TIME_STR_FORMAT = [string] [EOL] [EOL] OPTION_TYPES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_DISPLAY_OPTIONS , default = [ [string] ] ) : vol . All ( cv . ensure_list , [ vol . In ( OPTION_TYPES ) ] ) , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if hass . config . time_zone is None : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] devices = [ ] [EOL] for variable in config [ CONF_DISPLAY_OPTIONS ] : [EOL] device = TimeDateSensor ( hass , variable ) [EOL] async_track_point_in_utc_time ( hass , device . point_in_time_listener , device . get_next_interval ( ) ) [EOL] devices . append ( device ) [EOL] [EOL] async_add_entities ( devices , True ) [EOL] [EOL] [EOL] class TimeDateSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , option_type ) : [EOL] [docstring] [EOL] self . _name = OPTION_TYPES [ option_type ] [EOL] self . type = option_type [EOL] self . _state = None [EOL] self . hass = hass [EOL] [EOL] self . _update_internal_state ( dt_util . utcnow ( ) ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if [string] in self . type and [string] in self . type : [EOL] return [string] [EOL] if [string] in self . type : [EOL] return [string] [EOL] return [string] [EOL] [EOL] def get_next_interval ( self , now = None ) : [EOL] [docstring] [EOL] if now is None : [EOL] now = dt_util . utcnow ( ) [EOL] if self . type == [string] : [EOL] now = dt_util . start_of_local_day ( dt_util . as_local ( now ) ) [EOL] return now + timedelta ( seconds = [number] ) [EOL] if self . type == [string] : [EOL] interval = [number] [EOL] else : [EOL] interval = [number] [EOL] timestamp = int ( dt_util . as_timestamp ( now ) ) [EOL] delta = interval - ( timestamp % interval ) [EOL] return now + timedelta ( seconds = delta ) [EOL] [EOL] def _update_internal_state ( self , time_date ) : [EOL] time = dt_util . as_local ( time_date ) . strftime ( TIME_STR_FORMAT ) [EOL] time_utc = time_date . strftime ( TIME_STR_FORMAT ) [EOL] date = dt_util . as_local ( time_date ) . date ( ) . isoformat ( ) [EOL] [EOL] [comment] [EOL] time_bmt = time_date + timedelta ( hours = [number] ) [EOL] delta = timedelta ( hours = time_bmt . hour , minutes = time_bmt . minute , seconds = time_bmt . second , microseconds = time_bmt . microsecond ) [EOL] beat = int ( ( delta . seconds + delta . microseconds / [number] ) / [number] ) [EOL] [EOL] if self . type == [string] : [EOL] self . _state = time [EOL] elif self . type == [string] : [EOL] self . _state = date [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( date , time ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( time , date ) [EOL] elif self . type == [string] : [EOL] self . _state = time_utc [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( beat ) [EOL] [EOL] @ callback def point_in_time_listener ( self , time_date ) : [EOL] [docstring] [EOL] self . _update_internal_state ( time_date ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] async_track_point_in_utc_time ( self . hass , self . point_in_time_listener , self . get_next_interval ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_MONITORED_CONDITIONS , CONF_NAME , CONF_SSL , CONF_VERIFY_SSL ) [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_BLOCKED_DOMAINS = [string] [EOL] ATTR_PERCENTAGE_TODAY = [string] [EOL] ATTR_QUERIES_TODAY = [string] [EOL] [EOL] CONF_LOCATION = [string] [EOL] DEFAULT_HOST = [string] [EOL] [EOL] DEFAULT_LOCATION = [string] [EOL] DEFAULT_METHOD = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_SSL = False [EOL] DEFAULT_VERIFY_SSL = True [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] MONITORED_CONDITIONS = { [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_SSL , default = DEFAULT_SSL ) : cv . boolean , vol . Optional ( CONF_LOCATION , default = DEFAULT_LOCATION ) : cv . string , vol . Optional ( CONF_VERIFY_SSL , default = DEFAULT_VERIFY_SSL ) : cv . boolean , vol . Optional ( CONF_MONITORED_CONDITIONS , default = [ [string] ] ) : vol . All ( cv . ensure_list , [ vol . In ( MONITORED_CONDITIONS ) ] ) , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from hole import Hole [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] use_tls = config . get ( CONF_SSL ) [EOL] location = config . get ( CONF_LOCATION ) [EOL] verify_tls = config . get ( CONF_VERIFY_SSL ) [EOL] [EOL] session = async_get_clientsession ( hass ) [EOL] pi_hole = PiHoleData ( Hole ( host , hass . loop , session , location = location , tls = use_tls , verify_tls = verify_tls ) ) [EOL] [EOL] await pi_hole . async_update ( ) [EOL] [EOL] if pi_hole . api . data is None : [EOL] raise PlatformNotReady [EOL] [EOL] sensors = [ PiHoleSensor ( pi_hole , name , condition ) for condition in config [ CONF_MONITORED_CONDITIONS ] ] [EOL] [EOL] async_add_entities ( sensors , True ) [EOL] [EOL] [EOL] class PiHoleSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , pi_hole , name , condition ) : [EOL] [docstring] [EOL] self . pi_hole = pi_hole [EOL] self . _name = name [EOL] self . _condition = condition [EOL] [EOL] variable_info = MONITORED_CONDITIONS [ condition ] [EOL] self . _condition_name = variable_info [ [number] ] [EOL] self . _unit_of_measurement = variable_info [ [number] ] [EOL] self . _icon = variable_info [ [number] ] [EOL] self . data = { } [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name , self . _condition_name ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] try : [EOL] return round ( self . data [ self . _condition ] , [number] ) [EOL] except TypeError : [EOL] return self . data [ self . _condition ] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_BLOCKED_DOMAINS : self . data [ [string] ] , } [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . pi_hole . available [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] await self . pi_hole . async_update ( ) [EOL] self . data = self . pi_hole . api . data [EOL] [EOL] [EOL] class PiHoleData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api ) : [EOL] [docstring] [EOL] self . api = api [EOL] self . available = True [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) async def async_update ( self ) : [EOL] [docstring] [EOL] from hole . exceptions import HoleError [EOL] [EOL] try : [EOL] await self . api . get_data ( ) [EOL] self . available = True [EOL] except HoleError : [EOL] _LOGGER . error ( [string] ) [EOL] self . available = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import List , Tuple , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import json [EOL] import logging [EOL] [EOL] from homeassistant . components import mqtt [EOL] from homeassistant . core import callback [EOL] from homeassistant . const import TEMP_FAHRENHEIT , TEMP_CELSIUS [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import slugify [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] DOMAIN = [string] [EOL] [EOL] DATA_ARWN = [string] [EOL] TOPIC = [string] [EOL] [EOL] [EOL] def discover_sensors ( topic , payload ) : [EOL] [docstring] [EOL] parts = topic . split ( [string] ) [EOL] unit = payload . get ( [string] , [string] ) [EOL] domain = parts [ [number] ] [EOL] if domain == [string] : [EOL] name = parts [ [number] ] [EOL] if unit == [string] : [EOL] unit = TEMP_FAHRENHEIT [EOL] else : [EOL] unit = TEMP_CELSIUS [EOL] return ArwnSensor ( name , [string] , unit ) [EOL] if domain == [string] : [EOL] name = parts [ [number] ] + [string] [EOL] return ArwnSensor ( name , [string] , unit , [string] ) [EOL] if domain == [string] : [EOL] if len ( parts ) >= [number] and parts [ [number] ] == [string] : [EOL] return ArwnSensor ( [string] , [string] , [string] , [string] ) [EOL] if domain == [string] : [EOL] return ArwnSensor ( [string] , [string] , unit , [string] ) [EOL] if domain == [string] : [EOL] return ( ArwnSensor ( [string] , [string] , unit , [string] ) , ArwnSensor ( [string] , [string] , unit , [string] ) , ArwnSensor ( [string] , [string] , [string] , [string] ) ) [EOL] [EOL] [EOL] def _slug ( name ) : [EOL] return [string] . format ( slugify ( name ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] @ callback def async_sensor_event_received ( topic , payload , qos ) : [EOL] [docstring] [EOL] event = json . loads ( payload ) [EOL] sensors = discover_sensors ( topic , event ) [EOL] if not sensors : [EOL] return [EOL] [EOL] store = hass . data . get ( DATA_ARWN ) [EOL] if store is None : [EOL] store = hass . data [ DATA_ARWN ] = { } [EOL] [EOL] if isinstance ( sensors , ArwnSensor ) : [EOL] sensors = ( sensors , ) [EOL] [EOL] if [string] in event : [EOL] del event [ [string] ] [EOL] [EOL] for sensor in sensors : [EOL] if sensor . name not in store : [EOL] sensor . hass = hass [EOL] sensor . set_event ( event ) [EOL] store [ sensor . name ] = sensor [EOL] _LOGGER . debug ( [string] , dict ( name = sensor . name , event = event ) ) [EOL] async_add_entities ( ( sensor , ) , True ) [EOL] else : [EOL] store [ sensor . name ] . set_event ( event ) [EOL] [EOL] yield from mqtt . async_subscribe ( hass , TOPIC , async_sensor_event_received , [number] ) [EOL] return True [EOL] [EOL] [EOL] class ArwnSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , state_key , units , icon = None ) : [EOL] [docstring] [EOL] self . hass = None [EOL] self . entity_id = _slug ( name ) [EOL] self . _name = name [EOL] self . _state_key = state_key [EOL] self . event = { } [EOL] self . _unit_of_measurement = units [EOL] self . _icon = icon [EOL] [EOL] def set_event ( self , event ) : [EOL] [docstring] [EOL] self . event = { } [EOL] self . event . update ( event ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . event . get ( self . _state_key , None ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] return self . event [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Set , Any [EOL] import logging [EOL] import datetime [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_TYPE ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_AREAS = [string] [EOL] CONF_LAT_NE = [string] [EOL] CONF_LON_NE = [string] [EOL] CONF_LAT_SW = [string] [EOL] CONF_LON_SW = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_TYPE = [string] [EOL] SENSOR_TYPES = { [string] , [string] } [EOL] [EOL] [comment] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_AREAS ) : vol . All ( cv . ensure_list , [ { vol . Required ( CONF_LAT_NE ) : cv . latitude , vol . Required ( CONF_LAT_SW ) : cv . latitude , vol . Required ( CONF_LON_NE ) : cv . longitude , vol . Required ( CONF_LON_SW ) : cv . longitude , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_TYPE , default = DEFAULT_TYPE ) : vol . In ( SENSOR_TYPES ) } ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] netatmo = hass . components . netatmo [EOL] [EOL] sensors = [ ] [EOL] areas = config . get ( CONF_AREAS ) [EOL] for area_conf in areas : [EOL] data = NetatmoPublicData ( netatmo . NETATMO_AUTH , lat_ne = area_conf . get ( CONF_LAT_NE ) , lon_ne = area_conf . get ( CONF_LON_NE ) , lat_sw = area_conf . get ( CONF_LAT_SW ) , lon_sw = area_conf . get ( CONF_LON_SW ) , calculation = area_conf . get ( CONF_TYPE ) ) [EOL] sensors . append ( NetatmoPublicSensor ( area_conf . get ( CONF_NAME ) , data ) ) [EOL] add_entities ( sensors ) [EOL] [EOL] [EOL] class NetatmoPublicSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , data ) : [EOL] [docstring] [EOL] self . netatmo_data = data [EOL] self . _name = name [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . netatmo_data . update ( ) [EOL] self . _state = self . netatmo_data . data [EOL] [EOL] [EOL] class NetatmoPublicData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , auth , lat_ne , lon_ne , lat_sw , lon_sw , calculation ) : [EOL] [docstring] [EOL] self . auth = auth [EOL] self . data = None [EOL] self . lat_ne = lat_ne [EOL] self . lon_ne = lon_ne [EOL] self . lat_sw = lat_sw [EOL] self . lon_sw = lon_sw [EOL] self . calculation = calculation [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] import pyatmo [EOL] raindata = pyatmo . PublicData ( self . auth , LAT_NE = self . lat_ne , LON_NE = self . lon_ne , LAT_SW = self . lat_sw , LON_SW = self . lon_sw , required_data_type = [string] ) [EOL] [EOL] if raindata . CountStationInArea ( ) == [number] : [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] [EOL] raindata_live = raindata . getLive ( ) [EOL] [EOL] if self . calculation == [string] : [EOL] self . data = sum ( raindata_live . values ( ) ) / len ( raindata_live ) [EOL] else : [EOL] self . data = max ( raindata_live . values ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import datetime [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , CONF_UNIT_OF_MEASUREMENT , STATE_UNKNOWN , CONF_VALUE_TEMPLATE ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_BASEOID = [string] [EOL] CONF_COMMUNITY = [string] [EOL] CONF_VERSION = [string] [EOL] CONF_ACCEPT_ERRORS = [string] [EOL] CONF_DEFAULT_VALUE = [string] [EOL] [EOL] DEFAULT_COMMUNITY = [string] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [string] [EOL] DEFAULT_VERSION = [string] [EOL] [EOL] SNMP_VERSIONS = { [string] : [number] , [string] : [number] } [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_BASEOID ) : cv . string , vol . Optional ( CONF_ACCEPT_ERRORS , default = False ) : cv . boolean , vol . Optional ( CONF_COMMUNITY , default = DEFAULT_COMMUNITY ) : cv . string , vol . Optional ( CONF_DEFAULT_VALUE ) : cv . string , vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_UNIT_OF_MEASUREMENT ) : cv . string , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_VERSION , default = DEFAULT_VERSION ) : vol . In ( SNMP_VERSIONS ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pysnmp . hlapi import ( getCmd , CommunityData , SnmpEngine , UdpTransportTarget , ContextData , ObjectType , ObjectIdentity ) [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] community = config . get ( CONF_COMMUNITY ) [EOL] baseoid = config . get ( CONF_BASEOID ) [EOL] unit = config . get ( CONF_UNIT_OF_MEASUREMENT ) [EOL] version = config . get ( CONF_VERSION ) [EOL] accept_errors = config . get ( CONF_ACCEPT_ERRORS ) [EOL] default_value = config . get ( CONF_DEFAULT_VALUE ) [EOL] value_template = config . get ( CONF_VALUE_TEMPLATE ) [EOL] [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] errindication , _ , _ , _ = next ( getCmd ( SnmpEngine ( ) , CommunityData ( community , mpModel = SNMP_VERSIONS [ version ] ) , UdpTransportTarget ( ( host , port ) ) , ContextData ( ) , ObjectType ( ObjectIdentity ( baseoid ) ) ) ) [EOL] [EOL] if errindication and not accept_errors : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] data = SnmpData ( host , port , community , baseoid , version , accept_errors , default_value ) [EOL] add_entities ( [ SnmpSensor ( data , name , unit , value_template ) ] , True ) [EOL] [EOL] [EOL] class SnmpSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , name , unit_of_measurement , value_template ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . _value_template = value_template [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] value = self . data . value [EOL] [EOL] if value is None : [EOL] value = STATE_UNKNOWN [EOL] elif self . _value_template is not None : [EOL] value = self . _value_template . render_with_possible_json_value ( value , STATE_UNKNOWN ) [EOL] [EOL] self . _state = value [EOL] [EOL] [EOL] class SnmpData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , community , baseoid , version , accept_errors , default_value ) : [EOL] [docstring] [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _community = community [EOL] self . _baseoid = baseoid [EOL] self . _version = SNMP_VERSIONS [ version ] [EOL] self . _accept_errors = accept_errors [EOL] self . _default_value = default_value [EOL] self . value = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from pysnmp . hlapi import ( getCmd , CommunityData , SnmpEngine , UdpTransportTarget , ContextData , ObjectType , ObjectIdentity ) [EOL] errindication , errstatus , errindex , restable = next ( getCmd ( SnmpEngine ( ) , CommunityData ( self . _community , mpModel = self . _version ) , UdpTransportTarget ( ( self . _host , self . _port ) ) , ContextData ( ) , ObjectType ( ObjectIdentity ( self . _baseoid ) ) ) ) [EOL] [EOL] if errindication and not self . _accept_errors : [EOL] _LOGGER . error ( [string] , errindication ) [EOL] elif errstatus and not self . _accept_errors : [EOL] _LOGGER . error ( [string] , errstatus . prettyPrint ( ) , errindex and restable [ - [number] ] [ int ( errindex ) - [number] ] or [string] ) [EOL] elif ( errindication or errstatus ) and self . _accept_errors : [EOL] self . value = self . _default_value [EOL] else : [EOL] for resrow in restable : [EOL] self . value = str ( resrow [ - [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , Dict , List , Optional [EOL] import logging [EOL] import homeassistant [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from typing import Callable [EOL] [EOL] from homeassistant . components . sensor import DOMAIN [EOL] from homeassistant . components . isy994 import ( ISY994_NODES , ISY994_WEATHER , ISYDevice ) [EOL] from homeassistant . const import ( TEMP_CELSIUS , TEMP_FAHRENHEIT , UNIT_UV_INDEX ) [EOL] from homeassistant . helpers . typing import ConfigType [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] UOM_FRIENDLY_NAME = { [string] : [string] , [string] : [string] , [string] : TEMP_CELSIUS , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : TEMP_FAHRENHEIT , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : UNIT_UV_INDEX , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] UOM_TO_STATES = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] [EOL] for node in hass . data [ ISY994_NODES ] [ DOMAIN ] : [EOL] _LOGGER . debug ( [string] , node . name ) [EOL] devices . append ( ISYSensorDevice ( node ) ) [EOL] [EOL] for node in hass . data [ ISY994_WEATHER ] : [EOL] devices . append ( ISYWeatherDevice ( node ) ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class ISYSensorDevice ( ISYDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def raw_unit_of_measurement ( self ) : [EOL] [docstring] [EOL] if len ( self . _node . uom ) == [number] : [EOL] if self . _node . uom [ [number] ] in UOM_FRIENDLY_NAME : [EOL] friendly_name = UOM_FRIENDLY_NAME . get ( self . _node . uom [ [number] ] ) [EOL] if friendly_name in ( TEMP_CELSIUS , TEMP_FAHRENHEIT ) : [EOL] friendly_name = self . hass . config . units . temperature_unit [EOL] return friendly_name [EOL] return self . _node . uom [ [number] ] [EOL] return None [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . is_unknown ( ) : [EOL] return None [EOL] [EOL] if len ( self . _node . uom ) == [number] : [EOL] if self . _node . uom [ [number] ] in UOM_TO_STATES : [EOL] states = UOM_TO_STATES . get ( self . _node . uom [ [number] ] ) [EOL] if self . value in states : [EOL] return states . get ( self . value ) [EOL] elif self . _node . prec and self . _node . prec != [ [number] ] : [EOL] str_val = str ( self . value ) [EOL] int_prec = int ( self . _node . prec ) [EOL] decimal_part = str_val [ - int_prec : ] [EOL] whole_part = str_val [ : len ( str_val ) - int_prec ] [EOL] val = float ( [string] . format ( whole_part , decimal_part ) ) [EOL] raw_units = self . raw_unit_of_measurement [EOL] if raw_units in ( TEMP_CELSIUS , TEMP_FAHRENHEIT ) : [EOL] val = self . hass . config . units . temperature ( val , raw_units ) [EOL] [EOL] return str ( val ) [EOL] else : [EOL] return self . value [EOL] [EOL] return None [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] raw_units = self . raw_unit_of_measurement [EOL] if raw_units in ( TEMP_FAHRENHEIT , TEMP_CELSIUS ) : [EOL] return self . hass . config . units . temperature_unit [EOL] return raw_units [EOL] [EOL] [EOL] class ISYWeatherDevice ( ISYDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def raw_units ( self ) : [EOL] [docstring] [EOL] if self . _node . uom == [string] : [EOL] return TEMP_FAHRENHEIT [EOL] if self . _node . uom == [string] : [EOL] return TEMP_CELSIUS [EOL] return self . _node . uom [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] val = self . _node . status . _val [EOL] raw_units = self . _node . uom [EOL] [EOL] if raw_units in [ TEMP_CELSIUS , TEMP_FAHRENHEIT ] : [EOL] return self . hass . config . units . temperature ( val , raw_units ) [EOL] return val [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] raw_units = self . raw_units [EOL] [EOL] if raw_units in [ TEMP_CELSIUS , TEMP_FAHRENHEIT ] : [EOL] return self . hass . config . units . temperature_unit [EOL] return raw_units [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . verisure import HUB as hub [EOL] from homeassistant . components . verisure import ( CONF_THERMOMETERS , CONF_HYDROMETERS , CONF_MOUSE ) [EOL] from homeassistant . const import TEMP_CELSIUS [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] sensors = [ ] [EOL] hub . update_overview ( ) [EOL] [EOL] if int ( hub . config . get ( CONF_THERMOMETERS , [number] ) ) : [EOL] sensors . extend ( [ VerisureThermometer ( device_label ) for device_label in hub . get ( [string] ) ] ) [EOL] [EOL] if int ( hub . config . get ( CONF_HYDROMETERS , [number] ) ) : [EOL] sensors . extend ( [ VerisureHygrometer ( device_label ) for device_label in hub . get ( [string] ) ] ) [EOL] [EOL] if int ( hub . config . get ( CONF_MOUSE , [number] ) ) : [EOL] sensors . extend ( [ VerisureMouseDetection ( device_label ) for device_label in hub . get ( [string] ) ] ) [EOL] [EOL] add_entities ( sensors ) [EOL] [EOL] [EOL] class VerisureThermometer ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device_label ) : [EOL] [docstring] [EOL] self . _device_label = device_label [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) + [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) is not None [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] [comment] [EOL] def update ( self ) : [EOL] [docstring] [EOL] hub . update_overview ( ) [EOL] [EOL] [EOL] class VerisureHygrometer ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device_label ) : [EOL] [docstring] [EOL] self . _device_label = device_label [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) + [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) is not None [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [comment] [EOL] def update ( self ) : [EOL] [docstring] [EOL] hub . update_overview ( ) [EOL] [EOL] [EOL] class VerisureMouseDetection ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device_label ) : [EOL] [docstring] [EOL] self . _device_label = device_label [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) + [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) is not None [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [comment] [EOL] def update ( self ) : [EOL] [docstring] [EOL] hub . update_overview ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . ihc import ( validate_name , IHC_DATA , IHC_CONTROLLER , IHC_INFO ) [EOL] from homeassistant . components . ihc . ihcdevice import IHCDevice [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_ID , CONF_NAME , CONF_UNIT_OF_MEASUREMENT , CONF_SENSORS , TEMP_CELSIUS ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_SENSORS , default = [ ] ) : vol . All ( cv . ensure_list , [ vol . All ( { vol . Required ( CONF_ID ) : cv . positive_int , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_UNIT_OF_MEASUREMENT , default = TEMP_CELSIUS ) : cv . string } , validate_name ) ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] ihc_controller = hass . data [ IHC_DATA ] [ IHC_CONTROLLER ] [EOL] info = hass . data [ IHC_DATA ] [ IHC_INFO ] [EOL] devices = [ ] [EOL] if discovery_info : [EOL] for name , device in discovery_info . items ( ) : [EOL] ihc_id = device [ [string] ] [EOL] product_cfg = device [ [string] ] [EOL] product = device [ [string] ] [EOL] sensor = IHCSensor ( ihc_controller , name , ihc_id , info , product_cfg [ CONF_UNIT_OF_MEASUREMENT ] , product ) [EOL] devices . append ( sensor ) [EOL] else : [EOL] sensors = config [ CONF_SENSORS ] [EOL] for sensor_cfg in sensors : [EOL] ihc_id = sensor_cfg [ CONF_ID ] [EOL] name = sensor_cfg [ CONF_NAME ] [EOL] unit = sensor_cfg [ CONF_UNIT_OF_MEASUREMENT ] [EOL] sensor = IHCSensor ( ihc_controller , name , ihc_id , info , unit ) [EOL] devices . append ( sensor ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class IHCSensor ( IHCDevice , Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ihc_controller , name , ihc_id , info , unit , product = None ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ihc_controller , name , ihc_id , info , product ) [EOL] self . _state = None [EOL] self . _unit_of_measurement = unit [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def on_ihc_change ( self , ihc_id , value ) : [EOL] [docstring] [EOL] self . _state = value [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Dict , Any [EOL] import logging [EOL] import homeassistant [EOL] import threading [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from time import time [EOL] import threading [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( TEMP_CELSIUS , DEVICE_CLASS_HUMIDITY , DEVICE_CLASS_TEMPERATURE , STATE_UNKNOWN ) [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_MODULES = [string] [EOL] CONF_STATION = [string] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [comment] [EOL] NETATMO_UPDATE_INTERVAL = [number] [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , TEMP_CELSIUS , None , DEVICE_CLASS_TEMPERATURE ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , None , DEVICE_CLASS_HUMIDITY ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , TEMP_CELSIUS , [string] , None ] , [string] : [ [string] , TEMP_CELSIUS , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] , } [EOL] [EOL] MODULE_SCHEMA = vol . Schema ( { vol . Required ( cv . string ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_STATION ) : cv . string , vol . Optional ( CONF_MODULES ) : MODULE_SCHEMA , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] netatmo = hass . components . netatmo [EOL] data = NetAtmoData ( netatmo . NETATMO_AUTH , config . get ( CONF_STATION , None ) ) [EOL] [EOL] dev = [ ] [EOL] import pyatmo [EOL] try : [EOL] if CONF_MODULES in config : [EOL] [comment] [EOL] for module_name , monitored_conditions in config [ CONF_MODULES ] . items ( ) : [EOL] [comment] [EOL] if module_name not in data . get_module_names ( ) : [EOL] _LOGGER . error ( [string] , module_name ) [EOL] continue [EOL] [comment] [EOL] for variable in monitored_conditions : [EOL] dev . append ( NetAtmoSensor ( data , module_name , variable ) ) [EOL] else : [EOL] for module_name in data . get_module_names ( ) : [EOL] for variable in data . station_data . monitoredConditions ( module_name ) : [EOL] if variable in SENSOR_TYPES . keys ( ) : [EOL] dev . append ( NetAtmoSensor ( data , module_name , variable ) ) [EOL] else : [EOL] _LOGGER . warning ( [string] , variable , module_name ) [EOL] except pyatmo . NoDevice : [EOL] return None [EOL] [EOL] add_entities ( dev , True ) [EOL] [EOL] [EOL] class NetAtmoSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , netatmo_data , module_name , sensor_type ) : [EOL] [docstring] [EOL] self . _name = [string] . format ( module_name , SENSOR_TYPES [ sensor_type ] [ [number] ] ) [EOL] self . netatmo_data = netatmo_data [EOL] self . module_name = module_name [EOL] self . type = sensor_type [EOL] self . _state = None [EOL] self . _device_class = SENSOR_TYPES [ self . type ] [ [number] ] [EOL] self . _icon = SENSOR_TYPES [ self . type ] [ [number] ] [EOL] self . _unit_of_measurement = SENSOR_TYPES [ self . type ] [ [number] ] [EOL] module_id = self . netatmo_data . station_data . moduleByName ( module = module_name ) [ [string] ] [EOL] self . module_id = module_id [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . netatmo_data . update ( ) [EOL] data = self . netatmo_data . data . get ( self . module_name ) [EOL] [EOL] if data is None : [EOL] _LOGGER . warning ( [string] , self . module_name ) [EOL] self . _state = STATE_UNKNOWN [EOL] return [EOL] [EOL] if self . type == [string] : [EOL] self . _state = round ( data [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = round ( data [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] and self . module_id == [string] : [EOL] if data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] < [number] : [EOL] self . _state = [string] [EOL] elif self . type == [string] and self . module_id == [string] : [EOL] if data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] < [number] : [EOL] self . _state = [string] [EOL] elif self . type == [string] and self . module_id == [string] : [EOL] if data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] < [number] : [EOL] self . _state = [string] [EOL] elif self . type == [string] and self . module_id == [string] : [EOL] if data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] < [number] : [EOL] self . _state = [string] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] if data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] if data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] % data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] if data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] <= [number] : [EOL] self . _state = [string] [EOL] elif self . type == [string] : [EOL] self . _state = data [ [string] ] [EOL] elif self . type == [string] : [EOL] if data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] >= [number] : [EOL] self . _state = [string] [EOL] elif data [ [string] ] <= [number] : [EOL] self . _state = [string] [EOL] [EOL] [EOL] class NetAtmoData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , auth , station ) : [EOL] [docstring] [EOL] self . auth = auth [EOL] self . data = None [EOL] self . station_data = None [EOL] self . station = station [EOL] self . _next_update = time ( ) [EOL] self . _update_in_progress = threading . Lock ( ) [EOL] [EOL] def get_module_names ( self ) : [EOL] [docstring] [EOL] self . update ( ) [EOL] return self . data . keys ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if time ( ) < self . _next_update or not self . _update_in_progress . acquire ( False ) : [EOL] return [EOL] [EOL] try : [EOL] import pyatmo [EOL] self . station_data = pyatmo . WeatherStationData ( self . auth ) [EOL] [EOL] if self . station is not None : [EOL] self . data = self . station_data . lastData ( station = self . station , exclude = [number] ) [EOL] else : [EOL] self . data = self . station_data . lastData ( exclude = [number] ) [EOL] [EOL] newinterval = [number] [EOL] for module in self . data : [EOL] if [string] in self . data [ module ] : [EOL] newinterval = self . data [ module ] [ [string] ] [EOL] break [EOL] if newinterval : [EOL] [comment] [EOL] newinterval += NETATMO_UPDATE_INTERVAL - time ( ) [EOL] if newinterval > NETATMO_UPDATE_INTERVAL - [number] : [EOL] newinterval = NETATMO_UPDATE_INTERVAL [EOL] else : [EOL] if newinterval < NETATMO_UPDATE_INTERVAL / [number] : [EOL] [comment] [EOL] [comment] [EOL] newinterval = NETATMO_UPDATE_INTERVAL / [number] [EOL] _LOGGER . info ( [string] , newinterval ) [EOL] else : [EOL] [comment] [EOL] newinterval = NETATMO_UPDATE_INTERVAL [EOL] [EOL] self . _next_update = time ( ) + newinterval [EOL] finally : [EOL] self . _update_in_progress . release ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] import json [EOL] [EOL] import voluptuous as vol [EOL] import requests [EOL] from requests . auth import HTTPBasicAuth , HTTPDigestAuth [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_AUTHENTICATION , CONF_FORCE_UPDATE , CONF_HEADERS , CONF_NAME , CONF_METHOD , CONF_PASSWORD , CONF_PAYLOAD , CONF_RESOURCE , CONF_UNIT_OF_MEASUREMENT , CONF_USERNAME , CONF_VALUE_TEMPLATE , CONF_VERIFY_SSL , HTTP_BASIC_AUTHENTICATION , HTTP_DIGEST_AUTHENTICATION , STATE_UNKNOWN ) [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_METHOD = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_VERIFY_SSL = True [EOL] DEFAULT_FORCE_UPDATE = False [EOL] [EOL] CONF_JSON_ATTRS = [string] [EOL] METHODS = [ [string] , [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_RESOURCE ) : cv . url , vol . Optional ( CONF_AUTHENTICATION ) : vol . In ( [ HTTP_BASIC_AUTHENTICATION , HTTP_DIGEST_AUTHENTICATION ] ) , vol . Optional ( CONF_HEADERS ) : vol . Schema ( { cv . string : cv . string } ) , vol . Optional ( CONF_JSON_ATTRS , default = [ ] ) : cv . ensure_list_csv , vol . Optional ( CONF_METHOD , default = DEFAULT_METHOD ) : vol . In ( METHODS ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_PAYLOAD ) : cv . string , vol . Optional ( CONF_UNIT_OF_MEASUREMENT ) : cv . string , vol . Optional ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_VERIFY_SSL , default = DEFAULT_VERIFY_SSL ) : cv . boolean , vol . Optional ( CONF_FORCE_UPDATE , default = DEFAULT_FORCE_UPDATE ) : cv . boolean , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] resource = config . get ( CONF_RESOURCE ) [EOL] method = config . get ( CONF_METHOD ) [EOL] payload = config . get ( CONF_PAYLOAD ) [EOL] verify_ssl = config . get ( CONF_VERIFY_SSL ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] headers = config . get ( CONF_HEADERS ) [EOL] unit = config . get ( CONF_UNIT_OF_MEASUREMENT ) [EOL] value_template = config . get ( CONF_VALUE_TEMPLATE ) [EOL] json_attrs = config . get ( CONF_JSON_ATTRS ) [EOL] force_update = config . get ( CONF_FORCE_UPDATE ) [EOL] [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] if username and password : [EOL] if config . get ( CONF_AUTHENTICATION ) == HTTP_DIGEST_AUTHENTICATION : [EOL] auth = HTTPDigestAuth ( username , password ) [EOL] else : [EOL] auth = HTTPBasicAuth ( username , password ) [EOL] else : [EOL] auth = None [EOL] rest = RestData ( method , resource , auth , headers , payload , verify_ssl ) [EOL] rest . update ( ) [EOL] [EOL] add_entities ( [ RestSensor ( hass , rest , name , unit , value_template , json_attrs , force_update ) ] , True ) [EOL] [EOL] [EOL] class RestSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , rest , name , unit_of_measurement , value_template , json_attrs , force_update ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . rest = rest [EOL] self . _name = name [EOL] self . _state = STATE_UNKNOWN [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . _value_template = value_template [EOL] self . _json_attrs = json_attrs [EOL] self . _attributes = None [EOL] self . _force_update = force_update [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . rest . data is not None [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def force_update ( self ) : [EOL] [docstring] [EOL] return self . _force_update [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . rest . update ( ) [EOL] value = self . rest . data [EOL] [EOL] if self . _json_attrs : [EOL] self . _attributes = { } [EOL] if value : [EOL] try : [EOL] json_dict = json . loads ( value ) [EOL] if isinstance ( json_dict , dict ) : [EOL] attrs = { k : json_dict [ k ] for k in self . _json_attrs if k in json_dict } [EOL] self . _attributes = attrs [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL] except ValueError : [EOL] _LOGGER . warning ( [string] ) [EOL] _LOGGER . debug ( [string] , value ) [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL] if value is None : [EOL] value = STATE_UNKNOWN [EOL] elif self . _value_template is not None : [EOL] value = self . _value_template . render_with_possible_json_value ( value , STATE_UNKNOWN ) [EOL] [EOL] self . _state = value [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attributes [EOL] [EOL] [EOL] class RestData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , method , resource , auth , headers , data , verify_ssl ) : [EOL] [docstring] [EOL] self . _request = requests . Request ( method , resource , headers = headers , auth = auth , data = data ) . prepare ( ) [EOL] self . _verify_ssl = verify_ssl [EOL] self . data = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] with requests . Session ( ) as sess : [EOL] response = sess . send ( self . _request , timeout = [number] , verify = self . _verify_ssl ) [EOL] [EOL] self . data = response . text [EOL] except requests . exceptions . RequestException as ex : [EOL] _LOGGER . error ( [string] , self . _request , self . _request . url , ex ) [EOL] self . data = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . util import slugify [EOL] from homeassistant . helpers . dispatcher import ( dispatcher_connect , dispatcher_send ) [EOL] from homeassistant . components . volvooncall import DATA_KEY , SIGNAL_VEHICLE_SEEN [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_scanner ( hass , config , see , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] vin , _ = discovery_info [EOL] voc = hass . data [ DATA_KEY ] [EOL] vehicle = voc . vehicles [ vin ] [EOL] [EOL] def see_vehicle ( vehicle ) : [EOL] [docstring] [EOL] host_name = voc . vehicle_name ( vehicle ) [EOL] dev_id = [string] . format ( slugify ( host_name ) ) [EOL] see ( dev_id = dev_id , host_name = host_name , gps = ( vehicle . position [ [string] ] , vehicle . position [ [string] ] ) , icon = [string] ) [EOL] [EOL] dispatcher_connect ( hass , SIGNAL_VEHICLE_SEEN , see_vehicle ) [EOL] dispatcher_send ( hass , SIGNAL_VEHICLE_SEEN , vehicle ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Generator , Dict , Any [EOL] import logging [EOL] import homeassistant [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import random [EOL] import os [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_USERNAME , CONF_PASSWORD [EOL] from homeassistant . components . device_tracker import ( PLATFORM_SCHEMA , DOMAIN , ATTR_ATTRIBUTES , ENTITY_ID_FORMAT , DeviceScanner ) [EOL] from homeassistant . components . zone . zone import active_zone [EOL] from homeassistant . helpers . event import track_utc_time_change [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import slugify [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . util . location import distance [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] CONF_ACCOUNTNAME = [string] [EOL] CONF_MAX_INTERVAL = [string] [EOL] CONF_GPS_ACCURACY_THRESHOLD = [string] [EOL] [EOL] [comment] [EOL] ATTR_ACCOUNTNAME = [string] [EOL] ATTR_INTERVAL = [string] [EOL] ATTR_DEVICENAME = [string] [EOL] ATTR_BATTERY = [string] [EOL] ATTR_DISTANCE = [string] [EOL] ATTR_DEVICESTATUS = [string] [EOL] ATTR_LOWPOWERMODE = [string] [EOL] ATTR_BATTERYSTATUS = [string] [EOL] [EOL] ICLOUDTRACKERS = { } [EOL] [EOL] _CONFIGURING = { } [EOL] [EOL] DEVICESTATUSSET = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] DEVICESTATUSCODES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] SERVICE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ACCOUNTNAME ) : vol . All ( cv . ensure_list , [ cv . slugify ] ) , vol . Optional ( ATTR_DEVICENAME ) : cv . slugify , vol . Optional ( ATTR_INTERVAL ) : cv . positive_int } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( ATTR_ACCOUNTNAME ) : cv . slugify , vol . Optional ( CONF_MAX_INTERVAL , default = [number] ) : cv . positive_int , vol . Optional ( CONF_GPS_ACCURACY_THRESHOLD , default = [number] ) : cv . positive_int } ) [EOL] [EOL] [EOL] def setup_scanner ( hass , config , see , discovery_info = None ) : [EOL] [docstring] [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] account = config . get ( CONF_ACCOUNTNAME , slugify ( username . partition ( [string] ) [ [number] ] ) ) [EOL] max_interval = config . get ( CONF_MAX_INTERVAL ) [EOL] gps_accuracy_threshold = config . get ( CONF_GPS_ACCURACY_THRESHOLD ) [EOL] [EOL] icloudaccount = Icloud ( hass , username , password , account , max_interval , gps_accuracy_threshold , see ) [EOL] [EOL] if icloudaccount . api is not None : [EOL] ICLOUDTRACKERS [ account ] = icloudaccount [EOL] [EOL] else : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] def lost_iphone ( call ) : [EOL] [docstring] [EOL] accounts = call . data . get ( ATTR_ACCOUNTNAME , ICLOUDTRACKERS ) [EOL] devicename = call . data . get ( ATTR_DEVICENAME ) [EOL] for account in accounts : [EOL] if account in ICLOUDTRACKERS : [EOL] ICLOUDTRACKERS [ account ] . lost_iphone ( devicename ) [EOL] [EOL] hass . services . register ( DOMAIN , [string] , lost_iphone , schema = SERVICE_SCHEMA ) [EOL] [EOL] def update_icloud ( call ) : [EOL] [docstring] [EOL] accounts = call . data . get ( ATTR_ACCOUNTNAME , ICLOUDTRACKERS ) [EOL] devicename = call . data . get ( ATTR_DEVICENAME ) [EOL] for account in accounts : [EOL] if account in ICLOUDTRACKERS : [EOL] ICLOUDTRACKERS [ account ] . update_icloud ( devicename ) [EOL] [EOL] hass . services . register ( DOMAIN , [string] , update_icloud , schema = SERVICE_SCHEMA ) [EOL] [EOL] def reset_account_icloud ( call ) : [EOL] [docstring] [EOL] accounts = call . data . get ( ATTR_ACCOUNTNAME , ICLOUDTRACKERS ) [EOL] for account in accounts : [EOL] if account in ICLOUDTRACKERS : [EOL] ICLOUDTRACKERS [ account ] . reset_account_icloud ( ) [EOL] [EOL] hass . services . register ( DOMAIN , [string] , reset_account_icloud , schema = SERVICE_SCHEMA ) [EOL] [EOL] def setinterval ( call ) : [EOL] [docstring] [EOL] accounts = call . data . get ( ATTR_ACCOUNTNAME , ICLOUDTRACKERS ) [EOL] interval = call . data . get ( ATTR_INTERVAL ) [EOL] devicename = call . data . get ( ATTR_DEVICENAME ) [EOL] for account in accounts : [EOL] if account in ICLOUDTRACKERS : [EOL] ICLOUDTRACKERS [ account ] . setinterval ( interval , devicename ) [EOL] [EOL] hass . services . register ( DOMAIN , [string] , setinterval , schema = SERVICE_SCHEMA ) [EOL] [EOL] [comment] [EOL] return True [EOL] [EOL] [EOL] class Icloud ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , username , password , name , max_interval , gps_accuracy_threshold , see ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . username = username [EOL] self . password = password [EOL] self . api = None [EOL] self . accountname = name [EOL] self . devices = { } [EOL] self . seen_devices = { } [EOL] self . _overridestates = { } [EOL] self . _intervals = { } [EOL] self . _max_interval = max_interval [EOL] self . _gps_accuracy_threshold = gps_accuracy_threshold [EOL] self . see = see [EOL] [EOL] self . _trusted_device = None [EOL] self . _verification_code = None [EOL] [EOL] self . _attrs = { } [EOL] self . _attrs [ ATTR_ACCOUNTNAME ] = name [EOL] [EOL] self . reset_account_icloud ( ) [EOL] [EOL] randomseconds = random . randint ( [number] , [number] ) [EOL] track_utc_time_change ( self . hass , self . keep_alive , second = randomseconds ) [EOL] [EOL] def reset_account_icloud ( self ) : [EOL] [docstring] [EOL] from pyicloud import PyiCloudService [EOL] from pyicloud . exceptions import ( PyiCloudFailedLoginException , PyiCloudNoDevicesException ) [EOL] [EOL] icloud_dir = self . hass . config . path ( [string] ) [EOL] if not os . path . exists ( icloud_dir ) : [EOL] os . makedirs ( icloud_dir ) [EOL] [EOL] try : [EOL] self . api = PyiCloudService ( self . username , self . password , cookie_directory = icloud_dir , verify = True ) [EOL] except PyiCloudFailedLoginException as error : [EOL] self . api = None [EOL] _LOGGER . error ( [string] , error ) [EOL] return [EOL] [EOL] try : [EOL] self . devices = { } [EOL] self . _overridestates = { } [EOL] self . _intervals = { } [EOL] for device in self . api . devices : [EOL] status = device . status ( DEVICESTATUSSET ) [EOL] devicename = slugify ( status [ [string] ] . replace ( [string] , [string] , [number] ) ) [EOL] if devicename in self . devices : [EOL] _LOGGER . error ( [string] , devicename ) [EOL] continue [EOL] self . devices [ devicename ] = device [EOL] self . _intervals [ devicename ] = [number] [EOL] self . _overridestates [ devicename ] = None [EOL] except PyiCloudNoDevicesException : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def icloud_trusted_device_callback ( self , callback_data ) : [EOL] [docstring] [EOL] self . _trusted_device = int ( callback_data . get ( [string] ) ) [EOL] self . _trusted_device = self . api . trusted_devices [ self . _trusted_device ] [EOL] [EOL] if not self . api . send_verification_code ( self . _trusted_device ) : [EOL] _LOGGER . error ( [string] ) [EOL] self . _trusted_device = None [EOL] return [EOL] [EOL] if self . accountname in _CONFIGURING : [EOL] request_id = _CONFIGURING . pop ( self . accountname ) [EOL] configurator = self . hass . components . configurator [EOL] configurator . request_done ( request_id ) [EOL] [EOL] [comment] [EOL] self . icloud_need_verification_code ( ) [EOL] [EOL] def icloud_need_trusted_device ( self ) : [EOL] [docstring] [EOL] configurator = self . hass . components . configurator [EOL] if self . accountname in _CONFIGURING : [EOL] return [EOL] [EOL] devicesstring = [string] [EOL] devices = self . api . trusted_devices [EOL] for i , device in enumerate ( devices ) : [EOL] devicename = device . get ( [string] , [string] % device . get ( [string] ) ) [EOL] devicesstring += [string] . format ( i , devicename ) [EOL] [EOL] _CONFIGURING [ self . accountname ] = configurator . request_config ( [string] . format ( self . accountname ) , self . icloud_trusted_device_callback , description = ( [string] [string] + devicesstring ) , entity_picture = [string] , submit_caption = [string] , fields = [ { [string] : [string] , [string] : [string] } ] ) [EOL] [EOL] def icloud_verification_callback ( self , callback_data ) : [EOL] [docstring] [EOL] from pyicloud . exceptions import PyiCloudException [EOL] self . _verification_code = callback_data . get ( [string] ) [EOL] [EOL] try : [EOL] if not self . api . validate_verification_code ( self . _trusted_device , self . _verification_code ) : [EOL] raise PyiCloudException ( [string] ) [EOL] except PyiCloudException as error : [EOL] [comment] [EOL] _LOGGER . error ( [string] , error ) [EOL] self . _trusted_device = None [EOL] self . _verification_code = None [EOL] [EOL] [comment] [EOL] self . icloud_need_trusted_device ( ) [EOL] [EOL] if self . accountname in _CONFIGURING : [EOL] request_id = _CONFIGURING . pop ( self . accountname ) [EOL] configurator = self . hass . components . configurator [EOL] configurator . request_done ( request_id ) [EOL] [EOL] def icloud_need_verification_code ( self ) : [EOL] [docstring] [EOL] configurator = self . hass . components . configurator [EOL] if self . accountname in _CONFIGURING : [EOL] return [EOL] [EOL] _CONFIGURING [ self . accountname ] = configurator . request_config ( [string] . format ( self . accountname ) , self . icloud_verification_callback , description = ( [string] ) , entity_picture = [string] , submit_caption = [string] , fields = [ { [string] : [string] , [string] : [string] } ] ) [EOL] [EOL] def keep_alive ( self , now ) : [EOL] [docstring] [EOL] if self . api is None : [EOL] self . reset_account_icloud ( ) [EOL] [EOL] if self . api is None : [EOL] return [EOL] [EOL] if self . api . requires_2fa : [EOL] from pyicloud . exceptions import PyiCloudException [EOL] try : [EOL] if self . _trusted_device is None : [EOL] self . icloud_need_trusted_device ( ) [EOL] return [EOL] [EOL] if self . _verification_code is None : [EOL] self . icloud_need_verification_code ( ) [EOL] return [EOL] [EOL] self . api . authenticate ( ) [EOL] if self . api . requires_2fa : [EOL] raise Exception ( [string] ) [EOL] [EOL] self . _trusted_device = None [EOL] self . _verification_code = None [EOL] except PyiCloudException as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] else : [EOL] self . api . authenticate ( ) [EOL] [EOL] currentminutes = dt_util . now ( ) . hour * [number] + dt_util . now ( ) . minute [EOL] try : [EOL] for devicename in self . devices : [EOL] interval = self . _intervals . get ( devicename , [number] ) [EOL] if ( ( currentminutes % interval == [number] ) or ( interval > [number] and currentminutes % interval in [ [number] , [number] ] ) ) : [EOL] self . update_device ( devicename ) [EOL] except ValueError : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] def determine_interval ( self , devicename , latitude , longitude , battery ) : [EOL] [docstring] [EOL] currentzone = active_zone ( self . hass , latitude , longitude ) [EOL] [EOL] if ( ( currentzone is not None and currentzone == self . _overridestates . get ( devicename ) ) or ( currentzone is None and self . _overridestates . get ( devicename ) == [string] ) ) : [EOL] return [EOL] [EOL] zones = ( self . hass . states . get ( entity_id ) for entity_id in sorted ( self . hass . states . entity_ids ( [string] ) ) ) [EOL] [EOL] distances = [ ] [EOL] for zone_state in zones : [EOL] zone_state_lat = zone_state . attributes [ [string] ] [EOL] zone_state_long = zone_state . attributes [ [string] ] [EOL] zone_distance = distance ( latitude , longitude , zone_state_lat , zone_state_long ) [EOL] distances . append ( round ( zone_distance / [number] , [number] ) ) [EOL] [EOL] if distances : [EOL] mindistance = min ( distances ) [EOL] else : [EOL] mindistance = None [EOL] [EOL] self . _overridestates [ devicename ] = None [EOL] [EOL] if currentzone is not None : [EOL] self . _intervals [ devicename ] = self . _max_interval [EOL] return [EOL] [EOL] if mindistance is None : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] interval = round ( mindistance / [number] , [number] ) [EOL] [EOL] [comment] [EOL] interval = max ( interval , [number] ) [EOL] [EOL] if interval > [number] : [EOL] [comment] [EOL] interval = [number] [EOL] [EOL] if battery is not None and battery <= [number] and mindistance > [number] : [EOL] [comment] [EOL] interval = interval * [number] [EOL] [EOL] self . _intervals [ devicename ] = interval [EOL] [EOL] def update_device ( self , devicename ) : [EOL] [docstring] [EOL] from pyicloud . exceptions import PyiCloudNoDevicesException [EOL] [EOL] [comment] [EOL] [comment] [EOL] entity = self . hass . states . get ( ENTITY_ID_FORMAT . format ( devicename ) ) [EOL] if entity is None and devicename in self . seen_devices : [EOL] return [EOL] attrs = { } [EOL] kwargs = { } [EOL] [EOL] if self . api is None : [EOL] return [EOL] [EOL] try : [EOL] for device in self . api . devices : [EOL] if str ( device ) != str ( self . devices [ devicename ] ) : [EOL] continue [EOL] [EOL] status = device . status ( DEVICESTATUSSET ) [EOL] dev_id = status [ [string] ] . replace ( [string] , [string] , [number] ) [EOL] dev_id = slugify ( dev_id ) [EOL] attrs [ ATTR_DEVICESTATUS ] = DEVICESTATUSCODES . get ( status [ [string] ] , [string] ) [EOL] attrs [ ATTR_LOWPOWERMODE ] = status [ [string] ] [EOL] attrs [ ATTR_BATTERYSTATUS ] = status [ [string] ] [EOL] attrs [ ATTR_ACCOUNTNAME ] = self . accountname [EOL] status = device . status ( DEVICESTATUSSET ) [EOL] battery = status . get ( [string] , [number] ) * [number] [EOL] location = status [ [string] ] [EOL] if location and location [ [string] ] : [EOL] horizontal_accuracy = int ( location [ [string] ] ) [EOL] if horizontal_accuracy < self . _gps_accuracy_threshold : [EOL] self . determine_interval ( devicename , location [ [string] ] , location [ [string] ] , battery ) [EOL] interval = self . _intervals . get ( devicename , [number] ) [EOL] attrs [ ATTR_INTERVAL ] = interval [EOL] accuracy = location [ [string] ] [EOL] kwargs [ [string] ] = dev_id [EOL] kwargs [ [string] ] = status [ [string] ] [EOL] kwargs [ [string] ] = ( location [ [string] ] , location [ [string] ] ) [EOL] kwargs [ [string] ] = battery [EOL] kwargs [ [string] ] = accuracy [EOL] kwargs [ ATTR_ATTRIBUTES ] = attrs [EOL] self . see ( ** kwargs ) [EOL] self . seen_devices [ devicename ] = True [EOL] except PyiCloudNoDevicesException : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def lost_iphone ( self , devicename ) : [EOL] [docstring] [EOL] if self . api is None : [EOL] return [EOL] [EOL] self . api . authenticate ( ) [EOL] [EOL] for device in self . api . devices : [EOL] if devicename is None or device == self . devices [ devicename ] : [EOL] device . play_sound ( ) [EOL] [EOL] def update_icloud ( self , devicename = None ) : [EOL] [docstring] [EOL] from pyicloud . exceptions import PyiCloudNoDevicesException [EOL] [EOL] if self . api is None : [EOL] return [EOL] [EOL] try : [EOL] if devicename is not None : [EOL] if devicename in self . devices : [EOL] self . update_device ( devicename ) [EOL] else : [EOL] _LOGGER . error ( [string] , devicename , self . _attrs [ ATTR_ACCOUNTNAME ] ) [EOL] else : [EOL] for device in self . devices : [EOL] self . update_device ( device ) [EOL] except PyiCloudNoDevicesException : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def setinterval ( self , interval = None , devicename = None ) : [EOL] [docstring] [EOL] devs = [ devicename ] if devicename else self . devices [EOL] for device in devs : [EOL] devid = [string] . format ( DOMAIN , device ) [EOL] devicestate = self . hass . states . get ( devid ) [EOL] if interval is not None : [EOL] if devicestate is not None : [EOL] self . _overridestates [ device ] = active_zone ( self . hass , float ( devicestate . attributes . get ( [string] , [number] ) ) , float ( devicestate . attributes . get ( [string] , [number] ) ) ) [EOL] if self . _overridestates [ device ] is None : [EOL] self . _overridestates [ device ] = [string] [EOL] self . _intervals [ device ] = interval [EOL] else : [EOL] self . _overridestates [ device ] = None [EOL] self . update_device ( device ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Generator , Dict , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . image_processing import ( ATTR_AGE , ATTR_GENDER , ATTR_GLASSES , CONF_ENTITY_ID , CONF_NAME , CONF_SOURCE , PLATFORM_SCHEMA , ImageProcessingFaceEntity ) [EOL] from homeassistant . components . microsoft_face import DATA_MICROSOFT_FACE [EOL] from homeassistant . core import split_entity_id [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORTED_ATTRIBUTES = [ ATTR_AGE , ATTR_GENDER , ATTR_GLASSES ] [EOL] [EOL] CONF_ATTRIBUTES = [string] [EOL] DEFAULT_ATTRIBUTES = [ ATTR_AGE , ATTR_GENDER ] [EOL] [EOL] [EOL] def validate_attributes ( list_attributes ) : [EOL] [docstring] [EOL] for attr in list_attributes : [EOL] if attr not in SUPPORTED_ATTRIBUTES : [EOL] raise vol . Invalid ( [string] . format ( attr ) ) [EOL] return list_attributes [EOL] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_ATTRIBUTES , default = DEFAULT_ATTRIBUTES ) : vol . All ( cv . ensure_list , validate_attributes ) , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] api = hass . data [ DATA_MICROSOFT_FACE ] [EOL] attributes = config [ CONF_ATTRIBUTES ] [EOL] [EOL] entities = [ ] [EOL] for camera in config [ CONF_SOURCE ] : [EOL] entities . append ( MicrosoftFaceDetectEntity ( camera [ CONF_ENTITY_ID ] , api , attributes , camera . get ( CONF_NAME ) ) ) [EOL] [EOL] async_add_entities ( entities ) [EOL] [EOL] [EOL] class MicrosoftFaceDetectEntity ( ImageProcessingFaceEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , camera_entity , api , attributes , name = None ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _api = api [EOL] self . _camera = camera_entity [EOL] self . _attributes = attributes [EOL] [EOL] if name : [EOL] self . _name = name [EOL] else : [EOL] self . _name = [string] . format ( split_entity_id ( camera_entity ) [ [number] ] ) [EOL] [EOL] @ property def camera_entity ( self ) : [EOL] [docstring] [EOL] return self . _camera [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ asyncio . coroutine def async_process_image ( self , image ) : [EOL] [docstring] [EOL] face_data = None [EOL] try : [EOL] face_data = yield from self . _api . call_api ( [string] , [string] , image , binary = True , params = { [string] : [string] . join ( self . _attributes ) } ) [EOL] [EOL] except HomeAssistantError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] return [EOL] [EOL] if not face_data : [EOL] return [EOL] [EOL] faces = [ ] [EOL] for face in face_data : [EOL] face_attr = { } [EOL] for attr in self . _attributes : [EOL] if attr in face [ [string] ] : [EOL] face_attr [ attr ] = face [ [string] ] [ attr ] [EOL] [EOL] if face_attr : [EOL] faces . append ( face_attr ) [EOL] [EOL] self . async_process_faces ( faces , len ( face_data ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_HS_COLOR , SUPPORT_BRIGHTNESS , SUPPORT_COLOR_TEMP , SUPPORT_COLOR , Light ) [EOL] [EOL] import homeassistant . util . color as color_util [EOL] [EOL] from homeassistant . util . color import ( color_temperature_mired_to_kelvin as mired_to_kelvin , color_temperature_kelvin_to_mired as kelvin_to_mired ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] EUFY_MAX_KELVIN = [number] [EOL] EUFY_MIN_KELVIN = [number] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] add_entities ( [ EufyLight ( discovery_info ) ] , True ) [EOL] [EOL] [EOL] class EufyLight ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] import lakeside [EOL] [EOL] self . _temp = None [EOL] self . _brightness = None [EOL] self . _hs = None [EOL] self . _state = None [EOL] self . _name = device [ [string] ] [EOL] self . _address = device [ [string] ] [EOL] self . _code = device [ [string] ] [EOL] self . _type = device [ [string] ] [EOL] self . _bulb = lakeside . bulb ( self . _address , self . _code , self . _type ) [EOL] self . _colormode = False [EOL] if self . _type == [string] : [EOL] self . _features = SUPPORT_BRIGHTNESS [EOL] elif self . _type == [string] : [EOL] self . _features = SUPPORT_BRIGHTNESS | SUPPORT_COLOR_TEMP [EOL] elif self . _type == [string] : [EOL] self . _features = SUPPORT_BRIGHTNESS | SUPPORT_COLOR_TEMP | SUPPORT_COLOR [EOL] self . _bulb . connect ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _bulb . update ( ) [EOL] if self . _bulb . power : [EOL] self . _brightness = self . _bulb . brightness [EOL] self . _temp = self . _bulb . temperature [EOL] if self . _bulb . colors : [EOL] self . _colormode = True [EOL] self . _hs = color_util . color_RGB_to_hs ( * self . _bulb . colors ) [EOL] else : [EOL] self . _colormode = False [EOL] self . _state = self . _bulb . power [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _address [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return int ( self . _brightness * [number] / [number] ) [EOL] [EOL] @ property def min_mireds ( self ) : [EOL] [docstring] [EOL] return kelvin_to_mired ( EUFY_MAX_KELVIN ) [EOL] [EOL] @ property def max_mireds ( self ) : [EOL] [docstring] [EOL] return kelvin_to_mired ( EUFY_MIN_KELVIN ) [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] temp_in_k = int ( EUFY_MIN_KELVIN + ( self . _temp * ( EUFY_MAX_KELVIN - EUFY_MIN_KELVIN ) / [number] ) ) [EOL] return kelvin_to_mired ( temp_in_k ) [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] if not self . _colormode : [EOL] return None [EOL] return self . _hs [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _features [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] brightness = kwargs . get ( ATTR_BRIGHTNESS ) [EOL] colortemp = kwargs . get ( ATTR_COLOR_TEMP ) [EOL] [comment] [EOL] hs = kwargs . get ( ATTR_HS_COLOR ) [EOL] [EOL] if brightness is not None : [EOL] brightness = int ( brightness * [number] / [number] ) [EOL] else : [EOL] if self . _brightness is None : [EOL] self . _brightness = [number] [EOL] brightness = self . _brightness [EOL] [EOL] if colortemp is not None : [EOL] self . _colormode = False [EOL] temp_in_k = mired_to_kelvin ( colortemp ) [EOL] relative_temp = temp_in_k - EUFY_MIN_KELVIN [EOL] temp = int ( relative_temp * [number] / ( EUFY_MAX_KELVIN - EUFY_MIN_KELVIN ) ) [EOL] else : [EOL] temp = None [EOL] [EOL] if hs is not None : [EOL] rgb = color_util . color_hsv_to_RGB ( hs [ [number] ] , hs [ [number] ] , brightness / [number] * [number] ) [EOL] self . _colormode = True [EOL] elif self . _colormode : [EOL] rgb = color_util . color_hsv_to_RGB ( self . _hs [ [number] ] , self . _hs [ [number] ] , brightness / [number] * [number] ) [EOL] else : [EOL] rgb = None [EOL] [EOL] try : [EOL] self . _bulb . set_state ( power = True , brightness = brightness , temperature = temp , colors = rgb ) [EOL] except BrokenPipeError : [EOL] self . _bulb . connect ( ) [EOL] self . _bulb . set_state ( power = True , brightness = brightness , temperature = temp , colors = rgb ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] try : [EOL] self . _bulb . set_state ( power = False ) [EOL] except BrokenPipeError : [EOL] self . _bulb . connect ( ) [EOL] self . _bulb . set_state ( power = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from subprocess import check_output , CalledProcessError , STDOUT [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_ID , CONF_DEVICES ) [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , Light , PLATFORM_SCHEMA ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_X10 = SUPPORT_BRIGHTNESS [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DEVICES ) : vol . All ( cv . ensure_list , [ { vol . Required ( CONF_ID ) : cv . string , vol . Required ( CONF_NAME ) : cv . string , } ] ) , } ) [EOL] [EOL] [EOL] def x10_command ( command ) : [EOL] [docstring] [EOL] return check_output ( [ [string] ] + command . split ( [string] ) , stderr = STDOUT ) [EOL] [EOL] [EOL] def get_unit_status ( code ) : [EOL] [docstring] [EOL] output = check_output ( [string] + code , shell = True ) [EOL] return int ( output . decode ( [string] ) [ [number] ] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] try : [EOL] x10_command ( [string] ) [EOL] except CalledProcessError as err : [EOL] _LOGGER . error ( err . output ) [EOL] return False [EOL] [EOL] add_entities ( X10Light ( light ) for light in config [ CONF_DEVICES ] ) [EOL] [EOL] [EOL] class X10Light ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , light ) : [EOL] [docstring] [EOL] self . _name = light [ [string] ] [EOL] self . _id = light [ [string] ] [EOL] self . _brightness = [number] [EOL] self . _state = False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_X10 [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] x10_command ( [string] + self . _id ) [EOL] self . _brightness = kwargs . get ( ATTR_BRIGHTNESS , [number] ) [EOL] self . _state = True [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] x10_command ( [string] + self . _id ) [EOL] self . _state = False [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _state = bool ( get_unit_status ( self . _id ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . insteon import InsteonEntity [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , Light ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] MAX_BRIGHTNESS = [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] insteon_modem = hass . data [ [string] ] . get ( [string] ) [EOL] [EOL] address = discovery_info [ [string] ] [EOL] device = insteon_modem . devices [ address ] [EOL] state_key = discovery_info [ [string] ] [EOL] [EOL] _LOGGER . debug ( [string] , device . address . hex , device . states [ state_key ] . name ) [EOL] [EOL] new_entity = InsteonDimmerDevice ( device , state_key ) [EOL] [EOL] async_add_entities ( [ new_entity ] ) [EOL] [EOL] [EOL] class InsteonDimmerDevice ( InsteonEntity , Light ) : [EOL] [docstring] [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] onlevel = self . _insteon_device_state . value [EOL] return int ( onlevel ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return bool ( self . brightness ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_BRIGHTNESS [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] brightness = int ( kwargs [ ATTR_BRIGHTNESS ] ) [EOL] self . _insteon_device_state . set_level ( brightness ) [EOL] else : [EOL] self . _insteon_device_state . on ( ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _insteon_device_state . off ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from math import ceil [EOL] from homeassistant . components . abode import AbodeDevice , DOMAIN as ABODE_DOMAIN [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_HS_COLOR , SUPPORT_BRIGHTNESS , SUPPORT_COLOR , Light ) [EOL] import homeassistant . util . color as color_util [EOL] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import abodepy . helpers . constants as CONST [EOL] [EOL] data = hass . data [ ABODE_DOMAIN ] [EOL] [EOL] device_types = [ CONST . TYPE_LIGHT , CONST . TYPE_SWITCH ] [EOL] [EOL] devices = [ ] [EOL] [EOL] [comment] [EOL] for device in data . abode . get_devices ( generic_type = device_types ) : [EOL] if data . is_excluded ( device ) or not data . is_light ( device ) : [EOL] continue [EOL] [EOL] devices . append ( AbodeLight ( data , device ) ) [EOL] [EOL] data . devices . extend ( devices ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class AbodeLight ( AbodeDevice , Light ) : [EOL] [docstring] [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ( ATTR_HS_COLOR in kwargs and self . _device . is_dimmable and self . _device . has_color ) : [EOL] self . _device . set_color ( color_util . color_hs_to_RGB ( * kwargs [ ATTR_HS_COLOR ] ) ) [EOL] [EOL] if ATTR_BRIGHTNESS in kwargs and self . _device . is_dimmable : [EOL] [comment] [EOL] [comment] [EOL] self . _device . set_level ( ceil ( kwargs [ ATTR_BRIGHTNESS ] * [number] / [number] ) ) [EOL] else : [EOL] self . _device . switch_on ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _device . switch_off ( ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _device . is_on [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] if self . _device . is_dimmable and self . _device . has_brightness : [EOL] brightness = int ( self . _device . brightness ) [EOL] [comment] [EOL] if brightness == [number] : [EOL] return [number] [EOL] [comment] [EOL] return ceil ( brightness * [number] / [number] ) [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] if self . _device . is_dimmable and self . _device . has_color : [EOL] return color_util . color_RGB_to_hs ( * self . _device . color ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] if self . _device . is_dimmable and self . _device . has_color : [EOL] return SUPPORT_BRIGHTNESS | SUPPORT_COLOR [EOL] if self . _device . is_dimmable : [EOL] return SUPPORT_BRIGHTNESS [EOL] [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , Light ) [EOL] from homeassistant . components . lutron import ( LutronDevice , LUTRON_DEVICES , LUTRON_CONTROLLER ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devs = [ ] [EOL] for ( area_name , device ) in hass . data [ LUTRON_DEVICES ] [ [string] ] : [EOL] dev = LutronLight ( area_name , device , hass . data [ LUTRON_CONTROLLER ] ) [EOL] devs . append ( dev ) [EOL] [EOL] add_entities ( devs , True ) [EOL] return True [EOL] [EOL] [EOL] def to_lutron_level ( level ) : [EOL] [docstring] [EOL] return float ( ( level * [number] ) / [number] ) [EOL] [EOL] [EOL] def to_hass_level ( level ) : [EOL] [docstring] [EOL] return int ( ( level * [number] ) / [number] ) [EOL] [EOL] [EOL] class LutronLight ( LutronDevice , Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , area_name , lutron_device , controller ) : [EOL] [docstring] [EOL] self . _prev_brightness = None [EOL] LutronDevice . __init__ ( self , area_name , lutron_device , controller ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_BRIGHTNESS [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] new_brightness = to_hass_level ( self . _lutron_device . last_level ( ) ) [EOL] if new_brightness != [number] : [EOL] self . _prev_brightness = new_brightness [EOL] return new_brightness [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_BRIGHTNESS in kwargs and self . _lutron_device . is_dimmable : [EOL] brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] elif self . _prev_brightness == [number] : [EOL] brightness = [number] / [number] [EOL] else : [EOL] brightness = self . _prev_brightness [EOL] self . _prev_brightness = brightness [EOL] self . _lutron_device . level = to_lutron_level ( brightness ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _lutron_device . level = [number] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = { } [EOL] attr [ [string] ] = self . _lutron_device . id [EOL] return attr [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _lutron_device . last_level ( ) > [number] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . _prev_brightness is None : [EOL] self . _prev_brightness = to_hass_level ( self . _lutron_device . level ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . climate import ( PLATFORM_SCHEMA , SUPPORT_OPERATION_MODE , SUPPORT_TARGET_TEMPERATURE , ClimateDevice ) [EOL] from homeassistant . components . knx import ATTR_DISCOVER_DEVICES , DATA_KNX [EOL] from homeassistant . const import ATTR_TEMPERATURE , CONF_NAME , TEMP_CELSIUS [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] CONF_SETPOINT_SHIFT_ADDRESS = [string] [EOL] CONF_SETPOINT_SHIFT_STATE_ADDRESS = [string] [EOL] CONF_SETPOINT_SHIFT_STEP = [string] [EOL] CONF_SETPOINT_SHIFT_MAX = [string] [EOL] CONF_SETPOINT_SHIFT_MIN = [string] [EOL] CONF_TEMPERATURE_ADDRESS = [string] [EOL] CONF_TARGET_TEMPERATURE_ADDRESS = [string] [EOL] CONF_OPERATION_MODE_ADDRESS = [string] [EOL] CONF_OPERATION_MODE_STATE_ADDRESS = [string] [EOL] CONF_CONTROLLER_STATUS_ADDRESS = [string] [EOL] CONF_CONTROLLER_STATUS_STATE_ADDRESS = [string] [EOL] CONF_OPERATION_MODE_FROST_PROTECTION_ADDRESS = [string] [EOL] CONF_OPERATION_MODE_NIGHT_ADDRESS = [string] [EOL] CONF_OPERATION_MODE_COMFORT_ADDRESS = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_SETPOINT_SHIFT_STEP = [number] [EOL] DEFAULT_SETPOINT_SHIFT_MAX = [number] [EOL] DEFAULT_SETPOINT_SHIFT_MIN = - [number] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Required ( CONF_TEMPERATURE_ADDRESS ) : cv . string , vol . Required ( CONF_TARGET_TEMPERATURE_ADDRESS ) : cv . string , vol . Optional ( CONF_SETPOINT_SHIFT_ADDRESS ) : cv . string , vol . Optional ( CONF_SETPOINT_SHIFT_STATE_ADDRESS ) : cv . string , vol . Optional ( CONF_SETPOINT_SHIFT_STEP , default = DEFAULT_SETPOINT_SHIFT_STEP ) : vol . All ( float , vol . Range ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_SETPOINT_SHIFT_MAX , default = DEFAULT_SETPOINT_SHIFT_MAX ) : vol . All ( int , vol . Range ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_SETPOINT_SHIFT_MIN , default = DEFAULT_SETPOINT_SHIFT_MIN ) : vol . All ( int , vol . Range ( min = - [number] , max = [number] ) ) , vol . Optional ( CONF_OPERATION_MODE_ADDRESS ) : cv . string , vol . Optional ( CONF_OPERATION_MODE_STATE_ADDRESS ) : cv . string , vol . Optional ( CONF_CONTROLLER_STATUS_ADDRESS ) : cv . string , vol . Optional ( CONF_CONTROLLER_STATUS_STATE_ADDRESS ) : cv . string , vol . Optional ( CONF_OPERATION_MODE_FROST_PROTECTION_ADDRESS ) : cv . string , vol . Optional ( CONF_OPERATION_MODE_NIGHT_ADDRESS ) : cv . string , vol . Optional ( CONF_OPERATION_MODE_COMFORT_ADDRESS ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is not None : [EOL] async_add_entities_discovery ( hass , discovery_info , async_add_entities ) [EOL] else : [EOL] async_add_entities_config ( hass , config , async_add_entities ) [EOL] [EOL] [EOL] @ callback def async_add_entities_discovery ( hass , discovery_info , async_add_entities ) : [EOL] [docstring] [EOL] entities = [ ] [EOL] for device_name in discovery_info [ ATTR_DISCOVER_DEVICES ] : [EOL] device = hass . data [ DATA_KNX ] . xknx . devices [ device_name ] [EOL] entities . append ( KNXClimate ( hass , device ) ) [EOL] async_add_entities ( entities ) [EOL] [EOL] [EOL] @ callback def async_add_entities_config ( hass , config , async_add_entities ) : [EOL] [docstring] [EOL] import xknx [EOL] [EOL] climate = xknx . devices . Climate ( hass . data [ DATA_KNX ] . xknx , name = config . get ( CONF_NAME ) , group_address_temperature = config . get ( CONF_TEMPERATURE_ADDRESS ) , group_address_target_temperature = config . get ( CONF_TARGET_TEMPERATURE_ADDRESS ) , group_address_setpoint_shift = config . get ( CONF_SETPOINT_SHIFT_ADDRESS ) , group_address_setpoint_shift_state = config . get ( CONF_SETPOINT_SHIFT_STATE_ADDRESS ) , setpoint_shift_step = config . get ( CONF_SETPOINT_SHIFT_STEP ) , setpoint_shift_max = config . get ( CONF_SETPOINT_SHIFT_MAX ) , setpoint_shift_min = config . get ( CONF_SETPOINT_SHIFT_MIN ) , group_address_operation_mode = config . get ( CONF_OPERATION_MODE_ADDRESS ) , group_address_operation_mode_state = config . get ( CONF_OPERATION_MODE_STATE_ADDRESS ) , group_address_controller_status = config . get ( CONF_CONTROLLER_STATUS_ADDRESS ) , group_address_controller_status_state = config . get ( CONF_CONTROLLER_STATUS_STATE_ADDRESS ) , group_address_operation_mode_protection = config . get ( CONF_OPERATION_MODE_FROST_PROTECTION_ADDRESS ) , group_address_operation_mode_night = config . get ( CONF_OPERATION_MODE_NIGHT_ADDRESS ) , group_address_operation_mode_comfort = config . get ( CONF_OPERATION_MODE_COMFORT_ADDRESS ) ) [EOL] hass . data [ DATA_KNX ] . xknx . devices . add ( climate ) [EOL] async_add_entities ( [ KNXClimate ( hass , climate ) ] ) [EOL] [EOL] [EOL] class KNXClimate ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device ) : [EOL] [docstring] [EOL] self . device = device [EOL] self . hass = hass [EOL] self . async_register_callbacks ( ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] support = SUPPORT_TARGET_TEMPERATURE [EOL] if self . device . supports_operation_mode : [EOL] support |= SUPPORT_OPERATION_MODE [EOL] return support [EOL] [EOL] def async_register_callbacks ( self ) : [EOL] [docstring] [EOL] async def after_update_callback ( device ) : [EOL] [docstring] [EOL] await self . async_update_ha_state ( ) [EOL] self . device . register_device_updated_cb ( after_update_callback ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . device . name [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . hass . data [ DATA_KNX ] . connected [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . device . temperature . value [EOL] [EOL] @ property def target_temperature_step ( self ) : [EOL] [docstring] [EOL] return self . device . setpoint_shift_step [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . device . target_temperature . value [EOL] [EOL] @ property def min_temp ( self ) : [EOL] [docstring] [EOL] return self . device . target_temperature_min [EOL] [EOL] @ property def max_temp ( self ) : [EOL] [docstring] [EOL] return self . device . target_temperature_max [EOL] [EOL] async def async_set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if temperature is None : [EOL] return [EOL] await self . device . set_target_temperature ( temperature ) [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] if self . device . supports_operation_mode : [EOL] return self . device . operation_mode . value [EOL] return None [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return [ operation_mode . value for operation_mode in self . device . get_supported_operation_modes ( ) ] [EOL] [EOL] async def async_set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] if self . device . supports_operation_mode : [EOL] from xknx . knx import HVACOperationMode [EOL] knx_operation_mode = HVACOperationMode ( operation_mode ) [EOL] await self . device . set_operation_mode ( knx_operation_mode ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . climate import ( ATTR_TEMPERATURE , STATE_COOL , STATE_ECO , STATE_HEAT , STATE_PERFORMANCE , SUPPORT_OPERATION_MODE , SUPPORT_TARGET_TEMPERATURE , ClimateDevice ) [EOL] import homeassistant . components . toon as toon_main [EOL] from homeassistant . const import TEMP_CELSIUS [EOL] [EOL] SUPPORT_FLAGS = SUPPORT_TARGET_TEMPERATURE | SUPPORT_OPERATION_MODE [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] add_entities ( [ ThermostatDevice ( hass ) ] , True ) [EOL] [EOL] [EOL] class ThermostatDevice ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass ) : [EOL] [docstring] [EOL] self . _name = [string] [EOL] self . hass = hass [EOL] self . thermos = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] self . _state = None [EOL] self . _temperature = None [EOL] self . _setpoint = None [EOL] self . _operation_list = [ STATE_PERFORMANCE , STATE_HEAT , STATE_ECO , STATE_COOL , ] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_FLAGS [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] state = self . thermos . get_data ( [string] ) [EOL] return state [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return self . _operation_list [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . thermos . get_data ( [string] ) [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . thermos . get_data ( [string] ) [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temp = kwargs . get ( ATTR_TEMPERATURE ) [EOL] self . thermos . set_temp ( temp ) [EOL] [EOL] def set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] toonlib_values = { STATE_PERFORMANCE : [string] , STATE_HEAT : [string] , STATE_ECO : [string] , STATE_COOL : [string] , } [EOL] [EOL] self . thermos . set_state ( toonlib_values [ operation_mode ] ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . thermos . update ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . homekit_controller import ( HomeKitEntity , KNOWN_ACCESSORIES ) [EOL] from homeassistant . components . climate import ( ClimateDevice , STATE_HEAT , STATE_COOL , STATE_IDLE , SUPPORT_TARGET_TEMPERATURE , SUPPORT_OPERATION_MODE ) [EOL] from homeassistant . const import TEMP_CELSIUS , STATE_OFF , ATTR_TEMPERATURE [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] MODE_HOMEKIT_TO_HASS = { [number] : STATE_OFF , [number] : STATE_HEAT , [number] : STATE_COOL , } [EOL] [EOL] [comment] [EOL] MODE_HASS_TO_HOMEKIT = { v : k for k , v in MODE_HOMEKIT_TO_HASS . items ( ) } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is not None : [EOL] accessory = hass . data [ KNOWN_ACCESSORIES ] [ discovery_info [ [string] ] ] [EOL] add_entities ( [ HomeKitClimateDevice ( accessory , discovery_info ) ] , True ) [EOL] [EOL] [EOL] class HomeKitClimateDevice ( HomeKitEntity , ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( * args ) [EOL] self . _state = None [EOL] self . _current_mode = None [EOL] self . _valid_modes = [ ] [EOL] self . _current_temp = None [EOL] self . _target_temp = None [EOL] [EOL] def update_characteristics ( self , characteristics ) : [EOL] [docstring] [EOL] [comment] [EOL] from homekit import CharacteristicsTypes as ctypes [EOL] [EOL] for characteristic in characteristics : [EOL] ctype = characteristic [ [string] ] [EOL] if ctype == ctypes . HEATING_COOLING_CURRENT : [EOL] self . _state = MODE_HOMEKIT_TO_HASS . get ( characteristic [ [string] ] ) [EOL] if ctype == ctypes . HEATING_COOLING_TARGET : [EOL] self . _chars [ [string] ] = characteristic [ [string] ] [EOL] self . _features |= SUPPORT_OPERATION_MODE [EOL] self . _current_mode = MODE_HOMEKIT_TO_HASS . get ( characteristic [ [string] ] ) [EOL] self . _valid_modes = [ MODE_HOMEKIT_TO_HASS . get ( mode ) for mode in characteristic [ [string] ] ] [EOL] elif ctype == ctypes . TEMPERATURE_CURRENT : [EOL] self . _current_temp = characteristic [ [string] ] [EOL] elif ctype == ctypes . TEMPERATURE_TARGET : [EOL] self . _chars [ [string] ] = characteristic [ [string] ] [EOL] self . _features |= SUPPORT_TARGET_TEMPERATURE [EOL] self . _target_temp = characteristic [ [string] ] [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temp = kwargs . get ( ATTR_TEMPERATURE ) [EOL] [EOL] characteristics = [ { [string] : self . _aid , [string] : self . _chars [ [string] ] , [string] : temp } ] [EOL] self . put_characteristics ( characteristics ) [EOL] [EOL] def set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] characteristics = [ { [string] : self . _aid , [string] : self . _chars [ [string] ] , [string] : MODE_HASS_TO_HOMEKIT [ operation_mode ] } ] [EOL] self . put_characteristics ( characteristics ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if self . _current_mode == STATE_OFF : [EOL] return STATE_OFF [EOL] [EOL] if self . _state == STATE_OFF and self . _current_mode != STATE_OFF : [EOL] return STATE_IDLE [EOL] return self . _state [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . _current_temp [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . _target_temp [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] return self . _current_mode [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return self . _valid_modes [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _features [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . climate import ( ATTR_OPERATION_MODE , PLATFORM_SCHEMA , STATE_COOL , STATE_DRY , STATE_FAN_ONLY , STATE_HEAT , SUPPORT_FAN_MODE , SUPPORT_ON_OFF , SUPPORT_OPERATION_MODE , SUPPORT_TARGET_TEMPERATURE , ClimateDevice ) [EOL] from homeassistant . const import ( ATTR_TEMPERATURE , CONF_HOST , CONF_PORT , EVENT_HOMEASSISTANT_STOP , TEMP_CELSIUS ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . dispatcher import ( async_dispatcher_connect , async_dispatcher_send ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_GATEWAY_ADDRRESS = [string] [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] SIGNAL_DEVICE_ADDED = [string] [EOL] SIGNAL_ZHONG_HONG_HUB_START = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = [number] ) : vol . Coerce ( int ) , vol . Optional ( CONF_GATEWAY_ADDRRESS , default = [number] ) : vol . Coerce ( int ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from zhong_hong_hvac . hub import ZhongHongGateway [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] gw_addr = config . get ( CONF_GATEWAY_ADDRRESS ) [EOL] hub = ZhongHongGateway ( host , port , gw_addr ) [EOL] devices = [ ZhongHongClimate ( hub , addr_out , addr_in ) for ( addr_out , addr_in ) in hub . discovery_ac ( ) ] [EOL] [EOL] _LOGGER . debug ( [string] , len ( devices ) ) [EOL] [EOL] hub_is_initialized = False [EOL] [EOL] async def startup ( ) : [EOL] [docstring] [EOL] nonlocal hub_is_initialized [EOL] if not all ( [ device . is_initialized for device in devices ] ) : [EOL] return [EOL] [EOL] if hub_is_initialized : [EOL] return [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] await hass . async_add_job ( hub . start_listen ) [EOL] await hass . async_add_job ( hub . query_all_status ) [EOL] hub_is_initialized = True [EOL] [EOL] async_dispatcher_connect ( hass , SIGNAL_DEVICE_ADDED , startup ) [EOL] [EOL] [comment] [EOL] add_entities ( devices ) [EOL] [EOL] def stop_listen ( event ) : [EOL] [docstring] [EOL] hub . stop_listen ( ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , stop_listen ) [EOL] [EOL] [EOL] class ZhongHongClimate ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hub , addr_out , addr_in ) : [EOL] [docstring] [EOL] from zhong_hong_hvac . hvac import HVAC [EOL] self . _device = HVAC ( hub , addr_out , addr_in ) [EOL] self . _hub = hub [EOL] self . _current_operation = None [EOL] self . _current_temperature = None [EOL] self . _target_temperature = None [EOL] self . _current_fan_mode = None [EOL] self . _is_on = None [EOL] self . is_initialized = False [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _device . register_update_callback ( self . _after_update ) [EOL] self . is_initialized = True [EOL] async_dispatcher_send ( self . hass , SIGNAL_DEVICE_ADDED ) [EOL] [EOL] def _after_update ( self , climate ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] if self . _device . current_operation : [EOL] self . _current_operation = self . _device . current_operation . lower ( ) [EOL] if self . _device . current_temperature : [EOL] self . _current_temperature = self . _device . current_temperature [EOL] if self . _device . current_fan_mode : [EOL] self . _current_fan_mode = self . _device . current_fan_mode [EOL] if self . _device . target_temperature : [EOL] self . _target_temperature = self . _device . target_temperature [EOL] self . _is_on = self . _device . is_on [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . unique_id [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _device . addr_out , self . _device . addr_in ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return ( SUPPORT_TARGET_TEMPERATURE | SUPPORT_FAN_MODE | SUPPORT_OPERATION_MODE | SUPPORT_ON_OFF ) [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] return self . _current_operation [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return [ STATE_COOL , STATE_HEAT , STATE_DRY , STATE_FAN_ONLY ] [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . _current_temperature [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . _target_temperature [EOL] [EOL] @ property def target_temperature_step ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _device . is_on [EOL] [EOL] @ property def current_fan_mode ( self ) : [EOL] [docstring] [EOL] return self . _current_fan_mode [EOL] [EOL] @ property def fan_list ( self ) : [EOL] [docstring] [EOL] return self . _device . fan_list [EOL] [EOL] @ property def min_temp ( self ) : [EOL] [docstring] [EOL] return self . _device . min_temp [EOL] [EOL] @ property def max_temp ( self ) : [EOL] [docstring] [EOL] return self . _device . max_temp [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] return self . _device . turn_on ( ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] return self . _device . turn_off ( ) [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if temperature is not None : [EOL] self . _device . set_temperature ( temperature ) [EOL] [EOL] operation_mode = kwargs . get ( ATTR_OPERATION_MODE ) [EOL] if operation_mode is not None : [EOL] self . set_operation_mode ( operation_mode ) [EOL] [EOL] def set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] self . _device . set_operation_mode ( operation_mode . upper ( ) ) [EOL] [EOL] def set_fan_mode ( self , fan_mode ) : [EOL] [docstring] [EOL] self . _device . set_fan_mode ( fan_mode ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0