	0
from typing import Any [EOL] import typing [EOL] import json [EOL] import botocore . vendored . requests as requests [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] def response ( msg ) : [EOL] return { [string] : [number] , [string] : json . dumps ( msg ) } [EOL] [EOL] x = requests . get ( [string] ) [EOL] [EOL] return response ( x . text )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from sceptre . hooks import Hook [EOL] from sceptre . resolvers . stack_output import StackOutput [EOL] import boto3 [EOL] [EOL] [EOL] class S3EmptyBucket ( Hook ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( S3EmptyBucket , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def run ( self ) : [EOL] try : [EOL] bucket_name = StackOutput ( argument = self . argument , connection_manager = self . connection_manager , environment_config = self . environment_config , stack_config = self . stack_config , ) . resolve ( ) [EOL] print ( f" [string] { bucket_name }" ) [EOL] s3 = self . connection_manager . boto_session . resource ( [string] ) [EOL] bucket = s3 . Bucket ( bucket_name ) [EOL] bucket . objects . all ( ) . delete ( ) [EOL] except Exception as e : [EOL] print ( e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict , Callable , Union [EOL] import builtins [EOL] import typing [EOL] import json [EOL] import boto3 [EOL] import uuid [EOL] import botocore [EOL] from aws_xray_sdk . core import xray_recorder [EOL] from aws_xray_sdk . core import patch_all [EOL] [EOL] patch_all ( ) [EOL] [EOL] dynamo = boto3 . client ( [string] ) [EOL] xray = boto3 . client ( [string] ) [EOL] [EOL] [comment] [EOL] def generate_id ( ) : [EOL] with xray_recorder . capture ( [string] ) as subsegment : [EOL] id = uuid . uuid4 ( ) [EOL] id_as_str = str ( id ) [EOL] subsegment . put_annotation ( [string] , id_as_str ) [EOL] return id_as_str [EOL] [EOL] [comment] [EOL] def insert_to_table ( ) : [EOL] with xray_recorder . capture ( [string] ) as subsegment : [EOL] id = generate_id ( ) [EOL] subsegment . put_annotation ( [string] , id ) [EOL] dynamo . put_item ( TableName = [string] , Item = { [string] : { [string] : id } } ) [EOL] [EOL] def handler ( event , context ) : [EOL] with xray_recorder . capture ( [string] ) as subsegment : [EOL] insert_to_table ( ) [EOL] response = { [string] : [number] , [string] : json . dumps ( [string] ) } [EOL] raise ValueError ( [string] ) [EOL] return response	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from sceptre . resolvers import Resolver [EOL] [EOL] [EOL] class S3Version ( Resolver ) : [EOL] NAME = [string] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( S3Version , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def resolve ( self ) : [EOL] if self . argument : [EOL] s3_bucket , s3_key = self . argument . split ( [string] , [number] ) [EOL] print ( [string] . format ( self . NAME ) ) [EOL] print ( f" [string] { s3_bucket } [string] { s3_key }" ) [EOL] elif [string] in self . stack_config : [EOL] code = self . stack_config . get ( [string] ) . get ( [string] , { } ) [EOL] s3_bucket , s3_key = [ code . get ( [string] ) , code . get ( [string] ) ] [EOL] print ( [string] . format ( self . NAME ) ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] result = self . connection_manager . call ( service = [string] , command = [string] , kwargs = { [string] : s3_bucket , [string] : s3_key } , ) [EOL] [EOL] version_id = result . get ( [string] ) [EOL] [EOL] print ( [string] . format ( self . NAME , s3_bucket , s3_key , version_id ) ) [EOL] [EOL] return version_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0
from typing import Dict , Union [EOL] import typing [EOL] import json [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] response = { [string] : [number] , [string] : json . dumps ( [string] ) } [EOL] return response	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict , List [EOL] import builtins [EOL] import typing [EOL] import boto3 [EOL] from typing import List [EOL] import click [EOL] [EOL] ecs = boto3 . client ( [string] ) [EOL] ec2 = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def list_tasks ( cluster_id ) : [EOL] return ecs . list_tasks ( cluster = cluster_id ) . get ( [string] ) [EOL] [EOL] [EOL] def describe_tasks ( cluster_id , task_ids ) : [EOL] return ecs . describe_tasks ( cluster = cluster_id , tasks = task_ids ) [EOL] [EOL] [EOL] def describe_network_interface ( enis ) : [EOL] return ec2 . describe_network_interfaces ( NetworkInterfaceIds = enis ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , help = [string] ) def cli ( cluster_id ) : [EOL] [docstring] [EOL] try : [EOL] list_of_eni = [ ] [EOL] tasks = list_tasks ( cluster_id ) [EOL] tasks = describe_tasks ( cluster_id , tasks ) . get ( [string] ) [EOL] for task in tasks : [EOL] attachments = task . get ( [string] ) [EOL] for attachment in attachments : [EOL] details = attachment . get ( [string] ) [EOL] for detail in details : [EOL] if detail . get ( [string] ) == [string] and detail . get ( [string] ) . startswith ( [string] ) : [EOL] list_of_eni . append ( detail . get ( [string] ) ) [EOL] [EOL] network_interface_descriptions = describe_network_interface ( list_of_eni ) [EOL] for interface in network_interface_descriptions . get ( [string] ) : [EOL] public_dns = interface . get ( [string] ) . get ( [string] ) [EOL] public_ip = interface . get ( [string] ) . get ( [string] ) [EOL] print ( f" [string] { public_dns }" ) [EOL] print ( f" [string] { public_ip }" ) [EOL] [EOL] [EOL] except Exception as err : [EOL] print ( err ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cli ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , Any , List [EOL] import builtins [EOL] import typing [EOL] import boto3 [EOL] import click [EOL] import boto3 [EOL] import logging [EOL] from typing import Optional , List [EOL] from boto3 . session import Session [EOL] from botocore . exceptions import ClientError [EOL] from botocore . client import BaseClient [EOL] from dataclasses import dataclass [EOL] from datetime import datetime as DateTime [EOL] [EOL] @ dataclass ( frozen = True ) class TemporaryCredentials : [EOL] aws_access_key_id = ... [EOL] aws_secret_access_key = ... [EOL] aws_session_token = ... [EOL] expiration = ... [EOL] [EOL] @ dataclass ( frozen = True ) class Bucket : [EOL] name = ... [EOL] creation_date = ... [EOL] [EOL] @ dataclass ( frozen = True ) class S3Client : [EOL] client = ... [EOL] [EOL] def list_buckets ( self ) : [EOL] resp = self . client . list_buckets ( ) [EOL] return list ( map ( lambda e : Bucket ( e [ [string] ] , e [ [string] ] ) , resp [ [string] ] ) ) [EOL] [EOL] def get_credentials_for_role ( aws_account , role_name , role_session_name , duration ) : [EOL] creds = None [EOL] sts = boto3 . client ( [string] ) [EOL] try : [EOL] resp = sts . assume_role ( RoleArn = f' [string] { aws_account } [string] { role_name }' , RoleSessionName = role_session_name , DurationSeconds = duration ) [ [string] ] [EOL] return TemporaryCredentials ( resp [ [string] ] , resp [ [string] ] , resp [ [string] ] , resp [ [string] ] ) [EOL] except ClientError as e : [EOL] logging . exception ( [string] % e . response [ [string] ] [ [string] ] ) [EOL] [EOL] return creds [EOL] [EOL] def create_session ( creds ) : [EOL] return Session ( aws_access_key_id = creds . aws_access_key_id , aws_secret_access_key = creds . aws_secret_access_key , aws_session_token = creds . aws_session_token ) [EOL] [EOL] def s3_client ( session ) : [EOL] return S3Client ( session . client ( [string] ) ) [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , [string] , required = True , type = str , help = [string] ) @ click . option ( [string] , [string] , required = True , type = str , help = [string] ) @ click . option ( [string] , [string] , required = True , type = str , help = [string] ) @ click . option ( [string] , [string] , required = False , type = int , help = [string] , default = [number] ) def main ( aws_account , role_name , session_name , duration ) : [EOL] [docstring] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] ) [EOL] logging . info ( f' [string] { role_name } [string] { aws_account } [string] { session_name } [string] { duration }' ) [EOL] creds = get_credentials_for_role ( aws_account , role_name , session_name , duration ) [EOL] session = create_session ( creds ) [EOL] buckets = s3_client ( session ) . list_buckets ( ) [EOL] for bucket in buckets : [EOL] logging . info ( bucket . name ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $botocore.client.BaseClient$ 0 0 0 0 0 $typing.List[Bucket]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $boto3.session.Session$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $S3Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] import json [EOL] import botocore . vendored . requests as requests [EOL] import boto3 [EOL] import datetime [EOL] from time import gmtime , strftime [EOL] [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] def handler ( event , context ) : [EOL] start = datetime . datetime . now ( ) [EOL] response = requests . get ( [string] ) [EOL] end = datetime . datetime . now ( ) [EOL] diff = end - start [EOL] client . put_metric_data ( Namespace = [string] , MetricData = [ { [string] : f' [string] { response . status_code }' , [string] : datetime . datetime . now ( ) , [string] : diff . microseconds , [string] : [string] , [string] : [number] } , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import boto3 [EOL] import sys [EOL] import json [EOL] [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] stream_name = sys . argv [ [number] ] [EOL] number_of_messages = int ( sys . argv [ [number] ] ) [EOL] print ( f' [string] { number_of_messages } [string] { stream_name }' ) [EOL] [EOL] records = [ ] [EOL] [EOL] for x in range ( [number] , number_of_messages , [number] ) : [EOL] records . append ( { [string] : bytes ( json . dumps ( { [string] : f' [string] { x }' } ) , [string] ) } ) [EOL] [EOL] try : [EOL] response = client . put_record_batch ( DeliveryStreamName = stream_name , Records = records ) [EOL] if response [ [string] ] > [number] : [EOL] print ( [string] ) [EOL] [EOL] except Exception as e : [EOL] print ( f' [string] { e }' ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from base64 import b64encode , b64decode [EOL] import json [EOL] import uuid [EOL] [EOL] def handler ( event , context ) : [EOL] records = event [ [string] ] [EOL] for record in records : [EOL] record . pop ( [string] , None ) [EOL] msg = b64encode ( bytes ( json . dumps ( { [string] : f' [string] { uuid . uuid4 ( ) }' } ) , [string] ) ) . decode ( [string] ) [EOL] record . update ( { [string] : msg } ) [EOL] record . update ( { [string] : [string] } ) [comment] [EOL] print ( json . dumps ( records ) ) [EOL] return { [string] : records } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from base64 import b64encode , b64decode [EOL] import json [EOL] [EOL] def handler ( event , context ) : [EOL] records = event [ [string] ] [EOL] for record in records : [EOL] record . pop ( [string] , None ) [EOL] record . update ( { [string] : [string] } ) [comment] [EOL] print ( json . dumps ( records ) ) [EOL] return { [string] : records } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from sceptre . resolvers import Resolver [EOL] [EOL] [EOL] class S3Version ( Resolver ) : [EOL] NAME = [string] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( S3Version , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def resolve ( self ) : [EOL] if self . argument : [EOL] s3_bucket , s3_key = self . argument . split ( [string] , [number] ) [EOL] self . logger . debug ( [string] . format ( self . NAME ) ) [EOL] elif [string] in self . stack_config : [EOL] code = self . stack_config . get ( [string] ) . get ( [string] , { } ) [EOL] s3_bucket , s3_key = [ code . get ( [string] ) , code . get ( [string] ) ] [EOL] self . logger . debug ( [string] . format ( self . NAME ) ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] result = self . connection_manager . call ( service = [string] , command = [string] , kwargs = { [string] : s3_bucket , [string] : s3_key } , ) [EOL] [EOL] version_id = result . get ( [string] ) [EOL] [EOL] self . logger . debug ( [string] . format ( self . NAME , s3_bucket , s3_key , version_id ) ) [EOL] [EOL] return version_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0
from typing import Any , List [EOL] import typing [EOL] import io [EOL] import hashlib [EOL] import subprocess [EOL] import hashlib , os , subprocess , zipfile [EOL] from base64 import b64encode [EOL] from sceptre . hooks import Hook [EOL] from sceptre . resolvers import Resolver [EOL] from botocore . exceptions import ClientError [EOL] from datetime import datetime [EOL] from shutil import rmtree [EOL] try : [EOL] from subprocess import DEVNULL [EOL] except ImportError : [EOL] DEVNULL = open ( os . devnull , [string] ) [EOL] [EOL] try : [EOL] from StringIO import StringIO as BufferIO [EOL] except ImportError : [EOL] from io import BytesIO as BufferIO [EOL] [EOL] try : [EOL] import zlib [EOL] [EOL] compression = zipfile . ZIP_DEFLATED [EOL] except ImportError : [EOL] compression = zipfile . ZIP_STORED [EOL] [EOL] [EOL] class S3Package ( Hook ) : [EOL] NAME = [string] [EOL] TARGET = [string] [EOL] DELIMITER = [string] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( S3Package , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def run ( self ) : [EOL] if self . DELIMITER in self . argument : [EOL] fn_root_dir , s3_object = self . argument . split ( self . DELIMITER , [number] ) [EOL] s3_bucket , s3_key = s3_object . split ( [string] , [number] ) [EOL] self . logger . debug ( [string] . format ( self . NAME ) ) [EOL] elif [string] in self . stack_config : [EOL] code = self . stack_config . get ( [string] ) . get ( [string] , { } ) [EOL] fn_root_dir , s3_bucket , s3_key = [ self . argument , code . get ( [string] ) , code . get ( [string] ) , ] [EOL] self . logger . debug ( [string] . format ( self . NAME ) ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] if isinstance ( s3_bucket , Resolver ) : [EOL] s3_bucket = s3_bucket . resolve ( ) [EOL] self . logger . debug ( [string] . format ( self . NAME , s3_bucket ) ) [EOL] [EOL] if isinstance ( s3_key , Resolver ) : [EOL] s3_key = s3_key . resolve ( ) [EOL] self . logger . debug ( [string] . format ( self . NAME , s3_key ) ) [EOL] [EOL] fn_dist_dir = os . path . join ( fn_root_dir , self . TARGET ) [EOL] [EOL] command = [string] . format ( fn_root_dir ) [EOL] [EOL] self . logger . info ( [string] . format ( command ) ) [EOL] [EOL] p = subprocess . Popen ( [ command ] , shell = True , stdout = DEVNULL , stderr = DEVNULL ) [EOL] p . wait ( ) [EOL] [EOL] if p . returncode != [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] self . logger . debug ( [string] . format ( self . NAME , fn_dist_dir ) ) [EOL] [EOL] files = sorted ( [ os . path . join ( root [ len ( fn_dist_dir ) + [number] : ] , file ) for root , _ , files in os . walk ( fn_dist_dir ) for file in files ] ) [EOL] [EOL] buffer = BufferIO ( ) [EOL] [EOL] [comment] [EOL] static_ts = int ( datetime ( [number] , [number] , [number] ) . strftime ( [string] ) ) [EOL] [EOL] with zipfile . ZipFile ( buffer , mode = [string] , compression = compression ) as f : [EOL] for file in files : [EOL] real_file = os . path . join ( fn_dist_dir , file ) [EOL] self . logger . debug ( [string] . format ( self . NAME , real_file ) ) [EOL] os . utime ( real_file , ( static_ts , static_ts ) ) [EOL] f . write ( real_file , arcname = file ) [EOL] [EOL] rmtree ( fn_dist_dir ) [EOL] [EOL] buffer . seek ( [number] ) [EOL] content = buffer . read ( ) [EOL] [EOL] md5 = hashlib . new ( [string] ) [EOL] md5 . update ( content ) [EOL] [EOL] try : [EOL] self . connection_manager . call ( service = [string] , command = [string] , kwargs = { [string] : s3_bucket , [string] : s3_key , [string] : [string] . format ( md5 . hexdigest ( ) ) , } , ) [EOL] [EOL] self . logger . info ( [string] . format ( self . NAME , fn_dist_dir ) ) [EOL] except ClientError as e : [EOL] if e . response [ [string] ] [ [string] ] not in [ [string] , [string] ] : [EOL] raise e [EOL] [EOL] self . logger . info ( [string] . format ( self . NAME , fn_dist_dir , s3_bucket , s3_key ) ) [EOL] [EOL] result = self . connection_manager . call ( service = [string] , command = [string] , kwargs = { [string] : s3_bucket , [string] : s3_key , [string] : content , [string] : b64encode ( md5 . digest ( ) ) . strip ( ) . decode ( [string] ) , } , ) [EOL] [EOL] self . logger . debug ( [string] . format ( self . NAME , s3_bucket , s3_key , result . get ( [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BufferedWriter$ 0 0 0 0 0 $io.BufferedWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $io.BufferedWriter$ 0 0 0 $io.BufferedWriter$ 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $hashlib._Hash$ 0 0 0 0 0 0 0 0 $hashlib._Hash$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $hashlib._Hash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $hashlib._Hash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from sceptre . hooks import Hook [EOL] from sceptre . resolvers . stack_output import StackOutput [EOL] import boto3 [EOL] import os [EOL] [EOL] [EOL] class S3UploadFile ( Hook ) : [EOL] NAME = [string] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( S3UploadFile , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] try : [EOL] cwd = os . getcwd ( ) [EOL] print ( cwd ) [EOL] file_name , bucket_key , stack_param = self . argument . split ( [string] , [number] ) [EOL] bucket_name = StackOutput ( argument = stack_param , connection_manager = self . connection_manager , environment_config = self . environment_config , stack_config = self . stack_config , ) . resolve ( ) [EOL] print ( f" [string] { self . NAME } [string] { file_name } [string] { bucket_name } [string] { bucket_key }" ) [EOL] s3 = self . connection_manager . boto_session . resource ( [string] ) [EOL] bucket = s3 . Bucket ( bucket_name ) [EOL] bucket . upload_file ( file_name , bucket_key ) [EOL] except Exception as e : [EOL] print ( e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sceptre . hooks import Hook [EOL] from sceptre . resolvers . stack_output import StackOutput [EOL] from collections import defaultdict [EOL] [EOL] [EOL] class S3EmptyBucket ( Hook ) : [EOL] NAME = [string] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( S3EmptyBucket , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] id_list = defaultdict ( ) [EOL] del_obj_list = defaultdict ( list ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def handler ( event , context ) : [EOL] print ( event ) [EOL] return { [string] : event [ [string] ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import boto3 [EOL] import base64 [EOL] import json [EOL] import uuid [EOL] [EOL] [EOL] def test_put_record ( ) : [EOL] client = boto3 . client ( [string] ) [EOL] user = { [string] : str ( uuid . uuid4 ( ) ) , [string] : [string] , [string] : [number] } [EOL] result = client . put_record ( StreamName = [string] , Data = json . dumps ( user ) , PartitionKey = [string] ) [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] [EOL] [EOL] [EOL] def test_get_shard_interator ( ) : [EOL] [comment] [EOL] client = boto3 . client ( [string] ) [EOL] shard_iterator = client . get_shard_iterator ( StreamName = [string] , ShardId = [string] , ShardIteratorType = [string] ) [ [string] ] [EOL] records = client . get_records ( ShardIterator = shard_iterator , Limit = [number] ) [EOL] for record in records [ [string] ] : [EOL] print ( record ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import troposphere [EOL] from troposphere import Ref , Template [EOL] import troposphere . s3 as s3 [EOL] [EOL] def create_bucket ( ) : [EOL] bucket = s3 . Bucket ( [string] ) [EOL] bucket . BucketName = [string] [EOL] return bucket [EOL] [EOL] def sceptre_handler ( sceptre_user_data ) : [EOL] t = Template ( ) [EOL] t . add_resource ( create_bucket ( ) ) [EOL] return t . to_json ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $troposphere.s3.Bucket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import boto3 [EOL] [EOL] boto3 . setup_default_session ( profile_name = [string] ) [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] def delete_log_group ( logGroupNamePrefix ) : [EOL] paginator = client . get_paginator ( [string] ) [EOL] for page in paginator . paginate ( logGroupNamePrefix = logGroupNamePrefix ) : [EOL] for group in page [ [string] ] : [EOL] client . delete_log_group ( logGroupName = group [ [string] ] ) [EOL] [EOL] [EOL] def test_delete_lambda_loggroups ( ) : [EOL] delete_log_group ( [string] ) [EOL] [EOL] def test_delete_api_gateway_execution_logs ( ) : [EOL] delete_log_group ( [string] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import boto3 [EOL] [EOL] session = boto3 . Session ( region_name = [string] ) [EOL] ssm = session . client ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def test_ssm_get_parameter ( ) : [EOL] assert ssm . get_parameter ( Name = [string] ) [ [string] ] [ [string] ] == [string] [EOL] assert ssm . get_parameter ( Name = [string] ) [ [string] ] [ [string] ] == [string] [EOL] assert ssm . get_parameter ( Name = [string] , WithDecryption = True ) [ [string] ] [ [string] ] == [string] [EOL] [EOL] def name ( ) : [EOL] return [string] [EOL] [EOL] def test_misc ( ) : [EOL] assert f'{ name ( ) }' == [string]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] import click [EOL] import boto3 [EOL] import logging [EOL] from dataclasses import dataclass [EOL] from datetime import datetime [EOL] import json [EOL] [EOL] @ dataclass ( frozen = True ) class SNSMessageId : [EOL] value = ... [EOL] [EOL] def publish ( client , topic_name , message ) : [EOL] logging . info ( f' [string] { message }' ) [EOL] resp = client . publish ( TopicArn = f' [string] { topic_name }' , Subject = f' [string] { message }' , Message = [string] ) [EOL] return SNSMessageId ( resp [ [string] ] ) [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , [string] , required = True , type = str , help = [string] ) @ click . option ( [string] , [string] , required = True , type = str , help = [string] ) def main ( topic_name , message ) : [EOL] [docstring] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] ) [EOL] logging . info ( f' [string] { message } [string] { topic_name }' ) [EOL] client = boto3 . client ( [string] ) [EOL] id = publish ( client , topic_name , message + str ( datetime . utcnow ( ) ) ) [EOL] logging . info ( id ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $SNSMessageId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import boto3 [EOL] [EOL] [EOL] def test_crud ( ) : [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] client . put_item ( TableName = [string] , Item = { [string] : { [string] : [string] } , [string] : { [string] : [string] } } ) [EOL] [EOL] result = client . get_item ( TableName = [string] , Key = { [string] : { [string] : [string] } } ) [EOL] assert result [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] assert result [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] client . delete_item ( TableName = [string] , Key = { [string] : { [string] : [string] } } ) [EOL] [EOL] res = client . get_item ( TableName = [string] , Key = { [string] : { [string] : [string] } } ) [EOL] [EOL] assert not res . get ( [string] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0