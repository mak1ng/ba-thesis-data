from typing import Any , Union , Match , Optional , Dict , Pattern , List , Literal , Tuple [EOL] import typing_extensions [EOL] import typing [EOL] import annotations [EOL] import builtins [EOL] import datetime [EOL] [docstring] [EOL] [EOL] import datetime [EOL] import re [EOL] from typing import Optional [EOL] [EOL] from . annotations import DictStrInt [EOL] from . utils import to_int [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] SECONDS_PER_DAY = [number] [EOL] SECONDS_PER_WEEK = [number] [EOL] TIMEDELTA_FORMAT = [string] [EOL] TIMEDELTA_FORMATS = { [string] : ( [string] , [string] ) , [string] : ( [string] [string] [string] , [string] [string] [string] , ) , [string] : ( [string] [string] , [string] [string] [string] , ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] [string] , [string] [string] , ) , [string] : ( [string] [string] , [string] [string] , ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , } [EOL] [EOL] [EOL] def str_to_timedelta ( value , fmt = None ) : [EOL] [docstring] [EOL] [EOL] def timedelta_kwargs ( data ) : [EOL] [docstring] [EOL] seconds = data . get ( [string] , [number] ) [EOL] seconds += data . get ( [string] , [number] ) * [number] [EOL] seconds += data . pop ( [string] , [number] ) * [number] [EOL] seconds += data . pop ( [string] , [number] ) [EOL] seconds += data . pop ( [string] , [number] ) * SECONDS_PER_DAY [EOL] seconds += data . pop ( [string] , [number] ) * SECONDS_PER_WEEK [EOL] data . update ( { [string] : seconds } ) [EOL] return data [EOL] [EOL] if not isinstance ( value , str ) : [EOL] raise ValueError ( [string] . format ( type ( value ) ) ) [EOL] [EOL] user_fmt = fmt [EOL] [EOL] if isinstance ( fmt , ( list , tuple ) ) : [EOL] formats = list ( fmt ) [EOL] elif fmt is None : [EOL] formats = [ TIMEDELTA_FORMAT , [string] , [string] ] [EOL] else : [EOL] formats = [ fmt ] [EOL] [EOL] locale_data = { [string] : [string] . format ( [string] , [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] . format ( [string] , [string] ) , [string] : [string] . format ( [string] , [string] ) , } [EOL] regexps = [ ] [EOL] [EOL] for item in formats : [EOL] processed = [string] [EOL] [EOL] for part in item : [EOL] if part in TIMEDELTA_FORMATS : [EOL] part = TIMEDELTA_FORMATS [ part ] [ [number] ] % locale_data [EOL] else : [EOL] part = re . escape ( part ) [EOL] processed += part [EOL] [EOL] processed += [string] [EOL] regexps . append ( processed ) [EOL] [EOL] for regexp in regexps : [EOL] timedelta_re = re . compile ( regexp ) [EOL] matched = timedelta_re . match ( value ) [EOL] [EOL] if matched : [EOL] data = { key : to_int ( value ) or [number] for key , value in matched . groupdict ( ) . items ( ) } [EOL] return datetime . timedelta ( ** timedelta_kwargs ( data ) ) [EOL] [EOL] if user_fmt : [EOL] err = [string] [EOL] raise ValueError ( err . format ( value , user_fmt ) ) [EOL] [EOL] return None [EOL] [EOL] [EOL] def timedelta_average ( * values ) : [EOL] [docstring] [EOL] if isinstance ( values [ [number] ] , ( list , tuple ) ) : [EOL] values = values [ [number] ] [EOL] return sum ( values , datetime . timedelta ( ) ) // len ( values ) [EOL] [EOL] [EOL] def timedelta_div ( first , second ) : [EOL] [docstring] [EOL] first_seconds = timedelta_seconds ( first ) [EOL] second_seconds = timedelta_seconds ( second ) [EOL] [EOL] if not second_seconds : [EOL] return None [EOL] [EOL] return first_seconds / second_seconds [EOL] [EOL] [EOL] def timedelta_seconds ( value ) : [EOL] [docstring] [EOL] return SECONDS_PER_DAY * value . days + value . seconds [EOL] [EOL] [EOL] def timedelta_to_str ( value , fmt = None ) : [EOL] [docstring] [EOL] [comment] [EOL] if not isinstance ( value , datetime . timedelta ) : [EOL] err = [string] [EOL] raise ValueError ( err . format ( type ( value ) ) ) [EOL] [EOL] [comment] [EOL] days = value . days [EOL] microseconds = value . microseconds [EOL] seconds = timedelta_seconds ( value ) [EOL] [EOL] hours = seconds // [number] [EOL] minutes = seconds // [number] [EOL] weeks = days // [number] [EOL] [EOL] [comment] [EOL] day_hours = hours - days * [number] [EOL] hour_minutes = minutes - hours * [number] [EOL] minute_seconds = seconds - minutes * [number] [EOL] week_days = days - weeks * [number] [EOL] [EOL] days_label = [string] if days % [number] == [number] else [string] [EOL] short_days_label = [string] [EOL] short_week_days_label = [string] [EOL] short_weeks_label = [string] [EOL] week_days_label = [string] if week_days % [number] == [number] else [string] [EOL] weeks_label = [string] if weeks % [number] == [number] else [string] [EOL] [EOL] [comment] [EOL] data = locals ( ) [EOL] [EOL] fmt = fmt or TIMEDELTA_FORMAT [EOL] processed = [string] [EOL] [EOL] for part in fmt : [EOL] if part in TIMEDELTA_FORMATS : [EOL] is_full_part = part in ( [string] , [string] ) [EOL] is_repr_part = part in ( [string] , [string] ) [EOL] [EOL] part = TIMEDELTA_FORMATS [ part ] [ [number] ] [EOL] [EOL] if is_full_part or is_repr_part : [EOL] if is_repr_part and not days : [EOL] part = part . replace ( [string] , [string] ) [EOL] part = part . replace ( [string] , [string] ) [EOL] part = part . replace ( [string] , [string] ) [EOL] [EOL] if is_full_part and not minute_seconds : [EOL] part = part . replace ( [string] , [string] ) [EOL] [EOL] if is_full_part and not weeks : [EOL] part = part . replace ( [string] , [string] ) [EOL] part = part . replace ( [string] , [string] ) [EOL] part = part . replace ( [string] , [string] ) [EOL] [EOL] if is_full_part and not week_days : [EOL] part = part . replace ( [string] , [string] ) [EOL] part = part . replace ( [string] , [string] ) [EOL] part = part . replace ( [string] , [string] ) [EOL] [EOL] part = part . strip ( ) [EOL] part = [string] . join ( part . split ( ) ) [EOL] [EOL] processed += part [EOL] [EOL] return processed % data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from . openapi import ( get_openapi_context , get_openapi_schema , get_openapi_spec , get_validated_data , openapi_context , OperationTableDef , setup_openapi , ) [EOL] from . settings import BaseSettings , setup_settings , setup_settings_from_environ [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] __author__ = [string] [EOL] __license__ = [string] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Union , Optional , List , Tuple [EOL] import typing [EOL] import annotations [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import sys [EOL] from typing import Any , Optional , Union [EOL] [EOL] from . annotations import DictStrAny [EOL] [EOL] [EOL] class IgnoreErrorsFilter ( object ) : [EOL] [docstring] [EOL] [EOL] def filter ( self , record ) : [comment] [EOL] [docstring] [EOL] return record . levelname in { [string] , [string] } [EOL] [EOL] [EOL] def default_logging_dict ( * loggers , ** kwargs ) : [EOL] [docstring] [EOL] kwargs . setdefault ( [string] , [string] ) [EOL] return { [string] : [number] , [string] : True , [string] : { [string] : { [string] : IgnoreErrorsFilter } } , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : { [string] : { [string] : [string] , [string] : [ [string] ] , [string] : [string] , [string] : [string] , [string] : sys . stdout , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : sys . stderr , } , } , [string] : { logger : dict ( handlers = [ [string] , [string] ] , ** kwargs ) for logger in loggers } , } [EOL] [EOL] [EOL] def update_sentry_logging ( logging_dict , sentry_dsn , * loggers , level = None , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] if not sentry_dsn : [EOL] return [EOL] [EOL] [comment] [EOL] kwargs [ [string] ] = [string] [EOL] kwargs [ [string] ] = sentry_dsn [EOL] logging_dict [ [string] ] [ [string] ] = dict ( level = level or [string] , ** kwargs ) [EOL] [EOL] loggers = tuple ( logging_dict [ [string] ] ) if not loggers else loggers [EOL] for logger in loggers : [EOL] [comment] [EOL] logger_dict = logging_dict [ [string] ] . get ( logger ) [EOL] if not logger_dict : [EOL] continue [EOL] [EOL] [comment] [EOL] if logger_dict . pop ( [string] , False ) : [EOL] continue [EOL] [EOL] [comment] [EOL] handlers = list ( logger_dict . setdefault ( [string] , [ ] ) ) [EOL] handlers . append ( [string] ) [EOL] logger_dict [ [string] ] = tuple ( handlers ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.DictStrAny$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Optional , Iterator , Tuple [EOL] import typing [EOL] import urllib [EOL] import annotations [EOL] import builtins [EOL] import aiohttp [EOL] [docstring] [EOL] [EOL] from contextlib import contextmanager [EOL] from typing import Iterator , Optional , Union [EOL] from urllib . parse import urlparse [EOL] [EOL] from aiohttp import web [EOL] [EOL] from . annotations import DictStrAny , Handler , Protocol [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] ACCESS_LOG_FORMAT = [string] [EOL] [EOL] [EOL] class AddResourceFunc ( Protocol ) : [EOL] def __call__ ( self , url , get = None , * , name = None , ** kwargs ) : [EOL] ... [EOL] [EOL] [EOL] @ contextmanager def add_resource_context ( router , url_prefix = None , name_prefix = None ) : [EOL] [docstring] [EOL] [EOL] def add_resource ( url , get = None , * , name = None , ** kwargs ) : [EOL] [docstring] [EOL] if get : [EOL] kwargs [ [string] ] = get [EOL] [EOL] if url_prefix : [EOL] url = [string] . join ( ( url_prefix . rstrip ( [string] ) , url . lstrip ( [string] ) ) ) [EOL] [EOL] if not name and get : [EOL] name = get . __name__ [EOL] if name_prefix and name : [EOL] name = [string] . join ( ( name_prefix . rstrip ( [string] ) , name . lstrip ( [string] ) ) ) [EOL] [EOL] resource = router . add_resource ( url , name = name ) [EOL] for method , handler in kwargs . items ( ) : [EOL] if handler is None : [EOL] continue [EOL] resource . add_route ( method . upper ( ) , handler ) [EOL] [EOL] return resource [EOL] [EOL] yield add_resource [EOL] [EOL] [EOL] def is_xhr_request ( request ) : [EOL] [docstring] [EOL] value = request . headers . get ( [string] ) [EOL] return value == [string] [EOL] [EOL] [EOL] def parse_aioredis_url ( url ) : [EOL] [docstring] [EOL] parts = urlparse ( url ) [EOL] [EOL] db = parts . path [ [number] : ] or None [EOL] if db : [EOL] db = int ( db ) [EOL] [EOL] return { [string] : ( parts . hostname , parts . port or [number] ) , [string] : db , [string] : parts . password , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Resource$ 0 0 0 $builtins.str$ 0 $annotations.Handler$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $annotations.Handler$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[AddResourceFunc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Resource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.DictStrAny$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Mapping , Any , Dict , Type , TypeVar [EOL] import typing [EOL] [docstring] [EOL] [EOL] import types [EOL] from typing import Any , Callable , Dict , Mapping , Type , TypeVar , Union [EOL] [EOL] try : [EOL] from typing_extensions import Literal , Protocol , TypedDict [EOL] except ImportError : [EOL] from typing import Literal , Protocol , TypedDict [comment] [EOL] [EOL] from aiohttp import web [EOL] from aiohttp . web_middlewares import _Handler [EOL] [EOL] [EOL] F = TypeVar ( [string] , bound = Callable [ ... , Any ] ) [comment] [EOL] T = TypeVar ( [string] ) [EOL] [EOL] Level = Literal [ [string] , [string] , [string] , [string] ] [EOL] [EOL] Handler = _Handler [EOL] ViewType = Type [ web . View ] [EOL] [EOL] DictStrAny = Dict [ str , Any ] [EOL] DictStrInt = Dict [ str , int ] [EOL] DictStrStr = Dict [ str , str ] [EOL] [EOL] MappingStrAny = Mapping [ str , Any ] [EOL] MappingStrInt = Mapping [ str , int ] [EOL] MappingStrStr = Mapping [ str , str ] [EOL] [EOL] Settings = Union [ types . ModuleType , DictStrAny ] [EOL] [EOL] [EOL] ( Protocol , TypedDict ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Dict , List , Iterator , Type , Tuple [EOL] import src [EOL] import typing [EOL] import annotations [EOL] import builtins [EOL] import data [EOL] import openapi_core [EOL] from collections import deque [EOL] from functools import partial [EOL] from typing import Any , cast , Dict , Iterator , List , Optional , Tuple [EOL] [EOL] import pyrsistent [EOL] from email_validator import EmailNotValidError , validate_email [EOL] from isodate import parse_datetime [EOL] from jsonschema . exceptions import FormatError [EOL] from more_itertools import peekable [EOL] from openapi_core . casting . schemas . exceptions import CastError as CoreCastError [EOL] from openapi_core . exceptions import OpenAPIError as CoreOpenAPIError [EOL] from openapi_core . schema . operations . models import Operation [EOL] from openapi_core . schema . parameters . models import Parameter [EOL] from openapi_core . schema . paths . models import Path [EOL] from openapi_core . schema . schemas . enums import SchemaFormat , SchemaType [EOL] from openapi_core . schema . schemas . types import NoValue [EOL] from openapi_core . schema . servers . models import Server [EOL] from openapi_core . schema . specs . models import Spec [EOL] from openapi_core . templating . datatypes import TemplateResult [EOL] from openapi_core . templating . paths . exceptions import ( OperationNotFound , PathNotFound , ServerNotFound , ) [EOL] from openapi_core . templating . paths . finders import PathFinder as CorePathFinder [EOL] from openapi_core . unmarshalling . schemas . enums import UnmarshalContext [EOL] from openapi_core . unmarshalling . schemas . exceptions import InvalidSchemaValue [EOL] from openapi_core . unmarshalling . schemas . factories import ( SchemaUnmarshallersFactory as CoreSchemaUnmarshallersFactory , ) [EOL] from openapi_core . unmarshalling . schemas . formatters import Formatter [EOL] from openapi_core . unmarshalling . schemas . unmarshallers import ( ArrayUnmarshaller as CoreArrayUnmarshaller , ObjectUnmarshaller as CoreObjectUnmarshaller , ) [EOL] from openapi_core . validation . request . datatypes import ( OpenAPIRequest , RequestParameters , ) [EOL] from openapi_core . validation . request . validators import ( RequestValidator as CoreRequestValidator , ) [EOL] from openapi_core . validation . response . datatypes import OpenAPIResponse [EOL] from openapi_core . validation . response . validators import ( ResponseValidator as CoreResponseValidator , ) [EOL] from openapi_core . validation . validators import ( BaseValidator as CoreBaseValidator , ) [EOL] from openapi_schema_validator . _format import oas30_format_checker [EOL] [EOL] from . data import OpenAPIParameters , to_openapi_parameters [EOL] from . exceptions import CastError , ValidationError [EOL] from . security import validate_security [EOL] from . utils import get_base_url [EOL] from . . annotations import MappingStrAny [EOL] [EOL] [EOL] DATE_TIME_FORMATTER = Formatter . from_callables ( partial ( oas30_format_checker . check , format = [string] ) , parse_datetime , ) [EOL] PathTuple = Tuple [ Path , Operation , Server , TemplateResult , TemplateResult ] [EOL] [EOL] [EOL] class ArrayUnmarshaller ( CoreArrayUnmarshaller ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , value = NoValue ) : [EOL] if value is None and self . schema . nullable : [EOL] return None [EOL] return cast ( List [ Any ] , super ( ) . __call__ ( value ) ) [EOL] [EOL] [EOL] class EmailFormatter ( Formatter ) : [EOL] [docstring] [EOL] [EOL] def validate ( self , value ) : [EOL] try : [EOL] validate_email ( value ) [EOL] except EmailNotValidError as err : [EOL] raise FormatError ( f"{ value !r} [string] " , cause = err ) [EOL] return True [EOL] [EOL] [EOL] class ObjectUnmarshaller ( CoreObjectUnmarshaller ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , value = NoValue ) : [EOL] if value is None and self . schema . nullable : [EOL] return None [EOL] return cast ( Dict [ Any , Any ] , super ( ) . __call__ ( value ) ) [EOL] [EOL] [EOL] class PathFinder ( CorePathFinder ) : [EOL] [docstring] [EOL] [EOL] def find ( self , request ) : [EOL] [docstring] [EOL] paths_iter_peek = peekable ( self . _get_paths_iter ( request . full_url_pattern ) ) [EOL] if not paths_iter_peek : [EOL] raise PathNotFound ( request . full_url_pattern ) [EOL] [EOL] operations_iter_peek = peekable ( self . _get_operations_iter ( request . method , paths_iter_peek ) ) [EOL] if not operations_iter_peek : [EOL] raise OperationNotFound ( request . full_url_pattern , request . method ) [EOL] [EOL] servers_iter = self . _get_servers_iter ( request . full_url_pattern , operations_iter_peek ) [EOL] for server in servers_iter : [EOL] path = server [ [number] ] [EOL] if request . full_url_pattern . endswith ( path . name ) : [EOL] return server [EOL] [EOL] raise ServerNotFound ( request . full_url_pattern ) [EOL] [EOL] [EOL] class SchemaUnmarshallersFactory ( CoreSchemaUnmarshallersFactory ) : [EOL] [docstring] [EOL] [EOL] COMPLEX_UNMARSHALLERS = { ** CoreSchemaUnmarshallersFactory . COMPLEX_UNMARSHALLERS , SchemaType . ARRAY : ArrayUnmarshaller , SchemaType . OBJECT : ObjectUnmarshaller , } [EOL] [EOL] def get_formatter ( self , default_formatters , type_format = None , ) : [EOL] if type_format == SchemaFormat . DATETIME . value : [EOL] return DATE_TIME_FORMATTER [EOL] return super ( ) . get_formatter ( default_formatters , type_format ) [EOL] [EOL] [EOL] CUSTOM_FORMATTERS = { [string] : EmailFormatter ( ) } [EOL] [EOL] [EOL] class BaseValidator ( CoreBaseValidator ) : [EOL] [docstring] [EOL] [EOL] def _cast ( self , param_or_media_type , value ) : [EOL] try : [EOL] return super ( ) . _cast ( param_or_media_type , value ) [EOL] except CoreCastError as err : [EOL] [comment] [EOL] raise CastError ( name = param_or_media_type . name , value = err . value , type = err . type ) [EOL] [EOL] def _find_path ( self , request ) : [EOL] return PathFinder ( self . spec , base_url = self . base_url ) . find ( request ) [EOL] [EOL] def _unmarshal ( self , param_or_media_type , value , context ) : [EOL] [docstring] [EOL] if not param_or_media_type . schema : [EOL] return value [EOL] [EOL] unmarshallers_factory = SchemaUnmarshallersFactory ( self . spec . _resolver , self . custom_formatters , context = context , ) [EOL] unmarshaller = unmarshallers_factory . create ( param_or_media_type . schema ) [EOL] [EOL] try : [EOL] return unmarshaller ( value ) [EOL] except InvalidSchemaValue as err : [EOL] [comment] [EOL] if isinstance ( param_or_media_type , Parameter ) : [EOL] param_name = param_or_media_type . name [EOL] [EOL] for schema_error in err . schema_errors : [EOL] schema_error . path = schema_error . relative_path = deque ( [ param_name ] ) [EOL] [EOL] raise err [EOL] [EOL] [EOL] class RequestValidator ( BaseValidator , CoreRequestValidator ) : [EOL] def _get_parameters ( self , request , params ) : [EOL] [docstring] [EOL] parameters , errors = super ( ) . _get_parameters ( request , params ) [EOL] if errors : [EOL] raise ValidationError . from_request_errors ( errors , base_loc = [ [string] ] ) [EOL] return parameters , errors [EOL] [EOL] def _get_security ( self , request , operation ) : [EOL] [docstring] [EOL] return validate_security ( self , request , operation ) [EOL] [EOL] def _unmarshal ( self , param_or_media_type , value ) : [EOL] return super ( ) . _unmarshal ( param_or_media_type , value , UnmarshalContext . REQUEST ) [EOL] [EOL] [EOL] class ResponseValidator ( BaseValidator , CoreResponseValidator ) : [EOL] def _unmarshal ( self , param_or_media_type , value ) : [EOL] return super ( ) . _unmarshal ( param_or_media_type , value , UnmarshalContext . RESPONSE ) [EOL] [EOL] [EOL] def validate_core_request ( spec , core_request ) : [EOL] [docstring] [EOL] validator = RequestValidator ( spec , custom_formatters = CUSTOM_FORMATTERS , base_url = get_base_url ( core_request ) , ) [EOL] result = validator . validate ( core_request ) [EOL] [EOL] if result . errors : [EOL] raise ValidationError . from_request_errors ( result . errors ) [EOL] [EOL] return ( result . security , to_openapi_parameters ( result . parameters ) , pyrsistent . freeze ( result . body ) , ) [EOL] [EOL] [EOL] def validate_core_response ( spec , core_request , core_response , ) : [EOL] [docstring] [EOL] validator = ResponseValidator ( spec , custom_formatters = CUSTOM_FORMATTERS , base_url = get_base_url ( core_request ) , ) [EOL] result = validator . validate ( core_request , core_response ) [EOL] [EOL] if result . errors : [EOL] raise ValidationError . from_response_errors ( result . errors ) [EOL] [EOL] return result . data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $openapi_core.unmarshalling.schemas.formatters.Formatter$ 0 0 0 $typing.Dict[builtins.str,openapi_core.unmarshalling.schemas.formatters.Formatter]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,openapi_core.unmarshalling.schemas.formatters.Formatter]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $PathTuple$ 0 0 0 $openapi_core.validation.request.datatypes.OpenAPIRequest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $openapi_core.validation.request.datatypes.OpenAPIRequest$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $openapi_core.unmarshalling.schemas.enums.UnmarshalContext$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $src.rororo.openapi.core_validators.SchemaUnmarshallersFactory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $openapi_core.unmarshalling.schemas.enums.UnmarshalContext$ 0 $openapi_core.unmarshalling.schemas.enums.UnmarshalContext$ 0 0 0 $typing.Any$ 0 $src.rororo.openapi.core_validators.SchemaUnmarshallersFactory$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[openapi_core.validation.request.datatypes.RequestParameters,typing.List[openapi_core.exceptions.OpenAPIError]]$ 0 0 0 $openapi_core.validation.request.datatypes.OpenAPIRequest$ 0 $annotations.MappingStrAny$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $openapi_core.validation.request.datatypes.OpenAPIRequest$ 0 $annotations.MappingStrAny$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.MappingStrAny$ 0 0 0 $openapi_core.validation.request.datatypes.OpenAPIRequest$ 0 $openapi_core.schema.operations.models.Operation$ 0 0 0 0 0 0 0 0 0 0 $openapi_core.validation.request.datatypes.OpenAPIRequest$ 0 $openapi_core.schema.operations.models.Operation$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Optional [EOL] import typing [EOL] import annotations [EOL] import builtins [EOL] import data [EOL] import openapi_core [EOL] import aiohttp [EOL] from typing import Any , cast , Optional , Union [EOL] [EOL] from aiohttp import web [EOL] from aiohttp . helpers import ChainMapProxy [EOL] from openapi_core . schema . specs . models import Spec [EOL] from openapi_core . validation . request . datatypes import OpenAPIRequest [EOL] from yarl import URL [EOL] [EOL] from . constants import ( APP_OPENAPI_SCHEMA_KEY , APP_OPENAPI_SPEC_KEY , REQUEST_OPENAPI_CONTEXT_KEY , ) [EOL] from . data import OpenAPIContext , OpenAPIParameters [EOL] from . exceptions import ConfigurationError , ContextError [EOL] from . . annotations import DictStrAny [EOL] [EOL] [EOL] def add_prefix ( path , prefix ) : [EOL] if prefix : [EOL] if prefix [ - [number] ] == [string] : [EOL] prefix = prefix [ : - [number] ] [EOL] return f"{ prefix }{ path }" [EOL] return path [EOL] [EOL] [EOL] def get_base_url ( core_request ) : [EOL] return str ( URL ( core_request . full_url_pattern ) . with_path ( [string] ) ) [EOL] [EOL] [EOL] def get_openapi_context ( request ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( OpenAPIContext , request [ REQUEST_OPENAPI_CONTEXT_KEY ] ) [EOL] except KeyError : [EOL] raise ContextError ( [string] [string] [string] ) [EOL] [EOL] [EOL] def get_openapi_schema ( mixed ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( DictStrAny , mixed [ APP_OPENAPI_SCHEMA_KEY ] ) [EOL] except KeyError : [EOL] raise ConfigurationError ( [string] [string] [string] ) [EOL] [EOL] [EOL] def get_openapi_spec ( mixed ) : [EOL] [docstring] [EOL] try : [EOL] return mixed [ APP_OPENAPI_SPEC_KEY ] [EOL] except KeyError : [EOL] raise ConfigurationError ( [string] [string] [string] ) [EOL] [EOL] [EOL] def get_validated_data ( request ) : [EOL] [docstring] [EOL] return get_openapi_context ( request ) . data [EOL] [EOL] [EOL] def get_validated_parameters ( request ) : [EOL] [docstring] [EOL] return get_openapi_context ( request ) . parameters [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.OpenAPIContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.DictStrAny$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $openapi_core.schema.specs.models.Spec$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.OpenAPIParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Mapping , Any [EOL] import typing [EOL] import logging [EOL] import aiohttp [EOL] import logging [EOL] [EOL] import yaml [EOL] from aiohttp import web [EOL] from aiohttp_middlewares import error_context [EOL] [EOL] from . exceptions import ConfigurationError , OpenAPIError [EOL] from . utils import get_openapi_schema [EOL] from . . annotations import MappingStrStr [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def default_error_handler ( request ) : [EOL] [docstring] [EOL] with error_context ( request ) as context : [EOL] err = context . err [EOL] headers = { } [EOL] [EOL] if isinstance ( err , OpenAPIError ) : [EOL] headers = err . headers [EOL] else : [EOL] logger . error ( context . message , exc_info = True ) [EOL] [EOL] return web . json_response ( context . data , status = context . status , headers = headers , ) [EOL] [EOL] [EOL] async def openapi_schema ( request ) : [EOL] [docstring] [EOL] schema_format = request . match_info . get ( [string] ) [EOL] schema = get_openapi_schema ( request . config_dict ) [EOL] [EOL] if schema_format == [string] : [EOL] return web . json_response ( schema ) [EOL] [EOL] if schema_format == [string] : [EOL] safe_dumper = getattr ( yaml , [string] , yaml . SafeDumper ) [EOL] return web . Response ( text = yaml . dump ( schema , Dumper = safe_dumper ) , content_type = [string] , ) [EOL] [EOL] raise ConfigurationError ( f" [string] { schema_format } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import annotations [EOL] import openapi_core [EOL] [docstring] [EOL] [EOL] from typing import Any [EOL] [EOL] import attr [EOL] from aiohttp import web [EOL] from aiohttp . helpers import ChainMapProxy [EOL] from openapi_core . validation . request . datatypes import RequestParameters [EOL] from pyrsistent import pmap [EOL] [EOL] from . . annotations import MappingStrAny [EOL] [EOL] [EOL] @ attr . dataclass ( frozen = True , slots = True ) class OpenAPIParameters : [EOL] [comment] [EOL] path = attr . Factory ( pmap ) [EOL] [EOL] [comment] [EOL] query = attr . Factory ( pmap ) [EOL] [EOL] [comment] [EOL] header = attr . Factory ( pmap ) [EOL] [EOL] [comment] [EOL] cookie = attr . Factory ( pmap ) [EOL] [EOL] [EOL] @ attr . dataclass ( frozen = True , slots = True ) class OpenAPIContext : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] request = ... [EOL] [EOL] [comment] [EOL] app = ... [EOL] [EOL] [comment] [EOL] config_dict = ... [EOL] [EOL] [comment] [EOL] parameters = attr . Factory ( OpenAPIParameters ) [EOL] [EOL] [comment] [EOL] security = attr . Factory ( pmap ) [EOL] [EOL] [comment] [EOL] data = None [EOL] [EOL] [EOL] def to_openapi_parameters ( core_parameters , ) : [EOL] [docstring] [EOL] return OpenAPIParameters ( path = pmap ( core_parameters . path ) , query = pmap ( core_parameters . query ) , header = pmap ( core_parameters . header ) , cookie = pmap ( core_parameters . cookie ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.MappingStrAny$ 0 0 0 0 0 0 0 0 0 0 0 $annotations.MappingStrAny$ 0 0 0 0 0 0 0 0 0 0 0 $annotations.MappingStrAny$ 0 0 0 0 0 0 0 0 0 0 0 $annotations.MappingStrAny$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 $aiohttp.helpers.ChainMapProxy$ 0 0 0 0 0 0 $OpenAPIParameters$ 0 0 0 0 0 0 0 0 0 0 0 $annotations.MappingStrAny$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $OpenAPIParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] APP_OPENAPI_SCHEMA_KEY = [string] [EOL] [EOL] [comment] [EOL] APP_OPENAPI_SPEC_KEY = [string] [EOL] [EOL] [comment] [EOL] HANDLER_OPENAPI_MAPPING_KEY = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] REQUEST_CORE_OPERATION_KEY = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] REQUEST_CORE_REQUEST_KEY = [string] [EOL] [EOL] [comment] [EOL] REQUEST_OPENAPI_CONTEXT_KEY = [string] [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Union , Dict , Pattern , List , Type [EOL] import src [EOL] import logging [EOL] import typing [EOL] import annotations [EOL] import builtins [EOL] import openapi_core [EOL] import jsonschema [EOL] import logging [EOL] import re [EOL] from typing import Any , Dict , List , Union [EOL] [EOL] import attr [EOL] from jsonschema . exceptions import ValidationError as JsonSchemaValidationError [EOL] from openapi_core . casting . schemas . exceptions import CastError as CoreCastError [EOL] from openapi_core . deserializing . exceptions import DeserializeError [EOL] from openapi_core . deserializing . parameters . exceptions import ( EmptyParameterValue , ) [EOL] from openapi_core . exceptions import OpenAPIError as CoreOpenAPIError [EOL] from openapi_core . schema . media_types . exceptions import ( InvalidContentType , OpenAPIMediaTypeError , ) [EOL] from openapi_core . schema . parameters . exceptions import ( MissingParameter , MissingRequiredParameter , OpenAPIParameterError , ) [EOL] from openapi_core . schema . responses . exceptions import InvalidResponse [EOL] from openapi_core . unmarshalling . schemas . exceptions import ( InvalidSchemaValue , UnmarshalError , ) [EOL] from openapi_core . validation . exceptions import InvalidSecurity [EOL] [EOL] from . . annotations import DictStrAny , MappingStrStr , TypedDict [EOL] [EOL] [EOL] ERROR_FIELD_REQUIRED = [string] [EOL] ERROR_NOT_FOUND_TEMPLATE = [string] [EOL] ERROR_PARAMETER_EMPTY = [string] [EOL] ERROR_PARAMETER_INVALID = [string] [EOL] ERROR_PARAMETER_MISSING = [string] [EOL] ERROR_PARAMETER_REQUIRED = [string] [EOL] OBJECT_LABEL = [string] [EOL] [EOL] PathItem = Union [ int , str ] [EOL] DictPathItemAny = Dict [ PathItem , Any ] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] required_message_re = re . compile ( [string] ) [EOL] [EOL] [EOL] @ attr . s ( hash = True ) class CastError ( CoreCastError ) : [EOL] name = attr . ib ( ) [EOL] value = attr . ib ( ) [EOL] type = attr . ib ( ) [comment] [EOL] [EOL] [EOL] class OpenAPIError ( Exception ) : [EOL] [docstring] [EOL] [EOL] default_message = [string] [EOL] default_headers = { } [EOL] status = [number] [EOL] [EOL] def __init__ ( self , message = None , * , headers = None ) : [EOL] super ( ) . __init__ ( message or self . default_message ) [EOL] self . headers = headers or self . default_headers [EOL] [EOL] [EOL] class ConfigurationError ( OpenAPIError ) : [EOL] [docstring] [EOL] [EOL] default_message = [string] [EOL] [EOL] [EOL] class ContextError ( OpenAPIError ) : [EOL] [docstring] [EOL] [EOL] default_message = [string] [EOL] [EOL] [EOL] class OperationError ( OpenAPIError ) : [EOL] [docstring] [EOL] [EOL] default_message = [string] [EOL] [EOL] [EOL] class BadRequest ( OpenAPIError ) : [EOL] [docstring] [EOL] [EOL] default_message = [string] [EOL] status = [number] [EOL] [EOL] [EOL] class SecurityError ( OpenAPIError ) : [EOL] [docstring] [EOL] [EOL] default_message = [string] [EOL] status = [number] [EOL] [EOL] [EOL] class BasicSecurityError ( SecurityError ) : [EOL] [docstring] [EOL] [EOL] default_headers = { [string] : [string] } [EOL] status = [number] [EOL] [EOL] [EOL] class InvalidCredentials ( SecurityError ) : [EOL] [docstring] [EOL] [EOL] default_message = [string] [EOL] status = [number] [EOL] [EOL] [EOL] class BasicInvalidCredentials ( InvalidCredentials ) : [EOL] [docstring] [EOL] [EOL] default_headers = { [string] : [string] } [EOL] status = [number] [EOL] [EOL] [EOL] class ObjectDoesNotExist ( OpenAPIError ) : [EOL] [docstring] [EOL] [EOL] default_message = ERROR_NOT_FOUND_TEMPLATE . format ( label = OBJECT_LABEL ) [EOL] status = [number] [EOL] [EOL] def __init__ ( self , label = OBJECT_LABEL , * , message = None , headers = None , ) : [EOL] super ( ) . __init__ ( message or ERROR_NOT_FOUND_TEMPLATE . format ( label = label ) , headers = headers , ) [EOL] self . label = label [EOL] [EOL] [EOL] class ValidationErrorItem ( TypedDict ) : [EOL] loc = ... [EOL] message = ... [EOL] [EOL] [EOL] class ValidationError ( OpenAPIError ) : [EOL] [docstring] [EOL] [EOL] default_message = [string] [EOL] status = [number] [EOL] [EOL] def __init__ ( self , * , message = None , errors = None , ) : [EOL] super ( ) . __init__ ( message or self . default_message ) [EOL] [EOL] self . errors = errors [EOL] self . data = { [string] : errors } if errors else None [EOL] [EOL] @ classmethod def from_dict ( cls , data = None , ** kwargs ) : [EOL] if data and kwargs : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def dict_walker ( loc , data , errors , ) : [EOL] for key , value in data . items ( ) : [EOL] if isinstance ( value , dict ) : [EOL] dict_walker ( loc + [ key ] , value , errors ) [EOL] else : [EOL] errors . append ( { [string] : loc + [ key ] , [string] : value } ) [EOL] [EOL] errors = [ ] [EOL] dict_walker ( [ ] , data or kwargs , errors ) [EOL] return cls ( errors = errors ) [EOL] [EOL] @ classmethod def from_request_errors ( cls , errors , * , base_loc = None , ) : [EOL] base_loc = [ [string] ] if base_loc is None else base_loc [EOL] result = [ ] [EOL] [EOL] for err in errors : [EOL] if isinstance ( err , ( OpenAPIParameterError , EmptyParameterValue ) ) : [EOL] result . append ( get_parameter_error_details ( base_loc , err ) ) [EOL] elif isinstance ( err , OpenAPIMediaTypeError ) : [EOL] result . append ( get_media_type_error_details ( base_loc , err ) ) [EOL] elif isinstance ( err , CastError ) : [EOL] result . append ( { [string] : [ * base_loc , err . name ] , [string] : ( f"{ err . value !r} [string] { err . type !r}" ) , } ) [EOL] elif isinstance ( err , UnmarshalError ) : [EOL] result . extend ( get_unmarshal_error_details ( base_loc , err ) ) [EOL] else : [EOL] result . append ( get_common_error_details ( base_loc , err ) ) [EOL] [EOL] return cls ( message = [string] , errors = result , ) [EOL] [EOL] @ classmethod def from_response_errors ( cls , errors ) : [EOL] result = [ ] [EOL] loc = [ [string] ] [EOL] [EOL] for err in errors : [EOL] if isinstance ( err , InvalidResponse ) : [EOL] available_responses = [string] . join ( sorted ( err . responses ) ) [EOL] result . append ( { [string] : loc , [string] : ( f"{ err } [string] " f"{ available_responses }" ) , } ) [EOL] elif isinstance ( err , OpenAPIMediaTypeError ) : [EOL] result . append ( get_media_type_error_details ( loc , err ) ) [EOL] elif isinstance ( err , UnmarshalError ) : [EOL] result . extend ( get_unmarshal_error_details ( loc , err ) ) [EOL] else : [EOL] result . append ( get_common_error_details ( loc , err ) ) [EOL] [EOL] return cls ( message = [string] , errors = result ) [EOL] [EOL] [EOL] def ensure_loc ( loc ) : [EOL] return [ item for item in loc if item != [string] ] [EOL] [EOL] [EOL] def get_common_error_details ( loc , err ) : [EOL] return { [string] : loc , [string] : str ( err ) } [EOL] [EOL] [EOL] def get_json_schema_validation_error_details ( loc , err ) : [EOL] message = err . message [EOL] path = list ( err . absolute_path ) [EOL] matched = required_message_re . match ( message ) [EOL] [EOL] if matched : [EOL] return { [string] : ensure_loc ( loc + path + [ matched . groupdict ( ) [ [string] ] ] ) , [string] : ERROR_FIELD_REQUIRED , } [EOL] [EOL] return { [string] : ensure_loc ( loc + path ) , [string] : err . message , } [EOL] [EOL] [EOL] def get_media_type_error_details ( loc , err ) : [EOL] if isinstance ( err , InvalidContentType ) : [EOL] return { [string] : loc , [string] : ( f" [string] { err . mimetype }" ) , } [EOL] [EOL] return get_common_error_details ( loc , err ) [EOL] [EOL] [EOL] def get_parameter_error_details ( loc , err , ) : [EOL] parameter_name = getattr ( err , [string] , None ) [EOL] if parameter_name is None : [EOL] return get_common_error_details ( loc , err ) [EOL] [EOL] message = { DeserializeError : ERROR_PARAMETER_INVALID , EmptyParameterValue : ERROR_PARAMETER_EMPTY , MissingParameter : ERROR_PARAMETER_MISSING , MissingRequiredParameter : ERROR_PARAMETER_REQUIRED , } [ type ( err ) ] [EOL] [EOL] return { [string] : [ * loc , parameter_name ] , [string] : message } [EOL] [EOL] [EOL] def get_unmarshal_error_details ( loc , err ) : [EOL] if isinstance ( err , InvalidSchemaValue ) : [EOL] return [ get_json_schema_validation_error_details ( loc , item ) for item in err . schema_errors ] [EOL] [EOL] return [ get_common_error_details ( loc , err ) ] [EOL] [EOL] [EOL] def is_only_security_error ( errors ) : [EOL] return len ( errors ) == [number] and isinstance ( errors [ [number] ] , InvalidSecurity ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[PathItem]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ValidationError"$ 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 $typing.List[typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 $typing.List[typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.List[typing.Union[builtins.int,builtins.str]]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $"ValidationError"$ 0 0 0 $typing.List[openapi_core.exceptions.OpenAPIError]$ 0 0 0 $typing.List[ValidationErrorItem]$ 0 0 0 0 $typing.List[PathItem]$ 0 0 0 0 0 0 0 0 0 $typing.List[openapi_core.exceptions.OpenAPIError]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ValidationErrorItem]$ 0 0 0 0 0 0 $typing.List[PathItem]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ValidationErrorItem]$ 0 0 0 0 0 $typing.List[PathItem]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ValidationErrorItem]$ 0 0 0 0 0 $typing.List[PathItem]$ 0 0 0 0 0 0 0 0 $typing.List[ValidationErrorItem]$ 0 0 0 0 0 $typing.List[PathItem]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[openapi_core.exceptions.OpenAPIError]$ 0 $typing.List[ValidationErrorItem]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , Union , Deque , Dict , List , Type , Tuple [EOL] import pathlib [EOL] import settings [EOL] import yarl [EOL] import typing [EOL] import annotations [EOL] import builtins [EOL] import openapi_core [EOL] import aiohttp [EOL] import inspect [EOL] import json [EOL] import os [EOL] import warnings [EOL] from functools import lru_cache , partial [EOL] from pathlib import Path [EOL] from typing import Callable , cast , Deque , List , overload , Tuple , Union [EOL] [EOL] import attr [EOL] import yaml [EOL] from aiohttp import hdrs , web [EOL] from aiohttp_middlewares import cors_middleware [EOL] from openapi_core . schema . specs . models import Spec [EOL] from openapi_core . shortcuts import create_spec [EOL] from pyrsistent import pmap [EOL] from yarl import URL [EOL] [EOL] from . import views [EOL] from . constants import ( APP_OPENAPI_SCHEMA_KEY , APP_OPENAPI_SPEC_KEY , HANDLER_OPENAPI_MAPPING_KEY , ) [EOL] from . core_data import get_core_operation [EOL] from . exceptions import ConfigurationError [EOL] from . middlewares import openapi_middleware [EOL] from . utils import add_prefix [EOL] from . . annotations import ( DictStrAny , DictStrStr , F , Handler , Protocol , ViewType , ) [EOL] from . . settings import APP_SETTINGS_KEY , BaseSettings [EOL] [EOL] [EOL] SchemaLoader = Callable [ [ bytes ] , DictStrAny ] [EOL] Url = Union [ str , URL ] [EOL] [EOL] [EOL] class CreateSchemaAndSpec ( Protocol ) : [EOL] def __call__ ( self , path , * , schema_loader = None ) : [comment] [EOL] ... [EOL] [EOL] [EOL] @ attr . dataclass ( slots = True ) class OperationTableDef : [EOL] [docstring] [EOL] [EOL] handlers = attr . Factory ( list ) [EOL] views = attr . Factory ( list ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] return OperationTableDef ( handlers = [ * self . handlers , * other . handlers ] , views = [ * self . views , * other . views ] , ) [EOL] [EOL] def __iadd__ ( self , other ) : [EOL] self . handlers . extend ( other . handlers ) [EOL] self . views . extend ( other . views ) [EOL] return self [EOL] [EOL] @ overload def register ( self , handler ) : [EOL] ... [comment] [EOL] [EOL] @ overload def register ( self , operation_id ) : [EOL] ... [comment] [EOL] [EOL] def register ( self , mixed ) : [comment] [EOL] operation_id = mixed if isinstance ( mixed , str ) else mixed . __qualname__ [EOL] [EOL] def decorator ( handler ) : [EOL] mapping = { } [EOL] [EOL] if self . _is_view ( handler ) : [EOL] mapping . update ( self . _register_view ( handler , operation_id ) ) [EOL] else : [EOL] mapping . update ( self . _register_handler ( handler , operation_id ) ) [EOL] [EOL] setattr ( handler , HANDLER_OPENAPI_MAPPING_KEY , pmap ( mapping ) ) [EOL] return handler [EOL] [EOL] return decorator ( mixed ) if callable ( mixed ) else decorator [EOL] [EOL] def _is_view ( self , handler ) : [EOL] is_class = inspect . isclass ( handler ) [EOL] return is_class and issubclass ( handler , web . View ) [comment] [EOL] [EOL] def _register_handler ( self , handler , operation_id ) : [EOL] [comment] [EOL] has_self_parameter = [string] in inspect . signature ( handler ) . parameters [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not has_self_parameter : [EOL] self . handlers . append ( handler ) [EOL] [EOL] return { hdrs . METH_ANY : operation_id } [EOL] [EOL] def _register_view ( self , view , prefix ) : [EOL] mapping = { } [EOL] [EOL] for value in vars ( view ) . values ( ) : [EOL] if not callable ( value ) : [EOL] continue [EOL] [EOL] name = value . __name__ [EOL] maybe_method = name . upper ( ) [EOL] if maybe_method not in hdrs . METH_ALL : [EOL] continue [EOL] [EOL] maybe_operation_id = getattr ( value , HANDLER_OPENAPI_MAPPING_KEY , { } ) . get ( hdrs . METH_ANY ) [EOL] mapping [ maybe_method ] = ( maybe_operation_id [EOL] if maybe_operation_id [EOL] else f"{ prefix } [string] { name }" ) [EOL] [EOL] self . views . append ( view ) [EOL] return mapping [EOL] [EOL] [EOL] def convert_operations_to_routes ( operations , spec , * , prefix = None ) : [EOL] [docstring] [EOL] [EOL] async def noop ( request ) : [EOL] return web . json_response ( status = [number] ) [comment] [EOL] [EOL] routes = web . RouteTableDef ( ) [EOL] [EOL] [comment] [EOL] for handler in operations . handlers : [EOL] operation_id = getattr ( handler , HANDLER_OPENAPI_MAPPING_KEY ) [ hdrs . METH_ANY ] [EOL] core_operation = get_core_operation ( spec , operation_id ) [EOL] [EOL] routes . route ( core_operation . http_method , add_prefix ( core_operation . path_name , prefix ) , name = get_route_name ( core_operation . operation_id ) , ) ( handler ) [EOL] [EOL] [comment] [EOL] for view in operations . views : [EOL] ids = Deque ( getattr ( view , HANDLER_OPENAPI_MAPPING_KEY ) . values ( ) ) [EOL] [EOL] first_operation_id = ids . popleft ( ) [EOL] core_operation = get_core_operation ( spec , first_operation_id ) [EOL] [EOL] path = add_prefix ( core_operation . path_name , prefix ) [EOL] routes . view ( path , name = get_route_name ( core_operation . operation_id ) , ) ( view ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for other_operation_id in ids : [EOL] routes . route ( hdrs . METH_ANY , path , name = get_route_name ( other_operation_id ) ) ( noop ) [EOL] [EOL] return routes [EOL] [EOL] [EOL] def create_schema_and_spec ( path , * , schema_loader = None ) : [EOL] schema = read_openapi_schema ( path , loader = schema_loader ) [EOL] return ( schema , create_spec ( schema ) ) [EOL] [EOL] [EOL] @ lru_cache ( maxsize = [number] ) def create_schema_and_spec_with_cache ( path , * , schema_loader = None ) : [EOL] return create_schema_and_spec ( path , schema_loader = schema_loader ) [EOL] [EOL] [EOL] def find_route_prefix ( oas , * , server_url = None , settings = None , ) : [EOL] if server_url is not None : [EOL] return get_route_prefix ( server_url ) [EOL] [EOL] servers = oas [ [string] ] [EOL] if len ( servers ) == [number] : [EOL] return get_route_prefix ( servers [ [number] ] [ [string] ] ) [EOL] [EOL] if settings is None : [EOL] raise ConfigurationError ( [string] [string] [string] ) [EOL] [EOL] for server in servers : [EOL] mixed = server . get ( [string] ) [EOL] if isinstance ( mixed , list ) : [EOL] if settings . level in mixed : [EOL] return get_route_prefix ( server [ [string] ] ) [EOL] elif mixed == settings . level : [EOL] return get_route_prefix ( server [ [string] ] ) [EOL] [EOL] raise ConfigurationError ( [string] f' [string] { settings . level } [string] ' ) [EOL] [EOL] [EOL] def get_route_name ( operation_id ) : [EOL] return operation_id . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def get_route_prefix ( mixed ) : [EOL] return ( URL ( mixed ) if isinstance ( mixed , str ) else mixed ) . path [EOL] [EOL] [EOL] def read_openapi_schema ( path , * , loader = None ) : [EOL] [docstring] [EOL] if loader is None : [EOL] if path . suffix == [string] : [EOL] loader = json . loads [EOL] elif path . suffix in { [string] , [string] } : [EOL] safe_loader = getattr ( yaml , [string] , yaml . SafeLoader ) [EOL] loader = partial ( yaml . load , Loader = safe_loader ) [EOL] [EOL] if loader is not None : [EOL] return loader ( path . read_bytes ( ) ) [EOL] [EOL] raise ConfigurationError ( f" [string] { path } [string] " [string] ) [EOL] [EOL] [EOL] @ overload def setup_openapi ( app , schema_path , * operations , server_url = None , is_validate_response = True , has_openapi_schema_handler = True , use_error_middleware = True , error_middleware_kwargs = None , use_cors_middleware = True , cors_middleware_kwargs = None , schema_loader = None , cache_create_schema_and_spec = False , ) : [comment] [EOL] ... [EOL] [EOL] [EOL] @ overload def setup_openapi ( app , * operations , schema , spec , server_url = None , is_validate_response = True , has_openapi_schema_handler = True , use_error_middleware = True , error_middleware_kwargs = None , use_cors_middleware = True , cors_middleware_kwargs = None , ) : [comment] [EOL] ... [EOL] [EOL] [EOL] def setup_openapi ( app , schema_path = None , * operations , schema = None , spec = None , server_url = None , is_validate_response = True , has_openapi_schema_handler = True , use_error_middleware = True , error_middleware_kwargs = None , use_cors_middleware = True , cors_middleware_kwargs = None , schema_loader = None , cache_create_schema_and_spec = False , ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( schema_path , OperationTableDef ) : [EOL] operations = ( schema_path , * operations ) [EOL] schema_path = None [EOL] [EOL] if schema is None and spec is None : [EOL] if schema_path is None : [EOL] raise ConfigurationError ( [string] [string] ) [EOL] [EOL] [comment] [EOL] path = ( Path ( schema_path ) if isinstance ( schema_path , str ) else schema_path ) [EOL] if not path . exists ( ) or not path . is_file ( ) : [EOL] uid = os . getuid ( ) [EOL] raise ConfigurationError ( f" [string] { path } [string] " [string] f" [string] { uid }" ) [EOL] [EOL] [comment] [EOL] create_func = ( create_schema_and_spec_with_cache [comment] [EOL] if cache_create_schema_and_spec [EOL] else create_schema_and_spec ) [EOL] [EOL] try : [EOL] schema , spec = create_func ( path , schema_loader = schema_loader ) [EOL] except Exception : [EOL] raise ConfigurationError ( f" [string] { path } [string] " [string] [string] f" [string] { path . absolute ( ) } [string] " ) [EOL] elif schema_path is not None : [EOL] warnings . warn ( [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] app [ APP_OPENAPI_SCHEMA_KEY ] = schema [EOL] app [ APP_OPENAPI_SPEC_KEY ] = spec [EOL] [EOL] [comment] [EOL] [comment] [EOL] route_prefix = find_route_prefix ( cast ( DictStrAny , schema ) , server_url = server_url , settings = app . get ( APP_SETTINGS_KEY ) , ) [EOL] if has_openapi_schema_handler : [EOL] app . router . add_get ( add_prefix ( [string] , route_prefix ) , views . openapi_schema , ) [EOL] [EOL] [comment] [EOL] for item in operations : [EOL] app . router . add_routes ( convert_operations_to_routes ( item , spec , prefix = route_prefix ) ) [EOL] [EOL] [comment] [EOL] kwargs = error_middleware_kwargs or { } [EOL] kwargs . setdefault ( [string] , views . default_error_handler ) [EOL] [EOL] try : [EOL] app . middlewares . insert ( [number] , openapi_middleware ( is_validate_response = is_validate_response , use_error_middleware = use_error_middleware , error_middleware_kwargs = kwargs , ) , ) [EOL] except TypeError : [EOL] raise ConfigurationError ( [string] [string] f"{ error_middleware_kwargs !r}" ) [EOL] [EOL] [comment] [EOL] if use_cors_middleware : [EOL] try : [EOL] app . middlewares . insert ( [number] , cors_middleware ( ** ( cors_middleware_kwargs or { } ) ) ) [EOL] except TypeError : [EOL] raise ConfigurationError ( [string] [string] f"{ cors_middleware_kwargs !r}" ) [EOL] [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[annotations.DictStrAny,openapi_core.schema.specs.models.Spec]$ 0 0 0 $pathlib.Path$ 0 0 0 $SchemaLoader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annotations.Handler]$ 0 0 0 0 0 0 0 0 $typing.List[annotations.ViewType]$ 0 0 0 0 0 0 0 0 0 0 $"OperationTableDef"$ 0 0 0 $"OperationTableDef"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"OperationTableDef"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $"OperationTableDef"$ 0 0 0 0 0 0 0 0 $"OperationTableDef"$ 0 0 0 $"OperationTableDef"$ 0 0 0 0 0 0 0 0 0 $"OperationTableDef"$ 0 0 0 0 0 0 0 0 0 0 $"OperationTableDef"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.F$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.F$ 0 $annotations.F$ 0 0 0 $annotations.DictStrStr$ 0 0 0 0 0 0 0 0 0 0 $annotations.F$ 0 0 0 $annotations.DictStrStr$ 0 0 0 0 0 0 0 $annotations.F$ 0 0 0 0 0 0 0 0 $annotations.DictStrStr$ 0 0 0 0 0 0 0 $annotations.F$ 0 0 0 0 0 0 0 0 $annotations.F$ 0 0 0 0 0 $annotations.DictStrStr$ 0 0 0 0 $annotations.F$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $annotations.F$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $annotations.F$ 0 0 0 $builtins.bool$ 0 0 0 $annotations.F$ 0 0 0 0 0 0 0 0 0 $annotations.DictStrStr$ 0 0 0 $annotations.Handler$ 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $annotations.Handler$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $annotations.Handler$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $annotations.DictStrStr$ 0 0 0 $annotations.ViewType$ 0 $builtins.str$ 0 0 0 $annotations.DictStrStr$ 0 0 0 0 0 0 0 0 0 0 $annotations.ViewType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.DictStrStr$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.ViewType$ 0 0 0 $annotations.DictStrStr$ 0 0 0 0 $aiohttp.web.RouteTableDef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[annotations.DictStrAny,openapi_core.schema.specs.models.Spec]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[annotations.DictStrAny,openapi_core.schema.specs.models.Spec]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.DictStrAny$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator [EOL] import typing [EOL] import aiohttp [EOL] import data [EOL] from contextlib import contextmanager [EOL] from typing import Iterator [EOL] [EOL] from aiohttp import web [EOL] [EOL] from . data import OpenAPIContext [EOL] from . utils import get_openapi_context [EOL] [EOL] [EOL] @ contextmanager def openapi_context ( request ) : [EOL] [docstring] [EOL] yield get_openapi_context ( request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[data.OpenAPIContext]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from . contexts import openapi_context [EOL] from . openapi import OperationTableDef , setup_openapi [EOL] from . utils import ( get_openapi_context , get_openapi_schema , get_openapi_spec , get_validated_data , get_validated_parameters , ) [EOL] from . views import default_error_handler [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Optional [EOL] import yarl [EOL] import typing [EOL] import annotations [EOL] import builtins [EOL] import openapi_core [EOL] import aiohttp [EOL] from typing import cast , Optional , Union [EOL] [EOL] from aiohttp import hdrs , web [EOL] from aiohttp . payload import IOBasePayload , Payload [EOL] from openapi_core . schema . operations . models import Operation [EOL] from openapi_core . schema . specs . models import Spec [EOL] from openapi_core . validation . request . datatypes import ( OpenAPIRequest , RequestParameters , ) [EOL] from openapi_core . validation . response . datatypes import OpenAPIResponse [EOL] from yarl import URL [EOL] [EOL] from . constants import HANDLER_OPENAPI_MAPPING_KEY [EOL] from . exceptions import OperationError [EOL] from . utils import get_openapi_spec [EOL] from . . annotations import Handler [EOL] [EOL] [EOL] def find_core_operation ( request , handler ) : [EOL] mapping = getattr ( handler , HANDLER_OPENAPI_MAPPING_KEY , None ) [EOL] if not mapping : [EOL] return None [EOL] [EOL] operation_id = mapping . get ( request . method ) or mapping . get ( hdrs . METH_ANY ) [EOL] if operation_id is None : [EOL] return None [EOL] [EOL] try : [EOL] return get_core_operation ( get_openapi_spec ( request . config_dict ) , operation_id ) [EOL] except OperationError : [EOL] return None [EOL] [EOL] [EOL] def get_core_operation ( spec , operation_id ) : [EOL] for path in spec . paths . values ( ) : [EOL] for operation in path . operations . values ( ) : [EOL] if operation . operation_id == operation_id : [EOL] return operation [EOL] raise OperationError ( f" [string] { operation_id } [string] " ) [EOL] [EOL] [EOL] def get_full_url_pattern ( request ) : [EOL] [docstring] [EOL] full_url = request . url . with_path ( get_path_pattern ( request ) ) [EOL] return full_url . human_repr ( ) [EOL] [EOL] [EOL] def get_path_pattern ( request ) : [EOL] [docstring] [EOL] info = request . match_info . route . get_info ( ) [EOL] formatter = info . get ( [string] ) [EOL] return cast ( str , formatter if formatter is not None else info . get ( [string] ) ) [EOL] [EOL] [EOL] async def to_core_openapi_request ( request ) : [EOL] [docstring] [EOL] body = None [EOL] if request . body_exists and request . can_read_body : [EOL] raw_body = await request . read ( ) [EOL] [EOL] [comment] [EOL] try : [EOL] body = raw_body . decode ( [string] ) [EOL] [comment] [EOL] except UnicodeDecodeError : [EOL] body = raw_body [EOL] [EOL] return OpenAPIRequest ( full_url_pattern = get_full_url_pattern ( request ) , method = request . method . lower ( ) , body = body , mimetype = request . content_type , parameters = to_core_request_parameters ( request ) , ) [EOL] [EOL] [EOL] def to_core_openapi_response ( response ) : [EOL] [docstring] [EOL] return OpenAPIResponse ( data = to_core_openapi_response_data ( response ) , status_code = response . status , mimetype = response . content_type , ) [EOL] [EOL] [EOL] def to_core_openapi_response_data ( response , ) : [EOL] if isinstance ( response , web . Response ) : [EOL] body = response . body [EOL] if not body : [EOL] return None [EOL] [EOL] [comment] [EOL] if isinstance ( body , IOBasePayload ) : [EOL] return cast ( bytes , body . _value . getvalue ( ) ) [EOL] [EOL] if isinstance ( body , Payload ) : [EOL] return cast ( bytes , body . _value ) [EOL] [EOL] return body [EOL] return None [EOL] [EOL] [EOL] def to_core_request_parameters ( request ) : [EOL] header_attr = [ item for item in RequestParameters . __attrs_attrs__ if item . name == [string] ] [ [number] ] [EOL] is_dict_factory = header_attr . default . factory == dict [EOL] [EOL] return RequestParameters ( query = request . rel_url . query , header = request . headers if is_dict_factory else request . headers . items ( ) , cookie = request . cookies , path = request . match_info , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[openapi_core.schema.operations.models.Operation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $openapi_core.schema.operations.models.Operation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $openapi_core.validation.request.datatypes.OpenAPIRequest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $openapi_core.validation.response.datatypes.OpenAPIResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $openapi_core.validation.request.datatypes.RequestParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import annotations [EOL] import builtins [EOL] import aiohttp [EOL] import aiohttp_middlewares [EOL] from functools import partial [EOL] [EOL] from aiohttp import web [EOL] from aiohttp_middlewares import error_middleware , get_error_response [EOL] from aiohttp_middlewares . annotations import Middleware [EOL] [EOL] from . constants import REQUEST_CORE_OPERATION_KEY [EOL] from . core_data import find_core_operation [EOL] from . validators import validate_request , validate_response [EOL] from . . annotations import DictStrAny , Handler [EOL] [EOL] [EOL] def get_actual_handler ( handler ) : [EOL] [docstring] [EOL] if isinstance ( handler , partial ) and [string] in handler . keywords : [EOL] return get_actual_handler ( handler . keywords [ [string] ] ) [EOL] return handler [EOL] [EOL] [EOL] def openapi_middleware ( * , is_validate_response = True , use_error_middleware = True , error_middleware_kwargs = None ) : [EOL] [docstring] [EOL] [EOL] error_middleware_instance = ( error_middleware ( ** error_middleware_kwargs or { } ) [EOL] if use_error_middleware [EOL] else None ) [EOL] [EOL] async def get_response ( request , handler ) : [EOL] if error_middleware_instance is None : [EOL] return await handler ( request ) [EOL] return await error_middleware_instance ( request , handler ) [EOL] [EOL] @ web . middleware async def middleware ( request , handler ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] core_operation = find_core_operation ( request , get_actual_handler ( handler ) ) [EOL] if core_operation is None : [EOL] return await get_response ( request , handler ) [EOL] [EOL] try : [EOL] [comment] [EOL] request [ REQUEST_CORE_OPERATION_KEY ] = core_operation [EOL] response = await get_response ( await validate_request ( request ) , handler ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if is_validate_response : [EOL] validate_response ( request , response ) [EOL] [EOL] return response [EOL] except Exception as err : [EOL] return await get_error_response ( request , err , ** error_middleware_kwargs or { } ) [EOL] [EOL] return middleware [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annotations.Handler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp_middlewares.annotations.Middleware$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.StreamResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.StreamResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] from aiohttp import web [EOL] [EOL] from . constants import REQUEST_CORE_REQUEST_KEY , REQUEST_OPENAPI_CONTEXT_KEY [EOL] from . core_data import to_core_openapi_request , to_core_openapi_response [EOL] from . core_validators import validate_core_request , validate_core_response [EOL] from . data import OpenAPIContext [EOL] from . utils import get_openapi_spec [EOL] [EOL] [EOL] async def validate_request ( request ) : [EOL] config_dict = request . config_dict [EOL] [EOL] core_request = await to_core_openapi_request ( request ) [EOL] request [ REQUEST_CORE_REQUEST_KEY ] = core_request [EOL] [EOL] security , parameters , data = validate_core_request ( get_openapi_spec ( config_dict ) , core_request ) [EOL] request [ REQUEST_OPENAPI_CONTEXT_KEY ] = OpenAPIContext ( request = request , app = request . app , config_dict = config_dict , parameters = parameters , security = security , data = data , ) [EOL] [EOL] return request [EOL] [EOL] [EOL] def validate_response ( request , response ) : [EOL] validate_core_response ( get_openapi_spec ( request . config_dict ) , request [ REQUEST_CORE_REQUEST_KEY ] , to_core_openapi_response ( response ) , ) [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.StreamResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import settings [EOL] import typing [EOL] import builtins [EOL] import aiohttp [EOL] import examples [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] from aiohttp import web [EOL] [EOL] from rororo import setup_openapi , setup_settings [EOL] from . import views [EOL] from . settings import Settings [EOL] [EOL] [EOL] def create_app ( argv = None , * , settings = None ) : [EOL] [docstring] [EOL] [comment] [EOL] if settings is None : [EOL] settings = Settings . from_environ ( ) [comment] [EOL] [EOL] [comment] [EOL] app = setup_settings ( web . Application ( ) , settings , loggers = ( [string] , [string] , [string] , [string] ) , remove_root_handlers = True , ) [EOL] [EOL] [comment] [EOL] app [ settings . pets_app_key ] = [ ] [EOL] [EOL] [comment] [EOL] return setup_openapi ( app , Path ( __file__ ) . parent / [string] , views . operations , is_validate_response = False , cors_middleware_kwargs = { [string] : True } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import pytest [EOL] from petstore . app import create_app [EOL] from petstore . data import Pet [EOL] [EOL] [EOL] TEST_PET_NAME = [string] [EOL] TEST_PET = Pet ( id = [number] , name = TEST_PET_NAME , tag = None ) [EOL] [EOL] ADD_PET_JSON = { [string] : TEST_PET_NAME } [EOL] [EOL] [EOL] async def test_add_pet_200 ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . post ( [string] , json = ADD_PET_JSON ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [number] , [string] : TEST_PET_NAME , } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( None , [ [ [string] ] ] ) , ( { } , [ [ [string] , [string] ] ] ) , ( { [string] : None } , [ [ [string] , [string] ] ] ) , ( { [string] : [number] } , [ [ [string] , [string] ] ] ) , ) , ) async def test_add_pet_422 ( aiohttp_client , invalid_data , expected ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . post ( [string] , json = invalid_data ) [EOL] assert response . status == [number] [EOL] [EOL] data = await response . json ( ) [EOL] assert [ item [ [string] ] for item in data [ [string] ] ] == expected [EOL] [EOL] [EOL] async def test_delete_pet ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] await client . post ( [string] , json = ADD_PET_JSON ) [EOL] [EOL] response = await client . delete ( [string] ) [EOL] assert response . status == [number] [EOL] [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == [ ] [EOL] [EOL] [EOL] async def test_delete_pet_does_not_exist ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . delete ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] async def test_get_pet ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] await client . post ( [string] , json = ADD_PET_JSON ) [EOL] [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [number] , [string] : TEST_PET_NAME , } [EOL] [EOL] [EOL] async def test_get_pet_does_not_exist ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] async def test_list_pets ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] await client . post ( [string] , json = ADD_PET_JSON ) [EOL] [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == [ { [string] : [number] , [string] : TEST_PET_NAME } ] [EOL] [EOL] [EOL] async def test_list_pets_empty ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import rororo [EOL] from typing import Optional [EOL] [EOL] import attr [EOL] [EOL] from rororo . annotations import DictStrAny [EOL] [EOL] [EOL] @ attr . dataclass ( frozen = True , slots = True ) class NewPet : [EOL] name = ... [EOL] tag = ... [EOL] [EOL] def to_pet ( self , pet_id ) : [EOL] return Pet ( id = pet_id , name = self . name , tag = self . tag ) [EOL] [EOL] [EOL] @ attr . dataclass ( frozen = True , slots = True ) class Pet ( NewPet ) : [EOL] id = ... [comment] [EOL] [EOL] def to_dict ( self ) : [EOL] if self . tag : [EOL] return { [string] : self . id , [string] : self . name , [string] : self . tag } [EOL] return { [string] : self . id , [string] : self . name } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $"Pet"$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $rororo.annotations.DictStrAny$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Set [EOL] import typing [EOL] import logging [EOL] import aiohttp [EOL] import examples [EOL] import logging [EOL] [EOL] from aiohttp import web [EOL] [EOL] from rororo import openapi_context , OperationTableDef [EOL] from rororo . openapi import get_validated_data , get_validated_parameters [EOL] from . data import NewPet [EOL] from . shortcuts import get_pet_or_404 [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] operations = OperationTableDef ( ) [EOL] [EOL] [EOL] @ operations . register ( [string] ) async def create_pet ( request ) : [EOL] data = get_validated_data ( request ) [EOL] new_pet = NewPet ( name = data [ [string] ] , tag = data . get ( [string] ) ) [EOL] [EOL] pet = new_pet . to_pet ( len ( request . app [ [string] ] ) + [number] ) [EOL] request . app [ [string] ] . append ( pet ) [EOL] [EOL] return web . json_response ( pet . to_dict ( ) ) [EOL] [EOL] [EOL] @ operations . register ( [string] ) async def delete_pet ( request ) : [EOL] pet_id = get_validated_parameters ( request ) . path [ [string] ] [EOL] pet = get_pet_or_404 ( request . app [ [string] ] , pet_id ) [EOL] request . app [ [string] ] = [ item for item in request . app [ [string] ] if item != pet ] [EOL] return web . json_response ( status = [number] ) [EOL] [EOL] [EOL] @ operations . register ( [string] ) async def list_pets ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] limit = context . parameters . query . get ( [string] ) [EOL] tags = set ( context . parameters . query . get ( [string] ) or [ ] ) [EOL] [EOL] found = [ item for item in request . app [ [string] ] if not tags or ( tags and item . tag in tags ) ] [EOL] [EOL] return web . json_response ( [ item . to_dict ( ) for item in found [ : limit ] ] ) [EOL] [EOL] [EOL] @ operations . register ( [string] ) async def retrieve_pet ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] pet = get_pet_or_404 ( request . app [ [string] ] , context . parameters . path [ [string] ] ) [EOL] return web . json_response ( pet . to_dict ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import environ [EOL] [EOL] from rororo import BaseSettings [EOL] [EOL] [EOL] @ environ . config ( prefix = None , frozen = True ) class Settings ( BaseSettings ) : [EOL] pets_app_key = environ . var ( name = [string] , default = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import data [EOL] import examples [EOL] from typing import List [EOL] [EOL] from rororo . openapi . exceptions import ObjectDoesNotExist [EOL] from . data import Pet [EOL] [EOL] [EOL] def get_pet_or_404 ( pets , pet_id ) : [EOL] found = [ item for item in pets if item . id == pet_id ] [EOL] if not found : [EOL] raise ObjectDoesNotExist ( message = [string] ) [EOL] return found [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Pet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] import examples [EOL] import storage [EOL] import attr [EOL] from aiohttp import web [EOL] [EOL] from rororo import openapi_context , OperationTableDef [EOL] from . constants import APP_STORAGE_KEY [EOL] from . data import Todo [EOL] from . storage import Storage [EOL] from . validators import get_todo_or_404 [EOL] [EOL] [EOL] operations = OperationTableDef ( ) [EOL] [EOL] [EOL] @ operations . register class TodosView ( web . View ) : [EOL] [docstring] [EOL] [EOL] async def delete ( self ) : [EOL] storage = self . request . config_dict [ APP_STORAGE_KEY ] [EOL] await storage . delete_todos ( ) [EOL] [EOL] return web . json_response ( [string] ) [EOL] [EOL] @ operations . register ( [string] ) async def get ( self ) : [EOL] request = self . request [EOL] [EOL] storage = request . config_dict [ APP_STORAGE_KEY ] [EOL] todos = await storage . list_todos ( ) [EOL] [EOL] return web . json_response ( [ item . to_api_dict ( request = request ) for item in todos ] ) [EOL] [EOL] @ operations . register ( [string] ) async def post ( self ) : [EOL] request = self . request [EOL] [EOL] with openapi_context ( request ) as context : [EOL] todo = Todo ( title = context . data [ [string] ] , order = context . data . get ( [string] ) or [number] , ) [EOL] [EOL] storage = request . config_dict [ APP_STORAGE_KEY ] [EOL] await storage . create_todo ( todo ) [EOL] [EOL] return web . json_response ( todo . to_api_dict ( request = request ) , status = [number] ) [EOL] [EOL] [EOL] @ operations . register ( [string] ) class TodoView ( web . View ) : [EOL] async def delete ( self ) : [EOL] request = self . request [EOL] [EOL] storage = request . config_dict [ APP_STORAGE_KEY ] [EOL] await storage . delete_todo ( await get_todo_or_404 ( request ) ) [EOL] [EOL] return web . json_response ( [string] ) [EOL] [EOL] async def get ( self ) : [EOL] request = self . request [EOL] todo = await get_todo_or_404 ( request ) [EOL] return web . json_response ( todo . to_api_dict ( request = request ) ) [EOL] [EOL] async def patch ( self ) : [EOL] request = self . request [EOL] todo = await get_todo_or_404 ( request ) [EOL] [EOL] with openapi_context ( request ) as context : [EOL] next_todo = attr . evolve ( todo , ** context . data ) [EOL] [EOL] storage = request . config_dict [ APP_STORAGE_KEY ] [EOL] await storage . save_todo ( next_todo ) [EOL] [EOL] return web . json_response ( next_todo . to_api_dict ( request = request ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 $storage.Storage$ 0 0 0 0 0 0 0 0 0 0 0 $storage.Storage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $storage.Storage$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $storage.Storage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $examples.todobackend.data.Todo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $storage.Storage$ 0 0 0 0 0 0 0 0 0 $storage.Storage$ 0 0 0 $examples.todobackend.data.Todo$ 0 0 0 0 0 0 0 0 $examples.todobackend.data.Todo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $storage.Storage$ 0 0 0 0 0 0 0 0 0 $storage.Storage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 $examples.todobackend.data.Todo$ 0 0 0 0 0 0 0 0 0 0 0 0 $examples.todobackend.data.Todo$ 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 $examples.todobackend.data.Todo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $examples.todobackend.data.Todo$ 0 0 0 0 0 $examples.todobackend.data.Todo$ 0 0 0 0 0 0 0 0 $storage.Storage$ 0 0 0 0 0 0 0 0 0 $storage.Storage$ 0 0 0 $examples.todobackend.data.Todo$ 0 0 0 0 0 0 0 0 $examples.todobackend.data.Todo$ 0 0 0 0 0 0 0 0 0
from typing import Union , List , Any , Optional [EOL] import typing [EOL] import builtins [EOL] import aioredis [EOL] import data [EOL] import uuid [EOL] import pyrsistent [EOL] import uuid [EOL] from typing import Optional , Union [EOL] [EOL] import pyrsistent [EOL] from aioredis . connection import RedisConnection [EOL] from pyrsistent . typing import PVector [EOL] [EOL] from . data import Todo [EOL] [EOL] [EOL] class Storage : [EOL] def __init__ ( self , * , redis , data_key ) : [EOL] self . redis = redis [EOL] self . data_key = data_key [EOL] [EOL] def build_item_key ( self , mixed ) : [EOL] uid = mixed . uid if isinstance ( mixed , Todo ) else mixed [EOL] return [string] . join ( ( self . data_key , str ( uid ) ) ) [EOL] [EOL] async def create_todo ( self , todo ) : [EOL] await self . redis . rpush ( self . data_key , str ( todo . uid ) ) [EOL] await self . save_todo ( todo ) [EOL] [EOL] async def delete_todo ( self , todo ) : [EOL] redis = self . redis [EOL] [EOL] await redis . lrem ( self . data_key , [number] , str ( todo . uid ) ) [EOL] return await redis . delete ( self . build_item_key ( todo ) ) [comment] [EOL] [EOL] async def delete_todos ( self ) : [EOL] redis = self . redis [EOL] counter = [number] [EOL] [EOL] for key in await redis . lrange ( self . data_key , [number] , - [number] ) : [EOL] counter += await redis . delete ( self . build_item_key ( key ) ) [EOL] [EOL] await redis . delete ( self . data_key ) [EOL] return counter [EOL] [EOL] async def get_todo ( self , uid ) : [EOL] data = await self . redis . hgetall ( self . build_item_key ( uid ) ) [EOL] if not data : [EOL] return None [EOL] return Todo . from_storage ( data , uid = uid ) [EOL] [EOL] async def list_todos ( self ) : [EOL] redis = self . redis [EOL] [EOL] data = [ ] [EOL] for key in await redis . lrange ( self . data_key , [number] , - [number] ) : [EOL] uid = uuid . UUID ( key ) [EOL] item_key = self . build_item_key ( uid ) [EOL] [EOL] data . append ( Todo . from_storage ( await redis . hgetall ( item_key ) , uid = uid ) ) [EOL] [EOL] return pyrsistent . v ( * data ) [EOL] [EOL] async def save_todo ( self , todo ) : [EOL] await self . redis . hmset_dict ( self . build_item_key ( todo ) , todo . to_storage ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Union[builtins.str,data.Todo,uuid.UUID]$ 0 0 0 $typing.Union[builtins.str,uuid.UUID]$ 0 $typing.Union[builtins.str,data.Todo,uuid.UUID]$ 0 $typing.Union[builtins.str,uuid.UUID]$ 0 0 0 $typing.Union[builtins.str,data.Todo,uuid.UUID]$ 0 0 0 0 $typing.Union[builtins.str,data.Todo,uuid.UUID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,uuid.UUID]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $data.Todo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Todo$ 0 0 0 0 0 0 0 0 0 0 $data.Todo$ 0 0 0 0 0 $builtins.int$ 0 0 0 $data.Todo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Todo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Todo$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Optional[data.Todo]$ 0 0 0 $uuid.UUID$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $uuid.UUID$ 0 $uuid.UUID$ 0 0 0 0 0 $pyrsistent.typing.PVector[data.Todo]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $uuid.UUID$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $uuid.UUID$ 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 $data.Todo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Todo$ 0 0 $data.Todo$ 0 0 0 0 0 0
import builtins [EOL] import environ [EOL] [EOL] from rororo . settings import BaseSettings [EOL] [EOL] [EOL] @ environ . config ( prefix = None , frozen = True ) class Settings ( BaseSettings ) : [EOL] redis_url = environ . var ( name = [string] , default = [string] ) [EOL] [EOL] redis_data_key = environ . var ( name = [string] , default = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import todobackend [EOL] import uuid [EOL] [EOL] try : [EOL] from contextlib import asynccontextmanager [EOL] except ImportError : [EOL] from async_generator import asynccontextmanager [EOL] [EOL] import attr [EOL] import pyrsistent [EOL] import pytest [EOL] from aioredis import create_redis [EOL] from todobackend . app import create_app [EOL] from todobackend . data import Todo [EOL] from todobackend . settings import Settings [EOL] from todobackend . storage import Storage [EOL] from yarl import URL [EOL] [EOL] [EOL] FAKE_UID = [string] [EOL] TEST_TITLE = [string] [EOL] URL_TODOS = URL ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def todobackend_redis ( ) : [EOL] @ asynccontextmanager async def factory ( * , settings ) : [EOL] redis = await create_redis ( settings . redis_url , encoding = [string] ) [EOL] [EOL] try : [EOL] yield redis [EOL] finally : [EOL] keys = await redis . keys ( f"{ settings . redis_data_key } [string] " ) [EOL] for key in keys : [EOL] await redis . delete ( key ) [EOL] [EOL] redis . close ( ) [EOL] await redis . wait_closed ( ) [EOL] [EOL] return factory [EOL] [EOL] [EOL] @ pytest . fixture def todobackend_settings ( ) : [EOL] def factory ( ) : [EOL] settings = Settings . from_environ ( ) [EOL] return attr . evolve ( settings , redis_data_key = f" [string] { settings . redis_data_key }" ) [EOL] [EOL] return factory [EOL] [EOL] [EOL] async def test_flow ( aiohttp_client , todobackend_redis , todobackend_settings ) : [EOL] settings = todobackend_settings ( ) [EOL] async with todobackend_redis ( settings = settings ) : [EOL] client = await aiohttp_client ( create_app ( settings = settings ) ) [EOL] [EOL] response = await client . get ( URL_TODOS ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == [ ] [EOL] [EOL] response = await client . post ( URL_TODOS , json = { [string] : TEST_TITLE } ) [EOL] assert response . status == [number] [EOL] data = await response . json ( ) [EOL] assert data [ [string] ] == TEST_TITLE [EOL] [EOL] url = URL ( data [ [string] ] ) . relative ( ) [EOL] [EOL] response = await client . get ( url ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == data [EOL] [EOL] response = await client . get ( URL_TODOS ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == [ data ] [EOL] [EOL] response = await client . patch ( url , json = { [string] : True } ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { ** data , [string] : True } [EOL] [EOL] response = await client . delete ( url ) [EOL] assert response . status == [number] [EOL] [EOL] response = await client . get ( url ) [EOL] assert response . status == [number] [EOL] [EOL] response = await client . get ( URL_TODOS ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == [ ] [EOL] [EOL] [EOL] async def test_openapi_schema ( aiohttp_client , todobackend_settings ) : [EOL] settings = todobackend_settings ( ) [EOL] client = await aiohttp_client ( create_app ( settings = settings ) ) [EOL] response = await client . get ( URL_TODOS / [string] ) [EOL] assert response . status == [number] [EOL] [EOL] [EOL] async def test_storage ( todobackend_redis , todobackend_settings ) : [EOL] settings = todobackend_settings ( ) [EOL] async with todobackend_redis ( settings = settings ) as redis : [EOL] storage = Storage ( redis = redis , data_key = settings . redis_data_key ) [EOL] [EOL] assert await storage . list_todos ( ) == [ ] [EOL] [EOL] todo = Todo ( title = TEST_TITLE ) [EOL] await storage . create_todo ( todo ) [EOL] assert await storage . list_todos ( ) == pyrsistent . v ( todo ) [EOL] assert await storage . get_todo ( todo . uid ) == todo [EOL] [EOL] completed_todo = attr . evolve ( todo , completed = True ) [EOL] assert await storage . save_todo ( completed_todo ) != todo [EOL] assert await storage . get_todo ( todo . uid ) == completed_todo [EOL] [EOL] assert await storage . delete_todo ( todo ) == [number] [EOL] assert await storage . get_todo ( todo . uid ) is None [EOL] [EOL] await storage . create_todo ( todo ) [EOL] await storage . create_todo ( attr . evolve ( completed_todo , uid = uuid . uuid4 ( ) ) ) [EOL] assert await storage . delete_todos ( ) == [number] [EOL] [EOL] assert await storage . delete_todo ( todo ) == [number] [EOL] assert await storage . delete_todos ( ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , { } , URL_TODOS ) , ( [string] , { } , URL_TODOS ) , ( [string] , { } , URL_TODOS ) , ( [string] , { [string] : FAKE_UID } , URL_TODOS / FAKE_UID ) , ( [string] , { [string] : FAKE_UID } , URL_TODOS / FAKE_UID ) , ( [string] , { [string] : FAKE_UID } , URL_TODOS / FAKE_UID ) , ) , ) async def test_url ( route_name , kwargs , expected ) : [EOL] app = create_app ( ) [EOL] assert app . router [ route_name ] . url_for ( ** kwargs ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todobackend.settings.Settings$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $todobackend.settings.Settings$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import AsyncIterator , List , Any [EOL] import settings [EOL] import typing [EOL] import builtins [EOL] import aiohttp [EOL] import examples [EOL] from pathlib import Path [EOL] from typing import AsyncIterator , List [EOL] [EOL] from aiohttp import web [EOL] from aiohttp_middlewares import https_middleware [EOL] from aioredis import create_redis [EOL] [EOL] from rororo import setup_openapi , setup_settings [EOL] from rororo . settings import APP_SETTINGS_KEY [EOL] from . import views [EOL] from . constants import APP_REDIS_KEY , APP_STORAGE_KEY [EOL] from . settings import Settings [EOL] from . storage import Storage [EOL] [EOL] [EOL] def create_app ( argv = None , * , settings = None ) : [EOL] if settings is None : [EOL] settings = Settings . from_environ ( ) [comment] [EOL] [EOL] app = setup_openapi ( setup_settings ( web . Application ( ) , settings , loggers = ( [string] , [string] , [string] , [string] , ) , remove_root_handlers = True , ) , Path ( __file__ ) . parent / [string] , views . operations , cors_middleware_kwargs = { [string] : ( [string] , [string] ) } , cache_create_schema_and_spec = settings . is_test , ) [EOL] [EOL] [comment] [EOL] if settings . is_prod : [EOL] app . middlewares . insert ( [number] , https_middleware ( ) ) [EOL] [EOL] app . cleanup_ctx . append ( storage_context ) [EOL] return app [EOL] [EOL] [EOL] async def storage_context ( app ) : [EOL] settings = app [ APP_SETTINGS_KEY ] [EOL] [EOL] redis = app [ APP_REDIS_KEY ] = await create_redis ( settings . redis_url , encoding = [string] ) [EOL] app [ APP_STORAGE_KEY ] = Storage ( redis = redis , data_key = settings . redis_data_key ) [EOL] [EOL] yield [EOL] [EOL] redis . close ( ) [EOL] await redis . wait_closed ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterator[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
APP_REDIS_KEY = [string] [EOL] APP_STORAGE_KEY = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Optional [EOL] import storage [EOL] import typing [EOL] import data [EOL] import aiohttp [EOL] import examples [EOL] from aiohttp import web [EOL] [EOL] from rororo import openapi_context [EOL] from rororo . openapi . exceptions import ObjectDoesNotExist [EOL] from . constants import APP_STORAGE_KEY [EOL] from . data import Todo [EOL] from . storage import Storage [EOL] [EOL] [EOL] async def get_todo_or_404 ( request ) : [EOL] storage = request . config_dict [ APP_STORAGE_KEY ] [EOL] [EOL] with openapi_context ( request ) as context : [EOL] maybe_todo = await storage . get_todo ( context . parameters . path [ [string] ] ) [EOL] [EOL] if maybe_todo : [EOL] return maybe_todo [EOL] [EOL] raise ObjectDoesNotExist ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.Todo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] import rororo [EOL] from functools import wraps [EOL] [EOL] from aiohttp import web [EOL] [EOL] from rororo import openapi_context [EOL] from rororo . annotations import Handler [EOL] from . auth import authenticate [EOL] [EOL] [EOL] def login_required ( handler ) : [EOL] @ wraps ( handler ) async def decorator ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] basic_auth = context . security . get ( [string] ) [EOL] if basic_auth is not None : [EOL] username = basic_auth . login [EOL] personal_token = basic_auth . password [EOL] else : [EOL] username = context . parameters . header [ [string] ] [EOL] personal_token = ( context . security . get ( [string] ) or context . security [ [string] ] ) [EOL] [EOL] authenticate ( username = username , personal_token = personal_token ) [EOL] [EOL] return await handler ( request ) [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rororo.annotations.Handler$ 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.StreamResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] from rororo . openapi . exceptions import InvalidCredentials [EOL] from . data import GITHUB_PERSONAL_TOKEN , GITHUB_USERNAME [EOL] [EOL] [EOL] def authenticate ( * , username , personal_token ) : [EOL] if username != GITHUB_USERNAME or personal_token != GITHUB_PERSONAL_TOKEN : [EOL] raise InvalidCredentials ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Union , Dict , List [EOL] import typing [EOL] GITHUB_USERNAME = [string] [EOL] GITHUB_PERSONAL_TOKEN = [string] [EOL] GITHUB_REPOSITORY = [string] [EOL] [EOL] GITHUB_REPOSITORIES = { GITHUB_USERNAME : { GITHUB_REPOSITORY : { [string] : [string] , [string] : GITHUB_USERNAME , [string] : GITHUB_REPOSITORY , [string] : [ [string] , [string] ] , [string] : [string] , } } } [EOL] [EOL] ENVIRONMENT_VARS = { GITHUB_USERNAME : { [string] : f" [string] { GITHUB_USERNAME }" , [string] : [string] , } , f"{ GITHUB_USERNAME } [string] { GITHUB_REPOSITORY }" : { [string] : [string] } , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from aiohttp import BasicAuth [EOL] from hobotnica . app import create_app [EOL] from hobotnica . data import ( GITHUB_PERSONAL_TOKEN , GITHUB_REPOSITORY , GITHUB_USERNAME , ) [EOL] from yarl import URL [EOL] [EOL] [EOL] URL_REPOSITORIES = URL ( [string] ) [EOL] URL_FAVORITES_REPOSITORIES = URL_REPOSITORIES / [string] [EOL] URL_OWNER_REPOSITORIES = URL_REPOSITORIES / GITHUB_USERNAME [EOL] URL_OWNER_REPOSITORIES_ENV = URL_OWNER_REPOSITORIES / [string] [EOL] URL_REPOSITORY = URL_REPOSITORIES / GITHUB_USERNAME / GITHUB_REPOSITORY [EOL] URL_REPOSITORY_ENV = URL_REPOSITORY / [string] [EOL] [EOL] [EOL] async def test_create_repository_201 ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . post ( URL_REPOSITORIES , json = { [string] : GITHUB_USERNAME , [string] : GITHUB_REPOSITORY } , headers = { [string] : GITHUB_USERNAME , [string] : GITHUB_PERSONAL_TOKEN , } , ) [EOL] assert response . status == [number] [EOL] [EOL] [EOL] async def test_list_favorites_repositories_204 ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . get ( URL_FAVORITES_REPOSITORIES , headers = { [string] : GITHUB_USERNAME , [string] : GITHUB_PERSONAL_TOKEN , } , ) [EOL] assert response . status == [number] [EOL] assert response . headers [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_list_owner_repositories_200 ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . get ( URL_OWNER_REPOSITORIES , headers = { [string] : BasicAuth ( GITHUB_USERNAME , GITHUB_PERSONAL_TOKEN ) . encode ( ) } , ) [EOL] [EOL] assert response . status == [number] [EOL] data = await response . json ( ) [EOL] [EOL] assert len ( data ) == [number] [EOL] assert data [ [number] ] [ [string] ] == GITHUB_USERNAME [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { } , { [string] : [string] } , { [string] : f" [string] { GITHUB_PERSONAL_TOKEN }" } , { [string] : GITHUB_PERSONAL_TOKEN } , ) , ) async def test_list_owner_repositories_401 ( aiohttp_client , invalid_headers ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . get ( URL_OWNER_REPOSITORIES , headers = invalid_headers ) [EOL] [EOL] assert response . status == [number] [EOL] assert response . headers [ [string] ] == [string] [EOL] assert await response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] async def test_list_owner_repositories_422 ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . get ( URL_REPOSITORIES / [string] , headers = { [string] : BasicAuth ( GITHUB_USERNAME , GITHUB_PERSONAL_TOKEN ) . encode ( ) } , ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [ { [string] : [ [string] , [string] ] , [string] : [string] } ] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : GITHUB_USERNAME , [string] : GITHUB_PERSONAL_TOKEN , } , { [string] : GITHUB_USERNAME , [string] : f" [string] { GITHUB_PERSONAL_TOKEN }" , } , ) , ) async def test_list_repositories_200 ( aiohttp_client , headers ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . get ( URL_REPOSITORIES , headers = headers ) [EOL] [EOL] assert response . status == [number] [EOL] data = await response . json ( ) [EOL] [EOL] assert len ( data ) == [number] [EOL] assert data [ [number] ] [ [string] ] == GITHUB_USERNAME [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : GITHUB_USERNAME [ : : - [number] ] , [string] : GITHUB_PERSONAL_TOKEN , } , { [string] : GITHUB_USERNAME , [string] : [string] , } , { [string] : GITHUB_USERNAME [ : : - [number] ] , [string] : f" [string] { GITHUB_PERSONAL_TOKEN }" , } , { [string] : GITHUB_USERNAME , [string] : [string] , } , ) , ) async def test_list_repositories_403_invalid_credentials ( aiohttp_client , invalid_headers ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . get ( URL_REPOSITORIES , headers = invalid_headers ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : GITHUB_USERNAME } , { [string] : GITHUB_USERNAME , [string] : [string] } , { [string] : GITHUB_USERNAME , [string] : [string] } , { [string] : GITHUB_USERNAME , [string] : [string] } , ) , ) async def test_list_repositories_403_not_authenticated ( aiohttp_client , invalid_headers ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . get ( URL_REPOSITORIES , headers = invalid_headers ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : GITHUB_PERSONAL_TOKEN } , { [string] : f" [string] { GITHUB_PERSONAL_TOKEN }" } , ) , ) async def test_list_repositories_422 ( aiohttp_client , invalid_headers ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . get ( URL_REPOSITORIES , headers = invalid_headers ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [ { [string] : [ [string] , [string] ] , [string] : [string] , } ] } [EOL] [EOL] [EOL] async def test_retrieve_owner_env_200 ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] [EOL] response = await client . get ( URL_OWNER_REPOSITORIES_ENV , headers = { [string] : BasicAuth ( GITHUB_USERNAME , GITHUB_PERSONAL_TOKEN ) . encode ( ) } , ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : f" [string] { GITHUB_USERNAME }" , [string] : [string] , } [EOL] [EOL] [EOL] async def test_retrieve_repository_200 ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] [EOL] response = await client . get ( URL_REPOSITORY , headers = { [string] : GITHUB_USERNAME , [string] : GITHUB_PERSONAL_TOKEN , [string] : f" [string] { GITHUB_PERSONAL_TOKEN }" , } , ) [EOL] assert response . status == [number] [EOL] [EOL] data = await response . json ( ) [EOL] assert data [ [string] ] == GITHUB_USERNAME [EOL] assert data [ [string] ] == GITHUB_REPOSITORY [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { } , { [string] : GITHUB_USERNAME } , { [string] : GITHUB_USERNAME , [string] : GITHUB_PERSONAL_TOKEN , } , { [string] : GITHUB_USERNAME , [string] : f" [string] { GITHUB_PERSONAL_TOKEN }" , } , ) , ) async def test_retrieve_repository_403 ( aiohttp_client , invalid_headers ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] [EOL] response = await client . get ( URL_REPOSITORY , headers = invalid_headers ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] async def test_retrieve_repository_env_200 ( aiohttp_client ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] [EOL] response = await client . get ( URL_REPOSITORY_ENV , headers = { [string] : GITHUB_USERNAME , [string] : GITHUB_PERSONAL_TOKEN , } , ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] import aiohttp [EOL] import rororo [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] from aiohttp import web [EOL] from aiohttp_middlewares import ( NON_IDEMPOTENT_METHODS , shield_middleware , timeout_middleware , ) [EOL] [EOL] from rororo import BaseSettings , setup_openapi , setup_settings [EOL] from . import views [EOL] [EOL] [EOL] def create_app ( argv = None , * , settings = None ) : [EOL] if settings is None : [EOL] settings = BaseSettings . from_environ ( ) [comment] [EOL] [EOL] return setup_openapi ( setup_settings ( web . Application ( middlewares = ( shield_middleware ( methods = NON_IDEMPOTENT_METHODS ) , timeout_middleware ( [number] ) , ) ) , settings , loggers = ( [string] , [string] , [string] , [string] ) , remove_root_handlers = True , ) , Path ( __file__ ) . parent / [string] , views . operations , cors_middleware_kwargs = { [string] : True } , cache_create_schema_and_spec = settings . is_test , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] import uuid [EOL] [EOL] from aiohttp import web [EOL] [EOL] from rororo import openapi_context , OperationTableDef [EOL] from rororo . openapi . exceptions import ObjectDoesNotExist [EOL] from . data import ENVIRONMENT_VARS , GITHUB_REPOSITORIES [EOL] from . decorators import login_required [EOL] [EOL] [EOL] operations = OperationTableDef ( ) [EOL] [EOL] [EOL] @ operations . register @ login_required async def create_repository ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] return web . json_response ( { ** context . data , [string] : str ( uuid . uuid4 ( ) ) , [string] : [ [string] , [string] ] , [string] : [string] , } , status = [number] , ) [EOL] [EOL] [EOL] @ operations . register @ login_required async def list_favorites_repositories ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] return web . json_response ( status = [number] , headers = { [string] : context . parameters . query [ [string] ] } ) [EOL] [EOL] [EOL] @ operations . register @ login_required async def list_owner_repositories ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] username = context . security [ [string] ] . login [EOL] return web . json_response ( list ( ( GITHUB_REPOSITORIES . get ( username ) or { } ) . values ( ) ) ) [EOL] [EOL] [EOL] @ operations . register @ login_required async def list_repositories ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] username = context . parameters . header [ [string] ] [EOL] return web . json_response ( list ( ( GITHUB_REPOSITORIES . get ( username ) or { } ) . values ( ) ) ) [EOL] [EOL] [EOL] @ operations . register @ login_required async def retrieve_owner_env ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] owner = context . parameters . path [ [string] ] [EOL] return web . json_response ( ENVIRONMENT_VARS . get ( owner ) or { } ) [EOL] [EOL] [EOL] @ operations . register @ login_required async def retrieve_repository ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] owner = context . parameters . path [ [string] ] [EOL] repository = ( GITHUB_REPOSITORIES . get ( owner ) or { } ) . get ( context . parameters . path [ [string] ] ) [EOL] [EOL] if not repository : [EOL] raise ObjectDoesNotExist ( [string] ) [EOL] [EOL] return web . json_response ( repository ) [EOL] [EOL] [EOL] @ operations . register @ login_required async def retrieve_repository_env ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] owner = context . parameters . path [ [string] ] [EOL] name = context . parameters . path [ [string] ] [EOL] env_key = f"{ owner } [string] { name }" [EOL] return web . json_response ( ENVIRONMENT_VARS . get ( env_key ) or { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] import aiohttp [EOL] import copy [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] import yaml [EOL] from aiohttp import web [EOL] from openapi_core . shortcuts import create_spec [EOL] from pyrsistent import thaw [EOL] [EOL] from rororo import get_validated_data , OperationTableDef , setup_openapi [EOL] from . storage import DEFAULT_STORAGE [EOL] [EOL] [EOL] operations = OperationTableDef ( ) [EOL] [EOL] [EOL] def create_app ( argv = None ) : [EOL] schema = yaml . load ( ( Path ( __file__ ) . parent / [string] ) . read_bytes ( ) ) [EOL] [EOL] app = web . Application ( ) [EOL] app [ [string] ] = copy . deepcopy ( DEFAULT_STORAGE ) [EOL] [EOL] return setup_openapi ( app , operations , schema = schema , spec = create_spec ( schema ) , ) [EOL] [EOL] [EOL] @ operations . register async def create_simulation ( request ) : [EOL] data = thaw ( get_validated_data ( request ) ) [EOL] request . app [ [string] ] . append ( data ) [EOL] return web . json_response ( data , status = [number] ) [EOL] [EOL] [EOL] @ operations . register async def list_simulations ( request ) : [EOL] return web . json_response ( request . app [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Optional [EOL] import typing [EOL] DEFAULT_STORAGE = [ { [string] : [string] , [string] : None , [string] : None , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : None , [string] : None , } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import copy [EOL] [EOL] import pytest [EOL] from yarl import URL [EOL] [EOL] from . app import create_app [EOL] from . storage import DEFAULT_STORAGE [EOL] [EOL] [EOL] TEST_STORAGE_MISSING_VALUES = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] [EOL] TEST_URL = URL ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( DEFAULT_STORAGE [ [number] ] , TEST_STORAGE_MISSING_VALUES [ [number] ] ) ) async def test_create_simulation ( aiohttp_client , data ) : [EOL] client = await aiohttp_client ( create_app ( ) ) [EOL] response = await client . post ( TEST_URL , json = data ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == data [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( None , copy . deepcopy ( DEFAULT_STORAGE ) , TEST_STORAGE_MISSING_VALUES ) , ) async def test_list_simulations ( aiohttp_client , storage ) : [EOL] app = create_app ( ) [EOL] app [ [string] ] = storage [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( TEST_URL ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == storage [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Union , Dict , List , Tuple [EOL] import typing [EOL] import pathlib [EOL] import datetime [EOL] import datetime [EOL] import re [EOL] import sys [EOL] from pathlib import Path [EOL] [EOL] [EOL] ROOT_PATH = Path ( __file__ ) . parent . parent [EOL] SRC_PATH = ROOT_PATH / [string] [EOL] sys . path . insert ( [number] , str ( SRC_PATH ) ) [EOL] [EOL] PROJECT = [string] [EOL] INIT_PY = ( SRC_PATH / PROJECT / [string] ) . read_text ( ) [EOL] AUTHOR = re . findall ( [string] , INIT_PY ) [ [number] ] [EOL] VERSION = re . findall ( [string] , INIT_PY ) [ [number] ] [EOL] TODAY = datetime . date . today ( ) [EOL] [EOL] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] templates_path = [ [string] ] [EOL] source_suffix = [string] [EOL] master_doc = [string] [EOL] [EOL] project = PROJECT [EOL] author = AUTHOR [EOL] copyright = f" [string] { TODAY . year } [string] { AUTHOR }" [EOL] [EOL] version = [string] . join ( VERSION . split ( [string] ) [ : [number] ] ) [EOL] release = VERSION [EOL] [EOL] language = [string] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] pygments_style = [string] [EOL] [EOL] html_theme = [string] [EOL] html_theme_options = { [string] : True , [string] : [string] , [string] : [string] , [string] : project , [string] : True , [string] : True , [string] : [string] , [string] : True , } [EOL] html_static_path = [ [string] ] [EOL] html_sidebars = { [string] : [ [string] , [string] , [string] ] } [EOL] [EOL] htmlhelp_basename = [string] [EOL] latex_elements = { } [EOL] latex_documents = [ ( master_doc , [string] , [string] , [string] , [string] , ) ] [EOL] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] , ) ] [EOL] [EOL] intersphinx_mapping = { [string] : None , [string] : None , [string] : None , [string] : None , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $datetime.date$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[typing.Any],builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.Any,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from openapi_core . schema . exceptions import OpenAPIMappingError [EOL] from openapi_core . schema . media_types . exceptions import OpenAPIMediaTypeError [EOL] from openapi_core . schema . parameters . exceptions import OpenAPIParameterError [EOL] [EOL] from rororo . openapi . exceptions import ( BadRequest , ObjectDoesNotExist , OpenAPIError , ValidationError , ) [EOL] [EOL] [EOL] def test_bad_request ( ) : [EOL] assert str ( BadRequest ( ) ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( None , None , [string] ) , ( [string] , None , [string] ) , ( None , [string] , [string] ) , ( [string] , [string] , [string] ) , ) , ) def test_object_does_not_exist ( label , message , expected ) : [EOL] err = ObjectDoesNotExist ( label , message = message ) [EOL] assert str ( err ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( None , { } ) , ( { [string] : [string] } , { [string] : [string] } ) ) ) def test_openapi_error_headers ( headers , expected ) : [EOL] err = OpenAPIError ( headers = headers ) [EOL] assert err . headers == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { } , [ ] ) , ( { [string] : [string] } , [ { [string] : [ [string] ] , [string] : [string] } ] , ) , ( { [number] : { [string] : { [string] : { [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , } } } } , [number] : { [string] : [string] } , } , [ { [string] : [ [number] , [string] , [string] , [string] , [number] , [string] ] , [string] : [string] , } , { [string] : [ [number] , [string] , [string] , [string] , [number] , [string] ] , [string] : [string] , } , { [string] : [ [number] , [string] ] , [string] : [string] } , ] , ) , ) , ) def test_validation_error_from_dict_data ( data , expected ) : [EOL] err = ValidationError . from_dict ( data ) [EOL] assert err . errors == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { } , [ ] ) , ( { [string] : [string] } , [ { [string] : [ [string] ] , [string] : [string] } ] ) , ) , ) def test_validation_error_from_dict_kwargs ( kwargs , expected ) : [EOL] err = ValidationError . from_dict ( ** kwargs ) [EOL] assert err . errors == expected [EOL] [EOL] [EOL] def test_validation_error_from_dict_value_error ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] ValidationError . from_dict ( { [string] : [string] } , parameters = { [string] : [string] } ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ValidationError . from_request_errors , OpenAPIMappingError ( ) , [ [string] ] ) , ( ValidationError . from_response_errors , OpenAPIMappingError ( ) , [ [string] ] , ) , ( ValidationError . from_request_errors , OpenAPIMediaTypeError ( ) , [ [string] ] , ) , ( ValidationError . from_response_errors , OpenAPIMediaTypeError ( ) , [ [string] ] , ) , ( ValidationError . from_request_errors , OpenAPIParameterError ( ) , [ [string] ] , ) , ( ValidationError . from_response_errors , OpenAPIParameterError ( ) , [ [string] ] , ) , ) , ) def test_validation_error_from_dummy_error ( method , error , expected_loc ) : [EOL] err = method ( [ error ] ) [EOL] assert err . errors == [ { [string] : expected_loc , [string] : [string] } ] [EOL] assert err . data == { [string] : [ { [string] : expected_loc , [string] : [string] } ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pathlib [EOL] import aiohttp [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from pyrsistent import pmap [EOL] [EOL] from rororo import OperationTableDef , setup_openapi [EOL] from rororo . openapi . constants import HANDLER_OPENAPI_MAPPING_KEY [EOL] from rororo . openapi . exceptions import ConfigurationError [EOL] [EOL] [EOL] ROOT_PATH = Path ( __file__ ) . parent [EOL] [EOL] OPENAPI_JSON_PATH = ROOT_PATH / [string] [EOL] OPENAPI_YAML_PATH = ROOT_PATH / [string] [EOL] [EOL] [EOL] def test_add_operations ( ) : [EOL] operations = OperationTableDef ( ) [EOL] other = OperationTableDef ( ) [EOL] all_operations = OperationTableDef ( ) [EOL] [EOL] @ operations . register @ all_operations . register async def create ( request ) : [EOL] return web . json_response ( True , status = [number] ) [EOL] [EOL] @ other . register @ all_operations . register async def update ( request ) : [EOL] return web . json_response ( True ) [EOL] [EOL] assert operations + other == all_operations [EOL] assert operations != all_operations [EOL] assert other != all_operations [EOL] [EOL] operations += other [EOL] assert operations == all_operations [EOL] assert other != all_operations [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) def test_cache_create_schema_and_spec ( schema_path ) : [EOL] operations = OperationTableDef ( ) [EOL] for _ in range ( [number] ) : [EOL] setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , cache_create_schema_and_spec = True , ) [EOL] [EOL] [EOL] def test_handle_all_create_schema_and_spec_errors ( tmp_path ) : [EOL] invalid_json = tmp_path / [string] [EOL] invalid_json . write_text ( [string] ) [EOL] [EOL] with pytest . raises ( ConfigurationError ) : [EOL] setup_openapi ( web . Application ( ) , invalid_json , OperationTableDef ( ) ) [EOL] [EOL] [EOL] def test_ignore_non_http_view_methods ( ) : [EOL] operations = OperationTableDef ( ) [EOL] [EOL] @ operations . register class UserView ( web . View ) : [EOL] async def get ( self ) : [EOL] return web . json_response ( True ) [EOL] [EOL] @ operations . register ( [string] ) async def patch ( self ) : [EOL] return web . json_response ( True ) [EOL] [EOL] async def get_user_or_404 ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def log_user ( self , user ) : [EOL] raise NotImplementedError [EOL] [EOL] assert getattr ( UserView , HANDLER_OPENAPI_MAPPING_KEY ) == pmap ( { [string] : UserView . get . __qualname__ , [string] : [string] } ) [EOL] [EOL] [EOL] def test_missed_schema_path_or_schema_and_spec ( ) : [EOL] with pytest . raises ( ConfigurationError ) : [EOL] setup_openapi ( web . Application ( ) , OperationTableDef ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from rororo . utils import ensure_collection , to_bool , to_int [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , ( [string] , ) ) , ( ( [string] , ) , ( [string] , ) ) , ( { [string] } , { [string] } ) , ( [ [string] , [string] ] , [ [string] , [string] ] ) , ) , ) def test_ensure_collection ( value , expected ) : [EOL] assert ensure_collection ( value ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , True ) , ( [string] , False ) , ( [string] , True ) , ( [string] , False ) , ( [number] , True ) , ( [number] , False ) , ( [ [number] , [number] , [number] ] , True ) , ( [ ] , False ) , ) , ) def test_to_bool ( value , expected ) : [EOL] assert to_bool ( value ) is expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [number] , [number] ) , ( [string] , [number] ) , ( [string] , None ) ) ) def test_to_int ( value , expected ) : [EOL] assert to_int ( value ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [number] , [ ] , [ [number] , [number] , [number] ] ) ) def test_to_int_default_value ( value ) : [EOL] assert to_int ( [string] , value ) == value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pathlib [EOL] import aiohttp [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import make_mocked_request [EOL] from pyrsistent import pmap [EOL] [EOL] from rororo . openapi . constants import HANDLER_OPENAPI_MAPPING_KEY [EOL] from rororo . openapi . core_data import find_core_operation [EOL] from rororo . openapi . openapi import setup_openapi [EOL] [EOL] [EOL] ROOT_PATH = Path ( __file__ ) . parent [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ROOT_PATH / [string] , ROOT_PATH / [string] ) ) def test_find_core_operation_missing_operation_id ( path ) : [EOL] request = make_mocked_request ( [string] , [string] , app = setup_openapi ( web . Application ( ) , path , server_url = [string] ) , ) [EOL] [EOL] async def broken_handler ( request ) : [EOL] return web . json_response ( False ) [EOL] [EOL] setattr ( broken_handler , HANDLER_OPENAPI_MAPPING_KEY , pmap ( { [string] : [string] } ) , ) [EOL] [EOL] assert find_core_operation ( request , broken_handler ) is None [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ROOT_PATH / [string] , ROOT_PATH / [string] ) ) def test_find_core_operation_wrong_operation_id ( path ) : [EOL] request = make_mocked_request ( [string] , [string] , app = setup_openapi ( web . Application ( ) , path , server_url = [string] ) , ) [EOL] [EOL] async def broken_handler ( request ) : [EOL] return web . json_response ( False ) [EOL] [EOL] setattr ( broken_handler , HANDLER_OPENAPI_MAPPING_KEY , pmap ( { [string] : [string] } ) , ) [EOL] [EOL] assert find_core_operation ( request , broken_handler ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any [EOL] import typing [EOL] from random import choice [EOL] [EOL] from rororo . logger import ( default_logging_dict , IgnoreErrorsFilter , update_sentry_logging , ) [EOL] [EOL] [EOL] TEST_SENTRY_DSN = [string] [EOL] [EOL] [EOL] def test_default_logging_dict ( ) : [EOL] logging_dict = default_logging_dict ( [string] ) [EOL] [EOL] assert logging_dict [ [string] ] [ [string] ] [ [string] ] == IgnoreErrorsFilter [EOL] assert len ( logging_dict [ [string] ] ) == [number] [EOL] assert [string] in logging_dict [ [string] ] [EOL] assert [string] in logging_dict [ [string] ] [EOL] [EOL] assert len ( logging_dict [ [string] ] ) == [number] [EOL] assert [string] in logging_dict [ [string] ] [EOL] assert logging_dict [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] assert [string] in logging_dict [ [string] ] [EOL] assert logging_dict [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] assert len ( logging_dict [ [string] ] ) == [number] [EOL] assert [string] in logging_dict [ [string] ] [EOL] assert logging_dict [ [string] ] [ [string] ] [ [string] ] == [ [string] , [string] , ] [EOL] assert logging_dict [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] def test_default_logging_dict_keyword_arguments ( ) : [EOL] logging_dict = default_logging_dict ( [string] , level = [string] ) [EOL] assert logging_dict [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] def test_default_logging_dict_multiple_loggers ( ) : [EOL] logging_dict = default_logging_dict ( [string] , [string] ) [EOL] [EOL] assert len ( logging_dict [ [string] ] ) == [number] [EOL] assert [string] in logging_dict [ [string] ] [EOL] assert [string] in logging_dict [ [string] ] [EOL] [EOL] [EOL] def test_ignore_errors_filter ( ) : [EOL] filter_obj = IgnoreErrorsFilter ( ) [EOL] [EOL] debug = type ( [string] , ( object , ) , { [string] : [string] } ) ( ) [EOL] info = type ( [string] , ( object , ) , { [string] : [string] } ) ( ) [EOL] warning = type ( [string] , ( object , ) , { [string] : [string] } ) ( ) [EOL] error = type ( [string] , ( object , ) , { [string] : [string] } ) ( ) [EOL] critical = type ( [string] , ( object , ) , { [string] : [string] } ) ( ) [EOL] [EOL] assert filter_obj . filter ( debug ) is True [EOL] assert filter_obj . filter ( info ) is True [EOL] assert filter_obj . filter ( warning ) is False [EOL] assert filter_obj . filter ( error ) is False [EOL] assert filter_obj . filter ( critical ) is False [EOL] [EOL] [EOL] def test_update_sentry_logging ( ) : [EOL] logging_dict = default_logging_dict ( [string] ) [EOL] update_sentry_logging ( logging_dict , TEST_SENTRY_DSN , [string] ) [EOL] assert [string] in logging_dict [ [string] ] [EOL] assert [string] in logging_dict [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_update_sentry_logging_empty_dsn ( ) : [EOL] empty = choice ( ( False , None , [string] ) ) [EOL] [EOL] logging_dict = default_logging_dict ( [string] ) [EOL] update_sentry_logging ( logging_dict , empty , [string] ) [EOL] [EOL] assert [string] not in logging_dict [ [string] ] [EOL] assert [string] not in logging_dict [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_update_sentry_logging_empty_loggers ( ) : [EOL] logging_dict = default_logging_dict ( [string] , [string] ) [EOL] update_sentry_logging ( logging_dict , TEST_SENTRY_DSN ) [EOL] assert [string] in logging_dict [ [string] ] [ [string] ] [ [string] ] [EOL] assert [string] in logging_dict [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_update_sentry_logging_ignore_sentry ( ) : [EOL] logging_dict = default_logging_dict ( [string] , [string] ) [EOL] logging_dict [ [string] ] [ [string] ] [ [string] ] = True [EOL] update_sentry_logging ( logging_dict , TEST_SENTRY_DSN ) [EOL] assert [string] not in logging_dict [ [string] ] [ [string] ] [ [string] ] [EOL] assert [string] in logging_dict [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_update_sentry_logging_kwargs ( ) : [EOL] logging_dict = default_logging_dict ( [string] ) [EOL] update_sentry_logging ( logging_dict , TEST_SENTRY_DSN , key = [string] ) [EOL] assert logging_dict [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] def test_update_sentry_logging_missed_logger ( ) : [EOL] logging_dict = default_logging_dict ( [string] ) [EOL] update_sentry_logging ( logging_dict , TEST_SENTRY_DSN , [string] , [string] ) [EOL] [EOL] [EOL] def test_update_sentry_logging_overwrite_level ( ) : [EOL] logging_dict = default_logging_dict ( [string] ) [EOL] update_sentry_logging ( logging_dict , TEST_SENTRY_DSN , level = [string] ) [EOL] assert logging_dict [ [string] ] [ [string] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , Any [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] import calendar [EOL] import datetime [EOL] import logging [EOL] import os [EOL] [EOL] import environ [EOL] import pytest [EOL] from aiohttp import web [EOL] [EOL] from rororo . logger import default_logging_dict [EOL] from rororo . settings import ( BaseSettings , from_env , immutable_settings , inject_settings , is_setting_key , setup_locale , setup_logging , setup_settings , setup_timezone , ) [EOL] from . import settings as settings_module [EOL] [EOL] [EOL] TEST_DEBUG = True [EOL] TEST_USER = [string] [EOL] _TEST_USER = [string] [EOL] [EOL] [EOL] def check_immutability ( settings ) : [EOL] [comment] [EOL] key = list ( settings . keys ( ) ) [ [number] ] [EOL] with pytest . raises ( TypeError ) : [EOL] settings [ key ] = [string] [EOL] [EOL] [comment] [EOL] assert [string] not in settings [EOL] with pytest . raises ( TypeError ) : [EOL] settings [ [string] ] = [string] [EOL] [EOL] [comment] [EOL] with pytest . raises ( AttributeError ) : [EOL] settings . update ( { key : [string] , [string] : [string] } ) [EOL] [EOL] [EOL] def test_base_settings ( ) : [EOL] settings = BaseSettings . from_environ ( ) [EOL] assert settings . host == [string] [EOL] assert settings . port == [number] [EOL] assert settings . debug is False [EOL] assert settings . level == [string] [EOL] assert settings . time_zone == [string] [EOL] assert settings . first_weekday == [number] [EOL] assert settings . locale == [string] [EOL] assert settings . sentry_dsn is None [EOL] assert settings . sentry_release is None [EOL] [EOL] [EOL] def test_base_settings_apply ( ) : [EOL] BaseSettings . from_environ ( ) . apply ( ) [EOL] [EOL] [EOL] def test_base_settings_apply_with_loggers ( ) : [EOL] BaseSettings . from_environ ( ) . apply ( loggers = ( [string] , [string] ) ) [EOL] [EOL] [EOL] def test_base_settings_from_env ( monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] assert BaseSettings . from_environ ( ) . debug is True [EOL] [EOL] [EOL] def test_base_settings_from_env_kwargs ( ) : [EOL] assert BaseSettings . from_environ ( { [string] : [string] } ) . debug is True [EOL] [EOL] [EOL] def test_base_settings_from_kwargs ( ) : [EOL] assert BaseSettings ( debug = True ) . debug is True [EOL] [EOL] [EOL] def test_base_settings_inheritance ( monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] [EOL] @ environ . config ( prefix = None , frozen = True ) class Settings ( BaseSettings ) : [EOL] use_rororo = environ . bool_var ( name = [string] , default = True ) [EOL] [EOL] settings = Settings . from_environ ( ) [EOL] assert settings . debug is False [EOL] assert settings . use_rororo is True [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] [string] , ( ( [string] , False , True , False , False ) , ( [string] , True , False , False , False ) , ( [string] , False , False , False , True ) , ( [string] , False , False , True , False ) , ) , ) def test_base_settings_is_properties ( monkeypatch , level , expected_is_test , expected_is_dev , expected_is_staging , expected_is_prod , ) : [EOL] monkeypatch . setenv ( [string] , level ) [EOL] settings = BaseSettings . from_environ ( ) [EOL] assert settings . is_test is expected_is_test [EOL] assert settings . is_dev is expected_is_dev [EOL] assert settings . is_staging is expected_is_staging [EOL] assert settings . is_prod is expected_is_prod [EOL] [EOL] [EOL] def test_from_env ( ) : [EOL] assert from_env ( [string] ) == os . getenv ( [string] ) [EOL] assert from_env ( [string] ) is None [EOL] assert from_env ( [string] , True ) is True [EOL] [EOL] [EOL] def test_immutable_settings_from_dict ( ) : [EOL] settings_dict = { [string] : True , [string] : [string] , [string] : [string] , } [EOL] settings = immutable_settings ( settings_dict ) [EOL] [EOL] assert settings [ [string] ] is True [EOL] assert settings [ [string] ] == [string] [EOL] assert [string] not in settings [EOL] [EOL] settings_dict . pop ( [string] ) [EOL] assert settings [ [string] ] == [string] [EOL] [EOL] check_immutability ( settings ) [EOL] [EOL] [EOL] def test_immutable_settings_from_globals ( ) : [EOL] settings = immutable_settings ( globals ( ) ) [EOL] [EOL] assert settings [ [string] ] is True [EOL] assert settings [ [string] ] == [string] [EOL] assert [string] not in settings [EOL] assert [string] not in settings [EOL] [EOL] check_immutability ( settings ) [EOL] [EOL] [EOL] def test_immutable_settings_from_locals ( ) : [EOL] DEBUG = True [comment] [EOL] USER = [string] [comment] [EOL] _USER = [string] [comment] [EOL] not_a_setting = True [EOL] [EOL] settings = immutable_settings ( locals ( ) ) [EOL] [EOL] assert settings [ [string] ] is True [EOL] assert settings [ [string] ] , [string] [EOL] assert [string] not in settings [EOL] assert [string] not in settings [EOL] [EOL] del DEBUG , USER , _USER [EOL] assert settings [ [string] ] == [string] [EOL] [EOL] check_immutability ( settings ) [EOL] [EOL] [EOL] def test_immutable_settings_from_module ( ) : [EOL] settings = immutable_settings ( settings_module ) [EOL] [EOL] assert settings [ [string] ] is True [EOL] assert settings [ [string] ] == os . getenv ( [string] ) [EOL] assert [string] not in settings [EOL] [EOL] check_immutability ( settings ) [EOL] [EOL] [EOL] def test_immutable_settings_with_optionals ( ) : [EOL] settings = immutable_settings ( settings_module , DEBUG = False ) [EOL] assert settings [ [string] ] is False [EOL] assert settings [ [string] ] == os . getenv ( [string] ) [EOL] [EOL] [EOL] def test_inject_settings_fail_silently ( ) : [EOL] context = { } [EOL] inject_settings ( [string] , context , True ) [EOL] assert context == { } [EOL] [EOL] [EOL] def test_inject_settings_failed ( ) : [EOL] context = { } [EOL] with pytest . raises ( NameError ) : [EOL] inject_settings ( [string] , context ) [EOL] assert context == { } [EOL] [EOL] [EOL] def test_inject_settings_from_dict ( ) : [EOL] context = { [string] : False } [EOL] settings_dict = { [string] : True , [string] : True } [EOL] inject_settings ( settings_dict , context ) [EOL] assert context [ [string] ] is True [EOL] assert [string] not in context [EOL] [EOL] [EOL] def test_inject_settings_from_module ( ) : [EOL] context = { [string] : False } [EOL] inject_settings ( settings_module , context ) [EOL] assert context [ [string] ] is True [EOL] assert [string] not in context [EOL] [EOL] [EOL] def test_inject_settings_from_str ( ) : [EOL] context = { [string] : False } [EOL] inject_settings ( [string] , context ) [EOL] assert context [ [string] ] is True [EOL] assert [string] not in context [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , True ) , ( [string] , True ) , ( [string] , False ) , ( [string] , False ) , ( [string] , False ) , ) , ) def test_is_settings_key ( key , expected ) : [EOL] assert is_setting_key ( key ) is expected [EOL] [EOL] [EOL] def test_setup_locale ( ) : [EOL] monday = calendar . day_abbr [ [number] ] [EOL] first_weekday = calendar . firstweekday ( ) [EOL] [EOL] setup_locale ( [string] ) [EOL] assert calendar . day_abbr [ [number] ] != monday [EOL] assert calendar . firstweekday ( ) == first_weekday [EOL] [EOL] [EOL] def test_setup_locale_with_first_weekday ( ) : [EOL] first_weekday = calendar . firstweekday ( ) [EOL] [EOL] setup_locale ( [string] , [number] ) [EOL] assert calendar . firstweekday ( ) == [number] [EOL] [EOL] setup_locale ( [string] , first_weekday ) [EOL] [EOL] [EOL] def test_setup_logging ( ) : [EOL] setup_logging ( default_logging_dict ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( False , [number] ) , ( True , [number] ) ) ) def test_setup_logging_remove_root_handlers ( remove , expected ) : [EOL] logging . basicConfig ( level = [string] ) [EOL] assert len ( logging . root . handlers ) == [number] [EOL] [EOL] setup_logging ( default_logging_dict ( [string] ) , remove_root_handlers = remove ) [EOL] assert len ( logging . root . handlers ) == expected [EOL] [EOL] [EOL] def test_setup_settings ( ) : [EOL] app = web . Application ( ) [EOL] assert [string] not in app [EOL] [EOL] setup_settings ( app , BaseSettings ( ) ) [EOL] assert [string] in app [EOL] [EOL] [EOL] def test_setup_timezone ( ) : [EOL] setup_timezone ( [string] ) [EOL] utc_now = datetime . datetime . now ( ) [EOL] [EOL] setup_timezone ( [string] ) [EOL] kyiv_now = datetime . datetime . now ( ) [EOL] [EOL] assert utc_now . hour != kyiv_now . hour [EOL] [EOL] [EOL] def test_setup_timezone_empty ( ) : [EOL] previous = datetime . datetime . now ( ) [EOL] setup_timezone ( None ) [EOL] assert previous . hour == datetime . datetime . now ( ) . hour [EOL] [EOL] [EOL] def test_setup_timezone_unknown ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] setup_timezone ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import os [EOL] [EOL] [EOL] DEBUG = True [EOL] USER = os . environ [ [string] ] [EOL]	0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
import pytest [EOL] from jsonschema . exceptions import FormatError [EOL] [EOL] from rororo . openapi . core_validators import EmailFormatter [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] ) , ) def test_invalid_value ( invalid_value ) : [EOL] with pytest . raises ( FormatError ) as exc : [EOL] EmailFormatter ( ) . validate ( invalid_value ) [EOL] assert str ( exc . value ) == f"{ invalid_value !r} [string] " [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) def test_valid_email ( value ) : [EOL] assert EmailFormatter ( ) . validate ( value ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import make_mocked_request [EOL] from multidict import CIMultiDict [EOL] [EOL] from rororo . aio import add_resource_context , is_xhr_request , parse_aioredis_url [EOL] [EOL] [EOL] async def dummy_handler ( request ) : [EOL] return web . Response ( text = [string] ) [EOL] [EOL] [EOL] def check_length ( iterable , expected ) : [EOL] assert len ( list ( iterable ) ) == expected [EOL] [EOL] [EOL] def test_add_resource ( ) : [EOL] router = web . UrlDispatcher ( ) [EOL] [EOL] check_length ( router . resources ( ) , [number] ) [EOL] check_length ( router . routes ( ) , [number] ) [EOL] [EOL] with add_resource_context ( router ) as add_resource : [EOL] add_resource ( [string] , dummy_handler , head = dummy_handler ) [EOL] [EOL] check_length ( router . resources ( ) , [number] ) [EOL] check_length ( router . routes ( ) , [number] ) [EOL] [EOL] [EOL] def test_add_resource_missed_handler ( ) : [EOL] router = web . UrlDispatcher ( ) [EOL] [EOL] with add_resource_context ( router ) as add_resource : [EOL] add_resource ( [string] , None , post = None ) [EOL] [EOL] check_length ( router . resources ( ) , [number] ) [EOL] check_length ( router . routes ( ) , [number] ) [EOL] [EOL] [EOL] def test_add_resource_name_prefix ( ) : [EOL] router = web . UrlDispatcher ( ) [EOL] [EOL] ctx = add_resource_context ( router , name_prefix = [string] ) [EOL] with ctx as add_resource : [EOL] add_resource ( [string] , dummy_handler , name = [string] ) [EOL] [EOL] assert str ( router [ [string] ] . url_for ( ) ) == [string] [EOL] [EOL] [EOL] def test_add_resource_name_prefix_with_dot ( ) : [EOL] router = web . UrlDispatcher ( ) [EOL] [EOL] ctx = add_resource_context ( router , name_prefix = [string] ) [EOL] with ctx as add_resource : [EOL] add_resource ( [string] , dummy_handler , name = [string] ) [EOL] [EOL] assert str ( router [ [string] ] . url_for ( ) ) == [string] [EOL] [EOL] [EOL] def test_add_resource_real_world ( ) : [EOL] router = web . UrlDispatcher ( ) [EOL] [EOL] with add_resource_context ( router , [string] , [string] ) as add_resource : [EOL] add_resource ( [string] , dummy_handler , name = [string] ) [EOL] add_resource ( [string] , get = dummy_handler , post = dummy_handler , name = [string] ) [EOL] add_resource ( [string] , get = dummy_handler , patch = dummy_handler , put = dummy_handler , delete = dummy_handler , name = [string] , ) [EOL] [EOL] check_length ( router . resources ( ) , [number] ) [EOL] check_length ( router . routes ( ) , [number] ) [EOL] [EOL] assert str ( router [ [string] ] . url_for ( ) ) == [string] [EOL] assert str ( router [ [string] ] . url_for ( ) ) == [string] [EOL] assert str ( router [ [string] ] . url_for ( user_id = [string] ) ) == [string] [EOL] [EOL] [EOL] def test_add_resource_url_prefix ( ) : [EOL] router = web . UrlDispatcher ( ) [EOL] [EOL] ctx = add_resource_context ( router , url_prefix = [string] ) [EOL] with ctx as add_resource : [EOL] add_resource ( [string] , dummy_handler , name = [string] ) [EOL] add_resource ( [string] , get = dummy_handler , post = dummy_handler , name = [string] ) [EOL] [EOL] check_length ( router . resources ( ) , [number] ) [EOL] check_length ( router . routes ( ) , [number] ) [EOL] [EOL] assert str ( router [ [string] ] . url_for ( ) ) == [string] [EOL] assert str ( router [ [string] ] . url_for ( ) ) == [string] [EOL] [EOL] [EOL] def test_add_resource_url_prefix_with_slash ( ) : [EOL] router = web . UrlDispatcher ( ) [EOL] [EOL] ctx = add_resource_context ( router , url_prefix = [string] ) [EOL] with ctx as add_resource : [EOL] add_resource ( [string] , dummy_handler , name = [string] ) [EOL] [EOL] assert str ( router [ [string] ] . url_for ( ) ) == [string] [EOL] [EOL] [EOL] def test_add_resource_wildcard ( ) : [EOL] router = web . UrlDispatcher ( ) [EOL] [EOL] with add_resource_context ( router ) as add_resource : [EOL] add_resource ( [string] , ** { [string] : dummy_handler } ) [EOL] [EOL] check_length ( router . resources ( ) , [number] ) [EOL] check_length ( router . routes ( ) , [number] ) [EOL] [EOL] [EOL] def test_is_not_xhr_request ( ) : [EOL] non_xhr_request = make_mocked_request ( [string] , [string] ) [EOL] assert is_xhr_request ( non_xhr_request ) is False [EOL] [EOL] [EOL] def test_is_xhr_request ( ) : [EOL] xhr_request = make_mocked_request ( [string] , [string] , headers = CIMultiDict ( { [string] : [string] } ) , ) [EOL] assert is_xhr_request ( xhr_request ) is True [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , { [string] : ( [string] , [number] ) , [string] : None , [string] : None } , ) , ( [string] , { [string] : ( [string] , [number] ) , [string] : [number] , [string] : None } , ) , ( [string] , { [string] : ( [string] , [number] ) , [string] : None , [string] : [string] } , ) , ) , ) def test_parse_aioredis_url ( url , expected ) : [EOL] assert parse_aioredis_url ( url ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] import datetime [EOL] [EOL] import pytest [EOL] [EOL] from rororo . timedelta import ( str_to_timedelta , timedelta_average , timedelta_div , timedelta_seconds , timedelta_to_str , ) [EOL] [EOL] [EOL] EMPTY = datetime . timedelta ( ) [EOL] HOUR = datetime . timedelta ( hours = [number] ) [EOL] TWO_HOURS = HOUR * [number] [EOL] FOUR_HOURS = HOUR * [number] [EOL] SIX_HOURS = HOUR * [number] [EOL] [EOL] [EOL] def test_str_to_timedelta_default ( ) : [EOL] assert str_to_timedelta ( [string] ) == datetime . timedelta ( hours = [number] ) [EOL] [EOL] [EOL] def test_str_to_timedelta_multiple_formats ( ) : [EOL] assert str_to_timedelta ( [string] , ( [string] , [string] , [string] ) ) == datetime . timedelta ( hours = [number] , minutes = [number] ) [EOL] [EOL] [EOL] def test_str_to_timedelta_user_format ( ) : [EOL] assert str_to_timedelta ( [string] , [string] ) == datetime . timedelta ( hours = [number] , minutes = [number] , seconds = [number] ) [EOL] [EOL] [EOL] def test_str_to_timedelta_wrong_format ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] str_to_timedelta ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( datetime . timedelta ( ) , [number] ) ) ) def test_str_to_timedelta_wrong_value ( wrong_value ) : [EOL] with pytest . raises ( ValueError ) : [EOL] str_to_timedelta ( wrong_value ) [EOL] [EOL] [EOL] def test_str_to_timedelta_wrong_value_for_default_format ( ) : [EOL] assert str_to_timedelta ( [string] ) is None [EOL] [EOL] [EOL] def test_str_to_timedelta_wrong_value_for_user_format ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] str_to_timedelta ( [string] , [string] ) [EOL] [EOL] [EOL] def test_timedelta_average ( ) : [EOL] assert timedelta_average ( TWO_HOURS , FOUR_HOURS , SIX_HOURS ) == FOUR_HOURS [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [ TWO_HOURS , FOUR_HOURS , SIX_HOURS ] , ( TWO_HOURS , FOUR_HOURS , SIX_HOURS ) ) , ) def test_timedelta_average_as_list_or_tuple ( value ) : [EOL] assert timedelta_average ( value ) == FOUR_HOURS [EOL] [EOL] [EOL] def test_timedelta_div ( ) : [EOL] assert timedelta_div ( TWO_HOURS , FOUR_HOURS ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( EMPTY , HOUR , [number] ) , ( HOUR , EMPTY , None ) ) ) def test_timedelta_div_empty ( first , second , expected ) : [EOL] assert timedelta_div ( first , second ) == expected [EOL] [EOL] [EOL] def test_timedelta_seconds ( ) : [EOL] assert timedelta_seconds ( HOUR ) == [number] [EOL] [EOL] [EOL] def test_timedelta_seconds_empty ( ) : [EOL] assert timedelta_seconds ( datetime . timedelta ( ) ) == [number] [EOL] [EOL] [EOL] def test_timedelta_seconds_multiple_days ( ) : [EOL] value = datetime . timedelta ( days = [number] , hours = [number] , minutes = [number] , seconds = [number] ) [EOL] assert timedelta_seconds ( value ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) , ) def test_timedelta_to_str ( fmt , expected ) : [EOL] value = datetime . timedelta ( hours = [number] , minutes = [number] , seconds = [number] ) [EOL] assert timedelta_to_str ( value , fmt ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) , ) def test_timedelta_to_str_full_days ( fmt , expected ) : [EOL] value = datetime . timedelta ( hours = [number] , minutes = [number] , seconds = [number] ) [EOL] assert timedelta_to_str ( value , fmt ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) , ) def test_timedelta_to_str_full_no_seconds ( fmt , expected ) : [EOL] value = datetime . timedelta ( hours = [number] ) [EOL] assert timedelta_to_str ( value , fmt ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) , ) def test_timedelta_to_str_full_weeks ( fmt , expected ) : [EOL] value = datetime . timedelta ( hours = [number] , minutes = [number] ) [EOL] assert timedelta_to_str ( value , fmt ) == expected [EOL] [EOL] [EOL] def test_timedelta_to_str_default ( ) : [EOL] assert timedelta_to_str ( datetime . timedelta ( days = [number] , hours = [number] ) ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , datetime . date . today ( ) , datetime . datetime . utcnow ( ) ) ) def test_timedelta_to_str_wrong_value ( wrong_value ) : [EOL] with pytest . raises ( ValueError ) : [EOL] timedelta_to_str ( wrong_value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pathlib [EOL] import aiohttp [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp_middlewares import cors_middleware , error_context [EOL] from yarl import URL [EOL] [EOL] from rororo import OperationTableDef , setup_openapi [EOL] from rororo . openapi . exceptions import ConfigurationError [EOL] [EOL] [EOL] rel = Path ( __file__ ) . absolute ( ) . parent [EOL] OPENAPI_JSON_PATH = rel / [string] [EOL] OPENAPI_YAML_PATH = rel / [string] [EOL] [EOL] operations = OperationTableDef ( ) [EOL] [EOL] [EOL] @ operations . register async def hello_world ( request ) : [EOL] return web . json_response ( [string] ) [EOL] [EOL] [EOL] async def plain_error_handler ( request ) : [EOL] with error_context ( request ) as context : [EOL] return web . Response ( text = context . message , status = context . status ) [EOL] [EOL] [EOL] def has_middleware ( app , middleware ) : [EOL] for item in app . middlewares : [EOL] if item . __module__ == middleware . __module__ : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_custom_default_error_handler ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , error_middleware_kwargs = { [string] : plain_error_handler } , ) [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert response . content_type == [string] [EOL] assert await response . text ( ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_default_error_handler ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , ) [EOL] client = await aiohttp_client ( app ) [EOL] [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( OPENAPI_JSON_PATH , False , None ) , ( OPENAPI_YAML_PATH , False , None ) , ( OPENAPI_JSON_PATH , True , { [string] : True } ) , ( OPENAPI_YAML_PATH , True , { [string] : ( URL ( [string] ) ) } ) , ) , ) def test_use_cors_middleware ( schema_path , is_enabled , kwargs ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , use_cors_middleware = is_enabled , cors_middleware_kwargs = kwargs , ) [EOL] assert has_middleware ( app , cors_middleware ) is is_enabled [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( OPENAPI_JSON_PATH , False , [string] ) , ( OPENAPI_YAML_PATH , False , [string] ) , ( OPENAPI_JSON_PATH , True , [string] ) , ( OPENAPI_YAML_PATH , True , [string] ) , ) , ) async def test_use_error_middleware ( aiohttp_client , schema_path , is_enabled , expected_content_type ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , use_error_middleware = is_enabled , ) [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert response . content_type == expected_content_type [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) def test_use_invalid_cors_middleware_kwargs ( schema_path ) : [EOL] with pytest . raises ( ConfigurationError ) : [EOL] setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , use_cors_middleware = True , cors_middleware_kwargs = { [string] : True } , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) def test_use_invalid_error_middleware_kwargs ( schema_path ) : [EOL] with pytest . raises ( ConfigurationError ) : [EOL] setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , use_error_middleware = True , error_middleware_kwargs = { [string] : True } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List , Dict , Any [EOL] import pathlib [EOL] import typing [EOL] import datetime [EOL] import rororo [EOL] import builtins [EOL] import io [EOL] import aiohttp [EOL] import datetime [EOL] import io [EOL] import json [EOL] import zipfile [EOL] from pathlib import Path [EOL] [EOL] import pyrsistent [EOL] import pytest [EOL] import yaml [EOL] from aiohttp import web [EOL] from openapi_core . shortcuts import create_spec [EOL] from yarl import URL [EOL] [EOL] from rororo import ( BaseSettings , get_openapi_context , get_openapi_schema , get_openapi_spec , openapi_context , OperationTableDef , setup_openapi , setup_settings_from_environ , ) [EOL] from rororo . annotations import DictStrAny [EOL] from rororo . openapi import get_validated_data [EOL] from rororo . openapi . exceptions import ( ConfigurationError , OperationError , ValidationError , ) [EOL] [EOL] [EOL] ROOT_PATH = Path ( __file__ ) . parent [EOL] [EOL] INVALID_OPENAPI_JSON_PATH = ROOT_PATH / [string] [EOL] INVALID_OPENAPI_YAML_PATH = ROOT_PATH / [string] [EOL] OPENAPI_JSON_PATH = ROOT_PATH / [string] [EOL] OPENAPI_YAML_PATH = ROOT_PATH / [string] [EOL] TEST_NESTED_OBJECT = { [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { } } , [string] : [ { [string] : [string] , [string] : { [string] : [number] } } , { [string] : [string] , [string] : { [string] : [number] } } , ] , [string] : [ [string] , [string] , [string] ] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [ [number] , [number] , [number] ] } , } [EOL] [EOL] operations = OperationTableDef ( ) [EOL] invalid_operations = OperationTableDef ( ) [EOL] [EOL] [EOL] def custom_json_loader ( content ) : [EOL] return json . load ( io . BytesIO ( content ) ) [EOL] [EOL] [EOL] def custom_yaml_loader ( content ) : [EOL] return yaml . load ( content , Loader = yaml . SafeLoader ) [EOL] [EOL] [EOL] @ invalid_operations . register ( [string] ) async def does_not_exist ( request ) : [EOL] return web . Response ( text = [string] ) [EOL] [EOL] [EOL] @ operations . register ( [string] ) async def create_post ( request ) : [EOL] data = get_validated_data ( request ) [EOL] [EOL] published_at = data [ [string] ] [EOL] if published_at . tzinfo is None : [EOL] raise ValidationError . from_dict ( body = { [string] : [string] } ) [EOL] [EOL] return web . json_response ( { ** data , [string] : [number] , [string] : data [ [string] ] . isoformat ( ) } , status = [number] , ) [EOL] [EOL] [EOL] @ operations . register async def hello_world ( request ) : [EOL] with openapi_context ( request ) as context : [EOL] name = context . parameters . query . get ( [string] ) or [string] [EOL] email = context . parameters . query . get ( [string] ) or [string] [EOL] return web . json_response ( { [string] : f" [string] { name } [string] " , [string] : email } ) [EOL] [EOL] [EOL] @ operations . register async def retrieve_any_object_from_request_body ( request , ) : [EOL] return web . json_response ( pyrsistent . thaw ( get_validated_data ( request ) ) ) [EOL] [EOL] [EOL] @ operations . register async def retrieve_array_from_request_body ( request , ) : [EOL] with openapi_context ( request ) as context : [EOL] return web . json_response ( pyrsistent . thaw ( context . data ) ) [EOL] [EOL] [EOL] @ operations . register async def retrieve_empty ( request ) : [EOL] context = get_openapi_context ( request ) [EOL] return web . Response ( status = [number] , headers = { [string] : context . security . get ( [string] ) or [string] } ) [EOL] [EOL] [EOL] @ operations . register async def retrieve_invalid_response ( request ) : [EOL] return web . json_response ( { } ) [EOL] [EOL] [EOL] @ operations . register async def retrieve_post ( request ) : [EOL] context = get_openapi_context ( request ) [EOL] return web . json_response ( { [string] : context . parameters . path [ [string] ] , [string] : [string] } ) [EOL] [EOL] [EOL] @ operations . register async def retrieve_nested_object_from_request_body ( request , ) : [EOL] with openapi_context ( request ) as context : [EOL] data = pyrsistent . thaw ( context . data ) [EOL] data [ [string] ] = str ( data [ [string] ] ) [EOL] [EOL] return web . json_response ( data , headers = { [string] : str ( type ( context . data ) ) , [string] : str ( type ( context . data [ [string] ] [ [string] ] ) ) , [string] : str ( type ( context . data [ [string] ] [ [string] ] ) ) , [string] : str ( type ( context . data [ [string] ] ) ) , } , ) [EOL] [EOL] [EOL] @ operations . register async def retrieve_zip ( request ) : [EOL] output = io . BytesIO ( ) [EOL] [EOL] with zipfile . ZipFile ( output , [string] ) as handler : [EOL] handler . writestr ( [string] , [string] ) [EOL] [EOL] output . seek ( [number] ) [EOL] return web . Response ( body = output , content_type = [string] , headers = { [string] : [string] } , ) [EOL] [EOL] [EOL] @ operations . register async def upload_image ( request ) : [EOL] return web . Response ( body = get_openapi_context ( request ) . data , content_type = request . content_type , status = [number] , ) [EOL] [EOL] [EOL] @ operations . register async def upload_text ( request ) : [EOL] return web . Response ( text = get_openapi_context ( request ) . data , content_type = request . content_type , status = [number] , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_any_object_request_body ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = URL ( [string] ) ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . post ( [string] , json = TEST_NESTED_OBJECT ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == TEST_NESTED_OBJECT [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { } , [number] , { [string] : [ { [string] : [ [string] ] , [string] : [string] } ] } , ) , ( [ ] , [number] , { [string] : [ { [string] : [ [string] ] , [string] : [string] } ] } , ) , ( [ [string] ] , [number] , { [string] : [ { [string] : [ [string] , [number] ] , [string] : [string] } ] } , ) , ( [ [string] , [string] ] , [number] , [ [string] , [string] ] ) , ) , ) async def test_array_request_body ( aiohttp_client , data , expected_status , expected_response ) : [EOL] app = setup_openapi ( web . Application ( ) , OPENAPI_YAML_PATH , operations , server_url = URL ( [string] ) , ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . post ( [string] , json = data ) [EOL] assert response . status == expected_status [EOL] assert await response . json ( ) == expected_response [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_create_post_201 ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] ) [EOL] published_at = [string] [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . post ( [string] , json = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : published_at , } , ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : published_at , } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( OPENAPI_JSON_PATH , { } , [ { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] , [string] ] , [string] : [string] } , ] , ) , ( OPENAPI_YAML_PATH , { [string] : [string] } , [ { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] , [string] ] , [string] : [string] } , ] , ) , ( OPENAPI_JSON_PATH , { [string] : [string] , [string] : [string] } , [ { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] , [string] ] , [string] : [string] } , ] , ) , ( OPENAPI_YAML_PATH , { [string] : [string] , [string] : [string] , [string] : [string] } , [ { [string] : [ [string] , [string] ] , [string] : [string] } ] , ) , ) , ) async def test_create_post_422 ( aiohttp_client , schema_path , invalid_data , expected_detail ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = URL ( [string] ) , ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . post ( [string] , json = invalid_data ) [EOL] assert response . status == [number] [EOL] assert ( await response . json ( ) ) [ [string] ] == expected_detail [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( OPENAPI_JSON_PATH , custom_json_loader ) , ( OPENAPI_YAML_PATH , custom_yaml_loader ) , ) , ) def test_custom_schema_loader ( schema_path , schema_loader ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , schema_loader = schema_loader , ) [EOL] assert isinstance ( get_openapi_schema ( app ) , dict ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_email_format ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] , params = { [string] : [string] } ) [EOL] assert response . status == [number] [EOL] assert ( await response . json ( ) ) [ [string] ] == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_invalid_parameter_format ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [ { [string] : [ [string] , [string] ] , [string] : [string] , } ] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_invalid_parameter_value ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [ { [string] : [ [string] , [string] ] , [string] : [string] , } ] } [EOL] [EOL] [EOL] def test_get_openapi_schema_no_schema ( ) : [EOL] with pytest . raises ( ConfigurationError ) : [EOL] get_openapi_schema ( web . Application ( ) ) [EOL] [EOL] [EOL] def test_get_openapi_spec_no_spec ( ) : [EOL] with pytest . raises ( ConfigurationError ) : [EOL] get_openapi_spec ( web . Application ( ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_multiple_request_errors ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [ { [string] : [ [string] , [string] ] , [string] : [string] , } , { [string] : [ [string] , [string] ] , [string] : [string] , } , ] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( OPENAPI_JSON_PATH , None , [string] ) , ( OPENAPI_JSON_PATH , [string] , [string] ) , ( str ( OPENAPI_JSON_PATH ) , None , [string] ) , ( str ( OPENAPI_JSON_PATH ) , [string] , [string] ) , ( OPENAPI_YAML_PATH , None , [string] ) , ( OPENAPI_YAML_PATH , [string] , [string] ) , ( str ( OPENAPI_YAML_PATH ) , None , [string] ) , ( str ( OPENAPI_YAML_PATH ) , [string] , [string] ) , ) , ) async def test_openapi ( aiohttp_client , schema_path , query_string , expected_message ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] url = [string] [EOL] [EOL] response = await client . get ( f"{ url }{ query_string }" if query_string is not None else url ) [EOL] assert response . status == [number] [EOL] assert ( await response . json ( ) ) [ [string] ] == expected_message [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( False , True ) ) async def test_openapi_validate_response ( aiohttp_client , is_enabled ) : [EOL] app = web . Application ( ) [EOL] setup_openapi ( app , OPENAPI_YAML_PATH , operations , server_url = [string] , is_validate_response = is_enabled , ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( True , [string] , [number] ) , ( False , [string] , [number] ) , ( True , [string] , [number] ) , ( False , [string] , [number] ) , ( True , [string] , [number] ) , ( False , [string] , [number] ) , ) , ) async def test_openapi_schema_handler ( aiohttp_client , has_openapi_schema_handler , url , expected_status ) : [EOL] app = web . Application ( ) [EOL] setup_openapi ( app , OPENAPI_YAML_PATH , operations , server_url = URL ( [string] ) , has_openapi_schema_handler = has_openapi_schema_handler , ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( url ) [EOL] assert response . status == expected_status [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( OPENAPI_JSON_PATH , { } , [string] ) , ( OPENAPI_JSON_PATH , { [string] : [string] } , [string] ) , ( OPENAPI_YAML_PATH , { } , [string] ) , ( OPENAPI_YAML_PATH , { [string] : [string] } , [string] ) , ) , ) async def test_optional_security_scheme ( aiohttp_client , schema_path , headers , expected ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] , headers = headers ) [EOL] assert response . status == [number] [EOL] assert response . headers [ [string] ] == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_request_body_nested_object ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . post ( [string] , json = TEST_NESTED_OBJECT ) [EOL] assert response . status == [number] [EOL] assert response . headers [ [string] ] == [string] [EOL] assert ( response . headers [ [string] ] == [string] ) [EOL] assert ( response . headers [ [string] ] == [string] ) [EOL] assert response . headers [ [string] ] == [string] [EOL] assert await response . json ( ) == TEST_NESTED_OBJECT [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( OPENAPI_JSON_PATH , custom_json_loader ) , ( OPENAPI_YAML_PATH , custom_yaml_loader ) , ) , ) async def test_setup_openapi_schema_and_spec ( aiohttp_client , schema_path , loader ) : [EOL] schema = loader ( schema_path . read_bytes ( ) ) [EOL] spec = create_spec ( schema ) [EOL] [EOL] app = setup_openapi ( web . Application ( ) , operations , schema = schema , spec = spec , server_url = [string] , ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( OPENAPI_JSON_PATH , custom_json_loader ) , ( OPENAPI_YAML_PATH , custom_yaml_loader ) , ) , ) async def test_setup_openapi_schema_and_path_ignore_invalid_schema_path ( aiohttp_client , schema_path , loader ) : [EOL] schema = loader ( schema_path . read_bytes ( ) ) [EOL] spec = create_spec ( schema ) [EOL] [EOL] setup_openapi ( web . Application ( ) , INVALID_OPENAPI_JSON_PATH , operations , schema = schema , spec = spec , server_url = [string] , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) def test_setup_openapi_invalid_operation ( schema_path ) : [EOL] with pytest . raises ( OperationError ) : [EOL] setup_openapi ( web . Application ( ) , schema_path , invalid_operations , server_url = [string] , ) [EOL] [EOL] [EOL] def test_setup_openapi_invalid_path ( ) : [EOL] with pytest . raises ( ConfigurationError ) : [EOL] setup_openapi ( web . Application ( ) , ROOT_PATH / [string] , operations ) [EOL] [EOL] [EOL] def test_setup_openapi_invalid_file ( ) : [EOL] with pytest . raises ( ConfigurationError ) : [EOL] setup_openapi ( web . Application ( ) , ROOT_PATH / [string] , operations ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( INVALID_OPENAPI_JSON_PATH , INVALID_OPENAPI_YAML_PATH ) ) def test_setup_openapi_invalid_spec ( schema_path ) : [EOL] with pytest . raises ( ConfigurationError ) : [EOL] setup_openapi ( web . Application ( ) , schema_path , operations ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( OPENAPI_JSON_PATH , [string] , [string] , [number] ) , ( OPENAPI_JSON_PATH , [string] , [string] , [number] ) , ( OPENAPI_YAML_PATH , [string] , [string] , [number] ) , ( OPENAPI_YAML_PATH , [string] , [string] , [number] ) , ( OPENAPI_JSON_PATH , [string] , [string] , [number] ) , ( OPENAPI_JSON_PATH , [string] , [string] , [number] ) , ( OPENAPI_YAML_PATH , [string] , [string] , [number] ) , ( OPENAPI_YAML_PATH , [string] , [string] , [number] ) , ) , ) async def test_setup_openapi_server_url_from_settings ( monkeypatch , aiohttp_client , schema_path , level , url , expected_status ) : [EOL] monkeypatch . setenv ( [string] , level ) [EOL] [EOL] app = setup_openapi ( setup_settings_from_environ ( web . Application ( ) , BaseSettings ) , schema_path , operations , ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( url ) [EOL] assert response . status == expected_status [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) def test_setup_openapi_server_url_invalid_level ( monkeypatch , schema_path ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] [EOL] with pytest . raises ( ConfigurationError ) : [EOL] setup_openapi ( setup_settings_from_environ ( web . Application ( ) , BaseSettings ) , schema_path , operations , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) def test_setup_openapi_server_url_does_not_set ( schema_path ) : [EOL] with pytest . raises ( ConfigurationError ) : [EOL] setup_openapi ( web . Application ( ) , schema_path , operations ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_upload_image ( aiohttp_client , schema_path ) : [EOL] blank_png = ( Path ( __file__ ) . parent / [string] / [string] ) . read_bytes ( ) [EOL] [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . post ( [string] , data = blank_png , headers = { [string] : [string] } , ) [EOL] assert response . status == [number] [EOL] assert await response . read ( ) == blank_png [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_upload_text ( aiohttp_client , schema_path ) : [EOL] text = [string] [EOL] [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . post ( [string] , data = text . encode ( [string] ) , headers = { [string] : [string] } , ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == text [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_validate_binary_response ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , is_validate_response = True , ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert response . content_type == [string] [EOL] [EOL] content = io . BytesIO ( await response . read ( ) ) [EOL] with zipfile . ZipFile ( content ) as handler : [EOL] with handler . open ( [string] ) as item : [EOL] assert item . read ( ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_validate_empty_response ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , is_validate_response = True , ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( OPENAPI_JSON_PATH , False , [number] ) , ( OPENAPI_JSON_PATH , True , [number] ) , ( OPENAPI_YAML_PATH , False , [number] ) , ( OPENAPI_JSON_PATH , True , [number] ) , ) , ) async def test_validate_response ( aiohttp_client , schema_path , is_validate_response , expected_status ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , is_validate_response = is_validate_response , ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == expected_status [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( OPENAPI_JSON_PATH , OPENAPI_YAML_PATH ) ) async def test_validate_response_error ( aiohttp_client , schema_path ) : [EOL] app = setup_openapi ( web . Application ( ) , schema_path , operations , server_url = [string] , is_validate_response = True , ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert await response . json ( ) == { [string] : [ { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] , [string] ] , [string] : [string] } , ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $rororo.annotations.DictStrAny$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rororo.annotations.DictStrAny$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp_middlewares import error_middleware [EOL] [EOL] from rororo . openapi . utils import add_prefix , get_openapi_context [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) , ) def test_add_prefix ( path , prefix , expected ) : [EOL] assert add_prefix ( path , prefix ) == expected [EOL] [EOL] [EOL] async def test_get_openapi_context_error ( aiohttp_client ) : [EOL] async def handler ( request ) : [EOL] return web . json_response ( get_openapi_context ( request ) . operation . id ) [EOL] [EOL] app = web . Application ( middlewares = ( error_middleware ( ) , ) ) [EOL] app . router . add_get ( [string] , handler ) [EOL] [EOL] client = await aiohttp_client ( app ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert ( await response . json ( ) ) [ [string] ] . split ( ) [ [number] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0