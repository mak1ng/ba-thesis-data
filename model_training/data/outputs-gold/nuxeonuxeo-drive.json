import types [EOL] [docstring] [EOL] from types import SimpleNamespace [EOL] [EOL] Behavior = SimpleNamespace ( server_deletion = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $types.SimpleNamespace$ 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , List , Type , Dict , Callable , Any [EOL] import nxdrive [EOL] import datetime [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] import json [EOL] import os [EOL] import re [EOL] from contextlib import suppress [EOL] from datetime import datetime [EOL] from pathlib import Path [EOL] from typing import Any , Callable , Dict , List , Tuple [EOL] [EOL] from PyQt5 . QtCore import QTranslator , pyqtProperty , pyqtSignal , pyqtSlot [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] class Translator ( QTranslator ) : [EOL] [EOL] languageChanged = pyqtSignal ( ) [EOL] singleton = None [EOL] current_language = [string] [EOL] [EOL] def __init__ ( self , path , lang = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _labels = { } [EOL] [EOL] [comment] [EOL] for translation in path . iterdir ( ) : [EOL] label = self . guess_label ( translation . name ) [EOL] self . _labels [ label ] = json . loads ( translation . read_text ( encoding = [string] ) ) [EOL] [EOL] [comment] [EOL] self . langs = { } [EOL] for key in self . _labels : [EOL] with suppress ( KeyError ) : [EOL] self . langs [ key ] = ( key , self . _labels [ key ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] try : [EOL] self . set_language ( lang ) [EOL] except ValueError : [EOL] self . set_language ( [string] ) [EOL] self . _fallback = self . _labels [ [string] ] [EOL] [EOL] Translator . singleton = self [EOL] [EOL] def translate ( self , _context , text , _disambiguation , _n ) : [EOL] [docstring] [EOL] return self . get_translation ( text ) [EOL] [EOL] @ pyqtProperty ( str , notify = languageChanged ) def tr ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def guess_label ( filename ) : [EOL] [docstring] [EOL] label = os . path . splitext ( filename ) [ [number] ] . replace ( [string] , [string] ) [EOL] if label == [string] : [EOL] label = [string] [EOL] return label [EOL] [EOL] @ staticmethod def on_change ( func ) : [EOL] if not Translator . singleton : [EOL] raise RuntimeError ( [string] ) [EOL] Translator . singleton . languageChanged . connect ( func ) [EOL] [EOL] @ staticmethod def _tokenize ( label , values = None ) : [EOL] [docstring] [EOL] if not values : [EOL] return label [EOL] [EOL] result = re . sub ( [string] , [string] , label ) [EOL] return result . format ( * ( [ [string] ] + values ) ) [EOL] [EOL] def get_translation ( self , label , values = None ) : [EOL] if label not in self . _current : [EOL] if label not in self . _fallback : [EOL] return label [EOL] return self . _tokenize ( self . _fallback [ label ] , values ) [EOL] return self . _tokenize ( self . _current [ label ] , values ) [EOL] [EOL] @ pyqtSlot ( str ) def set_language ( self , lang ) : [EOL] try : [EOL] self . _current = self . _labels [ lang ] [EOL] except KeyError : [EOL] raise ValueError ( f" [string] { lang !r}" ) [EOL] else : [EOL] if self . current_language != lang : [EOL] self . current_language = lang [EOL] self . languageChanged . emit ( ) [EOL] [EOL] @ staticmethod def set ( lang ) : [EOL] if not Translator . singleton : [EOL] raise RuntimeError ( [string] ) [EOL] Translator . singleton . set_language ( lang ) [EOL] [EOL] @ staticmethod def format_datetime ( date ) : [EOL] return date . strftime ( Translator . get ( [string] ) ) [EOL] [EOL] @ staticmethod def locale ( ) : [EOL] if not Translator . singleton : [EOL] raise RuntimeError ( [string] ) [EOL] return Translator . singleton . current_language [EOL] [EOL] @ staticmethod def get ( label , values = None ) : [EOL] if not Translator . singleton : [EOL] raise RuntimeError ( [string] ) [EOL] return Translator . singleton . get_translation ( label , values ) [EOL] [EOL] @ staticmethod def languages ( ) : [EOL] if not Translator . singleton : [EOL] raise RuntimeError ( [string] ) [EOL] return sorted ( Translator . singleton . langs . values ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime.datetime$ 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import types [EOL] import typing [EOL] [docstring] [EOL] from types import SimpleNamespace [EOL] from typing import List [EOL] [EOL] Feature = SimpleNamespace ( auto_update = True , direct_edit = True , direct_transfer = False , s3 = False , ) [EOL] [EOL] Beta = [ [string] , [string] ] [EOL] [EOL] DisabledFeatures = [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.SimpleNamespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0
[comment] [EOL] import types [EOL] [docstring] [EOL] from types import SimpleNamespace [EOL] [EOL] State = SimpleNamespace ( about_to_quit = False , has_crashed = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $types.SimpleNamespace$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] __author__ = [string] [EOL] __version__ = [string] [EOL] __copyright__ = [string] [EOL]	0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
	0
	0
[comment] [EOL] from typing import Dict , Tuple , Generator [EOL] import nxdrive [EOL] import threading [EOL] import logging [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] from logging import getLogger [EOL] from pathlib import Path [EOL] from threading import Lock [EOL] from time import monotonic [EOL] from typing import Dict , Generator [EOL] [EOL] __all__ = ( [string] , ) [EOL] log = getLogger ( __name__ ) [EOL] [EOL] [EOL] class BlocklistItem : [EOL] def __init__ ( self , path , next_try = [number] ) : [EOL] self . path = path [EOL] self . _interval = next_try [EOL] [EOL] self . _next_try = self . _interval + int ( monotonic ( ) ) [EOL] self . count = [number] [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { type ( self ) . __name__ } [string] { self . path !r} [string] { self . count } [string] " [EOL] [EOL] def __str__ ( self ) : [EOL] return repr ( self ) [EOL] [EOL] def check ( self , cur_time ) : [EOL] return cur_time > self . _next_try [EOL] [EOL] def increase ( self , next_try = None ) : [EOL] [comment] [EOL] self . count += [number] [EOL] cur_time = int ( monotonic ( ) ) [EOL] if next_try is not None : [EOL] self . _next_try = next_try + cur_time [EOL] else : [EOL] self . _next_try = self . count * self . _interval + cur_time [EOL] [EOL] [EOL] class BlocklistQueue : [EOL] def __init__ ( self , delay = [number] ) : [EOL] self . _delay = delay [EOL] [EOL] self . _queue = { } [EOL] self . _lock = Lock ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { type ( self ) . __name__ } [string] { len ( self . _queue ) } [string] " [EOL] [EOL] def __str__ ( self ) : [EOL] return repr ( self ) [EOL] [EOL] def empty ( self ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] return not bool ( self . _queue ) [EOL] [EOL] def push ( self , path ) : [EOL] with self . _lock : [EOL] item = BlocklistItem ( path , next_try = self . _delay ) [EOL] log . debug ( f" [string] { item !r} [string] { self . _delay } [string] " ) [EOL] self . _queue [ path ] = item [EOL] [EOL] def repush ( self , item , increase_wait = True ) : [EOL] [comment] [EOL] with self . _lock : [EOL] item . increase ( next_try = None if increase_wait else self . _delay ) [EOL] self . _queue [ item . path ] = item [EOL] [EOL] def get ( self ) : [EOL] with self . _lock : [EOL] cur_time = int ( monotonic ( ) ) [EOL] for item in self . _queue . copy ( ) . values ( ) : [EOL] if not item . check ( cur_time ) : [EOL] continue [EOL] [EOL] log . debug ( f" [string] { item !r}" ) [EOL] yield self . _queue . pop ( item . path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 $builtins.int$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Dict[pathlib.Path,BlocklistItem]$ 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $nxdrive.engine.blocklist_queue.BlocklistItem$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $nxdrive.engine.blocklist_queue.BlocklistItem$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 $nxdrive.engine.blocklist_queue.BlocklistItem$ 0 0 0 $None$ 0 0 0 $BlocklistItem$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $BlocklistItem$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $BlocklistItem$ 0 0 0 0 $BlocklistItem$ 0 0 0 $typing.Generator[BlocklistItem,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Tuple [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] import sqlite3 [EOL] from contextlib import suppress [EOL] from datetime import datetime , timedelta [EOL] from logging import getLogger [EOL] from os import fsync [EOL] from pathlib import Path [EOL] from shutil import copyfile [EOL] [EOL] __all__ = ( [string] , [string] , [string] ) [EOL] [EOL] log = getLogger ( __name__ ) [EOL] [EOL] [EOL] def is_healthy ( database ) : [EOL] [docstring] [EOL] [EOL] log . info ( f" [string] { database !r}" ) [EOL] with sqlite3 . connect ( str ( database ) ) as con : [EOL] status = con . cursor ( ) . execute ( [string] ) . fetchone ( ) [EOL] return bool ( status [ [number] ] == [string] ) [EOL] [EOL] [EOL] def dump ( database , dump_file ) : [EOL] [docstring] [EOL] [EOL] log . info ( f" [string] { database !r} [string] { dump_file !r} [string] " ) [EOL] with sqlite3 . connect ( str ( database ) ) as con , dump_file . open ( mode = [string] , encoding = [string] ) as f : [EOL] for line in con . iterdump ( ) : [EOL] f . write ( f"{ line } [string] " ) [EOL] [EOL] [comment] [EOL] f . flush ( ) [EOL] fsync ( f . fileno ( ) ) [EOL] [EOL] log . info ( [string] ) [EOL] [EOL] [EOL] def read ( dump_file , database ) : [EOL] [docstring] [EOL] [EOL] log . info ( f" [string] { dump_file !r} [string] { database !r} [string] " ) [EOL] with sqlite3 . connect ( str ( database ) ) as con : [EOL] con . executescript ( dump_file . read_text ( encoding = [string] ) ) [EOL] log . info ( [string] ) [EOL] [EOL] [EOL] def fix_db ( database , dump_file = Path ( [string] ) ) : [EOL] [docstring] [EOL] [EOL] if is_healthy ( database ) : [EOL] return [EOL] [EOL] log . info ( f" [string] { database !r} [string] " ) [EOL] [EOL] [comment] [EOL] try : [EOL] old_size = database . stat ( ) . st_size [EOL] backup = database . with_name ( f"{ database . name } [string] " ) [EOL] dump ( database , dump_file ) [EOL] copyfile ( str ( database ) , str ( backup ) ) [EOL] database . unlink ( ) [EOL] except sqlite3 . DatabaseError : [EOL] [comment] [EOL] [comment] [EOL] log . exception ( [string] ) [EOL] raise [EOL] except Exception : [EOL] log . exception ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] try : [EOL] read ( dump_file , database ) [EOL] backup . unlink ( ) [EOL] except Exception : [EOL] log . exception ( [string] ) [EOL] log . info ( [string] ) [EOL] if not database . is_file ( ) : [EOL] backup . rename ( database ) [EOL] return [EOL] finally : [EOL] with suppress ( OSError ) : [EOL] dump_file . unlink ( ) [EOL] [EOL] new_size = database . stat ( ) . st_size [EOL] log . info ( f" [string] { ( old_size - new_size ) / [number] } [string] " ) [EOL] [EOL] [EOL] def restore_backup ( database ) : [EOL] [docstring] [EOL] [EOL] if not database : [EOL] return False [EOL] [EOL] backup_folder = database . with_name ( [string] ) [EOL] if not backup_folder . is_dir ( ) : [EOL] log . info ( [string] ) [EOL] return False [EOL] [EOL] backups = list ( backup_folder . glob ( f"{ database . name } [string] " ) ) [EOL] if not backups : [EOL] log . info ( f" [string] { database }" ) [EOL] return False [EOL] [EOL] latest = max ( backups , key = lambda p : int ( p . name . split ( [string] ) [ - [number] ] ) ) [EOL] log . info ( f" [string] { latest }" ) [EOL] if database . exists ( ) : [EOL] database . unlink ( ) [EOL] copyfile ( latest , database ) [EOL] return True [EOL] [EOL] [EOL] def save_backup ( database ) : [EOL] [docstring] [EOL] [EOL] if not ( database and database . is_file ( ) ) : [EOL] log . info ( [string] ) [EOL] return False [EOL] if not is_healthy ( database ) : [EOL] log . info ( f"{ database } [string] " ) [EOL] return False [EOL] [EOL] backup_folder = database . with_name ( [string] ) [EOL] backup_folder . mkdir ( exist_ok = True ) [EOL] [EOL] yesterday = int ( ( datetime . now ( ) - timedelta ( days = [number] ) ) . timestamp ( ) ) [EOL] old_backups = [ b for b in backup_folder . glob ( f"{ database . name } [string] " ) if int ( b . name . split ( [string] ) [ - [number] ] ) < yesterday ] [EOL] [comment] [EOL] for backup in old_backups : [EOL] log . debug ( f" [string] { backup }" ) [EOL] with suppress ( FileNotFoundError ) : [EOL] backup . unlink ( ) [comment] [EOL] [EOL] backup = backup_folder / f"{ database . name } [string] { int ( datetime . now ( ) . timestamp ( ) ) }" [EOL] log . info ( f" [string] { backup }" ) [EOL] copyfile ( database , backup ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] import pytest [EOL] from _pytest . runner import runtestprotocol [EOL] [EOL] [EOL] def get_random ( item ) : [EOL] for random in item . iter_markers ( [string] ) : [EOL] if random . kwargs . get ( [string] , True ) : [EOL] return random [EOL] return None [EOL] [EOL] [EOL] def get_repeat ( item ) : [EOL] random = get_random ( item ) [EOL] return random . kwargs . get ( [string] , [number] ) if random else None [EOL] [EOL] [EOL] def get_mode ( item ) : [EOL] random = get_random ( item ) [EOL] mode = ( ( item . config . default_mode or random . kwargs . get ( [string] , [string] ) ) [EOL] if random [EOL] else None ) [EOL] if mode not in { [string] , [string] , [string] } : [EOL] mode = [string] [EOL] return mode [EOL] [EOL] [EOL] def get_condition ( item ) : [EOL] random = get_random ( item ) [EOL] return random . kwargs . get ( [string] , True ) if random else False [EOL] [EOL] [EOL] def pytest_configure ( config ) : [EOL] [docstring] [EOL] config . default_mode = os . environ . get ( [string] , None ) [EOL] if config . default_mode not in { [string] , [string] , [string] } : [EOL] config . default_mode = None [EOL] config . addinivalue_line ( [string] , [string] [string] [string] [string] [string] [string] [string] , ) [EOL] [EOL] [EOL] def pytest_collection_modifyitems ( items ) : [EOL] [docstring] [EOL] for item in items : [EOL] marker = get_random ( item ) [EOL] if not marker : [EOL] continue [EOL] mode = get_mode ( item ) [EOL] if mode == [string] : [EOL] reason = marker . args [ [number] ] if marker . args else [string] [EOL] item . add_marker ( pytest . mark . skip ( reason = reason ) ) [EOL] [EOL] [EOL] def pytest_runtest_protocol ( item , nextitem ) : [EOL] [docstring] [EOL] condition = get_condition ( item ) [EOL] if not condition : [EOL] [comment] [EOL] [comment] [EOL] return [EOL] [EOL] repeat = get_repeat ( item ) [EOL] mode = get_mode ( item ) [EOL] [EOL] for i in range ( repeat ) : [EOL] item . ihook . pytest_runtest_logstart ( nodeid = item . nodeid , location = item . location ) [EOL] reports = runtestprotocol ( item , nextitem = nextitem , log = False ) [EOL] [EOL] for report in reports : [comment] [EOL] report . total_repeat = repeat [EOL] report . repeat = i [EOL] [EOL] if mode == [string] : [EOL] condition = not report . failed or hasattr ( report , [string] ) [EOL] elif mode == [string] : [EOL] condition = report . failed or report . skipped [EOL] [EOL] [comment] [EOL] if i == repeat - [number] or condition or report . when != [string] : [EOL] [comment] [EOL] if mode == [string] and i == repeat - [number] and report . when == [string] : [EOL] [comment] [EOL] report . outcome = [string] [EOL] report . sections . append ( ( [string] , f" [string] { item . nodeid !r} [string] " ) ) [EOL] [EOL] [comment] [EOL] item . ihook . pytest_runtest_logreport ( report = report ) [EOL] else : [EOL] [comment] [EOL] report . outcome = [string] [EOL] item . ihook . pytest_runtest_logreport ( report = report ) [EOL] [EOL] break [comment] [EOL] else : [EOL] return True [comment] [EOL] return True [EOL] [EOL] [EOL] def pytest_report_teststatus ( report ) : [EOL] if report . outcome == [string] : [EOL] return ( [string] , [string] , ( f" [string] { report . repeat + [number] : [string] } [string] { report . total_repeat }" , { [string] : True } , ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] [EOL] import pytest [EOL] [EOL] from nxdrive . constants import LINUX , MAC , WINDOWS [EOL] [EOL] [comment] [EOL] jenkins_only = pytest . mark . skipif ( [string] not in os . environ , reason = [string] ) [EOL] [EOL] [comment] [EOL] linux_only = pytest . mark . skipif ( not LINUX , reason = [string] ) [EOL] mac_only = pytest . mark . skipif ( not MAC , reason = [string] ) [EOL] windows_only = pytest . mark . skipif ( not WINDOWS , reason = [string] ) [EOL] [EOL] not_linux = pytest . mark . skipif ( LINUX ) [EOL] not_mac = pytest . mark . skipif ( MAC ) [EOL] not_windows = pytest . mark . skipif ( WINDOWS ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import typing [EOL] import nuxeo [EOL] [docstring] [EOL] import env [EOL] from nuxeo . client import Nuxeo [EOL] [EOL] [EOL] def remove_old_ws ( server ) : [EOL] docs = server . documents . get_children ( path = env . WS_DIR ) [EOL] for doc in docs : [EOL] if doc . title . startswith ( ( [string] , [string] ) ) : [EOL] doc . delete ( ) [EOL] print ( f" [string] { doc }" ) [EOL] [EOL] [EOL] def remove_old_users ( server ) : [EOL] op = server . operations . new ( [string] ) [EOL] op . params = { [string] : [string] } [EOL] for user in op . execute ( ) [ [string] ] : [EOL] server . users . delete ( user [ [string] ] ) [EOL] print ( f" [string] { user }" ) [EOL] [EOL] [EOL] auth = ( env . NXDRIVE_TEST_USERNAME , env . NXDRIVE_TEST_PASSWORD ) [EOL] server = Nuxeo ( host = env . NXDRIVE_TEST_NUXEO_URL , auth = auth ) [EOL] server . client . set ( schemas = [ [string] ] ) [EOL] [EOL] remove_old_ws ( server ) [EOL] remove_old_users ( server ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0
from typing import Literal , Union [EOL] import typing_extensions [EOL] import typing [EOL] from os import getenv [EOL] [EOL] [comment] [EOL] NXDRIVE_TEST_NUXEO_URL = getenv ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] NXDRIVE_TEST_USERNAME = getenv ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] NXDRIVE_TEST_PASSWORD = getenv ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] WS_DIR = getenv ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] SECOND_PARTITION = getenv ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] DOCTYPE_FILE = getenv ( [string] , [string] ) [EOL] DOCTYPE_FOLDERISH = getenv ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , List , Literal , Generator , Set , Any [EOL] import builtins [EOL] import typing_extensions [EOL] import typing [EOL] import shutil [EOL] import sys [EOL] [EOL] import nuxeo . client [EOL] import nuxeo . operations [EOL] import pytest [EOL] from nuxeo . client import Nuxeo [EOL] [EOL] from . import env [EOL] [EOL] pytest_plugins = [string] [EOL] [EOL] [EOL] [comment] [EOL] OPS_CACHE = None [EOL] SERVER_INFO = None [EOL] [EOL] [EOL] @ pytest . hookimpl ( trylast = True , hookwrapper = True ) def pytest_runtest_makereport ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] outcome = yield [EOL] [EOL] [comment] [EOL] report = outcome . get_result ( ) [EOL] [EOL] if report . passed : [EOL] [comment] [EOL] report . sections = [ ] [EOL] outcome . force_result ( report ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def tmp ( tmp_path ) : [EOL] [docstring] [EOL] [EOL] created_folders = [ ] [EOL] n = [number] [EOL] [EOL] def _make_folder ( ) : [EOL] nonlocal n [EOL] path = tmp_path / str ( n ) [EOL] created_folders . append ( path ) [EOL] n += [number] [EOL] return path [EOL] [EOL] yield _make_folder [EOL] [EOL] shutil . rmtree ( tmp_path , ignore_errors = True ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def no_warnings ( recwarn ) : [EOL] [docstring] [EOL] [EOL] yield [EOL] [EOL] warnings = [ ] [EOL] for warning in recwarn : [comment] [EOL] message = str ( warning . message ) [EOL] [EOL] if [string] in warning . filename : [EOL] continue [EOL] elif [string] in message : [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] elif [string] in message : [EOL] [comment] [EOL] continue [EOL] elif [string] in message : [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] elif [string] in message : [EOL] [comment] [EOL] continue [EOL] [EOL] warn = f"{ warning . filename } [string] { warning . lineno } [string] { message }" [EOL] print ( warn , file = sys . stderr ) [EOL] warnings . append ( warn ) [EOL] [EOL] assert not warnings [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def cleanup_attrs ( request ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] test_case = request . instance or request . node [EOL] attr_orig = set ( test_case . __dict__ . keys ( ) ) [EOL] [EOL] yield [EOL] [EOL] [comment] [EOL] [EOL] attr_added = set ( test_case . __dict__ . keys ( ) ) - attr_orig [EOL] if not attr_added : [EOL] return [EOL] [EOL] for attr in attr_added : [EOL] if attr . startswith ( [string] ) : [EOL] engine = getattr ( test_case , attr ) [EOL] if engine . remote : [EOL] engine . remote . client . _session . close ( ) [EOL] delattr ( test_case , attr ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def version ( ) : [EOL] import nxdrive [EOL] [EOL] return nxdrive . __version__ [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def nuxeo_url ( ) : [EOL] [docstring] [EOL] return env . NXDRIVE_TEST_NUXEO_URL . split ( [string] ) [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def server ( nuxeo_url ) : [EOL] [docstring] [EOL] auth = ( [string] , [string] ) [EOL] server = Nuxeo ( host = nuxeo_url , auth = auth ) [EOL] server . client . set ( schemas = [ [string] ] ) [EOL] [EOL] [comment] [EOL] global OPS_CACHE [EOL] if not OPS_CACHE : [EOL] OPS_CACHE = server . operations . operations [EOL] nuxeo . operations . API . ops = OPS_CACHE [EOL] global SERVER_INFO [EOL] if not SERVER_INFO : [EOL] SERVER_INFO = server . client . server_info ( ) [EOL] nuxeo . client . NuxeoClient . _server_info = SERVER_INFO [EOL] [EOL] return server [EOL] [EOL] [EOL] @ pytest . fixture def app ( ) : [EOL] [docstring] [EOL] from PyQt5 . QtCore import QCoreApplication , QTimer [EOL] [EOL] app = QCoreApplication ( [ ] ) [EOL] [EOL] [comment] [EOL] timer = QTimer ( ) [EOL] timer . timeout . connect ( lambda : None ) [EOL] timer . start ( [number] ) [EOL] [EOL] yield app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import List , Any [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] from nxdrive . constants import TransferStatus [EOL] [EOL] from . . markers import windows_only [EOL] [EOL] [EOL] def test_acquire_processors ( engine_dao ) : [EOL] with engine_dao ( [string] ) as dao : [EOL] assert dao . acquire_processor ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] assert not dao . acquire_processor ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] assert dao . acquire_processor ( [number] , [number] ) [EOL] assert dao . release_processor ( [number] ) [EOL] [EOL] [comment] [EOL] assert dao . acquire_processor ( [number] , [number] ) [EOL] row = dao . get_state_from_id ( [number] ) [EOL] dao . synchronize_state ( row ) [EOL] assert not dao . release_processor ( [number] ) [EOL] [EOL] [EOL] def test_batch_folder_files ( engine_dao ) : [EOL] [docstring] [EOL] with engine_dao ( [string] ) as dao : [EOL] ids = range ( [number] , [number] ) [EOL] index = [number] [EOL] state = dao . get_state_from_id ( [number] ) [comment] [EOL] [EOL] while index < len ( ids ) - [number] : [EOL] index += [number] [EOL] state = dao . get_next_folder_file ( state . remote_ref ) [EOL] assert state . id == ids [ index ] [EOL] [EOL] while index > [number] : [EOL] index -= [number] [EOL] state = dao . get_previous_folder_file ( state . remote_ref ) [EOL] assert state . id == ids [ index ] [EOL] [EOL] assert dao . get_previous_folder_file ( state . remote_ref ) is None [EOL] [EOL] [comment] [EOL] state = dao . get_state_from_id ( [number] ) [EOL] assert dao . get_next_folder_file ( state . remote_ref ) is None [EOL] [EOL] [EOL] def test_batch_upload_files ( engine_dao ) : [EOL] [docstring] [EOL] with engine_dao ( [string] ) as dao : [EOL] ids = [ [number] , [number] , [number] , [number] , [number] ] [EOL] index = [number] [EOL] state = dao . get_state_from_id ( ids [ index ] ) [EOL] [EOL] while index < len ( ids ) - [number] : [EOL] index += [number] [EOL] state = dao . get_next_sync_file ( state . remote_ref , [string] ) [EOL] assert state . id == ids [ index ] [EOL] [EOL] while index > [number] : [EOL] index -= [number] [EOL] state = dao . get_previous_sync_file ( state . remote_ref , [string] ) [EOL] assert state . id == ids [ index ] [EOL] [EOL] assert dao . get_previous_sync_file ( state . remote_ref , [string] ) is None [EOL] [EOL] [comment] [EOL] state = dao . get_state_from_id ( [number] ) [EOL] assert dao . get_next_sync_file ( state . remote_ref , [string] ) is None [EOL] [EOL] [EOL] def test_configuration_get ( engine_dao ) : [EOL] with engine_dao ( [string] ) as dao : [EOL] result = dao . get_config ( [string] , [string] ) [EOL] assert result == [string] [EOL] [EOL] result = dao . get_config ( [string] , [string] ) [EOL] assert result == [string] [EOL] [EOL] dao . update_config ( [string] , [string] ) [EOL] result = dao . get_config ( [string] , [string] ) [EOL] assert result != [string] [EOL] dao . update_config ( [string] , [string] ) [EOL] result = dao . get_config ( [string] , [string] ) [EOL] assert result == [string] [EOL] [EOL] dao . update_config ( [string] , None ) [EOL] result = dao . get_config ( [string] , [string] ) [EOL] assert result == [string] [EOL] [EOL] result = dao . get_config ( [string] ) [EOL] assert result is None [EOL] [EOL] [EOL] def test_configuration_get_bool ( engine_dao ) : [EOL] name = [string] [EOL] with engine_dao ( [string] ) as dao : [EOL] [comment] [EOL] dao . store_bool ( name , True ) [EOL] assert dao . get_bool ( name ) is True [EOL] assert dao . get_bool ( name , default = True ) is True [EOL] assert dao . get_bool ( name , default = False ) is True [EOL] assert dao . get_bool ( name , default = [string] ) is True [EOL] [EOL] [comment] [EOL] dao . store_bool ( name , False ) [EOL] assert dao . get_bool ( name ) is False [EOL] assert dao . get_bool ( name , default = True ) is False [EOL] assert dao . get_bool ( name , default = False ) is False [EOL] assert dao . get_bool ( name , default = [string] ) is False [EOL] [EOL] [comment] [EOL] assert dao . get_bool ( [string] ) is False [EOL] assert dao . get_bool ( [string] , default = [string] ) is False [EOL] assert dao . get_bool ( [string] , default = True ) is True [EOL] assert dao . get_bool ( [string] , default = [number] ) is False [EOL] assert dao . get_bool ( [string] , default = [number] ) is True [EOL] [EOL] [comment] [EOL] [EOL] dao . store_int ( [string] , [number] ) [EOL] res = dao . get_config ( [string] , [string] ) == [string] [EOL] assert res is False [EOL] assert dao . get_bool ( [string] ) is res [EOL] [EOL] dao . store_int ( [string] , [number] ) [EOL] res = dao . get_config ( [string] , [string] ) == [string] [EOL] assert res is True [EOL] assert dao . get_bool ( [string] ) is res [EOL] [EOL] res = dao . get_config ( [string] , [string] ) != [string] [EOL] assert res is True [EOL] assert dao . get_bool ( [string] , default = True ) is res [EOL] [EOL] is_frozen = True [comment] [EOL] res = dao . get_config ( [string] , str ( int ( is_frozen ) ) ) == [string] [EOL] assert res is True [EOL] assert dao . get_bool ( [string] , default = is_frozen ) is res [EOL] [EOL] is_frozen = False [comment] [EOL] res = dao . get_config ( [string] , str ( int ( is_frozen ) ) ) == [string] [EOL] assert res is False [EOL] assert dao . get_bool ( [string] , default = is_frozen ) is res [EOL] [EOL] res = dao . get_config ( [string] ) == [string] [EOL] assert res is False [EOL] assert dao . get_bool ( [string] ) is res [EOL] [EOL] [EOL] def test_configuration_get_int ( engine_dao ) : [EOL] name = [string] [EOL] with engine_dao ( [string] ) as dao : [EOL] [comment] [EOL] dao . store_int ( name , [number] ) [EOL] assert dao . get_int ( name ) == [number] [EOL] assert dao . get_int ( name , default = - [number] ) == [number] [EOL] assert dao . get_int ( name , default = [number] ) == [number] [EOL] assert dao . get_int ( name , default = [string] ) == [number] [EOL] [EOL] [comment] [EOL] dao . store_int ( name , - [number] ) [EOL] assert dao . get_int ( name ) == - [number] [EOL] assert dao . get_int ( name , default = [number] ) == - [number] [EOL] assert dao . get_int ( name , default = [number] ) == - [number] [EOL] assert dao . get_int ( name , default = [string] ) == - [number] [EOL] [EOL] [comment] [EOL] assert dao . get_int ( [string] ) == [number] [EOL] assert dao . get_int ( [string] , default = [string] ) == [number] [EOL] assert dao . get_int ( [string] , default = False ) == [number] [EOL] assert dao . get_int ( [string] , default = True ) == [number] [EOL] assert dao . get_int ( [string] , default = [number] ) == [number] [EOL] [EOL] [comment] [EOL] [EOL] res = int ( dao . get_config ( [string] , [number] ) ) [EOL] assert res == [number] [EOL] assert dao . get_int ( [string] ) == res [EOL] [EOL] dao . delete_config ( [string] ) [EOL] res = int ( dao . get_config ( [string] , [number] ) ) [EOL] assert res == [number] [EOL] assert dao . get_int ( [string] ) == res [EOL] [EOL] [EOL] def test_conflicts ( engine_dao ) : [EOL] with engine_dao ( [string] ) as dao : [EOL] assert dao . get_conflict_count ( ) == [number] [EOL] assert len ( dao . get_conflicts ( ) ) == [number] [EOL] [EOL] [EOL] def test_corrupted_database ( engine_dao ) : [EOL] [docstring] [EOL] with engine_dao ( [string] ) as dao : [EOL] c = dao . _get_read_connection ( ) . cursor ( ) [EOL] cols = c . execute ( [string] ) . fetchall ( ) [EOL] assert len ( cols ) == [number] [EOL] [EOL] [EOL] def test_errors ( engine_dao ) : [EOL] with engine_dao ( [string] ) as dao : [EOL] assert dao . get_error_count ( ) == [number] [EOL] assert not dao . get_error_count ( [number] ) [EOL] assert len ( dao . get_errors ( ) ) == [number] [EOL] row = dao . get_errors ( ) [ [number] ] [EOL] [EOL] [comment] [EOL] dao . reset_error ( row ) [EOL] assert not dao . get_error_count ( ) [EOL] row = dao . get_state_from_id ( row . id ) [EOL] assert row . last_error is None [EOL] assert row . last_error_details is None [EOL] assert not row . error_count [EOL] [EOL] [comment] [EOL] dao . increase_error ( row , [string] ) [EOL] assert not dao . get_error_count ( ) [EOL] dao . increase_error ( row , [string] ) [EOL] assert not dao . get_error_count ( ) [EOL] assert dao . get_error_count ( [number] ) == [number] [EOL] dao . increase_error ( row , [string] ) [EOL] assert not dao . get_error_count ( ) [EOL] assert dao . get_error_count ( [number] ) == [number] [EOL] [EOL] [comment] [EOL] assert not dao . synchronize_state ( row , version = row . version - [number] ) [EOL] assert dao . get_error_count ( [number] ) == [number] [EOL] [EOL] [comment] [EOL] assert dao . synchronize_state ( row ) [EOL] assert not dao . get_error_count ( [number] ) [EOL] [EOL] [EOL] def test_filters ( engine_dao ) : [EOL] [docstring] [EOL] with engine_dao ( [string] ) as dao : [EOL] assert len ( dao . get_filters ( ) ) == [number] [EOL] [EOL] dao . remove_filter ( [string] ) [EOL] assert len ( dao . get_filters ( ) ) == [number] [EOL] [EOL] [comment] [EOL] dao . add_filter ( [string] ) [EOL] assert len ( dao . get_filters ( ) ) == [number] [EOL] [EOL] dao . add_filter ( [string] ) [EOL] assert len ( dao . get_filters ( ) ) == [number] [EOL] [EOL] [EOL] def test_reinit_processors ( engine_dao ) : [EOL] with engine_dao ( [string] ) as dao : [EOL] state = dao . get_state_from_id ( [number] ) [EOL] assert not state . processor [EOL] [EOL] [EOL] def test_init_db ( engine_dao ) : [EOL] with engine_dao ( [string] ) as dao : [EOL] assert not dao . get_filters ( ) [EOL] assert not dao . get_conflicts ( ) [EOL] assert dao . get_config ( [string] ) is None [EOL] assert not dao . is_path_scanned ( [string] ) [EOL] [EOL] [EOL] def test_last_sync ( engine_dao ) : [EOL] [docstring] [EOL] with engine_dao ( [string] ) as dao : [EOL] ids = [ [number] , [number] , [number] , [number] , [number] ] [EOL] files = dao . get_last_files ( [number] ) [EOL] assert len ( files ) == [number] [EOL] for i in range ( [number] ) : [EOL] assert files [ i ] . id == ids [ i ] [EOL] [EOL] ids = [ [number] , [number] , [number] , [number] , [number] ] [EOL] files = dao . get_last_files ( [number] , direction = [string] ) [EOL] assert len ( files ) == [number] [EOL] for i in range ( [number] ) : [EOL] assert files [ i ] . id == ids [ i ] [EOL] [EOL] ids = [ [number] , [number] , [number] ] [EOL] files = dao . get_last_files ( [number] , direction = [string] ) [EOL] assert len ( files ) == [number] [EOL] for i in range ( [number] ) : [EOL] assert files [ i ] . id == ids [ i ] [EOL] [EOL] [EOL] def test_migration_db_v1 ( engine_dao ) : [EOL] with engine_dao ( [string] ) as dao : [EOL] c = dao . _get_read_connection ( ) . cursor ( ) [EOL] [EOL] cols = c . execute ( [string] ) . fetchall ( ) [EOL] assert len ( cols ) == [number] [EOL] [EOL] cols = c . execute ( [string] ) . fetchall ( ) [EOL] assert len ( cols ) == [number] [EOL] [EOL] [EOL] def test_migration_db_v1_with_duplicates ( engine_dao ) : [EOL] [docstring] [EOL] with engine_dao ( [string] ) as dao : [EOL] c = dao . _get_read_connection ( ) . cursor ( ) [EOL] rows = c . execute ( [string] ) . fetchall ( ) [EOL] assert not rows [EOL] [EOL] cols = c . execute ( [string] ) . fetchall ( ) [EOL] assert len ( cols ) == [number] [EOL] assert dao . get_config ( [string] ) is None [EOL] assert dao . get_config ( [string] ) is None [EOL] [EOL] [EOL] @ windows_only def test_migration_db_v8 ( engine_dao ) : [EOL] [docstring] [EOL] with engine_dao ( [string] ) as dao : [EOL] [EOL] for download in dao . get_downloads ( ) : [EOL] assert str ( download . tmpname ) . startswith ( [string] ) [EOL] [EOL] [EOL] def test_migration_db_v9 ( engine_dao ) : [EOL] [docstring] [EOL] with engine_dao ( [string] ) as dao : [EOL] downloads = list ( dao . get_downloads ( ) ) [EOL] assert len ( downloads ) == [number] [EOL] [EOL] [EOL] def test_migration_db_v10 ( engine_dao ) : [EOL] [docstring] [EOL] with engine_dao ( [string] ) as dao : [EOL] downloads = list ( dao . get_downloads ( ) ) [EOL] assert len ( downloads ) == [number] [EOL] [EOL] states = list ( dao . get_states_from_partial_local ( Path ( ) ) ) [EOL] assert len ( states ) == [number] [EOL] [EOL] bad_digest_file = dao . get_state_from_local ( Path ( [string] ) ) [EOL] assert not bad_digest_file [EOL] [EOL] [EOL] def test_migration_db_v15 ( engine_dao ) : [EOL] [docstring] [EOL] with engine_dao ( [string] ) as dao : [EOL] local_parent_path = [string] [EOL] [EOL] [comment] [EOL] assert not dao . get_session ( [number] ) [EOL] assert not dao . get_session ( [number] ) [EOL] last_session = dao . get_session ( [number] ) [EOL] assert last_session [EOL] [EOL] [comment] [EOL] doc_pairs = dao . get_local_children ( local_parent_path ) [EOL] assert len ( doc_pairs ) == [number] [EOL] for pair in doc_pairs : [EOL] assert pair . session == last_session . uid [EOL] [EOL] [comment] [EOL] assert last_session [EOL] assert last_session . status == TransferStatus . ONGOING [EOL] assert last_session . uploaded_items == [number] [EOL] assert last_session . total_items == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] import pathlib [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from nxdrive . translator import Translator [EOL] [EOL] [EOL] def get_folder ( folder ) : [EOL] return Path ( __file__ ) . parent . parent / [string] / folder [EOL] [EOL] [EOL] def test_non_existing_file ( ) : [EOL] with pytest . raises ( OSError ) : [EOL] Translator ( get_folder ( [string] ) ) [EOL] [EOL] [EOL] def test_load_file ( ) : [EOL] Translator ( get_folder ( [string] ) ) [EOL] [EOL] [comment] [EOL] assert Translator . locale ( ) == [string] [EOL] [EOL] [comment] [EOL] Translator . set ( [string] ) [EOL] assert Translator . locale ( ) == [string] [EOL] [EOL] [comment] [EOL] assert Translator . get ( [string] ) == [string] [EOL] [EOL] [comment] [EOL] assert Translator . get ( [string] ) == [string] [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) : [EOL] Translator . set ( [string] ) [EOL] assert Translator . locale ( ) == [string] [EOL] [EOL] [comment] [EOL] Translator . set ( [string] ) [EOL] assert Translator . locale ( ) == [string] [EOL] assert Translator . get ( [string] ) == [string] [EOL] [EOL] [comment] [EOL] Translator . set ( [string] ) [EOL] assert Translator . locale ( ) == [string] [EOL] assert Translator . get ( [string] ) == [string] [EOL] [EOL] [EOL] def test_non_iniialized ( ) : [EOL] Translator . singleton = None [EOL] with pytest . raises ( RuntimeError ) : [EOL] Translator . get ( [string] ) [EOL] [EOL] [EOL] def test_load_bad_language ( ) : [EOL] Translator ( get_folder ( [string] ) , [string] ) [EOL] [comment] [EOL] assert Translator . locale ( ) == [string] [EOL] [EOL] [EOL] def test_load_existing_language ( ) : [EOL] Translator ( get_folder ( [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] assert Translator . locale ( ) == [string] [EOL] [EOL] [comment] [EOL] assert Translator . get ( [string] ) == [string] [EOL] assert Translator . get ( [string] ) == [string] [EOL] assert Translator . get ( [string] ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , ) def test_token ( token , result ) : [EOL] options = [ [string] , [string] ] [EOL] Translator ( get_folder ( [string] ) ) [EOL] assert Translator . get ( token , options ) == result [EOL] [EOL] [EOL] def test_translate_twice ( ) : [EOL] [docstring] [EOL] Translator ( get_folder ( [string] ) ) [EOL] values = [ [string] ] [EOL] first = Translator . get ( [string] , values ) [EOL] second = Translator . get ( [string] , values ) [EOL] [EOL] assert first == second [EOL] assert values == [ [string] ] [EOL] [EOL] [EOL] def test_languages ( ) : [EOL] [docstring] [EOL] folder = Path ( __file__ ) . parent . parent . parent / [string] / [string] / [string] [EOL] Translator ( folder ) [EOL] expected = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] languages = Translator . languages ( ) [EOL] assert languages == expected [EOL] assert len ( languages ) == len ( list ( folder . glob ( [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Dict , Union [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] from contextlib import suppress [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] import requests [EOL] from nxdrive . options import Options [EOL] from sentry_sdk import configure_scope [EOL] [EOL] [comment] [EOL] with suppress ( KeyError ) : [EOL] del Options . callbacks [ [string] ] [EOL] with suppress ( KeyError ) : [EOL] del Options . callbacks [ [string] ] [EOL] [EOL] [EOL] @ Options . mock ( ) def test_batch_update_from_argparse ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( add_help = False ) [EOL] parser . add_argument ( [string] , default = True , action = [string] ) [EOL] parser . add_argument ( [string] , default = [number] , type = int ) [EOL] options = parser . parse_args ( [ ] ) [EOL] [EOL] Options . update ( options , setter = [string] ) [EOL] assert Options . debug [EOL] assert not Options . delay [EOL] [EOL] [EOL] @ Options . mock ( ) def test_batch_update_from_dict ( ) : [EOL] [docstring] [EOL] options = { [string] : True , [string] : [string] } [EOL] [EOL] Options . update ( options , setter = [string] ) [EOL] assert Options . debug [EOL] assert Options . locale == [string] [EOL] [EOL] [EOL] @ Options . mock ( ) def test_batch_update_from_dict_with_unknown_option ( ) : [EOL] options = { [string] : True , [string] : [number] } [EOL] [EOL] with pytest . raises ( RuntimeError ) as err : [EOL] Options . update ( options , setter = [string] ) [EOL] msg = err . value . args [ [number] ] [EOL] assert [string] in msg [EOL] assert [string] not in msg [EOL] assert [string] not in msg [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as err : [EOL] Options . update ( options , setter = [string] , file = [string] ) [EOL] msg = err . value . args [ [number] ] [EOL] assert [string] in msg [EOL] assert [string] in msg [EOL] assert [string] not in msg [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as err : [EOL] Options . update ( options , setter = [string] , file = [string] , section = [string] ) [EOL] msg = err . value . args [ [number] ] [EOL] assert [string] in msg [EOL] assert [string] in msg [EOL] assert [string] in msg [EOL] [EOL] assert Options . debug [EOL] assert not Options . foo [EOL] [EOL] [EOL] @ Options . mock ( ) def test_bytes_conversion ( ) : [EOL] Options . update_site_url = [string] [EOL] assert isinstance ( Options . update_site_url , str ) [EOL] assert Options . update_site_url == [string] [EOL] [EOL] [EOL] @ Options . mock ( ) def test_callback ( ) : [EOL] def _callback ( new_value ) : [EOL] global checkpoint [EOL] checkpoint = new_value [EOL] [EOL] global checkpoint [EOL] checkpoint = [number] [EOL] [EOL] Options . callbacks [ [string] ] = _callback [EOL] Options . delay = [number] [EOL] assert checkpoint == [number] [EOL] [EOL] [EOL] @ Options . mock ( ) def test_callback_bad_behavior ( ) : [EOL] def _raises_from_callback ( new_value ) : [EOL] new_value / [number] [EOL] [EOL] Options . callbacks [ [string] ] = _raises_from_callback [EOL] with pytest . raises ( ZeroDivisionError ) : [EOL] Options . delay = [number] [EOL] [EOL] [EOL] @ Options . mock ( ) def test_callback_no_args ( ) : [EOL] def _callback_with_no_args ( ) : [EOL] pass [EOL] [EOL] Options . callbacks [ [string] ] = _callback_with_no_args [EOL] with pytest . raises ( TypeError ) : [EOL] Options . delay = [number] [EOL] [EOL] [EOL] def test_defaults ( ) : [EOL] assert not Options . debug [EOL] assert Options . delay == [number] [EOL] assert not Options . force_locale [EOL] assert Options . startup_page == [string] [EOL] assert Options . callbacks [EOL] [EOL] [EOL] def test_getter ( ) : [EOL] assert Options . options [EOL] assert Options . delay == [number] [EOL] assert not Options . nothing [EOL] [EOL] [EOL] def test_error ( ) : [EOL] with pytest . raises ( RuntimeError ) : [EOL] Options . set ( [string] , [number] ) [EOL] [EOL] with configure_scope ( ) as scope : [EOL] scope . _should_capture = False [EOL] Options . set ( [string] , [number] , fail_on_error = False ) [EOL] [EOL] with pytest . raises ( TypeError ) as err : [EOL] Options . set ( [string] , [string] ) [EOL] msg = err . value . args [ [number] ] [EOL] assert [string] in msg [EOL] assert [string] not in msg [EOL] assert [string] not in msg [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as err : [EOL] Options . set ( [string] , [string] , file = [string] ) [EOL] msg = err . value . args [ [number] ] [EOL] assert [string] in msg [EOL] assert [string] in msg [EOL] assert [string] not in msg [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as err : [EOL] Options . set ( [string] , [string] , file = [string] , section = [string] ) [EOL] msg = err . value . args [ [number] ] [EOL] assert [string] in msg [EOL] assert [string] in msg [EOL] assert [string] in msg [EOL] [EOL] [EOL] @ Options . mock ( ) def test_list_conversion_and_original_values_updated ( ) : [EOL] assert isinstance ( Options . ignored_suffixes , tuple ) [EOL] assert [string] not in Options . ignored_suffixes [EOL] current_len = len ( Options . ignored_suffixes ) [EOL] [EOL] Options . set ( [string] , [ [string] ] , setter = [string] ) [EOL] assert isinstance ( Options . ignored_suffixes , tuple ) [EOL] assert [string] in Options . ignored_suffixes [EOL] assert len ( Options . ignored_suffixes ) == current_len + [number] [EOL] [EOL] new_values = { [string] : [ [string] , [string] , [string] , [string] ] , [string] : [string] , } [EOL] Options . update ( new_values , setter = [string] ) [EOL] assert isinstance ( Options . ignored_files , tuple ) [EOL] assert [string] in Options . ignored_files [EOL] assert [string] in Options . ignored_files [EOL] assert [string] in Options . ignored_files [EOL] assert len ( Options . ignored_files ) > [number] [EOL] [comment] [EOL] assert Options . ignored_files [ - [number] ] == [string] [EOL] [EOL] [EOL] @ Options . mock ( ) def test_repr ( ) : [EOL] assert repr ( Options ) [EOL] [EOL] Options . startup_page = [string] [EOL] assert repr ( Options ) [EOL] [EOL] [EOL] @ Options . mock ( ) def test_setters ( ) : [EOL] [docstring] [EOL] [EOL] Options . set ( [string] , [number] ) [EOL] assert Options . delay == [number] [EOL] [EOL] Options . set ( [string] , [number] , setter = [string] ) [EOL] assert Options . delay == [number] [EOL] [EOL] Options . set ( [string] , [number] ) [EOL] assert Options . delay == [number] [EOL] [EOL] Options . set ( [string] , [number] , setter = [string] ) [EOL] assert Options . delay == [number] [EOL] [EOL] Options . set ( [string] , [number] , setter = [string] ) [EOL] assert Options . delay == [number] [EOL] [EOL] Options . set ( [string] , [number] , setter = [string] ) [EOL] assert Options . delay == [number] [EOL] [EOL] Options . set ( [string] , [number] , setter = [string] ) [EOL] assert Options . delay == [number] [EOL] [EOL] Options . delay = [number] [EOL] assert Options . delay == [number] [EOL] [EOL] [EOL] @ Options . mock ( ) def test_server_and_local_config_with_default_value_forced ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] assert Options . synchronization_enabled [EOL] [EOL] [comment] [EOL] Options . set ( [string] , True , setter = [string] ) [EOL] assert str ( Options ) == [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] Options . set ( [string] , True , setter = [string] ) [EOL] assert str ( Options ) == [string] [EOL] [EOL] [comment] [EOL] Options . set ( [string] , True , setter = [string] ) [EOL] assert str ( Options ) == [string] [EOL] [EOL] [comment] [EOL] Options . set ( [string] , False , setter = [string] ) [EOL] assert Options . synchronization_enabled [EOL] [EOL] [EOL] def test_site_update_url ( ) : [EOL] with requests . get ( Options . update_site_url ) as resp : [EOL] resp . raise_for_status ( ) [EOL] [EOL] [EOL] @ Options . mock ( ) def test_str ( ) : [EOL] assert str ( Options ) == [string] [EOL] [EOL] Options . delay = [number] [EOL] assert str ( Options ) == [string] [EOL] [EOL] [EOL] @ Options . mock ( ) def test_str_utf8 ( ) : [EOL] Options . startup_page = [string] [EOL] assert [string] in str ( Options ) [EOL] [EOL] Options . startup_page = [string] [EOL] assert [string] in str ( Options ) [EOL] [EOL] [EOL] @ Options . mock ( ) @ pytest . mark . parametrize ( [string] , [ ( [string] , - [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , - [number] , [number] ) ] , ) def test_validator ( option , a_bad_value , a_good_value ) : [EOL] [comment] [EOL] Options . set ( option , a_bad_value ) [EOL] assert getattr ( Options , option ) != a_bad_value [EOL] [EOL] Options . set ( option , a_good_value ) [EOL] assert getattr ( Options , option ) == a_good_value [EOL] [EOL] [EOL] @ Options . mock ( ) def test_disabled_features ( caplog ) : [EOL] [docstring] [EOL] assert Options . feature_auto_update is True [EOL] assert Options . feature_s3 is False [EOL] [EOL] with patch ( [string] , new = [ [string] ] ) : [EOL] options = { [string] : False , [string] : True } [EOL] Options . update ( options , setter = [string] ) [EOL] [EOL] [comment] [EOL] assert Options . feature_auto_update is True [EOL] [EOL] [comment] [EOL] assert Options . feature_s3 is True [EOL] [EOL] [comment] [EOL] record = caplog . records [ [number] ] [EOL] assert record . levelname == [string] [EOL] assert record . message == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] def test_simple_filter ( engine_dao ) : [EOL] with engine_dao ( [string] ) as dao : [EOL] [EOL] [comment] [EOL] dao . add_filter ( [string] ) [EOL] assert len ( dao . get_filters ( ) ) == [number] [EOL] [EOL] [comment] [EOL] dao . add_filter ( [string] ) [EOL] assert len ( dao . get_filters ( ) ) == [number] [EOL] [EOL] [comment] [EOL] dao . add_filter ( [string] ) [EOL] assert len ( dao . get_filters ( ) ) == [number] [EOL] [EOL] [comment] [EOL] dao . remove_filter ( [string] ) [EOL] assert len ( dao . get_filters ( ) ) == [number] [EOL] [EOL] [comment] [EOL] dao . add_filter ( [string] ) [EOL] assert len ( dao . get_filters ( ) ) == [number] [EOL] [EOL] [comment] [EOL] dao . remove_filter ( [string] ) [EOL] assert not dao . get_filters ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] dao . add_filter ( [string] ) [EOL] dao . add_filter ( [string] ) [EOL] dao . add_filter ( [string] ) [EOL] dao . remove_filter ( [string] ) [EOL] assert len ( dao . get_filters ( ) ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import nxdrive [EOL] from pathlib import Path [EOL] from time import sleep [EOL] [EOL] import pytest [EOL] from nxdrive . engine . blocklist_queue import BlocklistItem , BlocklistQueue [EOL] [EOL] [EOL] @ pytest . mark . randombug ( [string] ) def test_delay ( ) : [EOL] sleep_time = [number] [EOL] [EOL] [comment] [EOL] queue = BlocklistQueue ( delay = [number] ) [EOL] queue . push ( Path ( [string] ) ) [EOL] queue . push ( Path ( [string] ) ) [EOL] [EOL] [comment] [EOL] assert not list ( queue . get ( ) ) [EOL] sleep ( sleep_time ) [EOL] [EOL] [comment] [EOL] item = next ( queue . get ( ) ) [EOL] assert isinstance ( item , BlocklistItem ) [EOL] assert item . path == Path ( [string] ) [EOL] item = next ( queue . get ( ) ) [EOL] assert item . path == Path ( [string] ) [EOL] assert item . count == [number] [EOL] [EOL] [comment] [EOL] queue . repush ( item , increase_wait = False ) [EOL] assert not list ( queue . get ( ) ) [EOL] sleep ( sleep_time ) [EOL] [EOL] [comment] [EOL] item = next ( queue . get ( ) ) [EOL] assert item . path == Path ( [string] ) [EOL] assert item . count == [number] [EOL] [EOL] [comment] [EOL] queue . repush ( item , increase_wait = True ) [EOL] sleep ( sleep_time ) [EOL] assert not list ( queue . get ( ) ) [EOL] [EOL] sleep ( sleep_time ) [EOL] item = next ( queue . get ( ) ) [EOL] assert item . path == Path ( [string] ) [EOL] assert item . count == [number] [EOL] assert not list ( queue . get ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import logging [EOL] import nxdrive [EOL] import typing [EOL] import logging [EOL] [EOL] from nxdrive . constants import MAX_LOG_DISPLAYED [EOL] from nxdrive . logging_config import CustomMemoryHandler [EOL] [EOL] [EOL] def test_custom_memory_handler ( ) : [EOL] [docstring] [EOL] root_logger = logging . getLogger ( ) [EOL] root_logger . setLevel ( logging . DEBUG ) [EOL] memory_handler = CustomMemoryHandler ( ) [EOL] memory_handler . setLevel ( logging . DEBUG ) [EOL] root_logger . addHandler ( memory_handler ) [EOL] [EOL] [comment] [EOL] for n in range ( MAX_LOG_DISPLAYED * [number] ) : [EOL] root_logger . debug ( f" [string] { n : [string] }" ) [EOL] [EOL] [comment] [EOL] assert len ( memory_handler . buffer ) <= MAX_LOG_DISPLAYED [EOL] [EOL] [comment] [EOL] buffer = memory_handler . get_buffer ( - [number] ) [EOL] assert len ( buffer ) == [number] [EOL] [EOL] [comment] [EOL] buffer = memory_handler . get_buffer ( [number] ) [EOL] assert len ( buffer ) == [number] [EOL] [EOL] [comment] [EOL] buffer = memory_handler . get_buffer ( MAX_LOG_DISPLAYED ) [EOL] assert len ( buffer ) == MAX_LOG_DISPLAYED [EOL] assert buffer [ [number] ] . message == [string] [EOL] assert buffer [ - [number] ] . message == [string] [EOL] [EOL] [comment] [EOL] buffer = memory_handler . get_buffer ( MAX_LOG_DISPLAYED + [number] ) [EOL] assert len ( buffer ) == MAX_LOG_DISPLAYED [EOL] assert buffer [ [number] ] . message == [string] [EOL] assert buffer [ - [number] ] . message == [string] [EOL] [EOL] [comment] [EOL] buffer = memory_handler . get_buffer ( [number] ) [EOL] assert len ( buffer ) == [number] [EOL] assert buffer [ [number] ] . message == [string] [EOL] assert buffer [ - [number] ] . message == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Literal , Any , Union [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] pytest_plugins = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def plugin ( testdir ) : [EOL] testdir . makeconftest ( [string] ) [EOL] [EOL] [EOL] def temporary_failure ( count = [number] , reverse = False ) : [EOL] comp = [string] if reverse else [string] [EOL] return f""" [string] { comp } [string] { count } [string] """ [EOL] [EOL] [EOL] def assert_outcomes ( result , passed = [number] , skipped = [number] , failed = [number] , error = [number] , xfailed = [number] , xpassed = [number] , repeated = [number] ) : [EOL] outcomes = result . parseoutcomes ( ) [EOL] assert outcomes . get ( [string] , [number] ) == passed [EOL] assert outcomes . get ( [string] , [number] ) == skipped [EOL] assert outcomes . get ( [string] , [number] ) == failed [EOL] assert outcomes . get ( [string] , [number] ) == error [EOL] assert outcomes . get ( [string] , [number] ) == xfailed [EOL] assert outcomes . get ( [string] , [number] ) == xpassed [EOL] assert outcomes . get ( [string] , [number] ) == repeated [EOL] [EOL] [EOL] def test_no_repeat_on_skipif_mark ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , skipped = [number] ) [EOL] [EOL] [EOL] def test_no_repeat_on_skip_call ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , skipped = [number] ) [EOL] [EOL] [EOL] def test_no_repeat_on_xfail_mark ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , xfailed = [number] ) [EOL] [EOL] [EOL] def test_no_repeat_on_xfail_call ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , xfailed = [number] ) [EOL] [EOL] [EOL] def test_relax_on_failing_test ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , failed = [number] , repeated = [number] ) [EOL] [EOL] [EOL] def test_relax_on_passing_test ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result ) [EOL] [EOL] [EOL] def test_relax_and_false_condition_on_failing_test ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , failed = [number] ) [EOL] [EOL] [EOL] def test_relax_passing_after_failure ( testdir ) : [EOL] testdir . makepyfile ( [string] + temporary_failure ( [number] ) ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , repeated = [number] ) [EOL] [EOL] [EOL] def test_strict_on_failing_test ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , failed = [number] ) [EOL] [EOL] [EOL] def test_strict_on_passing_test ( testdir ) : [EOL] [docstring] [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , failed = [number] , repeated = [number] ) [EOL] [EOL] [EOL] def test_strict_and_false_condition_on_passing_test ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result ) [EOL] [EOL] [EOL] def test_strict_failing_after_success ( testdir ) : [EOL] testdir . makepyfile ( [string] + temporary_failure ( [number] , reverse = True ) ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , failed = [number] , repeated = [number] ) [EOL] [EOL] [EOL] def test_strict_and_lower_repeat_number_on_passing_test ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , failed = [number] , repeated = [number] ) [EOL] [EOL] [EOL] def test_bypass_on_passing_test ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , skipped = [number] ) [EOL] [EOL] [EOL] def test_bypass_on_failing_test ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , skipped = [number] ) [EOL] [EOL] [EOL] def test_bypass_and_false_condition_on_passing_test ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result ) [EOL] [EOL] [EOL] def test_bypass_and_false_condition_on_failing_test ( testdir ) : [EOL] testdir . makepyfile ( [string] ) [EOL] result = testdir . runpytest ( ) [EOL] assert_outcomes ( result , passed = [number] , failed = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] from typing import List [EOL] import logging [EOL] import typing [EOL] import os [EOL] import subprocess [EOL] from glob import glob [EOL] from logging import getLogger [EOL] [EOL] import pytest [EOL] from nxdrive . constants import WINDOWS [EOL] [EOL] from . . . import env [EOL] [EOL] if not WINDOWS : [EOL] pytestmark = pytest . mark . skip [EOL] [EOL] log = getLogger ( __name__ ) [EOL] [EOL] [EOL] class Installer : [EOL] [EOL] launcher = [string] [EOL] uninstaller = [string] [EOL] [EOL] def __init__ ( self , path , * install_opt ) : [EOL] self . path = path [EOL] self . install_opt = [ [string] ] + list ( install_opt ) [EOL] log . info ( [string] , self . path ) [EOL] [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] self . uninstall ( ) [EOL] [EOL] def install ( self , * install_opt ) : [EOL] log . info ( [string] , self . path , [string] . join ( install_opt ) ) [EOL] subprocess . Popen ( [ self . path ] + list ( install_opt ) ) [EOL] self . launcher = [string] [EOL] self . uninstaller = [string] [EOL] [EOL] def uninstall ( self ) : [EOL] if not getattr ( self , [string] , None ) : [EOL] return [EOL] [EOL] log . info ( [string] , self . uninstaller ) [EOL] subprocess . Popen ( [ self . uninstaller , [string] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def installer_path ( ) : [EOL] [docstring] [EOL] cmd = [ [string] , [string] , [string] ] [EOL] log . info ( [string] , cmd ) [EOL] subprocess . Popen ( cmd ) [EOL] path = glob ( [string] ) [ [number] ] [EOL] yield path [EOL] os . remove ( path ) [EOL] [EOL] [EOL] def test_installer_arguments ( installer_path ) : [EOL] [docstring] [EOL] with Installer ( installer_path ) as installer : [EOL] args = [ f' [string] { env . NXDRIVE_TEST_NUXEO_URL } [string] ' , f' [string] { env . NXDRIVE_TEST_USERNAME } [string] ' , f' [string] { env . NXDRIVE_TEST_PASSWORD } [string] ' , ] [EOL] installer . install ( args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] from logging import getLogger [EOL] from time import sleep [EOL] [EOL] from nxdrive . constants import APP_NAME [EOL] [EOL] log = getLogger ( __name__ ) [EOL] [EOL] [EOL] def cb_get ( ) : [EOL] [docstring] [EOL] import win32clipboard [EOL] [EOL] win32clipboard . OpenClipboard ( ) [EOL] text = win32clipboard . GetClipboardData ( win32clipboard . CF_UNICODETEXT ) [EOL] win32clipboard . CloseClipboard ( ) [EOL] return text [EOL] [EOL] [EOL] def fatal_error_dlg ( app , with_details = True ) : [EOL] [comment] [EOL] [comment] [EOL] dlg = app . window ( title = f"{ APP_NAME } [string] " ) [EOL] if dlg . exists ( ) : [EOL] if with_details : [EOL] [comment] [EOL] sleep ( [number] ) [EOL] dlg . child_window ( title = [string] ) . wait ( [string] ) . click ( ) [EOL] sleep ( [number] ) [EOL] log . warning ( f" [string] { cb_get ( ) }" ) [EOL] else : [EOL] log . warning ( [string] ) [EOL] [EOL] dlg . close ( ) [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def main_window ( app ) : [EOL] [comment] [EOL] return app . top_window ( ) [EOL] [EOL] [EOL] def share_metrics_dlg ( app ) : [EOL] [comment] [EOL] [comment] [EOL] dlg = app . window ( title = f"{ APP_NAME } [string] " ) [EOL] if dlg . exists ( ) : [EOL] dlg . close ( ) [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def get_opened_url ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import os [EOL] from selenium import webdriver [EOL] [EOL] os . environ [ [string] ] = os . environ [ [string] ] + [string] + os . getcwd ( ) [EOL] [EOL] browser = webdriver . Firefox ( ) [EOL] try : [EOL] return browser . current_url [EOL] finally : [EOL] browser . quit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] from contextlib import contextmanager [EOL] from logging import getLogger [EOL] from time import sleep [EOL] [EOL] import pytest [EOL] [EOL] log = getLogger ( __name__ ) [EOL] [EOL] [EOL] def pytest_addoption ( parser ) : [EOL] parser . addoption ( [string] , action = [string] , default = [string] , help = [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def final_exe ( request ) : [EOL] return request . config . getoption ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def exe ( final_exe , tmp ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from pywinauto . application import Application [EOL] [EOL] path = tmp ( ) / [string] [EOL] path . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] @ contextmanager def execute ( cmd = final_exe , args = [string] , wait = [number] ) : [EOL] if [string] not in args : [EOL] args += f' [string] { path } [string] ' [EOL] if [string] not in args : [EOL] args += [string] [EOL] args = args . strip ( ) [EOL] [EOL] log . info ( f" [string] { cmd !r} [string] { args !r}" ) [EOL] [EOL] app = Application ( backend = [string] ) . start ( f"{ cmd } [string] { args }" ) [EOL] try : [EOL] yield app [EOL] if wait > [number] : [EOL] sleep ( wait ) [EOL] finally : [EOL] app . kill ( ) [EOL] [EOL] return execute [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] from logging import getLogger [EOL] [EOL] import pytest [EOL] from nxdrive . constants import WINDOWS [EOL] [EOL] from . utils import fatal_error_dlg , main_window , share_metrics_dlg [EOL] [EOL] if not WINDOWS : [EOL] pytestmark = pytest . mark . skip ( [string] ) [EOL] [EOL] log = getLogger ( __name__ ) [EOL] [EOL] [EOL] def test_start_app ( exe ) : [EOL] with exe ( ) as app : [EOL] assert not fatal_error_dlg ( app ) [EOL] assert share_metrics_dlg ( app ) [EOL] [EOL] [comment] [EOL] main = main_window ( app ) [EOL] assert main . exists ( ) [EOL] main . close ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] ] ) def test_invalid_argument ( exe , arg ) : [EOL] with exe ( args = arg ) as app : [EOL] assert fatal_error_dlg ( app , with_details = False ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_invalid_argument_value ( exe , arg ) : [EOL] with exe ( args = arg ) as app : [EOL] assert fatal_error_dlg ( app , with_details = False ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) def test_valid_argument_value ( exe , arg ) : [EOL] [docstring] [EOL] with exe ( args = arg ) as app : [EOL] assert not fatal_error_dlg ( app ) [EOL] share_metrics_dlg ( app ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] ] ) def test_argument_log_filename ( exe , tmp , file ) : [EOL] path = tmp ( ) [EOL] path . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] log = path / file [EOL] arg = f' [string] { log } [string] ' [EOL] [EOL] with exe ( args = arg ) as app : [EOL] assert not fatal_error_dlg ( app ) [EOL] share_metrics_dlg ( app ) [EOL] [EOL] assert log . is_file ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] ] ) def test_argument_nxdrive_home ( exe , tmp , folder ) : [EOL] path = tmp ( ) [EOL] path . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] home = path / folder [EOL] arg = f' [string] { home } [string] ' [EOL] [EOL] with exe ( args = arg ) as app : [EOL] assert not fatal_error_dlg ( app ) [EOL] share_metrics_dlg ( app ) [EOL] [EOL] assert home . is_dir ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , ] , ) def test_removed_argument ( exe , arg ) : [EOL] [docstring] [EOL] with exe ( args = arg ) as app : [EOL] assert fatal_error_dlg ( app , with_details = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] import os . path [EOL] import shutil [EOL] import stat [EOL] from logging import getLogger [EOL] [EOL] import pytest [EOL] from nuxeo . documents import Document [EOL] [EOL] from nxdrive . constants import WINDOWS [EOL] [EOL] from . . . import env [EOL] from . utils import cb_get , fatal_error_dlg [comment] [EOL] [EOL] if not WINDOWS : [EOL] pytestmark = pytest . mark . skip ( [string] ) [EOL] [EOL] log = getLogger ( __name__ ) [EOL] [EOL] [EOL] def launch ( exe , args , wait = [number] ) : [EOL] try : [EOL] with exe ( args = args , wait = wait ) as app : [EOL] return not fatal_error_dlg ( app ) [EOL] except Exception : [EOL] return False [EOL] [EOL] [EOL] def bind ( exe , args ) : [EOL] [docstring] [EOL] return launch ( exe , f" [string] { args }" ) [EOL] [EOL] [EOL] def unbind ( exe , args ) : [EOL] [docstring] [EOL] return launch ( exe , f" [string] { args }" ) [EOL] [EOL] [EOL] def test_console ( exe ) : [EOL] assert launch ( exe , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , ] , ) def test_bind_server ( nuxeo_url , exe , args ) : [EOL] [docstring] [EOL] assert bind ( exe , args . format ( user = [string] , url = nuxeo_url ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , ] , ) def test_bind_server_missing_arguments ( exe , args ) : [EOL] assert not bind ( exe , args ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_unbind_server ( nuxeo_url , exe , folder ) : [EOL] [docstring] [EOL] expanded_folder = os . path . expandvars ( folder ) [EOL] local_folder = f' [string] { folder } [string] ' [EOL] args = f" [string] { nuxeo_url } [string] { local_folder }" [EOL] [EOL] try : [EOL] assert bind ( exe , args ) [EOL] assert os . path . isdir ( expanded_folder ) [EOL] assert unbind ( exe , local_folder ) [EOL] finally : [EOL] assert launch ( exe , f" [string] { local_folder }" ) [EOL] [EOL] os . chmod ( expanded_folder , stat . S_IWUSR ) [EOL] shutil . rmtree ( expanded_folder ) [EOL] assert not os . path . isdir ( expanded_folder ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_unbind_server_missing_argument ( exe , folder ) : [EOL] [docstring] [EOL] local_folder = f' [string] { folder } [string] ' [EOL] assert unbind ( exe , local_folder ) [EOL] [EOL] [EOL] def test_bind_root_doc_not_found ( nuxeo_url , exe , server , tmp ) : [EOL] args = f" [string] { str ( tmp ( ) ) } [string] " [EOL] assert not launch ( exe , args ) [EOL] [EOL] [EOL] def test_unbind_root_doc_not_found ( nuxeo_url , exe , server , tmp ) : [EOL] args = f" [string] { str ( tmp ( ) ) } [string] " [EOL] assert not launch ( exe , args ) [EOL] [EOL] [EOL] def test_complete_scenario_synchronization_from_zero ( nuxeo_url , exe , server , tmp ) : [EOL] [docstring] [EOL] [EOL] folder = tmp ( ) [EOL] assert not folder . is_dir ( ) [EOL] local_folder = f' [string] { str ( folder ) } [string] ' [EOL] [EOL] ws = None [EOL] [EOL] try : [EOL] [comment] [EOL] args = f" [string] { nuxeo_url } [string] { local_folder } [string] " [EOL] assert bind ( exe , args ) [EOL] assert folder . is_dir ( ) [EOL] [EOL] [comment] [EOL] new = Document ( name = [string] , type = [string] , properties = { [string] : [string] } , ) [EOL] ws = server . documents . create ( new , parent_path = env . WS_DIR ) [EOL] [EOL] [comment] [EOL] args = f' [string] { ws . path } [string] { local_folder }' [EOL] assert launch ( exe , args , wait = [number] ) [EOL] [EOL] [comment] [EOL] assert launch ( exe , [string] , wait = [number] ) [EOL] [EOL] [comment] [EOL] assert ( folder / ws . title ) . is_dir ( ) [EOL] [EOL] [comment] [EOL] args = f' [string] { ws . path } [string] { local_folder }' [EOL] assert launch ( exe , args ) [EOL] [EOL] [comment] [EOL] assert unbind ( exe , local_folder ) [EOL] finally : [EOL] if ws : [EOL] ws . delete ( ) [EOL] [EOL] assert launch ( exe , f" [string] { local_folder }" ) [EOL] [EOL] os . chmod ( folder , stat . S_IWUSR ) [EOL] shutil . rmtree ( folder ) [EOL] assert not os . path . isdir ( folder ) [EOL] [EOL] [EOL] def test_ctx_menu_access_online_inexistant ( nuxeo_url , exe , server , tmp ) : [EOL] [docstring] [EOL] args = [string] [EOL] assert launch ( exe , args ) [EOL] [EOL] [EOL] def test_ctx_menu_copy_share_link_inexistant ( nuxeo_url , exe , server , tmp ) : [EOL] args = [string] [EOL] assert not launch ( exe , args ) [EOL] [EOL] [EOL] def test_ctx_menu_edit_metadata_inexistant ( nuxeo_url , exe , server , tmp ) : [EOL] [docstring] [EOL] args = [string] [EOL] assert launch ( exe , args ) [EOL] [EOL] [EOL] def test_ctx_menu_entries ( nuxeo_url , exe , server , tmp ) : [EOL] [docstring] [EOL] [EOL] folder = tmp ( ) [EOL] assert not folder . is_dir ( ) [EOL] local_folder = f' [string] { str ( folder ) } [string] ' [EOL] [EOL] ws = None [EOL] [EOL] try : [EOL] [comment] [EOL] args = f" [string] { nuxeo_url } [string] { local_folder } [string] " [EOL] assert bind ( exe , args ) [EOL] assert folder . is_dir ( ) [EOL] [EOL] [comment] [EOL] new = Document ( name = [string] , type = [string] , properties = { [string] : [string] } , ) [EOL] ws = server . documents . create ( new , parent_path = env . WS_DIR ) [EOL] [EOL] [comment] [EOL] args = f' [string] { ws . path } [string] { local_folder }' [EOL] assert launch ( exe , args , wait = [number] ) [EOL] [EOL] [comment] [EOL] assert launch ( exe , [string] , wait = [number] ) [EOL] [EOL] [comment] [EOL] synced_folder = folder / ws . title [EOL] assert (synced_folder) . is_dir ( ) [EOL] [EOL] [comment] [EOL] args = f' [string] { str ( synced_folder ) } [string] ' [EOL] assert launch ( exe , args ) [EOL] url_copied = cb_get ( ) [EOL] assert url_copied . startswith ( nuxeo_url ) [EOL] assert url_copied . endswith ( ws . uid ) [EOL] [EOL] [comment] [EOL] args = f' [string] { str ( synced_folder ) } [string] ' [EOL] assert launch ( exe , args ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] args = f' [string] { str ( synced_folder ) } [string] ' [EOL] assert launch ( exe , args ) [EOL] [comment] [EOL] finally : [EOL] if ws : [EOL] ws . delete ( ) [EOL] [EOL] assert launch ( exe , f" [string] { local_folder }" ) [EOL] [EOL] os . chmod ( folder , stat . S_IWUSR ) [EOL] shutil . rmtree ( folder ) [EOL] assert not os . path . isdir ( folder ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] from nuxeo . models import Document [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , ] , ) def test_personal_space ( manager_factory , tmp , nuxeo_url , user_factory , username ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] conf_folder = tmp ( ) / [string] [EOL] user = user_factory ( username = username ) [EOL] manager , engine = manager_factory ( user = user ) [EOL] [EOL] with manager : [EOL] manager . bind_server ( conf_folder , nuxeo_url , user . uid , user . password , start_engine = False ) [EOL] [EOL] folder = engine . remote . personal_space ( ) [EOL] assert isinstance ( folder , Document ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[comment] [EOL] from typing import List , Dict , Tuple , Pattern [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] FILENAMES = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] * [number] + [string] , [string] * [number] + [string] ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , FILENAMES ) def test_re_sub ( fname , fname_expected , benchmark ) : [EOL] from re import compile , sub [EOL] [EOL] pattern = compile ( [string] ) [EOL] assert benchmark ( lambda : sub ( pattern , [string] , fname ) ) == fname_expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , FILENAMES ) def test_str_translate ( fname , fname_expected , benchmark ) : [EOL] repmap = { ord ( c ) : [string] for c in [string] } [EOL] assert benchmark ( lambda : fname . translate ( repmap ) ) == fname_expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , FILENAMES ) def test_str_replace ( fname , fname_expected , benchmark ) : [EOL] assert ( benchmark ( lambda : ( fname . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) ) == fname_expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Literal , Any , Tuple , Union [EOL] import argparse [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import print_function , unicode_literals [EOL] [EOL] import argparse [EOL] import glob [EOL] import hashlib [EOL] import os [EOL] import os . path [EOL] [EOL] import yaml [EOL] [EOL] __version__ = [string] [EOL] __all__ = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def _load ( ) : [EOL] [docstring] [EOL] [EOL] with open ( [string] ) as yml : [EOL] return yaml . safe_load ( yml . read ( ) ) or { } [EOL] [EOL] [EOL] def _dump ( versions ) : [EOL] [docstring] [EOL] [EOL] with open ( [string] , [string] ) as yml : [EOL] yaml . safe_dump ( versions or [string] , yml , indent = [number] , default_flow_style = False ) [EOL] [EOL] [EOL] def wrap ( func ) : [EOL] [docstring] [EOL] [EOL] def func_wrapper ( * args , ** kwargs ) : [EOL] [docstring] [EOL] versions = _load ( ) [EOL] func ( versions , * args , ** kwargs ) [EOL] _dump ( versions ) [EOL] [EOL] return func_wrapper [EOL] [EOL] [EOL] @ wrap def check ( versions ) : [EOL] [docstring] [EOL] [EOL] assert isinstance ( versions , dict ) and versions , versions [EOL] [EOL] [EOL] def create ( version , category ) : [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] checksum_appimage = checksum_dmg = checksum_exe = checksum_exe_admin = None [EOL] folder = os . getenv ( [string] , [string] ) [EOL] paths = ( [string] , [string] , [string] , [string] , ) [EOL] for path in paths : [EOL] path = path . format ( folder , version ) [EOL] if os . getenv ( [string] ) and not os . path . isfile ( path ) : [EOL] continue [EOL] [EOL] with open ( path , [string] ) as installer : [comment] [EOL] checksum = hashlib . sha256 ( installer . read ( ) ) . hexdigest ( ) [EOL] if path . endswith ( [string] ) : [EOL] checksum_appimage = checksum [EOL] elif path . endswith ( [string] ) : [EOL] checksum_dmg = checksum [EOL] elif [string] in path : [EOL] checksum_exe_admin = checksum [EOL] else : [EOL] checksum_exe = checksum [EOL] [EOL] [comment] [EOL] output = [string] . format ( version ) [EOL] [EOL] [docstring] [EOL] yml = [string] . format ( version , category , checksum_appimage , checksum_dmg , checksum_exe , checksum_exe_admin , ) [EOL] with open ( output , [string] ) as versions : [EOL] versions . write ( yml ) [EOL] [EOL] [EOL] @ wrap def delete ( versions , version ) : [EOL] [docstring] [EOL] [EOL] versions . pop ( version , None ) [EOL] try : [EOL] os . remove ( [string] . format ( version ) ) [EOL] except OSError : [EOL] pass [EOL] [EOL] [EOL] @ wrap def merge ( versions ) : [EOL] [docstring] [EOL] [EOL] for filename in glob . glob ( [string] ) : [EOL] if filename == [string] : [EOL] continue [EOL] [EOL] version = filename [ : - [number] ] [EOL] with open ( filename ) as yml : [EOL] info = yaml . safe_load ( yml . read ( ) ) [EOL] versions [ version ] = info [ version ] [EOL] [EOL] [EOL] @ wrap def promote ( versions , version , category ) : [EOL] [docstring] [EOL] [EOL] versions [ version ] [ [string] ] = category [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , choices = ( [string] , [string] , [string] ) , help = [string] , ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] if args . add : [EOL] assert args . type , [string] [EOL] return create ( args . add , args . type ) [EOL] elif args . check : [EOL] return check ( ) [EOL] elif args . delete : [EOL] return delete ( args . delete ) [EOL] elif args . merge : [EOL] return merge ( ) [EOL] elif args . promote : [EOL] assert args . type , [string] [EOL] return promote ( args . promote , args . type ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Tuple , Generator [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] import os [EOL] import shutil [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Generator , List , Tuple [EOL] [EOL] FILES = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] def find_useless_files ( folder ) : [EOL] [docstring] [EOL] for pattern in FILES : [EOL] yield from folder . glob ( pattern ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] [docstring] [EOL] for folder in args : [EOL] print ( f" [string] { folder } [string] " ) [EOL] for file in find_useless_files ( Path ( folder ) ) : [EOL] if file . is_dir ( ) : [EOL] shutil . rmtree ( file ) [EOL] else : [EOL] os . remove ( file ) [EOL] print ( f" [string] { file }" ) [EOL] print ( f" [string] { folder } [string] " ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] import json [EOL] import sys [EOL] from pathlib import Path [EOL] [EOL] EXIT_SUCCESS = [number] [EOL] EXIT_FAILURE = [number] [EOL] [EOL] [EOL] def run_check ( ) : [EOL] [docstring] [EOL] [EOL] last_failed_file = Path ( [string] ) [EOL] [EOL] try : [EOL] data = json . loads ( last_failed_file . read_text ( encoding = [string] ) ) [EOL] except FileNotFoundError : [EOL] print ( [string] , flush = True ) [EOL] return EXIT_FAILURE [EOL] [EOL] for _ , value in data . items ( ) : [EOL] if value : [EOL] print ( [string] , flush = True ) [EOL] return EXIT_SUCCESS [EOL] [EOL] print ( [string] , flush = True ) [EOL] return EXIT_FAILURE [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( run_check ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Pattern [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] import json [EOL] import re [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] EXIT_SUCCESS = [number] [EOL] EXIT_FAILURE = [number] [EOL] [EOL] [EOL] def print_results ( errors , warnings ) : [EOL] [docstring] [EOL] if warnings : [EOL] print ( [string] ) [EOL] for warning in warnings : [EOL] print ( warning ) [EOL] [EOL] if not errors : [EOL] return EXIT_SUCCESS [EOL] [EOL] print ( [string] ) [EOL] for error in errors : [EOL] print ( error ) [EOL] [EOL] return EXIT_FAILURE [EOL] [EOL] [EOL] def find_errors_in_tested_file ( reference_translation , translation , file , ) : [EOL] [docstring] [EOL] matcher = re . compile ( [string] ) [EOL] [EOL] errors = [ ] [EOL] for key , sentence in reference_translation . items ( ) : [EOL] if key not in translation : [EOL] errors . append ( f"{ file } [string] { key !r}" ) [EOL] continue [EOL] reference_sentence_arguments = matcher . findall ( sentence ) [EOL] tested_sentence_arguments = matcher . findall ( translation [ key ] ) [EOL] [EOL] if sorted ( reference_sentence_arguments ) != sorted ( tested_sentence_arguments ) : [EOL] errors . append ( f"{ file } [string] { key !r}" ) [EOL] return errors [EOL] [EOL] [EOL] def run_check ( translations_folder ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] warnings = [ ] [EOL] [EOL] [comment] [EOL] errors = [ ] [EOL] [EOL] translations = Path ( translations_folder ) [EOL] reference_file = translations / [string] [EOL] reference_translation = json . loads ( reference_file . read_text ( encoding = [string] ) ) [EOL] [EOL] for file in translations . glob ( [string] ) : [EOL] translation = json . loads ( file . read_text ( encoding = [string] ) ) [EOL] warnings += [ f"{ file } [string] { key !r}" for key in set ( translation ) . difference ( set ( reference_translation ) ) ] [EOL] [EOL] errors += find_errors_in_tested_file ( reference_translation , translation , file , ) [EOL] [EOL] return print_results ( errors , warnings ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [docstring] [EOL] if len ( sys . argv ) != [number] : [EOL] print ( f" [string] { sys . argv [ [number] ] } [string] " ) [EOL] sys . exit ( EXIT_FAILURE ) [EOL] sys . exit ( run_check ( sys . argv [ [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import subprocess [EOL] import sys [EOL] [EOL] [EOL] def set_environment ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [EOL] [EOL] [EOL] def run_tests_from_source ( ) : [EOL] [docstring] [EOL] [EOL] osi = sys . platform [EOL] [EOL] if osi . startswith ( [string] ) : [EOL] install = [ [string] , [string] , [string] ] [EOL] tests = [ [string] , [string] , [string] ] [EOL] elif osi == [string] : [EOL] install = [ [string] , [string] , [string] ] [EOL] tests = [ [string] , [string] , [string] ] [EOL] elif osi == [string] : [EOL] install = [ [string] , [string] , [string] , ] [EOL] tests = [ [string] , [string] , [string] , ] [EOL] else : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] subprocess . check_call ( install ) [EOL] subprocess . check_call ( tests ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] set_environment ( ) [EOL] run_tests_from_source ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] [EOL] import xattr [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) > [number] : [EOL] folder = sys . argv [ [number] ] [EOL] if not os . path . isdir ( folder ) : [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL] else : [EOL] folder = [string] [EOL] txt = xattr . getxattr ( os . path . join ( folder , [string] ) , xattr . XATTR_RESOURCEFORK_NAME ) [EOL] with open ( [string] , [string] ) as out : [EOL] out . write ( txt ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] from typing import Tuple , Union , List , Literal , Pattern , Any [EOL] import typing [EOL] import typing_extensions [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import os [EOL] import re [EOL] import subprocess [EOL] import sys [EOL] import time [EOL] from typing import List , Pattern , Tuple [EOL] [EOL] import requests [EOL] [EOL] BUNDLE_IDENTIFIER = os . getenv ( [string] , [string] ) [EOL] NOTARIZATION_USERNAME = os . environ [ [string] ] [EOL] NOTARIZATION_PASSWORD = os . environ [ [string] ] [EOL] [EOL] [EOL] def ask_for_notarization_uid ( file ) : [EOL] [docstring] [EOL] print ( f" [string] { file !r}" , flush = True ) [EOL] print ( [string] , flush = True ) [EOL] [EOL] cmd = [ [string] , [string] , [string] , [string] , BUNDLE_IDENTIFIER , [string] , NOTARIZATION_USERNAME , [string] , NOTARIZATION_PASSWORD , [string] , file , ] [EOL] [EOL] output = call ( cmd ) [EOL] matches = re . findall ( [string] , output ) [EOL] return matches [ [number] ] if matches else [string] [EOL] [EOL] [EOL] def wait_for_notarization ( uuid ) : [EOL] [docstring] [EOL] print ( f" [string] { uuid !r}" , flush = True ) [EOL] print ( [string] , flush = True ) [EOL] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] cmd = [ [string] , [string] , [string] , uuid , [string] , NOTARIZATION_USERNAME , [string] , NOTARIZATION_PASSWORD , ] [EOL] status = [string] [EOL] [EOL] while [string] : [EOL] output = call ( cmd ) [EOL] status = get_notarization_status ( output ) [EOL] [EOL] if status != [string] : [EOL] [comment] [EOL] break [EOL] [EOL] [comment] [EOL] print ( [string] , flush = True ) [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] report_url = get_notarization_report ( output ) [EOL] [EOL] return status == [string] , report_url [EOL] [EOL] [EOL] def get_notarization_report ( output , pattern = re . compile ( [string] ) ) : [EOL] [docstring] [EOL] return re . findall ( pattern , output ) [ [number] ] [EOL] [EOL] [EOL] def get_notarization_status ( output , pattern = re . compile ( [string] ) ) : [EOL] [docstring] [EOL] return re . findall ( pattern , output ) [ [number] ] [EOL] [EOL] [EOL] def staple_the_notarization ( file ) : [EOL] [docstring] [EOL] call ( [ [string] , [string] , [string] , [string] , file ] ) [EOL] print ( [string] , flush = True ) [EOL] [EOL] [EOL] def call ( cmd ) : [EOL] [docstring] [EOL] exitcode , output = subprocess . getstatusoutput ( [string] . join ( cmd ) ) [EOL] if exitcode != [number] : [EOL] print ( [string] , flush = True ) [EOL] print ( output , flush = True ) [EOL] raise subprocess . CalledProcessError ( exitcode , cmd ) [EOL] return output [EOL] [EOL] [EOL] def download_report ( uuid , url ) : [EOL] [docstring] [EOL] output = f" [string] { uuid } [string] " [EOL] print ( f" [string] { output }" , flush = True ) [EOL] [EOL] with requests . get ( url ) as req : [EOL] with open ( output , [string] , encoding = [string] ) as ofile : [EOL] ofile . write ( req . text ) [EOL] return output [EOL] [EOL] [EOL] def main ( file , uuid = [string] ) : [EOL] [docstring] [EOL] [EOL] if not uuid : [EOL] [comment] [EOL] uuid = ask_for_notarization_uid ( file ) [EOL] if not uuid : [EOL] print ( [string] , flush = True ) [EOL] return [number] [EOL] [EOL] is_valid , report_url = wait_for_notarization ( uuid ) [EOL] download_report ( uuid , report_url ) [EOL] [EOL] if not is_valid : [EOL] print ( [string] , flush = True ) [EOL] return [number] [EOL] [EOL] staple_the_notarization ( file ) [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( * sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.bool,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , List , Generator [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] import os [EOL] import shutil [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Generator , List , Optional [EOL] [EOL] from macholib . MachO import MachO [EOL] [EOL] [EOL] def create_symlink ( folder ) : [EOL] [docstring] [EOL] sibling = Path ( str ( folder ) . replace ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] root = str ( sibling ) . partition ( [string] ) [ [number] ] . lstrip ( [string] ) [EOL] [comment] [EOL] backward = [string] * ( root . count ( [string] ) + [number] ) [EOL] [comment] [EOL] good_path = f"{ backward } [string] { root }" [EOL] [EOL] folder . symlink_to ( good_path ) [EOL] [EOL] [EOL] def fix_dll ( dll ) : [EOL] [docstring] [EOL] [EOL] def match_func ( pth ) : [EOL] [docstring] [EOL] basename = os . path . basename ( pth ) [EOL] if not basename . startswith ( [string] ) : [EOL] return None [EOL] return f" [string] { good_path } [string] { basename }" [EOL] [EOL] [comment] [EOL] root = str ( dll . parent ) . partition ( [string] ) [ [number] ] [ [number] : ] [EOL] [comment] [EOL] backward = [string] * ( root . count ( [string] ) + [number] ) [EOL] [comment] [EOL] good_path = f"{ backward } [string] " [EOL] [EOL] [comment] [EOL] dll = MachO ( dll ) [EOL] dll . rewriteLoadCommands ( match_func ) [EOL] with open ( dll . filename , [string] ) as f : [EOL] for header in dll . headers : [EOL] f . seek ( [number] ) [EOL] dll . write ( f ) [EOL] f . seek ( [number] , [number] ) [EOL] f . flush ( ) [EOL] [EOL] [EOL] def find_problematic_folders ( folder ) : [EOL] [docstring] [EOL] for path in folder . iterdir ( ) : [EOL] if not path . is_dir ( ) or path . is_symlink ( ) : [EOL] [comment] [EOL] continue [EOL] if [string] == path . name : [EOL] yield path [EOL] else : [EOL] yield from find_problematic_folders ( path ) [EOL] [EOL] [EOL] def move_contents_to_resources ( folder ) : [EOL] [docstring] [EOL] for path in folder . iterdir ( ) : [EOL] if path . is_symlink ( ) : [EOL] continue [EOL] if path . is_dir ( ) : [EOL] yield from move_contents_to_resources ( path ) [EOL] else : [EOL] sibling = Path ( str ( path ) . replace ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] sibling . parent . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] [comment] [EOL] shutil . move ( path , sibling ) [EOL] [EOL] [comment] [EOL] if sibling . name . endswith ( [string] ) : [EOL] yield sibling [EOL] [EOL] [EOL] def main ( args ) : [EOL] [docstring] [EOL] for app in args : [EOL] name = os . path . basename ( app ) [EOL] print ( f" [string] { name } [string] " ) [EOL] path = Path ( app ) / [string] / [string] [EOL] for folder in find_problematic_folders ( path ) : [EOL] for file in move_contents_to_resources ( folder ) : [EOL] fix_dll ( file ) [EOL] print ( f" [string] { str ( file ) !r}" ) [EOL] shutil . rmtree ( folder ) [EOL] create_symlink ( folder ) [EOL] print ( f" [string] { name } [string] " ) [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[pathlib.Path,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import csv [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] import csv [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] [EOL] def convert ( file ) : [EOL] [docstring] [EOL] output = file . with_suffix ( [string] ) [EOL] with file . open ( ) as csvfile , output . open ( [string] ) as fout : [EOL] reader = csv . DictReader ( csvfile ) [EOL] for row in reader : [EOL] [comment] [EOL] line = [string] . format ( ** row ) [EOL] fout . write ( line ) [EOL] return output [EOL] [EOL] [EOL] def main ( files ) : [EOL] [docstring] [EOL] if not files : [EOL] print ( __doc__ ) [EOL] print ( [string] , Path ( sys . argv [ [number] ] ) . name , [string] ) [EOL] return [number] [EOL] [EOL] errcode = [number] [EOL] for file in files : [EOL] try : [EOL] output = convert ( Path ( file ) ) [EOL] print ( [string] , file , [string] , output ) [EOL] except Exception as exc : [EOL] [comment] [EOL] print ( [string] , file , str ( exc ) ) [EOL] errcode = [number] [EOL] [EOL] return errcode [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Pattern [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] from datetime import datetime [EOL] from os . path import isfile [EOL] from sys import argv [EOL] [EOL] __version__ = [string] [EOL] [EOL] [EOL] def timer ( fname , delay = None ) : [EOL] [docstring] [EOL] [EOL] if not isfile ( fname ) : [EOL] print ( [string] , fname ) [EOL] return [number] [EOL] [EOL] delay = delay or [number] [EOL] [EOL] with open ( fname ) as handler : [EOL] lines = handler . readlines ( ) [EOL] [EOL] [comment] [EOL] regexp = re . compile ( [string] ) [EOL] threads_ = { } [EOL] for line in lines : [EOL] thread_ = re . findall ( regexp , line ) [EOL] if not thread_ : [EOL] continue [EOL] thread_ = thread_ [ [number] ] [EOL] try : [EOL] threads_ [ thread_ ] . append ( line . strip ( ) ) [EOL] except KeyError : [EOL] threads_ [ thread_ ] = [ line . strip ( ) ] [EOL] [EOL] [comment] [EOL] regexp = re . compile ( [string] ) [EOL] date_fmt = [string] [EOL] for thread_ , lines in threads_ . items ( ) : [EOL] out = [ [string] + thread_ ] [EOL] for line1 , line2 in zip ( lines [ : - [number] ] , lines [ [number] : ] ) : [EOL] time1 = datetime . strptime ( re . findall ( regexp , line1 ) [ [number] ] , date_fmt ) [EOL] time2 = datetime . strptime ( re . findall ( regexp , line2 ) [ [number] ] , date_fmt ) [EOL] delta = time2 - time1 [EOL] if delta . seconds < delay : [EOL] continue [EOL] out += [ [string] . format ( delta = delta , line1 = line1 , line2 = line2 ) ] [EOL] if len ( out ) > [number] : [EOL] print ( [string] . join ( out ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] fname = argv [ [number] ] [EOL] except IndexError : [EOL] print ( [string] , argv [ [number] ] , [string] ) [EOL] return [number] [EOL] else : [EOL] try : [EOL] delay = int ( argv [ [number] ] . split ( [string] ) [ [number] ] ) [EOL] except ( IndexError , ValueError ) : [EOL] delay = None [EOL] return timer ( fname , delay = delay ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , List , Literal , Type , Dict , Any [EOL] import typing_extensions [EOL] import socketserver [EOL] import http [EOL] import typing [EOL] import distutils [EOL] [docstring] [EOL] [EOL] import distutils . dir_util [EOL] import distutils . version [EOL] import hashlib [EOL] import http . server [EOL] import os [EOL] import os . path [EOL] import re [EOL] import shutil [EOL] import socketserver [EOL] import subprocess [EOL] import sys [EOL] import tempfile [EOL] import threading [EOL] import time [EOL] from os . path import expanduser , expandvars [EOL] from pathlib import Path [EOL] [EOL] import requests [EOL] import yaml [EOL] [EOL] [comment] [EOL] sys . path . insert ( [number] , os . getcwd ( ) ) [EOL] [EOL] __version__ = [string] [EOL] [EOL] EXT = { [string] : [string] , [string] : [string] , [string] : [string] } [ sys . platform ] [EOL] Server = http . server . SimpleHTTPRequestHandler [EOL] [EOL] [EOL] def create_versions ( dst , version ) : [EOL] [docstring] [EOL] [EOL] ext = [string] if EXT == [string] else f" [string] { EXT }" [EOL] name = f" [string] { version }{ ext }" [EOL] path = os . path . join ( dst , [string] , name ) [EOL] with open ( path , [string] ) as installer : [EOL] checksum = hashlib . sha256 ( installer . read ( ) ) . hexdigest ( ) [EOL] print ( [string] , checksum , flush = True ) [EOL] [EOL] [docstring] [EOL] yml = f""" [string] { version } [string] { checksum } [string] { checksum } [string] { checksum } [string] """ [EOL] print ( [string] , yml , flush = True ) [EOL] with open ( os . path . join ( dst , [string] ) , [string] ) as versions : [EOL] versions . write ( yml ) [EOL] [EOL] [EOL] def download_last_ga_release ( output_dir , version ) : [EOL] [docstring] [EOL] [EOL] file = f" [string] { version }" [EOL] file += [string] if EXT == [string] else f" [string] { EXT }" [EOL] url = f" [string] { file }" [EOL] output = os . path . join ( output_dir , [string] , file ) [EOL] headers = { [string] : f" [string] { __version__ }" } [EOL] print ( [string] , url , [string] , output , flush = True ) [EOL] [EOL] with requests . get ( url , headers = headers ) as req , open ( output , [string] ) as dst : [EOL] dst . write ( req . content ) [EOL] [EOL] [comment] [EOL] subprocess . check_call ( [ [string] , [string] , output ] ) [EOL] [EOL] return output [EOL] [EOL] [EOL] def gen_exe ( ) : [EOL] [docstring] [EOL] [EOL] cmd = [ ] [EOL] [EOL] if EXT == [string] : [EOL] cmd = [string] [EOL] elif EXT == [string] : [EOL] cmd = [string] [EOL] else : [EOL] cmd = ( [string] [string] ) [EOL] [EOL] print ( [string] , cmd , flush = True ) [EOL] subprocess . check_call ( cmd . split ( ) ) [EOL] [EOL] [EOL] def get_last_version_number ( ) : [EOL] [docstring] [EOL] [EOL] from nxdrive . updater . utils import get_latest_version [EOL] [EOL] url = [string] [EOL] headers = { [string] : f" [string] { __version__ }" } [EOL] print ( [string] , url , flush = True ) [EOL] with requests . get ( url , headers = headers ) as req : [EOL] data = req . content [EOL] [EOL] versions = yaml . safe_load ( data ) [EOL] return get_latest_version ( versions , [string] ) [EOL] [EOL] [EOL] def get_version ( ) : [EOL] [docstring] [EOL] [EOL] if EXT == [string] : [EOL] file = expandvars ( [string] ) [EOL] else : [EOL] file = expanduser ( [string] ) [EOL] [EOL] with open ( file ) as f : [EOL] return f . read ( ) . strip ( ) [EOL] [EOL] [EOL] def install_drive ( installer ) : [EOL] [docstring] [EOL] [EOL] if EXT == [string] : [EOL] [comment] [EOL] pass [EOL] elif EXT == [string] : [EOL] [comment] [EOL] cmd = [ [string] , [string] , installer ] [EOL] print ( [string] , cmd , flush = True ) [EOL] mount_info = subprocess . check_output ( cmd ) . decode ( [string] ) . strip ( ) [EOL] mount_dir = mount_info . splitlines ( ) [ - [number] ] . split ( [string] ) [ - [number] ] [EOL] [EOL] src = [string] . format ( mount_dir ) [EOL] dst = f"{ Path . home ( ) } [string] " [EOL] if os . path . isdir ( dst ) : [EOL] print ( [string] , dst , flush = True ) [EOL] shutil . rmtree ( dst ) [EOL] print ( [string] , src , [string] , dst , flush = True ) [EOL] shutil . copytree ( src , dst ) [EOL] [EOL] cmd = [ [string] , [string] , mount_dir ] [EOL] print ( [string] , cmd , flush = True ) [EOL] subprocess . check_call ( cmd ) [EOL] else : [EOL] cmd = [ installer , [string] ] [EOL] print ( [string] , cmd , flush = True ) [EOL] subprocess . check_call ( cmd ) [EOL] [EOL] [EOL] def launch_drive ( executable , args = None ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] if not args : [EOL] args = [ ] [EOL] [EOL] if EXT == [string] : [EOL] cmd = [ executable , * args ] [EOL] elif EXT == [string] : [EOL] cmd = [ [string] , f"{ Path . home ( ) } [string] " ] [EOL] if args : [EOL] cmd . append ( [string] ) [EOL] cmd . extend ( args ) [EOL] else : [EOL] cmd = [ expandvars ( [string] ) , * args , ] [EOL] [EOL] print ( [string] , cmd , flush = True ) [EOL] subprocess . check_call ( cmd ) [EOL] [EOL] [EOL] def save_log ( output , name ) : [EOL] [docstring] [EOL] [EOL] dst = os . path . join ( output , f" [string] { EXT } [string] { name } [string] " ) [EOL] [EOL] if EXT == [string] : [EOL] src = expandvars ( [string] ) [EOL] else : [EOL] src = expanduser ( [string] ) [EOL] [EOL] try : [EOL] os . remove ( dst ) [EOL] print ( [string] , repr ( dst ) , flush = True ) [EOL] except FileNotFoundError : [EOL] pass [EOL] try : [EOL] shutil . copyfile ( src , dst ) [EOL] print ( [string] , repr ( src ) , [string] , repr ( dst ) , flush = True ) [EOL] except FileNotFoundError : [EOL] pass [EOL] [EOL] [EOL] def set_options ( ) : [EOL] [docstring] [EOL] [EOL] if EXT == [string] : [EOL] home = expandvars ( [string] ) [EOL] file = f"{ home } [string] " [EOL] metrics = f"{ home } [string] " [EOL] else : [EOL] home = expanduser ( [string] ) [EOL] file = f"{ home } [string] " [EOL] metrics = f"{ home } [string] " [EOL] [EOL] options = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] if not os . path . isdir ( home ) : [EOL] os . mkdir ( home ) [EOL] [EOL] print ( [string] , flush = True ) [EOL] with open ( metrics , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] print ( [string] , options , flush = True ) [EOL] with open ( file , [string] ) as f : [EOL] f . write ( [string] ) [EOL] f . write ( [string] ) [EOL] f . write ( [string] ) [EOL] f . write ( [string] . join ( options ) ) [EOL] f . write ( [string] ) [EOL] [EOL] [EOL] def tests ( ) : [EOL] [docstring] [EOL] [EOL] version_checker = distutils . version . StrictVersion [EOL] assert version_decrement ( [string] ) == [string] [EOL] assert version_decrement ( [string] ) == [string] [EOL] assert version_decrement ( [string] ) == [string] [EOL] assert version_decrement ( [string] ) == [string] [EOL] assert version_decrement ( [string] ) == [string] [EOL] assert version_decrement ( [string] ) == [string] [EOL] assert version_checker ( version_decrement ( [string] ) ) [EOL] assert version_checker ( version_decrement ( [string] ) ) [EOL] assert version_checker ( version_decrement ( [string] ) ) [EOL] assert version_checker ( version_decrement ( [string] ) ) [EOL] return [number] [EOL] [EOL] [EOL] def uninstall_drive ( ) : [EOL] [docstring] [EOL] [EOL] if EXT == [string] : [EOL] [comment] [EOL] home = expanduser ( [string] ) [EOL] elif EXT == [string] : [EOL] home = expanduser ( [string] ) [EOL] path = f"{ Path . home ( ) } [string] " [EOL] if os . path . isdir ( path ) : [EOL] print ( [string] , path , flush = True ) [EOL] shutil . rmtree ( path ) [EOL] else : [EOL] home = expandvars ( [string] ) [EOL] cmd = [ expandvars ( [string] ) , [string] , ] [EOL] if os . path . isfile ( cmd [ [number] ] ) : [EOL] print ( [string] , cmd , flush = True ) [EOL] subprocess . check_call ( cmd ) [EOL] [EOL] [comment] [EOL] if os . path . isdir ( home ) : [EOL] print ( [string] , home , flush = True ) [EOL] shutil . rmtree ( home ) [EOL] [EOL] [EOL] def version_decrement ( version ) : [EOL] [docstring] [EOL] [EOL] major , minor , patch , * dev = map ( int , version . split ( [string] ) ) [EOL] [EOL] if dev : [EOL] dev [ [number] ] -= [number] [EOL] if dev [ [number] ] < [number] : [EOL] dev [ [number] ] = [number] [EOL] patch -= [number] [EOL] else : [EOL] patch -= [number] [EOL] [EOL] if patch < [number] : [EOL] patch = [number] [EOL] minor -= [number] [EOL] if minor < [number] : [EOL] minor = [number] [EOL] major -= [number] [EOL] [EOL] numbers = [ major , minor , patch ] [EOL] if dev : [EOL] numbers . append ( dev [ [number] ] ) [EOL] [EOL] return [string] . join ( map ( str , numbers ) ) [EOL] [EOL] [EOL] def version_find ( ) : [EOL] [docstring] [EOL] [EOL] path = os . path . join ( [string] , [string] ) [EOL] with open ( path , encoding = [string] ) as handler : [EOL] for lineno , line in enumerate ( handler . readlines ( ) ) : [EOL] if line . startswith ( [string] ) : [EOL] version = re . findall ( [string] , line ) [ [number] ] [EOL] print ( [string] , version , [string] , lineno , flush = True ) [EOL] return version , lineno [EOL] [EOL] [EOL] def version_update ( version , lineno ) : [EOL] [docstring] [EOL] [EOL] path = os . path . join ( [string] , [string] ) [EOL] [EOL] with open ( path , encoding = [string] ) as handler : [EOL] content = handler . readlines ( ) [EOL] [EOL] content [ lineno ] = f' [string] { version } [string] ' [EOL] [EOL] with open ( path , [string] , encoding = [string] , newline = [string] ) as handler : [EOL] handler . write ( [string] . join ( content ) ) [EOL] [EOL] [EOL] def webserver ( folder , port = [number] ) : [EOL] [docstring] [EOL] [EOL] def stop ( server ) : [EOL] [docstring] [EOL] time . sleep ( [number] ) [EOL] try : [EOL] server . shutdown ( ) [EOL] except Exception : [EOL] pass [EOL] [EOL] os . chdir ( folder ) [EOL] [EOL] httpd = socketserver . TCPServer ( ( [string] , port ) , Server ) [EOL] print ( [string] , folder , f" [string] { port }" , flush = True ) [EOL] print ( [string] , flush = True ) [EOL] try : [EOL] threading . Thread ( target = stop , args = ( httpd , ) ) . start ( ) [EOL] httpd . serve_forever ( ) [EOL] except KeyboardInterrupt : [EOL] httpd . shutdown ( ) [EOL] except Exception : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def check_against_me ( root ) : [EOL] [docstring] [EOL] version , lineno = version_find ( ) [EOL] [EOL] [comment] [EOL] previous = version_decrement ( version ) [EOL] [EOL] try : [EOL] [comment] [EOL] version_update ( previous , lineno ) [EOL] assert version_find ( ) == ( previous , lineno ) [EOL] [EOL] exe = gen_and_move ( root , previous ) [EOL] [EOL] [comment] [EOL] job ( root , version , exe , previous , [string] ) [EOL] finally : [EOL] [comment] [EOL] version_update ( version , lineno ) [EOL] [EOL] [EOL] def check_against_last_release ( root ) : [EOL] [docstring] [EOL] [EOL] version , _ = version_find ( ) [EOL] [EOL] [comment] [EOL] ga_version = get_last_version_number ( ) [EOL] [EOL] [comment] [EOL] last_ga = download_last_ga_release ( root , ga_version ) [EOL] [EOL] [comment] [EOL] create_versions ( root , ga_version ) [EOL] [EOL] [comment] [EOL] job ( root , version , last_ga , ga_version , [string] ) [EOL] [EOL] [EOL] def gen_and_move ( root , version ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] gen_exe ( ) [EOL] [EOL] [comment] [EOL] ext = [string] if EXT == [string] else f" [string] { EXT }" [EOL] file = f" [string] { version }{ ext }" [EOL] dst_file = os . path . join ( root , [string] , os . path . basename ( file ) ) [EOL] print ( [string] , file , [string] , dst_file , flush = True ) [EOL] shutil . move ( file , dst_file ) [EOL] [EOL] [comment] [EOL] create_versions ( root , version ) [EOL] [EOL] return dst_file [EOL] [EOL] [EOL] def job ( root , version , executable , previous_version , name ) : [EOL] [docstring] [EOL] [EOL] src = os . getcwd ( ) [EOL] [EOL] try : [EOL] [comment] [EOL] install_drive ( executable ) [EOL] [EOL] [comment] [EOL] set_options ( ) [EOL] [EOL] version_forced = os . getenv ( [string] , [string] ) == [string] [EOL] if not version_forced : [EOL] [comment] [EOL] local_folder = os . path . join ( root , [string] ) [EOL] [EOL] [comment] [EOL] url = os . getenv ( [string] , [string] ) [EOL] username = os . getenv ( [string] , [string] ) [EOL] password = os . getenv ( [string] , [string] ) [EOL] launch_drive ( executable , [ [string] , username , url , f" [string] { password }" , f" [string] { local_folder }" , ] , ) [EOL] [EOL] [comment] [EOL] print ( [string] , previous_version , [string] , version , flush = True ) [EOL] threading . Thread ( target = launch_drive , args = ( executable , ) ) . start ( ) [EOL] [EOL] [comment] [EOL] webserver ( root ) [EOL] [EOL] [comment] [EOL] save_log ( src , name ) [EOL] [EOL] [comment] [EOL] current_ver = get_version ( ) [EOL] print ( f" [string] { current_ver !r}" , flush = True ) [EOL] assert ( current_ver == version ) , f" [string] { current_ver !r} [string] { version } [string] " [EOL] finally : [EOL] os . chdir ( src ) [EOL] [EOL] if not version_forced : [EOL] [comment] [EOL] try : [EOL] launch_drive ( executable , [ [string] , f" [string] { root }" ] ) [EOL] except Exception as exc : [EOL] print ( [string] , exc , flush = True ) [EOL] [EOL] [comment] [EOL] uninstall_drive ( ) [EOL] [EOL] [EOL] def setup ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if os . path . isdir ( [string] ) : [EOL] shutil . rmtree ( [string] ) [EOL] [EOL] [comment] [EOL] uninstall_drive ( ) [EOL] [EOL] [comment] [EOL] root = tempfile . mkdtemp ( ) [EOL] path = os . path . join ( root , [string] ) [EOL] os . makedirs ( path ) [EOL] [EOL] return root [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] root = setup ( ) [EOL] [EOL] [comment] [EOL] version , _ = version_find ( ) [EOL] gen_and_move ( root , version ) [EOL] [EOL] try : [EOL] check_against_me ( root ) [EOL] [comment] [EOL] [comment] [EOL] finally : [EOL] [comment] [EOL] try : [EOL] shutil . rmtree ( root ) [EOL] except Exception as exc : [EOL] print ( [string] , exc , flush = True ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] tests ( ) [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http.server.SimpleHTTPRequestHandler]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http.server.SimpleHTTPRequestHandler]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0