[comment] [EOL] from typing import List [EOL] import typing [EOL] import platform [EOL] [EOL] [comment] [EOL] import nox [EOL] [EOL] [EOL] nox . options . stop_on_first_error = True [EOL] [EOL] current_python_version = [string] % platform . python_version_tuple ( ) [ : [number] ] [EOL] [EOL] [EOL] pythons = [ [string] , [string] ] [EOL] assert current_python_version in pythons [EOL] pythons = [ current_python_version ] [EOL] [EOL] [EOL] @ nox . session ( python = pythons , reuse_venv = True ) @ nox . parametrize ( [string] , [ None , [string] , [string] , [string] , [string] , [string] , ] , ) def test ( session , extractor_backend ) : [EOL] session . run ( [string] , [string] , [string] , [string] , [string] , * ( ( [string] , extractor_backend ) if extractor_backend else tuple ( ) ) , [string] , external = True , ) [EOL] session . run ( [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ nox . session ( python = [string] , reuse_venv = True ) def export_requirements_txt ( session ) : [EOL] session . install ( [string] ) [EOL] session . run ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from typing import Dict , List , Any , Union [EOL] import typing [EOL] from datetime import date [EOL] [EOL] [EOL] project = [string] [EOL] year = date . today ( ) . year [EOL] copyright = f"{ year } [string] " [EOL] author = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] ] [EOL] autodoc_inherit_docstrings = True [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] html_theme_options = { [string] : [string] , [string] : True , [string] : [string] , [string] : True , [string] : True , [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , } [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] html_sidebars = { [string] : [ [string] , [string] , [string] , [string] ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import os [EOL] import sys [EOL] [EOL] from contextlib import redirect_stdout [EOL] from pathlib import Path [EOL] [EOL] [EOL] def export ( path , * extras , dev = False , ) : [EOL] from unittest import mock [EOL] from poetry . console . application import Application [EOL] from poetry . puzzle . operations import Install , Update [EOL] from clikit . args import ArgvArgs [EOL] [EOL] with mock . patch ( [string] , ) as mocked_execute : [EOL] app = Application ( ) [EOL] app . config . set_terminate_after_run ( False ) [EOL] cmd = [ [string] , [string] , [string] ] [EOL] if not dev : [EOL] cmd . extend ( [ [string] ] ) [EOL] [EOL] for extra in extras : [EOL] cmd . extend ( [ [string] , extra ] ) [EOL] [EOL] with redirect_stdout ( open ( os . devnull , [string] ) ) : [EOL] app . run ( ArgvArgs ( cmd ) ) [EOL] [EOL] text = [string] [EOL] for call_args in mocked_execute . call_args_list : [EOL] if sys . version_info [ : [number] ] > ( [number] , [number] ) : [EOL] op = call_args . args [ [number] ] [EOL] else : [EOL] op = call_args [ [number] ] [ [number] ] [EOL] [EOL] if not isinstance ( op , ( Install , Update ) ) : [EOL] continue [EOL] [EOL] if op . skip_reason in ( [string] , [string] , ) : [EOL] continue [EOL] [EOL] package = op . package [EOL] dependency = package . to_dependency ( ) [EOL] line = [string] . format ( package . name , package . version ) [EOL] requirement = dependency . to_pep_508 ( ) [EOL] if [string] in requirement : [EOL] line += [string] . format ( requirement . split ( [string] ) [ [number] ] . strip ( ) ) [EOL] [EOL] text += f"{ line } [string] " [EOL] [EOL] if path . exists ( ) and path . read_text ( encoding = [string] ) == text : [EOL] return [EOL] [EOL] path . write_text ( text , encoding = [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] export ( Path ( [string] ) , dev = False ) [EOL] export ( Path ( [string] ) , [string] , [string] , [string] , dev = False , ) [EOL] export ( Path ( [string] ) , [string] , [string] , [string] , [string] , [string] , [string] , dev = True , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [comment] [EOL] from pathlib import Path [EOL] from unittest import mock [EOL] [EOL] [comment] [EOL] import click [EOL] import docutils . nodes [EOL] import docutils . parsers . rst [EOL] import docutils . parsers . rst . directives . misc [EOL] import docutils . statemachine [EOL] import docutils . utils [EOL] [EOL] [EOL] @ click . command ( ) @ click . argument ( [string] ) @ click . argument ( [string] ) def build_readme ( source_file , target_file ) : [EOL] old_string2lines = docutils . statemachine . string2lines [EOL] old_run = docutils . parsers . rst . directives . misc . Include . run [EOL] text = [string] [EOL] target_text = None [EOL] [EOL] def string2lines ( * args , ** kwargs ) : [EOL] nonlocal text , target_text [EOL] if target_text is not None : [EOL] text = text . replace ( target_text , args [ [number] ] ) [EOL] target_text = None [EOL] else : [EOL] text += args [ [number] ] [EOL] [EOL] rv = old_string2lines ( * args , ** kwargs ) [EOL] return rv [EOL] [EOL] def run ( self ) : [EOL] nonlocal target_text [EOL] target_text = self . block_text [EOL] rv = old_run ( self ) [EOL] return rv [EOL] [EOL] with mock . patch . object ( docutils . statemachine , [string] , string2lines ) , mock . patch . object ( docutils . parsers . rst . directives . misc . Include , [string] , run ) : [EOL] source_file_path = Path . cwd ( ) / source_file [EOL] target_file_path = Path . cwd ( ) / target_file [EOL] parser = docutils . parsers . rst . Parser ( ) [EOL] default_settings = docutils . frontend . OptionParser ( components = ( docutils . parsers . rst . Parser , ) ) . get_default_values ( ) [EOL] document = docutils . utils . new_document ( source_file_path . name , default_settings ) [EOL] parser . parse ( source_file_path . read_text ( encoding = [string] ) , document ) [EOL] text = text . rstrip ( ) + [string] [EOL] if ( target_file_path . exists ( ) [EOL] and target_file_path . read_text ( encoding = [string] ) == text ) : [EOL] return [EOL] [EOL] target_file_path . write_text ( text , encoding = [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] build_readme ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pathlib [EOL] import sys [EOL] [EOL] from pathlib import Path [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] jsonpath_file = Path ( f"{ sys . prefix } [string] " ) [EOL] if jsonpath_file . exists ( ) : [EOL] jsonpath_file . unlink ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0