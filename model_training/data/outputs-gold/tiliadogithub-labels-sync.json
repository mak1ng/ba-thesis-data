[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , List , Type , Union [EOL] import github_labels_sync [EOL] import builtins [EOL] import typing [EOL] import requests [EOL] import json [EOL] from typing import Union [EOL] [EOL] from github_labels_sync import http [EOL] [EOL] [EOL] class Client ( http . Client ) : [EOL] def set_token ( self , token ) : [EOL] self . headers [ [string] ] = f' [string] { token if isinstance ( token , str ) else token . decode ( [string] ) }' [EOL] [EOL] def unset_token ( self ) : [EOL] del self . headers [ [string] ] [EOL] [EOL] def call ( self , method ) : [EOL] response = self . session . get ( f'{ self . endpoint }{ method }' , headers = self . headers ) [EOL] data = response . json ( ) [EOL] assert isinstance ( data , ( dict , list ) ) [EOL] return data [EOL] [EOL] def post ( self , method , data ) : [EOL] response = self . session . post ( f'{ self . endpoint }{ method }' , headers = self . headers , data = json . dumps ( data ) . encode ( ) ) [EOL] data = response . json ( ) [EOL] assert isinstance ( data , ( dict , list ) ) [EOL] return data [EOL] [EOL] def patch ( self , method , data ) : [EOL] response = self . session . patch ( f'{ self . endpoint }{ method }' , headers = self . headers , data = json . dumps ( data ) . encode ( ) ) [EOL] data = response . json ( ) [EOL] assert isinstance ( data , ( dict , list ) ) [EOL] return data [EOL] [EOL] def delete ( self , method ) : [EOL] self . session . delete ( f'{ self . endpoint }{ method }' , headers = self . headers ) [EOL] [EOL] __call__ = call [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.dict,builtins.list]$ 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Union[builtins.dict,builtins.list]$ 0 0 0 $builtins.str$ 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 $typing.Union[builtins.dict,builtins.list]$ 0 0 0 $builtins.str$ 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Optional [EOL] import builtins [EOL] import typing [EOL] import requests [EOL] from typing import Optional [EOL] [EOL] import requests [EOL] [EOL] from github_labels_sync . typing import StrDict [EOL] [EOL] [EOL] class Client : [EOL] endpoint = ... [EOL] session = ... [EOL] headers = ... [EOL] [EOL] def __init__ ( self , endpoint , session = None ) : [EOL] self . endpoint = endpoint [EOL] if not session : [EOL] session = requests . Session ( ) [EOL] self . headers = { [string] : [string] } [EOL] self . session = session [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.Session$ 0 0 0 $github_labels_sync.typing.StrDict$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $requests.sessions.Session$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $requests.sessions.Session$ 0 0 $requests.sessions.Session$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $requests.sessions.Session$ 0 $requests.sessions.Session$ 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Optional , List [EOL] import github_labels_sync [EOL] import builtins [EOL] import typing [EOL] import argparse [EOL] import argparse [EOL] from typing import List , Optional [EOL] import os [EOL] [EOL] from github_labels_sync import io [EOL] from github_labels_sync . config import Config [EOL] from github_labels_sync . github import GitHub [EOL] from github_labels_sync . init_command import init [EOL] from github_labels_sync . pull_command import pull [EOL] from github_labels_sync . push_command import push [EOL] [EOL] [EOL] def main ( argv ) : [EOL] parser = argparse . ArgumentParser ( prog = argv [ [number] ] , description = [string] ) [EOL] group = parser . add_mutually_exclusive_group ( required = True ) [EOL] group . add_argument ( [string] , action = [string] , default = False , help = [string] ) [EOL] group . add_argument ( [string] , action = [string] , default = False , help = [string] ) [EOL] group . add_argument ( [string] , action = [string] , default = False , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] group = parser . add_mutually_exclusive_group ( required = False ) [EOL] group . add_argument ( [string] , help = [string] ) [EOL] group . add_argument ( [string] , help = [string] ) [EOL] params = parser . parse_args ( argv [ [number] : ] ) [EOL] [EOL] if params . dir : [EOL] os . chdir ( params . dir ) [EOL] [EOL] config = load_config ( params ) [EOL] if params . init : [EOL] return init ( config ) [EOL] [EOL] token = load_token ( params ) [EOL] [EOL] github = GitHub ( ) [EOL] github . set_token ( token ) [EOL] if params . pull : [EOL] return pull ( github , config ) [EOL] if params . push : [EOL] return push ( github , config ) [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def load_config ( params ) : [EOL] config_path = params . config [EOL] if not config_path : [EOL] for config_path in io . DEFAULT_CONFIG_FILES : [EOL] if os . path . isfile ( config_path ) : [EOL] break [EOL] else : [EOL] if params . init : [EOL] config_path = io . DEFAULT_CONFIG_FILES [ [number] ] [EOL] else : [EOL] raise ValueError ( f' [string] { [string] . join ( repr ( s ) for s in io . DEFAULT_CONFIG_FILES ) }' ) [EOL] [EOL] return Config ( config_path , primary_repo = params . primary_repo , allow_empty = params . init ) [EOL] [EOL] [EOL] def load_token ( params ) : [EOL] token = params . token . strip ( ) if params . token else None [EOL] if not token : [EOL] token_path = params . token_file [EOL] if not token_path : [EOL] for token_path in io . DEFAULT_TOKEN_FILES : [EOL] if os . path . isfile ( token_path ) : [EOL] break [EOL] else : [EOL] raise ValueError ( f' [string] { [string] . join ( repr ( s ) for s in io . DEFAULT_TOKEN_FILES ) }' ) [EOL] with open ( token_path ) as fh : [EOL] token = fh . read ( ) . strip ( ) [EOL] if not token : [EOL] raise ValueError ( [string] ) [EOL] return token [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $github_labels_sync.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Union , Any [EOL] import builtins [EOL] import typing [EOL] from typing import Union , Dict , Any [EOL] [EOL] [EOL] def get_str_dict ( data , key ) : [EOL] item = data . get ( key ) [EOL] if item is None : [EOL] return None [EOL] if not isinstance ( item , dict ) : [EOL] raise TypeError ( f'{ key } [string] { type ( item ) !s} [string] { item !r} [string] ' ) [EOL] for key2 , value2 in item . items ( ) : [EOL] if not isinstance ( key2 , str ) : [EOL] raise TypeError ( f'{ key } [string] { type ( key2 ) !s} [string] { key2 !r} [string] ' ) [EOL] if not isinstance ( value2 , str ) : [EOL] raise TypeError ( f'{ key } [string] { key2 } [string] { type ( value2 ) !s} [string] { value2 !r} [string] ' ) [EOL] return item [EOL] [EOL] [EOL] def get_str_dict_of_str_dicts ( data , key ) : [EOL] item = data . get ( key ) [EOL] if item is None : [EOL] return None [EOL] if not isinstance ( item , dict ) : [EOL] raise TypeError ( f'{ key } [string] { type ( item ) !s} [string] { item !r} [string] ' ) [EOL] for key2 , value2 in item . items ( ) : [EOL] if not isinstance ( key2 , str ) : [EOL] raise TypeError ( f'{ key } [string] { type ( key2 ) !s} [string] { key2 !r} [string] ' ) [EOL] if not isinstance ( value2 , dict ) : [EOL] raise TypeError ( f'{ key } [string] { key2 } [string] { type ( value2 ) !s} [string] { value2 !r} [string] ' ) [EOL] for key3 , value3 in value2 . items ( ) : [EOL] if not isinstance ( key3 , str ) : [EOL] raise TypeError ( f'{ key } [string] { key2 } [string] { type ( key3 ) !s} [string] { key3 !r} [string] ' ) [EOL] if not isinstance ( value3 , str ) : [EOL] raise TypeError ( f'{ key } [string] { key2 } [string] { key3 } [string] { type ( value3 ) !s} [string] { value3 !r} [string] ' ) [EOL] return item [EOL] [EOL] [EOL] def sorted_dict ( dictionary ) : [EOL] return { key : dictionary [ key ] for key in sorted ( dictionary ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.str],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , Type [EOL] import typing [EOL] from typing import Dict [EOL] [EOL] StrDict = Dict [ str , str ] [comment] [EOL] DictOfStrDicts = Dict [ str , StrDict ] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import sys [EOL] [EOL] from github_labels_sync import cli [EOL] [EOL] if __name__ == [string] : [EOL] argv = sys . argv [ : ] [EOL] argv [ [number] ] = [string] [EOL] try : [EOL] sys . exit ( cli . main ( argv ) or [number] ) [EOL] except ValueError as e : [EOL] print ( e , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict [EOL] import github_labels_sync [EOL] import builtins [EOL] import typing [EOL] from github_labels_sync . github import GitHub [EOL] from github_labels_sync . typing import StrDict [EOL] [EOL] [EOL] class Action : [EOL] def run ( self , github , repo ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class UpdateAction ( Action ) : [EOL] def __init__ ( self , label , updates ) : [EOL] self . updates = updates [EOL] self . label = label [EOL] [EOL] def run ( self , github , repo ) : [EOL] github . update_label ( repo , self . label [ [string] ] , self . updates ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . label [ [string] ] !r}' [EOL] [EOL] [EOL] class ReplaceAction ( Action ) : [EOL] def __init__ ( self , label , replacement ) : [EOL] self . label = label [EOL] self . replacement = replacement [EOL] assert [string] in replacement , replacement [EOL] [EOL] def run ( self , github , repo ) : [EOL] old_label = self . label [ [string] ] [EOL] github . replace_label ( repo , old_label , self . replacement [ [string] ] ) [EOL] github . delete_label ( repo , old_label ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . label [ [string] ] !r} [string] { self . replacement [ [string] ] !r}' [EOL] [EOL] [EOL] class RenameAction ( UpdateAction ) : [EOL] def __init__ ( self , label , updates ) : [EOL] super ( ) . __init__ ( label , updates ) [EOL] assert [string] in updates , updates [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . label [ [string] ] !r} [string] { self . updates [ [string] ] !r}' [EOL] [EOL] [EOL] class UnknownLabelAction ( Action ) : [EOL] def __init__ ( self , label ) : [EOL] self . label = label [EOL] [EOL] def run ( self , github , repo ) : [EOL] raise NotImplementedError ( f' [string] { self . label [ [string] ] !r} [string] { repo }' ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . label [ [string] ] !r}' [EOL] [EOL] [EOL] class CreateAction ( Action ) : [EOL] def __init__ ( self , name , properties , ) : [EOL] self . name = name [EOL] self . properties = properties [EOL] [EOL] def run ( self , github , repo ) : [EOL] github . create_label ( repo , self . name , self . properties ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . name !r}' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $None$ 0 0 0 $github_labels_sync.github.GitHub$ 0 $builtins.str$ 0 0 0 $github_labels_sync.github.GitHub$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $None$ 0 0 0 $github_labels_sync.github.GitHub$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $github_labels_sync.github.GitHub$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $github_labels_sync.github.GitHub$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $github_labels_sync.typing.StrDict$ 0 $github_labels_sync.typing.StrDict$ 0 0 0 0 0 0 0 0 0 $github_labels_sync.typing.StrDict$ 0 $github_labels_sync.typing.StrDict$ 0 0 0 0 0 $github_labels_sync.typing.StrDict$ 0 $github_labels_sync.typing.StrDict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $None$ 0 0 0 $github_labels_sync.github.GitHub$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $None$ 0 0 0 $github_labels_sync.github.GitHub$ 0 $builtins.str$ 0 0 0 $github_labels_sync.github.GitHub$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import github_labels_sync [EOL] import builtins [EOL] from github_labels_sync . config import Config [EOL] [EOL] [EOL] def init ( config ) : [EOL] config . save ( force = True ) [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , List , Iterable , Optional , Union [EOL] import github_labels_sync [EOL] import builtins [EOL] import typing [EOL] import requests [EOL] from typing import List , Dict , Optional , Union , Iterable , Any [EOL] [EOL] import requests [EOL] [EOL] from github_labels_sync import graphql , rest [EOL] [EOL] DEFAULT_GRAPHQL_ENDPOINT_URL = [string] [EOL] DEFAULT_REST_ENDPOINT_URL = [string] [EOL] [EOL] [EOL] class GraphqlClient ( graphql . Client ) : [EOL] def __init__ ( self , endpoint = DEFAULT_GRAPHQL_ENDPOINT_URL , session = None ) : [EOL] super ( ) . __init__ ( endpoint , session ) [EOL] [EOL] [EOL] class RestClient ( rest . Client ) : [EOL] def __init__ ( self , endpoint = DEFAULT_REST_ENDPOINT_URL , session = None ) : [EOL] super ( ) . __init__ ( endpoint , session ) [EOL] self . headers [ [string] ] = [string] [EOL] [EOL] [EOL] class GitHub : [EOL] graphql_client = ... [EOL] rest_client = ... [EOL] [EOL] def __init__ ( self , graphql_client = None , rest_client = None ) : [EOL] if not graphql_client or not rest_client : [EOL] session = requests . Session ( ) [EOL] if not graphql_client : [EOL] graphql_client = GraphqlClient ( session = session ) [EOL] if not rest_client : [EOL] rest_client = RestClient ( session = session ) [EOL] self . graphql_client = graphql_client [EOL] self . rest_client = rest_client [EOL] [EOL] def set_token ( self , token ) : [EOL] self . graphql_client . set_token ( token ) [EOL] self . rest_client . set_token ( token ) [EOL] [EOL] def unset_token ( self ) : [EOL] self . graphql_client . unset_token ( ) [EOL] self . rest_client . unset_token ( ) [EOL] [EOL] def get_label ( self , owner , repo , name ) : [EOL] result = self . rest_client ( f' [string] { owner } [string] { repo } [string] { name }' ) [EOL] assert isinstance ( result , dict ) [EOL] return result [EOL] [EOL] def create_label ( self , repo , name , properties ) : [EOL] properties [ [string] ] = name [EOL] result = self . rest_client . post ( f' [string] { repo } [string] ' , properties ) [EOL] assert isinstance ( result , dict ) [EOL] return result [EOL] [EOL] def update_label ( self , repo , name , properties ) : [EOL] result = self . rest_client . patch ( f' [string] { repo } [string] { name }' , properties ) [EOL] assert isinstance ( result , dict ) [EOL] return result [EOL] [EOL] def delete_label ( self , repo , name ) : [EOL] self . rest_client . delete ( f' [string] { repo } [string] { name }' ) [EOL] [EOL] def replace_label ( self , repo , old_label , new_label ) : [EOL] while True : [EOL] issues = self . list_issues_with_label ( repo , old_label ) [EOL] if not issues : [EOL] break [EOL] for issue in issues : [EOL] number = issue [ [string] ] [EOL] self . add_label_to_issue ( repo , number , new_label ) [EOL] self . remove_label_from_issue ( repo , number , old_label ) [EOL] [EOL] def add_label_to_issue ( self , repo , issue , label ) : [EOL] return self . add_labels_to_issue ( repo , issue , [ label ] ) [EOL] [EOL] def add_labels_to_issue ( self , repo , issue , labels ) : [EOL] result = self . rest_client . post ( f' [string] { repo } [string] { issue } [string] ' , list ( labels ) ) [EOL] assert isinstance ( result , list ) [EOL] return result [EOL] [EOL] def remove_label_from_issue ( self , repo , issue , label ) : [EOL] self . rest_client . delete ( f' [string] { repo } [string] { issue } [string] { label }' ) [EOL] [EOL] def list_labels ( self , repo ) : [EOL] owner , repo = repo . split ( [string] ) [EOL] data = self . graphql_client . query ( [string] , owner = owner , repo = repo ) [EOL] result = data [ [string] ] [ [string] ] [ [string] ] [EOL] return result [EOL] [EOL] def list_issues_with_label ( self , repo , label ) : [EOL] owner , repo = repo . split ( [string] ) [EOL] data = self . graphql_client . query ( [string] , owner = owner , repo = repo , label = label ) [EOL] result = data [ [string] ] [ [string] ] [ [string] ] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[requests.Session]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[requests.Session]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[requests.Session]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[requests.Session]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $github_labels_sync.graphql.Client$ 0 0 0 $github_labels_sync.rest.Client$ 0 0 0 0 0 $None$ 0 0 0 $github_labels_sync.graphql.Client$ 0 0 0 $github_labels_sync.rest.Client$ 0 0 0 0 0 0 0 $github_labels_sync.graphql.Client$ 0 0 $github_labels_sync.rest.Client$ 0 0 $requests.sessions.Session$ 0 0 0 0 0 0 0 0 0 $github_labels_sync.graphql.Client$ 0 0 $github_labels_sync.graphql.Client$ 0 0 0 $requests.sessions.Session$ 0 $requests.sessions.Session$ 0 0 0 0 $github_labels_sync.rest.Client$ 0 0 $github_labels_sync.rest.Client$ 0 0 0 $requests.sessions.Session$ 0 $requests.sessions.Session$ 0 0 0 0 $github_labels_sync.graphql.Client$ 0 $github_labels_sync.graphql.Client$ 0 0 0 $github_labels_sync.rest.Client$ 0 $github_labels_sync.rest.Client$ 0 0 0 $None$ 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 $builtins.dict$ 0 0 0 0 $builtins.str$ 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.dict$ 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Iterable[builtins.str]$ 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any]]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List [EOL] import github_labels_sync [EOL] import builtins [EOL] import typing [EOL] from github_labels_sync . config import Config [EOL] from github_labels_sync . github import GitHub [EOL] from github_labels_sync . actions import UnknownLabelAction [EOL] [EOL] [EOL] def push ( github , config ) : [EOL] all_ok = True [EOL] for repo in config . all_repos : [EOL] labels = github . list_labels ( repo ) [EOL] actions = config . labels . process ( labels ) [EOL] proceed = True [EOL] for action in actions : [EOL] if isinstance ( action , UnknownLabelAction ) : [EOL] print ( repo , [string] , action ) [EOL] proceed = False [EOL] if not proceed : [EOL] print ( repo , [string] ) [EOL] all_ok = False [EOL] break [EOL] [EOL] for action in actions : [EOL] print ( repo , action ) [EOL] action . run ( github , repo ) [EOL] return [number] if all_ok else [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , Type , Optional , Union [EOL] import github_labels_sync [EOL] import builtins [EOL] import typing [EOL] import requests [EOL] from typing import Union , Any , Optional [EOL] [EOL] from github_labels_sync import http [EOL] [EOL] [EOL] class Client ( http . Client ) : [EOL] def query ( self , query , variables = None , ** kwargs ) : [EOL] if variables is None : [EOL] variables = kwargs [EOL] elif kwargs : [EOL] variables . update ( kwargs ) [EOL] [EOL] response = self . session . post ( self . endpoint , json = { [string] : query , [string] : variables } , headers = self . headers ) [EOL] data = response . json ( ) [ [string] ] [EOL] assert isinstance ( data , dict ) [EOL] return data [EOL] [EOL] __call__ = query [EOL] [EOL] def set_token ( self , token ) : [EOL] self . headers [ [string] ] = f' [string] { token if isinstance ( token , str ) else token . decode ( [string] ) }' [EOL] [EOL] def unset_token ( self ) : [EOL] del self . headers [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 0 $typing.Union[builtins.bytes,builtins.str]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , List [EOL] import builtins [EOL] import typing [EOL] import os [EOL] from typing import Optional [EOL] [EOL] DEFAULT_CONFIG_PATH = os . path . expanduser ( [string] ) [EOL] [EOL] [EOL] def get_config_path ( path = None ) : [EOL] return os . path . join ( DEFAULT_CONFIG_PATH , path ) if path else DEFAULT_CONFIG_PATH [EOL] [EOL] [EOL] DEFAULT_CONFIG_FILES = [ [string] , [string] , [string] ] [EOL] DEFAULT_TOKEN_FILES = [ get_config_path ( [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List [EOL] import github_labels_sync [EOL] import builtins [EOL] import typing [EOL] from github_labels_sync . config import Config [EOL] from github_labels_sync . github import GitHub [EOL] [EOL] [EOL] def pull ( github , config ) : [EOL] owner , repo = config . primary_repo . split ( [string] ) [EOL] labels = github . list_labels ( config . primary_repo ) [EOL] config . labels . update ( labels ) [EOL] config . save ( force = True ) [EOL] for label in labels : [EOL] print ( github . get_label ( owner , repo , label [ [string] ] ) ) [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0