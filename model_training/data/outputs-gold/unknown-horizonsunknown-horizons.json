[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List , Union [EOL] import typing [EOL] import os [EOL] [EOL] from setuptools import setup [EOL] [EOL] [comment] [EOL] [comment] [EOL] includes_dir = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] includes_target = [string] [EOL] [EOL] [comment] [EOL] data_includes = [ ] [EOL] [EOL] [comment] [EOL] for root , dirs , filenames in os . walk ( includes_dir ) : [EOL] if root is includes_dir : [EOL] final = includes_target [EOL] else : [EOL] final = includes_target + root [ len ( includes_dir ) + [number] : ] + [string] [EOL] files = [ ] [EOL] for file in filenames : [EOL] if ( file [ [number] ] != [string] ) : [EOL] files . append ( os . path . join ( root , file ) ) [EOL] data_includes . append ( ( final , files ) ) [EOL] [EOL] packages = [ ] [EOL] packages . append ( [string] ) [EOL] packages . append ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] plist = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] } [EOL] [EOL] APP = [ [string] ] [EOL] OPTIONS = { [string] : True , [string] : packages , [string] : plist } [EOL] [EOL] setup ( app = APP , data_files = data_includes , options = { [string] : OPTIONS } , setup_requires = [ [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]],typing.List[typing.Any],builtins.bool]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]],typing.List[typing.Any],builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Dict , Literal , Any , List , Union [EOL] import gettext [EOL] import typing [EOL] import typing_extensions [EOL] from __future__ import print_function [EOL] import gettext [EOL] import os [EOL] import re [EOL] import subprocess [EOL] import sys [EOL] import yaml [EOL] [EOL] [comment] [EOL] [comment] [EOL] YAML_PATH = [string] [EOL] [comment] [EOL] [comment] [EOL] MO_OUTPUT = [string] [EOL] MSGFMT_PATH = [string] [EOL] [comment] [EOL] PO_INPUT_PATH = [string] [EOL] [EOL] [comment] [EOL] WEBLATE_PATH = re . compile ( [string] , re . VERBOSE ) [EOL] [EOL] [EOL] def setup_paths ( ) : [EOL] match = WEBLATE_PATH . match ( sys . argv [ [number] ] ) [EOL] path_prefix = match . group ( [number] ) [EOL] [comment] [EOL] language_path = match . group ( [number] ) [EOL] [comment] [EOL] scenario_path = match . group ( [number] ) [EOL] [EOL] if not os . path . exists ( scenario_path ) : [EOL] scenario_path = YAML_PATH . format ( path_prefix = path_prefix , scenario = scenario_path , language = [string] ) [EOL] if not os . path . exists ( scenario_path ) : [EOL] print ( [string] , scenario_path ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [comment] [EOL] scenario = os . path . splitext ( os . path . basename ( scenario_path ) ) [ [number] ] [EOL] if scenario . endswith ( [string] ) : [EOL] scenario = scenario [ : - [number] ] [EOL] [EOL] if os . path . exists ( language_path ) : [EOL] dirname = os . path . dirname ( language_path ) [EOL] language = dirname . split ( os . path . sep ) [ - [number] ] [EOL] else : [EOL] language = language_path [EOL] language_path = PO_INPUT_PATH . format ( scenario = scenario , language = language ) [EOL] [EOL] yaml_output = YAML_PATH . format ( path_prefix = path_prefix , scenario = scenario , language = language ) [EOL] msgfmt_output = MSGFMT_PATH . format ( MO_OUTPUT = MO_OUTPUT , language = language ) + [string] . format ( scenario ) [EOL] [EOL] [comment] [EOL] subprocess . call ( [ [string] , [string] , MSGFMT_PATH . format ( MO_OUTPUT = MO_OUTPUT , language = language ) ] ) [EOL] [EOL] return ( path_prefix , scenario , scenario_path , language , language_path , yaml_output , msgfmt_output ) [EOL] [EOL] [EOL] def setup_gettext ( scenario , language ) : [EOL] try : [EOL] translation = gettext . translation ( scenario , MO_OUTPUT , [ language ] ) [EOL] except IOError : [EOL] [comment] [EOL] print ( [string] [string] . format ( scenario , language , MO_OUTPUT ) ) [EOL] sys . exit ( [number] ) [EOL] else : [EOL] translation . install ( ) [EOL] [EOL] [EOL] def compile_scenario_po ( output_mo ) : [EOL] input_po = sys . argv [ [number] ] [EOL] if not os . path . exists ( input_po ) : [EOL] print ( [string] . format ( input_po ) ) [EOL] sys . exit ( [number] ) [EOL] try : [EOL] stats = subprocess . check_output ( [ [string] , [string] , [string] , input_po , [string] , output_mo , ] , stderr = subprocess . STDOUT , universal_newlines = True ) [EOL] except subprocess . CalledProcessError : [EOL] [comment] [EOL] print ( [string] [string] . format ( input_po ) ) [EOL] sys . exit ( [number] ) [EOL] else : [EOL] return stats [EOL] [EOL] [EOL] def write_translated_yaml ( fileish , where , metadata , generator ) : [EOL] [docstring] [EOL] [EOL] def translate ( string ) : [EOL] return _ ( string . rstrip ( [string] ) ) [EOL] [EOL] def preprint ( yamlish , new_anchor , just_copy = True ) : [EOL] [docstring] [EOL] if just_copy : [EOL] where . writelines ( yamlish ) [EOL] where . write ( new_anchor ) [EOL] return [EOL] [EOL] new_anchor = new_anchor . rstrip ( [string] ) [EOL] loaded_yaml = yaml . safe_load ( [string] . join ( yamlish ) ) [EOL] all_events = [ ] [EOL] for event in loaded_yaml : [EOL] if isinstance ( event , str ) : [EOL] if event . strip ( ) : [EOL] event = translate ( event ) [EOL] if isinstance ( event , list ) : [EOL] widget = event [ [number] ] [EOL] if widget in ( [string] , [string] , [string] ) : [EOL] pass [EOL] if widget in ( [string] , [string] , [string] , [string] ) : [EOL] event = [ widget ] + [ translate ( e ) for e in event [ [number] : ] ] [EOL] [EOL] all_events . append ( event ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] dumpster = yaml . safe_dump ( all_events , allow_unicode = True , width = [number] ) [EOL] [comment] [EOL] [comment] [EOL] for line in dumpster . split ( [string] ) : [EOL] indent = [string] if line else [string] [EOL] where . write ( indent + line + [string] ) [EOL] [EOL] where . write ( new_anchor + [string] ) [EOL] [EOL] def write_translated_metadata ( translated_metadata ) : [EOL] [comment] [EOL] file_metadata = yaml . safe_load ( [string] . join ( fileish ) ) [ [string] ] [EOL] translated_metadata = file_metadata . copy ( ) [EOL] [comment] [EOL] [comment] [EOL] for key in ( [string] , [string] , [string] ) : [EOL] value = file_metadata [ key ] [EOL] translated_metadata [ key ] = translate ( value ) [EOL] [comment] [EOL] [comment] [EOL] if metadata : [EOL] translated_metadata . update ( metadata ) [EOL] [comment] [EOL] [comment] [EOL] m = { [string] : translated_metadata } [EOL] dumped = yaml . safe_dump ( m , allow_unicode = True , width = [number] , default_flow_style = False ) [EOL] where . write ( dumped ) [EOL] [EOL] where . write ( [string] . format ( generator , metadata [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] anchors = [ ] [EOL] [comment] [EOL] sections = [ [ ] ] [EOL] [comment] [EOL] seen_start_anchor = False [EOL] [comment] [EOL] copy_again = False [EOL] [EOL] for line in fileish : [EOL] [EOL] if copy_again : [EOL] if line . startswith ( [string] ) : [EOL] write_translated_metadata ( [number] ) [EOL] break [EOL] where . write ( line ) [EOL] [EOL] elif line . startswith ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] anchors . append ( line ) [EOL] preprint ( sections [ - [number] ] , anchors [ - [number] ] , just_copy = not seen_start_anchor ) [EOL] sections . append ( [ ] ) [EOL] [EOL] if not seen_start_anchor : [EOL] seen_start_anchor = True [EOL] [EOL] elif line . startswith ( [string] ) : [EOL] [comment] [EOL] anchors . append ( line ) [EOL] preprint ( sections [ - [number] ] , anchors [ - [number] ] , just_copy = not seen_start_anchor ) [EOL] sections . append ( [ ] ) [EOL] [EOL] [comment] [EOL] copy_again = True [EOL] [EOL] else : [EOL] sections [ - [number] ] . append ( line ) [EOL] [EOL] [EOL] def main ( ) : [EOL] ( path_prefix , scenario , scenario_path , language , language_path , yaml_output , msgfmt_output ) = setup_paths ( ) [EOL] [comment] [EOL] [comment] [EOL] tl_status = compile_scenario_po ( msgfmt_output ) [EOL] setup_gettext ( scenario , language ) [EOL] [EOL] metadata = { [string] : tl_status . rstrip ( ) , [string] : language , [string] : scenario_path [ len ( path_prefix ) : ] , } [EOL] [EOL] generator = os . path . join ( [string] , os . path . basename ( __file__ ) ) [EOL] [EOL] with open ( yaml_output , [string] ) as out : [EOL] with open ( scenario_path , [string] ) as f : [EOL] english_scenario = f . readlines ( ) [EOL] write_translated_yaml ( english_scenario , out , metadata , generator ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) != [number] : [EOL] print ( [string] . format ( os . path . basename ( __file__ ) ) ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL] else : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Pattern , List [EOL] import io [EOL] import typing [EOL] from __future__ import print_function [EOL] import re [EOL] import sys [EOL] [EOL] is_function = re . compile ( [string] ) [EOL] is_decorator = re . compile ( [string] ) [EOL] func_param = re . compile ( [string] ) [EOL] is_empty = re . compile ( [string] ) [EOL] [EOL] files = sys . argv [ [number] : ] [EOL] for filename in files : [EOL] print ( [string] , filename ) [EOL] file = open ( filename , [string] ) [EOL] funk_reg = None [EOL] newfile = [ ] [EOL] for line in file : [EOL] if is_function . match ( line ) is not None : [EOL] funk_reg = is_function . match ( line ) [EOL] elif funk_reg is not None and line . strip ( ) . startswith ( [string] ) : [EOL] newfile . append ( funk_reg . group ( ) ) [EOL] newfile . append ( line ) [EOL] funk_reg = None [EOL] elif funk_reg is not None : [EOL] params = func_param . findall ( funk_reg . group ( [number] ) ) [EOL] indent = funk_reg . group ( [number] ) + [string] * ( funk_reg . group ( [number] ) != [string] ) [EOL] docstub = [ ( indent + [string] ) ] [EOL] for i in params : [EOL] if i [ [number] ] != [string] and i [ [number] ] != [string] : [EOL] docstub . append ( ( [string] . format ( indent , i [ [number] ] ) ) ) [EOL] docstub . append ( ( indent + [string] ) ) [EOL] if funk_reg . group ( [number] ) == [string] : [EOL] newfile . extend ( docstub ) [EOL] newfile . append ( funk_reg . group ( ) ) [EOL] else : [EOL] newfile . append ( funk_reg . group ( ) ) [EOL] newfile . extend ( docstub ) [EOL] newfile . append ( line ) [EOL] funk_reg = None [EOL] else : [EOL] newfile . append ( line ) [EOL] file . seek ( [number] ) [EOL] file . writelines ( newfile ) [EOL] file . close ( ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $None$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $None$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from __future__ import print_function [EOL] import os [EOL] import glob [EOL] [EOL] if os . path . basename ( os . getcwd ( ) ) != [string] : [EOL] print ( [string] ) [EOL] quit ( ) [EOL] [EOL] if not os . path . isdir ( [string] ) : [EOL] print ( [string] ) [EOL] quit ( ) [EOL] [EOL] os . chdir ( [string] ) [EOL] files = glob . glob ( [string] ) [EOL] for x in files : [EOL] file = x . rpartition ( [string] ) [ [number] ] [EOL] dir = file [ : - len ( [string] ) ] [EOL] dir = os . path . join ( [string] , [string] , dir , [string] , [string] ) [EOL] if not os . path . isdir ( dir ) : [EOL] os . makedirs ( dir ) [EOL] print ( [string] , file ) [EOL] command = [string] + x + [string] + dir + [string] [EOL] os . system ( command ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] import os [EOL] import os . path [EOL] [EOL] [EOL] [comment] [EOL] where = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] if not os . path . exists ( [string] ) : [EOL] os . chdir ( [string] ) [EOL] assert os . path . exists ( [string] ) , [string] [EOL] [EOL] base_url = [string] + os . path . abspath ( os . getcwd ( ) ) + [string] [EOL] [EOL] for root , dirs , files in sorted ( os . walk ( where ) ) : [EOL] for f in sorted ( files ) : [EOL] if not f . endswith ( ( [string] , [string] ) ) : [EOL] continue [EOL] url = base_url + [string] + root + [string] + f [EOL] print ( [string] . format ( url = url ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Dict [EOL] import io [EOL] import typing [EOL] from __future__ import print_function [EOL] import sys [EOL] [EOL] usage = [string] [EOL] usage = [string] [EOL] [EOL] if len ( sys . argv ) < [number] : [EOL] print ( usage ) [EOL] sys . exit ( [number] ) [EOL] [EOL] filename = sys . argv [ [number] ] [EOL] [EOL] readfile = open ( filename , [string] ) [EOL] [EOL] i = [number] [EOL] translations = { } [EOL] [EOL] state = [number] [EOL] [EOL] for line in readfile : [EOL] line = line . strip ( ) [EOL] [EOL] if state == [number] : [EOL] if [string] not in line : [EOL] continue [EOL] translations [ i ] = { } [EOL] translations [ i ] [ [number] ] = line [EOL] state += [number] [EOL] [EOL] elif state == [number] : [EOL] if [string] in line : [EOL] translations [ i ] [ [number] ] = line [EOL] state += [number] [EOL] else : [EOL] translations [ i ] [ [number] ] += line [EOL] [EOL] elif state == [number] : [EOL] if line . startswith ( [string] ) or not line : [EOL] state = [number] [EOL] i += [number] [EOL] else : [EOL] translations [ i ] [ [number] ] += line [EOL] [EOL] [EOL] for t in translations : [EOL] orig = translations [ t ] [ [number] ] [EOL] trans = translations [ t ] [ [number] ] [EOL] [EOL] if orig . startswith ( [string] ) or trans . startswith ( [string] ) : [EOL] continue [EOL] [EOL] if orig . startswith ( [string] ) : [EOL] orig = orig [ [number] : ] [EOL] if trans . startswith ( [string] ) : [EOL] trans = trans [ [number] : ] [EOL] [EOL] if trans == [string] : [EOL] continue [EOL] [EOL] len_ratio = float ( len ( orig ) ) / len ( trans ) [EOL] [EOL] if len_ratio > [number] or len_ratio < [number] and abs ( len ( orig ) - len ( trans ) ) > [number] : [EOL] print ( [string] , len_ratio ) [EOL] print ( orig ) [EOL] print ( trans ) [EOL] print ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Dict , OrderedDict , Any , List [EOL] import typing [EOL] import collections [EOL] from collections import OrderedDict [EOL] [EOL] [EOL] sections = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] section_widgets = { s : [string] + s . lower ( ) for s in sections } [EOL] section_widgets . update ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] [comment] [EOL] huge_pages = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] INPUT = [string] [EOL] OUTPUT = [string] [EOL] [EOL] HEADER = [string] . format ( INPUT , INPUT , __file__ ) [EOL] FOOTER = [string] [EOL] [EOL] XML_MESS = [ ( [string] , [string] ) , ] [EOL] [EOL] [EOL] def write ( f , level , text , newline = True ) : [EOL] wtext = [string] * newline + [string] * level + text [EOL] for search , replace in XML_MESS : [EOL] wtext = wtext . replace ( search , replace ) [EOL] f . write ( wtext ) [EOL] [EOL] [EOL] def close_box ( box , level ) : [EOL] write ( f , level , [string] . format ( box ) ) [EOL] [EOL] [EOL] def close_vbox ( level ) : [EOL] close_box ( [string] , level ) [EOL] [EOL] [EOL] def close_hbox ( level ) : [EOL] close_box ( [string] , level ) [EOL] [EOL] [EOL] class PageBreak ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] def parse_markdown ( infile ) : [EOL] [docstring] [EOL] tree = OrderedDict ( ) [EOL] headings = [ ( [number] , tree ) ] [EOL] [EOL] with open ( infile ) as f : [EOL] for line in f : [EOL] line = line . strip ( ) [EOL] if line . startswith ( [string] ) : [EOL] parts = line . split ( [string] ) [EOL] heading_level = parts [ [number] ] . count ( [string] ) [EOL] while heading_level <= headings [ - [number] ] [ [number] ] : [EOL] headings . pop ( ) [EOL] [EOL] parts = parts [ [number] : ] [EOL] if set ( parts [ - [number] ] ) == set ( [string] ) : [EOL] parts = parts [ : - [number] ] [EOL] text = [string] . join ( parts ) [EOL] dct = OrderedDict ( ) [EOL] headings [ - [number] ] [ [number] ] [ text ] = dct [EOL] headings . append ( ( heading_level , dct ) ) [EOL] elif line . startswith ( [string] ) or line . startswith ( [string] ) : [EOL] if [string] not in headings [ - [number] ] [ [number] ] : [EOL] headings [ - [number] ] [ [number] ] [ [string] ] = [ ] [EOL] [EOL] heading = line [ [number] : ] . lstrip ( ) [EOL] headings [ - [number] ] [ [number] ] [ [string] ] . append ( heading ) [EOL] elif not line : [EOL] pass [EOL] else : [EOL] raise Exception ( [string] + line ) [EOL] return headings [ [number] ] [ [number] ] [EOL] [EOL] [EOL] def write_page ( heading , content ) : [EOL] def write_page_header ( ) : [EOL] if heading in huge_pages : [EOL] write ( f , [number] , [string] [string] . format ( heading . lower ( ) ) ) [EOL] [comment] [EOL] write ( f , [number] , [string] ) [EOL] else : [EOL] write ( f , [number] , [string] ) [EOL] [EOL] def write_page_footer ( ) : [EOL] close_vbox ( [number] ) [EOL] if heading in huge_pages : [EOL] write ( f , [number] , [string] ) [EOL] [EOL] write ( f , [number] , [string] . format ( section_widgets [ heading ] ) ) [EOL] [EOL] write_page_header ( ) [EOL] [EOL] write ( f , [number] , [string] . format ( heading ) ) [EOL] write ( f , [number] , [string] ) [EOL] [EOL] for h3 , lines in content . items ( ) : [EOL] try : [EOL] write_subsection ( h3 , lines ) [EOL] except PageBreak : [EOL] [comment] [EOL] write_page_footer ( ) [EOL] write_page_header ( ) [EOL] [EOL] write_page_footer ( ) [EOL] close_hbox ( [number] ) [EOL] [EOL] [EOL] def write_subsection ( subheading , subcontent ) : [EOL] write ( f , [number] , [string] . format ( subheading ) ) [EOL] write ( f , [number] , [string] ) [EOL] for line in subcontent [ [string] ] : [comment] [EOL] if set ( line ) == set ( [string] ) : [EOL] close_vbox ( [number] ) [EOL] close_vbox ( [number] ) [EOL] raise PageBreak [EOL] else : [EOL] write ( f , [number] , [string] . format ( line ) ) [EOL] close_vbox ( [number] ) [EOL] close_vbox ( [number] ) [EOL] [EOL] [EOL] credits = parse_markdown ( INPUT ) [EOL] [EOL] [comment] [EOL] [EOL] with open ( OUTPUT , [string] ) as f : [EOL] write ( f , [number] , HEADER , newline = False ) [EOL] for h1 , dct in credits . items ( ) : [comment] [EOL] write_page ( h1 , dct ) [EOL] write ( f , [number] , FOOTER ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import os [EOL] import platform [EOL] import sys [EOL] [EOL] [EOL] def find_enet_module ( ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] import enet [EOL] return enet [EOL] except ImportError : [EOL] return None [EOL] [EOL] [EOL] enet = find_enet_module ( ) [EOL] [EOL] [comment] [EOL] if not hasattr ( enet , [string] ) and hasattr ( enet , [string] ) : [EOL] enet . PEER_STATE_DISCONNECTED = enet . PEER_STATE_DISCONNECT [EOL] [EOL] [EOL] class NetworkException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class SoftNetworkException ( NetworkException ) : [EOL] pass [EOL] [EOL] [EOL] class PacketTooLarge ( NetworkException ) : [EOL] pass [EOL] [EOL] [EOL] class NotConnected ( NetworkException ) : [EOL] def __str__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class ClientException ( NetworkException ) : [EOL] pass [EOL] [EOL] [EOL] class AlreadyConnected ( ClientException ) : [EOL] pass [EOL] [EOL] [EOL] class NotInGameLobby ( ClientException ) : [EOL] pass [EOL] [EOL] [EOL] class NotInServerMode ( ClientException ) : [EOL] pass [EOL] [EOL] [EOL] class UnableToConnect ( ClientException ) : [EOL] pass [EOL] [EOL] [EOL] class CommandError ( ClientException ) : [EOL] def __init__ ( self , message , cmd_type ) : [EOL] super ( ) . __init__ ( message ) [EOL] self . cmd_type = cmd_type [EOL] [EOL] [EOL] class FatalError ( ClientException ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def is_lazy_string ( obj ) : [EOL] [docstring] [EOL] return isinstance ( obj , _LazyString ) [EOL] [EOL] [EOL] def make_lazy_string ( __func , * args , ** kwargs ) : [EOL] [docstring] [EOL] return _LazyString ( __func , args , kwargs ) [EOL] [EOL] [EOL] def make_lazy_gettext ( lookup_func ) : [EOL] [docstring] [EOL] def lazy_gettext ( string ) : [EOL] if is_lazy_string ( string ) : [EOL] return string [EOL] return make_lazy_string ( lookup_func ( ) , string ) [EOL] return lazy_gettext [EOL] [EOL] [EOL] class _LazyString : [EOL] [docstring] [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , func , args , kwargs ) : [EOL] self . _func = func [EOL] self . _args = args [EOL] self . _kwargs = kwargs [EOL] [EOL] @ property def value ( self ) : [EOL] try : [EOL] return self . _func ( * self . _args , ** self . _kwargs ) [EOL] except AttributeError as e : [EOL] raise RuntimeError ( [string] + str ( e ) ) [EOL] [EOL] def __contains__ ( self , key ) : [EOL] return key in self . value [EOL] [EOL] def __bool__ ( self ) : [EOL] return bool ( self . value ) [EOL] [EOL] def __dir__ ( self ) : [EOL] return dir ( str ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . value ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . value ) [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . value ) [EOL] [EOL] def __unicode__ ( self ) : [EOL] return str ( self . value ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] return self . value + other [EOL] [EOL] def __radd__ ( self , other ) : [EOL] return other + self . value [EOL] [EOL] def __mod__ ( self , other ) : [EOL] return self . value % other [EOL] [EOL] def __rmod__ ( self , other ) : [EOL] return other % self . value [EOL] [EOL] def __mul__ ( self , other ) : [EOL] return self . value * other [EOL] [EOL] def __rmul__ ( self , other ) : [EOL] return other * self . value [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return self . value < other [EOL] [EOL] def __le__ ( self , other ) : [EOL] return self . value <= other [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . value == other [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return self . value != other [EOL] [EOL] def __gt__ ( self , other ) : [EOL] return self . value > other [EOL] [EOL] def __ge__ ( self , other ) : [EOL] return self . value >= other [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . value ) [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] if name == [string] : [EOL] return self . __dir__ ( ) [EOL] return getattr ( self . value , name ) [EOL] [EOL] def __getstate__ ( self ) : [EOL] return self . _func , self . _args , self . _kwargs [EOL] [EOL] def __setstate__ ( self , tup ) : [EOL] self . _func , self . _args , self . _kwargs = tup [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] return self . value [ key ] [EOL] [EOL] def __copy__ ( self ) : [EOL] return self [EOL] [EOL] def __repr__ ( self ) : [EOL] try : [EOL] return [string] + repr ( self . value ) [EOL] except Exception : [EOL] return [string] % self . __class__ . __name__ [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] doctest . testmod ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] __author_name__ = [string] [EOL] __author_email__ = [string] [EOL] __author__ = [string] % vars ( ) [EOL] [EOL] _copyright_year_begin = [string] [EOL] __date__ = [string] [EOL] _copyright_year_latest = __date__ . split ( [string] ) [ [number] ] [EOL] _copyright_year_range = _copyright_year_begin [EOL] if _copyright_year_latest > _copyright_year_begin : [EOL] _copyright_year_range += [string] % vars ( ) [EOL] __copyright__ = ( [string] [string] ) % vars ( ) [EOL] __license__ = [string] [EOL] [EOL] __url__ = [string] [EOL] __version__ = [string] [EOL] [EOL] [EOL] class EnumException ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] if self . __class__ is EnumException : [EOL] class_name = self . __class__ . __name__ [EOL] raise NotImplementedError ( [string] % vars ( ) ) [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] class EnumEmptyError ( AssertionError , EnumException ) : [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class EnumBadKeyError ( TypeError , EnumException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , key ) : [EOL] self . key = key [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % vars ( self ) [EOL] [EOL] [EOL] class EnumImmutableError ( TypeError , EnumException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args ) : [EOL] self . args = args [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] def _comparator ( func ) : [EOL] [docstring] [EOL] def comparator_wrapper ( self , other ) : [EOL] try : [EOL] assert self . enumtype == other . enumtype [EOL] result = func ( self . index , other . index ) [EOL] except ( AssertionError , AttributeError ) : [EOL] result = NotImplemented [EOL] [EOL] return result [EOL] comparator_wrapper . __name__ = func . __name__ [EOL] comparator_wrapper . __doc__ = getattr ( float , func . __name__ ) . __doc__ [EOL] return comparator_wrapper [EOL] [EOL] [EOL] class EnumValue : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , enumtype , index , key ) : [EOL] [docstring] [EOL] self . _enumtype = enumtype [EOL] self . _index = index [EOL] self . _key = key [EOL] [EOL] @ property def enumtype ( self ) : [EOL] return self . _enumtype [EOL] [EOL] @ property def key ( self ) : [EOL] return self . _key [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . key ) [EOL] [EOL] @ property def index ( self ) : [EOL] return self . _index [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % vars ( self ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . _index ) [EOL] [EOL] @ _comparator def __eq__ ( self , other ) : [EOL] return ( self == other ) [EOL] [EOL] @ _comparator def __ne__ ( self , other ) : [EOL] return ( self != other ) [EOL] [EOL] @ _comparator def __lt__ ( self , other ) : [EOL] return ( self < other ) [EOL] [EOL] @ _comparator def __le__ ( self , other ) : [EOL] return ( self <= other ) [EOL] [EOL] @ _comparator def __gt__ ( self , other ) : [EOL] return ( self > other ) [EOL] [EOL] @ _comparator def __ge__ ( self , other ) : [EOL] return ( self >= other ) [EOL] [EOL] [EOL] class Enum : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * keys , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] value_type = kwargs . get ( [string] , EnumValue ) [EOL] [EOL] if not keys : [EOL] raise EnumEmptyError ( ) [EOL] [EOL] keys = tuple ( keys ) [EOL] values = [ None ] * len ( keys ) [EOL] [EOL] for i , key in enumerate ( keys ) : [EOL] value = value_type ( self , i , key ) [EOL] values [ i ] = value [EOL] try : [EOL] super ( ) . __setattr__ ( key , value ) [EOL] except TypeError : [EOL] raise EnumBadKeyError ( key ) [EOL] [EOL] self . __dict__ [ [string] ] = keys [EOL] self . __dict__ [ [string] ] = values [EOL] [EOL] @ classmethod def get_extended ( cls , base_enum , * keys , ** kwargs ) : [EOL] keys = base_enum . _keys + keys [EOL] return cls ( * keys , ** kwargs ) [EOL] [EOL] def __setattr__ ( self , name , value ) : [EOL] raise EnumImmutableError ( name ) [EOL] [EOL] def __delattr__ ( self , name ) : [EOL] raise EnumImmutableError ( name ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _values ) [EOL] [EOL] def __getitem__ ( self , index ) : [EOL] return self . _values [ index ] [EOL] [EOL] def __setitem__ ( self , index , value ) : [EOL] raise EnumImmutableError ( index ) [EOL] [EOL] def __delitem__ ( self , index ) : [EOL] raise EnumImmutableError ( index ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . _values ) [EOL] [EOL] def __contains__ ( self , value ) : [EOL] is_member = False [EOL] if isinstance ( value , str ) : [EOL] is_member = ( value in self . _keys ) [EOL] else : [EOL] is_member = ( value in self . _values ) [EOL] return is_member [EOL] [EOL] def get_item_for_string ( self , key ) : [EOL] [docstring] [EOL] try : [EOL] index = self . _keys . index ( key ) [EOL] except ValueError : [EOL] raise KeyError [comment] [EOL] return self [ index ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import IO , Pattern , Tuple , Type , Dict , Optional , List , Set , Any , Match [EOL] import typing [EOL] import horizons [EOL] [docstring] [EOL] [EOL] import array [EOL] import codecs [EOL] import os [EOL] import re [EOL] import struct [EOL] import sys [EOL] import textwrap [EOL] [EOL] try : [EOL] import io [EOL] except ImportError : [EOL] [comment] [EOL] [comment] [EOL] class io ( object ) : [EOL] @ staticmethod def open ( fpath , mode = [string] , encoding = None ) : [EOL] return codecs . open ( fpath , mode , encoding ) [EOL] [EOL] [EOL] __author__ = [string] [EOL] __version__ = [string] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] [comment] [EOL] default_encoding = [string] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] if sys . version_info [ : [number] ] < ( [number] , [number] ) : [EOL] PY3 = False [EOL] text_type = unicode [EOL] [EOL] def b ( s ) : [EOL] return s [EOL] [EOL] def u ( s ) : [EOL] return unicode ( s , [string] ) [EOL] [EOL] else : [EOL] PY3 = True [EOL] text_type = str [EOL] [EOL] def b ( s ) : [EOL] return s . encode ( [string] ) [EOL] [EOL] def u ( s ) : [EOL] return s [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def _pofile_or_mofile ( f , type , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] enc = kwargs . get ( [string] ) [EOL] if enc is None : [EOL] enc = detect_encoding ( f , type == [string] ) [EOL] [EOL] [comment] [EOL] kls = type == [string] and _POFileParser or _MOFileParser [EOL] parser = kls ( f , encoding = enc , check_for_duplicates = kwargs . get ( [string] , False ) , klass = kwargs . get ( [string] ) ) [EOL] instance = parser . parse ( ) [EOL] instance . wrapwidth = kwargs . get ( [string] , [number] ) [EOL] return instance [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def _is_file ( filename_or_contents ) : [EOL] [docstring] [EOL] try : [EOL] return os . path . exists ( filename_or_contents ) [EOL] except ( ValueError , UnicodeEncodeError ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def pofile ( pofile , ** kwargs ) : [EOL] [docstring] [EOL] return _pofile_or_mofile ( pofile , [string] , ** kwargs ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def mofile ( mofile , ** kwargs ) : [EOL] [docstring] [EOL] return _pofile_or_mofile ( mofile , [string] , ** kwargs ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def detect_encoding ( file , binary_mode = False ) : [EOL] [docstring] [EOL] PATTERN = [string] [EOL] rxt = re . compile ( u ( PATTERN ) ) [EOL] rxb = re . compile ( b ( PATTERN ) ) [EOL] [EOL] def charset_exists ( charset ) : [EOL] [docstring] [EOL] try : [EOL] codecs . lookup ( charset ) [EOL] except LookupError : [EOL] return False [EOL] return True [EOL] [EOL] if not _is_file ( file ) : [EOL] match = rxt . search ( file ) [EOL] if match : [EOL] enc = match . group ( [number] ) . strip ( ) [EOL] if charset_exists ( enc ) : [EOL] return enc [EOL] else : [EOL] [comment] [EOL] if binary_mode or PY3 : [EOL] mode = [string] [EOL] rx = rxb [EOL] else : [EOL] mode = [string] [EOL] rx = rxt [EOL] f = open ( file , mode ) [EOL] for l in f . readlines ( ) : [EOL] match = rx . search ( l ) [EOL] if match : [EOL] f . close ( ) [EOL] enc = match . group ( [number] ) . strip ( ) [EOL] if not isinstance ( enc , text_type ) : [EOL] enc = enc . decode ( [string] ) [EOL] if charset_exists ( enc ) : [EOL] return enc [EOL] f . close ( ) [EOL] return default_encoding [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def escape ( st ) : [EOL] [docstring] [EOL] return st . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def unescape ( st ) : [EOL] [docstring] [EOL] def unescape_repl ( m ) : [EOL] m = m . group ( [number] ) [EOL] if m == [string] : [EOL] return [string] [EOL] if m == [string] : [EOL] return [string] [EOL] if m == [string] : [EOL] return [string] [EOL] if m == [string] : [EOL] return [string] [EOL] return m [comment] [EOL] return re . sub ( [string] , unescape_repl , st ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def natural_sort ( lst ) : [EOL] [docstring] [EOL] def convert ( text ) : [EOL] return int ( text ) if text . isdigit ( ) else text . lower ( ) [EOL] [EOL] def alphanum_key ( key ) : [EOL] return [ convert ( c ) for c in re . split ( [string] , key ) ] [EOL] [EOL] return sorted ( lst , key = alphanum_key ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class _BaseFile ( list ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] list . __init__ ( self ) [EOL] [comment] [EOL] pofile = kwargs . get ( [string] , None ) [EOL] if pofile and _is_file ( pofile ) : [EOL] self . fpath = pofile [EOL] else : [EOL] self . fpath = kwargs . get ( [string] ) [EOL] [comment] [EOL] self . wrapwidth = kwargs . get ( [string] , [number] ) [EOL] [comment] [EOL] self . encoding = kwargs . get ( [string] , default_encoding ) [EOL] [comment] [EOL] self . check_for_duplicates = kwargs . get ( [string] , False ) [EOL] [comment] [EOL] self . header = [string] [EOL] [comment] [EOL] self . metadata = { } [EOL] self . metadata_is_fuzzy = [number] [EOL] [EOL] def __unicode__ ( self ) : [EOL] [docstring] [EOL] ret = [ ] [EOL] entries = [ self . metadata_as_entry ( ) ] + [ e for e in self if not e . obsolete ] [EOL] for entry in entries : [EOL] ret . append ( entry . __unicode__ ( self . wrapwidth ) ) [EOL] for entry in self . obsolete_entries ( ) : [EOL] ret . append ( entry . __unicode__ ( self . wrapwidth ) ) [EOL] ret = u ( [string] ) . join ( ret ) [EOL] return ret [EOL] [EOL] if PY3 : [EOL] def __str__ ( self ) : [EOL] return self . __unicode__ ( ) [EOL] else : [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return unicode ( self ) . encode ( self . encoding ) [EOL] [EOL] def __contains__ ( self , entry ) : [EOL] [docstring] [EOL] return self . find ( entry . msgid , by = [string] , msgctxt = entry . msgctxt ) is not None [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return str ( self ) == str ( other ) [EOL] [EOL] def append ( self , entry ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if getattr ( self , [string] , False ) and entry in self : [EOL] raise ValueError ( [string] % entry . msgid ) [EOL] super ( _BaseFile , self ) . append ( entry ) [EOL] [EOL] def insert ( self , index , entry ) : [EOL] [docstring] [EOL] if self . check_for_duplicates and entry in self : [EOL] raise ValueError ( [string] % entry . msgid ) [EOL] super ( _BaseFile , self ) . insert ( index , entry ) [EOL] [EOL] def metadata_as_entry ( self ) : [EOL] [docstring] [EOL] e = POEntry ( msgid = [string] ) [EOL] mdata = self . ordered_metadata ( ) [EOL] if mdata : [EOL] strs = [ ] [EOL] for name , value in mdata : [EOL] [comment] [EOL] strs . append ( [string] % ( name , value ) ) [EOL] e . msgstr = [string] . join ( strs ) + [string] [EOL] if self . metadata_is_fuzzy : [EOL] e . flags . append ( [string] ) [EOL] return e [EOL] [EOL] def save ( self , fpath = None , repr_method = [string] ) : [EOL] [docstring] [EOL] if self . fpath is None and fpath is None : [EOL] raise IOError ( [string] ) [EOL] contents = getattr ( self , repr_method ) ( ) [EOL] if fpath is None : [EOL] fpath = self . fpath [EOL] if repr_method == [string] : [EOL] fhandle = open ( fpath , [string] ) [EOL] else : [EOL] fhandle = io . open ( fpath , [string] , encoding = self . encoding ) [EOL] if not isinstance ( contents , text_type ) : [EOL] contents = contents . decode ( self . encoding ) [EOL] fhandle . write ( contents ) [EOL] fhandle . close ( ) [EOL] [comment] [EOL] if self . fpath is None and fpath : [EOL] self . fpath = fpath [EOL] [EOL] def find ( self , st , by = [string] , include_obsolete_entries = False , msgctxt = False ) : [EOL] [docstring] [EOL] if include_obsolete_entries : [EOL] entries = self [ : ] [EOL] else : [EOL] entries = [ e for e in self if not e . obsolete ] [EOL] matches = [ ] [EOL] for e in entries : [EOL] if getattr ( e , by ) == st : [EOL] if msgctxt is not False and e . msgctxt != msgctxt : [EOL] continue [EOL] matches . append ( e ) [EOL] if len ( matches ) == [number] : [EOL] return matches [ [number] ] [EOL] elif len ( matches ) > [number] : [EOL] if not msgctxt : [EOL] [comment] [EOL] e = None [EOL] for m in matches : [EOL] if not m . msgctxt : [EOL] e = m [EOL] if e : [EOL] return e [EOL] [comment] [EOL] return matches [ [number] ] [EOL] return None [EOL] [EOL] def ordered_metadata ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] metadata = self . metadata . copy ( ) [EOL] data_order = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] ordered_data = [ ] [EOL] for data in data_order : [EOL] try : [EOL] value = metadata . pop ( data ) [EOL] ordered_data . append ( ( data , value ) ) [EOL] except KeyError : [EOL] pass [EOL] [comment] [EOL] [comment] [EOL] for data in natural_sort ( metadata . keys ( ) ) : [EOL] value = metadata [ data ] [EOL] ordered_data . append ( ( data , value ) ) [EOL] return ordered_data [EOL] [EOL] def to_binary ( self ) : [EOL] [docstring] [EOL] offsets = [ ] [EOL] entries = self . translated_entries ( ) [EOL] [EOL] [comment] [EOL] def cmp ( _self , other ) : [EOL] [comment] [EOL] self_msgid = _self . msgctxt and _self . msgctxt or _self . msgid [EOL] other_msgid = other . msgctxt and other . msgctxt or other . msgid [EOL] if self_msgid > other_msgid : [EOL] return [number] [EOL] elif self_msgid < other_msgid : [EOL] return - [number] [EOL] else : [EOL] return [number] [EOL] [comment] [EOL] entries . sort ( key = lambda o : o . msgid_with_context . encode ( [string] ) ) [EOL] mentry = self . metadata_as_entry ( ) [EOL] entries = [ mentry ] + entries [EOL] entries_len = len ( entries ) [EOL] ids , strs = b ( [string] ) , b ( [string] ) [EOL] for e in entries : [EOL] [comment] [EOL] [comment] [EOL] msgid = b ( [string] ) [EOL] if e . msgctxt : [EOL] [comment] [EOL] [comment] [EOL] msgid = self . _encode ( e . msgctxt + [string] ) [EOL] if e . msgid_plural : [EOL] msgstr = [ ] [EOL] for index in sorted ( e . msgstr_plural . keys ( ) ) : [EOL] msgstr . append ( e . msgstr_plural [ index ] ) [EOL] msgid += self . _encode ( e . msgid + [string] + e . msgid_plural ) [EOL] msgstr = self . _encode ( [string] . join ( msgstr ) ) [EOL] else : [EOL] msgid += self . _encode ( e . msgid ) [EOL] msgstr = self . _encode ( e . msgstr ) [EOL] offsets . append ( ( len ( ids ) , len ( msgid ) , len ( strs ) , len ( msgstr ) ) ) [EOL] ids += msgid + b ( [string] ) [EOL] strs += msgstr + b ( [string] ) [EOL] [EOL] [comment] [EOL] keystart = [number] * [number] + [number] * entries_len [EOL] [comment] [EOL] valuestart = keystart + len ( ids ) [EOL] koffsets = [ ] [EOL] voffsets = [ ] [EOL] [comment] [EOL] [comment] [EOL] for o1 , l1 , o2 , l2 in offsets : [EOL] koffsets += [ l1 , o1 + keystart ] [EOL] voffsets += [ l2 , o2 + valuestart ] [EOL] offsets = koffsets + voffsets [EOL] [EOL] output = struct . pack ( [string] , MOFile . MAGIC , [number] , entries_len , [number] * [number] , [number] * [number] + entries_len * [number] , [number] , keystart ) [EOL] if PY3 and sys . version_info . minor > [number] : [comment] [EOL] output += array . array ( [string] , offsets ) . tobytes ( ) [EOL] else : [EOL] output += array . array ( [string] , offsets ) . tostring ( ) [EOL] output += ids [EOL] output += strs [EOL] return output [EOL] [EOL] def _encode ( self , mixed ) : [EOL] [docstring] [EOL] if isinstance ( mixed , text_type ) : [EOL] mixed = mixed . encode ( self . encoding ) [EOL] return mixed [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class POFile ( _BaseFile ) : [EOL] [docstring] [EOL] [EOL] def __unicode__ ( self ) : [EOL] [docstring] [EOL] ret , headers = [string] , self . header . split ( [string] ) [EOL] for header in headers : [EOL] if not len ( header ) : [EOL] ret += [string] [EOL] elif header [ : [number] ] in [ [string] , [string] ] : [EOL] ret += [string] % header [EOL] else : [EOL] ret += [string] % header [EOL] [EOL] if not isinstance ( ret , text_type ) : [EOL] ret = ret . decode ( self . encoding ) [EOL] [EOL] return ret + _BaseFile . __unicode__ ( self ) [EOL] [EOL] def save_as_mofile ( self , fpath ) : [EOL] [docstring] [EOL] _BaseFile . save ( self , fpath , [string] ) [EOL] [EOL] def percent_translated ( self ) : [EOL] [docstring] [EOL] total = len ( [ e for e in self if not e . obsolete ] ) [EOL] if total == [number] : [EOL] return [number] [EOL] translated = len ( self . translated_entries ( ) ) [EOL] return int ( translated * [number] / float ( total ) ) [EOL] [EOL] def translated_entries ( self ) : [EOL] [docstring] [EOL] return [ e for e in self if e . translated ( ) ] [EOL] [EOL] def untranslated_entries ( self ) : [EOL] [docstring] [EOL] return [ e for e in self if not e . translated ( ) and not e . obsolete and not e . fuzzy ] [EOL] [EOL] def fuzzy_entries ( self ) : [EOL] [docstring] [EOL] return [ e for e in self if e . fuzzy ] [EOL] [EOL] def obsolete_entries ( self ) : [EOL] [docstring] [EOL] return [ e for e in self if e . obsolete ] [EOL] [EOL] def merge ( self , refpot ) : [EOL] [docstring] [EOL] [comment] [EOL] self_entries = dict ( ( entry . msgid_with_context , entry ) for entry in self ) [EOL] refpot_msgids = set ( entry . msgid_with_context for entry in refpot ) [EOL] [comment] [EOL] for entry in refpot : [EOL] e = self_entries . get ( entry . msgid_with_context ) [EOL] if e is None : [EOL] e = POEntry ( ) [EOL] self . append ( e ) [EOL] e . merge ( entry ) [EOL] [comment] [EOL] for entry in self : [EOL] if entry . msgid_with_context not in refpot_msgids : [EOL] entry . obsolete = True [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class MOFile ( _BaseFile ) : [EOL] [docstring] [EOL] MAGIC = [number] [EOL] MAGIC_SWAPPED = [number] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] _BaseFile . __init__ ( self , * args , ** kwargs ) [EOL] self . magic_number = None [EOL] self . version = [number] [EOL] [EOL] def save_as_pofile ( self , fpath ) : [EOL] [docstring] [EOL] _BaseFile . save ( self , fpath ) [EOL] [EOL] def save ( self , fpath = None ) : [EOL] [docstring] [EOL] _BaseFile . save ( self , fpath , [string] ) [EOL] [EOL] def percent_translated ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] def translated_entries ( self ) : [EOL] [docstring] [EOL] return self [EOL] [EOL] def untranslated_entries ( self ) : [EOL] [docstring] [EOL] return [ ] [EOL] [EOL] def fuzzy_entries ( self ) : [EOL] [docstring] [EOL] return [ ] [EOL] [EOL] def obsolete_entries ( self ) : [EOL] [docstring] [EOL] return [ ] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class _BaseEntry ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . msgid = kwargs . get ( [string] , [string] ) [EOL] self . msgstr = kwargs . get ( [string] , [string] ) [EOL] self . msgid_plural = kwargs . get ( [string] , [string] ) [EOL] self . msgstr_plural = kwargs . get ( [string] , { } ) [EOL] self . msgctxt = kwargs . get ( [string] , None ) [EOL] self . obsolete = kwargs . get ( [string] , False ) [EOL] self . encoding = kwargs . get ( [string] , default_encoding ) [EOL] [EOL] def __unicode__ ( self , wrapwidth = [number] ) : [EOL] [docstring] [EOL] if self . obsolete : [EOL] delflag = [string] [EOL] else : [EOL] delflag = [string] [EOL] ret = [ ] [EOL] [comment] [EOL] if self . msgctxt is not None : [EOL] ret += self . _str_field ( [string] , delflag , [string] , self . msgctxt , wrapwidth ) [EOL] [comment] [EOL] ret += self . _str_field ( [string] , delflag , [string] , self . msgid , wrapwidth ) [EOL] [comment] [EOL] if self . msgid_plural : [EOL] ret += self . _str_field ( [string] , delflag , [string] , self . msgid_plural , wrapwidth ) [EOL] if self . msgstr_plural : [EOL] [comment] [EOL] msgstrs = self . msgstr_plural [EOL] keys = list ( msgstrs ) [EOL] keys . sort ( ) [EOL] for index in keys : [EOL] msgstr = msgstrs [ index ] [EOL] plural_index = [string] % index [EOL] ret += self . _str_field ( [string] , delflag , plural_index , msgstr , wrapwidth ) [EOL] else : [EOL] [comment] [EOL] ret += self . _str_field ( [string] , delflag , [string] , self . msgstr , wrapwidth ) [EOL] ret . append ( [string] ) [EOL] ret = u ( [string] ) . join ( ret ) [EOL] return ret [EOL] [EOL] if PY3 : [EOL] def __str__ ( self ) : [EOL] return self . __unicode__ ( ) [EOL] else : [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return unicode ( self ) . encode ( self . encoding ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return str ( self ) == str ( other ) [EOL] [EOL] def _str_field ( self , fieldname , delflag , plural_index , field , wrapwidth = [number] ) : [EOL] lines = field . splitlines ( True ) [EOL] if len ( lines ) > [number] : [EOL] lines = [ [string] ] + lines [comment] [EOL] else : [EOL] escaped_field = escape ( field ) [EOL] specialchars_count = [number] [EOL] for c in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] specialchars_count += field . count ( c ) [EOL] [comment] [EOL] [comment] [EOL] flength = len ( fieldname ) + [number] [EOL] if plural_index : [EOL] flength += len ( plural_index ) [EOL] real_wrapwidth = wrapwidth - flength + specialchars_count [EOL] if wrapwidth > [number] and len ( field ) > real_wrapwidth : [EOL] [comment] [EOL] lines = [ [string] ] + [ unescape ( item ) for item in wrap ( escaped_field , wrapwidth - [number] , drop_whitespace = False , break_long_words = False ) ] [EOL] else : [EOL] lines = [ field ] [EOL] if fieldname . startswith ( [string] ) : [EOL] [comment] [EOL] fieldname = fieldname [ [number] : ] [EOL] [EOL] ret = [ [string] % ( delflag , fieldname , plural_index , escape ( lines . pop ( [number] ) ) ) ] [EOL] for line in lines : [EOL] ret . append ( [string] % ( delflag , escape ( line ) ) ) [EOL] return ret [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class POEntry ( _BaseEntry ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] _BaseEntry . __init__ ( self , * args , ** kwargs ) [EOL] self . comment = kwargs . get ( [string] , [string] ) [EOL] self . tcomment = kwargs . get ( [string] , [string] ) [EOL] self . occurrences = kwargs . get ( [string] , [ ] ) [EOL] self . flags = kwargs . get ( [string] , [ ] ) [EOL] self . previous_msgctxt = kwargs . get ( [string] , None ) [EOL] self . previous_msgid = kwargs . get ( [string] , None ) [EOL] self . previous_msgid_plural = kwargs . get ( [string] , None ) [EOL] self . linenum = kwargs . get ( [string] , None ) [EOL] [EOL] def __unicode__ ( self , wrapwidth = [number] ) : [EOL] [docstring] [EOL] ret = [ ] [EOL] [comment] [EOL] if self . obsolete : [EOL] comments = [ ( [string] , [string] ) ] [EOL] else : [EOL] comments = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] for c in comments : [EOL] val = getattr ( self , c [ [number] ] ) [EOL] if val : [EOL] for comment in val . split ( [string] ) : [EOL] if wrapwidth > [number] and len ( comment ) + len ( c [ [number] ] ) > wrapwidth : [EOL] ret += wrap ( comment , wrapwidth , initial_indent = c [ [number] ] , subsequent_indent = c [ [number] ] , break_long_words = False ) [EOL] else : [EOL] ret . append ( [string] % ( c [ [number] ] , comment ) ) [EOL] [EOL] [comment] [EOL] if not self . obsolete and self . occurrences : [EOL] filelist = [ ] [EOL] for fpath , lineno in self . occurrences : [EOL] if lineno : [EOL] filelist . append ( [string] % ( fpath , lineno ) ) [EOL] else : [EOL] filelist . append ( fpath ) [EOL] filestr = [string] . join ( filelist ) [EOL] if wrapwidth > [number] and len ( filestr ) + [number] > wrapwidth : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ret += [ l . replace ( [string] , [string] ) for l in wrap ( filestr . replace ( [string] , [string] ) , wrapwidth , initial_indent = [string] , subsequent_indent = [string] , break_long_words = False ) ] [EOL] else : [EOL] ret . append ( [string] + filestr ) [EOL] [EOL] [comment] [EOL] if self . flags : [EOL] ret . append ( [string] % [string] . join ( self . flags ) ) [EOL] [EOL] [comment] [EOL] fields = [ [string] , [string] , [string] ] [EOL] if self . obsolete : [EOL] prefix = [string] [EOL] else : [EOL] prefix = [string] [EOL] for f in fields : [EOL] val = getattr ( self , f ) [EOL] if val : [EOL] ret += self . _str_field ( f , prefix , [string] , val , wrapwidth ) [EOL] [EOL] ret . append ( _BaseEntry . __unicode__ ( self , wrapwidth ) ) [EOL] ret = u ( [string] ) . join ( ret ) [EOL] return ret [EOL] [EOL] def __cmp__ ( self , other ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . obsolete != other . obsolete : [EOL] if self . obsolete : [EOL] return - [number] [EOL] else : [EOL] return [number] [EOL] [comment] [EOL] occ1 = sorted ( self . occurrences [ : ] ) [EOL] occ2 = sorted ( other . occurrences [ : ] ) [EOL] pos = [number] [EOL] if occ1 > occ2 : [EOL] return [number] [EOL] if occ1 < occ2 : [EOL] return - [number] [EOL] [comment] [EOL] msgctxt = self . msgctxt or [string] [EOL] othermsgctxt = other . msgctxt or [string] [EOL] if msgctxt > othermsgctxt : [EOL] return [number] [EOL] elif msgctxt < othermsgctxt : [EOL] return - [number] [EOL] [comment] [EOL] msgid_plural = self . msgid_plural or [string] [EOL] othermsgid_plural = other . msgid_plural or [string] [EOL] if msgid_plural > othermsgid_plural : [EOL] return [number] [EOL] elif msgid_plural < othermsgid_plural : [EOL] return - [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] msgstr_plural = self . msgstr_plural or { } [EOL] othermsgstr_plural = other . msgstr_plural or { } [EOL] if len ( msgstr_plural ) > len ( othermsgstr_plural ) : [EOL] return [number] [EOL] elif len ( msgstr_plural ) < len ( othermsgstr_plural ) : [EOL] return - [number] [EOL] for idx in msgstr_plural : [EOL] if msgstr_plural [ idx ] > othermsgstr_plural [ idx ] : [EOL] return [number] [EOL] elif msgstr_plural [ idx ] < othermsgstr_plural [ idx ] : [EOL] return - [number] [EOL] [comment] [EOL] if self . msgid > other . msgid : [EOL] return [number] [EOL] elif self . msgid < other . msgid : [EOL] return - [number] [EOL] return [number] [EOL] [comment] [EOL] if self . msgstr > other . msgstr : [EOL] return [number] [EOL] elif self . msgstr < other . msgstr : [EOL] return - [number] [EOL] return [number] [EOL] [EOL] def __gt__ ( self , other ) : [EOL] return self . __cmp__ ( other ) > [number] [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return self . __cmp__ ( other ) < [number] [EOL] [EOL] def __ge__ ( self , other ) : [EOL] return self . __cmp__ ( other ) >= [number] [EOL] [EOL] def __le__ ( self , other ) : [EOL] return self . __cmp__ ( other ) <= [number] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . __cmp__ ( other ) == [number] [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return self . __cmp__ ( other ) != [number] [EOL] [EOL] def translated ( self ) : [EOL] [docstring] [EOL] if self . obsolete or self . fuzzy : [EOL] return False [EOL] if self . msgstr != [string] : [EOL] return True [EOL] if self . msgstr_plural : [EOL] for pos in self . msgstr_plural : [EOL] if self . msgstr_plural [ pos ] == [string] : [EOL] return False [EOL] return True [EOL] return False [EOL] [EOL] def merge ( self , other ) : [EOL] [docstring] [EOL] self . msgid = other . msgid [EOL] self . msgctxt = other . msgctxt [EOL] self . occurrences = other . occurrences [EOL] self . comment = other . comment [EOL] fuzzy = self . fuzzy [EOL] self . flags = other . flags [ : ] [comment] [EOL] if fuzzy : [EOL] self . flags . append ( [string] ) [EOL] self . msgid_plural = other . msgid_plural [EOL] self . obsolete = other . obsolete [EOL] self . previous_msgctxt = other . previous_msgctxt [EOL] self . previous_msgid = other . previous_msgid [EOL] self . previous_msgid_plural = other . previous_msgid_plural [EOL] if other . msgstr_plural : [EOL] for pos in other . msgstr_plural : [EOL] try : [EOL] [comment] [EOL] self . msgstr_plural [ pos ] [EOL] except KeyError : [EOL] self . msgstr_plural [ pos ] = [string] [EOL] [EOL] @ property def fuzzy ( self ) : [EOL] return [string] in self . flags [EOL] [EOL] @ property def msgid_with_context ( self ) : [EOL] if self . msgctxt : [EOL] return [string] % ( self . msgctxt , [string] , self . msgid ) [EOL] return self . msgid [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . msgid , self . msgstr ) ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class MOEntry ( _BaseEntry ) : [EOL] [docstring] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] _BaseEntry . __init__ ( self , * args , ** kwargs ) [EOL] self . comment = [string] [EOL] self . tcomment = [string] [EOL] self . occurrences = [ ] [EOL] self . flags = [ ] [EOL] self . previous_msgctxt = None [EOL] self . previous_msgid = None [EOL] self . previous_msgid_plural = None [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . msgid , self . msgstr ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class _POFileParser ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , pofile , * args , ** kwargs ) : [EOL] [docstring] [EOL] enc = kwargs . get ( [string] , default_encoding ) [EOL] if _is_file ( pofile ) : [EOL] try : [EOL] self . fhandle = io . open ( pofile , [string] , encoding = enc ) [EOL] except LookupError : [EOL] enc = default_encoding [EOL] self . fhandle = io . open ( pofile , [string] , encoding = enc ) [EOL] else : [EOL] self . fhandle = pofile . splitlines ( ) [EOL] [EOL] klass = kwargs . get ( [string] ) [EOL] if klass is None : [EOL] klass = POFile [EOL] self . instance = klass ( pofile = pofile , encoding = enc , check_for_duplicates = kwargs . get ( [string] , False ) ) [EOL] self . transitions = { } [EOL] self . current_line = [number] [EOL] self . current_entry = POEntry ( linenum = self . current_line ) [EOL] self . current_state = [string] [EOL] self . current_token = None [EOL] [comment] [EOL] self . msgstr_index = [number] [EOL] self . entry_obsolete = [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] all = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] self . add ( [string] , [ [string] , [string] ] , [string] ) [EOL] self . add ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , [string] ) [EOL] self . add ( [string] , all , [string] ) [EOL] self . add ( [string] , all , [string] ) [EOL] self . add ( [string] , all , [string] ) [EOL] self . add ( [string] , all , [string] ) [EOL] self . add ( [string] , all , [string] ) [EOL] self . add ( [string] , all , [string] ) [EOL] self . add ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , [string] ) [EOL] self . add ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , [string] ) [EOL] self . add ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] ] , [string] ) [EOL] self . add ( [string] , [ [string] , [string] , [string] ] , [string] ) [EOL] self . add ( [string] , [ [string] , [string] , [string] , [string] ] , [string] ) [EOL] self . add ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , [string] ) [EOL] [EOL] def parse ( self ) : [EOL] [docstring] [EOL] [EOL] keywords = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] prev_keywords = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] tokens = [ ] [EOL] fpath = [string] % self . instance . fpath if self . instance . fpath else [string] [EOL] for line in self . fhandle : [EOL] self . current_line += [number] [EOL] line = line . strip ( ) [EOL] if line == [string] : [EOL] continue [EOL] [EOL] tokens = line . split ( None , [number] ) [EOL] nb_tokens = len ( tokens ) [EOL] [EOL] if tokens [ [number] ] == [string] : [EOL] continue [EOL] [EOL] if tokens [ [number] ] == [string] and nb_tokens > [number] : [EOL] line = line [ [number] : ] . strip ( ) [EOL] tokens = tokens [ [number] : ] [EOL] nb_tokens -= [number] [EOL] self . entry_obsolete = [number] [EOL] else : [EOL] self . entry_obsolete = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if tokens [ [number] ] in keywords and nb_tokens > [number] : [EOL] line = line [ len ( tokens [ [number] ] ) : ] . lstrip ( ) [EOL] if re . search ( [string] , line [ [number] : - [number] ] ) : [EOL] raise IOError ( [string] [string] % ( fpath , self . current_line ) ) [EOL] self . current_token = line [EOL] self . process ( keywords [ tokens [ [number] ] ] ) [EOL] continue [EOL] [EOL] self . current_token = line [EOL] [EOL] if tokens [ [number] ] == [string] : [EOL] if nb_tokens <= [number] : [EOL] continue [EOL] [comment] [EOL] self . process ( [string] ) [EOL] [EOL] elif line [ : [number] ] == [string] : [EOL] [comment] [EOL] if re . search ( [string] , line [ [number] : - [number] ] ) : [EOL] raise IOError ( [string] [string] % ( fpath , self . current_line ) ) [EOL] self . process ( [string] ) [EOL] [EOL] elif line [ : [number] ] == [string] : [EOL] [comment] [EOL] self . process ( [string] ) [EOL] [EOL] elif tokens [ [number] ] == [string] : [EOL] if nb_tokens <= [number] : [EOL] continue [EOL] [comment] [EOL] self . process ( [string] ) [EOL] [EOL] elif tokens [ [number] ] == [string] or tokens [ [number] ] . startswith ( [string] ) : [EOL] if line == [string] : [EOL] line += [string] [EOL] [comment] [EOL] self . process ( [string] ) [EOL] [EOL] elif tokens [ [number] ] == [string] : [EOL] if nb_tokens <= [number] : [EOL] continue [EOL] [comment] [EOL] self . process ( [string] ) [EOL] [EOL] elif tokens [ [number] ] == [string] : [EOL] if nb_tokens <= [number] : [EOL] raise IOError ( [string] % ( fpath , self . current_line ) ) [EOL] [EOL] [comment] [EOL] line = line [ [number] : ] . lstrip ( ) [EOL] self . current_token = line [EOL] [EOL] if tokens [ [number] ] . startswith ( [string] ) : [EOL] [comment] [EOL] self . process ( [string] ) [EOL] continue [EOL] [EOL] if nb_tokens == [number] : [EOL] [comment] [EOL] raise IOError ( [string] [string] % ( fpath , self . current_line ) ) [EOL] [EOL] [comment] [EOL] if tokens [ [number] ] not in prev_keywords : [EOL] [comment] [EOL] raise IOError ( [string] [string] % ( fpath , self . current_line , tokens [ [number] ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] line = line [ len ( tokens [ [number] ] ) : ] . lstrip ( ) [EOL] self . current_token = line [EOL] self . process ( prev_keywords [ tokens [ [number] ] ] ) [EOL] [EOL] else : [EOL] raise IOError ( [string] % ( fpath , self . current_line ) ) [EOL] [EOL] if self . current_entry and len ( tokens ) > [number] and not tokens [ [number] ] . startswith ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . instance . append ( self . current_entry ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] metadataentry = self . instance . find ( [string] ) [EOL] if metadataentry : [comment] [EOL] [comment] [EOL] self . instance . remove ( metadataentry ) [EOL] self . instance . metadata_is_fuzzy = metadataentry . flags [EOL] key = None [EOL] for msg in metadataentry . msgstr . splitlines ( ) : [EOL] try : [EOL] key , val = msg . split ( [string] , [number] ) [EOL] self . instance . metadata [ key ] = val . strip ( ) [EOL] except ( ValueError , KeyError ) : [EOL] if key is not None : [EOL] self . instance . metadata [ key ] += [string] + msg . strip ( ) [EOL] [comment] [EOL] if not isinstance ( self . fhandle , list ) : [comment] [EOL] self . fhandle . close ( ) [EOL] return self . instance [EOL] [EOL] def add ( self , symbol , states , next_state ) : [EOL] [docstring] [EOL] for state in states : [EOL] action = getattr ( self , [string] % next_state ) [EOL] self . transitions [ ( symbol , state ) ] = ( action , next_state ) [EOL] [EOL] def process ( self , symbol ) : [EOL] [docstring] [EOL] try : [EOL] ( action , state ) = self . transitions [ ( symbol , self . current_state ) ] [EOL] if action ( ) : [EOL] self . current_state = state [EOL] except Exception : [EOL] raise IOError ( [string] % self . current_line ) [EOL] [EOL] [comment] [EOL] [EOL] def handle_he ( self ) : [EOL] [docstring] [EOL] if self . instance . header != [string] : [EOL] self . instance . header += [string] [EOL] self . instance . header += self . current_token [ [number] : ] [EOL] return [number] [EOL] [EOL] def handle_tc ( self ) : [EOL] [docstring] [EOL] if self . current_state in [ [string] , [string] , [string] ] : [EOL] self . instance . append ( self . current_entry ) [EOL] self . current_entry = POEntry ( linenum = self . current_line ) [EOL] if self . current_entry . tcomment != [string] : [EOL] self . current_entry . tcomment += [string] [EOL] tcomment = self . current_token . lstrip ( [string] ) [EOL] if tcomment . startswith ( [string] ) : [EOL] tcomment = tcomment [ [number] : ] [EOL] self . current_entry . tcomment += tcomment [EOL] return True [EOL] [EOL] def handle_gc ( self ) : [EOL] [docstring] [EOL] if self . current_state in [ [string] , [string] , [string] ] : [EOL] self . instance . append ( self . current_entry ) [EOL] self . current_entry = POEntry ( linenum = self . current_line ) [EOL] if self . current_entry . comment != [string] : [EOL] self . current_entry . comment += [string] [EOL] self . current_entry . comment += self . current_token [ [number] : ] [EOL] return True [EOL] [EOL] def handle_oc ( self ) : [EOL] [docstring] [EOL] if self . current_state in [ [string] , [string] , [string] ] : [EOL] self . instance . append ( self . current_entry ) [EOL] self . current_entry = POEntry ( linenum = self . current_line ) [EOL] occurrences = self . current_token [ [number] : ] . split ( ) [EOL] for occurrence in occurrences : [EOL] if occurrence != [string] : [EOL] try : [EOL] fil , line = occurrence . rsplit ( [string] , [number] ) [EOL] if not line . isdigit ( ) : [EOL] fil = occurrence [EOL] line = [string] [EOL] self . current_entry . occurrences . append ( ( fil , line ) ) [EOL] except ( ValueError , AttributeError ) : [EOL] self . current_entry . occurrences . append ( ( occurrence , [string] ) ) [EOL] return True [EOL] [EOL] def handle_fl ( self ) : [EOL] [docstring] [EOL] if self . current_state in [ [string] , [string] , [string] ] : [EOL] self . instance . append ( self . current_entry ) [EOL] self . current_entry = POEntry ( linenum = self . current_line ) [EOL] self . current_entry . flags += [ c . strip ( ) for c in self . current_token [ [number] : ] . split ( [string] ) ] [EOL] return True [EOL] [EOL] def handle_pp ( self ) : [EOL] [docstring] [EOL] if self . current_state in [ [string] , [string] , [string] ] : [EOL] self . instance . append ( self . current_entry ) [EOL] self . current_entry = POEntry ( linenum = self . current_line ) [EOL] self . current_entry . previous_msgid_plural = unescape ( self . current_token [ [number] : - [number] ] ) [EOL] return True [EOL] [EOL] def handle_pm ( self ) : [EOL] [docstring] [EOL] if self . current_state in [ [string] , [string] , [string] ] : [EOL] self . instance . append ( self . current_entry ) [EOL] self . current_entry = POEntry ( linenum = self . current_line ) [EOL] self . current_entry . previous_msgid = unescape ( self . current_token [ [number] : - [number] ] ) [EOL] return True [EOL] [EOL] def handle_pc ( self ) : [EOL] [docstring] [EOL] if self . current_state in [ [string] , [string] , [string] ] : [EOL] self . instance . append ( self . current_entry ) [EOL] self . current_entry = POEntry ( linenum = self . current_line ) [EOL] self . current_entry . previous_msgctxt = unescape ( self . current_token [ [number] : - [number] ] ) [EOL] return True [EOL] [EOL] def handle_ct ( self ) : [EOL] [docstring] [EOL] if self . current_state in [ [string] , [string] , [string] ] : [EOL] self . instance . append ( self . current_entry ) [EOL] self . current_entry = POEntry ( linenum = self . current_line ) [EOL] self . current_entry . msgctxt = unescape ( self . current_token [ [number] : - [number] ] ) [EOL] return True [EOL] [EOL] def handle_mi ( self ) : [EOL] [docstring] [EOL] if self . current_state in [ [string] , [string] , [string] ] : [EOL] self . instance . append ( self . current_entry ) [EOL] self . current_entry = POEntry ( linenum = self . current_line ) [EOL] self . current_entry . obsolete = self . entry_obsolete [EOL] self . current_entry . msgid = unescape ( self . current_token [ [number] : - [number] ] ) [EOL] return True [EOL] [EOL] def handle_mp ( self ) : [EOL] [docstring] [EOL] self . current_entry . msgid_plural = unescape ( self . current_token [ [number] : - [number] ] ) [EOL] return True [EOL] [EOL] def handle_ms ( self ) : [EOL] [docstring] [EOL] self . current_entry . msgstr = unescape ( self . current_token [ [number] : - [number] ] ) [EOL] return True [EOL] [EOL] def handle_mx ( self ) : [EOL] [docstring] [EOL] index = self . current_token [ [number] ] [EOL] value = self . current_token [ self . current_token . find ( [string] ) + [number] : - [number] ] [EOL] self . current_entry . msgstr_plural [ int ( index ) ] = unescape ( value ) [EOL] self . msgstr_index = int ( index ) [EOL] return True [EOL] [EOL] def handle_mc ( self ) : [EOL] [docstring] [EOL] token = unescape ( self . current_token [ [number] : - [number] ] ) [EOL] if self . current_state == [string] : [EOL] self . current_entry . msgctxt += token [EOL] elif self . current_state == [string] : [EOL] self . current_entry . msgid += token [EOL] elif self . current_state == [string] : [EOL] self . current_entry . msgid_plural += token [EOL] elif self . current_state == [string] : [EOL] self . current_entry . msgstr += token [EOL] elif self . current_state == [string] : [EOL] self . current_entry . msgstr_plural [ self . msgstr_index ] += token [EOL] elif self . current_state == [string] : [EOL] self . current_entry . previous_msgid_plural += token [EOL] elif self . current_state == [string] : [EOL] self . current_entry . previous_msgid += token [EOL] elif self . current_state == [string] : [EOL] self . current_entry . previous_msgctxt += token [EOL] [comment] [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class _MOFileParser ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mofile , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . fhandle = open ( mofile , [string] ) [EOL] [EOL] klass = kwargs . get ( [string] ) [EOL] if klass is None : [EOL] klass = MOFile [EOL] self . instance = klass ( fpath = mofile , encoding = kwargs . get ( [string] , default_encoding ) , check_for_duplicates = kwargs . get ( [string] , False ) ) [EOL] [EOL] def __del__ ( self ) : [EOL] [docstring] [EOL] if self . fhandle : [EOL] self . fhandle . close ( ) [EOL] [EOL] def parse ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] magic_number = self . _readbinary ( [string] , [number] ) [EOL] if magic_number == MOFile . MAGIC : [EOL] ii = [string] [EOL] elif magic_number == MOFile . MAGIC_SWAPPED : [EOL] ii = [string] [EOL] else : [EOL] raise IOError ( [string] ) [EOL] self . instance . magic_number = magic_number [EOL] [comment] [EOL] version , numofstrings = self . _readbinary ( ii , [number] ) [EOL] [comment] [EOL] [comment] [EOL] if version >> [number] not in ( [number] , [number] ) : [EOL] raise IOError ( [string] ) [EOL] self . instance . version = version [EOL] [comment] [EOL] msgids_hash_offset , msgstrs_hash_offset = self . _readbinary ( ii , [number] ) [EOL] [comment] [EOL] self . fhandle . seek ( msgids_hash_offset ) [EOL] msgids_index = [ ] [EOL] for i in range ( numofstrings ) : [EOL] msgids_index . append ( self . _readbinary ( ii , [number] ) ) [EOL] [comment] [EOL] self . fhandle . seek ( msgstrs_hash_offset ) [EOL] msgstrs_index = [ ] [EOL] for i in range ( numofstrings ) : [EOL] msgstrs_index . append ( self . _readbinary ( ii , [number] ) ) [EOL] [comment] [EOL] encoding = self . instance . encoding [EOL] for i in range ( numofstrings ) : [EOL] self . fhandle . seek ( msgids_index [ i ] [ [number] ] ) [EOL] msgid = self . fhandle . read ( msgids_index [ i ] [ [number] ] ) [EOL] [EOL] self . fhandle . seek ( msgstrs_index [ i ] [ [number] ] ) [EOL] msgstr = self . fhandle . read ( msgstrs_index [ i ] [ [number] ] ) [EOL] if i == [number] and not msgid : [comment] [EOL] raw_metadata , metadata = msgstr . split ( b ( [string] ) ) , { } [EOL] for line in raw_metadata : [EOL] tokens = line . split ( b ( [string] ) , [number] ) [EOL] if tokens [ [number] ] != b ( [string] ) : [EOL] try : [EOL] k = tokens [ [number] ] . decode ( encoding ) [EOL] v = tokens [ [number] ] . decode ( encoding ) [EOL] metadata [ k ] = v . strip ( ) [EOL] except IndexError : [EOL] metadata [ k ] = u ( [string] ) [EOL] self . instance . metadata = metadata [EOL] continue [EOL] [comment] [EOL] msgid_tokens = msgid . split ( b ( [string] ) ) [EOL] if len ( msgid_tokens ) > [number] : [EOL] entry = self . _build_entry ( msgid = msgid_tokens [ [number] ] , msgid_plural = msgid_tokens [ [number] ] , msgstr_plural = dict ( ( k , v ) for k , v in enumerate ( msgstr . split ( b ( [string] ) ) ) ) ) [EOL] else : [EOL] entry = self . _build_entry ( msgid = msgid , msgstr = msgstr ) [EOL] self . instance . append ( entry ) [EOL] [comment] [EOL] self . fhandle . close ( ) [EOL] return self . instance [EOL] [EOL] def _build_entry ( self , msgid , msgstr = None , msgid_plural = None , msgstr_plural = None ) : [EOL] msgctxt_msgid = msgid . split ( b ( [string] ) ) [EOL] encoding = self . instance . encoding [EOL] if len ( msgctxt_msgid ) > [number] : [EOL] kwargs = { [string] : msgctxt_msgid [ [number] ] . decode ( encoding ) , [string] : msgctxt_msgid [ [number] ] . decode ( encoding ) , } [EOL] else : [EOL] kwargs = { [string] : msgid . decode ( encoding ) } [EOL] if msgstr : [EOL] kwargs [ [string] ] = msgstr . decode ( encoding ) [EOL] if msgid_plural : [EOL] kwargs [ [string] ] = msgid_plural . decode ( encoding ) [EOL] if msgstr_plural : [EOL] for k in msgstr_plural : [EOL] msgstr_plural [ k ] = msgstr_plural [ k ] . decode ( encoding ) [EOL] kwargs [ [string] ] = msgstr_plural [EOL] return MOEntry ( ** kwargs ) [EOL] [EOL] def _readbinary ( self , fmt , numbytes ) : [EOL] [docstring] [EOL] bytes = self . fhandle . read ( numbytes ) [EOL] tup = struct . unpack ( fmt , bytes ) [EOL] if len ( tup ) == [number] : [EOL] return tup [ [number] ] [EOL] return tup [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class TextWrapper ( textwrap . TextWrapper ) : [EOL] [docstring] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] drop_whitespace = kwargs . pop ( [string] , True ) [EOL] textwrap . TextWrapper . __init__ ( self , * args , ** kwargs ) [EOL] self . drop_whitespace = drop_whitespace [EOL] [EOL] def _wrap_chunks ( self , chunks ) : [EOL] [docstring] [EOL] lines = [ ] [EOL] if self . width <= [number] : [EOL] raise ValueError ( [string] % self . width ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] chunks . reverse ( ) [EOL] [EOL] while chunks : [EOL] [EOL] [comment] [EOL] [comment] [EOL] cur_line = [ ] [EOL] cur_len = [number] [EOL] [EOL] [comment] [EOL] if lines : [EOL] indent = self . subsequent_indent [EOL] else : [EOL] indent = self . initial_indent [EOL] [EOL] [comment] [EOL] width = self . width - len ( indent ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . drop_whitespace and chunks [ - [number] ] . strip ( ) == [string] and lines : [EOL] del chunks [ - [number] ] [EOL] [EOL] while chunks : [EOL] length = len ( chunks [ - [number] ] ) [EOL] [EOL] [comment] [EOL] if cur_len + length <= width : [EOL] cur_line . append ( chunks . pop ( ) ) [EOL] cur_len += length [EOL] [EOL] [comment] [EOL] else : [EOL] break [EOL] [EOL] [comment] [EOL] [comment] [EOL] if chunks and len ( chunks [ - [number] ] ) > width : [EOL] self . _handle_long_word ( chunks , cur_line , cur_len , width ) [EOL] [EOL] [comment] [EOL] if self . drop_whitespace and cur_line and not cur_line [ - [number] ] . strip ( ) : [EOL] del cur_line [ - [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if cur_line : [EOL] lines . append ( indent + [string] . join ( cur_line ) ) [EOL] [EOL] return lines [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def wrap ( text , width = [number] , ** kwargs ) : [EOL] [docstring] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] return TextWrapper ( width = width , ** kwargs ) . wrap ( text ) [EOL] return textwrap . wrap ( text , width = width , ** kwargs ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Type[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Type[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[horizons.ext.polib.POFile]$ 0 0 0 0 0 0 0 0 0 $typing.Type[horizons.ext.polib.POFile]$ 0 0 0 0 $typing.Type[horizons.ext.polib.POFile]$ 0 0 0 0 0 0 0 $typing.Type[horizons.ext.polib.POFile]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 $typing.Any$ 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 $horizons.ext.polib.POEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[horizons.ext.polib.MOFile]$ 0 0 0 0 0 0 0 0 0 $typing.Type[horizons.ext.polib.MOFile]$ 0 0 0 0 $typing.Type[horizons.ext.polib.MOFile]$ 0 0 0 0 0 0 0 $typing.Type[horizons.ext.polib.MOFile]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] RANDOM_SEED = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import functools [EOL] import signal [EOL] [EOL] from pytest import skip [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] from signal import SIGALRM [EOL] SUPPORTED = True [EOL] except ImportError : [EOL] SUPPORTED = False [EOL] [EOL] [EOL] class Timer : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , handler ) : [EOL] [docstring] [EOL] if not SUPPORTED : [EOL] return [EOL] [EOL] signal . signal ( signal . SIGALRM , handler ) [EOL] [EOL] def start ( self , timeout ) : [EOL] [docstring] [EOL] if not SUPPORTED or timeout == [number] : [EOL] return [EOL] [EOL] signal . alarm ( timeout ) [EOL] [EOL] @ classmethod def stop ( cls ) : [EOL] [docstring] [EOL] if not SUPPORTED : [EOL] return [EOL] [EOL] signal . alarm ( [number] ) [EOL] [EOL] [EOL] def mark_flaky ( func ) : [EOL] [docstring] [EOL] @ functools . wraps ( func ) def wrapped ( * args , ** kwargs ) : [EOL] try : [EOL] func ( * args , ** kwargs ) [EOL] except Exception : [EOL] skip ( ) [EOL] return wrapped [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] [EOL] import horizons . main [comment] [EOL] from horizons . gui . tabs . buildtabs import BuildTab [EOL] from horizons . util . yamlcache import YamlCache [EOL] [EOL] ROOT_DIR = os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , [string] ) [EOL] [EOL] [EOL] def _get_referenced_buildings ( yaml_data ) : [EOL] [docstring] [EOL] for section in yaml_data . values ( ) : [EOL] for value in section : [EOL] if type ( value ) != list : [EOL] continue [EOL] [EOL] for text in value : [EOL] if text . startswith ( [string] ) : [EOL] yield text [EOL] [EOL] [EOL] def test_build_menu_consistency ( ) : [EOL] [docstring] [EOL] assert len ( BuildTab . build_menus ) == [number] , [string] [EOL] [EOL] buildings = [ ] [EOL] for filename in BuildTab . build_menus : [EOL] with open ( os . path . join ( ROOT_DIR , filename ) ) as f : [EOL] data = YamlCache . load_yaml_data ( f ) [EOL] buildings . append ( sorted ( list ( _get_referenced_buildings ( data ) ) ) ) [EOL] [EOL] assert buildings [ [number] ] == buildings [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import os [EOL] import tempfile [EOL] from functools import partial [EOL] [EOL] import pytest [EOL] [EOL] from horizons . util . random_map import generate_map_from_seed [EOL] from horizons . util . savegameaccessor import SavegameAccessor [EOL] from tests . game import game_test [EOL] [EOL] [EOL] @ pytest . mark . long @ game_test ( mapgen = partial ( generate_map_from_seed , [number] ) , human_player = False , ai_players = [number] , timeout = [number] * [number] ) def test_save_trivial ( session , _ ) : [EOL] [docstring] [EOL] session . run ( seconds = [number] * [number] ) [EOL] [EOL] fd , filename = tempfile . mkstemp ( ) [EOL] os . close ( fd ) [EOL] [EOL] assert session . save ( savegamename = filename ) [EOL] [EOL] SavegameAccessor ( filename , False ) [EOL] [EOL] os . unlink ( filename ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from functools import partial [EOL] [EOL] import pytest [EOL] [EOL] from horizons . util . random_map import generate_map_from_seed [EOL] from tests . game import game_test [EOL] [EOL] [EOL] @ pytest . mark . long @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] , [number] ] ) def test_ai_quick ( seed ) : [EOL] @ game_test ( mapgen = partial ( generate_map_from_seed , seed ) , human_player = False , ai_players = [number] , timeout = [number] * [number] ) def test ( session , _ ) : [EOL] [docstring] [EOL] session . run ( seconds = [number] * [number] ) [EOL] assert session . world . settlements [EOL] [EOL] test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import os [EOL] import shutil [EOL] import tempfile [EOL] from unittest import TestCase [EOL] [EOL] from horizons . constants import PATHS [EOL] from horizons . savegamemanager import SavegameManager [EOL] from horizons . util import create_user_dirs [EOL] [EOL] [EOL] class TestPaths ( TestCase ) : [EOL] odd_characters = [string] [EOL] [EOL] def test_normal ( self ) : [EOL] [EOL] create_user_dirs ( migrate = False ) [EOL] [EOL] def test_special_character ( self ) : [EOL] [docstring] [EOL] [EOL] outer = tempfile . mkdtemp ( self . __class__ . odd_characters ) [EOL] inner = str ( os . path . join ( outer , self . __class__ . odd_characters ) ) [EOL] inner2 = str ( os . path . join ( outer , self . __class__ . odd_characters + [string] ) ) [EOL] [EOL] PATHS . USER_DATA_DIR = inner [EOL] PATHS . LOG_DIR = os . path . join ( inner , [string] ) [EOL] PATHS . USER_MAPS_DIR = os . path . join ( inner , [string] ) [EOL] PATHS . SCREENSHOT_DIR = os . path . join ( inner , [string] ) [EOL] PATHS . SAVEGAME_DIR = os . path . join ( inner , [string] ) [EOL] [EOL] create_user_dirs ( migrate = False ) [EOL] [EOL] scenario_file = os . listdir ( SavegameManager . scenarios_dir ) [ [number] ] [EOL] shutil . copy ( os . path . join ( SavegameManager . scenarios_dir , scenario_file ) , inner ) [EOL] [EOL] SavegameManager . scenarios_dir = inner [EOL] SavegameManager . autosave_dir = inner2 [EOL] SavegameManager . init ( ) [EOL] [EOL] [comment] [EOL] SavegameManager . get_available_scenarios ( ) [EOL] [EOL] os . remove ( os . path . join ( inner , scenario_file ) ) [EOL] [EOL] SavegameManager . create_autosave_filename ( ) [EOL] [EOL] for dirpath , _dirnames , _filenames in os . walk ( inner , topdown = False ) : [EOL] os . rmdir ( dirpath ) [EOL] os . rmdir ( inner2 ) [EOL] os . rmdir ( outer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from unittest import mock [EOL] [EOL] import pytest [EOL] [EOL] from horizons . network import enet [EOL] from run_server import main [EOL] [EOL] pytestmark = pytest . mark . skipif ( enet is None , reason = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def server_mock ( mocker ) : [EOL] mocker . patch ( [string] ) [EOL] return mocker . patch ( [string] ) [EOL] [EOL] [EOL] def test_start ( server_mock ) : [EOL] main ( [ [string] ] ) [EOL] server_mock . assert_has_calls ( [ mock . call ( [string] , [number] , None ) ] ) [EOL] [EOL] [EOL] def test_start_port ( server_mock ) : [EOL] main ( [ [string] , [string] , [string] ] ) [EOL] server_mock . assert_has_calls ( [ mock . call ( [string] , [number] , None ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import io [EOL] import unittest [EOL] import typing [EOL] from io import StringIO [EOL] from unittest import mock [EOL] [EOL] from horizons . network . common import Game [EOL] from horizons . network . server import print_statistic [EOL] [EOL] [EOL] def test_stats_empty_server ( ) : [EOL] f = StringIO ( ) [EOL] print_statistic ( [ ] , [ ] , f ) [EOL] [EOL] assert f . getvalue ( ) == [string] . strip ( ) [EOL] [EOL] [EOL] def test_stats_busy_server ( mocker ) : [EOL] p1 = mock . Mock ( ) [EOL] p2 = mock . Mock ( ) [EOL] p2 . game = mock . Mock ( ) [EOL] p3 = mock . Mock ( ) [EOL] p3 . game = mock . Mock ( state = Game . State . Running ) [EOL] [EOL] g1 = mock . Mock ( ) [EOL] g2 = mock . Mock ( state = Game . State . Running ) [EOL] [EOL] f = StringIO ( ) [EOL] print_statistic ( [ p1 , p2 , p3 ] , [ g1 , g2 ] , f ) [EOL] assert f . getvalue ( ) == [string] . strip ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0