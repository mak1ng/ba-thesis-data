from setuptools import ( setup , find_packages , ) [EOL] [EOL] [EOL] setup ( name = [string] , description = [string] , version = [string] , author = [string] , author_email = [string] , entry_points = [string] , packages = find_packages ( ) , license = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type [EOL] import typing [EOL] import giggle [EOL] import os [EOL] [EOL] [EOL] class Config ( object ) : [EOL] DEBUG = True [EOL] TESTING = False [EOL] CSRF_ENABLED = True [EOL] SECRET_KEY = os . environ [ [string] ] [EOL] SQLALCHEMY_DATABASE_URI = os . environ [ [string] ] [EOL] SQLALCHEMY_TRACK_MODIFICATIONS = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Iterator , List , Any [EOL] import typing [EOL] import functools [EOL] import itertools [EOL] import json [EOL] import traceback [EOL] [EOL] [EOL] def wrap_exceptions ( func , logger = None ) : [EOL] @ functools . wraps ( func ) def func_wrapper ( * args , ** kwargs ) : [EOL] try : [EOL] return func ( * args , ** kwargs ) [EOL] except Exception as e : [EOL] return _error_as_json ( e , logger ) [EOL] return func_wrapper [EOL] [EOL] [EOL] def _error_as_json ( ex , logger = None , status = [number] ) : [EOL] if logger : [EOL] logger . error ( [string] ) [EOL] logger . error ( [string] % ex ) [EOL] logger . error ( traceback . format_exc ( ) ) [EOL] return json . dumps ( { [string] : [string] . format ( ex ) } ) , status [EOL] [EOL] [EOL] def grouper ( iterable , n , fillvalue = None ) : [EOL] args = [ iter ( iterable ) ] * n [EOL] return itertools . zip_longest ( * args , fillvalue = fillvalue ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type , Any [EOL] import tests [EOL] import typing [EOL] import numpy as np [EOL] [EOL] from giggle . recommender import ( RECOMMENDERS , ) [EOL] [EOL] from giggle . data import ( DATASETS , ) [EOL] [EOL] [EOL] dataset = DATASETS [ [string] ] ( ) [EOL] [EOL] [EOL] class TestBaseline : [EOL] [EOL] recommender = RECOMMENDERS [ [string] ] [EOL] [EOL] def test_error_improves ( self ) : [EOL] TOL = [number] [EOL] NR_ITERS = [number] [EOL] reco = TestBaseline . recommender [EOL] data = dataset . get_data ( ) [EOL] reco . mu = data . data_frame . rating . mean ( ) [EOL] prev_rmse = np . inf [EOL] for i , _ in enumerate ( reco . _update_params ( data ) ) : [EOL] if i == [number] : [EOL] break [EOL] curr_rmse = reco . _compute_rmse ( data . data_frame ) [EOL] assert curr_rmse - prev_rmse < TOL [EOL] prev_rmse = curr_rmse [EOL] [EOL] [EOL] class TestNeighbourhood : [EOL] [EOL] recommender = RECOMMENDERS [ [string] ] [EOL] recommender . fit ( dataset . get_data ( ) , verbose = [number] ) [EOL] [EOL] def test_sims ( self ) : [EOL] sims = TestNeighbourhood . recommender . sims [EOL] assert sims . shape [ [number] ] == sims . shape [ [number] ] [EOL] assert np . all ( np . logical_and ( - [number] <= sims , sims <= [number] ) ) [EOL] assert np . allclose ( np . diag ( sims ) , [number] ) [EOL] [EOL] def test_user_joke_matrix ( self ) : [EOL] mat = TestNeighbourhood . recommender . user_joke_matrix [EOL] nr_users = len ( TestNeighbourhood . recommender . data . users ) [EOL] nr_jokes = len ( TestNeighbourhood . recommender . data . jokes ) [EOL] assert mat . shape == ( nr_users , nr_jokes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_recommender.TestBaseline]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.float$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Type[tests.test_recommender.TestNeighbourhood]$ 0 0 0 0 0 0 $typing.Type[tests.test_recommender.TestNeighbourhood]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0
from typing import List [EOL] import typing [EOL] from giggle . utils import ( grouper , ) [EOL] [EOL] [EOL] def test_grouper ( ) : [EOL] xs = [ [number] , [number] , [number] , [number] ] [EOL] assert list ( grouper ( xs , [number] , None ) ) == [ ( [number] , [number] , [number] ) , ( [number] , None , None ) ] [EOL] assert list ( grouper ( xs , [number] , None ) ) == [ ( [number] , ) , ( [number] , ) , ( [number] , ) , ( [number] , ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import pdb [EOL] [EOL] jokes = { } [EOL] [EOL] with open ( [string] , [string] ) as f : [EOL] text = f . read ( ) [EOL] for i , joke in enumerate ( text . strip ( ) . split ( [string] ) , [number] ) : [EOL] lines = joke . split ( [string] ) [EOL] assert lines [ [number] ] == [string] . format ( i ) [EOL] jokes [ i ] = [string] . join ( lines [ [number] : ] ) . strip ( ) [EOL] [EOL] for i , joke in jokes . items ( ) : [EOL] with open ( [string] . format ( i ) , [string] ) as f : [EOL] f . write ( joke ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0