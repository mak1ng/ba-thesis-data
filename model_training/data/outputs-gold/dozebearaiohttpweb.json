	0
from typing import Dict , Union , Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from imagetagger . utils import config_from_dict [EOL] from imagetagger . app import init_app [EOL] [EOL] [EOL] @ pytest . fixture def loop ( event_loop ) : [EOL] return event_loop [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def conf ( ) : [EOL] d = { [string] : { [string] : [string] , [string] : [number] } , [string] : { [string] : [number] , [string] : [string] } , } [EOL] return config_from_dict ( d ) [EOL] [EOL] [EOL] @ pytest . fixture def api ( loop , aiohttp_client , conf ) : [EOL] app = loop . run_until_complete ( init_app ( conf ) ) [EOL] yield loop . run_until_complete ( aiohttp_client ( app ) ) [EOL] loop . run_until_complete ( app . shutdown ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Tuple , Optional [EOL] import PIL [EOL] import typing [EOL] import builtins [EOL] import io [EOL] import json [EOL] import signal [EOL] import numpy as np [EOL] from typing import Tuple , Dict , Any , Optional [EOL] [EOL] from keras . models import load_model [EOL] from keras . applications import imagenet_utils [EOL] from keras . preprocessing . image import img_to_array [EOL] from PIL import Image [EOL] [EOL] [EOL] _model = None [EOL] [EOL] [EOL] def warm ( model_path ) : [EOL] [comment] [EOL] signal . signal ( signal . SIGINT , signal . SIG_IGN ) [EOL] global _model [EOL] if _model is None : [EOL] _model = load_model ( model_path ) [EOL] [EOL] [EOL] def clean ( ) : [EOL] [comment] [EOL] signal . signal ( signal . SIGINT , signal . SIG_DFL ) [EOL] global _model [EOL] _model = None [EOL] [EOL] [EOL] def prepare_image ( image , target ) : [EOL] if image . mode != [string] : [EOL] image = image . convert ( [string] ) [EOL] [EOL] image = image . resize ( target ) [EOL] image = img_to_array ( image ) [EOL] image = np . expand_dims ( image , axis = [number] ) [EOL] image = imagenet_utils . preprocess_input ( image ) [EOL] return image [EOL] [EOL] [EOL] def predict ( raw_data , model = None ) : [EOL] if model is None : [EOL] model = _model [EOL] [EOL] if model is None : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] image = Image . open ( io . BytesIO ( raw_data ) ) [EOL] data = { } [EOL] image = prepare_image ( image , target = ( [number] , [number] ) ) [EOL] [EOL] preds = model . predict ( image ) [EOL] results = imagenet_utils . decode_predictions ( preds ) [EOL] data [ [string] ] = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for _ , label , prob in results [ [number] ] : [EOL] r = { [string] : label , [string] : float ( prob ) } [EOL] data [ [string] ] . append ( r ) [EOL] [EOL] data [ [string] ] = True [EOL] return json . dumps ( data ) . encode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 $PIL.Image$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
	0
import pathlib [EOL] import pathlib [EOL] [EOL] [EOL] OBJECT_NOT_FOUND_ERROR = [string] [EOL] PROJECT_DIR = pathlib . Path ( __file__ ) . parent . parent [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0
from . app import main [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import logging [EOL] [EOL] import aiohttp [EOL] import aiohttp_jinja2 [EOL] from aiohttp import web [EOL] from faker import Faker [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_random_name ( ) : [EOL] fake = Faker ( ) [EOL] return fake . name ( ) [EOL] [EOL] [EOL] async def index ( request ) : [EOL] ws_current = web . WebSocketResponse ( ) [EOL] ws_ready = ws_current . can_prepare ( request ) [EOL] if not ws_ready . ok : [EOL] return aiohttp_jinja2 . render_template ( [string] , request , { } ) [EOL] [EOL] await ws_current . prepare ( request ) [EOL] [EOL] name = get_random_name ( ) [EOL] log . info ( [string] , name ) [EOL] [EOL] await ws_current . send_json ( { [string] : [string] , [string] : name } ) [EOL] [EOL] for ws in request . app [ [string] ] . values ( ) : [EOL] await ws . send_json ( { [string] : [string] , [string] : name } ) [EOL] request . app [ [string] ] [ name ] = ws_current [EOL] [EOL] while True : [EOL] msg = await ws_current . receive ( ) [EOL] [EOL] if msg . type == aiohttp . WSMsgType . text : [EOL] for ws in request . app [ [string] ] . values ( ) : [EOL] if ws is not ws_current : [EOL] await ws . send_json ( { [string] : [string] , [string] : name , [string] : msg . data } ) [EOL] else : [EOL] break [EOL] [EOL] del request . app [ [string] ] [ name ] [EOL] log . info ( [string] , name ) [EOL] for ws in request . app [ [string] ] . values ( ) : [EOL] await ws . send_json ( { [string] : [string] , [string] : name } ) [EOL] [EOL] return ws_current [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from aiohttpdemo_chat . main import init_app [EOL] [EOL] [EOL] @ pytest . fixture async def client ( test_client ) : [EOL] app = await init_app ( ) [EOL] return await test_client ( app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import trafaret as t [EOL] from trafaret . contrib . object_id import MongoId [EOL] from trafaret . contrib . rfc_3339 import DateTime [EOL] [EOL] [EOL] user = t . Dict ( { t . Key ( [string] ) : MongoId ( ) , t . Key ( [string] ) : t . String ( max_length = [number] ) , t . Key ( [string] ) : t . Email , t . Key ( [string] ) : t . String ( ) , } ) [EOL] [EOL] [EOL] message = t . Dict ( { t . Key ( [string] ) : MongoId ( ) , t . Key ( [string] ) : MongoId ( ) , t . Key ( [string] ) : t . String ( max_length = [number] ) , t . Key ( [string] ) : t . String ( ) , t . Key ( [string] ) : DateTime ( ) , } ) [EOL] [EOL] follower = t . Dict ( { t . Key ( [string] ) : MongoId ( ) , t . Key ( [string] ) : MongoId ( ) , t . Key ( [string] ) : t . List ( MongoId ( ) ) , } ) [EOL] [EOL] [EOL] async def get_user_id ( user_collection , username ) : [EOL] rv = await ( user_collection . find_one ( { [string] : username } , { [string] : [number] } ) ) [EOL] return rv [ [string] ] if rv else None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import asyncio [EOL] import typing [EOL] import pathlib [EOL] import asyncio [EOL] import logging [EOL] import pathlib [EOL] [EOL] import aiohttp_jinja2 [EOL] import jinja2 [EOL] from aiohttp import web [EOL] from aiohttp_security import setup as setup_security [EOL] from aiohttp_security import CookiesIdentityPolicy [EOL] [EOL] from motortwit . routes import setup_routes [EOL] from motortwit . security import AuthorizationPolicy [EOL] from motortwit . utils import ( format_datetime , init_mongo , load_config , robo_avatar_url ) [EOL] from motortwit . views import SiteHandler [EOL] [EOL] [EOL] PROJ_ROOT = pathlib . Path ( __file__ ) . parent . parent [EOL] TEMPLATES_ROOT = pathlib . Path ( __file__ ) . parent / [string] [EOL] [EOL] [EOL] async def setup_mongo ( app , conf , loop ) : [EOL] mongo = await init_mongo ( conf [ [string] ] , loop ) [EOL] [EOL] async def close_mongo ( app ) : [EOL] mongo . client . close ( ) [EOL] [EOL] app . on_cleanup . append ( close_mongo ) [EOL] return mongo [EOL] [EOL] [EOL] def setup_jinja ( app ) : [EOL] jinja_env = aiohttp_jinja2 . setup ( app , loader = jinja2 . FileSystemLoader ( str ( TEMPLATES_ROOT ) ) ) [EOL] [EOL] jinja_env . filters [ [string] ] = format_datetime [EOL] jinja_env . filters [ [string] ] = robo_avatar_url [EOL] [EOL] [EOL] async def init ( loop ) : [EOL] conf = load_config ( PROJ_ROOT / [string] / [string] ) [EOL] [EOL] app = web . Application ( loop = loop ) [EOL] mongo = await setup_mongo ( app , conf , loop ) [EOL] [EOL] setup_jinja ( app ) [EOL] setup_security ( app , CookiesIdentityPolicy ( ) , AuthorizationPolicy ( mongo ) ) [EOL] [EOL] [comment] [EOL] handler = SiteHandler ( mongo ) [EOL] setup_routes ( app , handler , PROJ_ROOT ) [EOL] host , port = conf [ [string] ] , conf [ [string] ] [EOL] return app , host , port [EOL] [EOL] [EOL] def main ( ) : [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] app , host , port = loop . run_until_complete ( init ( loop ) ) [EOL] web . run_app ( app , host = host , port = port ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from motortwit . main import main [EOL] [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any , Union [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] import random [EOL] [EOL] from bson import ObjectId [EOL] from faker import Factory [EOL] [EOL] from motortwit import db [EOL] from motortwit . main import init_mongo [EOL] from motortwit . security import generate_password_hash [EOL] [EOL] [EOL] conf = { [string] : [string] , [string] : [number] , [string] : { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] } } [EOL] [EOL] [EOL] [comment] [EOL] async def insert_data ( collection , values ) : [EOL] await collection . insert ( values ) [EOL] return values [EOL] [EOL] [EOL] async def generate_users ( mongo , schema , rows , fake ) : [EOL] values = [ ] [EOL] pw_hash = generate_password_hash ( [string] ) [EOL] for i in range ( rows ) : [EOL] values . append ( schema ( { [string] : ObjectId ( ) , [string] : fake . user_name ( ) [ : [number] ] , [string] : fake . email ( ) , [string] : pw_hash , } ) ) [EOL] users = await insert_data ( mongo , values ) [EOL] return users [EOL] [EOL] [EOL] async def generate_messages ( mongo , schema , rows , fake , users ) : [EOL] values = [ ] [EOL] for user in users : [EOL] for i in range ( rows ) : [EOL] values . append ( schema ( { [string] : ObjectId ( ) , [string] : ObjectId ( user [ [string] ] ) , [string] : user [ [string] ] , [string] : fake . text ( max_nb_chars = [number] ) , [string] : fake . iso8601 ( ) , } ) ) [EOL] [EOL] ids = await insert_data ( mongo , values ) [EOL] return ids [EOL] [EOL] [EOL] async def generate_followers ( mongo , schema , rows , fake , user_ids ) : [EOL] values = [ ] [EOL] for user_id in user_ids : [EOL] entry = schema ( { [string] : ObjectId ( ) , [string] : user_id , [string] : [ ] } ) [EOL] for i in range ( rows ) : [EOL] entry [ [string] ] . append ( random . choice ( user_ids ) ) [EOL] values . append ( entry ) [EOL] await insert_data ( mongo , values ) [EOL] [EOL] [EOL] async def prepare_coolections ( * collections ) : [EOL] for coll in collections : [EOL] await coll . drop ( ) [EOL] [EOL] [EOL] async def init ( loop ) : [EOL] print ( [string] ) [EOL] mongo = await init_mongo ( conf [ [string] ] , loop ) [EOL] fake = Factory . create ( ) [EOL] fake . seed ( [number] ) [EOL] [EOL] await prepare_coolections ( mongo . user , mongo . message , mongo . follower ) [EOL] [EOL] users = await generate_users ( mongo . user , db . user , [number] , fake ) [EOL] await generate_messages ( mongo . message , db . message , [number] , fake , users ) [EOL] user_ids = [ v [ [string] ] for v in users ] [EOL] await generate_followers ( mongo . follower , db . follower , [number] , fake , user_ids ) [EOL] [EOL] [EOL] def main ( ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( init ( loop ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import List , Optional , Pattern , Match [EOL] import typing [EOL] import os [EOL] import re [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] [EOL] def read_version ( ) : [EOL] regexp = re . compile ( [string] ) [EOL] init_py = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] with open ( init_py ) as f : [EOL] for line in f : [EOL] match = regexp . match ( line ) [EOL] if match is not None : [EOL] return match . group ( [number] ) [EOL] else : [EOL] msg = [string] [EOL] raise RuntimeError ( msg ) [EOL] [EOL] [EOL] install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] setup ( name = [string] , classifiers = classifiers , version = read_version ( ) , description = [string] , platforms = [ [string] ] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( ) , include_package_data = True , install_requires = install_requires , license = [string] , zip_safe = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0
import pathlib [EOL] import pathlib [EOL] [EOL] [EOL] PROJ_ROOT = pathlib . Path ( __file__ ) . parent . parent [EOL]	0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pickle [EOL] import numpy as np [EOL] [EOL] _model = None [EOL] [EOL] [EOL] def warm ( model_path ) : [EOL] global _model [EOL] if _model is None : [EOL] with open ( model_path , [string] ) as f : [EOL] pipeline = pickle . load ( f ) [EOL] _model = pipeline [EOL] return True [EOL] [EOL] [EOL] def predict_probability ( comments ) : [EOL] results = _model . predict_proba ( np . array ( comments ) ) [EOL] return np . array ( results ) . T [ [number] ] . tolist ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] def setup_routes ( app , handler , project_root ) : [EOL] router = app . router [EOL] h = handler [EOL] router . add_get ( [string] , h . index , name = [string] ) [EOL] router . add_post ( [string] , h . moderate , name = [string] ) [EOL] router . add_static ( [string] , path = str ( project_root / [string] ) , name = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from moderator . consts import PROJ_ROOT [EOL] from moderator . model . pipeline import build_model [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] dataset_path = PROJ_ROOT / [string] / [string] / [string] / [string] [EOL] model_path = PROJ_ROOT / [string] [EOL] build_model ( dataset_path , model_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
from moderator . main import main [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import sys [EOL] [EOL] from aiohttpdemo_polls . main import main [EOL] [EOL] [EOL] main ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import aiopg . sa [EOL] from sqlalchemy import ( MetaData , Table , Column , ForeignKey , Integer , String , Date ) [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] meta = MetaData ( ) [EOL] [EOL] question = Table ( [string] , meta , Column ( [string] , Integer , primary_key = True ) , Column ( [string] , String ( [number] ) , nullable = False ) , Column ( [string] , Date , nullable = False ) ) [EOL] [EOL] choice = Table ( [string] , meta , Column ( [string] , Integer , primary_key = True ) , Column ( [string] , String ( [number] ) , nullable = False ) , Column ( [string] , Integer , server_default = [string] , nullable = False ) , Column ( [string] , Integer , ForeignKey ( [string] , ondelete = [string] ) ) ) [EOL] [EOL] [EOL] class RecordNotFound ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] async def init_pg ( app ) : [EOL] conf = app [ [string] ] [ [string] ] [EOL] engine = await aiopg . sa . create_engine ( database = conf [ [string] ] , user = conf [ [string] ] , password = conf [ [string] ] , host = conf [ [string] ] , port = conf [ [string] ] , minsize = conf [ [string] ] , maxsize = conf [ [string] ] , ) [EOL] app [ [string] ] = engine [EOL] [EOL] [EOL] async def close_pg ( app ) : [EOL] app [ [string] ] . close ( ) [EOL] await app [ [string] ] . wait_closed ( ) [EOL] [EOL] [EOL] async def get_question ( conn , question_id ) : [EOL] result = await conn . execute ( question . select ( ) . where ( question . c . id == question_id ) ) [EOL] question_record = await result . first ( ) [EOL] if not question_record : [EOL] msg = [string] [EOL] raise RecordNotFound ( msg . format ( question_id ) ) [EOL] result = await conn . execute ( choice . select ( ) . where ( choice . c . question_id == question_id ) . order_by ( choice . c . id ) ) [EOL] choice_records = await result . fetchall ( ) [EOL] return question_record , choice_records [EOL] [EOL] [EOL] async def vote ( conn , question_id , choice_id ) : [EOL] result = await conn . execute ( choice . update ( ) . returning ( * choice . c ) . where ( choice . c . question_id == question_id ) . where ( choice . c . id == choice_id ) . values ( votes = choice . c . votes + [number] ) ) [EOL] record = await result . fetchone ( ) [EOL] if not record : [EOL] msg = [string] [EOL] raise RecordNotFound ( msg . format ( question_id , choice_id ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any , Coroutine [EOL] import typing [EOL] import logging [EOL] import sys [EOL] [EOL] import aiohttp_jinja2 [EOL] import jinja2 [EOL] from aiohttp import web [EOL] [EOL] from aiohttpdemo_polls . db import close_pg , init_pg [EOL] from aiohttpdemo_polls . middlewares import setup_middlewares [EOL] from aiohttpdemo_polls . routes import setup_routes [EOL] from aiohttpdemo_polls . settings import get_config [EOL] [EOL] [EOL] async def init_app ( argv = None ) : [EOL] [EOL] app = web . Application ( ) [EOL] [EOL] app [ [string] ] = get_config ( argv ) [EOL] [EOL] [comment] [EOL] aiohttp_jinja2 . setup ( app , loader = jinja2 . PackageLoader ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] app . on_startup . append ( init_pg ) [EOL] app . on_cleanup . append ( close_pg ) [EOL] [EOL] [comment] [EOL] setup_routes ( app ) [EOL] [EOL] setup_middlewares ( app ) [EOL] [EOL] return app [EOL] [EOL] [EOL] def main ( argv ) : [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] app = init_app ( argv ) [EOL] [EOL] config = get_config ( argv ) [EOL] web . run_app ( app , host = config [ [string] ] , port = config [ [string] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from aiohttpdemo_polls . main import init_app [EOL] from aiohttpdemo_polls . settings import BASE_DIR , get_config [EOL] from init_db import ( setup_db , teardown_db , create_tables , sample_data , drop_tables ) [EOL] [EOL] TEST_CONFIG_PATH = BASE_DIR / [string] / [string] [EOL] [EOL] [EOL] @ pytest . fixture async def cli ( loop , test_client , db ) : [EOL] app = await init_app ( [ [string] , TEST_CONFIG_PATH . as_posix ( ) ] ) [EOL] return await test_client ( app ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def db ( ) : [EOL] test_config = get_config ( [ [string] , TEST_CONFIG_PATH . as_posix ( ) ] ) [EOL] [EOL] setup_db ( test_config [ [string] ] ) [EOL] yield [EOL] teardown_db ( test_config [ [string] ] ) [EOL] [EOL] [EOL] @ pytest . fixture def tables_and_data ( ) : [EOL] create_tables ( ) [EOL] sample_data ( ) [EOL] yield [EOL] drop_tables ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from aiohttpdemo_polls . db import choice [EOL] [EOL] [EOL] async def test_index ( cli , tables_and_data ) : [EOL] response = await cli . get ( [string] ) [EOL] assert response . status == [number] [EOL] [comment] [EOL] [comment] [EOL] assert [string] in await response . text ( ) [EOL] [EOL] [EOL] async def test_results ( cli , tables_and_data ) : [EOL] response = await cli . get ( [string] ) [EOL] assert response . status == [number] [EOL] assert [string] in await response . text ( ) [EOL] [EOL] [EOL] async def test_vote ( cli , tables_and_data ) : [EOL] [EOL] question_id = [number] [EOL] choice_text = [string] [EOL] [EOL] async with cli . server . app [ [string] ] . acquire ( ) as conn : [EOL] res = await conn . execute ( choice . select ( ) . where ( choice . c . question_id == question_id ) . where ( choice . c . choice_text == choice_text ) ) [EOL] not_much_choice = await res . first ( ) [EOL] not_much_choice_id = not_much_choice . id [EOL] votes_before = not_much_choice . votes [EOL] [EOL] response = await cli . post ( f' [string] { question_id } [string] ' , data = { [string] : not_much_choice_id } ) [EOL] assert response . status == [number] [EOL] [EOL] res = await conn . execute ( choice . select ( ) . where ( choice . c . question_id == question_id ) . where ( choice . c . choice_text == choice_text ) ) [EOL] not_much_choice = await res . first ( ) [EOL] votes_after = not_much_choice . votes [EOL] [EOL] assert votes_after == votes_before + [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from setuptools import setup [EOL] [EOL] [EOL] install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] setup ( name = [string] , version = [string] , install_requires = install_requires , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0
	0
from typing import Dict , Any [EOL] import typing [EOL] from aiohttpdemo_blog . forms import validate_login_form [EOL] from aiohttpdemo_blog . security import ( generate_password_hash , check_password_hash ) [EOL] [EOL] [EOL] def test_security ( ) : [EOL] user_password = [string] [EOL] hashed = generate_password_hash ( user_password ) [EOL] assert check_password_hash ( user_password , hashed ) [EOL] [EOL] [EOL] async def test_index_view ( tables_and_data , client ) : [EOL] resp = await client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] async def test_login_form ( tables_and_data , client ) : [EOL] invalid_form = { [string] : [string] , [string] : [string] } [EOL] valid_form = { [string] : [string] , [string] : [string] } [EOL] [EOL] async with client . server . app [ [string] ] . acquire ( ) as conn : [EOL] error = await validate_login_form ( conn , invalid_form ) [EOL] assert error [EOL] [EOL] no_error = await validate_login_form ( conn , valid_form ) [EOL] assert not no_error [EOL] [EOL] [EOL] async def test_login_view ( tables_and_data , client ) : [EOL] invalid_form = { [string] : [string] , [string] : [string] } [EOL] valid_form = { [string] : [string] , [string] : [string] } [EOL] [EOL] resp = await client . post ( [string] , data = invalid_form ) [EOL] assert resp . status == [number] [EOL] assert [string] in await resp . text ( ) [EOL] [EOL] resp = await client . post ( [string] , data = valid_form ) [EOL] assert resp . status == [number] [EOL] assert [string] in await resp . text ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from aiohttpdemo_blog import db [EOL] from aiohttpdemo_blog . security import check_password_hash [EOL] [EOL] [EOL] async def validate_login_form ( conn , form ) : [EOL] [EOL] username = form [ [string] ] [EOL] password = form [ [string] ] [EOL] [EOL] if not username : [EOL] return [string] [EOL] if not password : [EOL] return [string] [EOL] [EOL] user = await db . get_user_by_name ( conn , username ) [EOL] [EOL] if not user : [EOL] return [string] [EOL] if not check_password_hash ( password , user [ [string] ] ) : [EOL] return [string] [EOL] else : [EOL] return None [EOL] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from aiohttp_security . abc import AbstractAuthorizationPolicy [EOL] [EOL] from aiohttpdemo_blog import db [EOL] [EOL] [EOL] class DBAuthorizationPolicy ( AbstractAuthorizationPolicy ) : [EOL] [EOL] def __init__ ( self , db_pool ) : [EOL] self . db_pool = db_pool [EOL] [EOL] async def authorized_userid ( self , identity ) : [EOL] async with self . db_pool . acquire ( ) as conn : [EOL] user = await db . get_user_by_name ( conn , identity ) [EOL] if user : [EOL] return identity [EOL] [EOL] return None [EOL] [EOL] async def permits ( self , identity , permission , context = None ) : [EOL] if identity is None : [EOL] return False [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from datetime import datetime as dt [EOL] [EOL] import asyncpgsa [EOL] from sqlalchemy import ( MetaData , Table , Column , ForeignKey , Integer , String , DateTime ) [EOL] from sqlalchemy . sql import select [EOL] [EOL] metadata = MetaData ( ) [EOL] [EOL] [EOL] users = Table ( [string] , metadata , Column ( [string] , Integer , primary_key = True ) , Column ( [string] , String ( [number] ) , nullable = False , unique = True ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) , nullable = False ) ) [EOL] [EOL] [EOL] posts = Table ( [string] , metadata , Column ( [string] , Integer , primary_key = True ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , DateTime , index = True , default = dt . utcnow ) , Column ( [string] , Integer , ForeignKey ( [string] ) ) ) [EOL] [EOL] [EOL] async def init_db ( app ) : [EOL] dsn = construct_db_url ( app [ [string] ] [ [string] ] ) [EOL] pool = await asyncpgsa . create_pool ( dsn = dsn ) [EOL] app [ [string] ] = pool [EOL] return pool [EOL] [EOL] [EOL] def construct_db_url ( config ) : [EOL] DSN = [string] [EOL] return DSN . format ( user = config [ [string] ] , password = config [ [string] ] , database = config [ [string] ] , host = config [ [string] ] , port = config [ [string] ] , ) [EOL] [EOL] [EOL] async def get_user_by_name ( conn , username ) : [EOL] result = await conn . fetchrow ( users . select ( ) . where ( users . c . username == username ) ) [EOL] return result [EOL] [EOL] [EOL] async def get_users ( conn ) : [EOL] records = await conn . fetch ( users . select ( ) . order_by ( users . c . id ) ) [EOL] return records [EOL] [EOL] [EOL] async def get_posts ( conn ) : [EOL] records = await conn . fetch ( posts . select ( ) . order_by ( posts . c . id ) ) [EOL] return records [EOL] [EOL] [EOL] async def get_posts_with_joined_users ( conn ) : [EOL] j = posts . join ( users , posts . c . user_id == users . c . id ) [EOL] stmt = select ( [ posts , users . c . username ] ) . select_from ( j ) . order_by ( posts . c . timestamp ) [EOL] records = await conn . fetch ( stmt ) [EOL] return records [EOL] [EOL] [EOL] async def create_post ( conn , post_body , user_id ) : [EOL] stmt = posts . insert ( ) . values ( body = post_body , user_id = user_id ) [EOL] await conn . execute ( stmt ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import aioredis [EOL] import trafaret as t [EOL] import yaml [EOL] from aiohttp import web [EOL] [EOL] [EOL] def load_config ( fname ) : [EOL] with open ( fname , [string] ) as f : [EOL] data = yaml . load ( f ) [EOL] [comment] [EOL] return data [EOL] [EOL] [EOL] async def init_redis ( conf , loop ) : [EOL] pool = await aioredis . create_redis_pool ( ( conf [ [string] ] , conf [ [string] ] ) , minsize = conf [ [string] ] , maxsize = conf [ [string] ] , loop = loop ) [EOL] return pool [EOL] [EOL] [EOL] CHARS = [string] [EOL] [EOL] [EOL] def encode ( num , alphabet = CHARS ) : [EOL] if num == [number] : [EOL] return alphabet [ [number] ] [EOL] arr = [ ] [EOL] base = len ( alphabet ) [EOL] while num : [EOL] num , rem = divmod ( num , base ) [EOL] arr . append ( alphabet [ rem ] ) [EOL] arr . reverse ( ) [EOL] return [string] . join ( arr ) [EOL] [EOL] [EOL] ShortifyRequest = t . Dict ( { t . Key ( [string] ) : t . URL } ) [EOL] [EOL] [EOL] def fetch_url ( data ) : [EOL] try : [EOL] data = ShortifyRequest ( data ) [EOL] except t . DataError : [EOL] raise web . HTTPBadRequest ( [string] ) [EOL] return data [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from shortify . main import main [EOL] [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import jinja2 [EOL] import asyncio [EOL] import typing [EOL] import pathlib [EOL] import asyncio [EOL] import logging [EOL] import pathlib [EOL] [EOL] import aiohttp_jinja2 [EOL] import jinja2 [EOL] from aiohttp import web [EOL] [EOL] from shortify . routes import setup_routes [EOL] from shortify . utils import init_redis , load_config [EOL] from shortify . views import SiteHandler [EOL] [EOL] [EOL] PROJ_ROOT = pathlib . Path ( __file__ ) . parent . parent [EOL] TEMPLATES_ROOT = pathlib . Path ( __file__ ) . parent / [string] [EOL] [EOL] [EOL] async def setup_redis ( app , conf , loop ) : [EOL] pool = await init_redis ( conf [ [string] ] , loop ) [EOL] [EOL] async def close_redis ( app ) : [EOL] pool . close ( ) [EOL] await pool . wait_closed ( ) [EOL] [EOL] app . on_cleanup . append ( close_redis ) [EOL] app [ [string] ] = pool [EOL] return pool [EOL] [EOL] [EOL] def setup_jinja ( app ) : [EOL] loader = jinja2 . FileSystemLoader ( str ( TEMPLATES_ROOT ) ) [EOL] jinja_env = aiohttp_jinja2 . setup ( app , loader = loader ) [EOL] return jinja_env [EOL] [EOL] [EOL] async def init ( loop ) : [EOL] conf = load_config ( PROJ_ROOT / [string] / [string] ) [EOL] [EOL] app = web . Application ( loop = loop ) [EOL] redis_pool = await setup_redis ( app , conf , loop ) [EOL] setup_jinja ( app ) [EOL] [EOL] handler = SiteHandler ( redis_pool , conf ) [EOL] [EOL] setup_routes ( app , handler , PROJ_ROOT ) [EOL] host , port = conf [ [string] ] , conf [ [string] ] [EOL] return app , host , port [EOL] [EOL] [EOL] def main ( ) : [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] app , host , port = loop . run_until_complete ( init ( loop ) ) [EOL] web . run_app ( app , host = host , port = port ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
	0
from typing import List , Any [EOL] import builtins [EOL] import asyncio [EOL] import typing [EOL] import aiopg [EOL] import asyncio [EOL] import random [EOL] from typing import List [EOL] [EOL] import aiopg . sa [EOL] from aiopg . sa import SAConnection [EOL] from sqlalchemy . dialects . postgresql import ( CreateEnumType , DropEnumType , ) [EOL] from sqlalchemy . schema import ( CreateTable , DropTable , ) [EOL] import psycopg2 [EOL] from faker import Faker [EOL] [EOL] from graph . utils import get_config [EOL] from graph . auth . enums import UserGender [EOL] from graph . auth . tables import ( users , gender_enum , ) [EOL] from graph . chat . tables import ( rooms , messages , ) [EOL] [EOL] [EOL] tables = [ users , rooms , messages , ] [EOL] enums = [ gender_enum , ] [EOL] faker = Faker ( ) [EOL] [EOL] [EOL] async def drop_tables ( conn ) : [EOL] [EOL] for table in reversed ( tables ) : [EOL] try : [EOL] await conn . execute ( DropTable ( table ) ) [EOL] except psycopg2 . ProgrammingError : [EOL] pass [EOL] [EOL] for enum in enums : [EOL] try : [EOL] await conn . execute ( DropEnumType ( enum ) ) [EOL] except psycopg2 . ProgrammingError : [EOL] pass [EOL] [EOL] [EOL] async def create_tables ( conn ) : [EOL] [EOL] for enum in enums : [EOL] await conn . execute ( CreateEnumType ( enum ) ) [EOL] [EOL] for table in tables : [EOL] await conn . execute ( CreateTable ( table ) ) [EOL] [EOL] [EOL] async def create_engine ( ) : [EOL] [EOL] config = get_config ( ) [EOL] config = config [ [string] ] [EOL] engine = await aiopg . sa . create_engine ( ** config ) [EOL] [EOL] return engine [EOL] [EOL] [EOL] async def generate_users ( conn , count ) : [EOL] [EOL] values = [ ] [EOL] for number in range ( count ) : [EOL] name = faker . name ( ) [EOL] values . append ( { [string] : name , [string] : f'{ name . replace ( [string] , [string] ) . lower ( ) } [string] ' , [string] : [string] , [string] : ( [string] [string] ) , [string] : random . choice ( list ( UserGender ) ) . value } ) [EOL] [EOL] response = await conn . execute ( users . insert ( ) . values ( values ) . returning ( users . c . id ) ) [EOL] [EOL] return [ user [ [number] ] for user in response ] [EOL] [EOL] [EOL] async def generate_rooms ( conn , count , users , ) : [EOL] [EOL] values = [ ] [EOL] for number in range ( count ) : [EOL] values . append ( { [string] : f' [string] { number }' , [string] : random . choice ( users ) , } ) [EOL] [EOL] response = await conn . execute ( rooms . insert ( ) . values ( values ) . returning ( rooms . c . id ) ) [EOL] [EOL] return [ room [ [number] ] for room in response ] [EOL] [EOL] [EOL] async def generate_messages ( conn , users , rooms ) : [EOL] [EOL] values = [ ] [EOL] for room in rooms : [EOL] for i in range ( [number] ) : [EOL] values . append ( { [string] : faker . text ( max_nb_chars = [number] ) , [string] : random . sample ( users , random . randint ( [number] , [number] ) ) , [string] : random . choice ( users ) , [string] : room , } ) [EOL] [EOL] await conn . execute ( messages . insert ( ) . values ( values ) ) [EOL] [EOL] [EOL] async def main ( ) : [EOL] [EOL] print ( [string] ) [EOL] engine = await create_engine ( ) [EOL] [EOL] try : [EOL] async with engine . acquire ( ) as conn : [EOL] [comment] [EOL] await drop_tables ( conn ) [EOL] await create_tables ( conn ) [EOL] [EOL] [comment] [EOL] users = await generate_users ( conn , [number] ) [EOL] rooms = await generate_rooms ( conn , [number] , users ) [EOL] await generate_messages ( conn , users , rooms ) [EOL] finally : [EOL] engine . close ( ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import argparse [EOL] import builtins [EOL] import typing [EOL] import aiohttp [EOL] import pathlib [EOL] import pathlib [EOL] import argparse [EOL] [EOL] from aiohttp import web [EOL] from trafaret_config import commandline [EOL] import trafaret [EOL] [EOL] [EOL] PATH = pathlib . Path ( __file__ ) . parent [EOL] DEFAULT_CONFIG_PATH = PATH / [string] / [string] [EOL] [EOL] [EOL] CONFIG_TRAFARET = trafaret . Dict ( { trafaret . Key ( [string] ) : trafaret . Dict ( { [string] : trafaret . String ( ) , [string] : trafaret . String ( ) , [string] : trafaret . String ( ) , [string] : trafaret . String ( ) , [string] : trafaret . Int ( ) , } ) , trafaret . Key ( [string] ) : trafaret . Dict ( { [string] : trafaret . Int ( ) , [string] : trafaret . String ( ) , } ) , trafaret . Key ( [string] ) : trafaret . Dict ( { [string] : trafaret . IP , [string] : trafaret . Int ( ) , } ) , } ) [EOL] [EOL] [EOL] def get_config ( argv = None ) : [EOL] ap = argparse . ArgumentParser ( ) [EOL] commandline . standard_argparse_options ( ap , default_config = DEFAULT_CONFIG_PATH , ) [EOL] options = ap . parse_args ( argv ) [EOL] [EOL] return commandline . config_from_options ( options , CONFIG_TRAFARET ) [EOL] [EOL] [EOL] def init_config ( app ) : [EOL] app [ [string] ] = get_config ( [ [string] , DEFAULT_CONFIG_PATH . as_posix ( ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import List [EOL] from aiopg . sa . result import RowProxy [EOL] [EOL] [EOL] RowsProxy = List [ RowProxy ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
OBJECT_NOT_FOUND_ERROR = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] from sqlalchemy import MetaData [EOL] [EOL] [EOL] metadata = MetaData ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
import pathlib [EOL] import pathlib [EOL] [EOL] from graph . api . views import ( GQL , subscriptions , ) [EOL] from graph . main . views import index [EOL] [EOL] [EOL] PROJECT_PATH = pathlib . Path ( __file__ ) . parent [EOL] [EOL] [EOL] def init_routes ( app ) : [EOL] add_route = app . router . add_route [EOL] [EOL] add_route ( [string] , [string] , index , name = [string] ) [EOL] add_route ( [string] , [string] , GQL ( ) , name = [string] ) [EOL] add_route ( [string] , [string] , GQL ( graphiql = True ) , name = [string] ) [EOL] add_route ( [string] , [string] , subscriptions , name = [string] ) [EOL] [EOL] [comment] [EOL] app . router . add_static ( [string] , path = ( PROJECT_PATH / [string] ) , name = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from aiohttp import web [EOL] [EOL] from . app import init_app [EOL] [EOL] [EOL] def main ( ) : [EOL] app = init_app ( ) [EOL] web . run_app ( app ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Dict , Any [EOL] import graph [EOL] import typing [EOL] import builtins [EOL] from typing import Any , List [EOL] [EOL] from aiodataloader import DataLoader [EOL] [EOL] from graph . auth . db_utils import select_users [EOL] from graph . types import RowsProxy [EOL] [EOL] [EOL] __all__ = [ [string] , ] [EOL] [EOL] [EOL] class BaseAIODataLoader ( DataLoader ) : [EOL] [docstring] [EOL] engine = None [EOL] [EOL] def __init__ ( self , engine , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . engine = engine [EOL] [EOL] def sorted_by_keys ( self , items , keys ) : [EOL] [docstring] [EOL] items_dict = { key : value for key , value in zip ( sorted ( set ( keys ) ) , items ) } [EOL] [EOL] return [ items_dict [ key ] for key in keys ] [EOL] [EOL] [EOL] class UserDataLoader ( BaseAIODataLoader ) : [EOL] [docstring] [EOL] async def batch_load_fn ( self , keys ) : [EOL] async with self . engine . acquire ( ) as conn : [EOL] response = await select_users ( conn , keys ) [EOL] [EOL] return self . sorted_by_keys ( response , keys ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $graph.types.RowsProxy$ 0 0 0 $graph.types.RowsProxy$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $graph.types.RowsProxy$ 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graph.types.RowsProxy$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0
from graph . api . subscriptions . messages import MessageSubscription [EOL] [EOL] [EOL] class Subscription ( MessageSubscription ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_simple_fetch_messages_from_room ( client , requests ) : [EOL] executed = await client . execute ( [string] , context_value = requests , ) [EOL] [EOL] single_room = executed [ [string] ] [ [string] ] [ [number] ] [EOL] room_id = single_room [ [string] ] [EOL] [EOL] executed = await client . execute ( [string] % room_id , context_value = requests , ) [EOL] [EOL] messages = executed [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] assert messages [EOL] [EOL] single_messages = messages [ [number] ] [EOL] owner = single_messages [ [string] ] [EOL] [EOL] assert isinstance ( single_messages [ [string] ] , int ) [EOL] assert single_messages [ [string] ] [EOL] assert isinstance ( owner [ [string] ] , int ) [EOL] assert owner [ [string] ] [EOL] assert owner [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_mutations_for_message ( client , requests ) : [EOL] text = [string] [EOL] room_id = [number] [EOL] owner_id = [number] [EOL] [EOL] async def fetch_messages ( room_id ) : [EOL] return await client . execute ( [string] % room_id , context_value = requests , ) [EOL] [EOL] executed = await fetch_messages ( room_id ) [EOL] messages = executed [ [string] ] [ [string] ] [ [string] ] [EOL] init_last_messages = messages [ - [number] ] [EOL] [EOL] executed = await client . execute ( [string] % ( room_id , owner_id , text ) , context_value = requests , ) [EOL] [EOL] assert executed [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] executed = await fetch_messages ( room_id ) [EOL] messages = executed [ [string] ] [ [string] ] [ [string] ] [EOL] last_messages = messages [ - [number] ] [EOL] [EOL] assert last_messages [ [string] ] [ [string] ] == owner_id [EOL] assert last_messages [ [string] ] == text [EOL] [EOL] executed = await client . execute ( [string] % last_messages [ [string] ] , context_value = requests , ) [EOL] [EOL] assert executed [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] executed = await fetch_messages ( room_id ) [EOL] messages = executed [ [string] ] [ [string] ] [ [string] ] [EOL] last_messages = messages [ - [number] ] [EOL] [EOL] assert last_messages == init_last_messages [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_viewer ( client , requests ) : [EOL] executed = await client . execute ( [string] , return_value = requests , ) [EOL] [EOL] assert executed [ [string] ] [ [string] ] is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List [EOL] import graphql [EOL] import demos [EOL] import typing [EOL] import aiopg [EOL] from typing import List [EOL] [EOL] import graphene [EOL] from graphql import ResolveInfo [EOL] from aiopg . sa . result import RowProxy [EOL] [EOL] from graph . api . models . user import User [EOL] from graph . chat . db_utils import select_messages_by_room_id [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , ] [EOL] [EOL] [EOL] class Message ( graphene . ObjectType ) : [EOL] [docstring] [EOL] id = graphene . Int ( description = [string] , ) [EOL] body = graphene . String ( description = [string] ) [EOL] favouriteCount = graphene . Int ( description = [string] , ) [EOL] [EOL] owner = graphene . Field ( User , description = [string] , ) [EOL] [EOL] async def resolve_owner ( self , info ) : [EOL] app = info . context [ [string] ] . app [EOL] [EOL] return await app [ [string] ] . users . load ( self [ [string] ] ) [EOL] [EOL] [EOL] class Room ( graphene . ObjectType ) : [EOL] [docstring] [EOL] id = graphene . Int ( description = [string] , ) [EOL] name = graphene . String ( description = [string] , ) [EOL] [EOL] owner = graphene . Field ( User , description = [string] , ) [EOL] messages = graphene . List ( Message , description = [string] , ) [EOL] [EOL] async def resolve_owner ( self , info ) : [EOL] app = info . context [ [string] ] . app [EOL] [EOL] return await app [ [string] ] . users . load ( self [ [string] ] ) [EOL] [EOL] async def resolve_messages ( self , info ) : [EOL] app = info . context [ [string] ] . app [EOL] [EOL] async with app [ [string] ] . acquire ( ) as conn : [EOL] return await select_messages_by_room_id ( conn , self [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aiopg.sa.result.RowProxy]$ 0 0 0 $graphql.ResolveInfo$ 0 0 0 0 0 $graphql.ResolveInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aiopg.sa.result.RowProxy]$ 0 0 0 $graphql.ResolveInfo$ 0 0 0 0 0 $graphql.ResolveInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type [EOL] import demos [EOL] import typing [EOL] import graphene [EOL] [EOL] from graph . api . models . user import User [EOL] [EOL] [EOL] class UserQuery ( graphene . ObjectType ) : [EOL] viewer = graphene . Field ( User , description = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from graph . api . queries . user import UserQuery [EOL] from graph . api . queries . rooms import RoomsQuery [EOL] [EOL] [EOL] class Query ( UserQuery , RoomsQuery ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import graph [EOL] import builtins [EOL] import typing [EOL] import aiopg [EOL] from aiopg . sa import SAConnection as SAConn [EOL] from aiopg . sa . result import RowProxy [EOL] [EOL] from graph . types import RowsProxy [EOL] from graph . constants import OBJECT_NOT_FOUND_ERROR [EOL] from graph . chat . tables import ( rooms , messages , ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] async def select_rooms ( conn ) : [EOL] cursor = await conn . execute ( rooms . select ( ) . order_by ( rooms . c . id ) ) [EOL] [EOL] return await cursor . fetchall ( ) [EOL] [EOL] [EOL] async def select_room ( conn , id ) : [EOL] cursor = await conn . execute ( rooms . select ( ) . where ( rooms . c . id == id ) ) [EOL] item = await cursor . fetchone ( ) [EOL] assert item , OBJECT_NOT_FOUND_ERROR [EOL] [EOL] return item [EOL] [EOL] [EOL] async def select_messages_by_room_id ( conn , room_id ) : [EOL] query = messages . select ( ) . where ( messages . c . room_id == room_id ) . order_by ( messages . c . id ) [EOL] [EOL] cursor = await conn . execute ( query ) [EOL] [EOL] return await cursor . fetchall ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] async def create_message ( conn , room_id , owner_id , body , ) : [EOL] [EOL] query = messages . insert ( ) . values ( body = body , owner_id = owner_id , room_id = room_id ) . returning ( messages . c . id , messages . c . owner_id ) [EOL] [EOL] res = await conn . execute ( query ) [EOL] [EOL] return await res . fetchone ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] async def delete_message ( conn , id ) : [EOL] [EOL] await conn . execute ( messages . delete ( ) . where ( messages . c . id == id ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graph.types.RowsProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiopg.sa.result.RowProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graph.types.RowsProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiopg.sa.result.RowProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from graph . chat . db_utils import ( select_room , select_rooms , select_messages_by_room_id , create_message , delete_message , ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_select_room ( sa_engine ) : [EOL] async with sa_engine . acquire ( ) as conn : [EOL] res = await select_room ( conn , [number] ) [EOL] [EOL] assert res . id == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_select_rooms ( sa_engine ) : [EOL] async with sa_engine . acquire ( ) as conn : [EOL] res = await select_rooms ( conn ) [EOL] [EOL] assert isinstance ( res , list ) [EOL] assert res [ [number] ] . id == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_select_messages_by_room_id ( sa_engine ) : [EOL] async with sa_engine . acquire ( ) as conn : [EOL] res = await select_messages_by_room_id ( conn , [number] ) [EOL] [EOL] assert isinstance ( res , list ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_create_message ( sa_engine ) : [EOL] async with sa_engine . acquire ( ) as conn : [EOL] await create_message ( conn , [number] , [number] , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_delete_message ( sa_engine ) : [EOL] async with sa_engine . acquire ( ) as conn : [EOL] await delete_message ( conn , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List , Any [EOL] import graph [EOL] import aiopg [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] from aiopg . sa import SAConnection [EOL] [EOL] from graph . auth . tables import users [EOL] from graph . types import RowsProxy [EOL] from aiopg . sa . result import RowProxy [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , ] [EOL] [EOL] [EOL] async def select_users ( conn , keys ) : [EOL] query = users . select ( ) . where ( users . c . id . in_ ( keys ) ) . order_by ( users . c . id ) [EOL] [EOL] cursor = await conn . execute ( query ) [EOL] [EOL] return await cursor . fetchall ( ) [EOL] [EOL] [EOL] async def select_user ( conn , key ) : [EOL] query = users . select ( ) . where ( users . c . id == key ) . order_by ( users . c . id ) [EOL] cursor = await conn . execute ( query ) [EOL] [EOL] return await cursor . fetchone ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $graph.types.RowsProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiopg.sa.result.RowProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from enum import Enum , unique [EOL] [EOL] [EOL] @ unique class UserGender ( Enum ) : [EOL] women = [string] [EOL] male = [string] [EOL] none = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
	0
import aiohttp [EOL] import builtins [EOL] from aiohttp import web [EOL] import aiohttp_jinja2 [EOL] [EOL] [EOL] @ aiohttp_jinja2 . template ( [string] ) async def index ( request ) : [EOL] return { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0
	0