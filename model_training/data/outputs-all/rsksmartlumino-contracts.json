from typing import Dict , Optional , Any , List [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] import raiden_contracts [EOL] [docstring] [EOL] import json [EOL] from copy import deepcopy [EOL] from json import JSONDecodeError [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] from eth_typing . evm import HexAddress [EOL] from mypy_extensions import TypedDict [EOL] from semver import compare [EOL] [EOL] from raiden_contracts . constants import CONTRACTS_VERSION , ID_TO_NETWORKNAME , DeploymentModule [EOL] [EOL] _BASE = Path ( __file__ ) . parent [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] CompiledContract = TypedDict ( [string] , { [string] : List [ Dict [ str , Any ] ] , [string] : str , [string] : str , [string] : str } , ) [EOL] [EOL] [EOL] DeployedContract = TypedDict ( [string] , { [string] : HexAddress , [string] : str , [string] : int , [string] : int , [string] : List [ Any ] , } , ) [EOL] [EOL] [EOL] class DeployedContracts ( TypedDict ) : [EOL] chain_id = ... [EOL] contracts = ... [EOL] contracts_version = ... [EOL] [EOL] [EOL] class ContractManagerLoadError ( RuntimeError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ContractManager : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path ) : [EOL] [docstring] [EOL] self . overall_checksum = None [EOL] self . contracts_checksums = None [EOL] try : [EOL] with path . open ( ) as precompiled_file : [EOL] precompiled_content = json . load ( precompiled_file ) [EOL] except ( JSONDecodeError , UnicodeDecodeError ) as ex : [EOL] raise ContractManagerLoadError ( f" [string] { ex }" ) from ex [EOL] try : [EOL] self . contracts = precompiled_content [ [string] ] [EOL] if not self . contracts : [EOL] raise RuntimeError ( f" [string] { path } [string] " ) [EOL] self . overall_checksum = precompiled_content [ [string] ] [EOL] self . contracts_checksums = precompiled_content [ [string] ] [EOL] self . contracts_version = precompiled_content [ [string] ] [EOL] except KeyError as ex : [EOL] raise ContractManagerLoadError ( f" [string] { ex }" ) from ex [EOL] [EOL] def get_contract ( self , contract_name ) : [EOL] [docstring] [EOL] assert self . contracts , [string] [EOL] try : [EOL] return self . contracts [ contract_name ] [EOL] except KeyError : [EOL] raise KeyError ( f" [string] { self . contracts_version } [string] { contract_name }" ) [EOL] [EOL] def get_contract_abi ( self , contract_name ) : [EOL] [docstring] [EOL] assert self . contracts , [string] [EOL] return self . contracts [ contract_name ] [ [string] ] [EOL] [EOL] def get_event_abi ( self , contract_name , event_name ) : [EOL] [docstring] [EOL] [comment] [EOL] from web3 . utils . contracts import find_matching_event_abi [EOL] [EOL] assert self . contracts , [string] [EOL] contract_abi = self . get_contract_abi ( contract_name ) [EOL] return find_matching_event_abi ( abi = contract_abi , event_name = event_name ) [EOL] [EOL] def get_constructor_argument_types ( self , contract_name ) : [EOL] abi = self . get_contract_abi ( contract_name = contract_name ) [EOL] constructor = [ f for f in abi if f [ [string] ] == [string] ] [ [number] ] [EOL] return [ arg [ [string] ] for arg in constructor [ [string] ] ] [EOL] [EOL] @ property def version_string ( self ) : [EOL] [docstring] [EOL] return contract_version_string ( self . contracts_version ) [EOL] [EOL] def get_runtime_hexcode ( self , contract_name ) : [EOL] [docstring] [EOL] return [string] + self . contracts [ contract_name ] [ [string] ] [EOL] [EOL] [EOL] def contract_version_string ( version = None ) : [EOL] [docstring] [EOL] if version is None : [EOL] version = CONTRACTS_VERSION [EOL] return version [EOL] [EOL] [EOL] def contracts_data_path ( version = None ) : [EOL] [docstring] [EOL] if version is None : [EOL] return _BASE . joinpath ( [string] ) [EOL] return _BASE . joinpath ( f" [string] { version }" ) [EOL] [EOL] [EOL] def contracts_precompiled_path ( version = None ) : [EOL] [docstring] [EOL] data_path = contracts_data_path ( version ) [EOL] return data_path . joinpath ( [string] ) [EOL] [EOL] [EOL] def contracts_gas_path ( version = None ) : [EOL] [docstring] [EOL] data_path = contracts_data_path ( version ) [EOL] return data_path . joinpath ( [string] ) [EOL] [EOL] [EOL] def contracts_deployed_path ( chain_id , version = None , services = False ) : [EOL] [docstring] [EOL] data_path = contracts_data_path ( version ) [EOL] chain_name = ID_TO_NETWORKNAME [ chain_id ] if chain_id in ID_TO_NETWORKNAME else [string] [EOL] [EOL] return data_path . joinpath ( f' [string] { [string] if services else [string] }{ chain_name } [string] ' ) [EOL] [EOL] [EOL] def merge_deployment_data ( dict1 , dict2 ) : [EOL] [docstring] [EOL] if not dict1 : [EOL] return dict2 [EOL] if not dict2 : [EOL] return dict1 [EOL] common_contracts = deepcopy ( dict1 [ [string] ] ) [EOL] assert not common_contracts . keys ( ) & dict2 [ [string] ] . keys ( ) [EOL] common_contracts . update ( dict2 [ [string] ] ) [EOL] [EOL] assert dict2 [ [string] ] == dict1 [ [string] ] [EOL] assert dict2 [ [string] ] == dict1 [ [string] ] [EOL] [EOL] return { [string] : common_contracts , [string] : dict1 [ [string] ] , [string] : dict1 [ [string] ] , } [EOL] [EOL] [EOL] def version_provides_services ( version ) : [EOL] if version is None : [EOL] return True [EOL] if version == [string] : [EOL] return False [EOL] if version == [string] : [EOL] return True [EOL] return compare ( version , [string] ) >= [number] [EOL] [EOL] [EOL] def get_contracts_deployment_info ( chain_id , version = None , module = DeploymentModule . ALL ) : [EOL] [docstring] [EOL] if module not in DeploymentModule : [EOL] raise ValueError ( f" [string] { module } [string] " ) [EOL] [EOL] def module_chosen ( to_be_added ) : [EOL] return module == to_be_added or module == DeploymentModule . ALL [EOL] [EOL] files = [ ] [EOL] [EOL] if module_chosen ( DeploymentModule . RAIDEN ) : [EOL] files . append ( contracts_deployed_path ( chain_id = chain_id , version = version , services = False ) ) [EOL] [EOL] if module == DeploymentModule . SERVICES and not version_provides_services ( version ) : [EOL] raise ValueError ( f" [string] { version } [string] { version } [string] " [string] ) [EOL] [EOL] if module_chosen ( DeploymentModule . SERVICES ) and version_provides_services ( version ) : [EOL] files . append ( contracts_deployed_path ( chain_id = chain_id , version = version , services = True ) ) [EOL] [EOL] deployment_data = { } [comment] [EOL] [EOL] for f in files : [EOL] j = _load_json_from_path ( f ) [EOL] if j is None : [EOL] continue [EOL] deployment_data = merge_deployment_data ( deployment_data , DeployedContracts ( { [string] : j [ [string] ] , [string] : j [ [string] ] , [string] : j [ [string] ] , } ) , ) [EOL] [EOL] if not deployment_data : [EOL] deployment_data = None [EOL] return deployment_data [EOL] [EOL] [EOL] def _load_json_from_path ( f ) : [EOL] try : [EOL] with f . open ( ) as deployment_file : [EOL] return json . load ( deployment_file ) [EOL] except FileNotFoundError : [EOL] return None [EOL] except ( JSONDecodeError , UnicodeDecodeError ) as ex : [EOL] raise ValueError ( f" [string] { ex }" ) from ex [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,DeployedContract]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,CompiledContract]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,CompiledContract]$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $CompiledContract$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.List$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[DeployedContracts]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Optional , Any [EOL] import builtins [EOL] import raiden_contracts [EOL] import pathlib [EOL] import typing [EOL] import eth_typing [EOL] from pathlib import Path [EOL] from typing import Optional [EOL] [EOL] import click [EOL] from eth_typing import HexAddress [EOL] from eth_utils import encode_hex [EOL] from web3 import HTTPProvider , Web3 [EOL] from web3 . middleware import construct_sign_and_send_raw_middleware [EOL] [EOL] from raiden_contracts . constants import CONTRACT_CUSTOM_TOKEN [EOL] from raiden_contracts . contract_manager import ContractManager , contracts_precompiled_path [EOL] from raiden_contracts . utils . private_key import get_private_key [EOL] from raiden_contracts . utils . signature import private_key_to_address [EOL] [EOL] WEI_TO_ETH = [number] ** [number] [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , help = [string] , default = [string] , required = True ) @ click . option ( [string] , required = True , type = click . Path ( exists = True , dir_okay = False ) ) @ click . option ( [string] , help = [string] , required = True ) @ click . option ( [string] , help = [string] , required = True , type = click . INT ) def main ( rpc_url , private_key , token_address , amount ) : [EOL] web3 = Web3 ( HTTPProvider ( rpc_url ) ) [EOL] private_key_string = get_private_key ( private_key ) [EOL] assert private_key_string is not None [EOL] owner = private_key_to_address ( private_key_string ) [EOL] web3 . middleware_stack . add ( construct_sign_and_send_raw_middleware ( private_key_string ) ) [EOL] token_code = web3 . eth . getCode ( token_address , [string] ) [EOL] assert token_code != [string] [EOL] token_contract = ContractManager ( contracts_precompiled_path ( ) ) . get_contract ( CONTRACT_CUSTOM_TOKEN ) [EOL] token_proxy = web3 . eth . contract ( address = token_address , abi = token_contract [ [string] ] ) [EOL] tx_hash = token_proxy . functions . mint ( amount ) . transact ( { [string] : owner } ) [EOL] print ( f" [string] { owner }" ) [EOL] print ( f" [string] { encode_hex ( tx_hash ) }" ) [EOL] balance = token_proxy . functions . balanceOf ( owner ) . call ( ) [EOL] print ( f" [string] { owner } [string] { balance }" ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , TextIO , Pattern , Any , List , Set [EOL] import builtins [EOL] import typing [EOL] import json [EOL] import os [EOL] import re [EOL] import sys [EOL] from typing import Dict , List , Set , TextIO [EOL] [EOL] import click [EOL] from click . types import File [EOL] [EOL] IMPORT_RE = re . compile ( [string] ) [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class ContractJoiner : [EOL] def __init__ ( self , import_map = None ) : [EOL] self . have_pragma = False [EOL] self . seen = set ( ) [EOL] self . import_map = import_map if import_map else { } [EOL] [EOL] def join ( self , contract_file ) : [EOL] out = [ ] [EOL] if contract_file . name in self . seen : [EOL] print ( [string] . format ( contract_file . name ) , file = sys . stderr ) [EOL] return [ ] [EOL] [EOL] self . seen . add ( contract_file . name ) [EOL] print ( [string] . format ( contract_file . name ) , file = sys . stderr ) [EOL] [EOL] for line in contract_file : [EOL] line = line . strip ( [string] ) [EOL] stripped_line = line . strip ( ) [EOL] if stripped_line . startswith ( [string] ) : [EOL] self . _on_pragma_line ( line = line , out = out ) [EOL] elif stripped_line . startswith ( [string] ) : [EOL] self . _on_import_line ( stripped_line = stripped_line , out = out ) [EOL] else : [EOL] out . append ( line ) [EOL] return out [EOL] [EOL] def _on_pragma_line ( self , line , out ) : [EOL] if not self . have_pragma : [EOL] self . have_pragma = True [EOL] out . append ( line ) [EOL] [EOL] def _on_import_line ( self , stripped_line , out ) : [EOL] match = IMPORT_RE . match ( stripped_line ) [EOL] if match : [EOL] next_file = match . groupdict ( ) . get ( [string] ) [EOL] assert next_file [EOL] for prefix , path in self . import_map . items ( ) : [EOL] if next_file . startswith ( prefix ) : [EOL] next_file = next_file . replace ( prefix , path ) [EOL] if next_file and os . path . exists ( next_file ) : [EOL] with open ( next_file ) as next_contract : [EOL] out . extend ( self . join ( next_contract ) ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , default = [string] , help = [string] ) @ click . argument ( [string] , type = File ( ) ) @ click . argument ( [string] , type = File ( [string] ) ) def main ( contract , output , import_map ) : [EOL] import_map_json = json . loads ( import_map ) [EOL] output . write ( [string] . join ( ContractJoiner ( import_map_json ) . join ( contract ) ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.TextIO$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.TextIO$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any [EOL] import builtins [EOL] import coincurve [EOL] import eth_utils [EOL] import typing [EOL] from typing import Union [EOL] [EOL] from coincurve import PrivateKey , PublicKey [EOL] from eth_utils import keccak , remove_0x_prefix , to_bytes , to_checksum_address [EOL] from eth_utils . typing import ChecksumAddress [EOL] [EOL] sha3 = keccak [EOL] [EOL] [EOL] def sign ( privkey , msg , v = [number] ) : [EOL] assert isinstance ( msg , bytes ) [EOL] assert isinstance ( privkey , str ) [EOL] [EOL] pk = PrivateKey . from_hex ( remove_0x_prefix ( privkey ) ) [EOL] assert len ( msg ) == [number] [EOL] [EOL] sig = pk . sign_recoverable ( msg , hasher = None ) [EOL] assert len ( sig ) == [number] [EOL] [EOL] sig = sig [ : - [number] ] + bytes ( [ sig [ - [number] ] + v ] ) [EOL] [EOL] return sig [EOL] [EOL] [EOL] def private_key_to_address ( private_key ) : [EOL] [docstring] [EOL] if isinstance ( private_key , str ) : [EOL] private_key_bytes = to_bytes ( hexstr = private_key ) [EOL] else : [EOL] private_key_bytes = private_key [EOL] pk = PrivateKey ( private_key_bytes ) [EOL] return public_key_to_address ( pk . public_key ) [EOL] [EOL] [EOL] def public_key_to_address ( public_key ) : [EOL] [docstring] [EOL] if isinstance ( public_key , PublicKey ) : [EOL] public_key = public_key . format ( compressed = False ) [EOL] assert isinstance ( public_key , bytes ) [EOL] return to_checksum_address ( sha3 ( public_key [ [number] : ] ) [ - [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $eth_utils.typing.ChecksumAddress$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $eth_utils.typing.ChecksumAddress$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import typing [EOL] import raiden_contracts [EOL] from typing import Optional [EOL] [EOL] from semver import compare [EOL] [EOL] from raiden_contracts . constants import CONTRACT_TOKEN_NETWORK_REGISTRY [EOL] from raiden_contracts . contract_manager import ContractManager , contracts_precompiled_path [EOL] [EOL] [EOL] def contracts_version_expects_deposit_limits ( contracts_version ) : [EOL] [docstring] [EOL] if contracts_version is None : [EOL] return True [EOL] if contracts_version == [string] : [EOL] return False [EOL] return compare ( contracts_version , [string] ) > - [number] [EOL] [EOL] [EOL] def contract_version_with_max_token_networks ( version ) : [EOL] manager = ContractManager ( contracts_precompiled_path ( version ) ) [EOL] abi = manager . get_contract_abi ( CONTRACT_TOKEN_NETWORK_REGISTRY ) [EOL] constructors = list ( filter ( lambda x : x [ [string] ] == [string] , abi ) ) [EOL] assert len ( constructors ) == [number] [EOL] inputs = constructors [ [number] ] [ [string] ] [EOL] max_token_networks_args = list ( filter ( lambda x : x [ [string] ] == [string] , inputs ) ) [EOL] found_args = len ( max_token_networks_args ) [EOL] if found_args == [number] : [EOL] return False [EOL] elif found_args == [number] : [EOL] return True [EOL] else : [EOL] raise ValueError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import eth_typing [EOL] import builtins [EOL] from eth_abi import encode_single [EOL] from eth_typing . evm import HexAddress [EOL] from web3 import Web3 [EOL] [EOL] from raiden_contracts . constants import MessageTypeId [EOL] [EOL] from . signature import sign [EOL] [EOL] [EOL] def hash_balance_data ( transferred_amount , locked_amount , locksroot ) : [EOL] [comment] [EOL] return Web3 . soliditySha3 ( abi_types = [ [string] , [string] , [string] ] , values = [ transferred_amount , locked_amount , locksroot ] , ) [EOL] [EOL] [EOL] def eth_sign_hash_message ( encoded_message ) : [EOL] signature_prefix = [string] [EOL] return Web3 . sha3 ( Web3 . toBytes ( text = signature_prefix ) + Web3 . toBytes ( text = str ( len ( encoded_message ) ) ) + encoded_message ) [EOL] [EOL] [EOL] def hash_balance_proof ( token_network_address , chain_identifier , channel_identifier , balance_hash , nonce , additional_hash , ) : [EOL] return eth_sign_hash_message ( Web3 . toBytes ( hexstr = token_network_address ) + encode_single ( [string] , chain_identifier ) + encode_single ( [string] , MessageTypeId . BALANCE_PROOF ) + encode_single ( [string] , channel_identifier ) + balance_hash + encode_single ( [string] , nonce ) + additional_hash ) [EOL] [EOL] [EOL] def hash_balance_proof_update_message ( token_network_address , chain_identifier , channel_identifier , balance_hash , nonce , additional_hash , closing_signature , ) : [EOL] return eth_sign_hash_message ( Web3 . toBytes ( hexstr = token_network_address ) + encode_single ( [string] , chain_identifier ) + encode_single ( [string] , MessageTypeId . BALANCE_PROOF_UPDATE ) + encode_single ( [string] , channel_identifier ) + balance_hash + encode_single ( [string] , nonce ) + additional_hash + closing_signature ) [EOL] [EOL] [EOL] def hash_cooperative_settle_message ( token_network_address , chain_identifier , channel_identifier , participant1_address , participant1_balance , participant2_address , participant2_balance , ) : [EOL] return eth_sign_hash_message ( Web3 . toBytes ( hexstr = token_network_address ) + encode_single ( [string] , chain_identifier ) + encode_single ( [string] , MessageTypeId . COOPERATIVE_SETTLE ) + encode_single ( [string] , channel_identifier ) + Web3 . toBytes ( hexstr = participant1_address ) + encode_single ( [string] , participant1_balance ) + Web3 . toBytes ( hexstr = participant2_address ) + encode_single ( [string] , participant2_balance ) ) [EOL] [EOL] [EOL] def hash_withdraw_message ( token_network_address , chain_identifier , channel_identifier , participant , amount_to_withdraw , ) : [EOL] return eth_sign_hash_message ( Web3 . toBytes ( hexstr = token_network_address ) + encode_single ( [string] , chain_identifier ) + encode_single ( [string] , MessageTypeId . WITHDRAW ) + encode_single ( [string] , channel_identifier ) + Web3 . toBytes ( hexstr = participant ) + encode_single ( [string] , amount_to_withdraw ) ) [EOL] [EOL] [EOL] def hash_reward_proof ( channel_identifier , reward_amount , token_network_address , chain_id , nonce , ) : [EOL] return eth_sign_hash_message ( encode_single ( [string] , channel_identifier ) + encode_single ( [string] , reward_amount ) + Web3 . toBytes ( hexstr = token_network_address ) + encode_single ( [string] , chain_id ) + encode_single ( [string] , nonce ) ) [EOL] [EOL] [EOL] def sign_balance_proof ( privatekey , token_network_address , chain_identifier , channel_identifier , balance_hash , nonce , additional_hash , v = [number] , ) : [EOL] message_hash = hash_balance_proof ( token_network_address = token_network_address , chain_identifier = chain_identifier , channel_identifier = channel_identifier , balance_hash = balance_hash , nonce = nonce , additional_hash = additional_hash , ) [EOL] [EOL] return sign ( privkey = privatekey , msg = message_hash , v = v ) [EOL] [EOL] [EOL] def sign_balance_proof_update_message ( privatekey , token_network_address , chain_identifier , channel_identifier , balance_hash , nonce , additional_hash , closing_signature , v = [number] , ) : [EOL] message_hash = hash_balance_proof_update_message ( token_network_address = token_network_address , chain_identifier = chain_identifier , channel_identifier = channel_identifier , balance_hash = balance_hash , nonce = nonce , additional_hash = additional_hash , closing_signature = closing_signature , ) [EOL] [EOL] return sign ( privkey = privatekey , msg = message_hash , v = v ) [EOL] [EOL] [EOL] def sign_cooperative_settle_message ( privatekey , token_network_address , chain_identifier , channel_identifier , participant1_address , participant1_balance , participant2_address , participant2_balance , v = [number] , ) : [EOL] message_hash = hash_cooperative_settle_message ( token_network_address = token_network_address , chain_identifier = chain_identifier , channel_identifier = channel_identifier , participant1_address = participant1_address , participant1_balance = participant1_balance , participant2_address = participant2_address , participant2_balance = participant2_balance , ) [EOL] [EOL] return sign ( privkey = privatekey , msg = message_hash , v = v ) [EOL] [EOL] [EOL] def sign_withdraw_message ( privatekey , token_network_address , chain_identifier , channel_identifier , participant , amount_to_withdraw , v = [number] , ) : [EOL] message_hash = hash_withdraw_message ( token_network_address = token_network_address , chain_identifier = chain_identifier , channel_identifier = channel_identifier , participant = participant , amount_to_withdraw = amount_to_withdraw , ) [EOL] [EOL] return sign ( privkey = privatekey , msg = message_hash , v = v ) [EOL] [EOL] [EOL] def sign_reward_proof ( privatekey , channel_identifier , reward_amount , token_network_address , chain_id , nonce , v = [number] , ) : [EOL] message_hash = hash_reward_proof ( channel_identifier = channel_identifier , reward_amount = reward_amount , token_network_address = token_network_address , chain_id = chain_id , nonce = nonce , ) [EOL] [EOL] return sign ( privkey = privatekey , msg = message_hash , v = v ) [EOL] [EOL] [EOL] def sign_one_to_n_iou ( privatekey , sender , receiver , amount , expiration_block , one_to_n_address , chain_id , v = [number] , ) : [EOL] iou_hash = eth_sign_hash_message ( Web3 . toBytes ( hexstr = sender ) + Web3 . toBytes ( hexstr = receiver ) + encode_single ( [string] , amount ) + encode_single ( [string] , expiration_block ) + Web3 . toBytes ( hexstr = one_to_n_address ) + encode_single ( [string] , chain_id ) ) [EOL] return sign ( privkey = privatekey , msg = iou_hash , v = v ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from . events import * [EOL] from . logs import * [EOL] from . merkle import * [EOL] from . pending_transfers import * [EOL] from . proofs import * [EOL] from . signature import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , Tuple [EOL] import web3 [EOL] import builtins [EOL] import typing [EOL] from typing import Any , Dict , Optional , Tuple [EOL] [EOL] from web3 import Web3 [EOL] from web3 . utils . threads import Timeout [EOL] [EOL] [EOL] def check_successful_tx ( web3 , txid , timeout = [number] ) : [EOL] [docstring] [EOL] receipt = wait_for_transaction_receipt ( web3 = web3 , txid = txid , timeout = timeout ) [EOL] if receipt is None : [EOL] raise RuntimeError ( [string] ) [EOL] txinfo = web3 . eth . getTransaction ( txid ) [EOL] if [string] not in receipt : [EOL] raise KeyError ( [string] [string] ) [EOL] if receipt [ [string] ] == [number] : [EOL] raise ValueError ( f" [string] " ) [EOL] if txinfo [ [string] ] == receipt [ [string] ] : [EOL] raise ValueError ( f' [string] { txinfo [ [string] ] } [string] ' ) [EOL] return ( receipt , txinfo ) [EOL] [EOL] [EOL] def wait_for_transaction_receipt ( web3 , txid , timeout = [number] ) : [EOL] receipt = None [EOL] with Timeout ( timeout ) as time : [EOL] while not receipt or not receipt [ [string] ] : [comment] [EOL] try : [EOL] receipt = web3 . eth . getTransactionReceipt ( txid ) [EOL] except ValueError as ex : [EOL] if str ( ex ) . find ( [string] ) != - [number] : [EOL] pass [comment] [EOL] else : [EOL] raise ex [EOL] time . sleep ( [number] ) [EOL] [EOL] return receipt [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[builtins.str,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Iterable , Iterator , Any , List [EOL] import builtins [EOL] import typing [EOL] import raiden_contracts [EOL] from itertools import zip_longest [EOL] from typing import Iterable , List , NamedTuple [EOL] [EOL] from eth_utils import keccak [EOL] [EOL] EMPTY_MERKLE_ROOT = [string] * [number] [EOL] [EOL] MerkleTree = NamedTuple ( [string] , [ ( [string] , List [ List [ bytes ] ] ) ] ) [EOL] [EOL] [EOL] def _hash_pair ( first , second ) : [EOL] [docstring] [EOL] if first is None : [EOL] return second [EOL] [EOL] if second is None : [EOL] return first [EOL] [EOL] if first > second : [EOL] ret = keccak ( second + first ) [EOL] else : [EOL] ret = keccak ( first + second ) [EOL] [EOL] return ret [EOL] [EOL] [EOL] def compute_merkle_tree ( items ) : [EOL] [docstring] [EOL] [EOL] if not all ( isinstance ( l , bytes ) and len ( l ) == [number] for l in items ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] leaves = sorted ( items ) [EOL] if len ( leaves ) == [number] : [EOL] return MerkleTree ( layers = [ [ EMPTY_MERKLE_ROOT ] ] ) [EOL] [EOL] if not len ( leaves ) == len ( set ( leaves ) ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] tree = [ leaves ] [EOL] layer = leaves [EOL] while len ( layer ) > [number] : [EOL] [comment] [EOL] iterator = iter ( layer ) [EOL] paired_items = zip_longest ( iterator , iterator ) [EOL] [EOL] layer = [ _hash_pair ( a , b ) for a , b in paired_items ] [EOL] tree . append ( layer ) [EOL] [EOL] return MerkleTree ( layers = tree ) [EOL] [EOL] [EOL] def get_merkle_root ( merkle_tree ) : [EOL] [docstring] [EOL] assert merkle_tree . layers , [string] [EOL] assert merkle_tree . layers [ - [number] ] , [string] [EOL] [EOL] return merkle_tree . layers [ - [number] ] [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Type[raiden_contracts.utils.merkle.MerkleTree]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MerkleTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden_contracts.utils.merkle.MerkleTree]$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden_contracts.utils.merkle.MerkleTree]$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
from typing import Dict , Optional , Any [EOL] import builtins [EOL] import raiden_contracts [EOL] import click [EOL] import typing [EOL] import eth_typing [EOL] import logging [EOL] [docstring] [EOL] import functools [EOL] import json [EOL] import logging [EOL] from logging import getLogger [EOL] from pathlib import Path [EOL] from typing import Any , Optional , Union [EOL] [EOL] import click [EOL] from click import BadParameter , Context , Option , Parameter [EOL] from eth_typing . evm import ChecksumAddress , HexAddress [EOL] from eth_utils import is_address , to_checksum_address [EOL] from web3 import HTTPProvider , Web3 [EOL] from web3 . middleware import geth_poa_middleware [EOL] [EOL] from raiden_contracts . constants import CONTRACT_CUSTOM_TOKEN , CONTRACT_TOKEN_NETWORK_REGISTRY [EOL] from raiden_contracts . deploy . contract_deployer import ContractDeployer [EOL] from raiden_contracts . deploy . contract_verifier import ContractVerifier [EOL] from raiden_contracts . utils . private_key import get_private_key [EOL] from raiden_contracts . utils . signature import private_key_to_address [EOL] from raiden_contracts . utils . versions import contract_version_with_max_token_networks [EOL] [EOL] LOG = getLogger ( __name__ ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] def setup_ctx ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version = None , ) : [EOL] [docstring] [EOL] [EOL] if private_key is None : [EOL] return [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . INFO ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . INFO ) [EOL] [EOL] web3 = Web3 ( HTTPProvider ( rpc_provider , request_kwargs = { [string] : [number] } ) ) [EOL] web3 . middleware_stack . inject ( geth_poa_middleware , layer = [number] ) [EOL] print ( [string] , web3 . providers [ [number] ] ) [EOL] private_key_string = get_private_key ( Path ( private_key ) ) [EOL] if not private_key_string : [EOL] raise RuntimeError ( [string] ) [EOL] owner = private_key_to_address ( private_key_string ) [EOL] [comment] [EOL] if web3 . eth . getBalance ( owner ) == [number] : [EOL] raise RuntimeError ( [string] ) [EOL] deployer = ContractDeployer ( web3 = web3 , private_key = private_key_string , gas_limit = gas_limit , gas_price = gas_price , wait = wait , contracts_version = contracts_version , ) [EOL] ctx . obj = { } [EOL] ctx . obj [ [string] ] = deployer [EOL] ctx . obj [ [string] ] = { } [EOL] ctx . obj [ [string] ] = [string] [EOL] ctx . obj [ [string] ] = wait [EOL] [EOL] [EOL] @ click . group ( chain = True ) def main ( ) : [EOL] pass [EOL] [EOL] [EOL] def check_version_dependent_parameters ( contracts_version , max_token_networks ) : [EOL] required = contract_version_with_max_token_networks ( contracts_version ) [EOL] got = max_token_networks is not None [EOL] [EOL] [comment] [EOL] if required and not got : [EOL] raise BadParameter ( f" [string] { contracts_version } [string] " [string] ) [EOL] [comment] [EOL] if not required and got : [EOL] raise BadParameter ( f" [string] { contracts_version } [string] " [string] [string] ) [EOL] [EOL] [EOL] [EOL] def raiden ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , save_info , contracts_version , max_token_networks , ) : [EOL] check_version_dependent_parameters ( contracts_version , max_token_networks ) [EOL] [EOL] setup_ctx ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version ) [EOL] deployer = ctx . obj [ [string] ] [EOL] deployed_contracts_info = deployer . deploy_raiden_contracts ( max_num_of_token_networks = max_token_networks ) [EOL] deployed_contracts = { contract_name : info [ [string] ] for contract_name , info in deployed_contracts_info [ [string] ] . items ( ) } [EOL] [EOL] if save_info : [EOL] deployer . store_and_verify_deployment_info_raiden ( deployed_contracts_info = deployed_contracts_info ) [EOL] else : [EOL] deployer . verify_deployment_data ( deployed_contracts_info = deployed_contracts_info ) [EOL] [EOL] print ( json . dumps ( deployed_contracts , indent = [number] ) ) [EOL] ctx . obj [ [string] ] . update ( deployed_contracts ) [EOL] [EOL] [EOL] def services ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , token_address , save_info , contracts_version , user_deposit_whole_limit , ) : [EOL] setup_ctx ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version ) [EOL] deployer = ctx . obj [ [string] ] [EOL] [EOL] deployed_contracts_info = deployer . deploy_service_contracts ( token_address = token_address , user_deposit_whole_balance_limit = user_deposit_whole_limit ) [EOL] deployed_contracts = { contract_name : info [ [string] ] for contract_name , info in deployed_contracts_info [ [string] ] . items ( ) } [EOL] [EOL] if save_info : [EOL] deployer . store_and_verify_deployment_info_services ( deployed_contracts_info = deployed_contracts_info , token_address = token_address , user_deposit_whole_balance_limit = user_deposit_whole_limit , ) [EOL] else : [EOL] deployer . verify_service_contracts_deployment_data ( deployed_contracts_info = deployed_contracts_info , token_address = token_address , user_deposit_whole_balance_limit = user_deposit_whole_limit , ) [EOL] [EOL] print ( json . dumps ( deployed_contracts , indent = [number] ) ) [EOL] ctx . obj [ [string] ] . update ( deployed_contracts ) [EOL] [EOL] [EOL] [EOL] def token ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version , token_supply , token_name , token_decimals , token_symbol , ) : [EOL] setup_ctx ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version ) [EOL] deployer = ctx . obj [ [string] ] [EOL] token_supply *= [number] ** token_decimals [EOL] deployed_token = deployer . deploy_token_contract ( token_supply , token_decimals , token_name , token_symbol , token_type = ctx . obj [ [string] ] ) [EOL] print ( json . dumps ( deployed_token , indent = [number] ) ) [EOL] ctx . obj [ [string] ] . update ( deployed_token ) [EOL] [EOL] [EOL] [EOL] def register ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version , token_address , token_network_registry_address , channel_participant_deposit_limit , token_network_deposit_limit , registry_address , ) : [EOL] assert registry_address is None [comment] [EOL] setup_ctx ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version ) [EOL] token_type = ctx . obj [ [string] ] [EOL] deployer = ctx . obj [ [string] ] [EOL] [EOL] if token_address : [EOL] ctx . obj [ [string] ] [ token_type ] = token_address [EOL] if token_network_registry_address : [EOL] ctx . obj [ [string] ] [ CONTRACT_TOKEN_NETWORK_REGISTRY ] = token_network_registry_address [EOL] [EOL] if CONTRACT_TOKEN_NETWORK_REGISTRY not in ctx . obj [ [string] ] : [EOL] raise RuntimeError ( [string] [string] ) [EOL] assert token_type in ctx . obj [ [string] ] [EOL] abi = deployer . contract_manager . get_contract_abi ( CONTRACT_TOKEN_NETWORK_REGISTRY ) [EOL] deployer . register_token_network ( token_registry_abi = abi , token_registry_address = ctx . obj [ [string] ] [ CONTRACT_TOKEN_NETWORK_REGISTRY ] , token_address = ctx . obj [ [string] ] [ token_type ] , channel_participant_deposit_limit = channel_participant_deposit_limit , token_network_deposit_limit = token_network_deposit_limit , ) [EOL] [EOL] [EOL] [EOL] def verify ( _ , rpc_provider , contracts_version ) : [EOL] web3 = Web3 ( HTTPProvider ( rpc_provider , request_kwargs = { [string] : [number] } ) ) [EOL] web3 . middleware_stack . inject ( geth_poa_middleware , layer = [number] ) [EOL] print ( [string] , web3 . providers [ [number] ] ) [EOL] [EOL] verifier = ContractVerifier ( web3 = web3 , contracts_version = contracts_version ) [EOL] verifier . verify_deployed_contracts_in_filesystem ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
from typing import Callable , Any [EOL] import web3 [EOL] import eth_typing [EOL] import builtins [EOL] import typing [EOL] from typing import Callable [EOL] [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from eth_typing . evm import HexAddress [EOL] from web3 import Web3 [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import ( MAX_ETH_CHANNEL_PARTICIPANT , MAX_ETH_TOKEN_NETWORK , TEST_SETTLE_TIMEOUT_MAX , TEST_SETTLE_TIMEOUT_MIN , ParticipantInfoIndex , ) [EOL] [EOL] [EOL] def test_register_three_but_not_four ( web3 , get_token_network_registry , secret_registry_contract , custom_token_factory , channel_participant_deposit_limit , token_network_deposit_limit , ) : [EOL] [docstring] [EOL] token_network_registry = get_token_network_registry ( [ secret_registry_contract . address , int ( web3 . version . network ) , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , [number] , ] ) [EOL] assert token_network_registry . functions . max_token_networks ( ) . call ( ) == [number] [EOL] token0 = custom_token_factory ( ) [EOL] token1 = custom_token_factory ( ) [EOL] token2 = custom_token_factory ( ) [EOL] token3 = custom_token_factory ( ) [EOL] token_network_registry . functions . createERC20TokenNetwork ( token0 . address , channel_participant_deposit_limit , token_network_deposit_limit ) . call_and_transact ( ) [EOL] token_network_registry . functions . createERC20TokenNetwork ( token1 . address , channel_participant_deposit_limit , token_network_deposit_limit ) . call_and_transact ( ) [EOL] token_network_registry . functions . createERC20TokenNetwork ( token2 . address , channel_participant_deposit_limit , token_network_deposit_limit ) . call_and_transact ( ) [EOL] with pytest . raises ( TransactionFailed ) : [EOL] token_network_registry . functions . createERC20TokenNetwork ( token3 . address , channel_participant_deposit_limit , token_network_deposit_limit ) . call ( ) [EOL] [EOL] [EOL] def test_channel_participant_deposit_limit_value ( token_network ) : [EOL] [docstring] [EOL] limit = token_network . functions . channel_participant_deposit_limit ( ) . call ( ) [EOL] assert limit == MAX_ETH_CHANNEL_PARTICIPANT [EOL] [EOL] [EOL] def test_network_deposit_limit_value ( token_network ) : [EOL] [docstring] [EOL] limit = token_network . functions . token_network_deposit_limit ( ) . call ( ) [EOL] assert limit == MAX_ETH_TOKEN_NETWORK [EOL] [EOL] [EOL] def test_participant_deposit_limit ( get_accounts , token_network , create_channel , assign_tokens , ) : [EOL] [docstring] [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] deposit_A = [number] [EOL] deposit_B = [number] [EOL] channel_identifier = create_channel ( A , B ) [ [number] ] [EOL] assign_tokens ( A , MAX_ETH_CHANNEL_PARTICIPANT + [number] ) [EOL] assign_tokens ( B , MAX_ETH_CHANNEL_PARTICIPANT + [number] ) [EOL] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] token_network . functions . setTotalDeposit ( channel_identifier , A , MAX_ETH_CHANNEL_PARTICIPANT + [number] , B ) . call ( { [string] : A } ) [EOL] with pytest . raises ( TransactionFailed ) : [EOL] token_network . functions . setTotalDeposit ( channel_identifier , B , MAX_ETH_CHANNEL_PARTICIPANT + [number] , A ) . call ( { [string] : B } ) [EOL] [EOL] [comment] [EOL] token_network . functions . setTotalDeposit ( channel_identifier , A , deposit_A , B ) . call_and_transact ( { [string] : A } ) [EOL] info_A = token_network . functions . getChannelParticipantInfo ( channel_identifier , A , B ) . call ( ) [EOL] assert info_A [ ParticipantInfoIndex . DEPOSIT ] == deposit_A [EOL] [EOL] info_B = token_network . functions . setTotalDeposit ( channel_identifier , B , deposit_B , A ) . call_and_transact ( { [string] : B } ) [EOL] info_B = token_network . functions . getChannelParticipantInfo ( channel_identifier , B , A ) . call ( ) [EOL] assert info_B [ ParticipantInfoIndex . DEPOSIT ] == deposit_B [EOL] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] token_network . functions . setTotalDeposit ( channel_identifier , A , MAX_ETH_CHANNEL_PARTICIPANT + [number] , B ) . call ( { [string] : A } ) [EOL] with pytest . raises ( TransactionFailed ) : [EOL] token_network . functions . setTotalDeposit ( channel_identifier , B , MAX_ETH_CHANNEL_PARTICIPANT + [number] , A ) . call ( { [string] : B } ) [EOL] [EOL] token_network . functions . setTotalDeposit ( channel_identifier , A , MAX_ETH_CHANNEL_PARTICIPANT , B ) . call_and_transact ( { [string] : A } ) [EOL] token_network . functions . setTotalDeposit ( channel_identifier , B , MAX_ETH_CHANNEL_PARTICIPANT , A ) . call_and_transact ( { [string] : B } ) [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_network_deposit_limit ( create_account , custom_token , token_network , create_channel , assign_tokens , ) : [EOL] last_deposit = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] MAX_ETH_TOKEN_NETWORK_TESTING = int ( [number] * [number] ** [number] ) [EOL] [EOL] def remaining ( ) : [EOL] return ( MAX_ETH_TOKEN_NETWORK_TESTING - custom_token . functions . balanceOf ( token_network . address ) . call ( ) - last_deposit ) [EOL] [EOL] def send_remaining ( channel_identifier , participant1 , participant2 ) : [EOL] remaining_to_reach_limit = remaining ( ) [EOL] assign_tokens ( participant1 , remaining_to_reach_limit ) [EOL] token_network . functions . setTotalDeposit ( channel_identifier , participant1 , remaining_to_reach_limit , participant2 ) . call_and_transact ( { [string] : participant1 } ) [EOL] [EOL] remaining_to_reach_limit = remaining ( ) [EOL] while remaining_to_reach_limit > [number] : [EOL] A = create_account ( ) [EOL] B = create_account ( ) [EOL] assign_tokens ( A , MAX_ETH_CHANNEL_PARTICIPANT ) [EOL] assign_tokens ( B , MAX_ETH_CHANNEL_PARTICIPANT ) [EOL] channel_identifier = create_channel ( A , B ) [ [number] ] [EOL] [EOL] try : [EOL] token_network . functions . setTotalDeposit ( channel_identifier , A , MAX_ETH_CHANNEL_PARTICIPANT , B ) . call_and_transact ( { [string] : A } ) [EOL] except TransactionFailed : [EOL] send_remaining ( channel_identifier , A , B ) [EOL] break [EOL] [EOL] try : [EOL] token_network . functions . setTotalDeposit ( channel_identifier , B , MAX_ETH_CHANNEL_PARTICIPANT , A ) . call_and_transact ( { [string] : B } ) [EOL] except TransactionFailed : [EOL] send_remaining ( channel_identifier , B , A ) [EOL] break [EOL] [EOL] remaining_to_reach_limit = remaining ( ) [EOL] [EOL] assert ( MAX_ETH_TOKEN_NETWORK_TESTING - custom_token . functions . balanceOf ( token_network . address ) . call ( ) == last_deposit ) [EOL] [EOL] A = create_account ( ) [EOL] B = create_account ( ) [EOL] assign_tokens ( A , last_deposit + [number] ) [EOL] channel_identifier = create_channel ( A , B ) [ [number] ] [EOL] [EOL] token_network . functions . setTotalDeposit ( channel_identifier , A , last_deposit , B ) . call_and_transact ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] token_network . functions . setTotalDeposit ( channel_identifier , A , [number] , B ) . call ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] C = create_account ( ) [EOL] D = create_account ( ) [EOL] with pytest . raises ( TransactionFailed ) : [EOL] create_channel ( C , D ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , Tuple [EOL] import unittest [EOL] import builtins [EOL] import typing [EOL] import raiden_contracts [EOL] from typing import Optional [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] from eth_typing import HexAddress [EOL] [EOL] from raiden_contracts . constants import CONTRACTS_VERSION , DeploymentModule [EOL] from raiden_contracts . contract_manager import ( contracts_data_path , contracts_deployed_path , get_contracts_deployment_info , version_provides_services , ) [EOL] from raiden_contracts . deploy . contract_verifier import ContractVerifier [EOL] from raiden_contracts . tests . utils . constants import EMPTY_ADDRESS [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None , CONTRACTS_VERSION ] ) def test_deploy_data_dir_exists ( version ) : [EOL] [docstring] [EOL] assert contracts_data_path ( version ) . exists ( ) , [string] [EOL] assert contracts_data_path ( version ) . is_dir ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None , CONTRACTS_VERSION ] ) def test_deploy_data_dir_is_not_nested ( version ) : [EOL] [docstring] [EOL] assert list ( contracts_data_path ( version ) . glob ( [string] ) ) == [ ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None , CONTRACTS_VERSION ] ) @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] ] ) @ pytest . mark . parametrize ( [string] , [ False , True ] ) def test_deploy_data_file_exists ( version , chain_id , services ) : [EOL] [docstring] [EOL] assert contracts_deployed_path ( chain_id , version , services ) . exists ( ) [EOL] [EOL] [EOL] def reasonable_deployment_of_a_contract ( deployed ) : [EOL] [docstring] [EOL] assert isinstance ( deployed [ [string] ] , str ) [EOL] assert len ( deployed [ [string] ] ) == [number] [EOL] assert isinstance ( deployed [ [string] ] , str ) [EOL] assert len ( deployed [ [string] ] ) == [number] [EOL] assert isinstance ( deployed [ [string] ] , int ) [EOL] assert deployed [ [string] ] > [number] [EOL] assert isinstance ( deployed [ [string] ] , int ) [EOL] assert deployed [ [string] ] > [number] [EOL] assert isinstance ( deployed [ [string] ] , list ) [EOL] [EOL] [EOL] RAIDEN_CONTRACT_NAMES = ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None ] ) @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] ] ) def test_deploy_data_has_fields_raiden ( version , chain_id ) : [EOL] data = get_contracts_deployment_info ( chain_id , version , module = DeploymentModule . RAIDEN ) [EOL] assert data [EOL] assert data [ [string] ] == version if version else CONTRACTS_VERSION [EOL] assert data [ [string] ] == chain_id [EOL] contracts = data [ [string] ] [EOL] for name in RAIDEN_CONTRACT_NAMES : [EOL] deployed = contracts [ name ] [EOL] reasonable_deployment_of_a_contract ( deployed ) [EOL] [EOL] [EOL] SERVICE_CONTRACT_NAMES = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None ] ) @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] ] ) def test_deploy_data_has_fields_services ( version , chain_id ) : [EOL] data = get_contracts_deployment_info ( chain_id , version , module = DeploymentModule . SERVICES ) [EOL] assert data [EOL] assert data [ [string] ] == version if version else CONTRACTS_VERSION [EOL] assert data [ [string] ] == chain_id [EOL] contracts = data [ [string] ] [EOL] for name in SERVICE_CONTRACT_NAMES : [EOL] deployed = contracts [ name ] [EOL] reasonable_deployment_of_a_contract ( deployed ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None ] ) @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] ] ) def test_deploy_data_all ( version , chain_id ) : [EOL] data_all = get_contracts_deployment_info ( chain_id , version , module = DeploymentModule . ALL ) [EOL] data_default = get_contracts_deployment_info ( chain_id , version ) [EOL] assert data_all [EOL] assert data_all == data_default [EOL] [EOL] for name in RAIDEN_CONTRACT_NAMES + SERVICE_CONTRACT_NAMES : [EOL] deployed = data_all [ [string] ] [ name ] [EOL] reasonable_deployment_of_a_contract ( deployed ) [EOL] [EOL] [EOL] def test_deploy_data_unknown_module ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] get_contracts_deployment_info ( [number] , None , module = None ) [comment] [EOL] [EOL] [EOL] def test_deploy_data_not_deployed ( ) : [EOL] assert get_contracts_deployment_info ( [number] , [string] , module = DeploymentModule . RAIDEN ) is None [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ] ) def test_deploy_data_for_redeyes_succeed ( chain_id ) : [EOL] [docstring] [EOL] assert get_contracts_deployment_info ( chain_id , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] ] ) def test_service_deploy_data_for_redeyes_fail ( chain_id ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] assert get_contracts_deployment_info ( chain_id , [string] , DeploymentModule . SERVICES ) [EOL] [EOL] [EOL] def test_version_provides_services ( ) : [EOL] assert not version_provides_services ( [string] ) [EOL] assert not version_provides_services ( [string] ) [EOL] assert version_provides_services ( [string] ) [EOL] assert version_provides_services ( [string] ) [EOL] assert version_provides_services ( [string] ) [EOL] assert version_provides_services ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] assert version_provides_services ( [string] ) [EOL] [EOL] [EOL] def test_verify_nonexistent_deployment ( user_deposit_whole_balance_limit , ) : [EOL] [docstring] [EOL] web3_mock = Mock ( ) [EOL] web3_mock . version . network = [number] [EOL] [comment] [EOL] verifier = ContractVerifier ( web3 = web3_mock , contracts_version = [string] ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] verifier . verify_deployed_contracts_in_filesystem ( ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] verifier . verify_deployed_service_contracts_in_filesystem ( token_address = EMPTY_ADDRESS , user_deposit_whole_balance_limit = user_deposit_whole_balance_limit , ) [EOL] [EOL] [EOL] def test_verify_existent_deployment ( ) : [EOL] [docstring] [EOL] web3_mock = Mock ( ) [EOL] web3_mock . version . network = [number] [EOL] web3_mock . eth . getTransactionReceipt = lambda _ : { [string] : [number] } [EOL] verifier = ContractVerifier ( web3 = web3_mock , contracts_version = [string] ) [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) : [EOL] verifier . verify_deployed_contracts_in_filesystem ( ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] verifier . verify_deployed_service_contracts_in_filesystem ( token_address = HexAddress ( [string] ) , user_deposit_whole_balance_limit = [number] ** [number] - [number] , ) [EOL] [EOL] [EOL] def test_verify_existent_deployment_with_wrong_code ( ) : [EOL] [docstring] [EOL] web3_mock = Mock ( ) [EOL] web3_mock . version . network = [number] [EOL] web3_mock . eth . getTransactionReceipt = lambda _ : { [string] : [number] , [string] : [number] , [string] : [string] , } [EOL] verifier = ContractVerifier ( web3 = web3_mock , contracts_version = [string] ) [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) : [EOL] verifier . verify_deployed_contracts_in_filesystem ( ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] verifier . verify_deployed_service_contracts_in_filesystem ( token_address = HexAddress ( [string] ) , user_deposit_whole_balance_limit = [number] ** [number] - [number] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any , Tuple [EOL] import web3 [EOL] import builtins [EOL] import typing [EOL] from typing import Callable , Tuple [EOL] [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from web3 import Web3 [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACTS_VERSION , UserDepositEvent [EOL] [EOL] [EOL] def test_deposit ( user_deposit_contract , custom_token , get_accounts ) : [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] custom_token . functions . mint ( [number] ) . call_and_transact ( { [string] : A } ) [EOL] custom_token . functions . approve ( user_deposit_contract . address , [number] ) . call_and_transact ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] user_deposit_contract . functions . deposit ( A , [number] ) . call_and_transact ( { [string] : A } ) [EOL] assert user_deposit_contract . functions . balances ( A ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . total_deposit ( A ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( A ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( user_deposit_contract . address ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] user_deposit_contract . functions . deposit ( A , [number] ) . call_and_transact ( { [string] : A } ) [EOL] assert user_deposit_contract . functions . balances ( A ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . total_deposit ( A ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( A ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( user_deposit_contract . address ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] user_deposit_contract . functions . deposit ( A , [number] ) . call ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] user_deposit_contract . functions . deposit ( B , [number] ) . call_and_transact ( { [string] : A } ) [EOL] assert user_deposit_contract . functions . balances ( B ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . total_deposit ( B ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( A ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( user_deposit_contract . address ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] user_deposit_contract . functions . deposit ( A , [number] ) . call ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] limit = user_deposit_contract . functions . whole_balance_limit ( ) . call ( ) [EOL] assert limit > [number] [EOL] custom_token . functions . mint ( limit + [number] ) . call_and_transact ( { [string] : A } ) [EOL] custom_token . functions . approve ( user_deposit_contract . address , limit + [number] ) . call_and_transact ( { [string] : A } ) [EOL] with pytest . raises ( TransactionFailed ) : [EOL] user_deposit_contract . functions . deposit ( A , limit + [number] ) . call ( { [string] : A } ) [EOL] [EOL] [EOL] def test_transfer ( uninitialized_user_deposit_contract , udc_transfer_contract , get_accounts , event_handler , custom_token , ) : [EOL] user_deposit_contract = uninitialized_user_deposit_contract [EOL] ev_handler = event_handler ( user_deposit_contract ) [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] custom_token . functions . mint ( [number] ) . call_and_transact ( { [string] : A } ) [EOL] custom_token . functions . approve ( user_deposit_contract . address , [number] ) . call_and_transact ( { [string] : A } ) [EOL] user_deposit_contract . functions . deposit ( A , [number] ) . call_and_transact ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] udc_transfer_contract . functions . transfer ( A , B , [number] ) . call ( ) [EOL] [EOL] [comment] [EOL] user_deposit_contract . functions . init ( udc_transfer_contract . address , udc_transfer_contract . address ) . call_and_transact ( ) [EOL] tx_hash = udc_transfer_contract . functions . transfer ( A , B , [number] ) . call_and_transact ( ) [EOL] ev_handler . assert_event ( tx_hash , UserDepositEvent . BALANCE_REDUCED , dict ( owner = A , newBalance = [number] ) ) [EOL] assert user_deposit_contract . functions . balances ( A ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . balances ( B ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] assert not udc_transfer_contract . functions . transfer ( A , B , [number] ) . call ( ) [EOL] [EOL] [comment] [EOL] assert udc_transfer_contract . functions . transfer ( B , A , [number] ) . call ( ) [EOL] assert not udc_transfer_contract . functions . transfer ( B , A , [number] ) . call ( ) [EOL] [EOL] [EOL] def test_deposit_after_transfer ( uninitialized_user_deposit_contract , udc_transfer_contract , custom_token , get_accounts , ) : [EOL] [docstring] [EOL] user_deposit_contract = uninitialized_user_deposit_contract [EOL] user_deposit_contract . functions . init ( udc_transfer_contract . address , udc_transfer_contract . address ) . call_and_transact ( ) [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] custom_token . functions . mint ( [number] ) . call_and_transact ( { [string] : A } ) [EOL] custom_token . functions . approve ( user_deposit_contract . address , [number] ) . call_and_transact ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] user_deposit_contract . functions . deposit ( A , [number] ) . call_and_transact ( { [string] : A } ) [EOL] udc_transfer_contract . functions . transfer ( A , B , [number] ) . call_and_transact ( ) [EOL] assert user_deposit_contract . functions . balances ( A ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . total_deposit ( A ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( A ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( user_deposit_contract . address ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] user_deposit_contract . functions . deposit ( A , [number] ) . call_and_transact ( { [string] : A } ) [EOL] assert user_deposit_contract . functions . balances ( A ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . total_deposit ( A ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( A ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( user_deposit_contract . address ) . call ( ) == [number] [EOL] [EOL] [EOL] def test_withdraw ( user_deposit_contract , deposit_to_udc , get_accounts , web3 , event_handler , ) : [EOL] [docstring] [EOL] ev_handler = event_handler ( user_deposit_contract ) [EOL] ( A , ) = get_accounts ( [number] ) [EOL] deposit_to_udc ( A , [number] ) [EOL] assert user_deposit_contract . functions . balances ( A ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . effectiveBalance ( A ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] tx_hash = user_deposit_contract . functions . planWithdraw ( [number] ) . call_and_transact ( { [string] : A } ) [EOL] ev_handler . assert_event ( tx_hash , UserDepositEvent . WITHDRAW_PLANNED , dict ( withdrawer = A , plannedBalance = [number] ) ) [EOL] assert user_deposit_contract . functions . balances ( A ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . effectiveBalance ( A ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] withdraw_delay = user_deposit_contract . functions . withdraw_delay ( ) . call ( ) [EOL] web3 . testing . mine ( withdraw_delay - [number] ) [EOL] with pytest . raises ( TransactionFailed ) : [EOL] user_deposit_contract . functions . withdraw ( [number] ) . call ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] web3 . testing . mine ( [number] ) [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] user_deposit_contract . functions . withdraw ( [number] ) . call ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] user_deposit_contract . functions . withdraw ( [number] ) . call_and_transact ( { [string] : A } ) [EOL] assert user_deposit_contract . functions . balances ( A ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . effectiveBalance ( A ) . call ( ) == [number] [EOL] [EOL] [EOL] def test_version ( user_deposit_contract ) : [EOL] [docstring] [EOL] version = user_deposit_contract . functions . contract_version ( ) . call ( ) [EOL] assert version == CONTRACTS_VERSION [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import web3 [EOL] import typing [EOL] import pytest [EOL] from eth_abi import encode_single [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from eth_utils import to_checksum_address [EOL] from web3 import Web3 [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import TEST_SETTLE_TIMEOUT_MIN , MonitoringServiceEvent [EOL] from raiden_contracts . tests . utils . constants import EMPTY_LOCKSROOT [EOL] [EOL] REWARD_AMOUNT = [number] [EOL] [EOL] [EOL] @ pytest . fixture def ms_address ( get_accounts , custom_token , service_registry ) : [EOL] ( ms , ) = get_accounts ( [number] ) [EOL] [EOL] [comment] [EOL] custom_token . functions . mint ( [number] ) . call_and_transact ( { [string] : ms } ) [EOL] custom_token . functions . approve ( service_registry . address , [number] ) . call_and_transact ( { [string] : ms } ) [EOL] service_registry . functions . deposit ( [number] ) . call_and_transact ( { [string] : ms } ) [EOL] [EOL] return ms [EOL] [EOL] [EOL] @ pytest . fixture def monitor_data ( get_accounts , deposit_to_udc , create_channel , create_balance_proof , create_balance_proof_update_signature , create_reward_proof , token_network , ms_address , monitoring_service_external , ) : [EOL] [comment] [EOL] ( A , B ) = get_accounts ( [number] , privkeys = [ [string] + [string] * [number] , [string] + [string] * [number] ] ) [EOL] deposit_to_udc ( B , REWARD_AMOUNT ) [EOL] channel_identifier = create_channel ( A , B ) [ [number] ] [EOL] [EOL] [comment] [EOL] balance_proof_A = create_balance_proof ( channel_identifier , B , transferred_amount = [number] , nonce = [number] ) [EOL] balance_proof_B = create_balance_proof ( channel_identifier , A , transferred_amount = [number] , nonce = [number] ) [EOL] [EOL] [comment] [EOL] non_closing_signature_B = create_balance_proof_update_signature ( B , channel_identifier , * balance_proof_B ) [EOL] reward_proof = create_reward_proof ( B , channel_identifier , REWARD_AMOUNT , token_network . address , nonce = balance_proof_B [ [number] ] ) [EOL] [EOL] [comment] [EOL] token_network . functions . closeChannel ( channel_identifier , B , * balance_proof_A ) . call_and_transact ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] ( settle_block_number , _ ) = token_network . functions . getChannelInfo ( channel_identifier , A , B ) . call ( ) [EOL] first_allowed = monitoring_service_external . functions . firstBlockAllowedToMonitor ( closed_at_block = settle_block_number - TEST_SETTLE_TIMEOUT_MIN , settle_timeout = TEST_SETTLE_TIMEOUT_MIN , participant1 = A , participant2 = B , monitoring_service_address = ms_address , ) . call ( ) [EOL] [EOL] [comment] [EOL] return { [string] : ( A , B ) , [string] : balance_proof_A , [string] : balance_proof_B , [string] : non_closing_signature_B , [string] : reward_proof [ [number] ] , [string] : channel_identifier , [string] : first_allowed , } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_claimReward_with_settle_call ( token_network , monitoring_service_external , user_deposit_contract , event_handler , monitor_data , ms_address , web3 , with_settle , ) : [EOL] A , B = monitor_data [ [string] ] [EOL] channel_identifier = monitor_data [ [string] ] [EOL] [EOL] [comment] [EOL] token_network . web3 . testing . mine ( monitor_data [ [string] ] - web3 . eth . blockNumber ) [EOL] [EOL] [comment] [EOL] txn_hash = monitoring_service_external . functions . monitor ( A , B , * monitor_data [ [string] ] , monitor_data [ [string] ] , REWARD_AMOUNT , token_network . address , monitor_data [ [string] ] , ) . call_and_transact ( { [string] : ms_address } ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] monitoring_service_external . functions . claimReward ( channel_identifier , token_network . address , A , B ) . call ( { [string] : ms_address } ) [EOL] [EOL] [comment] [EOL] token_network . web3 . testing . mine ( [number] ) [EOL] if with_settle : [EOL] token_network . functions . settleChannel ( channel_identifier , B , [number] , [number] , EMPTY_LOCKSROOT , A , [number] , [number] , EMPTY_LOCKSROOT , ) . call_and_transact ( ) [EOL] [EOL] [comment] [EOL] monitoring_service_external . functions . claimReward ( channel_identifier , token_network . address , A , B ) . call_and_transact ( { [string] : ms_address } ) [EOL] [EOL] [comment] [EOL] reward_identifier = Web3 . sha3 ( encode_single ( [string] , channel_identifier ) + Web3 . toBytes ( hexstr = token_network . address ) ) [EOL] ms_ev_handler = event_handler ( monitoring_service_external ) [EOL] ms_ev_handler . assert_event ( txn_hash , MonitoringServiceEvent . REWARD_CLAIMED , dict ( ms_address = ms_address , amount = REWARD_AMOUNT , reward_identifier = reward_identifier ) , ) [EOL] [EOL] [comment] [EOL] ms_balance_after_reward = user_deposit_contract . functions . balances ( ms_address ) . call ( ) [EOL] assert ms_balance_after_reward == REWARD_AMOUNT [EOL] [EOL] [EOL] def test_monitor ( token_network , monitoring_service_external , monitor_data , ms_address , event_handler , web3 ) : [EOL] A , B = monitor_data [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] txn_hash = monitoring_service_external . functions . monitor ( A , B , * monitor_data [ [string] ] , monitor_data [ [string] ] , REWARD_AMOUNT + [number] , token_network . address , monitor_data [ [string] ] , ) . call ( { [string] : ms_address } ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] txn_hash = monitoring_service_external . functions . monitor ( A , B , * monitor_data [ [string] ] , monitor_data [ [string] ] , REWARD_AMOUNT + [number] , token_network . address , monitor_data [ [string] ] , ) . call ( { [string] : B } ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] assert web3 . eth . blockNumber < monitor_data [ [string] ] [EOL] txn_hash = monitoring_service_external . functions . monitor ( A , B , * monitor_data [ [string] ] , monitor_data [ [string] ] , REWARD_AMOUNT , token_network . address , monitor_data [ [string] ] , ) . call_and_transact ( { [string] : ms_address } ) [EOL] [EOL] [comment] [EOL] token_network . web3 . testing . mine ( monitor_data [ [string] ] - web3 . eth . blockNumber ) [EOL] [EOL] [comment] [EOL] txn_hash = monitoring_service_external . functions . monitor ( A , B , * monitor_data [ [string] ] , monitor_data [ [string] ] , REWARD_AMOUNT , token_network . address , monitor_data [ [string] ] , ) . call_and_transact ( { [string] : ms_address } ) [EOL] [EOL] [comment] [EOL] ms_ev_handler = event_handler ( monitoring_service_external ) [EOL] ms_ev_handler . assert_event ( txn_hash , MonitoringServiceEvent . NEW_BALANCE_PROOF_RECEIVED , dict ( token_network_address = token_network . address , channel_identifier = monitor_data [ [string] ] , reward_amount = REWARD_AMOUNT , nonce = monitor_data [ [string] ] [ [number] ] , ms_address = ms_address , raiden_node_address = B , ) , ) [EOL] [EOL] [EOL] def test_updateReward ( monitoring_service_internals , ms_address , token_network , create_reward_proof , monitor_data ) : [EOL] A , B = monitor_data [ [string] ] [EOL] reward_identifier = Web3 . sha3 ( encode_single ( [string] , monitor_data [ [string] ] ) + Web3 . toBytes ( hexstr = token_network . address ) ) [EOL] [EOL] def update_with_nonce ( nonce ) : [EOL] reward_proof = create_reward_proof ( B , monitor_data [ [string] ] , REWARD_AMOUNT , token_network . address , nonce = nonce , ) [EOL] reward_proof_signature = reward_proof [ [number] ] [EOL] monitoring_service_internals . functions . updateRewardPublic ( token_network . address , A , B , REWARD_AMOUNT , nonce , ms_address , reward_proof_signature ) . call_and_transact ( { [string] : ms_address } ) [EOL] [EOL] [comment] [EOL] update_with_nonce ( [number] ) [EOL] assert monitoring_service_internals . functions . rewardNonce ( reward_identifier ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] update_with_nonce ( [number] ) [EOL] [EOL] [comment] [EOL] update_with_nonce ( [number] ) [EOL] assert monitoring_service_internals . functions . rewardNonce ( reward_identifier ) . call ( ) == [number] [EOL] [EOL] [EOL] def test_firstAllowedBlock ( monitoring_service_external ) : [EOL] def call ( addresses , closed_at_block = [number] , settle_timeout = [number] ) : [EOL] first_allowed = monitoring_service_external . functions . firstBlockAllowedToMonitor ( closed_at_block = closed_at_block , settle_timeout = settle_timeout , participant1 = to_checksum_address ( [string] % addresses [ [number] ] ) , participant2 = to_checksum_address ( [string] % addresses [ [number] ] ) , monitoring_service_address = to_checksum_address ( [string] % addresses [ [number] ] ) , ) . call ( ) [EOL] assert closed_at_block < first_allowed <= closed_at_block + settle_timeout [EOL] return first_allowed [EOL] [EOL] [comment] [EOL] assert call ( [ [number] , [number] , [number] ] ) == [number] + [number] + ( [number] + [number] + [number] ) [EOL] [EOL] [comment] [EOL] assert call ( [ [number] , [number] , [number] ] ) == [number] + [number] + ( [number] % [number] + [number] + [number] ) [EOL] [EOL] [comment] [EOL] assert call ( [ [number] , [number] , [number] ] ) == [number] + [number] + ( [number] + [number] + [number] ) % [number] [EOL] [EOL] [comment] [EOL] MAX_ADDRESS = [number] ** [number] - [number] [EOL] assert call ( [ MAX_ADDRESS ] * [number] ) == [number] + [number] + ( [number] * MAX_ADDRESS ) % [number] [EOL] [EOL] [comment] [EOL] MAX_SETTLE_TIMEOUT = ( [number] ** [number] - [number] ) // [number] - [number] [EOL] assert call ( [ [number] , [number] , [number] ] , settle_timeout = MAX_SETTLE_TIMEOUT ) == [number] + ( MAX_SETTLE_TIMEOUT * [number] ) // [number] + ( [number] + [number] + [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] assert call ( [ [number] , [number] , [number] ] , settle_timeout = MAX_SETTLE_TIMEOUT + [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] [EOL] from raiden_contracts . constants import CONTRACTS_VERSION , OneToNEvent [EOL] from raiden_contracts . utils . proofs import sign_one_to_n_iou [EOL] [EOL] [EOL] def test_claim ( user_deposit_contract , one_to_n_contract , deposit_to_udc , get_accounts , get_private_key , web3 , event_handler , ) : [EOL] ev_handler = event_handler ( one_to_n_contract ) [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] deposit_to_udc ( A , [number] ) [EOL] [EOL] [comment] [EOL] amount = [number] [EOL] expiration = web3 . eth . blockNumber + [number] [EOL] chain_id = int ( web3 . version . network ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] bad_expiration = web3 . eth . blockNumber - [number] [EOL] signature = sign_one_to_n_iou ( get_private_key ( A ) , sender = A , receiver = B , amount = amount , expiration_block = bad_expiration , one_to_n_address = one_to_n_contract . address , chain_id = chain_id , ) [EOL] one_to_n_contract . functions . claim ( A , B , amount , bad_expiration , one_to_n_contract . address , signature ) . call ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] signature = sign_one_to_n_iou ( get_private_key ( A ) , sender = A , receiver = B , amount = amount , expiration_block = expiration , one_to_n_address = A , chain_id = chain_id , ) [EOL] one_to_n_contract . functions . claim ( A , B , amount , expiration , A , signature ) . call ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] signature = sign_one_to_n_iou ( get_private_key ( A ) , sender = A , receiver = B , amount = amount , expiration_block = expiration , one_to_n_address = one_to_n_contract . address , chain_id = chain_id + [number] , ) [EOL] one_to_n_contract . functions . claim ( A , B , amount , expiration , A , signature ) . call ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] expiration = web3 . eth . blockNumber + [number] [EOL] signature = sign_one_to_n_iou ( get_private_key ( A ) , sender = A , receiver = B , amount = amount + [number] , expiration_block = expiration , one_to_n_address = one_to_n_contract . address , chain_id = chain_id , ) [EOL] one_to_n_contract . functions . claim ( A , B , amount , expiration , one_to_n_contract . address , signature ) . call ( { [string] : A } ) [EOL] [EOL] signature = sign_one_to_n_iou ( get_private_key ( A ) , sender = A , receiver = B , amount = amount , expiration_block = expiration , one_to_n_address = one_to_n_contract . address , chain_id = chain_id , ) [EOL] [EOL] tx_hash = one_to_n_contract . functions . claim ( sender = A , receiver = B , amount = amount , expiration_block = expiration , one_to_n_address = one_to_n_contract . address , signature = signature , ) . call_and_transact ( { [string] : A } ) [EOL] [EOL] ev_handler . assert_event ( tx_hash , OneToNEvent . CLAIMED , dict ( sender = A , receiver = B , expiration_block = expiration , transferred = amount ) , ) [EOL] assert user_deposit_contract . functions . balances ( A ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . balances ( B ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] one_to_n_contract . functions . claim ( A , B , amount , expiration , one_to_n_contract . address , signature ) . call ( { [string] : A } ) [EOL] [EOL] [EOL] def test_claim_with_insufficient_deposit ( user_deposit_contract , one_to_n_contract , deposit_to_udc , get_accounts , get_private_key , web3 , event_handler , ) : [EOL] ev_handler = event_handler ( one_to_n_contract ) [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] deposit_to_udc ( A , [number] ) [EOL] chain_id = int ( web3 . version . network ) [EOL] [EOL] amount = [number] [EOL] expiration = web3 . eth . blockNumber + [number] [EOL] signature = sign_one_to_n_iou ( get_private_key ( A ) , sender = A , receiver = B , amount = amount , expiration_block = expiration , one_to_n_address = one_to_n_contract . address , chain_id = chain_id , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert ( one_to_n_contract . functions . claim ( A , B , amount , expiration , one_to_n_contract . address , signature ) . call ( { [string] : A } ) == [number] ) [EOL] [comment] [EOL] one_to_n_contract . functions . claim ( A , B , amount , expiration , one_to_n_contract . address , signature ) . call_and_transact ( { [string] : A } ) [EOL] [EOL] assert user_deposit_contract . functions . balances ( A ) . call ( ) == [number] [EOL] assert user_deposit_contract . functions . balances ( B ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] expiration = web3 . eth . blockNumber + [number] [EOL] signature = sign_one_to_n_iou ( get_private_key ( A ) , sender = A , receiver = B , amount = amount , expiration_block = expiration , one_to_n_address = one_to_n_contract . address , chain_id = chain_id , ) [EOL] one_to_n_contract . functions . claim ( A , B , amount , expiration , one_to_n_contract . address , signature ) . call_and_transact ( { [string] : A } ) [EOL] deposit_to_udc ( A , [number] + [number] ) [EOL] tx_hash = one_to_n_contract . functions . claim ( A , B , amount , expiration , one_to_n_contract . address , signature ) . call_and_transact ( { [string] : A } ) [EOL] ev_handler . assert_event ( tx_hash , OneToNEvent . CLAIMED , dict ( sender = A , receiver = B , expiration_block = expiration , transferred = [number] ) , ) [EOL] [EOL] [EOL] def test_version ( one_to_n_contract ) : [EOL] [docstring] [EOL] version = one_to_n_contract . functions . contract_version ( ) . call ( ) [EOL] assert version == CONTRACTS_VERSION [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import web3 [EOL] import typing [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import ( CONTRACTS_VERSION , TEST_SETTLE_TIMEOUT_MAX , TEST_SETTLE_TIMEOUT_MIN , ) [EOL] from raiden_contracts . tests . utils . constants import EMPTY_ADDRESS , FAKE_ADDRESS , MAX_UINT256 [EOL] [EOL] [EOL] def test_version ( token_network ) : [EOL] [docstring] [EOL] assert token_network . functions . contract_version ( ) . call ( ) == CONTRACTS_VERSION [EOL] [EOL] [EOL] def test_constructor_call ( web3 , get_token_network , custom_token , secret_registry_contract , get_accounts , channel_participant_deposit_limit , token_network_deposit_limit , ) : [EOL] [docstring] [EOL] [EOL] ( A , deprecation_executor ) = get_accounts ( [number] ) [EOL] chain_id = int ( web3 . version . network ) [EOL] settle_min = TEST_SETTLE_TIMEOUT_MIN [EOL] settle_max = TEST_SETTLE_TIMEOUT_MAX [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ [number] , secret_registry_contract . address , chain_id , settle_min , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ [number] , secret_registry_contract . address , chain_id , settle_min , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ [string] , secret_registry_contract . address , chain_id , settle_min , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ FAKE_ADDRESS , secret_registry_contract . address , chain_id , settle_min , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ custom_token . address , [number] , chain_id , settle_min , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ custom_token . address , [number] , chain_id , settle_min , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ custom_token . address , [string] , chain_id , settle_min , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ custom_token . address , FAKE_ADDRESS , chain_id , settle_min , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , [string] , settle_min , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , - [number] , settle_min , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , [string] , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , - [number] , settle_max , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , settle_min , [string] , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] with pytest . raises ( TypeError ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , settle_min , - [number] , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ EMPTY_ADDRESS , secret_registry_contract . address , chain_id , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ A , secret_registry_contract . address , chain_id , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ secret_registry_contract . address , secret_registry_contract . address , chain_id , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ custom_token . address , EMPTY_ADDRESS , chain_id , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ custom_token . address , A , chain_id , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , [number] , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , TEST_SETTLE_TIMEOUT_MAX , TEST_SETTLE_TIMEOUT_MIN , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , [number] , TEST_SETTLE_TIMEOUT_MIN , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , TEST_SETTLE_TIMEOUT_MIN , [number] , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , deprecation_executor , [number] , token_network_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , deprecation_executor , [number] , [number] , ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , deprecation_executor , token_network_deposit_limit , channel_participant_deposit_limit , ] ) [EOL] [EOL] [comment] [EOL] get_token_network ( [ custom_token . address , secret_registry_contract . address , chain_id , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , deprecation_executor , channel_participant_deposit_limit , token_network_deposit_limit , ] ) [EOL] [EOL] [EOL] def test_token_network_variables ( token_network , token_network_test_utils ) : [EOL] [docstring] [EOL] max_safe_uint256 = token_network_test_utils . functions . get_max_safe_uint256 ( ) . call ( ) [EOL] [EOL] assert token_network . functions . MAX_SAFE_UINT256 ( ) . call ( ) == max_safe_uint256 [EOL] assert max_safe_uint256 == MAX_UINT256 [EOL] [EOL] assert token_network . functions . channel_counter ( ) . call ( ) == [number] [EOL] assert token_network . functions . signature_prefix ( ) . call ( ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_constructor_not_registered ( custom_token , secret_registry_contract , token_network_registry_contract , token_network_external , ) : [EOL] [docstring] [EOL] [EOL] token_network = token_network_external [EOL] assert token_network . functions . token ( ) . call ( ) == custom_token . address [EOL] assert token_network . functions . secret_registry ( ) . call ( ) == secret_registry_contract . address [EOL] assert ( token_network . functions . chain_id ( ) . call ( ) == token_network_registry_contract . functions . chain_id ( ) . call ( ) ) [EOL] [EOL] [comment] [EOL] assert ( token_network_registry_contract . functions . token_to_token_networks ( custom_token . address ) . call ( ) == EMPTY_ADDRESS ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import web3 [EOL] import typing [EOL] import raiden_contracts [EOL] from typing import Callable [EOL] [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from web3 import Web3 [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACT_CUSTOM_TOKEN , CONTRACT_HUMAN_STANDARD_TOKEN [EOL] from raiden_contracts . contract_manager import ContractManager [EOL] [EOL] [EOL] def test_token_mint ( web3 , custom_token , get_accounts ) : [EOL] [docstring] [EOL] [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] token = custom_token [EOL] multiplier = custom_token . functions . multiplier ( ) . call ( ) [EOL] supply = token . functions . totalSupply ( ) . call ( ) [EOL] [EOL] token_pre_balance = web3 . eth . getBalance ( token . address ) [EOL] tokens_a = [number] * multiplier [EOL] token . functions . mint ( tokens_a ) . call_and_transact ( { [string] : A } ) [EOL] assert token . functions . balanceOf ( A ) . call ( ) == tokens_a [EOL] assert token . functions . balanceOf ( B ) . call ( ) == [number] [EOL] assert token . functions . totalSupply ( ) . call ( ) == supply + tokens_a [EOL] assert web3 . eth . getBalance ( token . address ) == token_pre_balance [EOL] [EOL] tokens_b = [number] * multiplier [EOL] token . functions . mintFor ( tokens_b , B ) . call_and_transact ( { [string] : A } ) [EOL] assert token . functions . balanceOf ( A ) . call ( ) == tokens_a [EOL] assert token . functions . balanceOf ( B ) . call ( ) == tokens_b [EOL] assert token . functions . totalSupply ( ) . call ( ) == supply + tokens_a + tokens_b [EOL] assert web3 . eth . getBalance ( token . address ) == token_pre_balance [EOL] [EOL] [EOL] def test_approve_transfer ( custom_token , get_accounts ) : [EOL] [docstring] [EOL] [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] token = custom_token [EOL] token . functions . mint ( [number] ) . call_and_transact ( { [string] : A } ) [EOL] initial_balance_A = token . functions . balanceOf ( A ) . call ( ) [EOL] initial_balance_B = token . functions . balanceOf ( B ) . call ( ) [EOL] to_transfer = [number] [EOL] token . functions . approve ( B , to_transfer ) . call_and_transact ( { [string] : A } ) [EOL] token . functions . transferFrom ( A , B , to_transfer ) . call_and_transact ( { [string] : B } ) [EOL] assert token . functions . balanceOf ( B ) . call ( ) == initial_balance_B + to_transfer [EOL] assert token . functions . balanceOf ( A ) . call ( ) == initial_balance_A - to_transfer [EOL] [EOL] assert custom_token . functions . allowance ( _owner = A , _spender = B ) . call ( ) == [number] [EOL] assert custom_token . functions . approve ( _spender = B , _value = [number] ) . call_and_transact ( { [string] : A } ) [EOL] assert custom_token . functions . allowance ( _owner = A , _spender = B ) . call ( ) == [number] [EOL] assert custom_token . functions . allowance ( _owner = A , _spender = token . address ) . call ( ) == [number] [EOL] [EOL] [EOL] def test_token_transfer_funds ( web3 , custom_token , get_accounts ) : [EOL] [docstring] [EOL] [EOL] A = get_accounts ( [number] ) [ [number] ] [EOL] token = custom_token [EOL] multiplier = custom_token . functions . multiplier ( ) . call ( ) [EOL] assert multiplier > [number] [EOL] supply = token . functions . totalSupply ( ) . call ( ) [EOL] assert supply > [number] [EOL] [EOL] owner = custom_token . functions . owner_address ( ) . call ( ) [EOL] [EOL] assert web3 . eth . getBalance ( token . address ) == [number] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] token . functions . transferFunds ( ) . call ( { [string] : owner } ) [EOL] [EOL] token . functions . mint ( [number] ) . call_and_transact ( { [string] : A } ) [EOL] assert web3 . eth . getBalance ( token . address ) == [number] [EOL] [EOL] [EOL] def test_custom_token ( custom_token , web3 , contracts_manager ) : [EOL] [docstring] [EOL] blockchain_bytecode = web3 . eth . getCode ( custom_token . address ) . hex ( ) [EOL] compiled_bytecode = contracts_manager . get_runtime_hexcode ( CONTRACT_CUSTOM_TOKEN ) [EOL] assert blockchain_bytecode == compiled_bytecode [EOL] [EOL] [EOL] def test_human_standard_token ( human_standard_token , web3 , contracts_manager ) : [EOL] [docstring] [EOL] blockchain_bytecode = web3 . eth . getCode ( human_standard_token . address ) . hex ( ) [EOL] compiled_bytecode = contracts_manager . get_runtime_hexcode ( CONTRACT_HUMAN_STANDARD_TOKEN ) [EOL] assert blockchain_bytecode == compiled_bytecode [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Callable , Any [EOL] import web3 [EOL] import typing [EOL] from typing import Callable [EOL] [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACTS_VERSION , EVENT_ADDRESS_REGISTERED [EOL] from raiden_contracts . utils . events import check_address_registered [EOL] [EOL] [EOL] def test_version ( endpoint_registry_contract ) : [EOL] [docstring] [EOL] version = endpoint_registry_contract . functions . contract_version ( ) . call ( ) [EOL] assert version == CONTRACTS_VERSION [EOL] [EOL] [EOL] def test_endpointregistry_calls ( endpoint_registry_contract , get_accounts ) : [EOL] [docstring] [EOL] A = get_accounts ( [number] ) [ [number] ] [EOL] ENDPOINT = [string] [EOL] endpoint_registry_contract . functions . registerEndpoint ( ENDPOINT ) . call_and_transact ( { [string] : A } ) [EOL] NEW_ENDPOINT = [string] [EOL] endpoint_registry_contract . functions . registerEndpoint ( NEW_ENDPOINT ) . call_and_transact ( { [string] : A } ) [EOL] assert endpoint_registry_contract . functions . findEndpointByAddress ( A ) . call ( ) == NEW_ENDPOINT [EOL] [EOL] [EOL] def test_events ( endpoint_registry_contract , get_accounts , event_handler ) : [EOL] [docstring] [EOL] A = get_accounts ( [number] ) [ [number] ] [EOL] ev_handler = event_handler ( endpoint_registry_contract ) [EOL] [EOL] ENDPOINT = [string] [EOL] txn_hash = endpoint_registry_contract . functions . registerEndpoint ( ENDPOINT ) . call_and_transact ( { [string] : A } ) [EOL] [EOL] ev_handler . add ( txn_hash , EVENT_ADDRESS_REGISTERED , check_address_registered ( A , ENDPOINT ) ) [EOL] ev_handler . check ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import web3 [EOL] import typing [EOL] from typing import Callable [EOL] [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACTS_VERSION [EOL] [EOL] [EOL] def test_deposit ( service_registry , custom_token , get_accounts ) : [EOL] ( A , ) = get_accounts ( [number] ) [EOL] custom_token . functions . mint ( [number] ) . call_and_transact ( { [string] : A } ) [EOL] custom_token . functions . approve ( service_registry . address , [number] ) . call_and_transact ( { [string] : A } ) [EOL] [EOL] [comment] [EOL] service_registry . functions . deposit ( [number] ) . call_and_transact ( { [string] : A } ) [EOL] assert service_registry . functions . deposits ( A ) . call ( ) == [number] [EOL] assert custom_token . functions . balanceOf ( A ) . call ( ) == [number] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] service_registry . functions . deposit ( [number] ) . call ( { [string] : A } ) [EOL] [EOL] [EOL] def test_setURL ( service_registry , get_accounts ) : [EOL] ( A , ) = get_accounts ( [number] ) [EOL] url1 = [string] [EOL] url2 = [string] [EOL] [EOL] [comment] [EOL] service_registry . functions . setURL ( url1 ) . call_and_transact ( { [string] : A } ) [EOL] assert service_registry . functions . urls ( A ) . call ( ) == url1 [EOL] assert service_registry . functions . service_addresses ( [number] ) . call ( ) == A [EOL] assert service_registry . functions . serviceCount ( ) . call ( ) == [number] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] assert service_registry . functions . service_addresses ( [number] ) . call ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] service_registry . functions . setURL ( url2 ) . call_and_transact ( { [string] : A } ) [EOL] assert service_registry . functions . urls ( A ) . call ( ) == url2 [EOL] assert service_registry . functions . service_addresses ( [number] ) . call ( ) == A [EOL] assert service_registry . functions . serviceCount ( ) . call ( ) == [number] [EOL] [EOL] [EOL] def test_version ( service_registry ) : [EOL] [docstring] [EOL] version = service_registry . functions . contract_version ( ) . call ( ) [EOL] assert version == CONTRACTS_VERSION [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . fixtures import * [comment] [EOL]	0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from . address import * [EOL] from . channel import * [EOL] from . constants import * [EOL] from . contracts import * [EOL] from . mock import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import string [EOL] from random import choice [EOL] [EOL] [EOL] def fake_hex ( size , fill = [string] ) : [EOL] return [string] + [string] . join ( [ fill for i in range ( [number] , size ) ] ) [EOL] [EOL] [EOL] def fake_bytes ( size , fill = [string] ) : [EOL] return bytes . fromhex ( fake_hex ( size , fill ) [ [number] : ] ) [EOL] [EOL] [EOL] def make_address ( ) : [EOL] return bytes ( [string] . join ( choice ( string . printable ) for _ in range ( [number] ) ) , encoding = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from web3 import Web3 [EOL] from web3 . providers . eth_tester import EthereumTesterProvider [EOL] [EOL] from raiden_contracts . constants import CONTRACT_CUSTOM_TOKEN , CONTRACT_TOKEN_NETWORK [EOL] from raiden_contracts . tests . utils . constants import FAUCET_ALLOWANCE [EOL] from raiden_contracts . utils . signature import private_key_to_address [EOL] [EOL] [EOL] def get_web3 ( eth_tester , deployer_key ) : [EOL] [docstring] [EOL] provider = EthereumTesterProvider ( eth_tester ) [EOL] web3 = Web3 ( provider ) [EOL] [EOL] [comment] [EOL] eth_tester . add_account ( deployer_key . to_hex ( ) ) [EOL] [EOL] [comment] [EOL] eth_tester . send_transaction ( { [string] : eth_tester . get_accounts ( ) [ [number] ] , [string] : private_key_to_address ( deployer_key . to_hex ( ) ) , [string] : [number] , [string] : FAUCET_ALLOWANCE , } ) [EOL] [EOL] return web3 [EOL] [EOL] [EOL] def deploy_contract ( web3 , contracts_manager , contract_name , deployer_key , args = None ) : [EOL] deployer_address = private_key_to_address ( deployer_key . to_hex ( ) ) [EOL] json_contract = contracts_manager . get_contract ( contract_name ) [EOL] contract = web3 . eth . contract ( abi = json_contract [ [string] ] , bytecode = json_contract [ [string] ] ) [EOL] tx_hash = contract . constructor ( * args ) . call_and_transact ( { [string] : deployer_address } ) [EOL] contract_address = web3 . eth . getTransactionReceipt ( tx_hash ) . contractAddress [EOL] [EOL] return contract ( contract_address ) [EOL] [EOL] [EOL] def deploy_custom_token ( web3 , deployer_key ) : [EOL] return deploy_contract ( web3 , CONTRACT_CUSTOM_TOKEN , deployer_key , [ ] , ( [number] ** [number] , [number] , CONTRACT_CUSTOM_TOKEN , [string] ) ) [EOL] [EOL] [EOL] def get_token_network ( web3 , address , contracts_manager ) : [EOL] json_contract = contracts_manager . get_contract ( CONTRACT_TOKEN_NETWORK ) [EOL] [EOL] return web3 . eth . contract ( abi = json_contract [ [string] ] , address = address ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from enum import IntEnum [EOL] [EOL] from eth_typing . evm import HexAddress [EOL] from eth_utils . units import units [EOL] [EOL] from raiden_contracts . utils . signature import private_key_to_address [EOL] [EOL] MAX_UINT256 = [number] ** [number] - [number] [EOL] MAX_UINT192 = [number] ** [number] - [number] [EOL] MAX_UINT32 = [number] ** [number] - [number] [EOL] FAKE_ADDRESS = [string] [EOL] EMPTY_ADDRESS = HexAddress ( [string] ) [EOL] EMPTY_BALANCE_HASH = [string] * [number] [EOL] EMPTY_ADDITIONAL_HASH = [string] * [number] [EOL] EMPTY_LOCKSROOT = [string] * [number] [EOL] EMPTY_SIGNATURE = [string] * [number] [EOL] passphrase = [string] [EOL] FAUCET_PRIVATE_KEY = [string] [EOL] FAUCET_ADDRESS = private_key_to_address ( FAUCET_PRIVATE_KEY ) [EOL] FAUCET_ALLOWANCE = [number] * int ( units [ [string] ] ) [EOL] CONTRACT_DEPLOYER_ADDRESS = FAUCET_ADDRESS [EOL] [EOL] [EOL] class TestLockIndex ( IntEnum ) : [EOL] EXPIRATION = [number] [EOL] AMOUNT = [number] [EOL] SECRETHASH = [number] [EOL] SECRET = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import random [EOL] [EOL] from raiden_contracts . tests . utils . constants import MAX_UINT256 [EOL] from raiden_contracts . utils . signature import private_key_to_address [EOL] [EOL] [EOL] def get_random_privkey ( ) : [EOL] [docstring] [EOL] return [string] % random . randint ( [number] , MAX_UINT256 ) [EOL] [EOL] [EOL] def get_random_address ( ) : [EOL] [docstring] [EOL] return private_key_to_address ( get_random_privkey ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from eth_utils import keccak [EOL] from hypothesis . strategies import binary , composite , integers [EOL] [EOL] UINT64_MAX = [number] ** [number] - [number] [EOL] UINT256_MAX = [number] ** [number] - [number] [EOL] [EOL] privatekeys = binary ( min_size = [number] , max_size = [number] ) [EOL] identifier = integers ( min_value = [number] , max_value = UINT64_MAX ) [EOL] nonce = integers ( min_value = [number] , max_value = UINT64_MAX ) [EOL] transferred_amount = integers ( min_value = [number] , max_value = UINT256_MAX ) [EOL] [EOL] [EOL] class Transfer : [EOL] cmdid = [number] [comment] [EOL] [EOL] def __init__ ( self , message_identifier , payment_identifier , nonce , registry_address , token , channel , transferred_amount , locked_amount , recipient , locksroot , ) : [EOL] self . message_identifier = message_identifier [EOL] self . payment_identifier = payment_identifier [EOL] self . nonce = nonce [EOL] self . registry_address = registry_address [EOL] self . token = token [EOL] self . channel = channel [EOL] self . transferred_amount = transferred_amount [EOL] self . locked_amount = locked_amount [EOL] self . recipient = recipient [EOL] self . locksroot = locksroot [EOL] [EOL] def sign ( self , private_key , node_address ) : [EOL] [docstring] [EOL] signature = private_key . sign_recoverable ( self . to_bytes ( ) , hasher = keccak ) [EOL] if len ( signature ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] signature = signature [ : - [number] ] + chr ( signature [ - [number] ] + [number] ) . encode ( ) [EOL] [EOL] self . signature = signature [EOL] [EOL] self . sender = node_address [EOL] self . signature = signature [EOL] [EOL] return signature [EOL] [EOL] def to_bytes ( self ) : [EOL] arr = bytearray ( ) [EOL] arr . extend ( self . message_identifier . to_bytes ( [number] , byteorder = [string] ) ) [EOL] arr . extend ( self . payment_identifier . to_bytes ( [number] , byteorder = [string] ) ) [EOL] arr . extend ( self . nonce . to_bytes ( [number] , byteorder = [string] ) ) [EOL] arr . extend ( self . token . encode ( ) ) [EOL] arr . extend ( self . registry_address . encode ( ) ) [EOL] arr . extend ( self . channel ) [EOL] arr . extend ( self . transferred_amount . to_bytes ( [number] , byteorder = [string] ) ) [EOL] arr . extend ( self . locked_amount . to_bytes ( [number] , byteorder = [string] ) ) [EOL] arr . extend ( self . recipient . encode ( ) ) [EOL] arr . extend ( self . locksroot ) [EOL] return arr [EOL] [EOL] def balance_hash ( self ) : [EOL] [comment] [EOL] return keccak ( text = [string] . format ( self . transferred_amount , self . locked_amount , self . locksroot ) ) [EOL] [EOL] [EOL] @ composite def direct_transfer ( draw , registry_address , token , channel , recipient , locksroot ) : [EOL] return Transfer ( draw ( identifier ) , draw ( identifier ) , draw ( nonce ) , draw ( registry_address ) , draw ( token ) , draw ( channel ) , draw ( transferred_amount ) , [number] , draw ( recipient ) , draw ( locksroot ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import contextlib [EOL] [EOL] import eth_tester . backends . pyevm . main as pyevm_main [EOL] from coincurve import PrivateKey [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from eth_utils import encode_hex , to_canonical_address , to_checksum_address [EOL] from hypothesis import assume [EOL] from hypothesis . stateful import GenericStateMachine [EOL] from hypothesis . strategies import integers , just , one_of , sampled_from , tuples [EOL] from web3 import Web3 [EOL] from web3 . exceptions import ValidationError [EOL] [EOL] from raiden_contracts . constants import ( CONTRACT_SECRET_REGISTRY , CONTRACT_TOKEN_NETWORK_REGISTRY , MAX_ETH_CHANNEL_PARTICIPANT , MAX_ETH_TOKEN_NETWORK , TEST_SETTLE_TIMEOUT_MAX , TEST_SETTLE_TIMEOUT_MIN , ) [EOL] from raiden_contracts . tests . fixtures . base . web3_fixtures import ethereum_tester [EOL] from raiden_contracts . tests . property . strategies import direct_transfer [EOL] from raiden_contracts . tests . utils import ( EMPTY_LOCKSROOT , deploy_contract , deploy_custom_token , get_token_network , get_web3 , make_address , ) [EOL] from raiden_contracts . utils . signature import private_key_to_address [EOL] [EOL] DEPOSIT = [string] [EOL] CLOSE = [string] [EOL] UPDATE_TRANSFER = [string] [EOL] MINE = [string] [EOL] GAS_LIMIT = [number] [EOL] [EOL] [EOL] @ contextlib . contextmanager def transaction_must_fail ( error_message ) : [EOL] try : [EOL] yield [EOL] except TransactionFailed : [EOL] pass [EOL] else : [EOL] raise ValueError ( error_message ) [EOL] [EOL] [EOL] class BlockGasLimitReached ( ValidationError ) : [EOL] pass [EOL] [EOL] [EOL] class TokenNetworkStateMachine ( GenericStateMachine ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . log = list ( ) [EOL] self . settle_timeout = [number] [EOL] [EOL] deployer_key = PrivateKey ( secret = [string] ) [EOL] [EOL] pyevm_main . GENESIS_GAS_LIMIT = [number] * [number] ** [number] [EOL] self . tester_chain = ethereum_tester ( ) [EOL] [EOL] self . web3 = get_web3 ( self . tester_chain , deployer_key ) [EOL] [EOL] self . tokens = [ deploy_custom_token ( self . web3 , deployer_key ) , deploy_custom_token ( self . web3 , deployer_key ) , ] [EOL] self . token = self . tokens [ [number] ] [EOL] [EOL] self . token_addresses = [ token . address for token in self . tokens ] [EOL] [EOL] self . private_keys = [ PrivateKey ( secret = [string] ) , PrivateKey ( secret = [string] ) , PrivateKey ( secret = [string] ) , ] [EOL] [EOL] [comment] [EOL] self . addresses = [ ] [EOL] token_amount = [number] [EOL] for private_key in self . private_keys : [EOL] self . tester_chain . add_account ( private_key . to_hex ( ) ) [EOL] [EOL] address = private_key_to_address ( private_key . to_hex ( ) ) [EOL] self . tester_chain . send_transaction ( { [string] : self . tester_chain . get_accounts ( ) [ [number] ] , [string] : address , [string] : [number] , [string] : self . web3 . toWei ( [number] , [string] ) , } ) [EOL] [EOL] self . token . functions . transfer ( address , token_amount ) . call_and_transact ( { [string] : private_key_to_address ( deployer_key . to_hex ( ) ) } ) [EOL] [EOL] self . addresses . append ( address ) [EOL] [EOL] self . secret_registry = deploy_contract ( self . web3 , CONTRACT_SECRET_REGISTRY , deployer_key , [ ] , [ ] ) [EOL] [EOL] self . token_network_registry = deploy_contract ( self . web3 , CONTRACT_TOKEN_NETWORK_REGISTRY , deployer_key , [ ] , [ self . secret_registry . address , [number] , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX ] , ) [EOL] [EOL] self . token_network_registry . functions . createERC20TokenNetwork ( self . token . address , MAX_ETH_CHANNEL_PARTICIPANT , MAX_ETH_TOKEN_NETWORK ) . call_and_transact ( ) [EOL] [EOL] token_network_address = self . token_network_registry . functions . token_to_token_networks ( self . token . address ) . call ( ) [EOL] [EOL] self . token_network = get_token_network ( self . web3 , to_checksum_address ( token_network_address ) ) [EOL] [EOL] channel_identifier = self . open_channel ( ) [EOL] [EOL] self . closing_address = None [EOL] self . update_transfer_called = False [EOL] [EOL] self . participant_addresses = { self . addresses [ [number] ] , self . addresses [ [number] ] } [EOL] [EOL] self . channel_addresses = [ channel_identifier , make_address ( ) ] [EOL] [EOL] def steps ( self ) : [EOL] transfer = direct_transfer ( just ( self . token_network . address ) , sampled_from ( self . token_addresses ) , sampled_from ( self . channel_addresses ) , sampled_from ( self . addresses ) , just ( EMPTY_LOCKSROOT ) , ) [EOL] [EOL] deposit_op = tuples ( just ( DEPOSIT ) , integers ( min_value = [number] ) , sampled_from ( self . private_keys ) , sampled_from ( self . private_keys ) , ) [EOL] [EOL] close_op = tuples ( just ( CLOSE ) , transfer , sampled_from ( self . private_keys ) , sampled_from ( self . private_keys ) ) [EOL] [EOL] update_transfer_op = tuples ( just ( UPDATE_TRANSFER ) , transfer , sampled_from ( self . private_keys ) , sampled_from ( self . private_keys ) , ) [EOL] [EOL] transaction_ops = one_of ( deposit_op , close_op , update_transfer_op ) [EOL] [EOL] mine_op = tuples ( just ( MINE ) , integers ( min_value = [number] , max_value = self . settle_timeout * [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] return one_of ( transaction_ops , mine_op ) [EOL] [EOL] def execute_step ( self , step ) : [EOL] op = step [ [number] ] [EOL] [EOL] if op == DEPOSIT : [EOL] try : [EOL] self . contract_deposit ( step [ [number] ] , step [ [number] ] , step [ [number] ] ) [EOL] except BlockGasLimitReached : [EOL] assume ( False ) [EOL] [EOL] elif op == CLOSE : [EOL] try : [EOL] self . contract_close ( step [ [number] ] , step [ [number] ] , step [ [number] ] ) [EOL] except BlockGasLimitReached : [EOL] assume ( False ) [EOL] [EOL] elif op == UPDATE_TRANSFER : [EOL] try : [EOL] self . contract_update_transfer ( step [ [number] ] , step [ [number] ] , step [ [number] ] ) [EOL] except BlockGasLimitReached : [EOL] assume ( False ) [EOL] [EOL] elif op == MINE : [EOL] self . tester_chain . mine_blocks ( num_blocks = step [ [number] ] ) [EOL] [EOL] def is_participant ( self , address ) : [EOL] return address in self . participant_addresses [EOL] [EOL] def contract_deposit ( self , deposit_amount , sender_pkey , partner_pkey ) : [EOL] sender_address = private_key_to_address ( sender_pkey . to_hex ( ) ) [EOL] partner_address = private_key_to_address ( partner_pkey . to_hex ( ) ) [EOL] [EOL] token_balance = self . token . functions . balanceOf ( sender_address ) . call ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if sender_address == partner_address : [EOL] return [EOL] [EOL] ( channel_identifier , _ , channel_state ) = self . token_network . functions . getChannelInfo ( participant1 = sender_address , participant2 = partner_address ) . call ( ) [EOL] [EOL] ( existing_deposit , _ , _ , _ , _ ) = self . token_network . functions . getChannelParticipantInfo ( participant = sender_address , partner = partner_address ) . call ( ) [EOL] [EOL] deposit_amount += existing_deposit [EOL] [EOL] if not self . is_participant ( sender_address ) : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . setTotalDeposit ( sender_address , deposit_amount , partner_address ) . transact ( { [string] : sender_address } ) [EOL] [EOL] elif channel_state != [number] : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . setTotalDeposit ( sender_address , deposit_amount , partner_address ) . transact ( { [string] : sender_address } ) [EOL] [EOL] elif token_balance < deposit_amount : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . setTotalDeposit ( sender_address , deposit_amount , partner_address ) . transact ( { [string] : sender_address } ) [EOL] [EOL] else : [EOL] self . token . functions . approve ( self . token_network . address , deposit_amount ) . transact ( { [string] : sender_address } ) [EOL] [EOL] self . token_network . functions . setTotalDeposit ( sender_address , deposit_amount , partner_address ) . transact ( { [string] : sender_address } ) [EOL] [EOL] def contract_close ( self , transfer , closer_pkey , partner_pkey ) : [EOL] closer_signature = transfer . sign ( closer_pkey , private_key_to_address ( closer_pkey . to_hex ( ) ) ) [EOL] [EOL] closer_address = private_key_to_address ( closer_pkey . to_hex ( ) ) [EOL] partner_address = private_key_to_address ( partner_pkey . to_hex ( ) ) [EOL] transfer_data = transfer . to_bytes ( ) [EOL] [EOL] transfer_hash = Web3 . sha3 ( hexstr = encode_hex ( transfer_data [ : - [number] ] ) ) [EOL] [EOL] if closer_address == partner_address : [EOL] return [EOL] [EOL] ( _ , _ , channel_state ) = self . token_network . functions . getChannelInfo ( participant1 = closer_address , participant2 = partner_address ) . call ( ) [EOL] [EOL] if not self . is_participant ( transfer . sender ) : [EOL] msg = [string] [EOL] with transaction_must_fail ( msg ) : [EOL] self . token_network . functions . closeChannel ( partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , closer_signature , ) . transact ( ) [EOL] [EOL] elif transfer . sender == closer_address : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . closeChannel ( partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , closer_signature , ) . transact ( ) [EOL] [EOL] elif channel_state == [number] : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . closeChannel ( partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , closer_signature , ) . transact ( ) [EOL] [EOL] elif not self . is_participant ( closer_address ) : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . closeChannel ( partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , closer_signature , ) . transact ( ) [EOL] [EOL] elif transfer . channel != to_canonical_address ( self . token_network . address ) : [EOL] msg = [string] [EOL] with transaction_must_fail ( msg ) : [EOL] self . token_network . functions . closeChannel ( partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , closer_signature , ) . transact ( ) [EOL] [EOL] else : [EOL] self . token_network . functions . closeChannel ( partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , closer_signature , ) . transact ( ) [EOL] [EOL] self . closing_address = closer_address [EOL] [EOL] def contract_update_transfer ( self , transfer , sender_pkey , partner_pkey ) : [EOL] sender_signature = transfer . sign ( sender_pkey , private_key_to_address ( sender_pkey . to_hex ( ) ) ) [EOL] [EOL] receiver_signature = transfer . sign ( partner_pkey , private_key_to_address ( partner_pkey . to_hex ( ) ) ) [EOL] [EOL] sender_address = private_key_to_address ( sender_pkey . to_hex ( ) ) [EOL] partner_address = private_key_to_address ( partner_pkey . to_hex ( ) ) [EOL] [EOL] transfer_data = transfer . to_bytes ( ) [EOL] transfer_hash = Web3 . sha3 ( hexstr = encode_hex ( transfer_data [ : - [number] ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if sender_address == partner_address : [EOL] return [EOL] [EOL] ( _ , settle_block_number , channel_state ) = self . token_network . functions . getChannelInfo ( sender_address , partner_address ) . call ( { [string] : self . web3 . eth . accounts [ [number] ] , [string] : GAS_LIMIT } ) [EOL] [EOL] is_closed = channel_state == [number] [EOL] block_number = self . tester_chain . get_block_by_number ( [string] ) [ [string] ] [EOL] is_settlement_period_over = is_closed and settle_block_number < block_number [EOL] [EOL] if not self . is_participant ( transfer . sender ) : [EOL] msg = [string] [EOL] with transaction_must_fail ( msg ) : [EOL] self . token_network . functions . updateNonClosingBalanceProof ( sender_address , partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , sender_signature , receiver_signature , ) . transact ( ) [EOL] [EOL] elif transfer . sender == sender_address : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . updateNonClosingBalanceProof ( sender_address , partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , sender_signature , receiver_signature , ) . transact ( ) [EOL] [EOL] elif self . update_transfer_called : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . updateNonClosingBalanceProof ( sender_address , partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , sender_signature , receiver_signature , ) . transact ( ) [EOL] [EOL] elif not self . is_participant ( sender_address ) : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . updateNonClosingBalanceProof ( sender_address , partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , sender_signature , receiver_signature , ) . transact ( ) [EOL] [EOL] elif transfer . channel != self . channel_addresses [ [number] ] : [EOL] msg = [string] [EOL] with transaction_must_fail ( msg ) : [EOL] self . token_network . functions . updateNonClosingBalanceProof ( sender_address , partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , sender_signature , receiver_signature , ) . transact ( ) [EOL] [EOL] elif not is_closed : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . updateNonClosingBalanceProof ( sender_address , partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , sender_signature , receiver_signature , ) . transact ( ) [EOL] [EOL] elif is_settlement_period_over : [EOL] msg = [string] [EOL] with transaction_must_fail ( msg ) : [EOL] self . token_network . functions . updateNonClosingBalanceProof ( sender_address , partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , sender_signature , receiver_signature , ) . transact ( ) [EOL] [EOL] elif sender_address == self . closing_address : [EOL] with transaction_must_fail ( [string] ) : [EOL] self . token_network . functions . updateNonClosingBalanceProof ( sender_address , partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , sender_signature , receiver_signature , ) . transact ( ) [EOL] [EOL] else : [EOL] self . token_network . functions . updateNonClosingBalanceProof ( sender_address , partner_address , transfer . balance_hash ( ) , transfer . nonce , transfer_hash , sender_signature , receiver_signature , ) . transact ( ) [EOL] self . update_transfer_called = True [EOL] [EOL] def open_channel ( self ) : [EOL] tx_hash = self . token_network . functions . openChannel ( self . addresses [ [number] ] , self . addresses [ [number] ] , TEST_SETTLE_TIMEOUT_MAX ) . transact ( { [string] : self . web3 . eth . accounts [ [number] ] , [string] : GAS_LIMIT } ) [EOL] [EOL] tx_receipt = self . web3 . eth . getTransactionReceipt ( tx_hash ) [EOL] tx_logs = self . token_network . events . ChannelOpened ( ) . processReceipt ( tx_receipt ) [EOL] [EOL] return tx_logs [ [number] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any , List [EOL] import typing [EOL] import logging [EOL] import logging [EOL] from typing import Any , Callable [EOL] [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] [EOL] from raiden_contracts . tests . utils . constants import CONTRACT_DEPLOYER_ADDRESS [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def deploy_tester_contract ( web3 , contracts_manager , deploy_contract ) : [EOL] [docstring] [EOL] [EOL] def f ( contract_name , args = None ) : [EOL] json_contract = contracts_manager . get_contract ( contract_name ) [EOL] contract = deploy_contract ( web3 , CONTRACT_DEPLOYER_ADDRESS , json_contract [ [string] ] , json_contract [ [string] ] , args ) [EOL] return contract [EOL] [EOL] return f [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def deploy_contract_txhash ( ) : [EOL] [docstring] [EOL] [EOL] def fn ( web3 , deployer_address , abi , bytecode , args ) : [EOL] if args is None : [EOL] args = [ ] [EOL] contract = web3 . eth . contract ( abi = abi , bytecode = bytecode ) [EOL] [comment] [EOL] return contract . constructor ( * args ) . transact ( { [string] : deployer_address } ) [EOL] [EOL] return fn [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def deploy_contract ( deploy_contract_txhash ) : [EOL] [docstring] [EOL] [EOL] def fn ( web3 , deployer_address , abi , bytecode , args ) : [EOL] contract = web3 . eth . contract ( abi = abi , bytecode = bytecode ) [EOL] txhash = deploy_contract_txhash ( web3 , deployer_address , abi , bytecode , args ) [EOL] contract_address = web3 . eth . getTransactionReceipt ( txhash ) . contractAddress [EOL] web3 . testing . mine ( [number] ) [EOL] [EOL] if web3 . eth . getTransactionReceipt ( txhash ) . status != [number] : [EOL] raise TransactionFailed ( [string] ) [EOL] [EOL] return contract ( contract_address ) [EOL] [EOL] return fn [EOL] [EOL] [EOL] @ pytest . fixture def deploy_tester_contract_txhash ( web3 , contracts_manager , deploy_contract_txhash ) : [EOL] [docstring] [EOL] [EOL] def f ( contract_name , args = None ) : [EOL] json_contract = contracts_manager . get_contract ( contract_name ) [EOL] txhash = deploy_contract_txhash ( web3 , CONTRACT_DEPLOYER_ADDRESS , json_contract [ [string] ] , json_contract [ [string] ] , args ) [EOL] return txhash [EOL] [EOL] return f [EOL] [EOL] [EOL] @ pytest . fixture def utils_contract ( deploy_tester_contract ) : [EOL] [docstring] [EOL] return deploy_tester_contract ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import web3 [EOL] import pytest [EOL] from web3 import Web3 [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACT_ONE_TO_N [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def one_to_n_contract ( deploy_tester_contract , uninitialized_user_deposit_contract , web3 ) : [EOL] chain_id = int ( web3 . version . network ) [EOL] return deploy_tester_contract ( CONTRACT_ONE_TO_N , [ uninitialized_user_deposit_contract . address , chain_id ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable [EOL] import web3 [EOL] import typing [EOL] from typing import Callable [EOL] [EOL] import pytest [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACT_ENDPOINT_REGISTRY [EOL] [EOL] [EOL] @ pytest . fixture def endpoint_registry_contract ( deploy_tester_contract ) : [EOL] [docstring] [EOL] return deploy_tester_contract ( CONTRACT_ENDPOINT_REGISTRY ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable [EOL] import web3 [EOL] import typing [EOL] from typing import Callable [EOL] [EOL] import pytest [EOL] from web3 import Web3 [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import TEST_SETTLE_TIMEOUT_MAX , TEST_SETTLE_TIMEOUT_MIN [EOL] [EOL] [EOL] @ pytest . fixture ( ) def token_network_test_storage ( deploy_tester_contract , web3 , custom_token , secret_registry_contract , ) : [EOL] return deploy_tester_contract ( [string] , [ custom_token . address , secret_registry_contract . address , int ( web3 . version . network ) , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , ] , ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def token_network_test_signatures ( deploy_tester_contract , web3 , custom_token , secret_registry_contract , ) : [EOL] return deploy_tester_contract ( [string] , [ custom_token . address , secret_registry_contract . address , int ( web3 . version . network ) , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , ] , ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def token_network_test_utils ( deploy_tester_contract , web3 , custom_token , secret_registry_contract , ) : [EOL] return deploy_tester_contract ( [string] , [ custom_token . address , secret_registry_contract . address , int ( web3 . version . network ) , TEST_SETTLE_TIMEOUT_MIN , TEST_SETTLE_TIMEOUT_MAX , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable [EOL] import web3 [EOL] import typing [EOL] from typing import Callable [EOL] [EOL] import pytest [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACT_SERVICE_REGISTRY [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def service_registry ( deploy_tester_contract , custom_token ) : [EOL] return deploy_tester_contract ( CONTRACT_SERVICE_REGISTRY , [ custom_token . address ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable [EOL] import web3 [EOL] import typing [EOL] from typing import Callable [EOL] [EOL] import pytest [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACT_SECRET_REGISTRY [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def secret_registry_contract ( deploy_tester_contract ) : [EOL] [docstring] [EOL] return deploy_tester_contract ( CONTRACT_SECRET_REGISTRY ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from . base import * [EOL] from . channel import * [EOL] from . contracts import * [EOL] from . endpoint_registry import * [EOL] from . monitoring_service import * [EOL] from . one_to_n import * [EOL] from . secret_registry import * [EOL] from . service_registry_fixtures import * [EOL] from . test_contracts import * [EOL] from . token import * [EOL] from . token_network_fixtures import * [EOL] from . token_network_registry import * [EOL] from . user_deposit import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable [EOL] import web3 [EOL] import eth_typing [EOL] import builtins [EOL] import typing [EOL] from typing import Callable [EOL] [EOL] import pytest [EOL] from eth_typing . evm import HexAddress [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACT_USER_DEPOSIT [EOL] from raiden_contracts . tests . fixtures . token import CUSTOM_TOKEN_TOTAL_SUPPLY [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def user_deposit_whole_balance_limit ( ) : [EOL] return CUSTOM_TOKEN_TOTAL_SUPPLY // [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def uninitialized_user_deposit_contract ( deploy_tester_contract , custom_token , user_deposit_whole_balance_limit ) : [EOL] return deploy_tester_contract ( CONTRACT_USER_DEPOSIT , [ custom_token . address , user_deposit_whole_balance_limit ] ) [EOL] [EOL] [EOL] @ pytest . fixture def user_deposit_contract ( uninitialized_user_deposit_contract , monitoring_service_external , one_to_n_contract , ) : [EOL] uninitialized_user_deposit_contract . functions . init ( monitoring_service_external . address , one_to_n_contract . address ) . call_and_transact ( ) [EOL] return uninitialized_user_deposit_contract [EOL] [EOL] [EOL] @ pytest . fixture def udc_transfer_contract ( deploy_tester_contract , uninitialized_user_deposit_contract ) : [EOL] return deploy_tester_contract ( [string] , [ uninitialized_user_deposit_contract . address ] ) [EOL] [EOL] [EOL] @ pytest . fixture def deposit_to_udc ( user_deposit_contract , custom_token ) : [EOL] def deposit ( receiver , amount ) : [EOL] [docstring] [EOL] custom_token . functions . mint ( amount ) . call_and_transact ( { [string] : receiver } ) [EOL] custom_token . functions . approve ( user_deposit_contract . address , amount ) . call_and_transact ( { [string] : receiver } ) [EOL] user_deposit_contract . functions . deposit ( receiver , amount ) . call_and_transact ( { [string] : receiver } ) [EOL] [EOL] return deposit [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Callable , Any , Tuple [EOL] import web3 [EOL] import builtins [EOL] import typing [EOL] from typing import Callable , List , Tuple [EOL] [EOL] import pytest [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACT_CUSTOM_TOKEN , CONTRACT_HUMAN_STANDARD_TOKEN [EOL] [EOL] CUSTOM_TOKEN_TOTAL_SUPPLY = [number] ** [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def token_args ( ) : [EOL] return ( CUSTOM_TOKEN_TOTAL_SUPPLY , [number] , CONTRACT_CUSTOM_TOKEN , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def custom_token_factory ( deploy_tester_contract , token_args ) : [EOL] [docstring] [EOL] [EOL] def f ( ) : [EOL] return deploy_tester_contract ( CONTRACT_CUSTOM_TOKEN , token_args ) [EOL] [EOL] return f [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def custom_token ( custom_token_factory ) : [EOL] [docstring] [EOL] return custom_token_factory ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def human_standard_token ( deploy_token_contract , token_args ) : [EOL] [docstring] [EOL] return deploy_token_contract ( * token_args ) [EOL] [EOL] [EOL] @ pytest . fixture def deploy_token_contract ( deploy_tester_contract ) : [EOL] [docstring] [EOL] [EOL] def f ( initial_amount , decimals , token_name , token_symbol ) : [EOL] assert initial_amount > [number] [EOL] assert decimals > [number] [EOL] return deploy_tester_contract ( CONTRACT_HUMAN_STANDARD_TOKEN , [ initial_amount , decimals , token_name , token_symbol ] ) [EOL] [EOL] return f [EOL] [EOL] [EOL] @ pytest . fixture def standard_token_contract ( custom_token ) : [EOL] [docstring] [EOL] return custom_token [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import web3 [EOL] import typing [EOL] import pytest [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . constants import CONTRACT_MONITORING_SERVICE [EOL] from raiden_contracts . utils . proofs import sign_reward_proof [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def monitoring_service_external ( deploy_tester_contract , custom_token , service_registry , uninitialized_user_deposit_contract ) : [EOL] return deploy_tester_contract ( CONTRACT_MONITORING_SERVICE , [ custom_token . address , service_registry . address , uninitialized_user_deposit_contract . address , ] , ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def monitoring_service_internals ( custom_token , service_registry , uninitialized_user_deposit_contract , deploy_tester_contract ) : [EOL] return deploy_tester_contract ( [string] , [ custom_token . address , service_registry . address , uninitialized_user_deposit_contract . address , ] , ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def create_reward_proof ( token_network , get_private_key ) : [EOL] def get ( signer , channel_identifier , reward_amount , token_network_address , nonce = [number] , v = [number] ) : [EOL] private_key = get_private_key ( signer ) [EOL] [EOL] signature = sign_reward_proof ( private_key , channel_identifier , reward_amount , token_network_address , int ( token_network . functions . chain_id ( ) . call ( ) ) , nonce , v , ) [EOL] return ( channel_identifier , reward_amount , token_network_address , int ( token_network . functions . chain_id ( ) . call ( ) ) , nonce , signature , ) [EOL] [EOL] return get [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any [EOL] import web3 [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import logging [EOL] from typing import Dict , Optional [EOL] [EOL] import pytest [EOL] from eth_tester import EthereumTester , PyEVMBackend [EOL] from web3 import Web3 [EOL] from web3 . contract import ContractFunction [EOL] from web3 . providers . eth_tester import EthereumTesterProvider [EOL] [EOL] from raiden_contracts . tests . utils . constants import ( FAUCET_ADDRESS , FAUCET_ALLOWANCE , FAUCET_PRIVATE_KEY , ) [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def ethereum_tester ( patch_genesis_gas_limit ) : [comment] [EOL] [docstring] [EOL] return EthereumTester ( PyEVMBackend ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def patch_genesis_gas_limit ( ) : [EOL] [docstring] [EOL] [EOL] tmp_limit = [number] * [number] ** [number] [EOL] import eth_tester . backends . pyevm . main as pyevm_main [EOL] [EOL] pyevm_main . GENESIS_GAS_LIMIT = tmp_limit [EOL] import eth . vm . forks . frontier . headers as headers [EOL] [EOL] headers . GENESIS_GAS_LIMIT = tmp_limit [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def web3 ( ethereum_tester , ) : [EOL] [docstring] [EOL] provider = EthereumTesterProvider ( ethereum_tester ) [EOL] web3 = Web3 ( provider ) [EOL] [comment] [EOL] web3 . eth . estimateGas = lambda txn : int ( [number] ) [comment] [EOL] [EOL] [comment] [EOL] ethereum_tester . add_account ( FAUCET_PRIVATE_KEY ) [EOL] [EOL] [comment] [EOL] ethereum_tester . send_transaction ( { [string] : ethereum_tester . get_accounts ( ) [ [number] ] , [string] : FAUCET_ADDRESS , [string] : [number] , [string] : FAUCET_ALLOWANCE , } ) [EOL] [EOL] yield web3 [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def auto_revert_chain ( web3 ) : [EOL] [docstring] [EOL] snapshot_id = web3 . testing . snapshot ( ) [EOL] yield [EOL] web3 . testing . revert ( snapshot_id ) [EOL] [EOL] [EOL] def _call_and_transact ( contract_function , transaction_params = None ) : [EOL] [docstring] [EOL] [comment] [EOL] contract_function . call ( transaction_params ) [EOL] return contract_function . transact ( transaction_params ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def call_and_transact ( ) : [EOL] ContractFunction . call_and_transact = _call_and_transact [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import pytest [EOL] from eth_utils import is_address [EOL] from eth_utils . units import units [EOL] [EOL] from raiden_contracts . tests . utils . constants import FAUCET_ADDRESS [EOL] [EOL] [EOL] @ pytest . fixture def send_funds ( ethereum_tester , custom_token ) : [EOL] [docstring] [EOL] [EOL] def f ( target ) : [EOL] assert is_address ( target ) [EOL] ethereum_tester . send_transaction ( { [string] : FAUCET_ADDRESS , [string] : target , [string] : [number] , [string] : [number] * int ( units [ [string] ] ) } ) [EOL] custom_token . functions . transfer ( _to = target , _value = [number] ) . call_and_transact ( { [string] : FAUCET_ADDRESS } ) [EOL] [EOL] return f [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from . address import * [EOL] from . contract_manager import * [EOL] from . utils import * [EOL] from . web3_fixtures import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Iterator , Any , List [EOL] import builtins [EOL] import typing [EOL] import json [EOL] from sys import argv [EOL] from typing import Dict [EOL] [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from eth_utils import is_same_address [EOL] from eth_utils . units import units [EOL] [EOL] from raiden_contracts . contract_manager import contracts_gas_path [EOL] from raiden_contracts . tests . utils import get_random_privkey [EOL] from raiden_contracts . utils . logs import LogHandler [EOL] from raiden_contracts . utils . signature import private_key_to_address [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def create_account ( web3 , ethereum_tester ) : [EOL] def get ( privkey = None ) : [EOL] if not privkey : [EOL] privkey = get_random_privkey ( ) [EOL] address = private_key_to_address ( privkey ) [EOL] [EOL] if not any ( ( is_same_address ( address , x ) for x in ethereum_tester . get_accounts ( ) ) ) : [EOL] [comment] [EOL] ethereum_tester . add_account ( privkey ) [EOL] [EOL] for faucet in web3 . eth . accounts [ : [number] ] : [EOL] try : [EOL] web3 . eth . sendTransaction ( { [string] : faucet , [string] : address , [string] : [number] * int ( units [ [string] ] ) } ) [EOL] break [EOL] except TransactionFailed : [EOL] continue [EOL] return address [EOL] [EOL] return get [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def get_accounts ( create_account ) : [EOL] def get ( number , privkeys = ( ) ) : [EOL] privkeys = iter ( privkeys ) [EOL] return [ create_account ( privkey = next ( privkeys , None ) ) for x in range ( number ) ] [EOL] [EOL] return get [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def get_private_key ( ethereum_tester ) : [EOL] def get ( account_address ) : [EOL] keys = [ key . to_hex ( ) for key in ethereum_tester . backend . account_keys if is_same_address ( key . public_key . to_address ( ) , account_address ) ] [EOL] assert len ( keys ) == [number] [EOL] return keys [ [number] ] [EOL] [EOL] return get [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def event_handler ( web3 ) : [EOL] def get ( contract = None , address = None , abi = None ) : [EOL] if contract : [EOL] abi = contract . abi [EOL] address = contract . address [EOL] [EOL] if address and abi : [EOL] return LogHandler ( web3 = web3 , address = address , abi = abi ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] return get [EOL] [EOL] [EOL] @ pytest . fixture def txn_cost ( web3 , txn_gas ) : [EOL] def get ( txn_hash ) : [EOL] return txn_gas ( txn_hash ) * web3 . eth . gasPrice [EOL] [EOL] return get [EOL] [EOL] [EOL] @ pytest . fixture def txn_gas ( web3 ) : [EOL] def get ( txn_hash ) : [EOL] receipt = web3 . eth . getTransactionReceipt ( txn_hash ) [EOL] return receipt [ [string] ] [EOL] [EOL] return get [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def gas_measurement_results ( ) : [EOL] results = { } [EOL] return results [EOL] [EOL] [EOL] def sys_args_contain ( searched ) : [EOL] [docstring] [EOL] for arg in argv : [EOL] if arg . find ( searched ) != - [number] : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] @ pytest . fixture def print_gas ( txn_gas , gas_measurement_results ) : [EOL] def get ( txn_hash , message = None , additional_gas = [number] ) : [EOL] if not sys_args_contain ( [string] ) : [EOL] [comment] [EOL] return [EOL] [EOL] gas_used = txn_gas ( txn_hash ) [EOL] if not message : [EOL] message = txn_hash [EOL] [EOL] print ( [string] ) [EOL] print ( [string] + message , gas_used + additional_gas ) [EOL] print ( [string] ) [EOL] gas_measurement_results [ message ] = gas_used + additional_gas [EOL] with contracts_gas_path ( ) . open ( mode = [string] ) as target_file : [EOL] target_file . write ( json . dumps ( gas_measurement_results , sort_keys = True , indent = [number] ) ) [EOL] [EOL] return get [EOL] [EOL] [EOL] @ pytest . fixture ( ) def get_block ( web3 ) : [EOL] def get ( txn_hash ) : [EOL] receipt = web3 . eth . getTransactionReceipt ( txn_hash ) [EOL] return receipt [ [string] ] [EOL] [EOL] return get [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator [EOL] import typing [EOL] import raiden_contracts [EOL] from pathlib import Path [EOL] from tempfile import NamedTemporaryFile [EOL] from typing import Generator [EOL] [EOL] import pytest [EOL] [EOL] from raiden_contracts . contract_source_manager import ContractSourceManager , contracts_source_path [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def contract_source_manager ( ) : [EOL] return ContractSourceManager ( contracts_source_path ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def contracts_manager ( contract_source_manager ) : [EOL] with NamedTemporaryFile ( ) as target_path : [EOL] yield contract_source_manager . compile_contracts ( Path ( target_path . name ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden_contracts.contract_source_manager.ContractSourceManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import web3 [EOL] import pytest [EOL] from eth_typing . evm import HexAddress [EOL] from web3 import Web3 [EOL] from web3 . contract import Contract [EOL] [EOL] from raiden_contracts . utils . logs import LogFilter [EOL] [EOL] [EOL] def test_logfilter_with_nonexistent_event ( web3 ) : [EOL] [docstring] [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] LogFilter ( web3 = web3 , abi = [ ] , address = HexAddress ( [string] ) , event_name = [string] , from_block = [number] , to_block = [string] , ) [EOL] [EOL] [EOL] def test_call_and_transact_does_not_mine ( web3 , custom_token ) : [EOL] [docstring] [EOL] [EOL] before = web3 . eth . blockNumber [EOL] custom_token . functions . multiplier ( ) . call_and_transact ( ) [EOL] after = web3 . eth . blockNumber [EOL] assert before + [number] == after [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] [EOL] from raiden_contracts . constants import TEST_SETTLE_TIMEOUT_MAX , TEST_SETTLE_TIMEOUT_MIN [EOL] from raiden_contracts . tests . utils import fake_bytes [EOL] [EOL] [EOL] def test_settle_timeout_inrange ( token_network , get_accounts , web3 ) : [EOL] [docstring] [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] [EOL] small_settle_timeout = TEST_SETTLE_TIMEOUT_MIN - [number] [EOL] large_settle_timeout = TEST_SETTLE_TIMEOUT_MAX + [number] [EOL] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] token_network . functions . openChannel ( A , B , small_settle_timeout ) . call ( ) [EOL] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] token_network . functions . openChannel ( A , B , large_settle_timeout ) . call ( ) [EOL] [EOL] token_network . functions . openChannel ( A , B , TEST_SETTLE_TIMEOUT_MIN ) . call_and_transact ( ) [EOL] channel_identifier = token_network . functions . getChannelIdentifier ( A , B ) . call ( ) [EOL] ( settle_block_number , _ ) = token_network . functions . getChannelInfo ( channel_identifier , A , B ) . call ( ) [EOL] [EOL] assert settle_block_number == TEST_SETTLE_TIMEOUT_MIN [EOL] [EOL] token_network . functions . closeChannel ( channel_identifier , B , fake_bytes ( [number] ) , [number] , fake_bytes ( [number] ) , fake_bytes ( [number] ) ) . call_and_transact ( { [string] : A } ) [EOL] web3 . testing . mine ( TEST_SETTLE_TIMEOUT_MIN + [number] ) [EOL] token_network . functions . settleChannel ( channel_identifier , A , [number] , [number] , fake_bytes ( [number] ) , B , [number] , [number] , fake_bytes ( [number] ) ) . call_and_transact ( { [string] : A } ) [EOL] token_network . functions . openChannel ( A , B , TEST_SETTLE_TIMEOUT_MAX ) . call_and_transact ( ) [EOL] channel_identifier = token_network . functions . getChannelIdentifier ( A , B ) . call ( ) [EOL] ( settle_block_number , _ ) = token_network . functions . getChannelInfo ( channel_identifier , A , B ) . call ( ) [EOL] [EOL] assert settle_block_number == TEST_SETTLE_TIMEOUT_MAX [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import typing [EOL] from typing import Callable [EOL] [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from web3 import Web3 [EOL] [EOL] from raiden_contracts . tests . utils . constants import EMPTY_ADDRESS [EOL] from raiden_contracts . utils . proofs import hash_balance_proof [EOL] from raiden_contracts . utils . signature import sign [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . fixture def signature_test_contract ( deploy_tester_contract ) : [EOL] return deploy_tester_contract ( [string] ) [EOL] [EOL] [EOL] def test_verify ( web3 , token_network , signature_test_contract , get_accounts , create_channel , create_balance_proof , ) : [EOL] [docstring] [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] channel_identifier = create_channel ( A , B ) [ [number] ] [EOL] [EOL] balance_proof_A = create_balance_proof ( channel_identifier , A , [number] , [number] , [number] ) [EOL] signature = balance_proof_A [ [number] ] [EOL] balance_proof_hash = hash_balance_proof ( token_network . address , int ( web3 . version . network ) , channel_identifier , * balance_proof_A [ : [number] ] ) [EOL] address = signature_test_contract . functions . verify ( balance_proof_hash , signature ) . call ( ) [EOL] assert address == A [EOL] [EOL] balance_proof_B = create_balance_proof ( channel_identifier , B , [number] , [number] , [number] ) [EOL] signature = balance_proof_B [ [number] ] [EOL] balance_proof_hash = hash_balance_proof ( token_network . address , int ( web3 . version . network ) , channel_identifier , * balance_proof_B [ : [number] ] ) [EOL] address = signature_test_contract . functions . verify ( balance_proof_hash , signature ) . call ( ) [EOL] assert address == B [EOL] [EOL] [EOL] def test_verify_fail ( signature_test_contract , get_accounts , get_private_key ) : [EOL] [docstring] [EOL] A = get_accounts ( [number] ) [ [number] ] [EOL] message_hash = Web3 . soliditySha3 ( [ [string] , [string] ] , [ [string] , [number] ] ) [EOL] signature = sign ( get_private_key ( A ) , message_hash , v = [number] ) [EOL] [EOL] assert signature_test_contract . functions . verify ( message_hash , signature ) . call ( ) == A [EOL] [EOL] message_hash = Web3 . soliditySha3 ( [ [string] , [string] ] , [ [string] , [number] ] ) [EOL] assert signature_test_contract . functions . verify ( message_hash , signature ) . call ( ) != A [EOL] [EOL] signature2 = signature [ : [number] ] + bytes ( [ [number] ] ) [EOL] with pytest . raises ( TransactionFailed ) : [EOL] signature_test_contract . functions . verify ( message_hash , signature2 ) . call ( ) [EOL] [EOL] [EOL] def test_ecrecover_output ( web3 , token_network , signature_test_contract , get_accounts , create_channel , create_balance_proof , ) : [EOL] [docstring] [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] channel_identifier = create_channel ( A , B ) [ [number] ] [EOL] balance_proof_A = create_balance_proof ( channel_identifier , A , [number] , [number] , [number] ) [EOL] signature = balance_proof_A [ [number] ] [EOL] r = signature [ : [number] ] [EOL] s = signature [ [number] : [number] ] [EOL] v = signature [ [number] : ] [EOL] balance_proof_hash = hash_balance_proof ( token_network . address , int ( web3 . version . network ) , channel_identifier , * balance_proof_A [ : [number] ] ) [EOL] [EOL] address = signature_test_contract . functions . verifyEcrecoverOutput ( balance_proof_hash , r , s , int . from_bytes ( v , byteorder = [string] ) ) . call ( ) [EOL] assert address == A [EOL] [EOL] [EOL] def test_ecrecover_output_zero ( signature_test_contract , get_accounts , get_private_key ) : [EOL] [docstring] [EOL] A = get_accounts ( [number] ) [ [number] ] [EOL] privatekey = get_private_key ( A ) [EOL] message_hash = Web3 . soliditySha3 ( [ [string] , [string] ] , [ [string] , [number] ] ) [EOL] signature = sign ( privatekey , message_hash , v = [number] ) [EOL] [EOL] assert ( signature_test_contract . functions . verifyEcrecoverOutput ( message_hash , signature [ : [number] ] , signature [ [number] : [number] ] , [number] ) . call ( ) == EMPTY_ADDRESS ) [EOL] [EOL] [EOL] def test_ecrecover_output_fail ( signature_test_contract , get_accounts , get_private_key ) : [EOL] [docstring] [EOL] A = get_accounts ( [number] ) [ [number] ] [EOL] privatekey = get_private_key ( A ) [EOL] message_hash = Web3 . soliditySha3 ( [ [string] , [string] ] , [ [string] , [number] ] ) [EOL] signature = sign ( privatekey , message_hash , v = [number] ) [EOL] [EOL] assert ( signature_test_contract . functions . verifyEcrecoverOutput ( message_hash , signature [ : [number] ] , signature [ [number] : [number] ] , int . from_bytes ( signature [ [number] : ] , byteorder = [string] ) , ) . call ( ) == A ) [EOL] [EOL] message_hash2 = Web3 . soliditySha3 ( [ [string] , [string] ] , [ [string] , [number] ] ) [EOL] assert ( signature_test_contract . functions . verifyEcrecoverOutput ( message_hash2 , signature [ : [number] ] , signature [ [number] : [number] ] , int . from_bytes ( signature [ [number] : ] , byteorder = [string] ) , ) . call ( ) != A ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from eth_tester . exceptions import TransactionFailed [EOL] [EOL] from raiden_contracts . tests . utils import fake_bytes [EOL] [EOL] [EOL] def test_recover_address_from_withdraw_message ( token_network_test_signatures , create_withdraw_signatures , create_channel_and_deposit , get_accounts , ) : [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] token_network = token_network_test_signatures [EOL] fake_signature = fake_bytes ( [number] ) [EOL] deposit_A = [number] [EOL] deposit_B = [number] [EOL] withdraw_A = [number] [EOL] channel_identifier = create_channel_and_deposit ( A , B , deposit_A , deposit_B ) [EOL] ( signature_A , signature_B ) = create_withdraw_signatures ( [ A , B ] , channel_identifier , A , withdraw_A , token_network . address ) [EOL] [EOL] recovered_address_A = token_network . functions . recoverAddressFromWithdrawMessagePublic ( channel_identifier , A , withdraw_A , signature_A ) . call ( ) [EOL] assert recovered_address_A == A [EOL] [EOL] recovered_address_B = token_network . functions . recoverAddressFromWithdrawMessagePublic ( channel_identifier , A , withdraw_A , signature_B ) . call ( ) [EOL] assert recovered_address_B == B [EOL] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] token_network . functions . recoverAddressFromWithdrawMessagePublic ( channel_identifier , A , withdraw_A , fake_signature ) . call ( ) [EOL] [EOL] wrong_participant = token_network . functions . recoverAddressFromWithdrawMessagePublic ( channel_identifier , B , withdraw_A , signature_A ) . call ( ) [EOL] assert recovered_address_A != wrong_participant [EOL] [EOL] wrong_withdraw_value = token_network . functions . recoverAddressFromWithdrawMessagePublic ( channel_identifier , A , [number] , signature_A ) . call ( ) [EOL] [EOL] assert recovered_address_A != wrong_withdraw_value [EOL] [EOL] wrong_signature = token_network . functions . recoverAddressFromWithdrawMessagePublic ( channel_identifier , A , withdraw_A , signature_B ) . call ( ) [EOL] [EOL] assert recovered_address_A != wrong_signature [EOL] [EOL] [EOL] def test_recover_address_from_balance_proof ( token_network_test_signatures , create_balance_proof , get_accounts ) : [EOL] [docstring] [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] [EOL] channel_identifier = [number] [EOL] balance_proof = create_balance_proof ( channel_identifier , A , other_token_network = token_network_test_signatures ) [EOL] [EOL] balance_proof_wrong_token_network = create_balance_proof ( channel_identifier , A ) [EOL] [EOL] balance_proof_other_signer = create_balance_proof ( channel_identifier , A , signer = B , other_token_network = token_network_test_signatures ) [EOL] [EOL] assert ( A == token_network_test_signatures . functions . recoverAddressFromBalanceProofPublic ( channel_identifier , * balance_proof ) . call ( ) ) [EOL] [EOL] assert ( B == token_network_test_signatures . functions . recoverAddressFromBalanceProofPublic ( channel_identifier , * balance_proof_other_signer ) . call ( ) ) [EOL] [EOL] assert ( A != token_network_test_signatures . functions . recoverAddressFromBalanceProofPublic ( channel_identifier , * balance_proof_wrong_token_network ) . call ( ) ) [EOL] [EOL] [EOL] def test_recover_address_from_balance_proof_update ( token_network_test_signatures , create_balance_proof , create_balance_proof_update_signature , get_accounts , ) : [EOL] [docstring] [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] other_token_network = token_network_test_signatures [EOL] [EOL] channel_identifier = [number] [EOL] balance_proof = create_balance_proof ( channel_identifier , A , other_token_network = other_token_network ) [EOL] balance_proof_update_signature = create_balance_proof_update_signature ( B , channel_identifier , * balance_proof , other_token_network = other_token_network ) [EOL] [EOL] balance_proof_update_signature_wrong_token_network = create_balance_proof_update_signature ( B , channel_identifier , * balance_proof ) [EOL] [EOL] balance_proof_signed_B = create_balance_proof ( channel_identifier , B , other_token_network = other_token_network ) [EOL] balance_proof_update_signature_wrong_signer = create_balance_proof_update_signature ( B , channel_identifier , * balance_proof_signed_B ) [EOL] [EOL] assert ( B == other_token_network . functions . recoverAddressFromBalanceProofUpdateMessagePublic ( channel_identifier , * balance_proof , balance_proof_update_signature ) . call ( ) ) [EOL] [EOL] assert ( B != other_token_network . functions . recoverAddressFromBalanceProofUpdateMessagePublic ( channel_identifier , * balance_proof , balance_proof_update_signature_wrong_token_network ) . call ( ) ) [EOL] [EOL] assert ( B != other_token_network . functions . recoverAddressFromBalanceProofUpdateMessagePublic ( channel_identifier , * balance_proof , balance_proof_update_signature_wrong_signer ) . call ( ) ) [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_recover_address_from_cooperative_settle_signature ( token_network_test_signatures , create_cooperative_settle_signatures , get_accounts ) : [EOL] ( A , B ) = get_accounts ( [number] ) [EOL] other_token_network = token_network_test_signatures [EOL] channel_identifier = [number] [EOL] fake_signature = fake_bytes ( [number] ) [EOL] [EOL] ( signature_A , signature_B ) = create_cooperative_settle_signatures ( [ A , B ] , channel_identifier , A , [number] , B , [number] , other_token_network = other_token_network ) [EOL] assert ( A == other_token_network . functions . recoverAddressFromCooperativeSettleSignaturePublic ( channel_identifier , A , [number] , B , [number] , signature_A ) . call ( ) ) [EOL] [EOL] assert ( B == other_token_network . functions . recoverAddressFromCooperativeSettleSignaturePublic ( channel_identifier , A , [number] , B , [number] , signature_B ) . call ( ) ) [EOL] [EOL] assert ( B != other_token_network . functions . recoverAddressFromCooperativeSettleSignaturePublic ( channel_identifier , A , [number] , B , [number] , signature_A ) . call ( ) ) [EOL] [EOL] assert ( A != other_token_network . functions . recoverAddressFromCooperativeSettleSignaturePublic ( channel_identifier , A , [number] , B , [number] , signature_B ) . call ( ) ) [EOL] [EOL] with pytest . raises ( TransactionFailed ) : [EOL] other_token_network . functions . recoverAddressFromCooperativeSettleSignaturePublic ( channel_identifier , A , [number] , B , [number] , fake_signature ) . call ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import functools [EOL] import click [EOL] from logging import getLogger [EOL] from typing import Optional [EOL] [EOL] from eth_utils import is_address , to_checksum_address [EOL] from raiden_contracts . constants import ( CONTRACT_CUSTOM_TOKEN , ) [EOL] [EOL] [EOL] log = getLogger ( __name__ ) [EOL] [EOL] [EOL] @ click . group ( chain = True ) def main ( ) : [EOL] pass [EOL] [EOL] [EOL] def validate_address ( ctx , param , value ) : [EOL] if not value : [EOL] return None [EOL] try : [EOL] is_address ( value ) [EOL] return to_checksum_address ( value ) [EOL] except ValueError : [EOL] raise click . BadParameter ( [string] ) [EOL] [EOL] def error_removed_option ( message ) : [EOL] [docstring] [EOL] [EOL] def f ( _ , param , value ) : [EOL] if value is not None : [EOL] raise click . NoSuchOption ( f' [string] { param . name . replace ( [string] , [string] ) } [string] ' + message ) [EOL] [EOL] return f [EOL] [EOL] [EOL] [EOL] def common_options ( func ) : [EOL] [docstring] [EOL] [EOL] @ click . option ( [string] , required = True , help = [string] ) @ click . option ( [string] , default = [string] , help = [string] , ) @ click . option ( [string] , default = [number] , help = [string] ) @ click . option ( [string] , default = [number] , type = int , help = [string] ) @ click . option ( [string] , default = [number] ) @ click . option ( [string] , default = None , help = [string] , ) @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] @ main . command ( ) @ common_options @ click . option ( [string] , default = True , help = [string] ) @ click . option ( [string] , help = [string] , type = int ) @ click . pass_context def lumino ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , save_info , contracts_version , max_token_networks , ) : [EOL] from raiden_contracts . deploy . __main__ import raiden [EOL] raiden ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , save_info , contracts_version , max_token_networks ) [EOL] [EOL] [EOL] [EOL] [EOL] @ main . command ( ) @ common_options @ click . option ( [string] , default = [number] , help = [string] , ) @ click . option ( [string] , default = CONTRACT_CUSTOM_TOKEN , help = [string] ) @ click . option ( [string] , default = [number] , help = [string] ) @ click . option ( [string] , default = [string] , help = [string] ) @ click . pass_context def token ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version , token_supply , token_name , token_decimals , token_symbol , ) : [EOL] from raiden_contracts . deploy . __main__ import token [EOL] token ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version , token_supply , token_name , token_decimals , token_symbol ) [EOL] [EOL] @ main . command ( ) @ common_options @ click . option ( [string] , default = None , callback = validate_address , help = [string] , ) @ click . option ( [string] , default = None , callback = error_removed_option ( [string] ) , hidden = True , help = [string] , ) @ click . option ( [string] , default = None , callback = validate_address , help = [string] , ) @ click . option ( [string] , default = None , type = int , help = [string] , ) @ click . option ( [string] , default = None , type = int , help = [string] , ) @ click . pass_context def register ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version , token_address , token_network_registry_address , channel_participant_deposit_limit , token_network_deposit_limit , registry_address , ) : [EOL] from raiden_contracts . deploy . __main__ import register [EOL] register ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , contracts_version , token_address , token_network_registry_address , channel_participant_deposit_limit , token_network_deposit_limit , registry_address ) [EOL] [EOL] [EOL] @ main . command ( ) @ common_options @ click . option ( [string] , default = None , callback = validate_address , help = [string] , ) @ click . option ( [string] , required = True , type = int , help = [string] , ) @ click . option ( [string] , default = True , help = [string] ) @ click . pass_context @ click . pass_context def services ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , token_address , save_info , contracts_version , user_deposit_whole_limit ) : [EOL] from raiden_contracts . deploy . __main__ import services [EOL] services ( ctx , private_key , rpc_provider , wait , gas_price , gas_limit , token_address , save_info , contracts_version , user_deposit_whole_limit ) [EOL] [EOL] @ main . command ( ) @ click . option ( [string] , default = [string] , help = [string] ) @ click . option ( [string] , help = [string] , ) @ click . pass_context def verify ( ctx , rpc_provider , contracts_version ) : [EOL] from raiden_contracts . deploy . __main__ import verify [EOL] verify ( ctx , rpc_provider , contracts_version ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0