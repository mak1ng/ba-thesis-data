from typing import Any [EOL] import typing [EOL] import torrent [EOL] import trio [EOL] import logging [EOL] import builtins [EOL] import src [EOL] import hashlib [EOL] import logging [EOL] import os [EOL] from typing import Any [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] import trio [EOL] [EOL] import torrent as tstate [EOL] [EOL] [EOL] def _create_empty_file ( path , torrent ) : [EOL] with open ( path , [string] ) as f : [EOL] for i in range ( torrent . _num_pieces ) : [comment] [EOL] b = bytes ( torrent . piece_length ( i ) ) [EOL] f . write ( b ) [EOL] [EOL] [EOL] class FileWrapper ( object ) : [EOL] def __init__ ( self , * , torrent , file_suffix = [string] ) : [EOL] self . _torrent = torrent [EOL] self . _tmp_path = torrent . file_path + file_suffix + [string] [EOL] self . _final_path = torrent . file_path + file_suffix [EOL] self . _file_path = None [EOL] self . _file = None [EOL] [EOL] def create_file_or_return_hashes ( self ) : [EOL] if os . path . exists ( self . _final_path ) : [EOL] self . _file_path = self . _final_path [EOL] else : [EOL] self . _file_path = self . _tmp_path [EOL] try : [EOL] self . _file = open ( self . _file_path , [string] ) [EOL] hashes = [ ] [EOL] for i , _ in enumerate ( self . _torrent . _complete ) : [EOL] l = self . _torrent . piece_length ( i ) [EOL] p = self . read_block ( i , [number] , l ) [EOL] h = hashlib . sha1 ( p ) . digest ( ) [EOL] hashes . append ( h ) [EOL] self . _file . close ( ) [EOL] except FileNotFoundError : [EOL] _create_empty_file ( self . _file_path , self . _torrent ) [comment] [EOL] hashes = None [EOL] self . _file = open ( self . _file_path , [string] ) [EOL] return hashes [EOL] [EOL] def write_piece ( self , index , piece ) : [EOL] start = index * self . _torrent . _piece_length [comment] [EOL] self . _file . seek ( start ) [EOL] self . _file . write ( piece ) [EOL] self . _file . flush ( ) [EOL] [EOL] def read_block ( self , index , begin , length ) : [EOL] start = index * self . _torrent . _piece_length + begin [EOL] self . _file . seek ( start ) [EOL] block = self . _file . read ( length ) [EOL] return block [EOL] [EOL] def move_file_to_final_location ( self ) : [EOL] if self . _file_path != self . _final_path : [EOL] self . _file . close ( ) [EOL] os . rename ( self . _file_path , self . _final_path ) [EOL] logger . info ( [string] . format ( self . _file_path , self . _final_path ) ) [EOL] self . _file_path = self . _final_path [EOL] self . _file = open ( self . _file_path , [string] ) [EOL] [EOL] [EOL] class FileManager ( object ) : [EOL] def __init__ ( self , * , file_wrapper , pieces_to_write , write_confirmations , blocks_to_read , blocks_for_peers , ) : [EOL] self . _file_wrapper = file_wrapper [EOL] self . _pieces_to_write = pieces_to_write [EOL] self . _write_confirmations = write_confirmations [EOL] self . _blocks_to_read = blocks_to_read [EOL] self . _blocks_for_peers = blocks_for_peers [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] async def run ( self ) : [EOL] async with trio . open_nursery ( ) as nursery : [EOL] nursery . start_soon ( self . piece_writing_loop ) [EOL] nursery . start_soon ( self . block_reading_loop ) [EOL] [EOL] async def piece_writing_loop ( self ) : [EOL] while True : [EOL] index , piece = await self . _pieces_to_write . receive ( ) [EOL] if ( index is None ) and ( piece is None ) : [comment] [EOL] self . _file_wrapper . move_file_to_final_location ( ) [EOL] else : [EOL] self . _file_wrapper . write_piece ( index , piece ) [EOL] logger . info ( [string] . format ( index ) ) [EOL] await self . _write_confirmations . send ( index ) [EOL] [EOL] async def block_reading_loop ( self ) : [EOL] while True : [EOL] who , ( index , begin , length ) = await self . _blocks_to_read . receive ( ) [EOL] block = self . _file_wrapper . read_block ( index , begin , length ) [EOL] await self . _blocks_for_peers . send ( ( who , ( index , begin , length ) , block ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $torrent.Torrent$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $torrent.Torrent$ 0 0 0 0 0 $torrent.Torrent$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $torrent.Torrent$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $FileWrapper$ 0 $trio.MemoryReceiveChannel$ 0 $trio.MemorySendChannel$ 0 $trio.MemoryReceiveChannel$ 0 $trio.MemorySendChannel$ 0 0 0 0 0 0 $src.file_manager.FileWrapper$ 0 $FileWrapper$ 0 0 0 0 0 $trio.MemoryReceiveChannel$ 0 0 0 0 0 $trio.MemorySendChannel$ 0 0 0 0 0 $trio.MemoryReceiveChannel$ 0 0 0 0 0 $trio.MemorySendChannel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0
from typing import Type [EOL] import typing [EOL] import trio [EOL] import builtins [EOL] import datetime [EOL] import src [EOL] import datetime [EOL] from enum import Enum [EOL] from typing import NamedTuple , Tuple , Set [EOL] [EOL] import bitarray [EOL] import trio [EOL] [EOL] import config [EOL] [EOL] PeerAddress = NamedTuple ( [string] , [ ( [string] , bytes ) , ( [string] , int ) ] ) [EOL] [EOL] [EOL] class PeerType ( Enum ) : [EOL] SERVER = [number] [EOL] CLIENT = [number] [EOL] [EOL] [EOL] class ChokeAlert ( Enum ) : [EOL] ALERT = [number] [EOL] DONT_ALERT = [number] [EOL] [EOL] [EOL] class PeerState ( object ) : [EOL] def __init__ ( self , peer_id , num_pieces ) : [EOL] now = datetime . datetime . now ( ) [EOL] pieces = bitarray . bitarray ( num_pieces ) [EOL] pieces . setall ( False ) [EOL] self . _pieces = pieces [EOL] self . _peer_id = peer_id [EOL] self . _outgoing_data_channel = trio . open_memory_channel ( config . INTERNAL_QUEUE_SIZE ) [EOL] self . _choked_us = True [EOL] self . _choked_them = True [EOL] [comment] [EOL] self . _first_seen = now [EOL] self . _last_seen = now [EOL] self . _total_download_count = [number] [EOL] self . _current_10_second_download_count = [number] [EOL] self . _prev_10_second_download_count = [number] [EOL] self . _total_upload_count = [number] [EOL] [EOL] def choke_us ( self ) : [EOL] self . _choked_us = True [EOL] [EOL] def unchoke_us ( self ) : [EOL] self . _choked_us = False [EOL] [EOL] @ property def is_client_choked ( self ) : [EOL] return self . _choked_us [EOL] [EOL] def choke_them ( self ) : [EOL] if self . _choked_them : [EOL] return ChokeAlert . DONT_ALERT [EOL] else : [EOL] self . _choked_them = True [EOL] return ChokeAlert . ALERT [EOL] [EOL] def unchoke_them ( self ) : [EOL] if not self . _choked_them : [EOL] return ChokeAlert . DONT_ALERT [EOL] else : [EOL] self . _choked_them = False [EOL] return ChokeAlert . ALERT [EOL] [EOL] @ property def is_peer_choked ( self ) : [EOL] return self . _choked_them [EOL] [EOL] def get_pieces ( self ) : [EOL] return self . _pieces [EOL] [EOL] def set_pieces ( self , new_pieces ) : [EOL] [comment] [EOL] [comment] [EOL] length = len ( self . _pieces ) [EOL] self . _pieces = new_pieces [ : length ] [EOL] [EOL] @ property def first_seen ( self ) : [EOL] return self . _first_seen [EOL] [EOL] @ property def last_seen ( self ) : [EOL] return self . _last_seen [EOL] [EOL] @ property def peer_id ( self ) : [EOL] return self . _peer_id [EOL] [EOL] @ property def receive_outgoing_data ( self ) : [EOL] return self . _outgoing_data_channel [ [number] ] [EOL] [EOL] @ property def send_outgoing_data ( self ) : [EOL] return self . _outgoing_data_channel [ [number] ] [EOL] [EOL] def inc_download_counters ( self ) : [EOL] self . _total_download_count += [number] [EOL] self . _current_10_second_download_count += [number] [EOL] [EOL] def inc_upload_counters ( self ) : [EOL] self . _total_upload_count += [number] [EOL] [EOL] def reset_rolling_download_count ( self ) : [EOL] self . _prev_10_second_download_count = self . _current_10_second_download_count [EOL] self . _current_10_second_download_count = [number] [EOL] [EOL] def get_20_second_rolling_download_count ( self ) : [EOL] return self . _prev_10_second_download_count + self . _current_10_second_download_count [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $builtins.int$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ChokeAlert$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $ChokeAlert$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trio.MemoryReceiveChannel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trio.MemorySendChannel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] import h11 [EOL] [EOL] from config import STREAM_CHUNK_SIZE [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class Http_stream ( object ) : [EOL] def __init__ ( self , stream , role ) : [EOL] self . stream = stream [EOL] self . conn = h11 . Connection ( our_role = role ) [EOL] logger . debug ( [string] . format ( self . conn ) ) [EOL] logger . debug ( [string] . format ( self . conn . our_role ) ) [EOL] logger . debug ( [string] . format ( self . conn . their_role ) ) [EOL] [EOL] async def receive_event ( self ) : [EOL] while True : [EOL] logger . debug ( [string] ) [EOL] e = self . conn . next_event ( ) [EOL] logger . debug ( [string] . format ( str ( e ) ) ) [EOL] if e == h11 . NEED_DATA : [EOL] raw_bytes = await self . stream . receive_some ( STREAM_CHUNK_SIZE ) [EOL] logger . debug ( [string] . format ( str ( raw_bytes ) ) ) [EOL] [comment] [EOL] self . conn . receive_data ( raw_bytes ) [EOL] logger . debug ( [string] ) [EOL] else : [EOL] return e [EOL] [EOL] async def receive_with_data ( self ) : [EOL] first_event = await self . receive_event ( ) [EOL] data = [ ] [EOL] next_event = await self . receive_event ( ) [EOL] while not isinstance ( next_event , h11 . EndOfMessage ) : [EOL] data . append ( next_event ) [EOL] next_event = await self . receive_event ( ) [EOL] return first_event , data [EOL] [EOL] async def send_event ( self , e ) : [EOL] raw_bytes = self . conn . send ( e ) [EOL] await self . stream . send_all ( raw_bytes ) [EOL] logger . debug ( [string] . format ( str ( e ) , str ( raw_bytes ) ) ) [EOL] [EOL] async def close ( self ) : [EOL] await self . stream . aclose ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import h11 [EOL] import trio [EOL] [EOL] import http_stream [EOL] [EOL] [EOL] async def handler ( stream ) : [EOL] h = http_stream . Http_stream ( stream , h11 . SERVER ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] . format ( stream . socket . getpeername ( ) ) ) [EOL] [EOL] request , data = await h . receive_with_data ( ) [EOL] [EOL] response = h11 . Response ( status_code = [number] , reason = [string] , headers = [ ] ) [EOL] await h . send_event ( response ) [EOL] [EOL] body = h11 . Data ( data = [string] ) [EOL] await h . send_event ( body ) [EOL] await h . send_event ( h11 . EndOfMessage ( ) ) [EOL] await h . close ( ) [EOL] [EOL] [EOL] async def run_server ( port ) : [EOL] print ( [string] . format ( port ) ) [EOL] await trio . serve_tcp ( handler , port ) [EOL] [EOL] [EOL] async def run_servers ( ) : [EOL] async with trio . open_nursery ( ) as nursery : [EOL] nursery . start_soon ( run_server , [number] ) [EOL] nursery . start_soon ( run_server , [number] ) [EOL] [EOL] [EOL] trio . run ( run_servers ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import os [EOL] import math [EOL] import os [EOL] import shutil [EOL] [EOL] CGREEN = [string] [EOL] CBLUE = [string] [EOL] CBEIGE = [string] [EOL] CWHITE = [string] [EOL] CEND = [string] [EOL] [EOL] [EOL] def display_piece ( count , display_block ) : [EOL] if os . name == [string] : [EOL] if count == display_block : [EOL] return [string] [EOL] elif ( count / display_block ) > [number] : [EOL] return [string] [EOL] elif ( count / display_block ) > [number] : [EOL] return [string] [EOL] elif ( count / display_block ) > [number] : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] else : [EOL] block = [string] [EOL] if count == display_block : [EOL] return CGREEN + block + CEND [EOL] elif ( count / display_block ) > [number] : [EOL] return CBLUE + block + CEND [EOL] elif ( count / display_block ) > [number] : [EOL] return CBEIGE + block + CEND [EOL] elif ( count / display_block ) > [number] : [EOL] return CWHITE + block + CEND [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] MAX_TEXT_LENGTH = [number] [EOL] [EOL] [EOL] def pretty_print ( width , p_id , pieces , received_from , sent_to ) : [EOL] lines = [ p_id . decode ( [string] ) , [string] . format ( math . floor ( sum ( pieces ) / len ( pieces ) * [number] ) ) , [string] . format ( received_from ) if ( received_from is not None ) else [string] , [string] . format ( sent_to ) if ( sent_to is not None ) else [string] , ] [EOL] [comment] [EOL] [comment] [EOL] grid_width = width - ( MAX_TEXT_LENGTH + [number] ) [EOL] total_grid_count = grid_width * len ( lines ) [EOL] [comment] [EOL] num_pieces = len ( pieces ) [EOL] display_block = num_pieces // total_grid_count [EOL] count_pieces = [ sum ( pieces [ i * display_block : ( i + [number] ) * display_block ] ) for i in range ( total_grid_count ) ] [EOL] display_pieces = [ display_piece ( n , display_block ) for n in count_pieces ] [EOL] [comment] [EOL] print ( width * [string] ) [EOL] for i in range ( len ( lines ) ) : [EOL] text = lines [ i ] [ : MAX_TEXT_LENGTH ] [EOL] spaces = ( MAX_TEXT_LENGTH - len ( text ) + [number] ) * [string] [EOL] grid = [string] . join ( display_pieces [ i * grid_width : ( i + [number] ) * grid_width ] ) [EOL] line = text + spaces + grid [EOL] print ( line ) [EOL] [EOL] [EOL] def print_peers ( torrent , peers ) : [EOL] terminal_info = shutil . get_terminal_size ( ) [EOL] width = terminal_info . columns [EOL] print ( chr ( [number] ) + [string] ) [EOL] [comment] [EOL] pretty_print ( width , torrent . peer_id + [string] , torrent . _complete , None , None ) [EOL] for _ , p_state in sorted ( peers . items ( ) ) [ : [number] ] : [EOL] pretty_print ( width , p_state . peer_id , p_state . get_pieces ( ) , p_state . _total_download_count , p_state . _total_upload_count , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , List , Any [EOL] import typing [EOL] import h11 [EOL] import logging [EOL] import builtins [EOL] import io [EOL] import logging [EOL] from urllib import parse as urllib_parse [comment] [EOL] [EOL] import h11 [EOL] import trio [EOL] [EOL] import bencode [EOL] import http_stream [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] def _int2bytes ( i ) : [EOL] return [string] % i [EOL] [EOL] [EOL] def tracker_request ( torrent , event ) : [EOL] [docstring] [EOL] d = { [string] : urllib_parse . quote_from_bytes ( torrent . info_hash ) . encode ( ) , [string] : torrent . peer_id , [string] : _int2bytes ( torrent . listening_port ) , [string] : _int2bytes ( torrent . uploaded ) , [string] : _int2bytes ( torrent . downloaded ) , [string] : _int2bytes ( torrent . left ) , [string] : [string] } [EOL] if event : [EOL] d [ [string] ] = event [EOL] params = [string] . join ( [ k + [string] + v for k , v in d . items ( ) ] ) [EOL] path = torrent . tracker_path + [string] + params [EOL] host = torrent . tracker_address + [string] + str ( torrent . tracker_port ) . encode ( ) [EOL] headers = [ ( [string] , host ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] r = h11 . Request ( method = [string] , target = path , headers = headers ) [EOL] return r [EOL] [EOL] [EOL] async def query ( torrent , event ) : [EOL] url = torrent . tracker_address [EOL] port = torrent . tracker_port [EOL] logger . debug ( [string] . format ( url , port ) ) [EOL] stream = await trio . open_tcp_stream ( url . decode ( [string] ) , port ) [comment] [EOL] logger . debug ( [string] ) [EOL] h = http_stream . Http_stream ( stream , h11 . CLIENT ) [EOL] logger . debug ( [string] ) [EOL] [EOL] await h . send_event ( tracker_request ( torrent , event ) ) [EOL] await h . send_event ( h11 . EndOfMessage ( ) ) [EOL] [EOL] response , data = await h . receive_with_data ( ) [EOL] return [string] . join ( d . data for d in data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $h11.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Optional [EOL] import typing [EOL] import multiprocessing [EOL] import logging [EOL] import builtins [EOL] import argparse [EOL] import pathlib [EOL] import argparse [EOL] import hashlib [EOL] import logging [EOL] import multiprocessing as mp [EOL] import pathlib [EOL] import random [EOL] import shutil [EOL] import os [EOL] import time [EOL] [EOL] import trio [EOL] [EOL] import bencode [EOL] import engine [EOL] import file_manager [EOL] from torrent import Torrent [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] def read_torrent_file ( torrent_path ) : [EOL] with open ( torrent_path , [string] ) as f : [EOL] torrent_data = bencode . parse_value ( f ) [EOL] logger . debug ( [string] . format ( torrent_data ) ) [EOL] torrent_info = bencode . encode_value ( torrent_data [ [string] ] ) [EOL] logger . debug ( [string] . format ( torrent_info ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return ( torrent_data , torrent_info ) [EOL] [EOL] [EOL] def run ( log_level , torrent_path , listening_port , download_dir ) : [EOL] if log_level : [EOL] log_level = getattr ( logging , log_level . upper ( ) ) [EOL] else : [EOL] log_level = getattr ( logging , [string] ) [EOL] logfile = [string] . format ( listening_port ) [comment] [EOL] logging . basicConfig ( filename = logfile , level = log_level , format = [string] , ) [EOL] torrent_data , torrent_info = read_torrent_file ( torrent_path ) [EOL] download_dir = download_dir if download_dir else os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] port = int ( listening_port ) if listening_port else None [EOL] t = Torrent ( torrent_data , torrent_info , download_dir , port ) [EOL] engine . run ( t ) [EOL] [EOL] [EOL] def run_command ( args ) : [EOL] run ( args . log_level , args . torrent_path , args . listening_port , args . download_dir ) [EOL] [EOL] [EOL] def make_test_files ( torrent_data , torrent_info , download_dir , number_of_files ) : [EOL] t = Torrent ( torrent_data , torrent_info , download_dir , None ) [EOL] files = [ ] [EOL] main_file_wrapper = file_manager . FileWrapper ( torrent = t , file_suffix = [string] ) [EOL] main_file_wrapper . create_file_or_return_hashes ( ) [EOL] for i in range ( int ( number_of_files ) ) : [EOL] fw = file_manager . FileWrapper ( torrent = t , file_suffix = [string] . format ( i ) ) [EOL] fw . create_file_or_return_hashes ( ) [EOL] files . append ( fw ) [EOL] for p in t . _pieces : [EOL] data = main_file_wrapper . read_block ( p . index , [number] , t . piece_length ( p . index ) ) [EOL] if p . sha1hash == hashlib . sha1 ( data ) . digest ( ) : [EOL] random . choice ( files ) . write_piece ( p . index , data ) [EOL] [EOL] [EOL] def make_test_files_command ( args ) : [EOL] torrent_data , torrent_info = read_torrent_file ( args . torrent_path ) [EOL] download_dir = ( args . download_dir if args . download_dir else os . path . dirname ( os . path . abspath ( __file__ ) ) ) [EOL] number_of_files = args . number_of_files [EOL] make_test_files ( torrent_data , torrent_info , download_dir , number_of_files ) [EOL] [EOL] [EOL] def test ( test_dir , torrent_path , number_of_clients ) : [EOL] test_dir = pathlib . Path ( test_dir ) [EOL] [comment] [EOL] start_time = time . perf_counter ( ) [EOL] torrent_data , torrent_info = read_torrent_file ( torrent_path ) [EOL] [comment] [EOL] client_processes = [ ] [EOL] for i in range ( number_of_clients ) : [EOL] client_dir = test_dir / [string] / ( [string] . format ( i ) ) [EOL] client_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] [comment] [EOL] torrent_name = bytes . decode ( torrent_data [ [string] ] [ [string] ] ) [EOL] test_file = test_dir / [string] . format ( torrent_name , i ) [EOL] tmp_file = client_dir / [string] . format ( torrent_name ) [EOL] final_file = client_dir / torrent_name [EOL] [EOL] try : [EOL] os . remove ( final_file ) [EOL] except FileNotFoundError : [EOL] pass [EOL] [EOL] shutil . copy ( test_file , tmp_file ) [EOL] [EOL] p = mp . Process ( target = run , args = ( [string] , torrent_path , [number] + i , client_dir ) ) [EOL] client_processes . append ( ( p , final_file , tmp_file ) ) [EOL] [EOL] torrent_start_time = time . perf_counter ( ) [EOL] for p , _ , _ in client_processes : [EOL] p . start ( ) [EOL] [comment] [EOL] while not all ( os . path . exists ( final_location ) for _ , final_location , _ in client_processes ) : [EOL] time . sleep ( [number] ) [EOL] end_time = time . perf_counter ( ) [EOL] for p , _ , _ in client_processes : [EOL] p . terminate ( ) [EOL] print ( [string] . format ( number_of_clients , end_time - torrent_start_time , torrent_start_time - start_time ) ) [EOL] [EOL] [EOL] def test_command ( args ) : [EOL] test ( args . test_dir , args . torrent_path , int ( args . number_of_clients ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] argparser = argparse . ArgumentParser ( ) [EOL] [comment] [EOL] sub_commands = argparser . add_subparsers ( help = [string] ) [EOL] run = sub_commands . add_parser ( [string] , help = [string] ) [EOL] run . add_argument ( [string] , help = [string] ) [EOL] run . add_argument ( [string] , help = [string] ) [EOL] run . add_argument ( [string] , help = [string] ) [EOL] run . add_argument ( [string] , help = [string] ) [EOL] run . set_defaults ( func = run_command ) [EOL] [comment] [EOL] make_test_files = sub_commands . add_parser ( [string] , help = [string] ) [EOL] make_test_files . add_argument ( [string] , help = [string] ) [EOL] make_test_files . add_argument ( [string] , help = [string] ) [EOL] make_test_files . add_argument ( [string] , help = [string] ) [EOL] make_test_files . set_defaults ( func = make_test_files_command ) [EOL] [comment] [EOL] test = sub_commands . add_parser ( [string] , help = [string] ) [EOL] test . add_argument ( [string] , help = [string] ) [EOL] test . add_argument ( [string] , help = [string] ) [EOL] test . add_argument ( [string] , help = [string] ) [EOL] test . set_defaults ( func = test_command ) [EOL] [comment] [EOL] args = argparser . parse_args ( ) [EOL] args . func ( args ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] from collections import deque [EOL] import logging [EOL] [EOL] import trio [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class NullBucket ( object ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def check_and_decrement ( self , _packet_size ) : [EOL] return True [EOL] [EOL] async def loop ( self ) : [EOL] pass [EOL] [EOL] [EOL] class TokenBucket ( object ) : [EOL] def __init__ ( self , bytes_per_second , max_size_in_bytes = None , updates_per_second = [number] ) : [EOL] self . bucket = [number] [EOL] self . max_size_in_bytes = max_size_in_bytes if max_size_in_bytes else [number] * bytes_per_second [EOL] self . bytes_per_second = bytes_per_second [EOL] self . updates_per_second = updates_per_second [EOL] [EOL] @ property def update_period ( self ) : [EOL] return [number] / self . updates_per_second [EOL] [EOL] def check_and_decrement ( self , packet_size ) : [EOL] if self . bucket >= packet_size : [EOL] self . bucket -= packet_size [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] async def loop ( self ) : [EOL] while True : [EOL] await trio . sleep ( self . update_period ) [EOL] increment = self . bytes_per_second / self . updates_per_second [EOL] self . bucket = min ( self . bucket + increment , self . max_size_in_bytes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0
from typing import Set , Dict , Tuple , Any , Literal , List , Optional [EOL] import typing [EOL] import torrent [EOL] import trio [EOL] import peer_state [EOL] import logging [EOL] import builtins [EOL] import typing_extensions [EOL] import src [EOL] import datetime [EOL] import hashlib [EOL] import io [EOL] import logging [EOL] import math [EOL] import random [EOL] from typing import List , Dict , Tuple , Set , Union [EOL] [EOL] import bitarray [EOL] import trio [EOL] [EOL] import bencode [EOL] import display [EOL] import file_manager [EOL] import messages [EOL] import peer_connection [EOL] import requests [EOL] import peer_state [EOL] from token_bucket import NullBucket , TokenBucket [EOL] import torrent as state [EOL] import tracker [EOL] [EOL] import config [EOL] [EOL] [EOL] def _pick_random_one_in_bitarray ( b ) : [EOL] n = len ( b ) [EOL] start = random . randint ( [number] , n - [number] ) [EOL] [comment] [EOL] try : [EOL] i = b . index ( True , start ) [EOL] return i [EOL] except ValueError : [EOL] pass [EOL] [comment] [EOL] try : [EOL] i = b . index ( True , [number] , start ) [EOL] return i [EOL] except ValueError : [EOL] return None [EOL] [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] stats = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] [EOL] def incStats ( field ) : [EOL] stats [ field ] += [number] [EOL] logger . debug ( [string] . format ( stats ) ) [EOL] [EOL] [EOL] class Engine ( object ) : [EOL] def __init__ ( self , * , torrent , complete_pieces_to_write , write_confirmations , blocks_to_read , blocks_for_peers , auto_shutdown = False ) : [EOL] self . _auto_shutdown = auto_shutdown [EOL] self . _state = torrent [EOL] [comment] [EOL] self . _peers_without_connection = trio . open_memory_channel ( config . INTERNAL_QUEUE_SIZE ) [EOL] [comment] [EOL] self . _complete_pieces_to_write = complete_pieces_to_write [EOL] self . _write_confirmations = write_confirmations [EOL] self . _blocks_to_read = blocks_to_read [EOL] self . _blocks_for_peers = blocks_for_peers [EOL] [comment] [EOL] self . _msg_from_peer = trio . open_memory_channel ( config . INTERNAL_QUEUE_SIZE ) [EOL] [comment] [EOL] self . _peers = dict ( ) [EOL] [comment] [EOL] self . _received_blocks = dict ( ) [EOL] self . requests = requests . RequestManager ( ) [EOL] [EOL] if config . MAX_OUTGOING_BYTES_PER_SECOND is None : [EOL] self . token_bucket = NullBucket ( ) [EOL] else : [EOL] self . token_bucket = TokenBucket ( config . MAX_OUTGOING_BYTES_PER_SECOND ) [EOL] [EOL] @ property def peer_messages ( self ) : [EOL] return self . _msg_from_peer [ [number] ] [EOL] [EOL] async def run ( self ) : [EOL] async with trio . open_nursery ( ) as nursery : [EOL] nursery . start_soon ( self . control_loop ) [EOL] nursery . start_soon ( self . peer_clients_loop ) [EOL] nursery . start_soon ( self . peer_server_loop ) [EOL] nursery . start_soon ( self . tracker_loop ) [EOL] nursery . start_soon ( self . peer_messages_loop ) [EOL] nursery . start_soon ( self . file_write_confirmation_loop ) [EOL] nursery . start_soon ( self . file_reading_loop ) [EOL] nursery . start_soon ( self . info_loop ) [EOL] nursery . start_soon ( self . choking_loop ) [EOL] nursery . start_soon ( self . delete_stale_requests_loop , config . DELETE_STALE_REQUESTS_SECONDS ) [EOL] nursery . start_soon ( self . token_bucket . loop ) [EOL] [EOL] async def control_loop ( self ) : [EOL] while True : [EOL] complete_peers = [ p . get_pieces ( ) . all for p in self . _peers . values ( ) ] [EOL] if ( self . _auto_shutdown and all ( complete_peers ) and self . _state . _complete . all ( ) ) : [comment] [EOL] await self . _complete_pieces_to_write . send ( ( None , None ) ) [EOL] raise KeyboardInterrupt [comment] [EOL] elif self . _state . _complete . all ( ) : [comment] [EOL] await self . _complete_pieces_to_write . send ( ( None , None ) ) [EOL] await trio . sleep ( [number] ) [EOL] [EOL] async def info_loop ( self ) : [EOL] while True : [EOL] unwritten_blocks = len ( self . _received_blocks . items ( ) ) [EOL] outstanding_requests = self . requests . size [EOL] logger . info ( [string] . format ( stats ) ) [EOL] logger . info ( [string] . format ( unwritten_blocks , outstanding_requests , sum ( self . _state . _complete ) , len ( self . _state . _complete ) , ) ) [EOL] if ( sum ( self . _state . _complete ) - len ( self . _state . _complete ) - sum ( self . _state . _complete ) > [number] ) : [EOL] logger . info ( [string] . format ( self . requests . _requests ) ) [EOL] unwritten_blocks = [ ( i , b , len ( data ) ) for i , blocks in self . _received_blocks . items ( ) for b , data in blocks ] [EOL] logger . info ( [string] . format ( unwritten_blocks ) ) [EOL] channels = [ self . _peers_without_connection [ [number] ] , self . _complete_pieces_to_write , self . _write_confirmations , self . _blocks_to_read , self . _blocks_for_peers , self . _msg_from_peer [ [number] ] , ] [EOL] logger . info ( [string] . format ( [ c . statistics ( ) for c in channels ] ) ) [EOL] logger . info ( [string] . format ( self . _peers . keys ( ) ) ) [EOL] display . print_peers ( self . _state , self . _peers ) [EOL] await trio . sleep ( [number] ) [EOL] [EOL] async def tracker_loop ( self ) : [EOL] new = True [EOL] while True : [EOL] logger . debug ( [string] ) [EOL] start_time = trio . current_time ( ) [EOL] event = [string] if new else None [EOL] raw_tracker_info = await tracker . query ( self . _state , event ) [EOL] tracker_info = bencode . parse_value ( io . BytesIO ( raw_tracker_info ) ) [EOL] [comment] [EOL] [comment] [EOL] peer_ips_and_ports = bencode . parse_peers ( tracker_info [ [string] ] , self . _state ) [EOL] peers = [ ( peer_state . PeerAddress ( ip , port ) , peer_id ) for ip , port , peer_id in peer_ips_and_ports ] [EOL] logger . info ( [string] . format ( peers ) ) [EOL] await self . update_peers ( peers ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] await trio . sleep_until ( start_time + self . _state . interval ) [EOL] new = False [EOL] [EOL] async def peer_server_loop ( self ) : [EOL] await trio . serve_tcp ( peer_connection . make_handler ( self ) , self . _state . listening_port ) [EOL] [EOL] async def peer_clients_loop ( self ) : [EOL] [docstring] [EOL] logger . debug ( [string] ) [EOL] async with trio . open_nursery ( ) as nursery : [EOL] while True : [EOL] logger . debug ( [string] ) [EOL] address = await self . _peers_without_connection [ [number] ] . receive ( ) [EOL] nursery . start_soon ( peer_connection . make_standalone , self , address ) [EOL] [EOL] async def update_peers ( self , peers ) : [EOL] for address , peer_id in peers : [EOL] if peer_id in self . _peers : [EOL] logger . info ( [string] . format ( peer_id ) ) [EOL] else : [EOL] logger . info ( [string] . format ( address , peer_id ) ) [EOL] await self . _peers_without_connection [ [number] ] . send ( address ) [EOL] [EOL] def _blocks_from_index ( self , index ) : [EOL] piece_length = self . _state . piece_length ( index ) [EOL] block_length = min ( piece_length , config . BLOCK_SIZE ) [EOL] begin_indexes = list ( range ( [number] , piece_length , block_length ) ) [EOL] return set ( ( index , begin , min ( block_length , piece_length - begin ) ) for begin in begin_indexes ) [EOL] [EOL] async def update_peer_requests ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . _state . _complete . all ( ) : [EOL] logger . info ( [string] ) [EOL] return [EOL] if not self . _peers : [EOL] logger . info ( [string] ) [EOL] return [EOL] for address , peer_state in self . _peers . items ( ) : [EOL] if peer_state . is_client_choked : [EOL] continue [EOL] [comment] [EOL] targets = ( ~ self . _state . _complete ) & peer_state . _pieces [EOL] target_index = _pick_random_one_in_bitarray ( targets ) [EOL] if target_index is not None : [EOL] logger . info ( [string] . format ( address , self . _state . _complete . any ( ) , peer_state . _pieces . any ( ) , target_index ) ) [EOL] existing_requests = self . requests . existing_requests_for_peer ( address ) [EOL] if len ( existing_requests ) > config . MAX_OUTSTANDING_REQUESTS_PER_PEER : [EOL] logger . info ( [string] . format ( address , len ( existing_requests ) ) ) [EOL] new_requests = set ( ) [EOL] else : [EOL] suggested_requests = self . _blocks_from_index ( target_index ) [EOL] new_requests = suggested_requests . difference ( existing_requests ) [EOL] logger . info ( [string] . format ( address , len ( suggested_requests ) , len ( existing_requests ) ) ) [EOL] logger . info ( [string] . format ( address , new_requests ) ) [EOL] if new_requests : [EOL] for r in new_requests : [EOL] self . requests . add_request ( address , r ) [EOL] incStats ( [string] ) [EOL] await peer_state . send_outgoing_data . send ( ( [string] , new_requests ) ) [EOL] else : [EOL] logger . info ( [string] . format ( address ) ) [EOL] [EOL] async def handle_peer_message ( self , peer_id , msg_type , msg_payload ) : [EOL] if peer_id not in self . _peers : [EOL] logger . info ( [string] . format ( peer_id ) ) [EOL] return [EOL] peer_state = self . _peers [ peer_id ] [EOL] if msg_type == messages . PeerMsg . CHOKE : [EOL] logger . info ( [string] . format ( peer_id ) ) [EOL] peer_state . choke_us ( ) [EOL] elif msg_type == messages . PeerMsg . UNCHOKE : [EOL] logger . info ( [string] . format ( peer_id ) ) [EOL] peer_state . unchoke_us ( ) [EOL] elif msg_type == messages . PeerMsg . INTERESTED : [EOL] logger . warning ( [string] . format ( peer_id ) ) [comment] [EOL] elif msg_type == messages . PeerMsg . NOT_INTERESTED : [EOL] logger . warning ( [string] . format ( peer_id ) ) [comment] [EOL] elif msg_type == messages . PeerMsg . HAVE : [EOL] index = messages . parse_have ( msg_payload ) [EOL] logger . debug ( [string] . format ( index , peer_id ) ) [EOL] peer_state . get_pieces ( ) [ index ] = True [EOL] elif msg_type == messages . PeerMsg . BITFIELD : [EOL] logger . info ( [string] . format ( peer_id ) ) [EOL] [comment] [EOL] bitfield = messages . parse_bitfield ( msg_payload ) [EOL] peer_state . set_pieces ( bitfield ) [EOL] elif msg_type == messages . PeerMsg . REQUEST : [EOL] incStats ( [string] ) [EOL] request_info = messages . parse_request_or_cancel ( msg_payload ) [EOL] logger . info ( [string] . format ( request_info , peer_state . peer_id ) ) [EOL] index = request_info [ [number] ] [EOL] if peer_state . is_peer_choked : [EOL] logger . warning ( [string] . format ( peer_state . peer_id , index ) ) [EOL] elif self . _state . _complete [ index ] : [EOL] await self . _blocks_to_read . send ( ( peer_state . peer_id , request_info ) ) [EOL] else : [EOL] logger . warning ( [string] . format ( peer_state . peer_id , index ) ) [EOL] elif msg_type == messages . PeerMsg . PIECE : [EOL] ( index , begin , data ) = messages . parse_piece ( msg_payload ) [EOL] incStats ( [string] ) [EOL] logger . info ( [string] . format ( ( index , begin , len ( data ) ) , peer_state . peer_id ) ) [EOL] peer_state . inc_download_counters ( ) [EOL] await self . handle_block_received ( index , begin , data ) [EOL] elif msg_type == messages . PeerMsg . CANCEL : [EOL] logger . warning ( [string] . format ( peer_id ) ) [comment] [EOL] request_info = messages . parse_request_or_cancel ( msg_payload ) [EOL] else : [EOL] [comment] [EOL] logger . warning ( [string] . format ( length ) ) [EOL] logger . warning ( [string] . format ( data ) ) [EOL] raise Exception ( [string] ) [EOL] [EOL] async def handle_block_received ( self , index , begin , data ) : [EOL] if index not in self . _received_blocks : [EOL] piece_length = self . _state . piece_length ( index ) [EOL] completed_blocks = bitarray . bitarray ( math . ceil ( piece_length / config . BLOCK_SIZE ) ) [EOL] completed_blocks . setall ( False ) [EOL] piece_data = bytearray ( piece_length ) [EOL] self . _received_blocks [ index ] = ( completed_blocks , piece_data ) [EOL] else : [EOL] completed_blocks = self . _received_blocks [ index ] [ [number] ] [EOL] piece_data = self . _received_blocks [ index ] [ [number] ] [EOL] block_index = begin // config . BLOCK_SIZE [EOL] completed_blocks [ block_index ] = True [EOL] piece_data [ begin : begin + len ( data ) ] = data [EOL] if completed_blocks . all ( ) : [EOL] piece_info = self . _state . piece_info ( index ) [EOL] complete_piece = bytes ( piece_data ) [EOL] if hashlib . sha1 ( complete_piece ) . digest ( ) == piece_info . sha1hash : [EOL] self . _received_blocks . pop ( index ) [comment] [EOL] await self . _complete_pieces_to_write . send ( ( index , complete_piece ) ) [EOL] else : [EOL] self . _received_blocks . pop ( index ) [EOL] self . requests . delete_all_for_piece ( index ) [EOL] logger . warning ( [string] . format ( index ) ) [EOL] [EOL] async def peer_messages_loop ( self ) : [EOL] while True : [EOL] logger . debug ( [string] ) [EOL] peer_state , msg_type , msg_payload = await self . _msg_from_peer [ [number] ] . receive ( ) [comment] [EOL] logger . debug ( [string] . format ( peer_state . peer_id ) ) [EOL] await self . handle_peer_message ( peer_state . peer_id , msg_type , msg_payload ) [comment] [EOL] await self . update_peer_requests ( ) [EOL] [EOL] async def announce_have_piece ( self , index ) : [EOL] peers = ( self . _peers . copy ( ) ) [comment] [EOL] for _peer_id , peer_s in peers . items ( ) : [EOL] await peer_s . send_outgoing_data . send ( ( [string] , index ) ) [EOL] [EOL] async def file_write_confirmation_loop ( self ) : [EOL] while True : [EOL] logger . debug ( [string] ) [EOL] index = await self . _write_confirmations . receive ( ) [EOL] self . requests . delete_all_for_piece ( index ) [EOL] [comment] [EOL] [comment] [EOL] self . _state . _complete [ index ] = True [comment] [EOL] await self . announce_have_piece ( index ) [EOL] await self . update_peer_requests ( ) [EOL] [EOL] async def file_reading_loop ( self ) : [EOL] while True : [EOL] logger . debug ( [string] ) [EOL] peer_id , block_details , block = await self . _blocks_for_peers . receive ( ) [EOL] incStats ( [string] ) [EOL] if peer_id in self . _peers : [EOL] p_state = self . _peers [ peer_id ] [EOL] p_state . inc_upload_counters ( ) [EOL] await p_state . send_outgoing_data . send ( ( [string] , ( block_details , block ) ) ) [EOL] else : [EOL] logger . info ( [string] . format ( block_details , peer_id ) ) [EOL] [EOL] async def choking_loop ( self ) : [EOL] period = [number] [EOL] optimistic_unchoke = None [EOL] while True : [EOL] await trio . sleep ( [number] ) [EOL] peers = [ ( peer_id , peer_s . get_20_second_rolling_download_count ( ) ) for peer_id , peer_s in self . _peers . items ( ) ] [EOL] if period == [number] and peers : [EOL] optimistic_unchoke = random . choice ( peers ) [ [number] ] [EOL] peers = sorted ( peers , key = lambda x : x [ [number] ] , reverse = True ) [EOL] logger . info ( [string] . format ( peers ) ) [EOL] [comment] [EOL] [comment] [EOL] unchoke = set ( p [ [number] ] for p in peers [ : config . NUM_UNCHOKED_PEERS ] ) [EOL] choke = set ( p [ [number] ] for p in peers [ config . NUM_UNCHOKED_PEERS : ] ) [EOL] if optimistic_unchoke : [EOL] unchoke . add ( optimistic_unchoke ) [EOL] choke . discard ( optimistic_unchoke ) [EOL] for p_id in unchoke : [EOL] if p_id in self . _peers : [comment] [EOL] p_state = self . _peers [ p_id ] [EOL] alert = p_state . unchoke_them ( ) [EOL] p_state . reset_rolling_download_count ( ) [EOL] if alert == peer_state . ChokeAlert . ALERT : [EOL] await p_state . send_outgoing_data . send ( ( [string] , None ) ) [EOL] for p_id in choke : [EOL] if p_id in self . _peers : [comment] [EOL] p_state = self . _peers [ p_id ] [EOL] alert = p_state . choke_them ( ) [EOL] p_state . reset_rolling_download_count ( ) [EOL] if alert == peer_state . ChokeAlert . ALERT : [EOL] await p_state . send_outgoing_data . send ( ( [string] , None ) ) [EOL] [comment] [EOL] period = ( period + [number] ) % [number] [comment] [EOL] [EOL] async def delete_stale_requests_loop ( self , seconds ) : [EOL] while True : [EOL] await trio . sleep ( seconds ) [EOL] count = self . requests . delete_older_than ( seconds = seconds ) [EOL] logging . info ( [string] . format ( count , seconds ) ) [EOL] [EOL] [EOL] def run ( torrent ) : [EOL] try : [EOL] [comment] [EOL] file_wrapper = file_manager . FileWrapper ( torrent = torrent ) [EOL] existing_hashes = file_wrapper . create_file_or_return_hashes ( ) [EOL] [EOL] if existing_hashes : [EOL] for index , h in enumerate ( existing_hashes ) : [EOL] piece_info = torrent . piece_info ( index ) [EOL] if piece_info . sha1hash == h : [EOL] torrent . _complete [ index ] = True [comment] [EOL] [EOL] s_complete_pieces , r_complete_pieces = trio . open_memory_channel ( config . INTERNAL_QUEUE_SIZE ) [EOL] s_write_confirmations , r_write_confirmations = trio . open_memory_channel ( config . INTERNAL_QUEUE_SIZE ) [EOL] s_blocks_to_read , r_blocks_to_read = trio . open_memory_channel ( config . INTERNAL_QUEUE_SIZE ) [EOL] s_blocks_for_peers , r_blocks_for_peers = trio . open_memory_channel ( config . INTERNAL_QUEUE_SIZE ) [EOL] [EOL] file_engine = file_manager . FileManager ( file_wrapper = file_wrapper , pieces_to_write = r_complete_pieces , write_confirmations = s_write_confirmations , blocks_to_read = r_blocks_to_read , blocks_for_peers = s_blocks_for_peers , ) [EOL] [EOL] engine = Engine ( torrent = torrent , complete_pieces_to_write = s_complete_pieces , write_confirmations = r_write_confirmations , blocks_to_read = s_blocks_to_read , blocks_for_peers = r_blocks_for_peers , ) [EOL] [EOL] async def run ( ) : [EOL] async with trio . open_nursery ( ) as nursery : [EOL] nursery . start_soon ( file_engine . run ) [EOL] nursery . start_soon ( engine . run ) [EOL] [EOL] trio . run ( run ) [EOL] except KeyboardInterrupt : [EOL] print ( ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $torrent.Torrent$ 0 $trio.MemorySendChannel$ 0 $trio.MemoryReceiveChannel$ 0 $trio.MemorySendChannel$ 0 $trio.MemoryReceiveChannel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $torrent.Torrent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trio.MemorySendChannel$ 0 0 0 0 0 $trio.MemoryReceiveChannel$ 0 0 0 0 0 $trio.MemorySendChannel$ 0 0 0 0 0 $trio.MemoryReceiveChannel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,peer_state.PeerState]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Tuple[bitarray,builtins.bytearray]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trio.MemorySendChannel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,builtins.int]]$ 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[typing_extensions.Literal[b'started']]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing_extensions.Literal[b'started']]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.List[peer_state.PeerAddress]$ 0 0 0 0 0 0 0 0 $typing.List[peer_state.PeerAddress]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Tuple , Any [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] import builtins [EOL] import datetime [EOL] import logging [EOL] from typing import List , Dict , Tuple , Set [EOL] [EOL] import peer_state [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class RequestManager ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _requests = set ( ) [EOL] [EOL] @ property def size ( self ) : [EOL] return len ( self . _requests ) [EOL] [EOL] def add_request ( self , peer_id , block ) : [EOL] self . _requests . add ( ( peer_id , block , datetime . datetime . now ( ) ) ) [EOL] [EOL] def delete_all_for_piece ( self , index ) : [EOL] to_delete = set ( ( p_id , r , t ) for p_id , r , t in self . _requests if r [ [number] ] == index ) [EOL] logger . info ( [string] . format ( len ( to_delete ) , index ) ) [EOL] self . _requests = set ( ( p_id , r , t ) for p_id , r , t in self . _requests if not r [ [number] ] == index ) [EOL] [EOL] def delete_all_for_peer ( self , peer_id ) : [EOL] self . _requests = set ( ( p_id , r , t ) for p_id , r , t in self . _requests if p_id != peer_id ) [EOL] [EOL] def delete_all ( self ) : [EOL] self . _requests = set ( ) [EOL] [EOL] def delete_older_than ( self , * , seconds ) : [EOL] now = datetime . datetime . now ( ) [EOL] prev_len = len ( self . _requests ) [EOL] self . _requests = set ( ( p_id , r , t ) for p_id , r , t in self . _requests if ( now - t ) . seconds > seconds ) [EOL] new_len = len ( self . _requests ) [EOL] return prev_len - new_len [EOL] [EOL] def existing_requests_for_peer ( self , peer_id ) : [EOL] return set ( r for p_id , r , _ in self . _requests if p_id == peer_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.bytes,typing.Tuple[builtins.int,builtins.int,builtins.int],datetime.datettime]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Set[typing.Tuple[typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[typing.Any,typing.Any,typing.Any]]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int,builtins.int]]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0
DEFAULT_LISTENING_PORT = [number] [EOL] [EOL] STREAM_CHUNK_SIZE = [number] * [number] [EOL] [EOL] BLOCK_SIZE = [number] * [number] [EOL] [EOL] INTERNAL_QUEUE_SIZE = [number] [EOL] [EOL] MAX_OUTSTANDING_REQUESTS_PER_PEER = [number] [EOL] [EOL] KEEPALIVE_SECONDS = [number] [EOL] [EOL] NUM_UNCHOKED_PEERS = [number] [EOL] [EOL] DELETE_STALE_REQUESTS_SECONDS = [number] * [number] [EOL] [EOL] MAX_OUTGOING_BYTES_PER_SECOND = [number] * [number] ** [number] [EOL] [comment] [EOL]	$builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] import io [EOL] import builtins [EOL] import collections [EOL] import io [EOL] [EOL] [EOL] def parse_string_length ( s , i = [string] ) : [EOL] [comment] [EOL] c = s . read ( [number] ) [EOL] while c . isdigit ( ) : [EOL] i += c [EOL] c = s . read ( [number] ) [EOL] [comment] [EOL] if c == [string] : [EOL] return int ( i ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def parse_string ( s , n ) : [EOL] return s . read ( n ) [EOL] [EOL] [EOL] def parse_int ( s ) : [EOL] i = [string] [EOL] c = s . read ( [number] ) [EOL] while c . isdigit ( ) : [EOL] i += c [EOL] c = s . read ( [number] ) [EOL] [comment] [EOL] if c == [string] : [EOL] return int ( i ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def parse_list ( s ) : [EOL] l = [ ] [EOL] while True : [EOL] v = parse_value ( s ) [EOL] if v is None : [EOL] return l [EOL] else : [EOL] l . append ( v ) [EOL] [EOL] [EOL] def parse_dict ( s ) : [EOL] d = collections . OrderedDict ( ) [EOL] while True : [EOL] k = parse_value ( s ) [EOL] if k is None : [EOL] return d [EOL] else : [EOL] v = parse_value ( s ) [EOL] d [ k ] = v [EOL] [EOL] [EOL] def parse_value ( s ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] c = s . read ( [number] ) [EOL] if c . isdigit ( ) : [EOL] length = parse_string_length ( s , c ) [EOL] return parse_string ( s , length ) [EOL] elif c == [string] : [EOL] return parse_int ( s ) [EOL] elif c == [string] : [EOL] return parse_list ( s ) [EOL] elif c == [string] : [EOL] return parse_dict ( s ) [EOL] elif c == [string] or c == [string] : [EOL] None [EOL] else : [EOL] raise Exception ( [string] . format ( c ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def encode_bytes ( s ) : [EOL] return [string] % ( len ( s ) , s ) [EOL] [EOL] [EOL] def encode_string ( s ) : [EOL] return encode_bytes ( s . encode ( ) ) [EOL] [EOL] [EOL] def encode_int ( i ) : [EOL] return [string] % i [EOL] [EOL] [EOL] def encode_list ( l ) : [EOL] inner = [string] . join ( encode_value ( v ) for v in l ) [EOL] return [string] % inner [EOL] [EOL] [EOL] def encode_dict ( d ) : [EOL] inner = [string] . join ( encode_value ( k ) + encode_value ( v ) for k , v in d . items ( ) ) [EOL] return [string] % inner [EOL] [EOL] [EOL] def encode_value ( v ) : [EOL] if isinstance ( v , bytes ) : [EOL] return encode_bytes ( v ) [EOL] elif isinstance ( v , str ) : [EOL] return encode_string ( v ) [EOL] elif isinstance ( v , int ) : [EOL] return encode_int ( v ) [EOL] elif isinstance ( v , list ) : [EOL] return encode_list ( v ) [EOL] elif isinstance ( v , dict ) : [EOL] return encode_dict ( v ) [EOL] else : [EOL] raise Exception ( [string] . format ( type ( v ) ) ) [EOL] [EOL] [EOL] def parse_compact_peers ( raw_bytes ) : [EOL] if ( len ( raw_bytes ) % [number] ) != [number] : [EOL] raise Exception ( [string] ) [EOL] else : [EOL] peers = [ ] [EOL] for i in range ( len ( raw_bytes ) // [number] ) : [EOL] ip = [string] . join ( str ( i ) for i in raw_bytes [ i : i + [number] ] ) . encode ( ) [EOL] port = int . from_bytes ( raw_bytes [ i + [number] : i + [number] ] , byteorder = [string] ) [EOL] peers . append ( ( ip , port ) ) [EOL] return peers [EOL] [EOL] [EOL] def replace_with_localhost ( tripple ) : [EOL] if tripple [ [number] ] == [string] : [EOL] return ( [string] , tripple [ [number] ] , tripple [ [number] ] ) [EOL] else : [EOL] return tripple [EOL] [EOL] [EOL] def parse_peers ( data , torrent ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] peer_list = parse_compact_peers ( data ) [EOL] peer_list = [ ( ip , port , None ) for ip , port in peer_list ] [EOL] except : [EOL] peer_list = [ ( x [ [string] ] , x [ [string] ] , x [ [string] ] ) for x in data ] [EOL] return [ replace_with_localhost ( tripple ) for tripple in peer_list if tripple [ [number] ] != torrent . listening_port ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Match , Type , Any , List , Optional [EOL] import typing [EOL] import logging [EOL] import src [EOL] import builtins [EOL] import datetime [EOL] import hashlib [EOL] import itertools [EOL] import logging [EOL] import os [EOL] import random [EOL] import re [EOL] from typing import NamedTuple , Any , List , Dict , Tuple , Optional , Set [EOL] [EOL] import bitarray [EOL] import trio [EOL] [EOL] from config import DEFAULT_LISTENING_PORT [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] Piece = NamedTuple ( [string] , [ ( [string] , str ) , ( [string] , int ) , ( [string] , bytes ) ] ) [EOL] [EOL] [EOL] def _random_char ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] n = random . randint ( [number] , [number] ) [EOL] if n < [number] : [EOL] c = chr ( n + [number] ) [EOL] elif n < [number] : [EOL] c = chr ( n - [number] + [number] ) [EOL] else : [EOL] c = chr ( n - [number] + [number] ) [EOL] return c [EOL] [EOL] [EOL] def _generate_peer_id ( ) : [EOL] return [string] . join ( _random_char ( ) for _ in range ( [number] , [number] ) ) . encode ( ) [EOL] [EOL] [EOL] def _parse_pieces ( bstring ) : [EOL] if ( len ( bstring ) % [number] ) != [number] : [EOL] raise Exception ( [string] ) [EOL] else : [EOL] l = [ ] [EOL] i = [number] [EOL] while i + [number] <= len ( bstring ) : [EOL] l . append ( bstring [ i : i + [number] ] ) [EOL] i += [number] [EOL] return l [EOL] [EOL] [EOL] class Torrent ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tdict , info_string , directory , listening_port = None , custom_name = None ) : [EOL] self . _listening_port = listening_port [EOL] self . _info_string = info_string [EOL] self . _info_hash = hashlib . sha1 ( info_string ) . digest ( ) [EOL] self . _peer_id = _generate_peer_id ( ) [EOL] self . _uploaded = [number] [EOL] self . _downloaded = [number] [EOL] self . _piece_length = int ( tdict [ [string] ] [ [string] ] ) [EOL] if [string] in tdict [ [string] ] : [comment] [EOL] raise Exception ( [string] ) [EOL] else : [comment] [EOL] [comment] [EOL] self . _torrent_name = bytes . decode ( tdict [ [string] ] [ [string] ] ) [EOL] if custom_name : [EOL] self . _filename = os . path . join ( directory , custom_name ) [EOL] else : [EOL] self . _filename = os . path . join ( directory , self . _torrent_name ) [EOL] [EOL] self . _pieces = [ Piece ( self . _filename , i , sha1 ) for i , sha1 in enumerate ( _parse_pieces ( tdict [ [string] ] [ [string] ] ) ) ] [EOL] [EOL] self . _file_length = int ( tdict [ [string] ] [ [string] ] ) [EOL] self . _left = self . _file_length [EOL] [EOL] self . _num_pieces = len ( self . _pieces ) [EOL] self . _complete = bitarray . bitarray ( self . _num_pieces ) [EOL] self . _complete . setall ( False ) [EOL] [EOL] [comment] [EOL] self . _raw_tracker_url = tdict [ [string] ] [EOL] r = re . compile ( [string] ) [EOL] m = r . fullmatch ( self . _raw_tracker_url . decode ( ) ) [EOL] g = m . groupdict ( ) [EOL] self . _tracker_address = m [ [string] ] . encode ( ) [EOL] self . _tracker_port = int ( m [ [string] ] ) [EOL] self . _tracker_path = m [ [string] ] . encode ( ) [EOL] logger . info ( [string] . format ( self . _tracker_address , self . _tracker_port , self . _tracker_path ) ) [EOL] [EOL] [comment] [EOL] self . _interval = [number] [EOL] self . _complete_peers = [number] [EOL] self . _incomplete_peers = [number] [EOL] [EOL] @ property def listening_port ( self ) : [EOL] if self . _listening_port : [EOL] return self . _listening_port [EOL] else : [EOL] return DEFAULT_LISTENING_PORT [EOL] [EOL] @ property def file_path ( self ) : [EOL] return self . _filename [EOL] [EOL] def piece_length ( self , index ) : [EOL] last_piece = self . _num_pieces - [number] [EOL] if index < last_piece : [EOL] return self . _piece_length [EOL] else : [EOL] return min ( self . _piece_length , self . _file_length - self . _piece_length * last_piece ) [EOL] [EOL] @ property def info_hash ( self ) : [EOL] return self . _info_hash [EOL] [EOL] @ property def peer_id ( self ) : [EOL] return self . _peer_id [EOL] [EOL] @ property def interval ( self ) : [EOL] return self . _interval [EOL] [EOL] @ property def tracker_address ( self ) : [EOL] return self . _tracker_address [EOL] [EOL] @ property def tracker_port ( self ) : [EOL] return self . _tracker_port [EOL] [EOL] @ property def tracker_path ( self ) : [EOL] return self . _tracker_path [EOL] [EOL] @ property def uploaded ( self ) : [EOL] [comment] [EOL] return [number] [EOL] [EOL] @ property def downloaded ( self ) : [EOL] [comment] [EOL] return [number] [EOL] [EOL] @ property def left ( self ) : [EOL] [comment] [EOL] return self . _file_length [EOL] [EOL] def piece_info ( self , n ) : [EOL] return self . _pieces [ n ] [EOL] [EOL] def is_piece_complete ( self , index ) : [EOL] return self . _complete [ index ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.torrent.Piece]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.torrent.Piece]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0