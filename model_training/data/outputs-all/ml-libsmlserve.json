from typing import Dict , List , Any , Match , Optional , Pattern [EOL] import typing [EOL] import sys [EOL] import os [EOL] import re [EOL] import sys [EOL] from setuptools import setup , find_packages [EOL] [EOL] [EOL] PY_VER = sys . version_info [EOL] [EOL] if not PY_VER >= ( [number] , [number] ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] def read ( f ) : [EOL] return open ( os . path . join ( os . path . dirname ( __file__ ) , f ) ) . read ( ) . strip ( ) [EOL] [EOL] [EOL] install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] extras_require = { } [EOL] [EOL] [EOL] def read_version ( ) : [EOL] regexp = re . compile ( [string] ) [EOL] init_py = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] with open ( init_py ) as f : [EOL] for line in f : [EOL] match = regexp . match ( line ) [EOL] if match is not None : [EOL] return match . group ( [number] ) [EOL] else : [EOL] msg = [string] [EOL] raise RuntimeError ( msg ) [EOL] [EOL] [EOL] classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] setup ( name = [string] , version = read_version ( ) , description = ( [string] [string] ) , long_description = [string] . join ( ( read ( [string] ) , read ( [string] ) ) ) , install_requires = install_requires , classifiers = classifiers , platforms = [ [string] ] , author = [string] , author_email = [string] , url = [string] , download_url = [string] , license = [string] , packages = find_packages ( ) , entry_points = { [string] : [ [string] ] } , extras_require = extras_require , keywords = [ [string] , [string] , [string] ] , zip_safe = True , include_package_data = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sys._version_info$ 0 0 0 0 0 0 0 0 $sys._version_info$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import pytest [EOL] import json [EOL] import pandas as pd [EOL] import numpy as np [EOL] from jsonschema import validate [EOL] from mlserve . schema_builder import build_schema [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def auto_dataset ( ) : [EOL] dataset_path = [string] [EOL] df = pd . read_csv ( dataset_path ) [EOL] return df [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def credit_dataset ( ) : [EOL] dataset_path = [string] [EOL] df = pd . read_csv ( dataset_path ) [EOL] [EOL] cat_features = [ [string] , [string] , [string] , [string] ] [EOL] for feature in cat_features : [EOL] df [ feature ] = df [ feature ] . astype ( [string] ) [EOL] return df [EOL] [EOL] [EOL] def assert_schema ( df ) : [EOL] desc = build_schema ( df ) [EOL] s = desc [ [string] ] [EOL] ui_schema = desc [ [string] ] [EOL] form_data = desc [ [string] ] [EOL] [EOL] for i in range ( len ( df ) ) : [EOL] row = json . loads ( df . iloc [ i ] . to_json ( ) ) [EOL] validate ( row , s ) [EOL] [EOL] assert set ( form_data . keys ( ) ) == set ( df . columns ) [EOL] assert ui_schema == { } [EOL] [EOL] [EOL] def test_basic ( auto_dataset , credit_dataset ) : [EOL] assert_schema ( auto_dataset ) [EOL] assert_schema ( credit_dataset ) [EOL] [EOL] [EOL] def test_none ( ) : [EOL] data = { [string] : [ [number] , [number] , [number] , np . nan ] , [string] : [ [number] , [number] , [number] , np . nan ] , [string] : [ True , False , True , np . nan ] , [string] : [ [string] , [string] , [string] , np . nan ] , } [EOL] df = pd . DataFrame . from_dict ( data ) [EOL] assert_schema ( df ) [EOL] [EOL] [EOL] def test_types ( ) : [EOL] data = { [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ True , False , True ] , [string] : [ [string] , [string] , [string] ] , } [EOL] df = pd . DataFrame . from_dict ( data ) [EOL] assert_schema ( df ) [EOL] [EOL] [EOL] def test_text_area ( ) : [EOL] data = { [string] : [string] * [number] } [EOL] df = pd . DataFrame ( [ data ] ) [EOL] desc = build_schema ( df ) [EOL] assert desc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import mlserve [EOL] import datetime [EOL] import typing [EOL] from datetime import datetime [EOL] from mlserve . stats import ModelStats , AggStats , RequestTiming [EOL] [EOL] [EOL] def test_request_timing_ctor ( ) : [EOL] dt = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] rt = RequestTiming ( [number] , dt , [number] ) [EOL] assert rt . status == [number] [EOL] [EOL] [EOL] def test_model_stats_ctor ( ) : [EOL] model_stats = ModelStats ( ) [EOL] assert model_stats . success == [number] [EOL] assert model_stats . error == [number] [EOL] assert model_stats . mean_resp_time ( ) == [number] [EOL] assert len ( model_stats . timings ) == [number] [EOL] expected = { [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] assert model_stats . formatted ( ) == expected [EOL] [EOL] [EOL] def test_model_stats_log_data_point ( ) : [EOL] dt = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] rt1 = RequestTiming ( [number] , dt , [number] ) [EOL] dt = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] rt2 = RequestTiming ( [number] , dt , [number] ) [EOL] model_stats = ModelStats ( ) [EOL] model_stats . log_data_point ( rt1 ) [EOL] model_stats . log_data_point ( rt2 ) [EOL] [EOL] assert model_stats . success == [number] [EOL] assert model_stats . error == [number] [EOL] assert model_stats . mean_resp_time ( ) == [number] [EOL] [EOL] [EOL] def test_agg_stats_ctor ( ) : [EOL] agg_stats = AggStats ( ) [EOL] assert agg_stats . success == [number] [EOL] assert agg_stats . error == [number] [EOL] assert agg_stats . mean_resp_time ( ) == [number] [EOL] assert len ( agg_stats . timings ) == [number] [EOL] [EOL] expected = { [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] assert agg_stats . formatted ( ) == expected [EOL] [EOL] model_stats1 = ModelStats ( ) [EOL] model_stats2 = ModelStats ( ) [EOL] [EOL] stats_map = { [string] : model_stats1 , [string] : model_stats2 } [EOL] agg_stats = AggStats . from_models_stats ( stats_map ) [EOL] assert agg_stats . success == [number] [EOL] assert agg_stats . error == [number] [EOL] assert agg_stats . mean_resp_time ( ) == [number] [EOL] assert len ( agg_stats . timings ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] async def test_index_page ( api ) : [EOL] resp = await api . get ( [string] ) [EOL] assert resp . status == [number] [EOL] body = await resp . text ( ) [EOL] assert body [EOL] [EOL] [EOL] async def test_models_list ( api ) : [EOL] resp = await api . get ( [string] ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert isinstance ( body , list ) [EOL] assert len ( body ) == [number] [EOL] [EOL] [EOL] async def test_get_one_model ( api ) : [EOL] resp = await api . get ( [string] ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert isinstance ( body , dict ) [EOL] [EOL] resp = await api . get ( [string] ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert isinstance ( body , dict ) [EOL] [EOL] [EOL] preds = { [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [number] } , } [EOL] [EOL] [EOL] async def test_baic_predict ( api ) : [EOL] resp = await api . post ( [string] , json = preds ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert isinstance ( body , dict ) [EOL] [EOL] resp = await api . post ( [string] , json = preds ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert isinstance ( body , list ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import typing [EOL] from mlserve . loaders import get_loader [EOL] [EOL] [EOL] def test_pickle_loader ( ) : [EOL] model_path = [string] [EOL] loader = get_loader ( [string] ) [EOL] model = loader ( model_path ) [EOL] assert hasattr ( model , [string] ) [EOL] [EOL] [EOL] def test_joblib_loader ( ) : [EOL] model_path = [string] [EOL] loader = get_loader ( [string] ) [EOL] model = loader ( model_path ) [EOL] assert hasattr ( model , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import mlserve [EOL] import typing [EOL] import json [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from mlserve . utils import load_models , ModelMeta [EOL] from mlserve . worker import warm , predict [EOL] [EOL] [EOL] def test_load_models ( ) : [EOL] m = [ ModelMeta ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ) ] [EOL] r = load_models ( m ) [EOL] f = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] assert len ( r ) == [number] [EOL] model_desc = r [ [number] ] [EOL] assert model_desc . loader == [string] [EOL] assert model_desc . target == [ [string] ] [EOL] assert model_desc . name == [string] [EOL] assert model_desc . features == f [EOL] assert model_desc . model_path == Path ( [string] ) [EOL] assert model_desc . data_schema_path == Path ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def model_desc ( ) : [EOL] m = [ ModelMeta ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ) ] [EOL] r = load_models ( m ) [EOL] assert len ( r ) == [number] [EOL] return r [ [number] ] [EOL] [EOL] [EOL] def test_warm_predict ( model_desc ) : [EOL] cache = { } [EOL] warm ( [ model_desc ] , cache ) [EOL] assert len ( cache ) == [number] [EOL] raw = json . dumps ( [ model_desc . schema [ [string] ] ] ) [EOL] target = [ [string] ] [EOL] [EOL] result = predict ( model_desc . name , target , raw , cache ) [EOL] assert result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] import gc [EOL] [EOL] import pytest [EOL] [EOL] from mlserve . server_utils import init [EOL] from mlserve . utils import ModelConfig [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def event_loop ( ) : [EOL] asyncio . set_event_loop_policy ( asyncio . DefaultEventLoopPolicy ( ) ) [EOL] loop = asyncio . get_event_loop_policy ( ) . new_event_loop ( ) [EOL] yield loop [EOL] gc . collect ( ) [EOL] loop . close ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def loop ( event_loop ) : [EOL] return event_loop [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def model_conf ( ) : [EOL] m = ModelConfig ( { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } ) [EOL] return m [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def max_workers ( ) : [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def api ( loop , aiohttp_client , max_workers , model_conf ) : [EOL] app = loop . run_until_complete ( init ( max_workers , model_conf ) ) [EOL] yield loop . run_until_complete ( aiohttp_client ( app ) ) [EOL] loop . run_until_complete ( app . shutdown ( ) ) [EOL] [EOL] [EOL] pytest_plugins = [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0
import pathlib [EOL] from pathlib import Path [EOL] [EOL] MODELS_KEY = [string] [EOL] PROJ_ROOT = Path ( __file__ ) . parent [EOL]	0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , List , Callable , Any , Optional , Type [EOL] import builtins [EOL] import numpy [EOL] import utils [EOL] import typing [EOL] import json [EOL] import signal [EOL] from typing import Dict , Any , List , Optional [EOL] [EOL] import numpy as np [EOL] import pandas as pd [EOL] [EOL] from . loaders import get_loader [EOL] from . utils import ModelDescriptor [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] Cache = Dict [ str , Any ] [EOL] _models = { } [EOL] [EOL] [EOL] def clean_worker ( ) : [EOL] signal . signal ( signal . SIGINT , signal . SIG_DFL ) [EOL] global _model [EOL] _models = None [comment] [EOL] [EOL] [EOL] def warm ( models , cache = None , init_signals = False , ) : [EOL] global _models [EOL] [EOL] if init_signals : [EOL] signal . signal ( signal . SIGINT , signal . SIG_IGN ) [EOL] [EOL] cache = cache if cache is not None else _models [EOL] [EOL] for model in models : [EOL] loader = get_loader ( model . loader ) [EOL] if model . name not in cache : [EOL] pipeline = loader ( str ( model . model_path ) ) [EOL] cache [ model . name ] = pipeline [EOL] return True [EOL] [EOL] [EOL] def format_result ( pred , target ) : [EOL] if len ( target ) == [number] : [EOL] results_list = [ pred ] [EOL] else : [EOL] results_list = pred [EOL] [EOL] formated = [ ] [EOL] for r in results_list : [EOL] paris = [ ( t , r ) for t , r in zip ( target , r ) ] [EOL] formated . append ( dict ( paris ) ) [EOL] return formated [EOL] [EOL] [EOL] def predict ( model_name , target , raw_data , cache = None ) : [EOL] cache = cache if cache is not None else _models [EOL] [comment] [EOL] df = pd . DataFrame ( json . loads ( raw_data ) ) [EOL] model = cache [ model_name ] [EOL] results = ... [EOL] if hasattr ( model , [string] ) : [EOL] results = model . predict_proba ( df ) [EOL] results = np . array ( results ) . T [ [number] ] . tolist ( ) [EOL] else : [EOL] results = model . predict ( df ) [EOL] [EOL] return format_result ( results , target ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Optional , Union [EOL] import builtins [EOL] import typing [EOL] import pandas [EOL] import json [EOL] import pandas as pd [EOL] [EOL] from pandas . core . dtypes . common import ( is_bool_dtype , is_categorical_dtype , is_datetime64_dtype , is_datetime64tz_dtype , is_integer_dtype , is_numeric_dtype , is_period_dtype , is_string_dtype , is_timedelta64_dtype , ) [EOL] from typing import Dict , Any , List , Optional [EOL] [EOL] [EOL] def as_json_table_type ( x ) : [EOL] if is_integer_dtype ( x ) : [EOL] return [string] [EOL] elif is_bool_dtype ( x ) : [EOL] return [string] [EOL] elif is_numeric_dtype ( x ) : [EOL] return [string] [EOL] elif ( is_datetime64_dtype ( x ) or is_datetime64tz_dtype ( x ) or is_period_dtype ( x ) ) : [EOL] [comment] [EOL] [comment] [EOL] return [string] [EOL] elif is_timedelta64_dtype ( x ) : [EOL] [comment] [EOL] [comment] [EOL] return [string] [EOL] elif is_categorical_dtype ( x ) : [EOL] [comment] [EOL] [comment] [EOL] return [string] [EOL] elif is_string_dtype ( x ) : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] text_area = { [string] : [string] , [string] : { [string] : [number] } } [EOL] [EOL] [EOL] radio_button = { [string] : [string] } [EOL] [EOL] [EOL] def make_field ( arr ) : [EOL] ui_schema = None [EOL] add_types = [ ] [EOL] if arr . isnull ( ) . sum ( ) > [number] : [EOL] arr_no_na = arr . dropna ( ) [EOL] dtype = arr_no_na . infer_objects ( ) . dtypes [EOL] add_types . append ( [string] ) [EOL] else : [EOL] dtype = arr . dtype [EOL] [EOL] if arr . name is None : [EOL] name = [string] [EOL] else : [EOL] name = arr . name [EOL] json_type = as_json_table_type ( dtype ) [EOL] field = { [string] : [ as_json_table_type ( dtype ) ] + add_types } [EOL] [EOL] if json_type == [string] and arr . str . len ( ) . mean ( ) > [number] : [EOL] ui_schema = text_area [EOL] [EOL] if is_categorical_dtype ( arr ) : [EOL] if hasattr ( arr , [string] ) : [EOL] cats = arr . categories [EOL] [comment] [EOL] else : [EOL] cats = arr . cat . categories [EOL] [comment] [EOL] field [ [string] ] = list ( cats ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return name , field , dtype , ui_schema [EOL] [EOL] [EOL] def build_schema ( data , include_example = True ) : [EOL] form_data = json . loads ( data . iloc [ [ [number] ] ] . to_json ( orient = [string] ) ) [ [number] ] [EOL] fields = [ ] [EOL] for _ , s in data . items ( ) : [EOL] fields . append ( make_field ( s ) ) [EOL] [EOL] names = [ ] [EOL] items = { } [EOL] ui_schema = { } [EOL] for k , v , _ , ui in fields : [EOL] items [ k ] = v [EOL] [comment] [EOL] names . append ( k ) [EOL] if ui is not None : [EOL] ui_schema [ k ] = ui [EOL] [EOL] schema = { [string] : [string] , [string] : items , [string] : names } [EOL] result = { [string] : schema , [string] : ui_schema , [string] : form_data if include_example else { } , } [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import mlserve [EOL] import typing [EOL] import pathlib [EOL] import json [EOL] import os [EOL] [EOL] import trafaret as t [EOL] import yaml [EOL] [EOL] from dataclasses import dataclass , asdict [EOL] from pathlib import Path [EOL] from typing import Any , List , Dict [EOL] [EOL] [EOL] ModelMeta = t . Dict ( { t . Key ( [string] ) : t . String , t . Key ( [string] ) : t . String , t . Key ( [string] ) : t . String , t . Key ( [string] ) : t . String , t . Key ( [string] ) : t . String | t . List ( t . String ) , t . Key ( [string] , default = [string] ) : t . Enum ( [string] , [string] ) , } ) [EOL] [EOL] [EOL] [comment] [EOL] ModelConfig = t . Dict ( { t . Key ( [string] , default = [string] ) : t . String , t . Key ( [string] , default = [number] ) : t . Int [ [number] : [number] ] , t . Key ( [string] , default = [number] ) : t . Int [ [number] : [number] ] , t . Key ( [string] ) : t . List ( ModelMeta ) , } ) [EOL] [EOL] [EOL] ServerConfigTrafaret = t . Dict ( { t . Key ( [string] , default = [string] ) : t . String , t . Key ( [string] , default = [number] ) : t . Int [ [number] : [number] ] , t . Key ( [string] , default = [number] ) : t . Int [ [number] : [number] ] , } ) . ignore_extra ( [string] ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class ServerConfig : [EOL] host = ... [EOL] port = ... [EOL] workers = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class ModelDescriptor : [EOL] name = ... [EOL] description = ... [EOL] target = ... [EOL] features = ... [EOL] schema = ... [EOL] model_path = ... [EOL] model_size = ... [EOL] data_schema_path = ... [EOL] schema_size = ... [EOL] loader = ... [EOL] [EOL] def asdict ( self ) : [EOL] return asdict ( self ) [EOL] [EOL] [EOL] def load_model_config ( fname ) : [EOL] with open ( fname , [string] ) as f : [EOL] raw_data = yaml . safe_load ( f ) [EOL] data = ModelConfig ( raw_data ) [EOL] return data [EOL] [EOL] [EOL] def load_models ( model_conf ) : [EOL] result = [ ] [EOL] for m in model_conf : [EOL] with open ( m [ [string] ] , [string] ) as f : [EOL] schema = json . load ( f ) [EOL] [EOL] _target = m [ [string] ] [EOL] target = _target if isinstance ( _target , list ) else [ _target ] [EOL] schema = drop_columns ( schema , target ) [EOL] [EOL] schema_size = os . path . getsize ( m [ [string] ] ) [EOL] model_size = os . path . getsize ( m [ [string] ] ) [EOL] features = list ( schema [ [string] ] [ [string] ] . keys ( ) ) [EOL] model_desc = ModelDescriptor ( name = m [ [string] ] , description = m [ [string] ] , target = target , features = features , schema = schema , model_path = Path ( m [ [string] ] ) , model_size = model_size , data_schema_path = Path ( m [ [string] ] ) , schema_size = schema_size , loader = m [ [string] ] , ) [EOL] result . append ( model_desc ) [EOL] return result [EOL] [EOL] [EOL] def drop_columns ( schema , columns ) : [EOL] for col in columns : [EOL] schema [ [string] ] [ [string] ] . pop ( col , None ) [EOL] schema [ [string] ] . pop ( col , None ) [EOL] schema [ [string] ] . pop ( col , None ) [EOL] [EOL] if col in schema [ [string] ] [ [string] ] : [EOL] schema [ [string] ] [ [string] ] . remove ( col ) [EOL] return schema [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $pathlib.Path$ 0 0 0 $builtins.int$ 0 0 0 $pathlib.Path$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ModelDescriptor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Optional [EOL] import builtins [EOL] import typing [EOL] import json [EOL] from typing import Optional , Dict , Any [EOL] [EOL] from aiohttp import web [EOL] [EOL] [EOL] [comment] [EOL] class RESTError ( web . HTTPError ) : [comment] [EOL] status_code = [number] [EOL] error = [string] [EOL] [EOL] def __init__ ( self , message = None , status_code = Optional [ int ] , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( reason = message ) [EOL] [EOL] if status_code is not None : [EOL] self . status_code = status_code [EOL] [EOL] if not message : [EOL] message = self . error [EOL] [EOL] msg_dict = { [string] : message } [EOL] [EOL] if kwargs : [EOL] msg_dict [ [string] ] = kwargs [EOL] [EOL] self . text = json . dumps ( msg_dict ) [EOL] self . content_type = [string] [EOL] [EOL] [EOL] class ObjectNotFound ( RESTError ) : [EOL] status_code = [number] [EOL] error = [string] [EOL] [EOL] [EOL] class UnprocessableEntity ( RESTError ) : [EOL] status_code = [number] [EOL] error = [string] [EOL] [EOL] [EOL] [comment] [EOL] class RestClientError ( Exception ) : [EOL] [docstring] [EOL] [EOL] @ property def status_code ( self ) : [EOL] r = self . args [ [number] ] [EOL] return r [EOL] [EOL] [EOL] class PlainRestError ( RestClientError ) : [EOL] [docstring] [EOL] [EOL] @ property def error_text ( self ) : [EOL] return str ( self . args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 $'RESTError'$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $'RESTError'$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 $'RESTError'$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 $'RESTError'$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $'RESTError'$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import builtins [EOL] import typing [EOL] import pickle [comment] [EOL] from typing import Any , Callable [EOL] [EOL] [EOL] def pickle_loader ( model_path ) : [EOL] with open ( model_path , [string] ) as f : [EOL] pipeline = pickle . load ( f ) [comment] [EOL] return pipeline [EOL] [EOL] [EOL] def joblib_loader ( model_path ) : [EOL] from sklearn . externals import joblib [EOL] with open ( model_path , [string] ) as f : [EOL] pipeline = joblib . load ( f ) [comment] [EOL] return pipeline [EOL] [EOL] [EOL] def get_loader ( loader_name ) : [EOL] if loader_name == [string] : [EOL] return joblib_loader [EOL] return pickle_loader [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.str],typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Callable , Any , Type [EOL] import builtins [EOL] import stats [EOL] import aiohttp [EOL] import concurrent [EOL] import functools [EOL] import mlserve [EOL] import utils [EOL] import typing [EOL] import pathlib [EOL] import asyncio [EOL] import json [EOL] [EOL] from concurrent . futures import ProcessPoolExecutor [EOL] from functools import partial [EOL] from pathlib import Path [EOL] from typing import Callable , Dict , Any , Union , List [EOL] [EOL] from aiohttp import web [EOL] [EOL] from . consts import MODELS_KEY [EOL] from . exceptions import ObjectNotFound [EOL] from . stats import ModelStats , AggStats [EOL] from . utils import ModelDescriptor [EOL] from . worker import predict [EOL] [EOL] [EOL] def path_serializer ( obj ) : [EOL] if isinstance ( obj , Path ) : [EOL] return str ( obj ) [EOL] raise TypeError ( [string] ) [EOL] [EOL] [EOL] jsonify = partial ( json . dumps , indent = [number] , sort_keys = True , default = path_serializer ) [EOL] JsonResp = Callable [ [ Union [ Dict [ str , Any ] , List [ Any ] ] ] , web . Response ] [EOL] json_response = partial ( web . json_response , dumps = jsonify ) [EOL] [EOL] [EOL] class SiteHandler : [EOL] [EOL] def __init__ ( self , project_root ) : [EOL] self . _root = project_root [EOL] self . _loop = asyncio . get_event_loop ( ) [EOL] [EOL] @ property def project_root ( self ) : [EOL] return self . _root [EOL] [EOL] async def index ( self , request ) : [EOL] path = str ( self . _root / [string] / [string] ) [EOL] return web . FileResponse ( path ) [EOL] [EOL] [EOL] def setup_app_routes ( app , handler ) : [EOL] r = app . router [EOL] h = handler [EOL] path = str ( handler . project_root / [string] ) [EOL] r . add_get ( [string] , h . index , name = [string] ) [EOL] r . add_get ( [string] , h . index , name = [string] ) [EOL] r . add_get ( [string] , h . index , name = [string] ) [EOL] r . add_static ( [string] , path = path , name = [string] ) [EOL] return app [EOL] [EOL] [EOL] class APIHandler : [EOL] def __init__ ( self , app , executor , project_root , model_descs , ) : [EOL] self . _app = app [EOL] self . _executor = executor [EOL] self . _root = project_root [EOL] self . _loop = asyncio . get_event_loop ( ) [EOL] [EOL] self . _models = { m . name : m for m in model_descs } [EOL] self . _app [ MODELS_KEY ] = { m . name : ModelStats ( ) for m in model_descs } [EOL] [EOL] result = sorted ( self . _models . values ( ) , key = lambda v : v . name ) [EOL] self . _models_list = [ { [string] : m . name , [string] : m . target } for m in result ] [EOL] [EOL] def validate_model_name ( self , model_name ) : [EOL] if model_name not in self . _models : [EOL] msg = f' [string] { model_name } [string] ' [EOL] raise ObjectNotFound ( msg ) [EOL] return model_name [EOL] [EOL] async def model_list ( self , request ) : [EOL] return json_response ( self . _models_list ) [EOL] [EOL] async def model_detail ( self , request ) : [EOL] model_name = request . match_info [ [string] ] [EOL] self . validate_model_name ( model_name ) [EOL] [EOL] r = self . _models [ model_name ] . asdict ( ) [EOL] return json_response ( r ) [EOL] [EOL] async def model_predict ( self , request ) : [EOL] model_name = request . match_info [ [string] ] [EOL] self . validate_model_name ( model_name ) [EOL] target = self . _models [ model_name ] . target [EOL] raw_data = await request . read ( ) [EOL] run = self . _loop . run_in_executor [EOL] [comment] [EOL] r = await run ( self . _executor , predict , model_name , target , raw_data ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return json_response ( r ) [EOL] [EOL] async def model_stats ( self , request ) : [EOL] model_name = request . match_info [ [string] ] [EOL] stats = request . app [ MODELS_KEY ] [ model_name ] [EOL] r = stats . formatted ( ) [EOL] return json_response ( r ) [EOL] [EOL] async def agg_stats ( self , request ) : [EOL] stats_map = request . app [ MODELS_KEY ] [EOL] agg = AggStats . from_models_stats ( stats_map ) [EOL] return json_response ( agg . formatted ( ) ) [EOL] [EOL] [EOL] def setup_api_routes ( api , handler ) : [EOL] r = api . router [EOL] h = handler [EOL] r . add_get ( [string] , h . agg_stats , name = [string] ) [EOL] r . add_get ( [string] , h . model_list , name = [string] ) [EOL] r . add_get ( [string] , h . model_detail , name = [string] ) [EOL] r . add_get ( [string] , h . model_stats , name = [string] ) [EOL] r . add_get ( [string] , h . model_detail , name = [string] ) [EOL] r . add_post ( [string] , h . model_predict , name = [string] , ) [EOL] return api [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $JsonResp$ 0 0 0 0 0 $JsonResp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.FileResponse$ 0 0 0 $aiohttp.web.Request$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aiohttp.web.Application$ 0 $concurrent.futures.ProcessPoolExecutor$ 0 $pathlib.Path$ 0 $typing.List[utils.ModelDescriptor]$ 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 $concurrent.futures.process.ProcessPoolExecutor$ 0 $concurrent.futures.ProcessPoolExecutor$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[utils.ModelDescriptor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[utils.ModelDescriptor]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $aiohttp.web.Response$ 0 0 0 $aiohttp.web.Request$ 0 0 0 0 $JsonResp$ 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 $aiohttp.web.Request$ 0 0 0 $typing.Any$ 0 $aiohttp.web.Request$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $JsonResp$ 0 $typing.Any$ 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 $aiohttp.web.Request$ 0 0 0 $typing.Any$ 0 $aiohttp.web.Request$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $JsonResp$ 0 $typing.Any$ 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 $aiohttp.web.Request$ 0 0 0 $typing.Any$ 0 $aiohttp.web.Request$ 0 0 0 0 0 0 $stats.ModelStats$ 0 $aiohttp.web.Request$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $stats.ModelStats$ 0 0 0 0 0 0 $JsonResp$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 $aiohttp.web.Request$ 0 0 0 $typing.Dict[builtins.str,stats.ModelStats]$ 0 $aiohttp.web.Request$ 0 0 0 0 0 0 $mlserve.stats.AggStats$ 0 0 0 0 0 $typing.Dict[builtins.str,stats.ModelStats]$ 0 0 0 $JsonResp$ 0 $mlserve.stats.AggStats$ 0 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] from . schema_builder import build_schema [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Deque , Any , List [EOL] import builtins [EOL] import mlserve [EOL] import typing [EOL] from collections import deque [EOL] from dataclasses import dataclass , field [EOL] from datetime import datetime [EOL] from statistics import mean [EOL] from typing import Deque , Dict , Any [EOL] [EOL] [EOL] @ dataclass class RequestTiming : [EOL] status = ... [EOL] start_time = ... [EOL] duration = ... [EOL] [EOL] [EOL] def factory ( maxlen = [number] ) : [EOL] return deque ( maxlen = maxlen ) [EOL] [EOL] [EOL] @ dataclass class _Stats : [EOL] success = [number] [EOL] error = [number] [EOL] timings = field ( default_factory = factory ) [EOL] [EOL] def mean_resp_time ( self ) : [EOL] series = [ t . duration for t in self . timings if t . status < [number] ] [EOL] return mean ( series ) if series else [number] [EOL] [EOL] def formatted ( self ) : [EOL] [comment] [EOL] f = { [string] : self . success , [string] : self . error , [string] : round ( self . mean_resp_time ( ) , [number] ) } [EOL] return f [EOL] [EOL] [EOL] class ModelStats ( _Stats ) : [EOL] [EOL] def log_data_point ( self , t ) : [EOL] if t . status < [number] : [EOL] self . success += [number] [EOL] else : [EOL] self . error += [number] [EOL] self . timings . append ( t ) [EOL] [EOL] [EOL] class AggStats ( _Stats ) : [EOL] [EOL] @ classmethod def from_models_stats ( cls , stats_map ) : [EOL] agg_stats = cls ( ) [EOL] all_timings = [ ] [EOL] for stat in stats_map . values ( ) : [EOL] agg_stats . success += stat . success [EOL] agg_stats . error += stat . error [EOL] all_timings . extend ( list ( stat . timings ) ) [EOL] [EOL] [comment] [EOL] timings = sorted ( all_timings , key = lambda v : v . start_time ) [ - [number] : ] [EOL] agg_stats . timings . extend ( timings ) [EOL] return agg_stats [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $datetime.datetime$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Deque[RequestTiming]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Deque[RequestTiming]$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $RequestTiming$ 0 0 0 0 $RequestTiming$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RequestTiming$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'AggStats'$ 0 0 0 $typing.Dict[builtins.str,ModelStats]$ 0 0 0 $mlserve.stats.AggStats$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,ModelStats]$ 0 0 0 0 0 0 $mlserve.stats.AggStats$ 0 0 0 0 0 0 0 $mlserve.stats.AggStats$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mlserve.stats.AggStats$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $mlserve.stats.AggStats$ 0
from typing import Type , Callable , Any [EOL] import builtins [EOL] import stats [EOL] import aiohttp [EOL] import mlserve [EOL] import datetime [EOL] import typing [EOL] import time [EOL] from datetime import datetime [EOL] from aiohttp . web import middleware [EOL] from typing import Awaitable , Callable [comment] [EOL] from aiohttp . web import HTTPException , Request , Application , Response [EOL] [EOL] from . handlers import APIHandler [EOL] from . stats import ModelStats , RequestTiming [EOL] from . consts import MODELS_KEY [EOL] [EOL] [EOL] Handler = Callable [ [ Request ] , Awaitable [ Response ] ] [EOL] [EOL] [EOL] def process_request ( req , resp , ts , duration ) : [EOL] model_name = req . match_info [ [string] ] [EOL] if model_name not in req . app [ MODELS_KEY ] : [EOL] return [EOL] point = RequestTiming ( resp . status , ts , duration ) [EOL] stats = req . app [ MODELS_KEY ] [ model_name ] [EOL] stats . log_data_point ( point ) [EOL] [EOL] [EOL] @ middleware async def stats_middleware ( request , handler ) : [EOL] if request . match_info . route . name == [string] : [EOL] ts = datetime . now ( ) [EOL] start = time . time ( ) [EOL] try : [EOL] resp = await handler ( request ) [EOL] except HTTPException as e : [EOL] duration = time . time ( ) - start [EOL] process_request ( request , e , ts , duration ) [EOL] raise [EOL] else : [EOL] duration = time . time ( ) - start [EOL] process_request ( request , resp , ts , duration ) [EOL] [EOL] else : [EOL] resp = await handler ( request ) [EOL] return resp [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0