from typing import Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import pydcop [EOL] [docstring] [EOL] [EOL] [EOL] from typing import Any , Tuple [EOL] [EOL] from numpy import random [EOL] [EOL] from pydcop . algorithms import ComputationDef [EOL] from pydcop . dcop . relations import assignment_cost [EOL] from pydcop . infrastructure . computations import VariableComputation , message_type , register [EOL] [EOL] [comment] [EOL] GRAPH_TYPE = [string] [EOL] [EOL] DsaMessage = message_type ( [string] , [ [string] ] ) [EOL] [EOL] [EOL] class DsaTutoComputation ( VariableComputation ) : [EOL] [docstring] [EOL] def __init__ ( self , computation_definition ) : [EOL] super ( ) . __init__ ( computation_definition . node . variable , computation_definition ) [EOL] [EOL] assert computation_definition . algo . algo == [string] [EOL] [EOL] self . constraints = computation_definition . node . constraints [EOL] self . current_cycle = { } [EOL] self . next_cycle = { } [EOL] [EOL] def on_start ( self ) : [EOL] self . random_value_selection ( ) [EOL] self . logger . debug ( [string] , self . current_value ) [EOL] self . post_to_all_neighbors ( DsaMessage ( self . current_value ) ) [EOL] [EOL] if self . is_cycle_complete ( ) : [EOL] self . evaluate_cycle ( ) [EOL] [EOL] @ register ( [string] ) def on_value_msg ( self , variable_name , recv_msg , t ) : [EOL] self . logger . debug ( [string] , recv_msg , variable_name ) [EOL] [EOL] if variable_name not in self . current_cycle : [EOL] self . current_cycle [ variable_name ] = recv_msg . value [EOL] if self . is_cycle_complete ( ) : [EOL] self . evaluate_cycle ( ) [EOL] [EOL] else : [comment] [EOL] self . next_cycle [ variable_name ] = recv_msg . value [EOL] [EOL] def evaluate_cycle ( self ) : [EOL] [EOL] self . logger . debug ( [string] , self . cycle_count , self . current_cycle ) [EOL] [EOL] arg_min , min_cost = self . compute_best_value ( ) [EOL] self . current_cycle [ self . variable . name ] = self . current_value [EOL] current_cost = assignment_cost ( self . current_cycle , self . constraints ) [EOL] [EOL] self . logger . debug ( [string] , self . cycle_count , current_cost , min_cost ) [EOL] [EOL] if current_cost - min_cost > [number] and [number] > random . random ( ) : [EOL] self . value_selection ( arg_min ) [EOL] self . logger . debug ( [string] , self . cycle_count , min_cost ) [EOL] else : [EOL] self . logger . debug ( [string] , self . current_value ) [EOL] [EOL] self . new_cycle ( ) [EOL] self . current_cycle , self . next_cycle = self . next_cycle , { } [EOL] self . post_to_all_neighbors ( DsaMessage ( self . current_value ) ) [EOL] [EOL] def is_cycle_complete ( self ) : [EOL] [comment] [EOL] return len ( self . current_cycle ) == len ( self . neighbors ) [EOL] [EOL] def compute_best_value ( self ) : [EOL] [EOL] arg_min , min_cost = None , float ( [string] ) [EOL] for value in self . variable . domain : [EOL] self . current_cycle [ self . variable . name ] = value [EOL] cost = assignment_cost ( self . current_cycle , self . constraints ) [EOL] if cost < min_cost : [EOL] min_cost , arg_min = cost , value [EOL] return arg_min , min_cost [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.algorithms.ComputationDef$ 0 0 0 0 0 0 0 0 0 $pydcop.algorithms.ComputationDef$ 0 0 0 0 0 $pydcop.algorithms.ComputationDef$ 0 0 0 0 $pydcop.algorithms.ComputationDef$ 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.algorithms.ComputationDef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import pydcop [EOL] import logging [EOL] import sys [EOL] [EOL] from pydcop . algorithms . amaxsum import VariableAlgo , FactorAlgo [EOL] from pydcop . dcop . objects import VariableWithCostFunc , VariableNoisyCostFunc [EOL] from pydcop . dcop . relations import AsNAryFunctionRelation [EOL] from pydcop . infrastructure . agents import Agent [EOL] from pydcop . infrastructure . run import synchronous_single_run [EOL] from pydcop . infrastructure . communication import InProcessCommunicationLayer [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] logging . info ( [string] ) [EOL] [EOL] [EOL] def maxsum_equality_noise ( ) : [EOL] [docstring] [EOL] [EOL] l1 = VariableNoisyCostFunc ( [string] , list ( range ( [number] ) ) , lambda x : x ) [EOL] l2 = VariableNoisyCostFunc ( [string] , list ( range ( [number] ) ) , lambda x : x ) [EOL] [EOL] [comment] [EOL] y1 = VariableWithCostFunc ( [string] , list ( range ( [number] ) ) , lambda x : [number] * abs ( [number] - x ) ) [EOL] [EOL] @ AsNAryFunctionRelation ( l1 , l2 , y1 ) def scene_rel ( x , y , z ) : [EOL] if z == x + y : [EOL] return [number] [EOL] return [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] algo_l1 = VariableAlgo ( l1 , [ scene_rel . name ] ) [EOL] [EOL] [comment] [EOL] algo_l2 = VariableAlgo ( l2 , [ scene_rel . name ] ) [EOL] [EOL] [comment] [EOL] algo_y1 = VariableAlgo ( y1 , [ scene_rel . name ] ) [EOL] algo_scene = FactorAlgo ( scene_rel ) [EOL] [EOL] comm = InProcessCommunicationLayer ( ) [EOL] [EOL] a1 = Agent ( [string] , comm ) [EOL] a1 . add_computation ( algo_l1 ) [EOL] [EOL] a2 = Agent ( [string] , comm ) [EOL] a2 . add_computation ( algo_l2 ) [EOL] [EOL] a3 = Agent ( [string] , comm ) [EOL] a3 . add_computation ( algo_y1 ) [EOL] a3 . add_computation ( algo_scene ) [EOL] dcop_agents = [ a1 , a2 , a3 ] [EOL] [EOL] results , _ , _ = synchronous_single_run ( dcop_agents , [number] ) [EOL] [EOL] print ( results ) [EOL] [EOL] if results [ [string] ] == [number] and results [ [string] ] + results [ [string] ] == [number] : [EOL] logging . info ( [string] ) [EOL] return [number] [EOL] else : [EOL] logging . info ( [string] + str ( results ) ) [EOL] return [number] [EOL] [EOL] [EOL] def run_test ( ) : [EOL] return maxsum_equality_noise ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( maxsum_equality_noise ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import pydcop [EOL] import logging [EOL] import sys [EOL] [EOL] from pydcop import infrastructure [EOL] from pydcop . algorithms import amaxsum [EOL] from pydcop . dcop import relations [EOL] from pydcop . dcop . objects import Variable [EOL] from pydcop . dcop . relations import UnaryFunctionRelation [EOL] from pydcop . infrastructure . run import synchronous_single_run [EOL] from pydcop . infrastructure . communication import InProcessCommunicationLayer [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] logging . info ( [string] ) [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] [EOL] def distribue_agent_for_all ( variables , factors ) : [EOL] comm = infrastructure . communication . InProcessCommunicationLayer ( ) [EOL] [EOL] node_agents = [ ] [EOL] for v in variables : [EOL] f_for_variable = [ f . name for f in factors if v . name in [ i . name for i in f . dimensions ] ] [EOL] [EOL] a = infrastructure . Agent ( [string] + v . name , comm ) [EOL] a . add_computation ( amaxsum . VariableAlgo ( v , f_for_variable ) ) [EOL] node_agents . append ( a ) [EOL] [EOL] for f in factors : [EOL] a = infrastructure . Agent ( [string] + f . name , comm ) [EOL] a . add_computation ( amaxsum . FactorAlgo ( f ) ) [EOL] node_agents . append ( a ) [EOL] [EOL] return node_agents [EOL] [EOL] [EOL] def graph_coloring_pb ( ) : [EOL] [EOL] [comment] [EOL] d1 = [ [number] , [number] ] [EOL] d2 = [ [number] , [number] , [number] ] [EOL] x1 = Variable ( [string] , d1 ) [EOL] x2 = Variable ( [string] , d2 ) [EOL] [EOL] [comment] [EOL] x1_cost = UnaryFunctionRelation ( [string] , x1 , lambda v : { [number] : [number] , [number] : - [number] } [ v ] ) [EOL] x2_cost = UnaryFunctionRelation ( [string] , x2 , lambda v : { [number] : [number] , [number] : - [number] , [number] : - [number] } [ v ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ relations . AsNAryFunctionRelation ( x1 , x2 ) def all_diff ( x1_val , x2_val ) : [EOL] if x1_val == x2_val : [EOL] return [number] [EOL] return [number] [EOL] [EOL] [comment] [EOL] variables = [ x1 , x2 ] [EOL] factors = [ x1_cost , x2_cost , all_diff ] [EOL] node_agents = distribue_agent_for_all ( variables , factors ) [EOL] [EOL] [comment] [EOL] results , _ , _ = synchronous_single_run ( node_agents ) [EOL] [EOL] print ( results ) [EOL] if results [ [string] ] == [number] and results [ [string] ] == [number] : [EOL] logging . info ( [string] ) [EOL] return [number] [EOL] else : [EOL] logging . info ( [string] + str ( results ) ) [EOL] return [number] [EOL] [EOL] [EOL] def run_test ( ) : [EOL] return graph_coloring_pb ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( run_test ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] from typing import List , Any , Dict [EOL] import typing [EOL] import os [EOL] import time [EOL] [EOL] [EOL] def run_all_integ_tests ( ) : [EOL] [docstring] [EOL] [EOL] dir_path = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] tests_run = { } [EOL] tests_nums = [ [number] , [number] , [number] ] [EOL] [EOL] entries = os . listdir ( dir_path ) [EOL] for entry in entries : [EOL] module_name = entry [ : - [number] ] [EOL] if entry . endswith ( [string] ) : [EOL] integ_test_module = __import__ ( entry [ : - [number] ] ) [EOL] [EOL] try : [EOL] test_method = getattr ( integ_test_module , [string] ) [EOL] tests_nums [ [number] ] += [number] [EOL] try : [EOL] print ( [string] + module_name ) [EOL] result = test_method ( ) [EOL] if result == [number] : [EOL] tests_run [ module_name ] = [string] [EOL] tests_nums [ [number] ] += [number] [EOL] else : [EOL] tests_run [ module_name ] = [string] [EOL] tests_nums [ [number] ] += [number] [EOL] [EOL] except Exception as e : [EOL] tests_run [ module_name ] = [string] . format ( e ) [EOL] tests_nums [ [number] ] += [number] [EOL] except AttributeError : [EOL] print ( [string] + entry ) [EOL] tests_run [ module_name ] = [string] [EOL] [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] print ( [string] . format ( * tests_nums ) ) [EOL] [EOL] print ( [string] ) [EOL] for k in [ k for k , v in tests_run . items ( ) if v == [string] ] : [EOL] print ( [string] + k ) [EOL] [EOL] print ( [string] ) [EOL] for ( k , v ) in [ ( k , v ) for k , v in tests_run . items ( ) if v . startswith ( [string] ) ] : [EOL] print ( [string] . format ( k , v ) ) [EOL] [EOL] print ( [string] ) [EOL] for k in [ k for k , v in tests_run . items ( ) if v . startswith ( [string] ) ] : [EOL] print ( [string] + k ) [EOL] [EOL] if __name__ == [string] : [EOL] run_all_integ_tests ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Union , Literal , Any [EOL] import typing [EOL] import pydcop [EOL] import typing_extensions [EOL] import logging [EOL] import sys [EOL] [EOL] from pydcop . algorithms import amaxsum [EOL] from pydcop . dcop import relations [EOL] from pydcop . dcop . objects import Variable [EOL] from pydcop . infrastructure . agents import Agent [EOL] from pydcop . infrastructure . run import synchronous_single_run [EOL] from pydcop . infrastructure . communication import InProcessCommunicationLayer [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] logging . info ( [string] ) [EOL] [EOL] [EOL] def distribute_agents ( var_facts ) : [EOL] comm = InProcessCommunicationLayer ( ) [EOL] [EOL] dcop_agents = [ ] [EOL] factors = [ f for _ , f in var_facts ] [EOL] [EOL] i = [number] [EOL] for v , f in var_facts : [EOL] [EOL] [comment] [EOL] [comment] [EOL] f_for_variable = [ f . name for f in factors if v . name in [ i . name for i in f . dimensions ] ] [EOL] v_a = amaxsum . VariableAlgo ( v , f_for_variable ) [EOL] [EOL] [comment] [EOL] f_a = amaxsum . FactorAlgo ( f ) [EOL] [EOL] [comment] [EOL] a = Agent ( [string] + str ( i ) , comm ) [EOL] a . add_computation ( v_a ) [EOL] a . add_computation ( f_a ) [EOL] i += [number] [EOL] [EOL] dcop_agents . append ( a ) [EOL] [EOL] return dcop_agents , comm [EOL] [EOL] [EOL] def graph_coloring_with_prefs ( ) : [EOL] [docstring] [EOL] [comment] [EOL] d = [ [string] , [string] ] [EOL] x1 = Variable ( [string] , d ) [EOL] x2 = Variable ( [string] , d ) [EOL] x3 = Variable ( [string] , d ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def p1 ( v ) : [EOL] return - [number] if v == [string] else [number] [EOL] [EOL] def p2 ( v ) : [EOL] return - [number] if v == [string] else [number] [EOL] [EOL] def p3 ( v ) : [EOL] return - [number] if v == [string] else [number] [EOL] [EOL] [comment] [EOL] @ relations . AsNAryFunctionRelation ( x1 , x2 ) def u1 ( x1_ , x2_ ) : [EOL] c = [number] if x1_ == x2_ else [number] [EOL] return c + p1 ( x1_ ) + p2 ( x2_ ) [EOL] [EOL] @ relations . AsNAryFunctionRelation ( x1 , x2 , x3 ) def u2 ( x1_ , x2_ , x3_ ) : [EOL] c = [number] if x1_ == x2_ else [number] [EOL] c += [number] if x2_ == x3_ else [number] [EOL] return c + p1 ( x1_ ) + p2 ( x2_ ) + p3 ( x3_ ) [EOL] [EOL] @ relations . AsNAryFunctionRelation ( x2 , x3 ) def u3 ( x2_ , x3_ ) : [EOL] c = [number] if x2_ == x3_ else [number] [EOL] return c + p2 ( x2_ ) + p3 ( x3_ ) [EOL] [EOL] [comment] [EOL] node_agents , comm = distribute_agents ( [ ( x1 , u1 ) , ( x2 , u2 ) , ( x3 , u3 ) ] ) [EOL] [EOL] [comment] [EOL] results , _ , _ = synchronous_single_run ( node_agents ) [EOL] [EOL] if results [ [string] ] == [string] and results [ [string] ] == [string] and results [ [string] ] == [string] : [EOL] logging . info ( [string] ) [EOL] return [number] [EOL] else : [EOL] logging . info ( [string] + str ( results ) ) [EOL] return [number] [EOL] [EOL] [EOL] def run_test ( ) : [EOL] return graph_coloring_with_prefs ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( graph_coloring_with_prefs ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import pydcop [EOL] import logging [EOL] [EOL] import pydcop . infrastructure . communication [EOL] from pydcop import infrastructure [EOL] from pydcop . algorithms import amaxsum [EOL] from pydcop . dcop import relations [EOL] from pydcop . dcop . objects import Variable [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def distribue_agent_for_all ( variables , factors ) : [EOL] comm = infrastructure . communication . InProcessCommunicationLayer ( ) [EOL] [EOL] node_agents = [ ] [EOL] for v in variables : [EOL] f_for_variable = [ f . name for f in factors if v . name in [ i . name for i in f . dimensions ] ] [EOL] [EOL] a = infrastructure . Agent ( [string] + v . name , comm ) [EOL] a . add_computation ( amaxsum . VariableAlgo ( v , f_for_variable ) ) [EOL] node_agents . append ( a ) [EOL] [EOL] for f in factors : [EOL] a = infrastructure . Agent ( [string] + f . name , comm ) [EOL] a . add_computation ( amaxsum . FactorAlgo ( f ) ) [EOL] node_agents . append ( a ) [EOL] [EOL] return node_agents [EOL] [EOL] [EOL] def graph_coloring_no_prefs ( ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] d = [ [string] , [string] ] [EOL] v1 = Variable ( [string] , d ) [EOL] v2 = Variable ( [string] , d ) [EOL] v3 = Variable ( [string] , d ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] BIN_DIFF_TABLE_2 = [ [ [number] , [number] ] , [ [number] , [number] ] ] [EOL] [comment] [EOL] f12 = relations . NAryMatrixRelation ( [ v1 , v2 ] , name = [string] , matrix = BIN_DIFF_TABLE_2 ) [EOL] [EOL] [comment] [EOL] f23 = relations . NAryMatrixRelation ( [ v2 , v3 ] , name = [string] , matrix = BIN_DIFF_TABLE_2 ) [EOL] [EOL] [comment] [EOL] node_agents = distribue_agent_for_all ( [ v1 , v2 , v3 ] , [ f12 , f23 ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for n in node_agents : [EOL] for a in n . computations : [EOL] if hasattr ( a , [string] ) : [EOL] a . _init_msg ( ) [EOL] res , _ , _ = infrastructure . synchronous_single_run ( node_agents ) [EOL] [EOL] print ( [string] + str ( res ) ) [EOL] [EOL] [EOL] def graph_coloring_with_prefs ( ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] d = [ [string] , [string] ] [EOL] v1 = Variable ( [string] , d ) [EOL] v2 = Variable ( [string] , d ) [EOL] v3 = Variable ( [string] , d ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] BIN_DIFF_TABLE_PREFS_12 = [ [ [number] , [number] ] , [ - [number] , [number] ] ] [EOL] [EOL] f12 = relations . NAryMatrixRelation ( [ v1 , v2 ] , name = [string] , matrix = BIN_DIFF_TABLE_PREFS_12 ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] BIN_DIFF_TABLE_PREFS_23 = [ [ [number] , [number] ] , [ [number] , [number] ] ] [EOL] f23 = relations . NAryMatrixRelation ( [ v2 , v3 ] , name = [string] , matrix = BIN_DIFF_TABLE_PREFS_23 ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] node_agents = distribue_agent_for_all ( [ v1 , v2 , v3 ] , [ f12 , f23 ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for n in node_agents : [EOL] for a in n . computations : [EOL] if hasattr ( a , [string] ) : [EOL] a . _init_msg ( ) [EOL] res , _ , _ = infrastructure . synchronous_single_run ( node_agents ) [EOL] [EOL] print ( [string] + str ( res ) ) [EOL] [EOL] [EOL] def run_test ( ) : [EOL] graph_coloring_with_prefs ( ) [EOL] graph_coloring_no_prefs ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [number] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] graph_coloring_with_prefs ( ) [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Union , Dict , Any , List , Literal [EOL] import typing [EOL] import pydcop [EOL] import typing_extensions [EOL] import logging [EOL] import sys [EOL] [EOL] from pydcop . algorithms import dsa [EOL] from pydcop . dcop import relations [EOL] from pydcop . dcop . objects import Variable [EOL] from pydcop . infrastructure . agents import Agent [EOL] from pydcop . infrastructure . run import synchronous_single_run [EOL] from pydcop . infrastructure . communication import InProcessCommunicationLayer [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] logging . info ( [string] ) [EOL] [EOL] [EOL] def distribute_agents ( var_facts , variant , probability ) : [EOL] comm = InProcessCommunicationLayer ( ) [EOL] [EOL] dcop_agents = [ ] [EOL] factors = [ f for _ , f in var_facts ] [EOL] [EOL] i = [number] [EOL] for v , f in var_facts : [EOL] [comment] [EOL] [comment] [EOL] f_for_variable = [ f for f in factors if v . name in [ i . name for i in f . dimensions ] ] [EOL] v_a = dsa . DsaComputation ( v , f_for_variable , variant = [string] ) [EOL] [EOL] [comment] [EOL] a = Agent ( [string] + str ( i ) , comm ) [EOL] a . add_computation ( v_a ) [EOL] i += [number] [EOL] [EOL] dcop_agents . append ( a ) [EOL] [EOL] return dcop_agents , comm [EOL] [EOL] [EOL] def graph_coloring_with_prefs ( variant , probability ) : [EOL] [comment] [EOL] d = [ [string] , [string] ] [EOL] x1 = Variable ( [string] , d ) [EOL] x2 = Variable ( [string] , d ) [EOL] x3 = Variable ( [string] , d ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def p1 ( v ) : [EOL] return - [number] if v == [string] else [number] [EOL] [EOL] def p2 ( v ) : [EOL] return - [number] if v == [string] else [number] [EOL] [EOL] def p3 ( v ) : [EOL] return - [number] if v == [string] else [number] [EOL] [EOL] [comment] [EOL] @ relations . AsNAryFunctionRelation ( x1 , x2 ) def u1 ( x1_ , x2_ ) : [EOL] c = [number] if x1_ == x2_ else [number] [EOL] return c + p1 ( x1_ ) + p2 ( x2_ ) [EOL] [EOL] @ relations . AsNAryFunctionRelation ( x1 , x2 , x3 ) def u2 ( x1_ , x2_ , x3_ ) : [EOL] c = [number] if x1_ == x2_ else [number] [EOL] c += [number] if x2_ == x3_ else [number] [EOL] return c + p1 ( x1_ ) + p2 ( x2_ ) + p3 ( x3_ ) [EOL] [EOL] @ relations . AsNAryFunctionRelation ( x2 , x3 ) def u3 ( x2_ , x3_ ) : [EOL] c = [number] if x2_ == x3_ else [number] [EOL] return c + p2 ( x2_ ) + p3 ( x3_ ) [EOL] [EOL] [comment] [EOL] node_agents , comm = distribute_agents ( [ ( x1 , u1 ) , ( x2 , u2 ) , ( x3 , u3 ) ] , variant , probability ) [EOL] [EOL] [comment] [EOL] results , _ , _ = synchronous_single_run ( node_agents ) [EOL] [EOL] if results [ [string] ] == [string] and results [ [string] ] == [string] and results [ [string] ] == [string] : [EOL] logging . info ( [string] ) [EOL] return [number] [EOL] else : [EOL] logging . info ( [string] + str ( results ) ) [EOL] return [number] [EOL] [EOL] [EOL] def run_several_times ( variant , probability , run_count = [number] ) : [EOL] res = [number] [EOL] for i in range ( run_count ) : [EOL] res += graph_coloring_with_prefs ( variant , probability ) [EOL] success_rate = ( run_count - res ) / run_count [EOL] logging . info ( [string] , run_count , success_rate ) [EOL] return success_rate [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def run_full_bench ( ) : [EOL] results = { } [EOL] for probability in [ x / [number] for x in range ( [number] , [number] ) ] : [EOL] results [ probability ] = { } [EOL] for variant in [ [string] , [string] , [string] ] : [EOL] success_rate = run_several_times ( variant , probability , [number] ) [EOL] results [ probability ] [ variant ] = success_rate [EOL] [EOL] logging . info ( [string] , results ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def run_test ( ) : [EOL] return run_several_times ( [string] , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( run_full_bench ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pydcop [EOL] import logging [EOL] import sys [EOL] [EOL] from pydcop . algorithms . dpop import DpopAlgo [EOL] from pydcop . dcop import relations [EOL] from pydcop . dcop . objects import Variable [EOL] from pydcop . infrastructure . run import synchronous_single_run [EOL] from pydcop . infrastructure . agents import Agent [EOL] from pydcop . infrastructure . communication import InProcessCommunicationLayer [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] logging . info ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] INFNT = sys . maxsize [EOL] [EOL] [EOL] def dpop_nonbinaryrelation_4vars ( ) : [EOL] [EOL] x0 = Variable ( [string] , list ( range ( [number] ) ) ) [EOL] x1 = Variable ( [string] , list ( range ( [number] ) ) ) [EOL] x2 = Variable ( [string] , list ( range ( [number] ) ) ) [EOL] x3 = Variable ( [string] , list ( range ( [number] ) ) ) [EOL] [EOL] @ relations . AsNAryFunctionRelation ( x0 ) def x0_prefs ( x ) : [EOL] if x > [number] : [EOL] return [number] [EOL] return [number] [EOL] [EOL] @ relations . AsNAryFunctionRelation ( x1 ) def x1_prefs ( x ) : [EOL] if [number] < x < [number] : [EOL] return [number] [EOL] return [number] [EOL] [EOL] @ relations . AsNAryFunctionRelation ( x2 ) def x2_prefs ( x ) : [EOL] if x < [number] : [EOL] return [number] [EOL] return [number] [EOL] [EOL] @ relations . AsNAryFunctionRelation ( x3 ) def x3_prefs ( x ) : [EOL] if [number] < x < [number] : [EOL] return [number] [EOL] return [number] [EOL] [EOL] @ relations . AsNAryFunctionRelation ( x0 , x1 , x2 , x3 ) def four_ary_relation ( a , b , c , d ) : [EOL] return abs ( [number] - ( a + b + c + d ) ) [EOL] [EOL] def neutral_relation ( x , y ) : [EOL] return [number] [EOL] [EOL] comm = InProcessCommunicationLayer ( ) [EOL] [EOL] al0 = DpopAlgo ( x0 , mode = [string] ) [EOL] al1 = DpopAlgo ( x1 , mode = [string] ) [EOL] al2 = DpopAlgo ( x2 , mode = [string] ) [EOL] al3 = DpopAlgo ( x3 , mode = [string] ) [EOL] [EOL] [comment] [EOL] al0 . add_relation ( x0_prefs ) [EOL] al1 . add_relation ( x1_prefs ) [EOL] al2 . add_relation ( x2_prefs ) [EOL] al3 . add_relation ( x3_prefs ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] al0 . add_child ( x1 ) [EOL] al1 . set_parent ( x0 ) [EOL] al1 . add_relation ( relations . NAryFunctionRelation ( neutral_relation , [ x0 , x1 ] ) ) [EOL] [EOL] al1 . add_child ( x2 ) [EOL] al2 . set_parent ( x1 ) [EOL] al2 . add_relation ( relations . NAryFunctionRelation ( neutral_relation , [ x1 , x2 ] ) ) [EOL] [EOL] al2 . add_child ( x3 ) [EOL] al3 . set_parent ( x2 ) [EOL] al3 . add_relation ( relations . NAryFunctionRelation ( neutral_relation , [ x2 , x3 ] ) ) [EOL] [EOL] al3 . add_relation ( four_ary_relation ) [EOL] [EOL] a0 = Agent ( [string] , comm ) [EOL] a0 . add_computation ( al0 ) [EOL] a1 = Agent ( [string] , comm ) [EOL] a1 . add_computation ( al1 ) [EOL] a2 = Agent ( [string] , comm ) [EOL] a2 . add_computation ( al2 ) [EOL] a3 = Agent ( [string] , comm ) [EOL] a3 . add_computation ( al3 ) [EOL] [EOL] results , _ , _ = synchronous_single_run ( [ a0 , a1 , a2 , a3 ] ) [EOL] [EOL] if results == { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } : [EOL] logging . info ( [string] + str ( results ) ) [EOL] return [number] [EOL] else : [EOL] logging . info ( [string] + str ( results ) ) [EOL] return [number] [EOL] [EOL] [EOL] def run_test ( ) : [EOL] return dpop_nonbinaryrelation_4vars ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( dpop_nonbinaryrelation_4vars ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pydcop [EOL] import logging [EOL] [EOL] from pydcop . computations_graph . factor_graph import build_computation_graph [EOL] from pydcop . dcop . yamldcop import load_dcop [EOL] from pydcop . distribution . oneagent import distribute [EOL] from pydcop . infrastructure import synchronous_single_run [EOL] from pydcop . infrastructure . agents import deploy_on_local_agents [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] logging . info ( [string] ) [EOL] [EOL] [EOL] dcop_yaml = [string] [EOL] [EOL] dcop = load_dcop ( dcop_yaml ) [EOL] [EOL] cg = build_computation_graph ( dcop ) [EOL] [EOL] mapping = distribute ( cg , dcop . agents ) [EOL] [EOL] agents = deploy_on_local_agents ( cg , mapping ) [EOL] [EOL] results , _ , _ = synchronous_single_run ( agents ) [EOL] [EOL] print ( [string] + str ( results ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $pydcop.computations_graph.factor_graph.ComputationsFactorGraph$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $pydcop.computations_graph.factor_graph.ComputationsFactorGraph$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $pydcop.computations_graph.factor_graph.ComputationsFactorGraph$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] def diff_vars ( a , b ) : [EOL] [docstring] [EOL] if a == b : [EOL] return [number] [EOL] else : [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [docstring] [EOL] import sys [EOL] from os import path [EOL] [EOL] [EOL] def instance_path ( instance_filename ) : [EOL] [docstring] [EOL] cur_dir = sys . modules [ __name__ ] . __file__ [EOL] dir_name = path . dirname ( cur_dir ) [EOL] test_file_path = path . join ( dir_name , [string] , [string] , instance_filename ) [EOL] return test_file_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import builtins [EOL] import unittest [EOL] from subprocess import check_output , STDOUT , CalledProcessError [EOL] [EOL] import yaml [EOL] [EOL] from tests . dcop_cli . utils import instance_path [EOL] [EOL] [EOL] class GraphColoring1 ( unittest . TestCase ) : [EOL] [EOL] def test_oneagent_pseudotree ( self ) : [EOL] result = run_distribute ( [string] , [string] , [string] ) [EOL] dist = result [ [string] ] [EOL] [EOL] [comment] [EOL] for a in dist : [EOL] self . assertLessEqual ( len ( dist [ a ] ) , [number] ) [EOL] [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] [EOL] def test_oneagent_factorgraph ( self ) : [EOL] result = run_distribute ( [string] , [string] , [string] ) [EOL] dist = result [ [string] ] [EOL] [EOL] [comment] [EOL] for a in dist : [EOL] self . assertLessEqual ( len ( dist [ a ] ) , [number] ) [EOL] [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] [EOL] def test_oneagent_constraints_hypergraph ( self ) : [EOL] result = run_distribute ( [string] , [string] , [string] ) [EOL] dist = result [ [string] ] [EOL] [EOL] [comment] [EOL] for a in dist : [EOL] self . assertLessEqual ( len ( dist [ a ] ) , [number] ) [EOL] [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] [EOL] @ unittest . skip ( [string] ) def test_adhoc_pseudotree ( self ) : [EOL] result = run_distribute ( [string] , [string] , [string] , algo = [string] ) [EOL] dist = result [ [string] ] [EOL] [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] [EOL] def test_adhoc_factorgraph ( self ) : [EOL] result = run_distribute ( [string] , [string] , [string] , algo = [string] ) [EOL] dist = result [ [string] ] [EOL] [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] [EOL] def test_adhoc_constraints_hypergraph ( self ) : [EOL] result = run_distribute ( [string] , [string] , [string] , algo = [string] ) [EOL] dist = result [ [string] ] [EOL] [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] [EOL] def test_ilp_fgdp_factorgraph ( self ) : [EOL] [comment] [EOL] result = run_distribute ( [string] , [string] , [string] , algo = [string] ) [EOL] dist = result [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for a in dist : [EOL] self . assertEqual ( len ( dist [ a ] ) , [number] ) [EOL] [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] self . assertTrue ( is_hosted ( dist , [string] ) ) [EOL] [EOL] def test_ilp_fgdp_pseudotree ( self ) : [EOL] [comment] [EOL] self . assertRaises ( CalledProcessError , run_distribute , [string] , [string] , [string] , algo = [string] ) [EOL] [EOL] def test_ilp_fgdp_constraints_hypergraph ( self ) : [EOL] [comment] [EOL] self . assertRaises ( CalledProcessError , run_distribute , [string] , [string] , [string] , algo = [string] ) [EOL] [EOL] def test_ilp_compref_factorgraph ( self ) : [EOL] [comment] [EOL] result = run_distribute ( [string] , [string] , [string] , algo = [string] ) [EOL] [comment] [EOL] [EOL] def test_ilp_compref_constraints_hypergraph ( self ) : [EOL] result = run_distribute ( [string] , [string] , [string] , algo = [string] ) [EOL] [comment] [EOL] [EOL] [EOL] class DistAlgoOpionCompatibility ( unittest . TestCase ) : [EOL] [EOL] def test_dist_with_only_algo_only ( self ) : [EOL] run_distribute ( [string] , [string] , algo = [string] ) [EOL] [EOL] def test_dist_with_graph_only ( self ) : [EOL] run_distribute ( [string] , [string] , graph = [string] ) [EOL] [EOL] def test_incompatible_graph_algo_must_fail ( self ) : [EOL] self . assertRaises ( CalledProcessError , run_distribute , [string] , [string] , algo = [string] , graph = [string] ) [EOL] [EOL] def is_hosted ( mapping , computation ) : [EOL] for a in mapping : [EOL] if computation in mapping [ a ] : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def run_distribute ( filename , distribution , graph = None , algo = None ) : [EOL] [docstring] [EOL] filename = instance_path ( filename ) [EOL] algo_opt = [string] if algo is None else [string] + algo [EOL] graph_opt = [string] if graph is None else [string] + graph [EOL] cmd = [string] [string] . format ( distribution = distribution , graph_opt = graph_opt , algo_opt = algo_opt , file = filename ) [EOL] output = check_output ( cmd , stderr = STDOUT , timeout = [number] , shell = True ) [EOL] return yaml . load ( output . decode ( encoding = [string] ) , Loader = yaml . FullLoader ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import unittest [EOL] from subprocess import check_output , STDOUT , CalledProcessError [EOL] [EOL] import yaml [EOL] [EOL] from tests . dcop_cli . utils import instance_path [EOL] [EOL] [EOL] class GraphColoring1 ( unittest . TestCase ) : [EOL] [EOL] def test_pseudotree ( self ) : [EOL] result = run_graph ( [string] , [string] ) [EOL] [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] / ( [number] * [number] ) ) [EOL] [EOL] def test_factor_graph ( self ) : [EOL] result = run_graph ( [string] , [string] ) [EOL] [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] [EOL] def test_constraints_hypergraph ( self ) : [EOL] result = run_graph ( [string] , [string] ) [EOL] [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] / [number] ) [EOL] [EOL] [EOL] class SecpSimple1 ( unittest . TestCase ) : [EOL] [EOL] def test_pseudotree ( self ) : [EOL] result = run_graph ( [string] , [string] ) [EOL] [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] [EOL] def test_factor_graph ( self ) : [EOL] result = run_graph ( [string] , [string] ) [EOL] [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] * [number] / ( [number] * [number] ) ) [EOL] [EOL] def test_constraints_hypergraph ( self ) : [EOL] result = run_graph ( [string] , [string] ) [EOL] [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] ) [EOL] self . assertEqual ( result [ [string] ] , [number] / [number] ) [EOL] [EOL] [EOL] def run_graph ( filename , graph ) : [EOL] filename = instance_path ( filename ) [EOL] cmd = [string] . format ( graph = graph , file = filename ) [EOL] output = check_output ( cmd , stderr = STDOUT , timeout = [number] , shell = True ) [EOL] return yaml . load ( output . decode ( encoding = [string] ) , Loader = yaml . FullLoader ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import MagicMock [EOL] [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture def event_bus ( ) : [EOL] from pydcop . infrastructure . Events import event_bus [EOL] [EOL] event_bus . reset ( ) [EOL] event_bus . enabled = True [EOL] return event_bus [EOL] [EOL] [EOL] def test_simple_send ( event_bus ) : [EOL] [EOL] cb = MagicMock ( ) [EOL] [EOL] event_bus . subscribe ( [string] , cb ) [EOL] [EOL] event_bus . send ( [string] , [number] ) [EOL] cb . assert_called_once_with ( [string] , [number] ) [EOL] [EOL] [EOL] def test_cb_not_called_when_not_subscribed ( event_bus ) : [EOL] [EOL] cb = MagicMock ( ) [EOL] event_bus . send ( [string] , [number] ) [EOL] cb . assert_not_called ( ) [EOL] [EOL] [EOL] def test_do_not_receive_evt_once_unsubscribed ( event_bus ) : [EOL] cb = MagicMock ( ) [EOL] [EOL] event_bus . subscribe ( [string] , cb ) [EOL] [EOL] event_bus . send ( [string] , [number] ) [EOL] [EOL] cb . assert_called_once_with ( [string] , [number] ) [EOL] [EOL] cb . reset_mock ( ) [EOL] event_bus . unsubscribe ( cb ) [EOL] [EOL] event_bus . send ( [string] , [number] ) [EOL] cb . assert_not_called ( ) [EOL] [EOL] [EOL] def test_unsubscribe_from_single_topic ( event_bus ) : [EOL] [EOL] cb1 = event_bus . subscribe ( [string] , MagicMock ( ) ) [EOL] cb2 = event_bus . subscribe ( [string] , MagicMock ( ) ) [EOL] [EOL] event_bus . send ( [string] , [number] ) [EOL] [EOL] cb1 . assert_called_once_with ( [string] , [number] ) [EOL] cb2 . assert_called_once_with ( [string] , [number] ) [EOL] [EOL] cb1 . reset_mock ( ) [EOL] cb2 . reset_mock ( ) [EOL] event_bus . unsubscribe ( cb2 ) [EOL] [EOL] event_bus . send ( [string] , [number] ) [EOL] cb1 . assert_called_once_with ( [string] , [number] ) [EOL] cb2 . assert_not_called ( ) [EOL] [EOL] [EOL] def test_several_subscribers ( event_bus ) : [EOL] [EOL] cb1 = event_bus . subscribe ( [string] , MagicMock ( ) ) [EOL] cb2 = event_bus . subscribe ( [string] , MagicMock ( ) ) [EOL] cb3 = event_bus . subscribe ( [string] , MagicMock ( ) ) [EOL] [EOL] event_bus . send ( [string] , [number] ) [EOL] [EOL] cb1 . assert_called_once_with ( [string] , [number] ) [EOL] cb2 . assert_called_once_with ( [string] , [number] ) [EOL] cb3 . assert_called_once_with ( [string] , [number] ) [EOL] [EOL] [EOL] def test_receive_evt_from_sub_topics ( event_bus ) : [EOL] [EOL] cb1 = event_bus . subscribe ( [string] , MagicMock ( ) ) [EOL] [EOL] [comment] [EOL] event_bus . send ( [string] , [number] ) [EOL] cb1 . assert_called_once_with ( [string] , [number] ) [EOL] [EOL] [comment] [EOL] cb1 . reset_mock ( ) [EOL] event_bus . send ( [string] , [number] ) [EOL] cb1 . assert_not_called ( ) [EOL] [EOL] [comment] [EOL] cb1 . reset_mock ( ) [EOL] event_bus . send ( [string] , [number] ) [EOL] cb1 . assert_not_called ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from pydcop . commands . generators . meetingscheduling import ( generate_resources , generate_events , generate_problem_definition , peav_variables_for_resource , ) [EOL] [EOL] [EOL] def test_generate_resources ( ) : [EOL] resources = generate_resources ( count = [number] , max_value = [number] , slots = [ [number] , [number] , [number] ] ) [EOL] [EOL] assert len ( resources ) == [number] [EOL] for id , resource in resources . items ( ) : [EOL] assert id == resource . id [EOL] assert len ( resource . value_free ) == [number] [EOL] for value in resource . value_free : [EOL] assert [number] <= value <= [number] [EOL] [EOL] [EOL] def test_generate_events ( ) : [EOL] resources = generate_resources ( count = [number] , max_value = [number] , slots = [ [number] , [number] , [number] ] ) [EOL] events = generate_events ( count = [number] , max_value = [number] , max_length = [number] , resources = list ( resources . values ( ) ) , max_resources_count = [number] , ) [EOL] [EOL] assert len ( events ) == [number] [EOL] for id , event in events . items ( ) : [EOL] assert event . id == id [EOL] assert [number] <= event . length <= [number] [EOL] assert [number] <= len ( event . resources ) <= [number] [EOL] assert len ( set ( event . resources ) ) == len ( event . resources ) [EOL] for resource , value in event . resources . items ( ) : [EOL] assert [number] <= value <= [number] [EOL] [EOL] [EOL] def test_generate_variables ( ) : [EOL] slots_count = [number] [EOL] slots , events , resources = generate_problem_definition ( slots_count = slots_count , resources_count = [number] , max_resource_value = [number] , events_count = [number] , max_length_event = [number] , max_resources_event = [number] , ) [EOL] [EOL] _ , resource = resources . popitem ( ) [EOL] variables = peav_variables_for_resource ( resource , events , slots_count ) [EOL] events_with_resource = [ evt for evt in events . values ( ) if resource . id in evt . resources ] [EOL] assert len ( variables ) == len ( events_with_resource ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import functools [EOL] import pydcop [EOL] import unittest [EOL] from functools import partial [EOL] [EOL] import pytest [EOL] [EOL] from pydcop . utils . expressionfunction import ExpressionFunction , _analyse_ast [EOL] from pydcop . utils . simple_repr import simple_repr , from_repr [EOL] [EOL] [EOL] class TestExpressionFunction ( unittest . TestCase ) : [EOL] [EOL] def test_callable ( self ) : [EOL] [EOL] f = ExpressionFunction ( [string] ) [EOL] self . assertEqual ( f ( a = [number] , b = [number] ) , [number] ) [EOL] [EOL] def test_simple_math_expression ( self ) : [EOL] [EOL] f = ExpressionFunction ( [string] ) [EOL] self . assertEqual ( f . expression , [string] ) [EOL] [EOL] def test_oneline_python_expression ( self ) : [EOL] [EOL] f = ExpressionFunction ( [string] ) [EOL] [EOL] self . assertEqual ( f ( a = [number] , b = [number] ) , [number] ) [EOL] self . assertEqual ( f ( a = [number] , b = [number] ) , [string] ) [EOL] [EOL] def test_complex_oneline_exp ( self ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] f = ExpressionFunction ( [string] [string] ) [EOL] [EOL] self . assertEqual ( f ( a = [number] , b = [number] , c = [number] , M = [number] ) , [number] ) [EOL] self . assertEqual ( f ( a = [number] , b = [number] , c = [number] , M = [number] ) , [number] ) [EOL] self . assertEqual ( f ( a = [number] , b = [number] , c = [number] , M = [number] ) , [number] ) [EOL] [EOL] def test_variable_names ( self ) : [EOL] [EOL] f = ExpressionFunction ( [string] ) [EOL] names = f . variable_names [EOL] [EOL] self . assertEqual ( len ( list ( names ) ) , [number] ) [EOL] self . assertIn ( [string] , names ) [EOL] self . assertIn ( [string] , names ) [EOL] [EOL] def test_should_work_with_partial ( self ) : [EOL] [EOL] f = ExpressionFunction ( [string] ) [EOL] [EOL] fp = partial ( f , c = [number] ) [EOL] self . assertEqual ( f ( a = [number] , b = [number] , c = [number] ) , [number] ) [EOL] self . assertEqual ( f ( a = [number] , b = [number] , c = [number] ) , fp ( a = [number] , b = [number] ) ) [EOL] [EOL] fp = partial ( f , c = [number] , a = [number] ) [EOL] self . assertEqual ( f ( a = [number] , b = [number] , c = [number] ) , fp ( b = [number] ) ) [EOL] [EOL] def test_non_numeric_variable ( self ) : [EOL] [EOL] f = ExpressionFunction ( [string] ) [EOL] self . assertEqual ( f ( a = [string] ) , [number] ) [EOL] self . assertEqual ( f ( a = [string] ) , [number] ) [EOL] [EOL] def test_str_with_function_call ( self ) : [EOL] r = ExpressionFunction ( [string] ) [EOL] [EOL] self . assertEqual ( len ( list ( r . variable_names ) ) , [number] ) [EOL] self . assertEqual ( r ( s1 = [number] , s2 = [number] ) , [number] ) [EOL] self . assertEqual ( r ( s1 = [number] , s2 = [number] ) , [number] ) [EOL] [EOL] def test_raise_on_syntax_error ( self ) : [EOL] self . assertRaises ( SyntaxError , ExpressionFunction , [string] ) [EOL] [EOL] def test_simple_repr ( self ) : [EOL] f = ExpressionFunction ( [string] ) [EOL] self . assertEqual ( f . expression , [string] ) [EOL] [EOL] r = simple_repr ( f ) [EOL] [EOL] self . assertEqual ( r [ [string] ] , [string] ) [EOL] [EOL] def test_from_simple_repr ( self ) : [EOL] f = ExpressionFunction ( [string] ) [EOL] self . assertEqual ( f . expression , [string] ) [EOL] [EOL] r = simple_repr ( f ) [EOL] f2 = from_repr ( r ) [EOL] [EOL] self . assertEqual ( f ( a = [number] , b = [number] ) , f2 ( a = [number] , b = [number] ) ) [EOL] self . assertEqual ( f2 ( a = [number] , b = [number] ) , [number] ) [EOL] self . assertEqual ( f , f2 ) [EOL] [EOL] def test_partial ( self ) : [EOL] f = ExpressionFunction ( [string] ) [EOL] fp = f . partial ( a = [number] ) [EOL] self . assertEqual ( fp ( b = [number] ) , [number] ) [EOL] [EOL] self . assertNotIn ( [string] , fp . variable_names ) [EOL] [EOL] def test_fixed_vars ( self ) : [EOL] f = ExpressionFunction ( [string] , b = [number] ) [EOL] self . assertEqual ( f ( a = [number] ) , [number] ) [EOL] [EOL] self . assertNotIn ( [string] , f . variable_names ) [EOL] [EOL] def test_simple_repr_on_partial ( self ) : [EOL] f = ExpressionFunction ( [string] ) [EOL] fp = f . partial ( a = [number] ) [EOL] [EOL] r = simple_repr ( fp ) [EOL] print ( r ) [EOL] [EOL] self . assertEqual ( r [ [string] ] , [string] ) [EOL] self . assertIn ( [string] , r [ [string] ] ) [EOL] self . assertEqual ( r [ [string] ] [ [string] ] , [number] ) [EOL] [EOL] def test_from_repr_on_partial ( self ) : [EOL] f = ExpressionFunction ( [string] ) [EOL] fp = f . partial ( a = [number] ) [EOL] [EOL] r = simple_repr ( fp ) [EOL] f1 = from_repr ( r ) [EOL] print ( r ) [EOL] [EOL] self . assertEqual ( f1 ( b = [number] ) , [number] ) [EOL] self . assertEqual ( f1 ( b = [number] ) , f ( a = [number] , b = [number] ) ) [EOL] [EOL] def test_hash ( self ) : [EOL] f = ExpressionFunction ( [string] ) [EOL] h = hash ( f ) [EOL] [EOL] self . assertEqual ( h , hash ( ExpressionFunction ( [string] ) ) ) [EOL] self . assertNotEqual ( h , hash ( ExpressionFunction ( [string] ) ) ) [EOL] [EOL] def test_hash_fixed_vars ( self ) : [EOL] f1 = ExpressionFunction ( [string] , b = [number] ) [EOL] f2 = ExpressionFunction ( [string] , b = [number] ) [EOL] f3 = ExpressionFunction ( [string] ) [EOL] [EOL] self . assertNotEqual ( hash ( f1 ) , hash ( f2 ) ) [EOL] self . assertNotEqual ( hash ( f1 ) , hash ( f3 ) ) [EOL] [EOL] [EOL] def test_type_error_on_incomplete_assignment ( ) : [EOL] f = ExpressionFunction ( [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] f ( a = [number] ) [EOL] [EOL] [EOL] def test_type_error_on_excessive_assignment ( ) : [EOL] f = ExpressionFunction ( [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] f ( a = [number] , b = [number] , c = [number] ) [EOL] [EOL] [EOL] def test_analyse_ast_simple_expr_no_variable ( ) : [EOL] has_return , exp_vars = _analyse_ast ( [string] ) [EOL] assert not has_return [EOL] assert exp_vars == set ( ) [EOL] [EOL] [EOL] def test_analyse_ast_simple_expr_one_variable ( ) : [EOL] has_return , exp_vars = _analyse_ast ( [string] ) [EOL] assert not has_return [EOL] assert exp_vars == { [string] } [EOL] [EOL] [EOL] def test_analyse_ast_simple_expr_two_variable ( ) : [EOL] has_return , exp_vars = _analyse_ast ( [string] ) [EOL] assert not has_return [EOL] assert exp_vars == { [string] , [string] } [EOL] [EOL] [EOL] def test_analyse_ast_simple_if_expr ( ) : [EOL] has_return , exp_vars = _analyse_ast ( [string] ) [EOL] assert not has_return [EOL] assert exp_vars == { [string] , [string] } [EOL] [EOL] [EOL] def test_analyse_ast_func_no_variable ( ) : [EOL] has_return , exp_vars = _analyse_ast ( [string] ) [EOL] assert has_return [EOL] assert exp_vars == set ( ) [EOL] [EOL] [EOL] def test_analyse_ast_func_one_variable ( ) : [EOL] has_return , exp_vars = _analyse_ast ( [string] ) [EOL] assert has_return [EOL] assert exp_vars == { [string] } [EOL] [EOL] [EOL] def test_analyse_ast_func_two_variable ( ) : [EOL] has_return , exp_vars = _analyse_ast ( [string] ) [EOL] assert has_return [EOL] assert exp_vars == { [string] , [string] } [EOL] [EOL] [EOL] def test_multiline_expression_starting_with_newline ( ) : [EOL] exp = ExpressionFunction ( [string] ) [EOL] [EOL] assert exp ( ) == [number] [EOL] [EOL] [EOL] def test_multiline_expression_no_newline_at_start ( ) : [EOL] exp = ExpressionFunction ( [string] ) [EOL] [EOL] assert exp ( ) == [number] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] exp ( a = [number] , b = [number] , c = [number] ) [EOL] with pytest . raises ( TypeError ) : [EOL] exp ( a = [number] ) [EOL] with pytest . raises ( TypeError ) : [EOL] exp ( [number] ) [EOL] [EOL] [EOL] def test_multiline_expression_one_var ( ) : [EOL] exp = ExpressionFunction ( [string] ) [EOL] [EOL] assert exp ( b = [number] ) == [number] [EOL] [EOL] with pytest . raises ( TypeError ) as exception : [EOL] exp ( ) [EOL] assert [string] in str ( exception . value ) [EOL] [EOL] with pytest . raises ( TypeError ) as exception : [EOL] exp ( [number] ) [EOL] assert [string] in str ( exception . value ) [EOL] [EOL] [EOL] def test_multiline_expression_with_import ( ) : [EOL] exp = ExpressionFunction ( [string] ) [EOL] [EOL] import math [EOL] assert exp ( a = [number] ) == math . pi + [number] [EOL] [EOL] with pytest . raises ( TypeError ) as exception : [EOL] exp ( [number] ) [EOL] [EOL] [EOL] def test_multiline_expression_with_fromimport ( ) : [EOL] exp = ExpressionFunction ( [string] ) [EOL] [EOL] import math [EOL] assert exp ( a = [number] ) == math . pi + [number] [EOL] [EOL] with pytest . raises ( TypeError ) as exception : [EOL] exp ( [number] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 $typing.Any$ 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 $typing.Any$ 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 $pydcop.utils.expressionfunction.ExpressionFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from pydcop . computations_graph . objects import ComputationNode , Link [EOL] from pydcop . utils . simple_repr import from_repr , simple_repr [EOL] [EOL] [EOL] def test_node_creation_minimal ( ) : [EOL] [comment] [EOL] n = ComputationNode ( [string] ) [EOL] assert n . name == [string] [EOL] assert not n . type [EOL] assert not n . links [EOL] assert not n . neighbors [EOL] [EOL] def test_node_creation_with_links ( ) : [EOL] [EOL] n1 = ComputationNode ( [string] , links = [ Link ( [ [string] ] ) ] ) [EOL] [EOL] assert [string] in n1 . neighbors [EOL] assert list ( n1 . links ) [ [number] ] . has_node ( [string] ) [EOL] [EOL] def test_node_creation_with_hyperlinks ( ) : [EOL] [EOL] n1 = ComputationNode ( [string] , links = [ Link ( [ [string] , [string] ] ) , Link ( [ [string] ] ) ] ) [EOL] [EOL] assert [string] in n1 . neighbors [EOL] assert [string] in n1 . neighbors [EOL] assert [string] in n1 . neighbors [EOL] [EOL] def test_node_creation_with_one_neighbor ( ) : [EOL] [EOL] n1 = ComputationNode ( [string] , neighbors = [ [string] ] ) [EOL] [EOL] assert [string] in n1 . neighbors [EOL] assert len ( n1 . links ) == [number] [EOL] assert list ( n1 . links ) [ [number] ] . has_node ( [string] ) [EOL] [EOL] def test_node_creation_with_several_neighbors ( ) : [EOL] [EOL] n1 = ComputationNode ( [string] , neighbors = [ [string] , [string] , [string] ] ) [EOL] [EOL] assert [string] in n1 . neighbors [EOL] assert [string] in n1 . neighbors [EOL] assert [string] in n1 . neighbors [EOL] assert len ( n1 . links ) == [number] [EOL] [EOL] [EOL] def test_node_creation_raises_when_giving_links_neighbors ( ) : [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] n1 = ComputationNode ( [string] , links = [ Link ( [ [string] ] ) ] , neighbors = [ [string] ] ) [EOL] [EOL] [EOL] def test_node_simplerepr ( ) : [EOL] n1 = ComputationNode ( [string] , neighbors = [ [string] , [string] , [string] ] ) [EOL] [EOL] r1 = simple_repr ( n1 ) [EOL] [EOL] obtained = from_repr ( r1 ) [EOL] [EOL] assert n1 == obtained [EOL] assert [string] in n1 . neighbors [EOL] assert [string] in n1 . neighbors [EOL] assert [string] in n1 . neighbors [EOL] assert len ( n1 . links ) == [number]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from . version import __version__ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any , Dict , Tuple [EOL] import typing [EOL] import _importlib_modulespec [EOL] import importlib [EOL] import types [EOL] from numbers import Number [EOL] from typing import Callable [EOL] [EOL] from pydcop . utils . various import func_args [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class SimpleReprException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class SimpleRepr ( object ) : [EOL] [docstring] [EOL] def _simple_repr ( self ) : [EOL] [EOL] [comment] [EOL] r = { [string] : self . __module__ , [string] : self . __class__ . __qualname__ } [EOL] [EOL] args = [ a for a in func_args ( self . __init__ ) if a != [string] ] [EOL] for arg in args : [EOL] try : [EOL] val = getattr ( self , [string] + arg ) [EOL] r [ arg ] = simple_repr ( val ) [EOL] except AttributeError : [EOL] if hasattr ( self , [string] ) and arg in self . _repr_mapping : [EOL] try : [EOL] r [ arg ] = self . __getattribute__ ( self . _repr_mapping [ arg ] ) [EOL] except AttributeError : [EOL] SimpleReprException ( [string] [string] . format ( self , self . _repr_mapping [ arg ] ) ) [EOL] [EOL] else : [EOL] raise SimpleReprException ( [string] [string] . format ( self , arg ) ) [EOL] return r [EOL] [EOL] @ classmethod def _from_repr ( cls , r ) : [EOL] [docstring] [EOL] args = { k : from_repr ( v ) for k , v in r . items ( ) if k not in [ [string] , [string] ] } [EOL] return cls ( ** args ) [EOL] [EOL] [EOL] def from_repr ( r ) : [EOL] [docstring] [EOL] if isinstance ( r , dict ) : [EOL] [comment] [EOL] [comment] [EOL] if [string] in r and [string] in r : [EOL] [EOL] [EOL] if r [ [string] ] == [string] : [EOL] [comment] [EOL] values = sorted ( [ ( int ( i ) , v ) for i , v in r . items ( ) if i not in [ [string] , [string] ] ] ) [EOL] return tuple ( [ from_repr ( v ) for _ , v in values ] ) [EOL] module = importlib . import_module ( r [ [string] ] ) [EOL] qual = getattr ( module , r [ [string] ] ) [EOL] [EOL] if type ( qual ) == types . FunctionType : [EOL] args = { k : from_repr ( v ) for k , v in r . items ( ) if k not in [ [string] , [string] , [string] ] } [EOL] M = qual ( r [ [string] ] , args ) [EOL] return M ( ** args ) [EOL] [EOL] if hasattr ( qual , [string] ) : [EOL] [comment] [EOL] args = { k : from_repr ( v ) for k , v in r . items ( ) if k not in [ [string] , [string] ] } [EOL] return qual . __new__ ( qual , ** args ) [EOL] [EOL] return qual . _from_repr ( r ) [EOL] else : [EOL] return { k : from_repr ( v ) for k , v in r . items ( ) } [EOL] elif isinstance ( r , list ) : [EOL] return [ from_repr ( v ) for v in r ] [EOL] elif isinstance ( r , str ) or isinstance ( r , Number ) : [EOL] return r [EOL] [EOL] [EOL] def simple_repr ( o ) : [EOL] [docstring] [EOL] if hasattr ( o , [string] ) : [EOL] return o . _simple_repr ( ) [EOL] elif isinstance ( o , tuple ) : [EOL] if hasattr ( o , [string] ) : [EOL] [comment] [EOL] r = o . _asdict ( ) [EOL] r [ [string] ] = o . __module__ [EOL] r [ [string] ] = o . __class__ . __qualname__ [EOL] else : [EOL] r = { i : simple_repr ( v ) for i , v in enumerate ( o ) } [EOL] r [ [string] ] = o . __class__ . __module__ [EOL] r [ [string] ] = o . __class__ . __qualname__ [EOL] return r [EOL] elif isinstance ( o , str ) or isinstance ( o , Number ) or isinstance ( o , bool ) : [EOL] return o [EOL] elif isinstance ( o , list ) or isinstance ( o , tuple ) or isinstance ( o , set ) or isinstance ( o , frozenset ) : [EOL] return [ simple_repr ( i ) for i in o ] [EOL] elif isinstance ( o , dict ) : [EOL] return { k : simple_repr ( o [ k ] ) for k in o } [EOL] elif o is None : [EOL] return None [EOL] else : [EOL] raise SimpleReprException ( [string] [string] . format ( o , type ( o ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from typing import Iterable [EOL] [EOL] def func_args ( f ) : [EOL] [docstring] [EOL] try : [EOL] return list ( f . __code__ . co_varnames [ : f . __code__ . co_argcount ] ) [EOL] except AttributeError : [EOL] [EOL] if hasattr ( f , [string] ) : [EOL] return f . variable_names [EOL] [EOL] original_args = func_args ( f . func ) [EOL] [EOL] var_list = [ a for a in original_args if a not in f . keywords ] [EOL] return var_list [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Set , Dict , Any , List , Generator [EOL] import typing [EOL] import pydcop [EOL] import random [EOL] import networkx as nx [EOL] [EOL] [EOL] class Node ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , content , node_type = None ) : [EOL] [docstring] [EOL] self . content = content [EOL] self . type = node_type [EOL] self . neighbors = [ ] [EOL] [EOL] @ property def name ( self ) : [EOL] return self . content . name [EOL] [EOL] def add_neighbors ( self , node , directed = False ) : [EOL] if node . type is not None and self . type == node . type : [EOL] raise ValueError ( [string] [string] . format ( node , self ) ) [EOL] self . neighbors . append ( node ) [EOL] if not directed : [EOL] node . add_neighbors ( self , directed = True ) [EOL] [EOL] [EOL] def as_bipartite_graph ( variables , relations ) : [EOL] nodes = { } [EOL] [EOL] for v in variables : [EOL] n = Node ( v , [string] ) [EOL] nodes [ v . name ] = n [EOL] [EOL] for r in relations : [EOL] n = Node ( r , [string] ) [EOL] nodes [ r . name ] = n [EOL] for v in r . dimensions : [EOL] current_var_neighbors = [ n . content for n in nodes [ v . name ] . neighbors ] [EOL] if v not in current_var_neighbors : [EOL] n . add_neighbors ( nodes [ v . name ] ) [EOL] [EOL] return nodes . values ( ) [EOL] [EOL] [EOL] def calc_diameter ( nodes ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] root = random . choice ( nodes ) [EOL] node , distance = find_furthest_node ( root , nodes ) [EOL] [EOL] _ , distance = find_furthest_node ( node , nodes ) [EOL] [EOL] return distance [EOL] [EOL] [EOL] def find_furthest_node ( root_node , nodes ) : [EOL] [EOL] [comment] [EOL] queue = [ root_node ] [EOL] distances = { root_node . name : [number] } [EOL] max_distance = [number] [EOL] furthest_node = root_node [EOL] while len ( queue ) > [number] : [EOL] current = queue . pop ( ) [EOL] [EOL] for neighbor in current . neighbors : [EOL] d = distances . get ( neighbor . name , - [number] ) [EOL] if d == - [number] : [EOL] d = distances [ current . name ] + [number] [EOL] if d > max_distance : [EOL] max_distance = d [EOL] furthest_node = neighbor [EOL] distances [ neighbor . name ] = d [EOL] queue . append ( neighbor ) [EOL] [EOL] return furthest_node , max_distance [EOL] [EOL] [EOL] def as_networkx_graph ( variables , relations ) : [EOL] [docstring] [EOL] graph = nx . Graph ( ) [EOL] [EOL] [comment] [EOL] graph . add_nodes_from ( [ v . name for v in variables ] ) [EOL] [EOL] for r in relations : [EOL] for p in all_pairs ( [ e . name for e in r . dimensions ] ) : [EOL] graph . add_edge ( * p ) [EOL] return graph [EOL] [EOL] [EOL] def as_networkx_bipartite_graph ( variables , relations ) : [EOL] [docstring] [EOL] graph = nx . Graph ( ) [EOL] [EOL] [comment] [EOL] graph . add_nodes_from ( [ v . name for v in variables ] , bipartite = [number] ) [EOL] graph . add_nodes_from ( [ r . name for r in relations ] , bipartite = [number] ) [EOL] [EOL] for r in relations : [EOL] for e in r . dimensions : [EOL] graph . add_edge ( r . name , e . name ) [EOL] return graph [EOL] [EOL] [EOL] def display_graph ( variables , relations ) : [EOL] [docstring] [EOL] graph = as_networkx_graph ( variables , relations ) [EOL] [EOL] [comment] [EOL] try : [EOL] import matplotlib . pyplot as plt [EOL] [EOL] nx . draw_networkx ( graph , with_labels = True ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] plt . show ( ) [EOL] except ImportError : [EOL] print ( [string] ) [EOL] [EOL] [EOL] def display_bipartite_graph ( variables , relations ) : [EOL] [docstring] [EOL] graph = as_networkx_bipartite_graph ( variables , relations ) [EOL] [EOL] [comment] [EOL] try : [EOL] import matplotlib . pyplot as plt [EOL] [EOL] pos = nx . drawing . spring_layout ( graph ) [EOL] variables = set ( n for n , d in graph . nodes ( data = True ) if d [ [string] ] == [number] ) [EOL] factors = set ( graph ) - variables [EOL] nx . draw_networkx_nodes ( graph , pos = pos , with_labels = True , nodelist = variables , node_shape = [string] , node_color = [string] , label = [string] , alpha = [number] , ) [EOL] nx . draw_networkx_nodes ( graph , pos = pos , with_labels = True , nodelist = factors , node_shape = [string] , node_color = [string] , label = [string] , alpha = [number] , ) [EOL] nx . draw_networkx_labels ( graph , pos = pos ) [EOL] nx . draw_networkx_edges ( graph , pos = pos ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] plt . show ( ) [EOL] except ImportError : [EOL] print ( [string] ) [EOL] [EOL] [EOL] def cycles_count ( variables , relations ) : [EOL] [EOL] g = as_networkx_graph ( variables , relations ) [EOL] cycles = nx . cycle_basis ( g ) [EOL] return len ( cycles ) [EOL] [EOL] [EOL] def graph_diameter ( variables , relations ) : [EOL] [docstring] [EOL] diams = [ ] [EOL] g = as_networkx_graph ( variables , relations ) [EOL] components = ( g . subgraph ( c ) . copy ( ) for c in nx . connected_components ( g ) ) [EOL] for c in components : [EOL] diams . append ( nx . diameter ( c ) ) [EOL] [EOL] return diams [EOL] [EOL] [EOL] def all_pairs ( elements ) : [EOL] [docstring] [EOL] if len ( elements ) < [number] : [EOL] return [ ] [EOL] elif len ( elements ) == [number] : [EOL] return [ ( elements [ [number] ] , elements [ [number] ] ) ] [EOL] else : [EOL] new_pairs = [ ] [EOL] for elt in elements [ [number] : ] : [EOL] new_pairs . append ( ( elements [ [number] ] , elt ) ) [EOL] return all_pairs ( elements [ [number] : ] ) + new_pairs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import _importlib_modulespec [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] from importlib import import_module [EOL] import sys [EOL] import yaml [EOL] [EOL] from pydcop . dcop . yamldcop import load_dcop_from_file [EOL] from pydcop . utils . graphs import ( as_networkx_graph , display_graph , display_bipartite_graph , ) [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def set_parser ( subparsers ) : [EOL] [EOL] parser = subparsers . add_parser ( [string] , help = [string] [string] , ) [EOL] parser . set_defaults ( func = run_cmd ) [EOL] [EOL] parser . add_argument ( [string] , type = str , nargs = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] [string] , ) [EOL] parser . add_argument ( [string] , [string] , choices = [ [string] , [string] , [string] ] , help = [string] , ) [EOL] [EOL] [EOL] def run_cmd ( args ) : [EOL] logger . debug ( [string] . format ( args ) ) [EOL] [EOL] dcop_yaml_file = args . dcop_file [EOL] logger . info ( [string] . format ( dcop_yaml_file ) ) [EOL] dcop = load_dcop_from_file ( dcop_yaml_file ) [EOL] [EOL] if args . display : [EOL] if args . graph == [string] : [EOL] display_bipartite_graph ( dcop . variables . values ( ) , dcop . constraints . values ( ) ) [EOL] else : [EOL] display_graph ( dcop . variables . values ( ) , dcop . constraints . values ( ) ) [EOL] [EOL] try : [EOL] graph_module = import_module ( [string] . format ( args . graph ) ) [EOL] logger . info ( [string] . format ( dcop . name ) ) [EOL] graph_stats ( dcop , graph_module ) [EOL] except ImportError : [EOL] _error ( [string] . format ( args . graph ) ) [EOL] [EOL] [EOL] def graph_stats ( dcop , graph_module ) : [EOL] [EOL] [comment] [EOL] logger . info ( [string] . format ( dcop . name ) ) [EOL] cg = graph_module . build_computation_graph ( dcop ) [EOL] [EOL] edges_count = len ( list ( cg . links ) ) [EOL] nodes_count = len ( list ( cg . nodes ) ) [EOL] density = cg . density ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] result = { [string] : [string] , [string] : len ( dcop . variables ) , [string] : len ( dcop . constraints ) , [string] : nodes_count , [string] : edges_count , [string] : density , } [EOL] print ( yaml . dump ( result , default_flow_style = False ) ) [EOL] [EOL] [EOL] def _error ( msg ) : [EOL] print ( [string] . format ( msg ) ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Type , Set , Any , List , Optional , Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import Iterable , Optional , Tuple , List , Set [EOL] [EOL] Node = str [EOL] Path = Tuple [ Node , ... ] [EOL] [EOL] [EOL] def head ( path ) : [EOL] [docstring] [EOL] try : [EOL] return path [ [number] ] [EOL] except IndexError : [EOL] return None [EOL] [EOL] [EOL] def last ( path ) : [EOL] [docstring] [EOL] try : [EOL] return path [ - [number] ] [EOL] except IndexError : [EOL] return None [EOL] [EOL] [EOL] def before_last ( path ) : [EOL] [docstring] [EOL] return path [ - [number] ] [EOL] [EOL] [EOL] PathsTable = List [ Tuple [ float , Path ] ] [EOL] [EOL] [EOL] def remove_path ( paths , path ) : [EOL] [docstring] [EOL] to_remove = [ ( c , p ) for c , p in paths if p == path ] [EOL] for item in to_remove : [EOL] paths . remove ( item ) [EOL] return paths [EOL] [EOL] [EOL] def cheapest_path_to ( target , paths ) : [EOL] [docstring] [EOL] for cost , p in paths : [EOL] if p [ - [number] ] == target : [EOL] return cost , p [EOL] return float ( [string] ) , ( ) [EOL] [EOL] [EOL] def affordable_path_from ( prefix , max_path_cost , paths ) : [EOL] [comment] [EOL] plen = len ( prefix ) [EOL] for cost , path in paths : [EOL] if path [ : plen ] == prefix and ( cost - max_path_cost ) <= [number] : [EOL] yield path [ plen : ] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def filter_missing_agents_paths ( paths , removed_agents ) : [EOL] [docstring] [EOL] filtered = [ ] [EOL] for cost , path in paths : [EOL] missing = False [EOL] for elt in path : [EOL] if elt in removed_agents : [EOL] missing = True [EOL] break [EOL] if missing : [EOL] continue [EOL] filtered . append ( ( cost , path ) ) [EOL] return filtered [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PathsTable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PathsTable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Type [EOL] import typing [EOL] import builtins [EOL] import pydcop [EOL] from typing import List [EOL] [EOL] from pydcop . utils . simple_repr import SimpleRepr [EOL] [EOL] [EOL] class EventAction ( SimpleRepr ) : [EOL] [EOL] def __init__ ( self , type , ** kwargs ) : [EOL] self . _type = type [EOL] self . _args = kwargs [EOL] [EOL] @ property def type ( self ) : [EOL] return self . _type [EOL] [EOL] @ property def args ( self ) : [EOL] return self . _args [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . type , self . _args ) [EOL] [EOL] [EOL] class DcopEvent ( SimpleRepr ) : [EOL] [docstring] [EOL] [EOL] type = None [EOL] [EOL] def __init__ ( self , id , delay = None , actions = None ) : [EOL] [docstring] [EOL] self . _actions = actions [EOL] self . _delay = delay [EOL] self . _id = id [EOL] [EOL] @ property def id ( self ) : [EOL] return self . _id [EOL] [EOL] @ property def delay ( self ) : [EOL] return self . _delay [EOL] [EOL] @ property def actions ( self ) : [EOL] return self . _actions [EOL] [EOL] @ property def is_delay ( self ) : [EOL] return self . delay is not None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . id , self . actions ) [EOL] [EOL] [EOL] class Scenario ( SimpleRepr ) : [EOL] [docstring] [EOL] def __init__ ( self , events = None ) : [EOL] [EOL] self . _events = events if events else [ ] [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . _events ) [EOL] [EOL] @ property def events ( self ) : [EOL] return list ( self . _events )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pydcop.dcop.scenario.EventAction]$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[DcopEvent]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[DcopEvent]$ 0 $typing.List[DcopEvent]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0