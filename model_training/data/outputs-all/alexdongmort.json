[comment] [EOL] [EOL] import os [EOL] [EOL] from fabric . api import local [EOL] [EOL] [EOL] CURRENT_PATH = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] def coverage ( ) : [EOL] local ( [string] ) [EOL] [EOL] def lint ( ) : [EOL] local ( [string] ) [EOL] local ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict , Tuple , List [EOL] import requests [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import logging [EOL] from typing import List , Dict , Tuple [EOL] [EOL] import requests [EOL] [EOL] from mort . list_utils import every [EOL] from mort . local_conf import BROWSER_STACK_ACCESS_KEY , TEST_AGAINST_SERVER [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class InvalidRequestError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def submit_request ( path , targets ) : [EOL] [docstring] [EOL] [comment] [EOL] request_payload = { [string] : TEST_AGAINST_SERVER + path , [string] : targets } [EOL] headers = { [string] : [string] , [string] : [string] } [EOL] logger . debug ( [string] , request_payload ) [EOL] r = requests . post ( [string] , json = request_payload , headers = headers , auth = BROWSER_STACK_ACCESS_KEY ) [EOL] if r . status_code != [number] : [EOL] logger . error ( [string] , r . status_code ) [EOL] if r . status_code == [number] and [string] in r . json ( ) : [EOL] job_id = r . json ( ) [ [string] ] [EOL] logger . info ( [string] , job_id ) [EOL] else : [EOL] logger . error ( [string] , r . content ) [EOL] raise InvalidRequestError ( [string] , r . status_code ) [EOL] [EOL] [comment] [EOL] job_id = r . json ( ) [ [string] ] [EOL] logger . info ( [string] , job_id ) [EOL] return job_id [EOL] [EOL] [EOL] def is_done ( payload ) : [EOL] return [string] == payload [ [string] ] [EOL] [EOL] [EOL] def get_job_state ( job_id ) : [EOL] [docstring] [EOL] r = requests . get ( [string] + job_id + [string] , auth = BROWSER_STACK_ACCESS_KEY ) [EOL] logger . debug ( [string] , r . status_code ) [EOL] logger . debug ( [string] , r . content ) [EOL] [EOL] payload = r . json ( ) [EOL] return is_done ( payload ) or every ( is_done , payload [ [string] ] ) , payload [EOL] [EOL] [EOL] def download_latest_target_list ( to_json_file ) : [EOL] [docstring] [EOL] logger . debug ( [string] , to_json_file ) [EOL] r = requests . get ( [string] , auth = BROWSER_STACK_ACCESS_KEY ) [EOL] with open ( to_json_file , [string] ) as fp : [EOL] fp . write ( r . content ) [EOL] return len ( r . json ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.bool,typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import os [EOL] import subprocess [EOL] [EOL] from mort . local_conf import SOURCE_CODE_PATH [EOL] [EOL] [EOL] def get_git_hash ( path = SOURCE_CODE_PATH ) : [EOL] return subprocess . check_output ( [ [string] , [string] , [string] , [string] ] , cwd = path ) . strip ( ) . decode ( [string] ) [EOL] [EOL] [EOL] def create_dir_if_not_exists ( path ) : [EOL] if os . path . exists ( path ) : [EOL] return False [EOL] [EOL] os . makedirs ( path ) [EOL] return True [EOL] [EOL] [EOL] def get_absolute_path ( relative_path ) : [EOL] [docstring] [EOL] cwd = os . getcwd ( ) [EOL] if cwd . endswith ( [string] ) : [comment] [EOL] cwd = cwd . replace ( [string] , [string] ) [EOL] return os . path . join ( cwd , relative_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Callable , List , Dict , Any , Optional [EOL] import typing [EOL] import builtins [EOL] from typing import List , Callable , Any , Optional [EOL] [EOL] [EOL] def iterable ( l ) : [EOL] return hasattr ( l , [string] ) [EOL] [EOL] [EOL] def apply ( func , args = None , kwargs = None ) : [EOL] [docstring] [EOL] if args is None : [EOL] args = ( ) [EOL] if kwargs is None : [EOL] kwargs = { } [EOL] if not isinstance ( args , tuple ) : [EOL] args = ( args , ) [EOL] [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] [EOL] def some ( predicate , l ) : [EOL] for el in l : [EOL] if apply ( predicate , el ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def every ( predicate , l ) : [EOL] if not l : [EOL] return False [EOL] [EOL] for el in l : [EOL] if not apply ( predicate , el ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def first ( predicate , l ) : [EOL] for el in l : [EOL] if apply ( predicate , el ) : [EOL] return el [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] import cv2 [EOL] import numpy [EOL] from skimage . measure import compare_ssim [EOL] from skimage . measure import structural_similarity as ssim [EOL] [EOL] from mort . local_conf import IMAGE_DIFF_BOX_COLOR , IMAGE_DIFF_BOX_STROKE_WIDTH [EOL] [EOL] [EOL] def load_image ( img_file ) : [EOL] [docstring] [EOL] img = cv2 . imread ( img_file , [number] ) [comment] [EOL] return img [EOL] [EOL] [EOL] def get_similarity_index ( image_file , reference_file ) : [EOL] [docstring] [EOL] reference = load_image ( reference_file ) [EOL] image = load_image ( image_file ) [EOL] return ssim ( image , reference ) [EOL] [EOL] [EOL] def generate_annotated_diff_image ( image_file , reference_file , as_file ) : [EOL] [docstring] [EOL] reference = load_image ( reference_file ) [EOL] image = load_image ( image_file ) [EOL] ( _ , diff_image ) = compare_ssim ( image , reference , full = True ) [comment] [EOL] [EOL] [comment] [EOL] diff_image = ( diff_image * [number] ) . astype ( [string] ) [EOL] [EOL] [comment] [EOL] threshold_image = cv2 . threshold ( diff_image , [number] , [number] , cv2 . THRESH_BINARY_INV | cv2 . THRESH_OTSU ) [ [number] ] [EOL] region_contours = cv2 . findContours ( threshold_image , cv2 . RETR_EXTERNAL , cv2 . CHAIN_APPROX_SIMPLE ) [ [number] ] [EOL] [EOL] [comment] [EOL] region_boxes = [ cv2 . boundingRect ( contour ) for contour in region_contours ] [EOL] [EOL] [comment] [EOL] color_image = cv2 . imread ( image_file ) [EOL] for ( x , y , w , h ) in region_boxes : [EOL] cv2 . rectangle ( color_image , ( x , y ) , ( x + w , y + h ) , IMAGE_DIFF_BOX_COLOR , IMAGE_DIFF_BOX_STROKE_WIDTH ) [EOL] cv2 . imwrite ( as_file , color_image ) [EOL] return len ( region_boxes ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Tuple , List [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import time [EOL] from typing import List , Dict [EOL] [EOL] from mort . download_utils import download_urls [EOL] from mort . driver import submit_request , get_job_state , is_done [EOL] from mort . imgdiff import get_similarity_index [EOL] from mort . repo_manager import extract_urls_from_job_details , local_dir_for_screen_shots , save_capture_result_to , load_screenshots [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def capture ( paths , targets , git_hash ) : [EOL] [docstring] [EOL] logger . debug ( [string] ) [EOL] logger . debug ( [string] , paths ) [EOL] logger . debug ( [string] , targets ) [EOL] [EOL] results = { } [EOL] for path in paths : [EOL] logger . debug ( [string] , path ) [EOL] job_id = submit_request ( path , targets ) [EOL] total_seconds_in_waiting = [number] [EOL] while True : [EOL] ( job_is_completed , payload ) = get_job_state ( job_id ) [EOL] if job_is_completed : [EOL] logger . info ( [string] , job_id ) [EOL] break [EOL] [EOL] done_count = len ( list ( filter ( is_done , payload [ [string] ] ) ) ) [EOL] total_seconds_in_waiting += [number] [EOL] logger . debug ( [string] , total_seconds_in_waiting , done_count , len ( targets ) ) [EOL] time . sleep ( [number] ) [EOL] [EOL] results [ path ] = payload [comment] [EOL] download_urls ( extract_urls_from_job_details ( payload ) , local_dir_for_screen_shots ( job_id , git_hash ) ) [EOL] [EOL] logger . info ( [string] ) [EOL] save_capture_result_to ( results , git_hash ) [EOL] [EOL] [EOL] def compare ( paths , targets , curr_git_hash , ref_git_hash ) : [EOL] screenshot_pairs = load_screenshots ( paths , targets , curr_git_hash , ref_git_hash ) [EOL] for ( path , target , curr_image_path , ref_image_path ) in screenshot_pairs : [EOL] diff_index = get_similarity_index ( curr_image_path , ref_image_path ) [EOL] logger . debug ( [string] , path , target , diff_index ) [EOL] [EOL] [EOL] if __name__ == [string] : [comment] [EOL] from mort . local_conf import PATHS , TARGETS [EOL] [EOL] capture ( PATHS , TARGETS , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Dict , Any , Optional [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] import json [EOL] import logging [EOL] import os [EOL] from functools import partial [EOL] from typing import List , Dict , Optional , Tuple [EOL] [EOL] from mort . driver import is_done [EOL] from mort . file_utils import create_dir_if_not_exists [EOL] from mort . list_utils import first [EOL] from mort . local_conf import SCREEN_SHOT_SAVED_TO [EOL] from mort . matcher import target_matches [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def extract_urls_from_job_details ( job_detail ) : [EOL] [docstring] [EOL] return [ screenshot [ [string] ] for screenshot in job_detail [ [string] ] if is_done ( screenshot ) ] [EOL] [EOL] [EOL] def local_dir_for_screen_shots ( job_id , git_hash ) : [EOL] [docstring] [EOL] return os . path . join ( SCREEN_SHOT_SAVED_TO , git_hash , job_id ) [EOL] [EOL] [EOL] def save_capture_result_to ( capture_result , git_hash ) : [EOL] [docstring] [EOL] root_path = os . path . join ( SCREEN_SHOT_SAVED_TO , git_hash ) [EOL] create_dir_if_not_exists ( root_path ) [EOL] [EOL] manifest_file_path = os . path . join ( root_path , [string] ) [EOL] with open ( manifest_file_path , [string] ) as fp : [EOL] fp . write ( json . dumps ( capture_result , indent = [number] , sort_keys = True ) ) [EOL] return manifest_file_path [EOL] [EOL] [EOL] def get_screenshot_path ( git_hash , screenshot ) : [EOL] [docstring] [EOL] return os . path . join ( SCREEN_SHOT_SAVED_TO , git_hash , [string] . join ( screenshot [ [string] ] . split ( [string] ) [ - [number] : ] ) ) [EOL] [EOL] [EOL] def load_screenshots ( paths , targets , curr_git_hash , ref_git_hash ) : [EOL] [docstring] [EOL] results = [ ] [EOL] for path in paths : [EOL] for target in targets : [EOL] curr_screenshot = get_screenshot ( curr_git_hash , path , target ) [EOL] ref_screenshot = get_screenshot ( ref_git_hash , path , target ) [EOL] if curr_screenshot and ref_screenshot : [EOL] curr_path = get_screenshot_path ( curr_git_hash , curr_screenshot ) [EOL] ref_path = get_screenshot_path ( ref_git_hash , ref_screenshot ) [EOL] results . append ( ( path , target , curr_path , ref_path ) ) [EOL] [EOL] return results [EOL] [EOL] [EOL] def get_screenshot ( git_hash , path , target_spec ) : [EOL] [docstring] [EOL] manifest_file_path = os . path . join ( SCREEN_SHOT_SAVED_TO , git_hash , [string] ) [EOL] manifest = json . loads ( open ( manifest_file_path , [string] ) . read ( ) ) [EOL] return first ( partial ( target_matches , target_spec ) , manifest [ path ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] import builtins [EOL] import json [EOL] from typing import Dict , List [EOL] [EOL] from mort . file_utils import get_absolute_path [EOL] from mort . local_conf import TARGET_LIST_FILE_PATH [EOL] [EOL] [EOL] def target_matches ( pattern , target ) : [EOL] [docstring] [EOL] if not set ( pattern . keys ( ) ) . issubset ( set ( target . keys ( ) ) ) : [EOL] return False [EOL] for ( key , substr ) in pattern . items ( ) : [EOL] if not target [ key ] or substr . lower ( ) not in target [ key ] . lower ( ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def get_targets ( pattern ) : [EOL] [docstring] [EOL] return [ target for target in json . loads ( open ( get_absolute_path ( TARGET_LIST_FILE_PATH ) ) . read ( ) ) if target_matches ( pattern , target ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import os [EOL] from functools import partial [EOL] from multiprocessing import Pool [EOL] from typing import List [EOL] [EOL] import httplib2 [EOL] [EOL] from mort . file_utils import create_dir_if_not_exists [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def download_urls ( urls , to_dir , pool_size = [number] ) : [comment] [EOL] [docstring] [EOL] logger . debug ( [string] , to_dir , urls ) [EOL] create_dir_if_not_exists ( to_dir ) [EOL] with Pool ( pool_size ) as pool : [EOL] pool . map ( partial ( download , to_dir = to_dir ) , urls ) [EOL] return len ( urls ) [EOL] [EOL] [EOL] def download ( url , to_dir ) : [EOL] [docstring] [EOL] to_file = os . path . join ( to_dir , get_filename_from_url ( url ) ) [EOL] logger . debug ( [string] , url , to_file ) [EOL] [EOL] h = httplib2 . Http ( [string] ) [EOL] ( _ , content ) = h . request ( url , [string] ) [EOL] with open ( to_file , [string] ) as f : [EOL] f . write ( content ) [EOL] return to_file [EOL] [EOL] [EOL] def get_filename_from_url ( url ) : [EOL] return url . split ( [string] ) [ - [number] ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import json [EOL] [EOL] import click [EOL] [EOL] from mort import controller [EOL] from mort . driver import download_latest_target_list [EOL] from mort . file_utils import get_git_hash [EOL] from mort . local_conf import TARGETS , PATHS , TARGET_LIST_FILE_PATH [EOL] [EOL] [EOL] @ click . group ( ) @ click . option ( [string] , default = json . dumps ( TARGETS ) ) @ click . option ( [string] , default = json . dumps ( PATHS ) ) @ click . option ( [string] , default = get_git_hash ( ) ) @ click . pass_context def cli ( ctx , targets , paths , git_hash ) : [EOL] ctx . obj = { [string] : json . loads ( targets ) , [string] : json . loads ( paths ) , [string] : git_hash } [EOL] [EOL] [EOL] @ cli . command ( ) @ click . pass_obj def capture ( ctx ) : [EOL] controller . capture ( ctx . obj [ [string] ] , ctx . obj [ [string] ] , ctx . obj [ [string] ] ) [EOL] [EOL] [EOL] @ cli . command ( ) @ click . pass_obj @ click . argument ( [string] ) def compare ( ctx , ref_git_hash ) : [EOL] controller . compare ( ctx . obj [ [string] ] , ctx . obj [ [string] ] , ctx . obj [ [string] ] , ref_git_hash ) [EOL] [EOL] [EOL] @ cli . command ( ) @ click . option ( [string] , default = TARGET_LIST_FILE_PATH ) def update ( save_as ) : [EOL] print ( [string] ) [EOL] download_latest_target_list ( save_as ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from mort . matcher import target_matches , get_targets [EOL] [EOL] [EOL] class TestMatcher ( TestCase ) : [EOL] TARGETS = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] [EOL] [EOL] def test_single_match ( self ) : [EOL] self . assertTrue ( target_matches ( { [string] : [string] } , self . TARGETS [ [number] ] ) ) [EOL] self . assertFalse ( target_matches ( { [string] : [string] } , self . TARGETS [ [number] ] ) ) [EOL] self . assertFalse ( target_matches ( { [string] : [string] , [string] : [string] } , self . TARGETS [ [number] ] ) ) [EOL] [EOL] self . assertFalse ( target_matches ( { [string] : [string] } , self . TARGETS [ [number] ] ) ) [EOL] self . assertTrue ( target_matches ( { [string] : [string] } , self . TARGETS [ [number] ] ) ) [EOL] self . assertTrue ( target_matches ( { [string] : [string] , [string] : [string] } , self . TARGETS [ [number] ] ) ) [EOL] self . assertTrue ( target_matches ( { [string] : [string] , [string] : [string] , [string] : [string] } , self . TARGETS [ [number] ] ) ) [EOL] [EOL] def test_match_against_target_list ( self ) : [EOL] self . assertGreaterEqual ( len ( get_targets ( { [string] : [string] } ) ) , [number] ) [EOL] self . assertGreaterEqual ( len ( get_targets ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from unittest import mock , TestCase [EOL] [EOL] from mort . file_utils import get_git_hash , create_dir_if_not_exists [EOL] [EOL] [EOL] class TestFileUtils ( TestCase ) : [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_get_filename_from_url ( self , makedirs , exists ) : [EOL] exists . return_value = True [EOL] create_dir_if_not_exists ( [string] ) [EOL] self . assertEqual ( exists . call_count , [number] ) [EOL] self . assertEqual ( makedirs . call_count , [number] ) [EOL] [EOL] exists . return_value = False [EOL] create_dir_if_not_exists ( [string] ) [EOL] self . assertEqual ( exists . call_count , [number] ) [EOL] self . assertEqual ( makedirs . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_download ( self , check_output ) : [EOL] check_output . return_value = [string] . encode ( [string] ) [EOL] git_hash = get_git_hash ( ) [EOL] self . assertEqual ( git_hash , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] from unittest import mock , TestCase [EOL] [EOL] import pytest [EOL] [EOL] from mort . driver import submit_request , get_job_state , InvalidRequestError , download_latest_target_list [EOL] from tests . data import PATH , TARGETS , JOB_ID , JOB_DETAIL [EOL] [EOL] [EOL] class TestSubmitRequest ( TestCase ) : [EOL] @ mock . patch ( [string] ) def test_submit_request_successful ( self , post ) : [EOL] resp = mock . MagicMock ( ) [EOL] resp . status_code = [number] [EOL] resp . json = lambda : { [string] : JOB_ID } [EOL] post . return_value = resp [EOL] job_id = submit_request ( PATH , TARGETS ) [EOL] self . assertEqual ( job_id , JOB_ID ) [EOL] self . assertEqual ( post . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_submit_duplicated_request_returns_existing_job_id ( self , post ) : [EOL] resp = mock . MagicMock ( ) [EOL] resp . status_code = [number] [EOL] resp . json = lambda : { [string] : JOB_ID } [EOL] post . return_value = resp [EOL] job_id = submit_request ( PATH , TARGETS ) [EOL] self . assertEqual ( job_id , JOB_ID ) [EOL] [EOL] @ mock . patch ( [string] ) def test_submit_invalid_request_throws_out_exception ( self , post ) : [EOL] resp = mock . MagicMock ( ) [EOL] resp . status_code = [number] [EOL] post . return_value = resp [EOL] with pytest . raises ( InvalidRequestError ) : [EOL] submit_request ( PATH , TARGETS ) [EOL] [EOL] [EOL] class TestWaitAndFetch ( TestCase ) : [EOL] @ mock . patch ( [string] ) def test_is_job_done ( self , get ) : [EOL] resp = mock . MagicMock ( ) [EOL] resp . json = lambda : { [string] : [string] , [string] : [ ] } [EOL] get . return_value = resp [EOL] is_job_completed , _ = get_job_state ( JOB_ID ) [EOL] self . assertFalse ( is_job_completed ) [EOL] [EOL] @ mock . patch ( [string] ) def test_return_correct_list_when_ready ( self , get ) : [EOL] resp = mock . MagicMock ( ) [EOL] resp . json = lambda : JOB_DETAIL [EOL] get . return_value = resp [EOL] is_job_completed , response = get_job_state ( JOB_ID ) [EOL] self . assertTrue ( is_job_completed ) [EOL] self . assertIn ( [string] , response ) [EOL] self . assertIn ( [string] , response ) [EOL] [EOL] @ mock . patch ( [string] ) def test_download_latest_target_list ( self , get ) : [EOL] resp = mock . MagicMock ( ) [EOL] resp . content = [string] [EOL] resp . json = lambda : [ { } , { } ] [EOL] get . return_value = resp [EOL] target_count = download_latest_target_list ( [string] ) [EOL] self . assertEqual ( [number] , target_count ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
from unittest import TestCase [EOL] [EOL] from mort . list_utils import some , iterable , apply , every [EOL] [EOL] [EOL] def empty ( ) : [EOL] return True [EOL] [EOL] [EOL] def is_three ( x ) : [EOL] return x == [number] [EOL] [EOL] [EOL] def is_multiple ( x , y ) : [EOL] return x % y == [number] [EOL] [EOL] [EOL] def say_hello ( to = [string] ) : [EOL] return [string] . format ( to ) [EOL] [EOL] [EOL] class TestListUtils ( TestCase ) : [EOL] def test_every ( self ) : [EOL] self . assertFalse ( every ( is_three , [ [number] , [number] , [number] ] ) ) [EOL] self . assertTrue ( every ( is_three , [ [number] , [number] , [number] ] ) ) [EOL] self . assertFalse ( every ( is_three , [ ] ) ) [EOL] [EOL] def test_some ( self ) : [EOL] self . assertTrue ( some ( is_three , [ [number] , [number] , [number] ] ) ) [EOL] self . assertFalse ( some ( is_three , [ [number] , [number] , [number] ] ) ) [EOL] [EOL] self . assertFalse ( some ( is_multiple , [ ( [number] , [number] ) , ( [number] , [number] ) ] ) ) [EOL] self . assertTrue ( some ( is_multiple , [ ( [number] , [number] ) , ( [number] , [number] ) ] ) ) [EOL] [EOL] def test_iterable ( self ) : [EOL] self . assertTrue ( iterable ( [ ] ) ) [EOL] self . assertTrue ( iterable ( { } ) ) [EOL] self . assertFalse ( iterable ( [number] ) ) [EOL] [EOL] def test_apply ( self ) : [EOL] self . assertTrue ( apply ( empty , None ) ) [EOL] self . assertFalse ( apply ( is_three , [number] ) ) [EOL] self . assertTrue ( apply ( is_three , [number] ) ) [EOL] self . assertTrue ( apply ( is_three , [number] , None ) ) [EOL] self . assertTrue ( apply ( is_multiple , ( [number] , [number] ) ) ) [EOL] self . assertFalse ( apply ( is_multiple , ( [number] , [number] ) ) ) [EOL] self . assertEqual ( [string] , apply ( say_hello , None , { [string] : [string] } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import tests [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from mort . imgdiff import get_similarity_index , generate_annotated_diff_image [EOL] from mort . file_utils import get_absolute_path [EOL] [EOL] [EOL] class TestImageDiff ( TestCase ) : [EOL] ORIGIN = get_absolute_path ( [string] ) [EOL] EDITED = get_absolute_path ( [string] ) [EOL] [EOL] def test_get_similarity_index ( self ) : [EOL] index = get_similarity_index ( self . EDITED , self . ORIGIN ) [EOL] self . assertLess ( index , [number] ) [EOL] self . assertGreater ( index , [number] ) [EOL] [EOL] def test_generate_diff_image ( self ) : [EOL] diff_count = generate_annotated_diff_image ( self . EDITED , self . ORIGIN , [string] ) [EOL] self . assertEqual ( diff_count , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_imgdiff.TestImageDiff]$ 0 0 0 0 0 0 $typing.Type[tests.test_imgdiff.TestImageDiff]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0
import builtins [EOL] from typing import Type [EOL] import tests [EOL] import typing [EOL] from unittest import mock , TestCase [EOL] [EOL] from mort . download_utils import get_filename_from_url , download [EOL] [EOL] [EOL] class TestUtils ( TestCase ) : [EOL] URL = [string] + [string] [EOL] [EOL] def test_get_filename_from_url ( self ) : [EOL] self . assertEqual ( [string] , get_filename_from_url ( self . URL ) ) [EOL] [EOL] @ mock . patch ( [string] ) def test_download ( self , request ) : [EOL] request . return_value = ( None , [string] ) [EOL] file_path = download ( self . URL , [string] ) [EOL] self . assertEqual ( [string] , file_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Tuple , List , Dict , Any , Optional [EOL] import typing [EOL] from unittest import mock , TestCase [EOL] [EOL] from mort . file_utils import get_absolute_path [EOL] from tests . data import JOB_ID , JOB_DETAIL , GIT_HASH_CURR , GIT_HASH_REF , PATH , TARGETS [EOL] from mort . repo_manager import extract_urls_from_job_details , get_screenshot_path , get_screenshot , load_screenshots [EOL] [EOL] [EOL] class TestRepoManager ( TestCase ) : [EOL] @ mock . patch ( [string] , return_value = get_absolute_path ( [string] ) ) def test_find_all_screenshots ( self , _ ) : [EOL] self . assertIsNone ( get_screenshot ( GIT_HASH_CURR , PATH , { [string] : [string] , [string] : [string] } ) ) [EOL] screen_shot = get_screenshot ( GIT_HASH_CURR , PATH , { [string] : [string] , [string] : [string] } ) [EOL] self . assertIn ( [string] , screen_shot [ [string] ] ) [EOL] [EOL] def test_extract_urls_from_job_details ( self ) : [EOL] urls = extract_urls_from_job_details ( JOB_DETAIL ) [EOL] self . assertEqual ( len ( urls ) , [number] ) [EOL] self . assertIn ( [string] , urls [ [number] ] ) [EOL] [EOL] def test_get_screenshot_path ( self ) : [EOL] path = get_screenshot_path ( GIT_HASH_CURR , JOB_DETAIL [ [string] ] [ [number] ] ) [EOL] self . assertIn ( JOB_ID , path ) [EOL] self . assertIn ( [string] , path ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_load_screenshots ( self , get_screenshot_path , get_screenshot ) : [EOL] get_screenshot . return_value = None [EOL] no_images = load_screenshots ( [ PATH ] , TARGETS , GIT_HASH_CURR , GIT_HASH_REF ) [EOL] self . assertEqual ( [number] , len ( no_images ) ) [EOL] self . assertEqual ( [number] , get_screenshot_path . call_count ) [EOL] [EOL] get_screenshot . return_value = TARGETS [ [number] ] [EOL] get_screenshot_path . return_value = [string] [EOL] two_images = load_screenshots ( [ PATH ] , TARGETS , GIT_HASH_CURR , GIT_HASH_REF ) [EOL] self . assertEqual ( [number] , len ( two_images ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,...]]$ 0 0 0
[EOL] [EOL] [EOL] import builtins [EOL] from typing import Dict , Union , Optional , List [EOL] import typing [EOL] PATH = [string] [EOL] [EOL] TARGETS = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } ] [EOL] [EOL] PATHS = [ [string] , [string] , [string] ] [EOL] [EOL] JOB_ID = [string] [EOL] [EOL] JOB_DETAIL = { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] } , ] } [EOL] [EOL] GIT_HASH_CURR = [string] [EOL] GIT_HASH_REF = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,typing.List[typing.Dict[builtins.str,typing.Optional[builtins.str]]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from unittest import mock , TestCase [EOL] [EOL] from mort . controller import capture , compare [EOL] from tests . data import PATH , TARGETS , JOB_ID , JOB_DETAIL , GIT_HASH_CURR , GIT_HASH_REF [EOL] [EOL] [EOL] class TestController ( TestCase ) : [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_capture_successful ( self , sleep , get_job_state , submit_request , download_urls ) : [EOL] submit_request . return_value = JOB_ID [EOL] get_job_state . side_effect = [ ( False , JOB_DETAIL ) , ( True , JOB_DETAIL ) ] [EOL] download_urls . return_value = [number] [EOL] capture ( [ PATH ] , [ TARGETS [ [number] ] ] , GIT_HASH_CURR ) [EOL] self . assertEqual ( download_urls . call_count , [number] ) [EOL] self . assertEqual ( submit_request . call_count , [number] ) [EOL] self . assertEqual ( get_job_state . call_count , [number] ) [EOL] self . assertEqual ( sleep . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_compare ( self , get_similarity_index , load_screenshots ) : [EOL] load_screenshots . return_value = [ ( [string] , TARGETS [ [number] ] , [string] , [string] ) ] [EOL] get_similarity_index . return_value = [number] [EOL] compare ( [ PATH ] , TARGETS , GIT_HASH_CURR , GIT_HASH_REF ) [EOL] self . assertEqual ( load_screenshots . call_count , [number] ) [EOL] self . assertEqual ( get_similarity_index . call_count , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0